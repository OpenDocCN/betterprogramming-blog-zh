<html>
<head>
<title>MongoDB: Improve Performance With Indexes and Covered Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB:利用索引和覆盖查询提高性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mongodb-improve-performances-with-indexes-and-covered-queries-8fd1aa7f43e6?source=collection_archive---------4-----------------------#2019-07-17">https://betterprogramming.pub/mongodb-improve-performances-with-indexes-and-covered-queries-8fd1aa7f43e6?source=collection_archive---------4-----------------------#2019-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a8441d61e4abe274cb101de0285e5527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbYLDYXkxoYAMpsgHhstXg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">约翰·施诺布里奇在<a class="ae kf" href="https://unsplash.com/search/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ff1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一个<a class="ae kf" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>集合上建立索引可能看起来是一个琐碎而基本的必要任务，因为我们经常在Oracle或<a class="ae kf" href="https://mariadb.org/" rel="noopener ugc nofollow" target="_blank"> MariaDB </a> / <a class="ae kf" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>等RDBMS上这样做。</p><p id="a7b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">MongoDB索引经常被误解，我经历过许多不正确的索引实现。与其他DBMS一样，MongoDB索引也有自己的规范。</p><p id="679f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我想弄清楚Mongo中的基本索引是如何工作的，以及如何掌握它们，这样就涵盖了你的应用程序查询，增加了执行时间。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/8a0bce8dc78bb5b3dfc50ffdf35e0058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YIL4IDBAA1Vv1drOwSbVWQ.jpeg"/></div></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="924e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">MongoDB索引类型</h1><p id="15a7" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">MongoDB提供了多种索引类型，所以第一步是知道如何为您的应用程序上下文选择正确的索引。</p><h2 id="c0f1" class="mt lr it bd ls mu mv dn lw mw mx dp ma kr my mz me kv na nb mi kz nc nd mm ne bi translated">单字段索引</h2><p id="9b90" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这是集合中单个字段的基本索引集。</p><p id="d805" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您主要通过单个字段进行查询并根据该字段本身进行排序时，请使用像这样的简单索引。</p><p id="336b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单字段索引可以按升序和降序设置。这不是一个关键特性，因为我们是按单个字段选择的，所以sort方法可以按两种顺序读取索引(自然或反向)。</p><p id="4d54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果要索引整个嵌入文档，单字段索引会变得复杂。是的，如果您的查询大部分时间都试图匹配目标嵌入文档上的字段，这可能是合理的。</p><h2 id="d43b" class="mt lr it bd ls mu mv dn lw mw mx dp ma kr my mz me kv na nb mi kz nc nd mm ne bi translated">复合指数</h2><p id="d5fc" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这是一种涉及多个字段的索引，就像在RDBMS数据库中一样。</p><p id="43d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">复合索引的行为类似于单字段索引，但是当我们耦合多个字段上的信息时，索引顺序成为一个关键的实现。</p><p id="23cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您在目标集合上创建复合索引时，您可以选择在涉及的每个字段上是升序还是降序。</p><p id="3586" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正确的选择取决于您将发送给引擎的查询，并且它必须是兼容的。例如，如果按升序对字段名进行索引，按降序对姓氏进行索引，则索引将只覆盖查询的一个子集。</p><h2 id="d5c1" class="mt lr it bd ls mu mv dn lw mw mx dp ma kr my mz me kv na nb mi kz nc nd mm ne bi translated">多键索引</h2><p id="4fde" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">当你听说多键时，你是在和数组打交道。</p><p id="4834" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数组在MongoDB集合中非常流行，因为它们是高效存储单个字段的多个值的好方法。</p><p id="fb85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们使用数组，我们就开始考虑如何在数组中索引值。</p><p id="d7ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当对保存数组值的字段进行索引时，MongoDB会为数组中的每个元素创建一个索引键。这意味着索引大小增加了，但是它可以导致显著的性能改进。</p><h2 id="bcf8" class="mt lr it bd ls mu mv dn lw mw mx dp ma kr my mz me kv na nb mi kz nc nd mm ne bi translated">文本索引</h2><p id="dd48" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">当您需要实现全文查询并按相关性对结果进行排序时，请使用文本索引。</p><p id="1972" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文本索引是一个很棒的MongoDB特性，可以用来排除搜索查询中的单词，对多个单词进行完全匹配，并在文本字段上给出一个类似Google的搜索实现。</p><p id="9449" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，MongoDB对文本索引有限制，一个集合最多只能有一个文本索引。</p><h2 id="ab4a" class="mt lr it bd ls mu mv dn lw mw mx dp ma kr my mz me kv na nb mi kz nc nd mm ne bi translated">地理空间索引:二维球体和二维索引</h2><p id="de16" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这些种类的索引非常有趣。它们可用于索引纬度和经度坐标，以及<a class="ae kf" href="https://geojson.org/" rel="noopener ugc nofollow" target="_blank"> GeoJSON </a>结构化数据。</p><p id="619d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这些索引来执行有效的查询，能够通过邻近、边界框等方式提取数据。</p><h2 id="b749" class="mt lr it bd ls mu mv dn lw mw mx dp ma kr my mz me kv na nb mi kz nc nd mm ne bi translated">散列索引</h2><p id="b877" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">散列索引将<code class="fe nf ng nh ni b">hashed</code>指定为索引键值。</p><p id="4bb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能想知道为什么我们需要这个。当您需要在多个MongoDB实例上分割您的集合时，散列索引在扩展中很受欢迎，因为它们改善了基数和值的分布。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="1c5a" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">涵盖的查询</h1><p id="94a3" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">只要查询是以某种方式组成的，MongoDB就会认为查询是“覆盖的”,这样引擎就可以直接从索引中提取结果。</p><p id="cf93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，覆盖查询是一个完全可以使用索引来满足的查询(它不需要检查任何文档)。</p><p id="5857" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着覆盖查询是我们的目标，因为它们可以由MongoDB 3.2以来可用的MongoDB引擎<a class="ae kf" href="http://www.wiredtiger.com/" rel="noopener ugc nofollow" target="_blank"> WiredTiger </a>以最佳方式执行。</p><p id="729f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要记住的第一条规则是:以正确的方式在集合上建立索引。</p><p id="721e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择索引类型和组成可能会成为一个陷阱，因为不容易理解查询何时被覆盖，何时未被覆盖。</p><p id="e844" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> </strong> <code class="fe nf ng nh ni b">explain()</code>命令可能有用。您可以使用它来检查和理解查询执行，并检查在集合上设置索引后是否提高了性能。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="5bd4" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">运行覆盖查询</h1><p id="6f85" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">考虑一个名为<em class="nj"> users </em>的简单集合和一个如下所示的简单文档:</p><pre class="lf lg lh li gt nk ni nl nm aw nn bi"><span id="9b33" class="mt lr it ni b gy no np l nq nr">{ <br/>    name : “Ivano”, <br/>    lastName : “Di Gese” <br/>}</span></pre><p id="1389" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，知道您可以在<code class="fe nf ng nh ni b">name</code>字段上设置一个索引，并将匹配<code class="fe nf ng nh ni b">name</code>字段值的查询转换为真正被索引覆盖是没有意义的。</p><p id="bb31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只需在此集合上设置索引，我们就完成了:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1ca0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们看看WiredTiger MongoDB引擎如何使用<code class="fe nf ng nh ni b">explain()</code>命令解释和执行查询。</p><p id="5197" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用<code class="fe nf ng nh ni b">executionStats</code>标志来显示相关信息:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/c98de95a8f0de4641be4f5c6eb88dbab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAOHTjy4MFaPPK0SDQGlJg.jpeg"/></div></div></figure><p id="fbb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nf ng nh ni b">explain()</code>命令输出非常冗长，但是您可以过滤掉一些规范并注意突出显示的内容:</p><ol class=""><li id="e53b" class="nv nw it ki b kj kk kn ko kr nx kv ny kz nz ld oa ob oc od bi translated"><code class="fe nf ng nh ni b">TotalDocsExamined</code>:显示光标所检查的文档数，与结果集的文档相匹配。</li><li id="17fd" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld oa ob oc od bi translated"><code class="fe nf ng nh ni b">Stage</code>:这是输入阶段的<code class="fe nf ng nh ni b">IXSCAN</code>，然后是执行阶段的<code class="fe nf ng nh ni b">FETCH</code>。这意味着我们仅使用索引就完全覆盖了查询。<code class="fe nf ng nh ni b">FETCH</code>意味着，即使我们使用索引来检索文档所属的内存地址，我们仍然需要从用户集合中获取它。</li></ol><p id="848f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，完全覆盖的查询是同时满足两个条件的查询(<a class="ae kf" href="https://docs.mongodb.com/manual/core/query-optimization/index.html#covered-query" rel="noopener ugc nofollow" target="_blank">更多信息</a>):</p><ol class=""><li id="2ede" class="nv nw it ki b kj kk kn ko kr nx kv ny kz nz ld oa ob oc od bi translated">查询中的所有字段都是索引的一部分。</li><li id="9ee1" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld oa ob oc od bi translated">结果中返回的所有字段都在同一个索引中。</li></ol><p id="52b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们不满足第二个条件，查询仍然没有被完全覆盖，因为我们仍然需要从用户集合中获取它。</p><p id="85ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是一个值得注意的实现。在检索了文档的内存位置后，从集合中提取单个文档并不复杂，也不会影响查询性能。</p><p id="e853" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我们可以做得更好，我们只想使用指数。我们可以要求查询只检索一个精确的索引字段！</p><p id="553f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尝试执行以下查询:</p><pre class="lf lg lh li gt nk ni nl nm aw nn bi"><span id="86b8" class="mt lr it ni b gy no np l nq nr">db.users.find(<br/>    { name : “Ivano” }, <br/>    { name : 1, _id : 0 }<br/>).explain(“executionStats”)</span></pre><p id="91c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会注意到<code class="fe nf ng nh ni b">TotalDocsExamined</code>现在最终为零。这意味着即使我们做了一个<code class="fe nf ng nh ni b">PROJECTION</code>阶段(这是字段选择)，我们也不会访问集合，因为我们已经在索引中有了唯一需要的字段。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="efef" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">复合索引上的覆盖查询</h1><p id="1f5e" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">上面的例子很简单。我们希望从索引本身提取数据，因此我们必须满足所涵盖的查询定义的两个条件。</p><p id="a01d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，覆盖多个字段的索引会发生什么？</p><p id="e107" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样的故事，同样的行为。你自己试试。我们的目标始终是拥有最少的<code class="fe nf ng nh ni b">TotalDocsExamined</code>，这意味着我们在执行<code class="fe nf ng nh ni b">COLLSCAN</code>阶段时投入最少的努力和最少的比较数。</p><p id="caab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了实现这个目标，要正确地使用索引，包括可能需要通过查找和聚合来检索的字段。</p><p id="deaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的查询越复杂，索引设置阶段就越困难。</p><p id="5b68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于MongoDB索引还有很多需要了解的。我只是试图介绍索引类型和它们的基本行为。</p><p id="fb9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">掌握索引特性和机会需要做大量的工作，而且可能比看起来更困难，尤其是与RDBMS的索引策略相比。但是，正如你所知道的……没有付出就没有收获。</p></div></div>    
</body>
</html>