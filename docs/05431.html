<html>
<head>
<title>Cracking the Amazon Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解亚马逊访谈</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cracking-the-amazon-interview-cf6a6c5f954a?source=collection_archive---------0-----------------------#2020-07-08">https://betterprogramming.pub/cracking-the-amazon-interview-cf6a6c5f954a?source=collection_archive---------0-----------------------#2020-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c1d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看亚马逊编码面试中的热门问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9fc5ef36c6886b62c9f696e5501d8302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icEx8_11o68d-eXoTaA1AQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure><p id="fc16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在亚马逊找到一份工作是全球许多开发者的梦想。亚马逊是世界上最大的公司之一，拥有超过50万的员工。亚马逊正在快速招聘，其独特的招聘流程强调公司文化和领导原则。今天，我将为你介绍一次亚马逊面试所需的一切，包括编码问题和一步一步的准备指南。</p><p id="44a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">今天我们将复习以下内容:</strong></p><ul class=""><li id="f13b" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">45个常见的亚马逊编码面试问题</li><li id="8eed" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">亚马逊编码访谈概述</li><li id="ddd5" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何准备编码面试</li><li id="34e1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">包扎</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/fe25490d59daa1e1d4e43d28363425cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhCUNxfhMf0ttcQ6bwAd7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b966" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">45个常见的亚马逊编码面试问题</h1><h2 id="9895" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">1.找出数组中缺少的数字</h2><p id="dd52" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给你一个从<code class="fe nz oa ob oc b">1</code>到<code class="fe nz oa ob oc b">n</code>的正数数组，这样从<code class="fe nz oa ob oc b">1</code>到<code class="fe nz oa ob oc b">n</code>的所有数字都存在，除了一个数字<code class="fe nz oa ob oc b">x</code>。你得找到<code class="fe nz oa ob oc b">x</code>。输入数组未排序。查看下面的数组，并查看Python中的解决方案。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/find-the-missing-number" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/0eeeb5090ee5d1fa57ff64d103a34cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wtWd1bBLnN7PFIK-ZVkxXA.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="8984" class="ni mr it oc b gy ok ol l om on">def find_missing(input):</span><span id="8b25" class="ni mr it oc b gy oo ol l om on"># calculate sum of all elements<br/># in input list<br/>sum_of_elements = sum(input)</span><span id="5083" class="ni mr it oc b gy oo ol l om on"># There is exactly 1 number missing<br/>n = len(input) + 1<br/>actual_sum = (n * ( n + 1 ) ) / 2<br/>return actual_sum - sum_of_elements</span><span id="58fe" class="ni mr it oc b gy oo ol l om on">def test(n):<br/> missing_element = random.randint(1, n)<br/> v = []<br/> for i in range(1, n):<br/> if i != missing_element:<br/>    v.append(i)</span><span id="466c" class="ni mr it oc b gy oo ol l om on">actual_missing = find_missing(v)<br/>print("Expected Missing = ", missing_element, " Actual Missing = ", actual_missing)<br/>assert missing_element == actual_missing</span><span id="8fc1" class="ni mr it oc b gy oo ol l om on">def main():<br/>   for n in range(1, 10):<br/>   test(1000000)</span><span id="1982" class="ni mr it oc b gy oo ol l om on">main()</span></pre><p id="9dc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，O(n)</p><p id="088a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>常数，O(1)</p><p id="865a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个简单的解决方案是在输入数组中搜索<code class="fe nz oa ob oc b">1</code>和<code class="fe nz oa ob oc b">n</code>之间的每个整数，只要有一个数字丢失，就停止搜索。但是我们可以做得更好。这是一个线性的O(n)解，使用算术级数求和公式。以下是查找缺失数字的步骤:</p><ul class=""><li id="5b19" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">求数组中所有数字的和<code class="fe nz oa ob oc b">sum_of_elements</code>。这将需要线性扫描，O(n)。</li><li id="342a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">然后使用算术级数求和公式计算第一个<code class="fe nz oa ob oc b">n</code>数字的和<code class="fe nz oa ob oc b">expected_sum</code></li><li id="94b2" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">两者之差，即<code class="fe nz oa ob oc b">expected_sum - sum_of_elements</code>，是数组中缺失的数字。</li></ul><h2 id="b690" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">2.确定两个整数之和是否等于给定值</h2><p id="9e32" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给定一个整数数组和一个值，确定数组中是否有任意两个整数的和等于给定值。如果总和存在，返回<code class="fe nz oa ob oc b">true</code>,如果不存在，返回<code class="fe nz oa ob oc b">false</code>。考虑这个数组和目标和。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/sum-of-two-values" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/08736623e132bb2af746266e49d455df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfWhi3-EtuGY7U1I_Em3NA.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="60f0" class="ni mr it oc b gy ok ol l om on">def find_sum_of_two(A, val):<br/>  found_values = set()<br/>  for a in A:<br/>     if val - a in found_values:<br/>        return True</span><span id="383d" class="ni mr it oc b gy oo ol l om on">     found_values.add(a)</span><span id="7a26" class="ni mr it oc b gy oo ol l om on">return False</span><span id="9d59" class="ni mr it oc b gy oo ol l om on">v = [5, 7, 1, 2, 8, 4, 3]<br/>test = [3, 20, 1, 2, 7]</span><span id="5991" class="ni mr it oc b gy oo ol l om on">for i in range(len(test)):<br/>  output = find_sum_of_two(v, test[i])<br/>  print("find_sum_of_two(v, " + str(test[i]) + ") = " + str(output))</span></pre><p id="0fee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，O(n)</p><p id="53cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，O(n)</p><p id="8b1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以使用下面的算法找到一对加起来的目标(比方说，<code class="fe nz oa ob oc b">val</code>)。</p><ul class=""><li id="5a1f" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">扫描整个数组一次，并将访问过的元素存储在哈希集中。</li><li id="60fa" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在<code class="fe nz oa ob oc b">scan</code>期间，对于数组中的每个元素<code class="fe nz oa ob oc b">e</code>，我们检查<code class="fe nz oa ob oc b">val - e</code>是否存在于哈希集中，即<code class="fe nz oa ob oc b">val - e</code>是否已经被访问过。</li><li id="2305" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果在hash集中找到了<code class="fe nz oa ob oc b">val - e</code>，说明数组中有一对(<code class="fe nz oa ob oc b">e</code>，<code class="fe nz oa ob oc b">val - e</code>)，其和等于给定的<code class="fe nz oa ob oc b">val</code>。</li><li id="8134" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果我们已经穷尽了数组中的所有元素，但没有找到任何这样的元素对，函数将返回<code class="fe nz oa ob oc b">false</code>。</li></ul><h2 id="7d7b" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">3.合并两个排序的链表</h2><p id="68ef" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给定两个已排序的链表，合并它们，使得结果链表也是已排序的。以两个排序链表和它们下面的合并链表为例。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/merge-two-sorted-linked-lists" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/006d918270be708f0707c309b1eb83e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqwIyOvKEHpMLvZzDdUO5Q.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="8e83" class="ni mr it oc b gy ok ol l om on">def merge_sorted(head1, head2):<br/>  # if both lists are empty then merged list is also empty<br/>  # if one of the lists is empty then other is the merged list<br/>if head1 == None: <br/>   return head2<br/>elif head2 == None:<br/>   return head1</span><span id="831f" class="ni mr it oc b gy oo ol l om on">mergedHead = None;<br/>if head1.data &lt;= head2.data:<br/>   mergedHead = head1<br/>   head1 = head1.next<br/>else:<br/>   mergedHead = head2<br/>   head2 = head2.next</span><span id="1398" class="ni mr it oc b gy oo ol l om on">mergedTail = mergedHead</span><span id="c20b" class="ni mr it oc b gy oo ol l om on">while head1 != None and head2 != None:<br/>   temp = None<br/>   if head1.data &lt;= head2.data:<br/>   temp = head1<br/>   head1 = head1.next<br/>else:<br/>   temp = head2<br/>   head2 = head2.next</span><span id="e94d" class="ni mr it oc b gy oo ol l om on"> mergedTail.next = temp<br/> mergedTail = temp</span><span id="0f4c" class="ni mr it oc b gy oo ol l om on">if head1 != None:<br/>   mergedTail.next = head1<br/>elif head2 != None:<br/>   mergedTail.next = head2</span><span id="0b52" class="ni mr it oc b gy oo ol l om on">return mergedHead<br/></span><span id="6728" class="ni mr it oc b gy oo ol l om on">array1 = [2, 3, 5, 6]<br/>array2 = [1, 4, 10]<br/>list_head1 = create_linked_list(array1)<br/>print("Original1:")<br/>display (list_head1)<br/>list_head2 = create_linked_list(array2)<br/>print("\nOriginal2:")<br/>display (list_head2)<br/>new_head = merge_sorted(list_head1, list_head2)</span><span id="7803" class="ni mr it oc b gy oo ol l om on">print("\nMerged:")<br/>display(new_head)</span></pre><p id="51c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，O(m+n)其中m和n是两个链表的长度</p><p id="ef35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>常数，O(1)</p><p id="64ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在合并的链表上保持一个头指针和一个尾指针。然后通过比较两个链表的第一个节点来选择合并链表的头。对于两个列表中的所有后续节点，选择较小的当前节点，将其链接到合并列表的尾部，并将该列表的当前指针向前移动一步。</p><p id="313f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当两个列表中都有一些剩余元素时，继续此操作。如果只有一个列表中还有一些元素，您可以将这个剩余的列表链接到合并列表的尾部。最初，合并的链表是<code class="fe nz oa ob oc b">NULL</code>。</p><p id="7356" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比较前两个节点的值，将值较小的节点作为合并链表的头节点。在本例中，是从<code class="fe nz oa ob oc b">head1</code>开始的<code class="fe nz oa ob oc b">4</code>。因为它是合并列表中的第一个也是唯一的节点，所以它也是尾部。然后向前移动<code class="fe nz oa ob oc b">head1</code>一步。</p><h2 id="ffe8" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">4.用任意指针复制链表</h2><p id="71c0" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给你一个链表，其中的节点有两个指针。首先是常规的<code class="fe nz oa ob oc b">next</code>指针。第二个指针叫做<code class="fe nz oa ob oc b">arbitrary_pointer</code>，它可以指向链表中的任何一个节点。你的工作是编写代码来深度复制给定的链表。这里的<em class="od">深度复制</em>是指对原始列表的任何操作都不应该影响复制的列表。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/copy-linked-list-with-arbitrary-pointer" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="7c95" class="ni mr it oc b gy ok ol l om on">def deep_copy_arbitrary_pointer(head):<br/>  if head == None:<br/>    return None</span><span id="1223" class="ni mr it oc b gy oo ol l om on">current = head;<br/>new_head = None<br/>new_prev = None<br/>ht = dict()</span><span id="a5b5" class="ni mr it oc b gy oo ol l om on"># create copy of the linked list, recording the corresponding<br/># nodes in hashmap without updating arbitrary pointer<br/>while current != None:<br/>   new_node = LinkedListNode(current.data)</span><span id="3536" class="ni mr it oc b gy oo ol l om on"># copy the old arbitrary pointer in the new node<br/>   new_node.arbitrary = current.arbitrary;</span><span id="a8a8" class="ni mr it oc b gy oo ol l om on">if new_prev != None:<br/>   new_prev.next = new_node<br/>else:<br/>   new_head = new_node</span><span id="087f" class="ni mr it oc b gy oo ol l om on">ht[current] = new_node</span><span id="d33a" class="ni mr it oc b gy oo ol l om on">   new_prev = new_node<br/>   current = current.next</span><span id="f09f" class="ni mr it oc b gy oo ol l om on">new_current = new_head</span><span id="01d3" class="ni mr it oc b gy oo ol l om on"># updating arbitrary pointer<br/>while new_current != None:<br/>  if new_current.arbitrary != None:<br/>    node = ht[new_current.arbitrary]</span><span id="40cd" class="ni mr it oc b gy oo ol l om on">    new_current.arbitrary = node</span><span id="e5b1" class="ni mr it oc b gy oo ol l om on">  new_current = new_current.next</span><span id="a84b" class="ni mr it oc b gy oo ol l om on">return new_head</span><span id="2a13" class="ni mr it oc b gy oo ol l om on">def create_linked_list_with_arb_pointers(length):<br/>  head = create_random_list(length)<br/>  v = []<br/>  temp = head<br/>  while temp != None:<br/>    v.append(temp)<br/>    temp = temp.next</span><span id="0d1f" class="ni mr it oc b gy oo ol l om on">  for i in range(0, len(v)):<br/>    j = random.randint(0, len(v) - 1)<br/>    p = random.randint(0, 100)<br/>    if p &lt; 75:<br/>      v[i].arbitrary = v[j]</span><span id="85e6" class="ni mr it oc b gy oo ol l om on">return head</span></pre><p id="8270" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，O(n)</p><p id="2801" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，O(n)</p><p id="f94f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法使用映射来跟踪原始列表指向的任意节点。您将分两步创建原始链表的深层副本(比如<code class="fe nz oa ob oc b">list_orig</code>)。</p><ul class=""><li id="6691" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">在第一遍中，创建原始链表的副本。创建该副本时，在新列表中使用相同的数据和<code class="fe nz oa ob oc b">arbitrary_pointer</code>值。此外，用条目更新映射，其中键是旧节点的地址，值是新节点的地址。</li><li id="8919" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">创建副本后，对复制的链表再进行一次遍历，并使用第一次遍历中创建的映射更新指向新地址的任意指针。</li></ul><h2 id="b0bb" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">5.二叉树的层次顺序遍历</h2><p id="9e62" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给定二叉树的根，显示每一层的节点值。所有级别的节点值应该显示在单独的行上。让我们看看下面的二叉树。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/level-order-traversal-binary-tree" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/a25242a0292c24baf4c8772aaf3eef2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eU4m-Gkch7X6cj3WHMgi5w.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="a3ec" class="ni mr it oc b gy ok ol l om on"># Using two queues</span><span id="e6ea" class="ni mr it oc b gy oo ol l om on">def level_order_traversal_1(root):<br/>  if root == None:<br/>    return</span><span id="0d00" class="ni mr it oc b gy oo ol l om on">  queues = [deque(), deque()]</span><span id="f0f8" class="ni mr it oc b gy oo ol l om on">  current_queue = queues[0]<br/>  next_queue = queues[1]</span><span id="e723" class="ni mr it oc b gy oo ol l om on">  current_queue.append(root)<br/>  level_number = 0</span><span id="59f3" class="ni mr it oc b gy oo ol l om on">while current_queue:<br/>   temp = current_queue.popleft()<br/>   print(str(temp.data) , end = " ")</span><span id="5f59" class="ni mr it oc b gy oo ol l om on">   if temp.left != None:<br/>     next_queue.append(temp.left)</span><span id="6ae9" class="ni mr it oc b gy oo ol l om on">  if temp.right != None:<br/>     next_queue.append(temp.right)</span><span id="0f37" class="ni mr it oc b gy oo ol l om on">  if not current_queue:<br/>     print()<br/>     level_number += 1<br/>     current_queue = queues[level_number % 2]<br/>     next_queue = queues[(level_number + 1) % 2]<br/> print()</span><span id="5332" class="ni mr it oc b gy oo ol l om on">arr = [100,50,200,25,75,350]<br/>root = create_BST(arr)<br/>print("InOrder Traversal:", end = "")<br/>display_inorder(root)<br/>print("\nLevel Order Traversal:\n", end = "")<br/>level_order_traversal_1(root)</span></pre><p id="a0fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，O(n)</p><p id="1651" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，O(n)</p><p id="53e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里使用了两个队列:<code class="fe nz oa ob oc b">current_queue</code>和<code class="fe nz oa ob oc b">next_queue</code>。您可以根据当前级别号交替推送两个队列中的节点。</p><p id="03b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将使节点从<code class="fe nz oa ob oc b">current_queue</code>中出列，打印节点的数据，并将节点的子节点加入到<code class="fe nz oa ob oc b">next_queue</code>中。一旦<code class="fe nz oa ob oc b">current_queue</code>变为空，您就已经处理了当前<code class="fe nz oa ob oc b">level_number</code>的所有节点。为了指示<code class="fe nz oa ob oc b">new level</code>，打印一个换行符(<code class="fe nz oa ob oc b">\n</code>，交换两个队列，继续上述逻辑。</p><p id="eb80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从<code class="fe nz oa ob oc b">current_queue</code>打印叶节点后，交换<code class="fe nz oa ob oc b">current_queue</code>和<code class="fe nz oa ob oc b">next_queue</code>。因为<code class="fe nz oa ob oc b">current_queue</code>是空的，你可以终止循环。</p><h2 id="ab0c" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">6.确定二叉树是否是二叉查找树</h2><p id="527d" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给定一棵二叉树，算出它是否是二叉查找树。在二叉查找树中，每个节点的键值都小于右边子树中所有节点的键值，并且大于左边子树中所有节点的键值。下面是一个有效BST的二叉树示例。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/is-binary-tree-a-binary-search-tree" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/155be6d551b64e5f80bf51ebbf2269d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ENFl_inXGHYu9976cndFw.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="4a4a" class="ni mr it oc b gy ok ol l om on">def is_bst_rec(root, min_value, max_value):<br/>   if root == None:<br/>      return True</span><span id="ed6f" class="ni mr it oc b gy oo ol l om on">  if root.data &lt; min_value or root.data &gt; max_value:<br/>     return False</span><span id="f771" class="ni mr it oc b gy oo ol l om on">  return is_bst_rec(root.left, min_value, root.data) and is_bst_rec(root.right, root.data, max_value)</span><span id="86f9" class="ni mr it oc b gy oo ol l om on">def is_bst(root):<br/>   return is_bst_rec(root, -sys.maxint - 1, sys.maxint)</span><span id="5fbf" class="ni mr it oc b gy oo ol l om on">root = create_random_BST(15)<br/>root2 = create_random_BST(15)<br/>root2.data = 100<br/>print("\nInOrder Traversal")<br/>display_inorder(root)<br/>print("\nIs BST\n\n")<br/>print("\nInOrder Traversal")<br/>display_inorder(root2)<br/>print("\nIs not BST\n\n")</span></pre><p id="cf8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，O(n)</p><p id="ec1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，O(n) <em class="od"> O </em></p><p id="e41f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有几种方法可以解决这个问题。一个基本的算法是检查每个节点，其左子树的最大值小于该节点的数据，而其右子树的最小值大于该节点的数据。这是非常低效的，因为对于每个节点，它的左和右子树都被探索。</p><p id="8ea7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种方法是进行常规的有序遍历，在每次递归调用中，传递最大和最小边界，以检查当前节点的值是否在给定的边界内。</p><h2 id="131a" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">7.字符串分段</h2><p id="2e82" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给你一个单词字典和一个大的输入字符串。您必须找出输入字符串是否可以完全分割成给定词典中的单词。以下两个例子进一步阐述了这个问题。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/string-segmentation" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/66c11c37638486c7c76417f3e9d05564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnAjOhx6S2Ll1Aiz5OIITQ.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="ca02" class="ni mr it oc b gy ok ol l om on">def can_segment_string(s, dictionary):<br/>   for i in range(1, len(s) + 1):<br/>     first = s[0:i]<br/>     if first in dictionary:<br/>        second = s[i:]<br/>        if not second or second in dictionary or can_segment_string(second, dictionary):<br/>          return True <br/>   return False</span><span id="38f7" class="ni mr it oc b gy oo ol l om on">s = "hellonow";<br/>dictionary= set(["hello","hell","on","now"])<br/>if can_segment_string(s, dictionary):<br/>   print("String Can be Segmented")<br/>else:<br/>   print("String Can NOT be Segmented")</span></pre><p id="3075" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>指数级，O(2^n)</p><p id="cf0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>多项式，O(n^2)</p><p id="4d55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过在每个可能的位置分割大字符串来解决这个问题，看看该字符串是否可以完全分割成字典中的单词。如果您分步编写算法，将如下所示:</p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="5ff5" class="ni mr it oc b gy ok ol l om on">n = length of input string<br/>for i = 0 to n - 1<br/>  first_word = substring (input string from index [0, i] )<br/>  second_word = substring (input string from index [i + 1, n - 1] )<br/>  if dictionary has first_word<br/>    if second_word is in dictionary OR second_word is of zero length, then return true<br/>    recursively call this method with second_word as input and return true if it can be segmented</span></pre><p id="309b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该算法将在循环的每次迭代中从头开始计算两个字符串。最坏的情况是，每次都会递归调用<code class="fe nz oa ob oc b">second_word</code>。这使得时间复杂度达到了2^n.，你可以看到你可能多次计算同一个子串，即使它不存在于字典中。这种冗余可以通过记忆来解决，在记忆中你记住了哪些子串已经被解决了。为了实现记忆，您可以每次将<code class="fe nz oa ob oc b">second</code>字符串存储在一个新的集合中。这将减少时间和内存的复杂性。</p><h2 id="2556" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">8.颠倒句子中的单词</h2><p id="6564" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">反转给定句子中单词的顺序(字符数组)。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/reverse-words-in-a-sentence" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/603c6ff639bbecd6ec2e408937acaa4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vm86278f7EsuGxOrcvHz4A.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="0e5c" class="ni mr it oc b gy ok ol l om on">def str_rev(str, start, end):<br/>  if str == None or len(str) &lt; 2:<br/>    return<br/> <br/>  while start &lt; end:<br/>    temp = str[start]<br/>    str[start] = str[end]<br/>    str[end] = temp<br/> <br/>    start += 1<br/>    end -= 1<br/> <br/> <br/>def reverse_words(sentence):<br/> <br/>  # Here sentence is a null-terminated string ending with char '\0'.<br/> <br/>  if sentence == None or len(sentence) == 0:<br/>    return<br/> <br/>  #  To reverse all words in the string, we will first reverse<br/>  #  the string. Now all the words are in the desired location, but<br/>  #  in reverse order: "Hello World" -&gt; "dlroW olleH".<br/> <br/>  str_len = len(sentence)<br/>  str_rev(sentence, 0, str_len - 2)<br/> <br/>  # Now, let's iterate the sentence and reverse each word in place.<br/>  # "dlroW olleH" -&gt; "World Hello"<br/> <br/>  start = 0<br/>  end = 0<br/> <br/>  while True:<br/> <br/>  # find the  start index of a word while skipping spaces.<br/>    while start &lt; len(sentence) and sentence[start] == ' ':<br/>      start += 1<br/> <br/>    if start == str_len:<br/>      break<br/> <br/>  # find the end index of the word.<br/>    end = start + 1<br/>    while end &lt; str_len and sentence[end] != ' ':<br/>      end += 1<br/> <br/>  # let's reverse the word in-place.<br/>    str_rev(sentence, start, end - 1)<br/>    start = end<br/> <br/> <br/>def get_array(t):<br/>  s = array('u', t)<br/>  return s<br/> <br/> <br/>def print_array(s):<br/>  i = 0<br/>  while i != len(s):<br/>    stdout.write(s[i])<br/>    i += 1<br/>  print ()<br/> <br/> <br/>s = get_array('Hello World!')<br/>print_array(s)<br/>reverse_words(s)<br/>print_array(s)</span></pre><p id="2fc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，O(n)</p><p id="14c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>常数，O(1)</p><p id="e515" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决这个问题的步骤比看起来简单:</p><ul class=""><li id="b1b7" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">反转绳子。</li><li id="655e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">遍历字符串，将每个单词颠倒过来。</li></ul><h2 id="d1b0" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">9.有多少种方法可以用硬币和总数来找零？</h2><p id="55c6" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">假设我们有[1，2，5]的硬币面额，总数是7。我们可以通过以下六种方式做出改变。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/coin-changing-problem" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/d6fbc216433df7fe4ccd9dce99869a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-fJNRtyGL3fkV7NpdKFvw.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="7260" class="ni mr it oc b gy ok ol l om on">def solve_coin_change(denominations, amount):<br/>  solution = [0] * (amount + 1)<br/>  solution[0] = 1;<br/>  for den in denominations:<br/>    for i in range(den, amount + 1):<br/>      solution[i] += solution[i - den] <br/> <br/>  return solution[len(solution) - 1]<br/>    <br/>denominations = [1, 2, 5]<br/>amount = 7<br/>result = solve_coin_change(denominations, amount)<br/># printing the answer<br/>print("solve_coin_change(" + str(denominations) + ', ' + str(amount) + ') = ', end = '' )<br/>print(result)</span></pre><p id="a068" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>二次，O(m∫n)</p><p id="6ad7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，O(n)</p><p id="1a58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，我们将保持一个大小为<code class="fe nz oa ob oc b">amount + 1</code>的数组。保留了一个额外的空间，因为我们还想存储<code class="fe nz oa ob oc b">0</code>数量的解决方案。只有一种方法可以改变<code class="fe nz oa ob oc b">0</code>，即选择无硬币，所以我们将初始化<code class="fe nz oa ob oc b">solution[0] = 1</code>。我们将解决每个金额的问题，从面额到金额，使用硬币到一个面额，<code class="fe nz oa ob oc b">den</code>。不同面值的结果应存储在阵列解决方案中。使用面额<code class="fe nz oa ob oc b">den</code>的金额<code class="fe nz oa ob oc b">x</code>的解决方案将是:</p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="3b6f" class="ni mr it oc b gy ok ol l om on">solution[x] = solution[x] + solution[x - den]</span></pre><p id="786d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将对所有的面额重复这个过程，在<code class="fe nz oa ob oc b">solution</code>数组的最后一个元素，我们将有解决方案。</p><h2 id="9354" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">10.寻找第k个排列</h2><p id="d6b5" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给定一组n个元素，求它们的第k次排列。考虑以下一组元素。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/find-permutation" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/569288eafe10395372b5e63cb8b47aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxzSPYjJuqzMwlAZLiXKoA.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="3b9e" class="ni mr it oc b gy ok ol l om on">def factorial(n):<br/>  if n == 0 or n == 1:<br/>    return 1<br/>  return n * factorial(n -1 )<br/> <br/>def find_kth_permutation(v, k, result):<br/>  if not v:<br/>    return<br/>  <br/>  n = len(v)<br/>  # count is number of permutations starting with first digit<br/>  count = factorial(n - 1)<br/>  selected = (k - 1) // count<br/>  <br/>  result += str(v[selected])<br/>  del v[selected]<br/>  k = k - (count * selected)<br/>  find_kth_permutation(v, k, result)<br/>  <br/>def get_permutation(n, k):<br/>  v = list(range(1, n + 1))<br/>  result = []<br/>  find_kth_permutation(v, k, result)<br/>  return ''.join(result)<br/> <br/>def main():<br/>  n = factorial(4)<br/>  for i in range(1, n + 1):<br/>    print(str(i) + "th permutation = \t", get_permutation(4, i))<br/> <br/>main()</span></pre><p id="33f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，O(n)</p><p id="60ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，O(n)</p><p id="f3c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们将遵循的算法:</p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="3271" class="ni mr it oc b gy ok ol l om on">If input vector is empty return result vector<br/> <br/>block_size = (n-1)! ['n' is the size of vector]<br/> <br/>Figure out which block k will lie in and select the first element of that block<br/>(this can be done by doing (k-1)/block_size)<br/> <br/>Append selected element to result vector and remove it from original input vector<br/> <br/>Deduce from k the blocks that are skipped i.e k = k - selected*block_size and goto step 1</span></pre><h2 id="b425" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">11.查找给定整数集的所有子集</h2><p id="bb83" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给我们一组整数，我们要找出这组整数所有可能的子集。以下示例对此进行了进一步阐述。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/find-all-subsets" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/3dcfb3f05a700a67c723d0113222d5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ovzy3RstxOA48_mRVdPOQA.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="058f" class="ni mr it oc b gy ok ol l om on">def get_bit(num, bit):<br/>    temp = (1 &lt;&lt; bit)<br/>    temp = temp &amp; num<br/>    if temp == 0:<br/>      return 0<br/>    return 1<br/>        <br/>def get_all_subsets(v, sets):<br/>    subsets_count = 2 ** len(v)<br/>    for i in range(0, subsets_count):<br/>      st = set([])<br/>      for j in range(0, len(v)):<br/>         if get_bit(i, j) == 1:<br/>            st.add(v[j])<br/>      sets.append(st)<br/>      <br/>def main():<br/>    v = [8,13,3,22,17,39,87,45,36]<br/>    subsets = []<br/>    get_all_subsets(v, subsets);<br/>    print("****Total*****" + str(len(subsets)))<br/>    for i in range(0, len(subsets)):<br/>        print("{", end = "")<br/>        print(subsets[i], end = "")<br/>        print("}")<br/>    print("****Total*****" + str(len(subsets)))<br/> <br/>main()</span></pre><p id="049b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>指数级，O(2^n∗n)</p><p id="e112" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>指数，O(2^n∗n)</p><p id="20ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有几种方法可以解决这个问题。我们将讨论一个简洁易懂的例子。我们知道，对于一组<code class="fe nz oa ob oc b">n</code>元素，存在2^n子集。例如，具有三个元素的集合将具有八个子集。下面是我们将使用的算法:</p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="bb35" class="ni mr it oc b gy ok ol l om on">n = size of given integer set<br/>subsets_count = 2^n<br/>for i = 0 to subsets_count<br/>    form a subset using the value of 'i' as following:<br/>        bits in number 'i' represent index of elements to choose from original set,<br/>        if a specific bit is 1 choose that number from original set and add it to current subset,<br/>        e.g. if i = 6 i.e 110 in binary means that 1st and 2nd elements in original array need to be picked.<br/>    add current subset to list of all subsets</span></pre><h2 id="5cb8" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">12.打印平衡括号组合</h2><p id="4f44" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">打印给定值n的所有大括号组合，使它们平衡。对于这个解决方案，我们将使用递归。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/all-possible-braces" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="3922" class="ni mr it oc b gy ok ol l om on">def print_all_braces_rec(n, left_count, right_count, output, result):<br/> <br/>  if left_count &gt;= n and right_count &gt;= n:<br/>    result.append(copy.copy(output));<br/>    <br/>  if left_count &lt; n:<br/>    output += '{'<br/>    print_all_braces_rec(n, left_count + 1, right_count, output, result)<br/>    output.pop()<br/> <br/>  if right_count &lt; left_count:<br/>    output += '}'<br/>    print_all_braces_rec(n, left_count, right_count + 1, output, result)<br/>    output.pop()<br/> <br/>def print_all_braces(n):<br/>  output = []<br/>  result = []<br/>  print_all_braces_rec(n, 0, 0, output, result)<br/>  return result<br/> <br/>result = print_all_braces(3)<br/> <br/>for rs in result: <br/>  print(rs)</span></pre><p id="2c09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>指数级，2^n</p><p id="cacc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，O(n)</p><p id="cd3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决方案是保持<code class="fe nz oa ob oc b">left_braces</code>和<code class="fe nz oa ob oc b">right_braces</code>的计数。基本算法如下:</p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="4419" class="ni mr it oc b gy ok ol l om on">left_braces count: 0<br/>right_braces count: 0<br/> <br/>if left_braces count is less than n:<br/>  add left_braces and recurse further<br/>if right_braces count is less than left_braces count:<br/>  add right_braces and recurse further<br/>stop recursing when left_braces and right_braces counts are both equal to n</span></pre><h2 id="121a" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">13.克隆一个有向图</h2><p id="3e29" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给定一个有向图的根节点，通过创建它的深层副本来克隆这个图，以便克隆的图与原始图具有相同的顶点和边。让我们以下面的图表为例。如果输入图是G=(V，E)，其中V是顶点集，E是边集，那么输出图(克隆图)G' = (V '，E ')使得V = V '和E = E '。我们假设所有的顶点都可以从根顶点到达，也就是说，我们有一个连通图。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/clone-directed-graph" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/bffb830ea4ef705875e33d7d40e6fa23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FH9VeNSPYriiomR6R7fdsQ.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="4c43" class="ni mr it oc b gy ok ol l om on">class Node:<br/>  def __init__(self, d):<br/>    self.data = d<br/>    self.neighbors = []<br/> <br/>def clone_rec(root, nodes_completed):<br/>  if root == None:<br/>    return None<br/> <br/>  pNew = Node(root.data)<br/>  nodes_completed[root] = pNew<br/> <br/>  for p in root.neighbors:<br/>    x = nodes_completed.get(p)<br/>    if x == None:<br/>      pNew.neighbors += [clone_rec(p, nodes_completed)]<br/>    else:<br/>      pNew.neighbors += [x]<br/>  return pNew<br/> <br/>def clone(root):<br/>  nodes_completed = {}<br/>  return clone_rec(root, nodes_completed)<br/> <br/> <br/># this is un-directed graph i.e.<br/># if there is an edge from x to y<br/># that means there must be an edge from y to x<br/># and there is no edge from a node to itself<br/># hence there can maximim of (nodes * nodes - nodes) / 2 edgesin this graph<br/>def create_test_graph_undirected(nodes_count, edges_count):<br/>  vertices = []<br/>  for i in range(0, nodes_count):<br/>    vertices += [Node(i)]<br/> <br/>  all_edges = []<br/>  for i in range(0, nodes_count):<br/>    for j in range(i + 1, nodes_count):<br/>      all_edges.append([i, j])<br/> <br/>  shuffle(all_edges)<br/> <br/>  for i in range(0, min(edges_count, len(all_edges))):<br/>    edge = all_edges[i]<br/>    vertices[edge[0]].neighbors += [vertices[edge[1]]]<br/>    vertices[edge[1]].neighbors += [vertices[edge[0]]]<br/> <br/>  return vertices<br/>  <br/> <br/>def print_graph(vertices):<br/>  for n in vertices:<br/>    print(str(n.data), end = ": {")<br/>    for t in n.neighbors:<br/>      print(str(t.data), end = " ")<br/>    print()<br/> <br/>def print_graph_rec(root, visited_nodes):<br/>  if root == None or root in visited_nodes:<br/>    return<br/> <br/>  visited_nodes.add(root)<br/> <br/>  print(str(root.data), end = ": {")<br/>  for n in root.neighbors:<br/>    print(str(n.data), end = " ")<br/>  print("}")<br/> <br/>  for n in root.neighbors:<br/>    print_graph_rec(n, visited_nodes)<br/> <br/>def print_graph(root):<br/>  visited_nodes = set()<br/>  print_graph_rec(root, visited_nodes)<br/> <br/>def main():<br/>  vertices = create_test_graph_undirected(7, 18)<br/>  print_graph(vertices[0])<br/>  cp = clone(vertices[0])<br/>  print()<br/>  print("After copy.")<br/>  print_graph(cp)<br/> <br/> <br/>main()</span></pre><p id="4f9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，O(n)</p><p id="d41e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>对数，O(logn)</p><p id="52ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用深度优先遍历，并在遍历图时创建每个节点的副本。为了避免陷入循环，我们将使用一个哈希表来存储每个完成的节点，并且不会重新访问哈希表中存在的节点。hashtable键将是原始图中的一个节点，它的值将是克隆图中相应的节点。</p><h2 id="4431" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">14.查找低/高索引</h2><p id="c587" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给定一个排序的整数数组，返回给定键的高低索引。如果没有找到索引，必须返回<code class="fe nz oa ob oc b">-1</code>。数组长度可以达到数百万，有许多重复。</p><p id="c307" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的例子中，根据<code class="fe nz oa ob oc b">key</code>,<code class="fe nz oa ob oc b">low</code>和<code class="fe nz oa ob oc b">high</code>指数将是:</p><ul class=""><li id="fc05" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe nz oa ob oc b">key</code> : 1，<code class="fe nz oa ob oc b">low</code> = 0，<code class="fe nz oa ob oc b">high</code> = 0</li><li id="8114" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nz oa ob oc b">key</code> : 2，<code class="fe nz oa ob oc b">low</code> = 1，<code class="fe nz oa ob oc b">high</code> = 1</li><li id="9a15" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nz oa ob oc b">key</code> : 5，<code class="fe nz oa ob oc b">low</code> = 2，<code class="fe nz oa ob oc b">high</code> = 9</li><li id="f2f0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe nz oa ob oc b">key</code> : 20，<code class="fe nz oa ob oc b">low</code> = 10，<code class="fe nz oa ob oc b">high</code> = 10</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/a131d0af2f0ac2f59c57f3ef9c428ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o0ROwlW0_cynAww-"/></div></div></figure><p id="6940" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了测试您的代码，输入数组将是:</p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="a2db" class="ni mr it oc b gy ok ol l om on">1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6, 6</span></pre><p id="f6b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/find-low-high-index" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="f17a" class="ni mr it oc b gy ok ol l om on">def find_low_index(arr, key):<br/>  <br/>  low = 0<br/>  high = len(arr) - 1<br/>  mid = int(high / 2)<br/> <br/>  while low &lt;= high:<br/> <br/>    mid_elem = arr[mid]<br/> <br/>    if mid_elem &lt; key:<br/>      low = mid + 1<br/>    else:<br/>      high = mid - 1<br/> <br/>    mid = low + int((high - low) / 2)<br/> <br/>  if low &lt; len(arr) and arr[low] == key:<br/>    return low<br/> <br/>  return -1<br/> <br/>def find_high_index(arr, key):<br/>  low = 0<br/>  high = len(arr) - 1<br/>  mid = int(high / 2)<br/> <br/>  while low &lt;= high:<br/>    mid_elem = arr[mid]<br/> <br/>    if mid_elem &lt;= key:<br/>      low = mid + 1<br/>    else:<br/>      high = mid - 1<br/> <br/>    mid = low + int((high - low) / 2);<br/>  <br/>  if high == -1:<br/>    return high<br/> <br/>  if high &lt; len(arr) and arr[high] == key:<br/>    return high<br/> <br/>  return -1<br/> <br/> <br/>array = [1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6, 6]<br/>key = 5<br/>low = find_low_index(array, key)<br/>high = find_high_index(array, key)<br/>print("Low Index of " + str(key) + ": " + str(low))<br/>print("High Index of " + str(key) + ": " + str(high))<br/> <br/>key = -2<br/>low = find_low_index(array, key)<br/>high = find_high_index(array, key)<br/>print("Low Index of " + str(key) + ": " + str(low))<br/>print("High Index of " + str(key) + ": " + str(high))</span></pre><p id="c004" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>对数，O(logn)</p><p id="4b21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>常数，O(1)</p><p id="5913" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">线性扫描排序后的数组来寻找<code class="fe nz oa ob oc b">low</code>和<code class="fe nz oa ob oc b">high</code>索引是非常低效的，因为我们的数组可能有几百万个。相反，我们将使用稍微修改的二分搜索法来查找给定键的<code class="fe nz oa ob oc b">low</code>和<code class="fe nz oa ob oc b">high</code>索引。我们需要做两次二分搜索法:一次是寻找<code class="fe nz oa ob oc b">low</code>指数，一次是寻找<code class="fe nz oa ob oc b">high</code>指数。</p><p id="a7e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看寻找<code class="fe nz oa ob oc b">low</code>索引的算法。在每一步，考虑<code class="fe nz oa ob oc b">low</code>和<code class="fe nz oa ob oc b">high</code>索引之间的数组，并计算<code class="fe nz oa ob oc b">mid</code>索引。</p><ul class=""><li id="2358" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">如果<code class="fe nz oa ob oc b">mid</code>索引处的元素小于<code class="fe nz oa ob oc b">key</code>，则<code class="fe nz oa ob oc b">low</code>变为<code class="fe nz oa ob oc b">mid + 1</code>(向范围起点移动)。</li><li id="a8d8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果<code class="fe nz oa ob oc b">mid</code>处的元素大于或等于<code class="fe nz oa ob oc b">key</code>，<code class="fe nz oa ob oc b">high</code>变为<code class="fe nz oa ob oc b">mid - 1</code>。T4的指数保持不变。</li><li id="259b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">当<code class="fe nz oa ob oc b">low</code>大于<code class="fe nz oa ob oc b">high</code>时，<code class="fe nz oa ob oc b">low</code>将指向第一次出现的<code class="fe nz oa ob oc b">key</code>。</li><li id="a1c8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果<code class="fe nz oa ob oc b">low</code>处的元素与<code class="fe nz oa ob oc b">key</code>、<code class="fe nz oa ob oc b">return -1</code>不匹配。</li></ul><p id="1e2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，我们可以通过稍微修改上面的条件来找到<code class="fe nz oa ob oc b">high</code>索引:</p><ul class=""><li id="6eda" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">当<code class="fe nz oa ob oc b">mid</code>索引处的元素小于或等于<code class="fe nz oa ob oc b">key</code>时，将<code class="fe nz oa ob oc b">low</code>索引切换到<code class="fe nz oa ob oc b">mid + 1</code>。</li><li id="e7bd" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">当<code class="fe nz oa ob oc b">mid</code>处的元素大于<code class="fe nz oa ob oc b">key</code>时，将<code class="fe nz oa ob oc b">high</code>索引切换到<code class="fe nz oa ob oc b">mid - 1</code>。</li></ul><h2 id="0dee" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">15.搜索旋转数组</h2><p id="4be2" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">在一个排序的数组中搜索一个给定的数字，该数组具有唯一的元素，并且被旋转了任意的数字。如果号码不存在，返回<code class="fe nz oa ob oc b">-1</code>。假设数组不包含重复项。<em class="od">点击</em> <a class="ae oe" href="https://www.educative.io/m/search-rotated-array" rel="noopener ugc nofollow" target="_blank"> <em class="od">此处</em> </a> <em class="od">查看C++、Java、JavaScript、Ruby的解决方案。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/aa77620a0438ad54b7f79a388c13a8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8epKR5PsHWuhV47D9ybfw.png"/></div></div></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="125a" class="ni mr it oc b gy ok ol l om on">def binary_search(arr, start, end, key):<br/>  # assuming all the keys are unique.<br/>  <br/>  if (start &gt; end):<br/>    return -1;<br/> <br/>  mid = int(start + (end - start) / 2)<br/> <br/>  if arr[mid] == key:<br/>    return mid<br/>    <br/>  if arr[start] &lt;= arr[mid] and key &lt;= arr[mid] and key &gt;= arr[start]:<br/>    return binary_search(arr, start, mid - 1, key)<br/>  <br/>  elif arr[mid] &lt;= arr[end] and key &gt;= arr[mid] and key &lt;= arr[end]: <br/>    return binary_search(arr, mid + 1, end, key)</span></pre><p id="0b97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>对数，O(logn)</p><p id="2d8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>对数，O(logn)</p><p id="6f02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该解决方案本质上是一个二分搜索法，但做了一些修改。如果我们仔细观察示例中的数组，我们会注意到至少有一半的数组总是被排序的。我们可以利用这一特性。如果数字<code class="fe nz oa ob oc b">n</code>位于数组排序后的一半，那么我们的问题就是一个基本的二分搜索法。否则，丢弃已排序的一半，继续检查未排序的一半。因为我们在每一步都将数组分成两半，所以我们的运行时复杂度为O(logn)<em class="od">O</em>(<em class="od">logn</em>)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a130" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">更常见的亚马逊编码面试问题</h1><ul class=""><li id="15e3" class="lu lv it la b lb nu le nv lh pb ll pc lp pd lt lz ma mb mc bi translated">数组中k个最大的元素</li><li id="b99a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将二叉树转换为DLL。</li><li id="bbe3" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">给定一棵二叉树T，求最大路径和。该路径可以在树中的任何节点开始和结束。</li><li id="1500" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将矩阵旋转90度。</li><li id="bd7a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">基于动态规划的装配线调度</li><li id="ead9" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">用O(1) <em class="od"> O </em> (1)时间实现一个<code class="fe nz oa ob oc b">push()</code>、<code class="fe nz oa ob oc b">min()</code>、<code class="fe nz oa ob oc b">pop()</code>的栈。</li><li id="ca80" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何将一个数组旋转K？</li><li id="fbaf" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用面向对象的分析和设计技术设计贪吃蛇游戏。</li><li id="ee27" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用递归打印给定字符串的所有排列。</li><li id="a91d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用链表实现队列。</li><li id="fbef" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">找出数组中最长的递增子序列。</li><li id="59bd" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">二叉查找树和二叉树的最低共同祖先</li><li id="47cf" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将给定列表向右旋转<code class="fe nz oa ob oc b">k</code>位，非负。</li><li id="cbd8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">编写一个函数，计算一个32位整数中设置位的总数。</li><li id="4b16" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何检测单链表中的循环？</li><li id="09be" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">成组反转数组。</li><li id="4a86" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">给定一棵二叉树，检查它是否是自身的镜像。</li><li id="5000" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">递归的约瑟夫问题</li><li id="4444" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">零和子阵列</li><li id="ac48" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">贪婪算法的霍夫曼解码</li><li id="e552" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">动态规划的落蛋难题</li><li id="8926" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">n皇后问题</li><li id="362f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">检查字符串是否是彼此的旋转。</li><li id="a754" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">0-1背包问题</li><li id="6af6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">无界背包问题</li><li id="9360" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">最长回文子序列</li><li id="878b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">打印斐波纳契数列中的<code class="fe nz oa ob oc b">nth</code>数。</li><li id="5088" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">最长公共子串</li><li id="55b5" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">最长公共子序列</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3ffd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">亚马逊编码访谈概述</h1><p id="ec54" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">要想在亚马逊找到一份软件工程的工作，你需要知道前方有什么。你准备得越充分，你就会越自信。所以，我们来分解一下。</p><ul class=""><li id="b811" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><strong class="la iu">面试时间表:</strong>整个面试过程需要六到八周完成。</li><li id="0a11" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">面试类型:</strong>亚马逊编码面试由五到七个面试组成。这包括一次体能和资质评估、一两次在线测试和四至六次现场面试，也称为<em class="od">循环。</em></li><li id="a484" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">循环:</strong>现场面试包括一至三次与招聘经理的面试，以及一次评估亚马逊14项领导原则的面试。</li><li id="13fb" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">编码问题:</strong>亚马逊编程问题集中在算法、数据结构、谜题等方面。</li><li id="4b97" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">招聘级别:</strong>亚马逊通常招聘入门级别的员工(总共12名)，该级别的平均年薪为10.6万美元至11.4万美元。</li><li id="7191" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">招聘团队:</strong>亚马逊基于团队招聘。最常见的招聘团队是Alexa和AWS。</li><li id="7453" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">编程语言:</strong>亚马逊对于编码问题更喜欢以下编程语言:Java、C++、Python、Ruby、Perl。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/a20bcb05eae6eeecfad0600936938614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*52aVRuol6zgsmLOR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f1ab" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">亚马逊的14条领导原则</h1><p id="c127" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">尽管亚马逊的编码面试与其他大型科技公司的相似，但他们的流程还是有一些不同，特别是<em class="od">酒吧老板</em>。亚马逊引入了一个名为Bar Raiser的客观第三方面试官，他根据亚马逊的14项领导原则评估候选人。酒吧老板对你是否会被雇佣有完全的否决权。提高门槛者确保亚马逊雇佣该级别候选人中排名前50%的人。</p><p id="9b0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你不太可能知道哪个面试官是酒吧老板。关键是要认真对待面试的每一个部分，并始终假设你正在接受文化契合度和技术能力的评估。你可以在这里阅读<a class="ae oe" href="https://www.amazon.jobs/en/principles" rel="noopener ugc nofollow" target="_blank">亚马逊的14条领导原则</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/47ba8eb8ebe1314661f1b5845bcb3e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDxFTSO6EQOtDrIDIFXemQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6e2d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何准备亚马逊编码面试</h1><p id="62ad" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">既然你对面试有所了解，也知道会问什么样的问题，那么让我们根据亚马逊独特的<a class="ae oe" href="https://www.codinginterview.com/amazon" rel="noopener ugc nofollow" target="_blank">面试流程</a>来学习一些准备策略。</p><h2 id="f6f9" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">更新你的简历</h2><p id="4ee6" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">确保你已经更新了你的简历和LinkedIn个人资料。尽可能使用可交付成果和度量标准，因为它们是您所完成工作的具体例子。通常，招聘人员会浏览LinkedIn寻找候选人。如果亚马逊的招聘人员认为你很合适，他们会联系你(通过电子邮件或LinkedIn)安排时间聊天。</p><h2 id="da78" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">准备编码评估</h2><p id="bc5b" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">这取决于你来参加一个为技术评估做好充分准备的编码面试。我建议至少自学三个月才能成功。这包括选择编程语言、复习基础知识、学习算法、数据结构、系统设计、面向对象编程、操作系统和并发概念。你还需要为行为面试做准备。</p><h2 id="5818" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">与招聘人员一起进行预筛选</h2><p id="f174" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">期待一个15到30分钟的电话，招聘人员会评估你的兴趣水平，并确定你是否适合。招聘人员可能会涉及一些技术方面。他们只是想了解一下你的技能。典型的问题可能包括你过去的工作经历、你对公司/职位的了解、薪水和其他后勤问题。准备好七到十个你自己的问题来问面试官是很重要的。在早期阶段提出问题显示了对该职位的投入和兴趣。</p><h2 id="f1cb" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">在线评估</h2><p id="b434" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">一旦你完成了与招聘人员的通话，他们将进行在线编码测试、调试测试和能力测试。调试部分会有大约六七个问题，你有30分钟的时间来解决。能力部分将有大约14道选择题，涉及基本排列组合和概率等概念。</p><p id="0419" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码测试包括两个问题。你将有大约1.5小时来完成它。预计测试将通过Codility、HackerRank或其他网站进行。期待一些简单到中等的问题，这些问题通常与算法相关。例子包括:</p><ul class=""><li id="0d06" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">反转链表的后半部分</li><li id="e355" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">查找字符串中的所有变位词</li><li id="cbe0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">合并重叠间隔</li></ul><h2 id="efa5" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">电话采访</h2><p id="df0c" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">一旦你通过了预筛选和在线评估，招聘人员会安排你的下一轮面试，可能会和招聘经理或你希望加入的团队的经理一起。在这一阶段，还会有一到三次面试。在这里，他们会问你与简历直接相关的问题，以及数据结构、算法和其他各种适用于该职位的编码问题。您可以编写代码，审查代码，并展示您的技术知识。</p><h2 id="5465" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">现场采访:循环</h2><p id="c6e7" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">如果你成功通过了一系列的电话面试，你将被邀请到现场参观。这一整天的现场访谈被称为循环。一整天，你会遇到四到六个人。预计这些面试一半是技术性的，另一半是评估软技能。准备在白板上解决问题，并讨论您的思考过程。</p><p id="d05e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">亚马逊喜欢测试的概念是数据结构和算法。了解不同类别算法的运行时间、理论限制和基本实现策略非常重要。</p><ul class=""><li id="33a6" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><strong class="la iu">你应该知道的数据结构:</strong>数组、栈、队列、链表、树、图、哈希表</li><li id="e687" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">你应该知道的算法:</strong>广度优先搜索、深度优先搜索、二分搜索法、快速排序、归并排序、动态规划、分治</li></ul><h2 id="21e2" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">提议/不提议</h2><p id="e816" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">一般来说，你会在面试后一周内收到招聘人员的回复。如果你没有得到报价，亚马逊会给你打电话。你可能要再等六个月才能重新申请。如果你的现场面试进行得很顺利，他们会联系你，这时他们会给你一个提议，发给你文件让你签字，并讨论你的任何进一步的问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1788" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">包扎</h1><p id="eb90" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">破解亚马逊编码面试归结于你花在准备上的时间，比如练习编码题，研究行为面试，了解亚马逊的公司文化。没有金奖券，但更多的准备一定会让你成为一个更自信、更令人向往的候选人。</p><p id="0562" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">学习如何清晰地表达你的解决问题的过程伴随着实践和面试经验。记住:如果你没有马上得到一份工作，要有耐心。重新申请或者申请不同的职位/团队都没问题。坚持不懈的意愿很重要。</p><p id="c929" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">继续学习学习！</p></div></div>    
</body>
</html>