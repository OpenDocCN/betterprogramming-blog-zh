<html>
<head>
<title>My Perfect 2020 Stack: A New Stack for a New Generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的完美2020堆栈:面向新一代的新堆栈</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2020-002-my-perfect-2020-stack-43be78df37dd?source=collection_archive---------1-----------------------#2019-12-16">https://betterprogramming.pub/2020-002-my-perfect-2020-stack-43be78df37dd?source=collection_archive---------1-----------------------#2019-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a178" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">从“全栈”到“2020栈”的旅程有一些令人惊讶的赢家和输家</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/7596d86a61fb7bb694603a7a2f2481a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rty_-Nt-Ylpr1_vSqEA_VQ.png"/></div></div></figure><p id="23b6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">还记得web堆栈简单的时候吗？什么时候这些层可以缩成一个四个字母的缩写词，像LAMP或LEMP或LEPP？当你需要的只是廉价的商品硬件、一些开源软件和毅力的时候？</p><p id="2dee" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我第一个成功的网站vintage 1999是由少数几层构建的:HTML4、CSS2、JavaScript3和Apache 1.1，都运行在Linux 2.0内核上。它有38，000页，20年后<a class="ae lr" href="https://crescentbloom.com/?utm_term=MyPerfect2020Stack" rel="noopener ugc nofollow" target="_blank">它仍在把它们推出</a>。</p><p id="d5a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但从那以后我们都变了。哦，我们的筹码增加了多少！</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="e06b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">我的完美2020堆栈</h1><p id="7e7f" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">这是新的十年，新的一代。因此，是时候采用新的堆栈了，即2020堆栈。<strong class="kx iu"> * </strong></p><p id="5c1f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">2020年的堆栈是什么样的？嗯，这很大程度上取决于你想做什么。选择正确的层在很大程度上取决于您需要多大的可伸缩性。</p><p id="bbb1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我最喜欢的是小网站。适合虚拟服务器的那些。不需要负载平衡器或有状态数据存储的应用程序。已经被WordPress占领了很长时间的CMS利基市场。但不是玛丽·近藤的极简服务器。相反，它可以处理持续的流量，而不需要高峰时段的自动供应。</p><p id="4f86" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我的甜蜜点现在有十二层。从下到上，我有:</p><p id="43f8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在基地，Digital Ocean是一家迎合“自己动手”人群的云提供商。我过去一直运行自己的服务器，直到成本高得令人望而却步。机架空间租赁、专用IP地址和带宽每月加起来总共为100美元.但是真正的杀手是电费。一个5美元的数字海洋水滴比我发给我的电力供应商的1.25美元/天要便宜得多。将这些数字相乘，我最终每年节省了数百美元。</p><p id="d8df" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来是带有SELinux的Fedora Linux发行版。安全性是我们所有人都非常关心的问题。SELinux是运行在内核中的广泛的安全网。搭配好的<code class="fe mw mx my mz b">iptables</code>防火墙配置，再没有比这更安全的感觉了。如果你怀疑这种需要，考虑一下这个:在你最喜欢的云提供商上安装一个新的服务器，看看它会多快被坏人攻击。我见过新服务器在不到10分钟的时间内遭受SSH暴力登录尝试！</p><p id="a5e7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我的web服务器是读写服务器，TLS证书来自LetsEncrypt。我曾经是Apache的明星，只需几分钟就能配置和启动新网站。但是因为我已经从PHP迁移到了JavaScript，所以我没有其他选择了。在我尝试模仿Apache以前给我的所有功能之前，Express看起来是一个简单的东西:内容协商、条件缓存、压缩、SEO重写、CORS和内容安全策略。我已经切换到读写服务，它在默认情况下处理所有这些。</p><p id="e094" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">服务器上的应用程序逻辑由Node.js处理。NPM的生态系统似乎有一个包来处理一切，所以组装我需要的东西并将其插入读写服务器是一项简单的任务。发送邮件、与支付网关接口、访问数据库以及我编写的所有其他服务器端API都不需要费力。</p><p id="83c0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我的数据库服务器是MariaDB，开源社区采用的MySQL的更名分支。当我需要存储非结构化的JSON时，我依赖PostgreSQL，因为我可以直接在特定的JSON属性上执行查询——这有点像MongoDB，但熟悉SQL语法。</p><p id="2266" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于跨线通信，我依赖HTTP/2的持久会话和多路复用流。对古老的HTTP/1.1协议的这两项改进改变了我组装文档的方式。首先，行首阻塞的问题消失了，所以不需要图像精灵，即使我有几十个小图像。其次，没有必要将我的JavaScript和CSS文件优化成包。一旦浏览器和服务器之间建立了连接，所有这些小文件就可以不间断地在网络上传输。</p><p id="16b1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于HTML模板，我使用Blue Phrase，它是HTML的完全无损表达，带有简写符号。对我来说，无与伦比的开始和结束标签以及不可读的标签汤的日子已经结束了。我倾向于在每个模板中只使用几个变量(标题，描述，关键字，搜索引擎优化，飞溅，日期等)。)并将它们以声明性的语言风格分散到模板中。</p><p id="badb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我写新的网页时，我专注于我想表达的东西，而不是装饰。为此，我使用Read Write Doc，它有一种不受干扰的写作体验。即使我的最终目标是在一个媒体出版物上发表博文，我也会使用它(它有一个无与伦比的在线所见即所得编辑器)。作为一名经验丰富的代码编辑人员，我更喜欢使用一页等宽的字符，用手敲击键盘，而不是鼠标。无论如何，每当我想看到我的CSS作品时，我可以用一个简单的按键在预览和编辑模式之间切换。</p><p id="6800" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于web组件，我使用了W3C标准:影子DOM、定制元素、HTML <template>和ECMAScript模块。这让我可以把所有的东西都打包，然后在NPM分发。对我来说，最大的优势是shadow DOM提供的隔离。它消除了命名空间的污染，这是CSS的祸根。</template></p><p id="a9e5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">客户端脚本都是模块化的面向对象的ECMAScript。我只在最新的浏览器版本中使用最新的语言特性。也就是说，我只会在<a class="ae lr" href="https://caniuse.com" rel="noopener ugc nofollow" target="_blank">caniuse.com</a>对每个主要浏览器的最新版本全线绿灯的时候使用它。我远离聚脂填料。</p><p id="176a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">CSS是关于排版和布局的，而排版是从正确选择字体开始的。我更喜欢可读性。现在，我也把我使用的所有字体文件放在自己的服务器上，这样我就不会被第三方的带宽限制所阻碍。比如类似这样的:<code class="fe mw mx my mz b">&lt;link href='/fonts/source-serif-pro-400-latin.woff2' rel=preload as=font crossorigin /&gt;</code>。这样做的额外好处是，不用担心FOUT——“无样式文本的闪现”。</p><p id="b618" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，对于图形艺术，我发现自己转向GIMP看光栅png，转向InkScape看矢量SVG。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="16fa" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">失败者</h1><p id="b15d" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">一些旧的最爱和短暂的爱情不再是我的一部分:</p><ul class=""><li id="088f" class="na nb it kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated"><strong class="kx iu"> Photoshop &amp; Illustrator。两个非常好的应用程序满足了我多年的图形艺术需求。我依依不舍地向这些人道别。他们的免费和开源替代品现在满足了我的所有需求。</strong></li><li id="348c" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">jQuery。自从跨浏览器兼容性战争结束后，我就不需要这个了。唯一真正的杀手级特性是它的选择器语法，它非常有用，以至于早在2009年就作为<code class="fe mw mx my mz b">querySelector</code>被添加到DOM中。</li><li id="de86" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><strong class="kx iu"> AJAX。Web 2.0的前身现在是那个时代的遗迹，T2被现代的、更简单的技术取代，XML被JSON取代。</strong></li><li id="24fe" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><strong class="kx iu">萨斯/SCSS。我承认编写没有变量的CSS是没有效率的，所以SASS有了一个好的开始。模块也是一项重要的工作。但是最终，它需要太多的脑力才能有效地在JavaScript中使用。从那时起，CSS已经走过了漫长的道路，像这样的代码争论者和破坏者正在被淘汰。</strong></li><li id="a571" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><strong class="kx iu">贝姆命名。</strong>CSS类名的<em class="no">块元素修饰符</em>方法确实解决了全局名称空间问题，但是代价是过于冗长。我在语义元素上切换到了父/子选择器，避开了标识符和类名，采用了一种更简单的方法，比如:</li></ul><pre class="kk kl km kn gt np mz nq nr aw ns bi"><span id="4340" class="nt ma it mz b gy nu nv l nw nx">header &gt; ul &gt; li<!-- --> {<br/>   ...<br/>}<br/>nav &gt; ul &gt; li<!-- --> {<br/>   ...<br/>}<br/>footer &gt; ul &gt; li<!-- --> {<br/>   ...<br/>}</span></pre><ul class=""><li id="7661" class="na nb it kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">格鲁吉亚&amp;凡尔纳。这两个在我的字库中占据了多年的榜首。我可以相信它们是可用的、可读的。但是一旦有了规则，铸造厂开始分发开源字体，我就开始寻找其他地方。</li><li id="c2cd" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">Babel，Grunt，Gulp，Browserify，WebPack。前四个并不奇怪。但是说WebPack已经没有用了，这有点令人惊讶。这是背景故事。</li></ul><ol class=""><li id="4d09" class="na nb it kx b ky kz lb lc le nc li nd lm ne lq ny ng nh ni bi translated">在具有持久会话和多路复用流的HTTP/2之前，我们依赖这些工具来捆绑我们的资源。但是在HTTP/2的新世界中，捆绑没有给我们带来任何东西。</li><li id="59a2" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq ny ng nh ni bi translated">随着ECMAScript 2015的推出，新的语言特性一落地，我们就争相使用，但有一个问题。如果不将代码传输回ECMAScript 5，我们就无法在野外部署代码。我们依赖Babel作为我们构建过程中的标准步骤。今天，我需要的所有新语言特性到处都有，所以巴别塔是不必要的。</li><li id="a0a5" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq ny ng nh ni bi translated">在动态导入在浏览器中可用之前，我们需要将文件转换回CommonJS格式。现在大多数主流浏览器都支持<code class="fe mw mx my mz b">&lt;script type='module'&gt;</code>(Edge 76+即将推出)，所以我们终于可以和ECMAScript模块打招呼了，和所有其他的说再见了。</li></ol><ul class=""><li id="8f59" class="na nb it kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated"><strong class="kx iu"> JSX。我不明白为什么有人认为这是件好事。“但你会习惯的”从来都不是一个令人信服的论点。</strong></li><li id="df1e" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><strong class="kx iu">功能编程。我将我的函数式编程限制在一行程序中，就像<code class="fe mw mx my mz b">numbers.sort((a, b) =&gt; a - b);</code>对于其他所有事情，我使用面向对象编程。</strong></li></ul></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="d0b3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">获胜者</h1><p id="1810" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">对我来说，真正的明星层是:</p><ul class=""><li id="fce5" class="na nb it kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated"><strong class="kx iu"> JavaScript模块。</strong>服务器端Node.js中的模块被证明是赢家。我很高兴终于可以在客户端使用它们了。</li><li id="a199" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><strong class="kx iu">面向对象的JavaScript。</strong>这可以总结为五条黄金法则:1)用命名类替换匿名对象，2)声明<em class="no">并初始化</em>构造函数中的所有属性，3)立即密封所有对象，4)用不变签名定义方法，5)将<code class="fe mw mx my mz b">this</code>绑定到每个回调。</li><li id="ad97" class="na nb it kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><strong class="kx iu">蓝色短语。用于模板、创作和声明性编程。我依靠它来生成好看且写起来愉快的HTML。</strong></li></ul></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="c6db" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是新的一代，过去几十年的四层堆栈现在是十二层堆栈。冒着听起来老生常谈的风险，我将首先陈述一个显而易见的事实:你的筹码可能会有所不同。我很好奇其他人会提出什么样的<em class="no">完美的2020堆栈</em>。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="c4db" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="no"> *“这是一个新的十年。”当然，如果你是一个纯粹主义者，并且你认为新的十年要到2021年1月1日才开始，你可以保存这篇文章，明年再看。但是你会错过一年的快乐时光。</em></p></div></div>    
</body>
</html>