<html>
<head>
<title>Preventing Smart Contract Attacks on Ethereum — “DELEGATECALL”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防止以太坊上的智能合约攻击——“委托呼叫”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/preventing-smart-contract-attacks-on-ethereum-delegatecall-e864d0042188?source=collection_archive---------5-----------------------#2022-02-22">https://betterprogramming.pub/preventing-smart-contract-attacks-on-ethereum-delegatecall-e864d0042188?source=collection_archive---------5-----------------------#2022-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0a7d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们编写一个易受攻击的智能合约代码，看看攻击是如何工作的，并了解修复它的预防技术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/43c3afc29ab0ec2b757f5d7db38781fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CDZgVHvn9FGeuV7M"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://unsplash.com/@clark_fransa" rel="noopener ugc nofollow" target="_blank">阿诺·弗朗西斯卡</a></p></figure><p id="ce24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe ls lt lu lv b">DELEGATECALL</code>的上下文保持特性，构建无漏洞的定制库并不像最初想象的那样简单。库本身的代码可以是安全的，没有漏洞；然而，当在另一个应用程序的上下文中执行时，新的漏洞可能会出现。为了更好地理解这一点，让我们用斐波那契数来检查一个相当复杂的例子。</p><p id="cfa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们以<code class="fe ls lt lu lv b">FibonacciLib.sol</code>中的库为例，它可以生成斐波那契数列和类似性质的数列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">FibonacciLib.sol</p></figure><p id="d564" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个库提供了一个计算序列中第n个斐波那契数的函数。它还允许用户改变序列的起始数(<code class="fe ls lt lu lv b">start</code>)并计算这个新序列中的第n个类似斐波那契数列的数字。</p><p id="1cec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看一个使用这个库的契约，<code class="fe ls lt lu lv b">FibonacciBalance.sol</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">FbonacciBalance.sol</p></figure><h2 id="1f5e" class="ly lz iq bd ma mb mc dn md me mf dp mg lf mh mi mj lj mk ml mm ln mn mo mp mq bi translated">剥削</h2><p id="0b80" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">该合约允许参与者从合约中提取乙醚，乙醚的数量等于参与者提取订单对应的斐波那契数；也就是说，第一个参与者得到1以太，第二个参与者也得到1以太，第三个参与者得到2以太，第四个参与者得到3以太，第五个参与者得到5以太，以此类推，直到合约的余额低于与所请求的提款相关联的斐波纳契数。</p><p id="61a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经注意到,<code class="fe ls lt lu lv b">start</code>变量已经在库和主契约中使用。在库契约中，<code class="fe ls lt lu lv b">start</code>用于指定斐波那契数列的开始，并被设置为<code class="fe ls lt lu lv b">0</code>，而在主契约中，它被设置为<code class="fe ls lt lu lv b">3</code>。您可能还注意到，FibonacciBalance契约中的fallback函数允许将所有调用传递给库契约，这允许调用库契约的<code class="fe ls lt lu lv b">setStart</code>函数。所以，这个契约的要点是我们保留了变量<code class="fe ls lt lu lv b">start</code>的状态，对吗？但是如果我们使用<code class="fe ls lt lu lv b">setStart</code>函数，那将让我们改变局部<code class="fe ls lt lu lv b">FibonnacciBalance</code>契约中开始变量的状态。如果是这样的话，有人可以提取更多的乙醚，因为<code class="fe ls lt lu lv b">calculatedFibNumber</code>依赖于起始变量。但是实际上，<code class="fe ls lt lu lv b">setStart</code>函数并不改变<code class="fe ls lt lu lv b">FibonacciBalance</code>契约中的开始变量。这份合同的真正问题远比玩弄<code class="fe ls lt lu lv b">start</code>变量更糟糕。</p><p id="5c32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在请注意，在第21行的<code class="fe ls lt lu lv b">withdraw</code>中，我们执行了<code class="fe ls lt lu lv b">fibonacciLibrary.delegatecall(fibSig,withdrawalCounter)</code>。这调用了<code class="fe ls lt lu lv b">setFibonacci</code>函数，它改变了存储<code class="fe ls lt lu lv b">slot[1]</code>，在我们当前的上下文中是<code class="fe ls lt lu lv b">calculatedFibNumber</code>。这当然是可以预料到的(即执行后，<code class="fe ls lt lu lv b">calculatedFibNumber</code>被修改)。但是，记住<code class="fe ls lt lu lv b">FibonacciLib</code>契约中的<code class="fe ls lt lu lv b">start</code>变量位于存储器<code class="fe ls lt lu lv b">slot[0]</code>中，即当前契约中的<code class="fe ls lt lu lv b">fibonacciLibrary</code>地址。这意味着函数<code class="fe ls lt lu lv b">fibonacci</code>将给出错误的答案，因为它引用了<code class="fe ls lt lu lv b">start</code> ( <code class="fe ls lt lu lv b">slot[0]</code>)，这在当前调用上下文中是fibonacciLibrary地址(当解释为<code class="fe ls lt lu lv b">uint</code>时，它通常会很大)。所以很可能<code class="fe ls lt lu lv b">withdraw</code>函数会失败，因为它没有<code class="fe ls lt lu lv b">uint(fibonacciLibrary)</code>数量的乙醚，这是<code class="fe ls lt lu lv b">calculatedFibNumber</code>将返回的。</p><p id="bcbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更糟糕的是，<code class="fe ls lt lu lv b">FibonacciBalance</code>契约允许用户通过第26行的fallback函数调用所有的<code class="fe ls lt lu lv b">fibonacciLibrary</code>函数。这包括<code class="fe ls lt lu lv b">setStart</code>功能，正如我们所讨论的，它允许任何人改变或设置存储<code class="fe ls lt lu lv b">slot[0]</code>。正如我们所讨论的，那个存储<code class="fe ls lt lu lv b">slot[0]</code>就是<code class="fe ls lt lu lv b">fibonacciLibrary</code>地址。因此，攻击者可以创建一个恶意契约，将地址转换成一个<code class="fe ls lt lu lv b">uint</code>(在Python中使用<code class="fe ls lt lu lv b">int('&lt;address&gt;',16)</code>可以很容易地做到这一点)，然后调用<code class="fe ls lt lu lv b">setStart(&lt;attack_contract_address_as_uint&gt;)</code>。它会把<code class="fe ls lt lu lv b">fibonacciLibrary</code>改成攻击契约的地址。然后，每当用户调用<code class="fe ls lt lu lv b">withdraw</code>或fallback函数时，恶意契约就会运行，窃取契约的全部余额。</p><p id="ed2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种攻击契约的一个例子是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Attack.sol</p></figure><h2 id="892c" class="ly lz iq bd ma mb mc dn md me mf dp mg lf mh mi mj lj mk ml mm ln mn mo mp mq bi translated">预防措施</h2><p id="3480" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Solidity中提供的<code class="fe ls lt lu lv b">library</code>关键字确保了库契约的无状态性和不可自毁性，使其更加可靠。</p><h2 id="a881" class="ly lz iq bd ma mb mc dn md me mf dp mg lf mh mi mj lj mk ml mm ln mn mo mp mq bi translated">真实世界黑客示例:平价Multisig钱包(第二次黑客攻击)</h2><p id="b488" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">图书馆合同:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">WalletLibrary.sol</p></figure><p id="8923" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">钱包合同:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">钱包. sol</p></figure><p id="aafc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，<code class="fe ls lt lu lv b">Wallet</code>契约通过委托调用将所有调用传递给<code class="fe ls lt lu lv b">WalletLibrary</code>契约。这段代码中的常量<code class="fe ls lt lu lv b">_walletLibrary</code>地址充当实际部署的<code class="fe ls lt lu lv b">WalletLibrary</code>合同(位于<code class="fe ls lt lu lv b">0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4</code>)的占位符。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="f442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果还没有，请查看另一个漏洞“可重入性”</p><div class="nd ne gp gr nf ng"><a rel="noopener  ugc nofollow" target="_blank" href="/preventing-smart-contract-attacks-on-ethereum-a-code-analysis-bf95519b403a"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">防止对以太坊的智能合约攻击——代码分析</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">让我们编写一个易受攻击的智能合约代码，看看攻击是如何工作的，并了解修复它的预防技术</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">better编程. pub</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kp ng"/></div></div></a></div></div></div>    
</body>
</html>