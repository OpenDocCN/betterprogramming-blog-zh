<html>
<head>
<title>Persistent Databases Using Docker’s Volumes and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker的卷和MongoDB的持久数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/persistent-databases-using-dockers-volumes-and-mongodb-9ac284c25b39?source=collection_archive---------0-----------------------#2020-04-02">https://betterprogramming.pub/persistent-databases-using-dockers-volumes-and-mongodb-9ac284c25b39?source=collection_archive---------0-----------------------#2020-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2d10" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Docker Compose版本3</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/919f38d163d51904294b66cdd675548f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGFcfAtp-IVSfnG9aG4CPw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@imgix?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> imgix </a>在<a class="ae kv" href="https://unsplash.com/s/photos/storage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="244e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将帮助你理解Docker中的<code class="fe ls lt lu lv b">Volumes</code>，并解释如何使用它们来存储数据。这是第三版Docker Compose的最新指南。</p><p id="9bed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我之前关于Dockerizing Express、Mongo和React的文章中，我使用了一个非持久的容器，在这篇文章中，我将解释如何正确地存储你的数据以及它是如何工作的。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="c79a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">码头工人</h1><p id="55da" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们先来解释一下Docker是如何存储数据的。不管您是使用单个容器和Docker CLI，还是使用多个容器和docker-compose，想法都是一样的。</p><p id="ba7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们运行Docker时，它获取一个图像，这是只读的，并在顶部添加一个额外的层，这是读写的，这是临时存储。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/a2a38f59f953585fad04ab565d1b1f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXEFWUJ4jK-mLfhfwnGWiw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可写层下的基础图像层</p></figure><p id="c108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当容器修改文件或添加数据时，它使用一个可写层来完成。问题是当容器被删除时，层也被删除。当我们重新启动Docker时，我们保存的所有数据都不见了。</p><p id="3079" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种技术称为<a class="ae kv" href="https://docs.docker.com/glossary/#copy-on-write" rel="noopener ugc nofollow" target="_blank">写入时复制</a>，通常它会加快启动时间和整体性能，并最大限度地减少映像的占用空间。</p><p id="adba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了能够持久存储数据，Docker提出了卷的概念。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9a3e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">卷</h1><p id="090f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">卷基本上是容器之外的数据存储，存在于主机文件系统中。有两种类型的卷，Docker管理的卷和绑定装载卷。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/f58ef149d6bb8ea5c90a6fb21e46cfd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypKs6Czr8L8uV9CRjnvM4w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nickoloff，J. (2016) Docker在行动</p></figure><p id="d798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所示，您可以看到容器是独立于卷的实体，存储在主机的硬盘上。它们所在的路径取决于卷的类型。</p><h2 id="ff76" class="nc me iq bd mf nd ne dn mj nf ng dp mn lf nh ni mp lj nj nk mr ln nl nm mt nn bi translated">绑定装载卷</h2><p id="3f3b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">顾名思义，这些卷指向主机文件系统上用户指定的位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/68275b201fc1841ae7e2b7e880b97626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUPk-iAdcofNOSax8uJ1Sg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nickoloff，J. (2016) Docker在行动</p></figure><p id="54a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在Mongo中使用它们，我们必须指定一个到主机驱动器上所选位置的路径，它必须是一个绝对路径。在我们的例子中，这将是<code class="fe ls lt lu lv b">~/mongo/data</code>。</p><p id="e441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将这个位置绑定到Mongo在一个容器中的数据位置，这个容器就是<code class="fe ls lt lu lv b">/data/db</code>。使用Docker CLI定义卷是通过使用<code class="fe ls lt lu lv b">-v</code>或<code class="fe ls lt lu lv b">--volume</code>标志完成的。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="6a27" class="nc me iq lv b gy nt nu l nv nw">docker run -d --name db \<br/>  -v ~/mongo/data:/data/db \ <br/>  -p 27017:27017 \<br/>  mongo:latest</span></pre><p id="17be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以对<code class="fe ls lt lu lv b">docker-compose</code>文件做同样的事情，语法非常相似。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="cdb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">优点</strong></p><ul class=""><li id="1463" class="nz oa iq ky b kz la lc ld lf ob lj oc ln od lr oe of og oh bi translated">如果您需要将几个容器指向一个存储，这非常有用。</li><li id="7ad9" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated">如果您删除带有<code class="fe ls lt lu lv b">-v</code>标志的容器，该卷仍然存在。</li><li id="0489" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated">您知道数据在主机文件系统中的确切位置。</li></ul><p id="7daf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">缺点</strong></p><ul class=""><li id="c440" class="nz oa iq ky b kz la lc ld lf ob lj oc ln od lr oe of og oh bi translated">很难移除，你必须手动移除。</li><li id="0973" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated">将容器绑定到一个特定的主机。</li><li id="5df8" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated">由于许多confiners使用同一个卷，很容易覆盖数据。</li><li id="feed" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated">在具有许多容器和卷的大型系统中管理起来很复杂。</li></ul><h2 id="5995" class="nc me iq bd mf nd ne dn mj nf ng dp mn lf nh ni mp lj nj nk mr ln nl nm mt nn bi translated">Docker管理的卷</h2><p id="4e28" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">托管卷由Docker守护程序自动创建。用户不能选择位置，因为它们是在Docker拥有的主机文件系统部分中创建的。</p><p id="9f9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker用卷自己的id创建一个目录。所有被管理的卷都存储在同一个Docker目录中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/57e5605528e1b4776f58d86bac363cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RhW4I9Wrv-3DmQg34jQ4vw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nickoloff，J. (2016) Docker在行动</p></figure><p id="d04e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用起来相当容易，对于Mongo来说，只需要在容器<code class="fe ls lt lu lv b">/data/db</code>中提供Mongo的数据位置。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="907b" class="nc me iq lv b gy nt nu l nv nw">docker run -d --name db \<br/>  -v /data/db \ <br/>  -p 27017:27017 \<br/>  mongo:latest</span></pre><p id="d15a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe ls lt lu lv b">docker-compose</code>文件也是如此。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f08d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">优点</strong></p><ul class=""><li id="f7e4" class="nz oa iq ky b kz la lc ld lf ob lj oc ln od lr oe of og oh bi translated">拆卸容器时便于拆卸，<code class="fe ls lt lu lv b">docker rm &lt;name&gt; -v</code>。</li><li id="c5f7" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated">绑定到单个容器。</li><li id="a9ae" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated">独立于宿主。</li><li id="57bc" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated">在具有许多容器和卷的大型系统中更易于管理。</li></ul><p id="ae9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">缺点</strong></p><ul class=""><li id="4c6c" class="nz oa iq ky b kz la lc ld lf ob lj oc ln od lr oe of og oh bi translated">当您在删除容器时忘记使用<code class="fe ls lt lu lv b">-v</code>时，很难删除。</li><li id="fb82" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated">与许多容器共享一个卷更加困难。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="129b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">共享Docker管理的卷</h1><p id="c2d6" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为了在容器之间共享Docker管理的卷，我们将使用<em class="oo">卷容器模式</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/a7dff2154029af679b7ac90e80a1307b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Tomha3ghMWZZ8CrLUGosQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nickoloff，J. (2016) Docker在行动</p></figure><p id="3f99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种模式，我们创建两个容器并将它们链接到一个卷。首先，我们创建一个<em class="oo">卷容器</em>作为Docker管理的卷，我们用前缀<code class="fe ls lt lu lv b">vc_</code>调用这个映像。在我们的例子中，这将是<code class="fe ls lt lu lv b">vc_db</code>。</p><p id="8e39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是使用顶级的<a class="ae kv" href="https://docs.docker.com/compose/compose-file/#volumes" rel="noopener ugc nofollow" target="_blank"> volumes </a>键创建一个命名卷。</p><p id="d181" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker Compose版本3中提供了此功能。旧版本使用了<code class="fe ls lt lu lv b">--volumes-from</code>标志。</p><p id="ef6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ls lt lu lv b">docker-compose</code>文件应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="02d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些人可能会注意到没有用于<code class="fe ls lt lu lv b">vc_db</code>容器的端口。不需要它们，因为我们不会连接到它。它只是用来保持与共享卷的连接。</p><p id="9532" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们必须将两个映像链接到我们创建的命名卷。语法与绑定模块非常相似，但是我们只提供卷的名称，而不是卷的绝对路径。在我们的例子中，是<code class="fe ls lt lu lv b">shared_database</code>。</p><p id="c9fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们仍然使用MongoDB的数据位置<code class="fe ls lt lu lv b">/data/db</code>，就像在<em class="oo">容器</em>中一样。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="71c7" class="nc me iq lv b gy nt nu l nv nw">volumes: shared_database:/data/db</span></pre><p id="745d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们更新我们的<code class="fe ls lt lu lv b">docker-compose</code>文件，并将绑定添加到指定的卷。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="fbd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式背后的思想是:</p><ol class=""><li id="beb2" class="nz oa iq ky b kz la lc ld lf ob lj oc ln od lr oq of og oh bi translated">能够轻松地与其他容器共享一个卷，只需绑定指定的卷。</li><li id="5798" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oq of og oh bi translated">无论何时出于某种原因删除主数据库映像，即使使用了<code class="fe ls lt lu lv b">-v</code>标志，卷仍然存在。只要卷连接到至少一个容器，就不能删除卷。</li><li id="c05c" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oq of og oh bi translated">因为我们使用Docker管理的卷，所以我们得到了上面提到的所有好处。</li></ol><p id="56a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢你花时间阅读它。我希望这能帮助你更好地理解Docker的卷，并鼓励你使用这一基本功能。</p></div></div>    
</body>
</html>