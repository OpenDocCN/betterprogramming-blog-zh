<html>
<head>
<title>How to Create Modals in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中创建模态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modals-in-reactjs-631d801e2723?source=collection_archive---------9-----------------------#2020-06-03">https://betterprogramming.pub/modals-in-reactjs-631d801e2723?source=collection_archive---------9-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="101c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带Redux和挂钩</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a4a3ad94232dd5b76c1f22fe4abd4564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pPENihfnxABlNFE6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hojipago?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">姚</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="8517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我开始使用React时，我的第一个任务是创建一个模态对话框，在其中显示一些数据。我花了很多时间谷歌如何创建一个函数，我可以调用它来显示一些窗口。对我来说这是很自然的事。甚至VanillaJs也允许你只调用<code class="fe lv lw lx ly b">alert</code>函数来显示一个简单的对话框。我不明白为什么反应不是这样。</p><p id="6fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你看，React不是这样工作的。React的一个主要概念是，如果你有一个状态并且它没有改变，你可以任意多次渲染页面，它看起来总是一样的。但是调用显示一些模态的函数违背了这个原则。模态的显示不是基于组件的状态，而是基于一些函数调用。</p><p id="edea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们该怎么做呢？</p><p id="19a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们有一个应该打开模态的组件。我们将有一个简单的按钮组件，点击按钮时，我们会希望一个确认框打开。它将记录到控制台“让我们做吧！”如果<code class="fe lv lw lx ly b">confirm</code>被接受，并且如果<code class="fe lv lw lx ly b">confirm</code>被取消，将不做任何事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="69d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？但是现在让我们制作自己的<code class="fe lv lw lx ly b">confirm</code>模态，去掉内置的<code class="fe lv lw lx ly b">confirm</code>。我们要做的是给组件添加一个状态，添加一个名为<code class="fe lv lw lx ly b">openConfirm</code>的标志，并基于此呈现我们自己的组件。然后，我们将提供一个应该在confirm上调用的方法，作为我们的模态组件的一个属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还必须创建带有一些自定义样式的<code class="fe lv lw lx ly b">CustomConfirm</code>组件，并将道具正确链接到按钮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="5756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧，完成了！这就是你如何用React方式创建简单的模态。</p><p id="9567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们开始庆祝之前，让我们考虑一个更复杂的情况。在多个项目中，我需要从应用程序的不同部分打开不同的模态，加载一些rest API数据。您可能知道，如果您想在React中从应用程序的不同部分更改组件的状态，您将使用像<a class="ae ky" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux </a>或<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>这样的全局状态提供者。您可能不希望每个模态都有一个单独的减速器——特别是如果您有很多减速器的话。</p><p id="aa5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我创建了一个公共模态组件来显示所有不同的模态，同时关心Redux的状态管理和打开/关闭模态。让我们来看看你如何做同样的事情。</p><p id="cbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这种方法将与Redux的商店紧密绑定，所以让我们从那里开始。首先，我们需要一些模态缩减器，它将包含关于我们的模态的数据并围绕它们进行操作。一般来说，我们需要两种动作类型:</p><ul class=""><li id="eb83" class="mb mc it lb b lc ld lf lg li md lm me lq mf lu mg mh mi mj bi translated">具有给定数据的给定类型的打开模式。</li><li id="9637" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated">关闭模态。</li></ul><p id="32e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在减速器中很容易实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="bfe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个缩减器只做两件事:如果调度了<code class="fe lv lw lx ly b">OPEN_MODAL</code>动作，则设置给定的数据；如果调度了<code class="fe lv lw lx ly b">CLOSE_MODAL</code>动作，则设置状态为<code class="fe lv lw lx ly b">null</code>。为了更好地理解发送给<code class="fe lv lw lx ly b">OPEN_MODAL</code>的数据，让我们看一下动作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们做了一个异步操作并获得了一些数据(在本例中，<code class="fe lv lw lx ly b">profile</code>)。然后，我们用我们想要显示的模态类型和我们想要传递到那里的任何数据来调度<code class="fe lv lw lx ly b">OPEN_MODAL</code>动作。我们现在需要做的就是在一个组件中使用这些数据，这个组件将包装我们所有的模态窗口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里做的是将我们的模态数据从一个全局状态连接到<code class="fe lv lw lx ly b">Modal</code>组件。我们还提供了一个函数作为道具，允许调度<code class="fe lv lw lx ly b">closeModal</code>动作。然后我们获取这些数据并呈现一个模态窗口。</p><pre class="kj kk kl km gt mp ly mq mr aw ms bi"><span id="8e8f" class="mt mu it ly b gy mv mw l mx my">&lt;div className="modal"&gt;<br/>...<br/>&lt;/div&gt;</span></pre><p id="a63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的模态窗口，具有所有必要的样式。在里面，我们对<code class="fe lv lw lx ly b">modal.type</code>进行了检查。基于此，我们显示正确的模态体(在我们的例子中，<code class="fe lv lw lx ly b">ProfileModal</code>)。然后我们有一个关闭按钮，允许我们关闭窗口。当然，在真实的app中，你也可以添加一些花哨的标题和页脚。现在剩下要做的就是将<code class="fe lv lw lx ly b">Modal</code>组件添加到我们的应用程序的根组件中，这样每次打开一些模态时，<code class="fe lv lw lx ly b">Modal</code>组件就可以被渲染。在我的例子中，我只是把它放在<code class="fe lv lw lx ly b">App.js</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="121c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们在这里所做的只是创建一个按钮来调度<code class="fe lv lw lx ly b">openProfile</code>动作，该动作获取一些API数据，然后打开一个模态。</p><p id="f957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我们创建了通用的模态组件。我知道这种方法看起来太复杂，无法显示一个愚蠢的模态窗口。但是通过这样做，并且实际上遵循React的思维方式，您将会创建漂亮而干净的组件，这些组件易于重用并且易于测试。</p><p id="608c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/rochus222/medium-modal-service" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看整个工作app。</p></div></div>    
</body>
</html>