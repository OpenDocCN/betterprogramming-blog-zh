<html>
<head>
<title>Using JavaScript’s Object Constructor —Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript的对象构造函数—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-javascripts-object-constructor-entries-and-descriptors-7c76f28fae8e?source=collection_archive---------22-----------------------#2020-01-02">https://betterprogramming.pub/using-javascripts-object-constructor-entries-and-descriptors-7c76f28fae8e?source=collection_archive---------22-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d73f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">条目和描述符</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/269e7e8d78952621b7aa9db948e8b40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4f1uB0mVb1OQ1myY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="aa4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，<code class="fe lv lw lx ly b">object</code>构造函数让我们用给定的值创建对象包装器。如果将<code class="fe lv lw lx ly b">null</code>或<code class="fe lv lw lx ly b">undefined</code>传递给<code class="fe lv lw lx ly b">object</code>构造函数，它将创建一个空对象。如果传入构造函数的值已经是一个对象，那么它将返回该对象。</p><p id="fa95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">object</code>构造函数有两个属性。它有一个始终为1的<code class="fe lv lw lx ly b">length</code>属性，像所有其他对象一样，<code class="fe lv lw lx ly b">object</code>构造函数有一个原型来获取类型<code class="fe lv lw lx ly b">object</code>的所有附加属性。</p><p id="fc89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续《T21》第1部分，构造函数<code class="fe lv lw lx ly b">object</code>有许多有用的方法，不用构造新的对象就可以使用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="63dc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.fromEntries()</code></h1><p id="0df5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.fromEntries()</code>方法接受一个包含键-值对的数组，其中键作为第一个元素，对应键的值作为第二个元素。我们还可以将其他具有相同类型数组的iterables传入该方法。</p><p id="ff9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以编写以下代码来传入一个键值对数组以创建一个对象:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="580d" class="nh mh it ly b gy ni nj l nk nl">const entries = [<br/>  [<br/>    ['a', 1],<br/>    ['b', 2]<br/>  ]<br/>];</span><span id="406f" class="nh mh it ly b gy nm nj l nk nl">const obj = Object.fromEntries(entries);</span><span id="4808" class="nh mh it ly b gy nm nj l nk nl">console.log(obj);</span></pre><p id="e55d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码时，我们可以从<code class="fe lv lw lx ly b">console.log</code>输出中看到，结果对象<code class="fe lv lw lx ly b">obj</code>应该是<code class="fe lv lw lx ly b">{a: 1, b: 2}</code>。我们可以传入其他可记录的东西，比如地图:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4422" class="nh mh it ly b gy ni nj l nk nl">const entries = new Map([<br/>  ['a', 1],<br/>  ['b', 2]<br/>]);</span><span id="9d6e" class="nh mh it ly b gy nm nj l nk nl">const obj = Object.fromEntries(entries);</span><span id="8dc6" class="nh mh it ly b gy nm nj l nk nl">console.log(obj);</span></pre><p id="da23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到同样的事情被记录下来。此外，我们可以使用以下代码将数组转换为对象:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7eae" class="nh mh it ly b gy ni nj l nk nl">const arr = [1,2,3];<br/>const entries = arr.map((value, index) =&gt; [index, value]);</span><span id="0ec1" class="nh mh it ly b gy nm nj l nk nl">const obj = Object.fromEntries(entries);</span><span id="679d" class="nh mh it ly b gy nm nj l nk nl">console.log(obj);</span></pre><p id="5440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当上面的代码运行时，我们得到<code class="fe lv lw lx ly b">{0: 1, 1: 2, 2: 3}</code>,因为我们将每个数组条目的索引映射到键，并将每个数组条目的值映射到值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2238" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.getOwnPropertyDescriptor()</code></h1><p id="197b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.getOwnPropertyDescriptor()</code>方法获取对象中属性的属性描述符并返回它。顾名思义，它只获取对象本身的属性描述符，而不是原型链的上游。</p><p id="d7fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性描述符是一个对象，其属性名作为关键字，属性<code class="fe lv lw lx ly b">writable</code>、<code class="fe lv lw lx ly b">configurable</code>、<code class="fe lv lw lx ly b">enumerable</code>和<code class="fe lv lw lx ly b">value</code>作为属性名关键字的属性。</p><p id="0eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">writable</code>指财产的价值可以改变。<code class="fe lv lw lx ly b">configurable</code>表示属性描述符可能被更改，并且属性是否可以从对象中删除。</p><p id="be7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">enumerable</code>属性意味着该属性在用<code class="fe lv lw lx ly b">for...in</code>循环枚举属性的过程中出现，<code class="fe lv lw lx ly b">value</code>是该属性的值。</p><p id="b5e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们用以下命令记录一个对象的属性描述符:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="880e" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  a: 1<br/>}</span><span id="2875" class="nh mh it ly b gy nm nj l nk nl">const descriptor = Object.getOwnPropertyDescriptor(obj, 'a');<br/>console.log(descriptor);</span></pre><p id="2e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe lv lw lx ly b">{value: 1, writable: true, enumerable: true, configurable: true}</code>。<code class="fe lv lw lx ly b">value</code>是属性的值，其余的属性是属性描述符的属性。如果我们有属性getters和setters，它们也会随方法调用一起返回:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4f3d" class="nh mh it ly b gy ni nj l nk nl">let obj = {};<br/>let value;<br/>Object.defineProperty(obj, 'a', {<br/>  get() {<br/>    return value;<br/>  },<br/>  set(a) {<br/>    value = a;<br/>  }<br/>});<br/><br/>const descriptor = Object.getOwnPropertyDescriptor(obj, 'a');<br/>console.log(descriptor);</span></pre><p id="d291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当上面的代码运行时，我们在描述符对象中获得了<code class="fe lv lw lx ly b">get</code>和<code class="fe lv lw lx ly b">set</code>函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="77dd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.getOwnPropertyDescriptors()</code></h1><p id="c294" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当<code class="fe lv lw lx ly b">Object.getOwnPropertyDescriptor()</code>获取单个对象的属性描述符时，<code class="fe lv lw lx ly b">Object.getOwnPropertyDescriptors()</code>获取一个对象中一个对象的所有属性描述符——同样没有这个对象在原型链上继承的属性，属性名作为键，对应属性名键的属性描述符作为值。</p><p id="8086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b9cc" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  a: 1,<br/>  b: 2<br/>}<br/>const descriptors = Object.getOwnPropertyDescriptors(obj);<br/>console.log(descriptors);</span></pre><p id="895e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5c00" class="nh mh it ly b gy ni nj l nk nl">{<br/>  "a": {<br/>    "value": 1,<br/>    "writable": true,<br/>    "enumerable": true,<br/>    "configurable": true<br/>  },<br/>  "b": {<br/>    "value": 2,<br/>    "writable": true,<br/>    "enumerable": true,<br/>    "configurable": true<br/>  }<br/>}</span></pre><p id="b511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们获得每个属性的所有值和属性描述符属性。像<code class="fe lv lw lx ly b">Object.getOwnPropertyDescriptor()</code>一样，这个方法对属性描述符有相同的定义。</p><p id="edad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性描述符是一个对象，其属性名作为关键字，属性<code class="fe lv lw lx ly b">writable</code>、<code class="fe lv lw lx ly b">configurable</code>、<code class="fe lv lw lx ly b">enumerable</code>和<code class="fe lv lw lx ly b">value</code>作为属性名关键字的属性。</p><p id="d225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">writable</code>意味着财产的价值可以改变。<code class="fe lv lw lx ly b">configurable</code>表示属性描述符可以被改变，并且属性是否可以从对象中删除。</p><p id="8790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">enumerable</code>属性表示该属性在用<code class="fe lv lw lx ly b">for...in</code>循环枚举属性时出现，<code class="fe lv lw lx ly b">value</code>是该属性的值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="981e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.getOwnPropertyNames()</code></h1><p id="057c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.getOwnPropertyNames()</code>方法返回一个属性名数组，这些属性名是在对象本身而不是原型链上的任何对象中定义的。除了符号属性以外，还会返回不可枚举的属性。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9218" class="nh mh it ly b gy ni nj l nk nl">let obj = {<br/>  a: 1,<br/>  b: 2<br/>}</span><span id="a9c6" class="nh mh it ly b gy nm nj l nk nl">Object.defineProperty(obj, 'c', {<br/>  "value": 2,<br/>  "writable": true,<br/>  "enumerable": false,<br/>  "configurable": true<br/>})</span><span id="1b64" class="nh mh it ly b gy nm nj l nk nl">const names = Object.getOwnPropertyNames(obj);<br/>console.log(names);</span></pre><p id="356f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们会返回<code class="fe lv lw lx ly b">[“a”, “b”, “c”]</code>,因为除了用符号标识的属性之外，所有定义的属性都会返回。如果我们的对象中有符号，我们将不会在返回的数组中看到它。例如，如果我们有</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a3af" class="nh mh it ly b gy ni nj l nk nl">let obj = {<br/>  a: 1,<br/>  b: 2,<br/>  [Symbol('foo')]: 3<br/>}<br/>Object.defineProperty(obj, 'c', {<br/>  "value": 4,<br/>  "writable": true,<br/>  "enumerable": false,<br/>  "configurable": true<br/>})<br/>const names = Object.getOwnPropertyNames(obj);<br/>console.log(names);</span></pre><p id="8678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们仍然会看到<code class="fe lv lw lx ly b">[“a”, “b”, “c”]</code>，因为符号没有包含在数组中。我们用<code class="fe lv lw lx ly b">Object.getOwnPropertySymbols()</code>来获取用符号标识的属性。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="14ec" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.getOwnPropertySymbols()</code></h1><p id="f615" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.getOwnPropertySymbols()</code>返回一个符号数组，这些符号在一个对象的属性中被用作标识符。</p><p id="b234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它只获取用符号命名的属性标识符，没有其他内容。</p><p id="e99b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它不会遍历原型链来获取原型链上的对象的属性。例如，如果我们有以下代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9503" class="nh mh it ly b gy ni nj l nk nl">let obj = {<br/>  a: 1,<br/>  b: 2,<br/>  [Symbol('foo')]: 3<br/>}<br/>Object.defineProperty(obj, 'c', {<br/>  "value": 4,<br/>  "writable": true,<br/>  "enumerable": false,<br/>  "configurable": true<br/>})<br/>const symbols = Object.getOwnPropertySymbols(obj);<br/>console.log(symbols);</span></pre><p id="6d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如预期的那样记录了<code class="fe lv lw lx ly b">[Symbol(foo)]</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f142" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.getPrototypeOf()</code></h1><p id="e3e5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.getPrototypeOf()</code>方法获取对象的原型，与指定对象的<code class="fe lv lw lx ly b">[[Prototype]]</code>属性相同。例如，如果我们有</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ea49" class="nh mh it ly b gy ni nj l nk nl">const prototype1 = {};<br/>const obj = Object.create(prototype1);<br/>console.log(Object.getPrototypeOf(obj) === prototype1);</span></pre><p id="ca72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">console.log</code>将输出<code class="fe lv lw lx ly b">true</code>，因为<code class="fe lv lw lx ly b">Object.create</code>的第一个参数是它返回的对象的原型对象；同样，如果我们使用<code class="fe lv lw lx ly b">Object.setPrototypeOf()</code>方法来设置一个现有对象的原型。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e11a" class="nh mh it ly b gy ni nj l nk nl">const prototype2 = {};<br/>let obj2 = {};<br/>Object.setPrototypeOf(obj2, prototype2);<br/>console.log(Object.getPrototypeOf(obj2) === prototype2);</span></pre><p id="2b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于明确设置了<code class="fe lv lw lx ly b">obj2</code>的原型，<code class="fe lv lw lx ly b">console.log</code>也会输出<code class="fe lv lw lx ly b">true</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/7695644a03c7d754f1a44a1c89c9cd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kPHMrXvuwP3WCFGM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼古拉斯·托马斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8415" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.is()</code></h1><p id="675c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.is()</code>方法比较在其参数中传递的两个对象是否是相同的值。两个值相同，如果它们是:</p><ul class=""><li id="e00e" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">两者<code class="fe lv lw lx ly b">undefined</code></li><li id="b287" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">双双<code class="fe lv lw lx ly b">null</code></li><li id="ffe8" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">两个<code class="fe lv lw lx ly b">true</code>或两个<code class="fe lv lw lx ly b">false</code></li><li id="ef62" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">两个字符串长度相同，字符顺序相同</li><li id="67d3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">两个对象具有相同的引用</li><li id="26c1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">两个数字和都是<code class="fe lv lw lx ly b">+0</code>，或者都是<code class="fe lv lw lx ly b">-0</code>，或者都是<code class="fe lv lw lx ly b">NaN</code>，或者都是非零且都不是<code class="fe lv lw lx ly b">NaN</code>，并且它们都具有相同的值</li></ul><p id="d961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不像<code class="fe lv lw lx ly b">==</code>操作符那样转换类型来比较对象，也不将真值或假值转换成布尔值。此外，这与使用<code class="fe lv lw lx ly b">===</code>运算符比较对象不同，因为使用<code class="fe lv lw lx ly b">===</code>运算符时，<code class="fe lv lw lx ly b">-0</code>和<code class="fe lv lw lx ly b">+0</code>相等，<code class="fe lv lw lx ly b">NaN</code>与自身不同。</p><p id="8e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以进行以下比较:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ffe2" class="nh mh it ly b gy ni nj l nk nl">Object.is('a', 'a');             // true<br/>Object.is(document, document);   // true<br/><br/>Object.is('a', 'b');             // false<br/>Object.is([], []);               // false<br/><br/>const obj = { a: 1 };<br/>const obj2 = { a: 1 };<br/>Object.is(obj, obj);             // true<br/>Object.is(obj, obj2);            // false<br/><br/>Object.is(null, null);           // true<br/><br/>Object.is(0, -0);                // false<br/>Object.is(-0, -0);               // true<br/>Object.is(NaN, 0/0);             // true</span></pre><p id="0e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，只有对象引用和值被比较。对象的内容不会被比较，所以即使两个对象有相同的内容，它们仍然被认为是不同的，因为它们在内存中的引用是不同的，因为它们是由两个不同的变量定义的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="0adb" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated"><code class="fe lv lw lx ly b">Object.isExtensible()</code></h2><p id="07aa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">方法检查一个对象的属性是否是可扩展的。也就是说，如果一个对象可以添加新的属性。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e9b8" class="nh mh it ly b gy ni nj l nk nl">const obj = {};<br/>const obj2 = {};</span><span id="5d23" class="nh mh it ly b gy nm nj l nk nl">console.log(Object.isExtensible(obj));</span><span id="8899" class="nh mh it ly b gy nm nj l nk nl">Object.preventExtensions(obj2);</span><span id="c420" class="nh mh it ly b gy nm nj l nk nl">console.log(Object.isExtensible(obj2));</span></pre><p id="5cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe lv lw lx ly b">console.log(Object.isExtensible(obj));</code>将记录<code class="fe lv lw lx ly b">true</code>，因为我们没有明确阻止向<code class="fe lv lw lx ly b">obj</code>添加新属性。然而，<code class="fe lv lw lx ly b">console.log(Object.isExtensible(obj2));</code>将记录<code class="fe lv lw lx ly b">false</code>，因为我们调用了<code class="fe lv lw lx ly b">Object.preventExtensions(obj2);</code>来防止新的属性被添加到<code class="fe lv lw lx ly b">obj2</code>中。</p><p id="3736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行下面的代码，我们也会在两个<code class="fe lv lw lx ly b">console.log</code>语句中记录<code class="fe lv lw lx ly b">false</code>，因为我们明确地阻止了对象<code class="fe lv lw lx ly b">obj</code>和<code class="fe lv lw lx ly b">obj2</code>分别使用<code class="fe lv lw lx ly b">Object.freeze()</code>和<code class="fe lv lw lx ly b">Object.seal()</code>方法添加新属性:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4a3c" class="nh mh it ly b gy ni nj l nk nl">const obj = {};<br/>const obj2 = {};<br/>Object.freeze(obj);<br/>console.log(Object.isExtensible(obj));</span><span id="ea53" class="nh mh it ly b gy nm nj l nk nl">Object.seal(obj2);<br/>console.log(Object.isExtensible(obj2));</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="befb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><code class="fe lv lw lx ly b">Object.isFrozen()</code></h1><p id="f099" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.isFrozen()</code>方法确定一个对象是否被冻结。冻结意味着对象中的所有属性值都不能更改。此外，不能向其添加新属性，也不能更改冻结对象的现有属性描述符。物体被冻结在原地。该方法不返回新的冻结对象。相反，它返回冻结前的原始对象。冻结对象的原型也不能改变。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="457e" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  a: 1<br/>};</span><span id="4af6" class="nh mh it ly b gy nm nj l nk nl">console.log(Object.isFrozen(obj));</span></pre><p id="4a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe lv lw lx ly b">console.log</code>语句中得到<code class="fe lv lw lx ly b">false</code>，因为我们没有通过调用<code class="fe lv lw lx ly b">Object.freeze(obj)</code>来显式冻结对象。另一方面，我们已经冻结了对象，那么<code class="fe lv lw lx ly b">Object.isFrozen()</code>将返回<code class="fe lv lw lx ly b">true</code>。例如:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7abc" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  a: 1<br/>};</span><span id="6fae" class="nh mh it ly b gy nm nj l nk nl">Object.freeze(obj);<br/>console.log(Object.isFrozen(obj));</span></pre><p id="8b6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们从<code class="fe lv lw lx ly b">console.log</code>语句中得到<code class="fe lv lw lx ly b">true</code>，因为我们通过调用<code class="fe lv lw lx ly b">Object.freeze(obj)</code>冻结了对象。如果原始值被传入，<code class="fe lv lw lx ly b">Object.isFrozen()</code>将返回<code class="fe lv lw lx ly b">true</code>，因为它们是不可变的。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a8ec" class="nh mh it ly b gy ni nj l nk nl">console.log(Object.isFrozen(1));<br/>console.log(Object.isFrozen('string'));<br/>console.log(Object.isFrozen(null));<br/>console.log(Object.isFrozen(undefined));<br/>console.log(Object.isFrozen(NaN));<br/>console.log(Object.isFrozen(true));<br/>console.log(Object.isFrozen(Symbol('a')));</span></pre><p id="2f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么所有的<code class="fe lv lw lx ly b">console.log</code>语句都将是<code class="fe lv lw lx ly b">true</code>，因为它们都是不可变的。</p><p id="5326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object</code>构造函数有更多的方法，用于从具有属性的键和值的数组中构造对象，也有方法从对象、属性名称、属性符号中获取属性描述符，获取对象的键，并防止属性被添加或删除或修改它们的属性描述符。</p></div></div>    
</body>
</html>