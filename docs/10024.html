<html>
<head>
<title>Custom Operators in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的客户操作员</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-operators-in-swift-5cf596d27849?source=collection_archive---------14-----------------------#2021-11-15">https://betterprogramming.pub/custom-operators-in-swift-5cf596d27849?source=collection_archive---------14-----------------------#2021-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="462d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对运算符类型、如何使用它们以及它们的缺点的简短介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a5bf3d35dd65a6989bb3bdeb50fad62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJRW0DkwKBrDhSoBIrDEEQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布雷特·赛勒斯的照片</p></figure><p id="542a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift是一种非常灵活的语言，为您提供了许多工具来修改和扩充它。这些增强之一是对自定义或重载运算符的支持。</p><h1 id="e454" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是自定义运算符？</h1><p id="6da4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">除了预定义的运算符集合，Swift还允许您定义自己的运算符，如<code class="fe ms mt mu mv b">==</code>、<code class="fe ms mt mu mv b">+</code>、<code class="fe ms mt mu mv b">-</code>等。有三种不同的类型:<em class="mw">前缀</em>、<em class="mw">后缀</em>和<em class="mw">中缀</em>运算符。</p><h2 id="a271" class="mx lw it bd lx my mz dn mb na nb dp mf li nc nd mh lm ne nf mj lq ng nh ml ni bi translated">前缀和后缀</h2><p id="8e47" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">顾名思义，这些操作符要么在它们各自的目标之前，要么在它们各自的目标之后，比如递增/递减操作符<code class="fe ms mt mu mv b">++</code> / <code class="fe ms mt mu mv b">--</code>。因此，它们是“T21”一元运算符，影响单个值。</p><p id="ca44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要声明前缀或后缀操作符，我们需要在目标类型的扩展中创建一个带有正确修饰符<code class="fe ms mt mu mv b">prefix</code>或<code class="fe ms mt mu mv b">postfix</code>的<code class="fe ms mt mu mv b">static</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="de1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要定义操作符。操作符的可能字符被限制为不干扰其他事物的标识符，如类型、函数等。完整列表可在“<a class="ae ky" href="https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418" rel="noopener ugc nofollow" target="_blank">Swift编程语言</a>中找到。</p><p id="d78a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上并不需要将操作符逻辑放入扩展中。全球发售的<code class="fe ms mt mu mv b">func</code>也可以。但是在扩展中为它们各自的类型添加操作符是一种对它们进行逻辑分组的好方法。</p><h2 id="bea4" class="mx lw it bd lx my mz dn mb na nb dp mf li nc nd mh lm ne nf mj lq ng nh ml ni bi translated">中缀</h2><p id="a851" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作为一个“<a class="ae ky" href="https://en.wikipedia.org/wiki/Binary_operation" rel="noopener ugc nofollow" target="_blank">二元</a>操作符，第三种在它的目标之间工作，可以访问两者，像算术操作符<code class="fe ms mt mu mv b">+</code>、<code class="fe ms mt mu mv b">-</code>、<code class="fe ms mt mu mv b">*</code>、<code class="fe ms mt mu mv b">/</code>等。</p><p id="56aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们的定义非常类似于<em class="mw">中缀</em> / <em class="mw">前缀</em>运算符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经存在的<code class="fe ms mt mu mv b">infix operator -</code>不需要重新定义，但是编译器也没有抱怨。相关的类型不必完全相同，就像我们可以返回我们喜欢的任何类型一样。这允许非常灵活的操作符，比如创建中间类型来创建类似构建器的特定于领域的语言。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8d02" class="lv lw it bd lx ly ns ma mb mc nt me mf jz nu ka mh kc nv kd mj kf nw kg ml mm bi translated">声明运算符</h1><p id="81c6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要定义操作符的功能，首先必须定义它本身。如果我们不想覆盖或重用现有的修饰符，我们必须自己定义它的<a class="ae ky" href="https://en.wikipedia.org/wiki/Order_of_operations" rel="noopener ugc nofollow" target="_blank"> <em class="mw">优先级</em> </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Associative_property" rel="noopener ugc nofollow" target="_blank"> <em class="mw">结合性</em> </a>。</p><p id="d8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运算的顺序，也称为“运算符优先级”，定义了表达式中不同运算符之间的规则。例如，表达式<code class="fe ms mt mu mv b">2 + 3 * 4</code>将导致<code class="fe ms mt mu mv b">14</code>，因为由于运算符优先级，该表达式等效于<code class="fe ms mt mu mv b">2 + (3 * 4)</code>。</p><p id="ae6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结合性定义了相同优先级的操作符在一起使用时应该如何表现。根据我们的逻辑，当表达式<code class="fe ms mt mu mv b">a !! b !! c</code>被赋值<code class="fe ms mt mu mv b">(a !! b) !! c</code>和<code class="fe ms mt mu mv b">a !! (b !! c)</code>时，可能会有不同。这就是为什么我们可以定义如何以及是否可以将多个操作符链接在一起。</p><p id="e7ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经定义了多个precede组，如果我们的操作符不使用现有的组，它默认为<code class="fe ms mt mu mv b">DefaultPrecedenceGroup</code>。</p><p id="275b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些组按“从高到低”排序。所有组名都以<code class="fe ms mt mu mv b">Precedence</code>结尾，为便于阅读，此处省略。</p><pre class="kj kk kl km gt nx mv ny nz aw oa bi"><span id="1857" class="mx lw it mv b gy ob oc l od oe">| Group              | Assoc | Example operators   <br/>| ------------------ | ----- | --------------------------- <br/>| BitwiseShift       | none  | &lt;&lt;  &gt;&gt;                   <br/>| Multiplication     | left  | *  /                     <br/>| Addition           | left  | +  -                     <br/>| RangeFormation     | none  | ...  ..&lt;                 <br/>| Casting            | none  | is  as  as?  as!       <br/>| NilCoalescing      | right | ??                        <br/>| Comparison         | none  | !=  ==  &lt;  &gt;  &lt;=  &gt;= <br/>| LogicalConjunction | left  | &amp;&amp;                        <br/>| LogicalDisjunction | left  | ||                      <br/>| Default            | none  |                             <br/>| Ternary            | right | ?  :                       <br/>| Assignment         | right | =  +=  -=`               </span></pre><p id="587a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义优先组允许我们将运算符放在现有运算符之间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文章中已经提到了优先位置和结合性。但是什么是<code class="fe ms mt mu mv b">assignment</code>属性呢？</p><p id="eac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/master/proposals/0077-operator-precedence.md#assignment" rel="noopener ugc nofollow" target="_blank"> Swift提案SE-0077 </a>中所写，<code class="fe ms mt mu mv b">assignment: true</code>将把操作器折叠成一个可选的链，允许<code class="fe ms mt mu mv b">foo?.bar += 2</code>作为<code class="fe ms mt mu mv b">foo?(.bar += 2)</code>工作，而不是作为<code class="fe ms mt mu mv b">(foo?.bar) += 2</code>没有进行类型检查。</p><p id="b872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获得这些操作符属性可能需要一些“试错法”，或者更好，一组单元测试来定义确切的行为，特别是如果它们是共享框架的一部分。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="90f4" class="lv lw it bd lx ly ns ma mb mc nt me mf jz nu ka mh kc nv kd mj kf nw kg ml mm bi translated">重载运算符</h1><p id="73a7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">另一个要注意的陷阱是重载现有的操作符。没有什么能阻止你为<code class="fe ms mt mu mv b">Int</code>重新定义像<code class="fe ms mt mu mv b">+</code>这样的基本操作符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不认为有必要解释为什么这是一个可怕的想法。如果你重载现有的操作符，或者用不同的类型重用同一个操作符，确保它的目的是清楚的。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="551d" class="lv lw it bd lx ly ns ma mb mc nt me mf jz nu ka mh kc nv kd mj kf nw kg ml mm bi translated">自定义操作符的缺点</h1><p id="1ede" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">尽管自定义操作符很容易创建，并且自定义操作符的可能用例是多种多样的，但是我强烈建议您不要(过度)使用它们！</p><p id="64c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与扩展一样，我们以新的非标准操作符的形式将技术债务引入到我们的项目中。更糟糕的是，它可能是在新的上下文中重用的熟悉的操作符。Onboarding开发人员可能不知道发生了什么，需要搜索文档或操作符声明本身。这将需要一定的心智能力来理解Swift本身之上的“迷你语言”。你不能像用扩展方法一样，用CMD键点击操作符来找到它的定义。</p><p id="1acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我创建了<a class="ae ky" href="https://github.com/netzgut/integral-swift-autolayout" rel="noopener ugc nofollow" target="_blank">库</a>来简化创建带有扩展和自定义操作符的AutoLayout代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="decb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，我创建了一些扩展来避免我一遍又一遍地输入<code class="fe ms mt mu mv b">constraint(</code>或<code class="fe ms mt mu mv b">constant:</code>。代码更加易读和简洁，不需要解释发生了什么。所有需要的信息都还在。</p><p id="bc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还为本文创建了自定义操作符，以创建比扩展方法更直观的“特定于领域的语言”方法。尽管在处理代码时可能会立即提高生产率，但从长远来看，这可能会成为一个问题。</p><p id="5b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果并没有真的努力在每个版本中破坏Xcode、Swift或iOS SDK即使没有自定义操作符或扩展，我们的代码也可能会意外破坏。但是通过引入这样的增强，我们增加了破损的可能性。因此，除了我们的“正常”代码，我们还必须为项目的生命周期维护“支持”代码。恢复到“未扩充”代码可能不像“搜索&amp;替换”那么简单。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="4a11" class="lv lw it bd lx ly ns ma mb mc nt me mf jz nu ka mh kc nv kd mj kf nw kg ml mm bi translated">结论</h1><p id="d3da" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与您可以使用的其他工具和依赖项一样，您需要知道何时值得包含它，并意识到它对您的项目的长期影响。这并不意味着您不应该使用自定义操作符。它们是简化表达式的好工具。但不要为了短期收益把自己画到墙角。</p><p id="a5b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展方法是一个很好的选择，提供了一个更详细的表面和可发现性来解释它们的用例，即使有人不熟悉“幕后”发生的事情。但是它们不会为您提供对它们的使用的控制，比如设置特定的优先级或结合性。</p><h1 id="703c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">资源</h1><ul class=""><li id="a2f5" class="of og it lb b lc mn lf mo li oh lm oi lq oj lu ok ol om on bi translated"><a class="ae ky" href="https://github.com/apple/swift-evolution/blob/master/proposals/0077-operator-precedence.md" rel="noopener ugc nofollow" target="_blank"> Swift提案SE-0077:改进运营商声明</a></li><li id="d868" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html" rel="noopener ugc nofollow" target="_blank">Swift编程语言:高级操作员</a>(Swift编程语言)</li><li id="7ba1" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><a class="ae ky" href="https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418" rel="noopener ugc nofollow" target="_blank">操作符允许字符</a>(Swift编程语言)</li><li id="994d" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Order_of_operations" rel="noopener ugc nofollow" target="_blank">操作顺序</a>(维基百科)</li><li id="07f8" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Associative_property" rel="noopener ugc nofollow" target="_blank">关联属性</a>(维基百科)</li></ul></div></div>    
</body>
</html>