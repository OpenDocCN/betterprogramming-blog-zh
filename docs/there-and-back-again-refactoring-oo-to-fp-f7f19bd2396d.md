# 一去不复返:重构面向对象的函数式编程

> 原文：<https://betterprogramming.pub/there-and-back-again-refactoring-oo-to-fp-f7f19bd2396d>

## 我们能发现一种新的范式“FOOP”吗？

![](img/80bf775551a4d8670127fc113b27cfa7.png)

由[杨紫琼](https://unsplash.com/@jeneyeo?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

函数式编程(FP)最近似乎非常流行。虽然我确实认为 FP 有很多好处，但是我经常很难接受 FP 优于面向对象(OO)编程的教条式的比较。

与流行的观点相反，我认为 OO 和 FP 比看起来更接近。至少，如果 OO 代码是按照坚实的设计原则编写的，这一点似乎尤其正确。

在本文中，我们将探索使用 TypeScript 从可靠的面向对象(OO)代码到更具功能性的编程(FP)风格的重构。

除了“如何做”方面，我们将从可测试性的角度来看每一个重构。我发现这是衡量代码质量的一个很好的标准。如果它易于测试，那么很有可能没有一堆奇怪的状态或隐藏的依赖关系。

事不宜迟…我们来重构一下！

对于这个例子，我们将使用一个非常*非常*简化的银行账户例子。我们将有一个帐户域对象，我们的用例是开立一个新帐户。

正如你在这个例子中看到的，这是一个非常典型的代码。我们有一些无状态的服务类，包含我们用例的业务规则，我们依赖数据层来保存我们的帐户信息。这很容易测试，因为我们可以使用内存数据库或 mock 注入一个假的实现。

在我们对 FP 的第一次重构中，我们需要把它变成一个函数。就像他们说的，“终结是穷人的目标”。所以让我们把它变成一个功能性的闭包。

我们开始工作了吗？不完全是。在这个迭代中，我们仍然有可能保持私有状态，所以让我们去掉闭包，引入一个高阶函数。

嘿，这太酷了！我们将依赖关系直接传递给函数。我们排除了在闭包中保持状态的能力，它仍然是可测试的。感觉就像一个接口有一个方法和一个内置的构造函数。我喜欢。

尽管如此，仍有工作要做。我们能完全排除依赖性吗？首先，我们可以创建 account 对象，并将其提取到自己的函数中。

请注意，`createAccount`函数现在是纯函数。不依赖于接口，我们可以直接编写 saveAccount 函数实现。

最后，我们可以组合这两个来满足我们的用例。

但是等等，这怎么可考！？我们无法将我们的假刀注入到函数中。这里的答案是我们*不*单元测试作文。相反，我们对非常简单的纯部分进行单元测试。

为了测试整个组合，我们需要一个集成测试(名副其实)。

最终，也许我们的目标不是决定使用 OO 还是 FP，而是更多的具有清晰职责和有限耦合的无状态编程。

就像生活中的大多数事情一样，它并不是非黑即白的。注意，所有这些重构从一开始就是可行的。每一个都是无状态的，可测试的，责任明确的！这里的主要区别是通过使用依赖性反转或依赖性拒绝的依赖性管理。

我想我会得出这样的结论，也许平衡就在中间的某个地方。就我个人而言，我更喜欢高阶函数重构。它似乎拥有两个世界的最佳之处，因为它:

*   避免了类和闭包带来的混乱
*   不会把事情做得太细，以至于很难跟踪(功能组合)

也许我们可以发明一种叫做 FOOP 的新模式？感谢阅读！