<html>
<head>
<title>Authentication and Authorization using Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redis进行身份验证和授权</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/authentication-and-authorization-using-redis-49c5f0e6b311?source=collection_archive---------0-----------------------#2019-03-04">https://betterprogramming.pub/authentication-and-authorization-using-redis-49c5f0e6b311?source=collection_archive---------0-----------------------#2019-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/45e635a82f7dbbdec1088ec4a0ff070b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TR1SCU4OIrJnvJycfvZSQ.png"/></div></div></figure><p id="5b57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文是<a class="ae kz" href="https://medium.com/@pankaj.panigrahi/list-of-node-js-articles-ededa6dd304b" rel="noopener"> <strong class="kd iu"> <em class="la">系列文章</em> </strong> </a>的第6篇，它将帮助您掌握Node.js背后的不同概念，并使您能够创建生产就绪的应用程序。这篇文章期望读者了解巴别塔以及如何设置它。如果你需要了解相同的内容，请阅读这篇文章。</p><p id="d03e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当你为你的网站/网络应用构建后端或者一个通用的后端来作为移动和网络应用的后端时，你需要用一个认证层来保护你的API。这些API应该只由登录的用户访问，并且应该根据用户返回结果。</p><p id="c22d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在当今时代，每个人都在寻求基于令牌的认证，而不是基于会话的cookies。OAuth、JWT和带有memcached / redis的随机令牌是最流行的基于令牌的身份验证形式。<br/>这里有一个不错的电子表格，比较了一些常见的身份验证方法:</p><div class="lb lc gp gr ld le"><a href="https://docs.google.com/spreadsheets/d/1tAX5ZJzluilhoYKjra-uHbMCZraaQkqIHl3RIQ8mVkM/edit#gid=0" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">API的认证技术</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">描述将用户名和密码与每个带有用户信息的请求签名或加密的cookie一起传递。通常…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">docs.google.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jz le"/></div></div></a></div><p id="0dda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">免责声明:电子表格由其他作者编写。</p><p id="c298" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JWT和带内存存储的随机令牌各有优缺点。您应该根据项目的需求来使用它们。您可以在下面的文章中找到两者的对比:</p><div class="lb lc gp gr ld le"><a href="https://dzone.com/articles/stop-using-jwts-as-session-tokens" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">停止使用jwt作为会话令牌</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">JSON Web令牌(jwt)现在非常热门。它们在web开发中风靡一时，因为它们时尚、安全…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">dzone.com</p></div></div><div class="ln l"><div class="lt l lp lq lr ln ls jz le"/></div></div></a></div><p id="db74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">说到redis和memcached，我更喜欢redis，原因如下:</p><p id="fc87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">a)支持更多数据类型</p><p id="dcb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">b)默认磁盘持久性</p><p id="a826" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">c)更大的键值大小</p><p id="914f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在下面的文章中了解更多信息:</p><p id="2740" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://www.linkedin.com/pulse/memcached-vs-redis-which-one-pick-ranjeet-vimal/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/memcached-vs-redis-which-one-pick-ran Jeet-vimal/</a></p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="7a12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我们已经决定借助redis实现基于令牌的身份验证，那么让我们开始吧。</p><p id="24b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="la"> Redis </em> </strong>是一个开源的(BSD许可的)、内存中的数据结构存储，用作数据库、缓存和消息代理。它支持诸如字符串、散列、列表、集合、带有范围查询的排序集合、位图等数据结构。redis最流行的两种用法是构建缓存层或充当会话存储系统。</p><p id="017d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请按照以下文章开始使用redis。</p><div class="lb lc gp gr ld le"><a href="https://redis.io/topics/introduction" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">Redis介绍</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">Redis是一个开源的(BSD许可的)，内存中的数据结构存储，用作数据库，缓存和消息代理…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">redis.io</p></div></div><div class="ln l"><div class="mb l lp lq lr ln ls jz le"/></div></div></a></div><div class="lb lc gp gr ld le"><a href="https://redis.io/topics/quickstart" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">快速入门</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">建议安装Redis的方法是从源代码中编译它，因为Redis除了一个工作…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">redis.io</p></div></div><div class="ln l"><div class="mc l lp lq lr ln ls jz le"/></div></div></a></div><div class="lb lc gp gr ld le"><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">第1章:了解Redis | Redis实验室</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">第一章:了解Redis这一章讲述了Redis是怎样的，与你用过的其他软件不同，如何使用…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">redislabs.com</p></div></div><div class="ln l"><div class="md l lp lq lr ln ls jz le"/></div></div></a></div><p id="b297" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将使用redis的本地安装。但是你也可以从redis实验室得到一个免费的服务器。</p><div class="lb lc gp gr ld le"><a href="https://redislabs.com/get-started/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">Redis Enterprise | Redis Labs入门</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">选择您的部署选项云托管注册部署Redis数据库的最快方法。全面管理…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">redislabs.com</p></div></div><div class="ln l"><div class="me l lp lq lr ln ls jz le"/></div></div></a></div><p id="374d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从第五篇文章中离开的地方开始。建议你先看第5篇，再看这篇文章。但是，如果您对node.js有一些经验，并且能够找到自己的代码，您可以从下面的样板文件开始:</p><blockquote class="mf mg mh"><p id="ea8f" class="kb kc la kd b ke kf kg kh ki kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ky im bi translated">您可以在此处找到代码:</p><p id="97c2" class="kb kc la kd b ke kf kg kh ki kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ky im bi translated">https://github.com/pankaj805/medium-05_mongo_client<a class="ae kz" href="https://github.com/pankaj805/medium-05_mongo_client" rel="noopener ugc nofollow" target="_blank"/></p></blockquote></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="28fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的项目中，我们将使用以下npm模块作为redis客户端库</p><div class="lb lc gp gr ld le"><a href="https://www.npmjs.com/package/redis" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">雷迪斯</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">Redis客户库</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">www.npmjs.com</p></div></div><div class="ln l"><div class="ml l lp lq lr ln ls jz le"/></div></div></a></div><p id="7246" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，让我们首先在项目中安装以下库。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3162" class="mv mw it mr b gy mx my l mz na">npm install redis --save</span></pre><p id="2a6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和另一个库来创建随机的唯一id</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="6fc9" class="mv mw it mr b gy mx my l mz na">npm install node-uuid --save</span></pre><p id="e1e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本教程中，我们将构建两个api:第一个api是“登录”api，它应该返回一个新的会话令牌，其他API将更新密码，这将需要登录用户的有效会话令牌。</p><p id="a290" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先添加一个服务方法来更新用户的密码</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5f08" class="mv mw it mr b gy mx my l mz na">export const updateUserPassword = (db, userName,pwd) =&gt; {<br/>  return db.collection('user').updateOne({'username': userName }, {<br/>    $set: {password:pwd} <br/>  })<br/>  .then((r) =&gt; {<br/>    return Promise.resolve(r.matchedCount);<br/>  })<br/>  .catch((err) =&gt; {<br/>    return Promise.reject(err);<br/>  })<br/>}</span></pre><p id="9fd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以最后<em class="la"> services/UserService.js </em>应该是这样的:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="54ec" class="mv mw it mr b gy mx my l mz na">export const getUserDetails = (db, userName) =&gt; {<br/>   return new Promise((resolve, reject) =&gt;<br/>      db.collection('user')<br/>        .find({ 'username': userName })<br/>        .toArray((err, docs) =&gt; {<br/>           if(docs &amp;&amp; docs.length&gt;0){<br/>              resolve(docs[0]);<br/>           }else{<br/>              reject();<br/>           }<br/>      });<br/>   });<br/>}</span><span id="9845" class="mv mw it mr b gy nb my l mz na">export const updateUserPassword = (db, userName,pwd) =&gt; {<br/>  return db.collection('user').updateOne({'username': userName }, {<br/>    $set: {password:pwd} <br/>  })<br/>  .then((r) =&gt; {<br/>    return Promise.resolve(r.matchedCount);<br/>  })<br/>  .catch((err) =&gt; {<br/>    return Promise.reject(err);<br/>  })<br/>}</span></pre><p id="a1e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们创建一个用来存储会话数据的类。让我们在公共文件夹中创建一个文件。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0093" class="mv mw it mr b gy mx my l mz na">class Session {<br/>  constructor() {<br/>    this.userData = {};<br/>    this.sessionID = '';<br/>  }<br/> <br/>  set(obj) {<br/>    this.userData = obj;<br/>  }</span><span id="b604" class="mv mw it mr b gy nb my l mz na">  save(client){<br/>    if(this.sessionID){<br/>      client.set(this.sessionID, JSON.stringify(this.userData));<br/>      client.expire(this.sessionID, 60 * 60 * 2);<br/>    }<br/>  }</span><span id="9068" class="mv mw it mr b gy nb my l mz na">  destroy(client) {<br/>    client.del(this.sessionID);<br/>  }<br/>}</span><span id="f7d4" class="mv mw it mr b gy nb my l mz na">export default Session;</span></pre><p id="085d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了<strong class="kd iu">保存</strong>和<strong class="kd iu">销毁</strong>方法之外，这个文件非常简单明了。save方法被传递了一个参数，该参数应该是对redis客户机实例的引用。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="d648" class="mv mw it mr b gy mx my l mz na">client.set(this.sessionID, JSON.stringify(this.userData));</span></pre><p id="bc8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的行用于用用户数据更新redis键-值对。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3b2d" class="mv mw it mr b gy mx my l mz na">client.expire(this.sessionID, 60 * 60 * 2);</span></pre><p id="009e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而client.del()就是从redis中删除某个键值对。</p><p id="af88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们编辑我们的common/authUtils.js文件来处理所需的场景。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="292d" class="mv mw it mr b gy mx my l mz na">import uuid from 'node-uuid';</span><span id="b638" class="mv mw it mr b gy nb my l mz na">const newSessionRoutes = [{ path: '/user/login', method: 'POST' }];</span><span id="7d1f" class="mv mw it mr b gy nb my l mz na">const authRoutes = [{ path: '/user/password', method: 'PUT' }];</span></pre><p id="4876" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">导入uuid模块并定义两个常量，第一个常量包含需要新会话的api方法数组，第二个常量包含需要有效会话的api方法数组。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e227" class="mv mw it mr b gy mx my l mz na">export const isNewSessionRequired = (httpMethod, url) =&gt; {<br/>  for (let routeObj of newSessionRoutes) {<br/>    if (routeObj.method === httpMethod &amp;&amp; routeObj.path === url) {<br/>      return true;<br/>    }<br/>  }</span><span id="a4cd" class="mv mw it mr b gy nb my l mz na">  return false;<br/>}</span><span id="53fc" class="mv mw it mr b gy nb my l mz na">export const isAuthRequired = (httpMethod, url) =&gt; {<br/>  for (let routeObj of authRoutes) {<br/>    if (routeObj.method === httpMethod &amp;&amp; routeObj.path === url) {<br/>      return true;<br/>    }<br/>  }<br/>  return false;<br/>}</span></pre><p id="cb8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加以上两个方法来检查传递的api需要新的会话还是旧的会话。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="602b" class="mv mw it mr b gy mx my l mz na">export const generateRandomSessionID = () =&gt; {<br/>  return uuid.v4();<br/>}</span></pre><p id="4429" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加上述方法来创建随机uuid字符串。我们将使用它为redis键-值对创建一个惟一的键。</p><p id="5aff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还需要一个从redis服务器读取值的方法。根据文档，我们需要执行以下操作:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0e2f" class="mv mw it mr b gy mx my l mz na">client.get("redis-key", function (err, reply) {<br/>  console.log(reply.toString());<br/>});</span></pre><p id="58db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们定义一个方法，将上述方法封装在一个承诺中:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3f8b" class="mv mw it mr b gy mx my l mz na">export const getRedisSessionData = (redisClient,sessionId) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    redisClient.get(sessionId, function (err, data) {<br/>      if (err) {<br/>        reject(err);<br/>      }<br/>      resolve(data);<br/>    });<br/>  })<br/>}</span></pre><p id="c108" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们的authUtils文件应该如下所示:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8b45" class="mv mw it mr b gy mx my l mz na">import {getClientDetails} from '../services/ClientService';<br/>import uuid from 'node-uuid';</span><span id="f65c" class="mv mw it mr b gy nb my l mz na">const newSessionRoutes = [{ path: '/user/login', method: 'POST' }];<br/>const authRoutes = [{ path: '/user/password', method: 'PUT' }];</span><span id="6fdd" class="mv mw it mr b gy nb my l mz na">export const clientApiKeyValidation = async (req,res,next) =&gt; {<br/>   let clientApiKey = req.get('api_key');</span><span id="c94e" class="mv mw it mr b gy nb my l mz na">if(!clientApiKey){<br/>      return res.status(400).send({<br/>         status:false,<br/>         response:"Missing Api Key"<br/>      });<br/>   }</span><span id="dac0" class="mv mw it mr b gy nb my l mz na">try {<br/>      let clientDetails = await getClientDetails(req.db, clientApiKey);<br/>      if (clientDetails) {<br/>         next();<br/>      }<br/>   } catch (e) {<br/>      console.log('%%%%%%%% error :', e);<br/>      return res.status(400).send({<br/>         status: false,<br/>         response: "Invalid Api Key"<br/>      });<br/>   }</span><span id="aa9f" class="mv mw it mr b gy nb my l mz na">}</span><span id="521c" class="mv mw it mr b gy nb my l mz na">export const isNewSessionRequired = (httpMethod, url) =&gt; {<br/>  for (let routeObj of newSessionRoutes) {<br/>    if (routeObj.method === httpMethod &amp;&amp; routeObj.path === url) {<br/>      return true;<br/>    }<br/>  }</span><span id="651d" class="mv mw it mr b gy nb my l mz na">return false;<br/>}</span><span id="714a" class="mv mw it mr b gy nb my l mz na">export const isAuthRequired = (httpMethod, url) =&gt; {<br/>  for (let routeObj of authRoutes) {<br/>    if (routeObj.method === httpMethod &amp;&amp; routeObj.path === url) {<br/>      return true;<br/>    }<br/>  }<br/>  return false;<br/>}</span><span id="102e" class="mv mw it mr b gy nb my l mz na">export const generateRandomSessionID = () =&gt; {<br/>  return uuid.v4();<br/>}</span><span id="eee1" class="mv mw it mr b gy nb my l mz na">export const getRedisSessionData = (redisClient,sessionId) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    redisClient.get(sessionId, function (err, data) {<br/>      if (err) {<br/>        reject(err);<br/>      }<br/>      resolve(data);<br/>    });<br/>  })<br/>}</span></pre><p id="fcdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在开始下一个文件之前，这里有一些注意事项:</p><p id="2b3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这不是生产质量代码。我们过分简化了事情，忽略了一些最佳实践。这里列出了一些过于简单的东西，限制了本文的重点:</p><p id="e35e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">API授权配置已放入常量变量中。理想情况下，它们应该从数据库中获取，或者应该放在json文件中。甚至配置也可能更复杂，以处理基于用户角色的身份验证。</p><p id="9248" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> ii) </strong>密码应以加密方式保存。这可以通过使用bcrypt等各种npm库轻松实现</p><p id="a8cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们编辑app.js文件。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="be05" class="mv mw it mr b gy mx my l mz na">import {clientApiKeyValidation} from './common/authUtils';</span></pre><p id="04ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将上面的行更新如下:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="eb79" class="mv mw it mr b gy mx my l mz na">import { clientApiKeyValidation, isNewSessionRequired, isAuthRequired, generateRandomSessionID, getRedisSessionData } from './common/authUtils';</span></pre><p id="4c34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和另外两个进口货</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7543" class="mv mw it mr b gy mx my l mz na">import redis from 'redis';<br/>import Session from './common/Session';</span></pre><p id="744e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在mongo connect代码之前/之后添加以下代码。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7827" class="mv mw it mr b gy mx my l mz na">let redisClient = null;<br/>redisClient = redis.createClient({<br/>  prefix: 'node-sess:',<br/>  host: 'localhost'<br/>});</span></pre><p id="3b64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正在实例化一个redis客户端连接，并将其分配给一个全局变量。前缀值将用于该客户端写入/读取的所有密钥。这里使用的默认端口是6379。</p><p id="b916" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我们注入了<strong class="kd iu"> clientApiKeyValidation的那一行之后添加下面的代码。</strong></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5f7d" class="mv mw it mr b gy mx my l mz na">app.use(async (req, res, next) =&gt; {<br/>  var apiUrl = req.originalUrl;<br/>  var httpMethod = req.method;</span><span id="898a" class="mv mw it mr b gy nb my l mz na">if (isNewSessionRequired(httpMethod, apiUrl)) {<br/>    let sessionID = generateRandomSessionID()<br/>    req.session = new Session();<br/>    req.session.sessionID = sessionID;<br/>    req.sessionID = sessionID;<br/>  } else if (isAuthRequired(httpMethod, apiUrl)) {<br/>    let sessionID = req.header('Authorization');<br/>    if (sessionID) {<br/>      let redisData = await getRedisSessionData(redisClient, sessionID);<br/>      if (redisData) {<br/>        redisData = JSON.parse(redisData);<br/>        req.session = new Session();<br/>        req.sessionID = sessionID;<br/>        req.session.sessionID = sessionID;<br/>        req.session.userData = redisData;<br/>      } else {<br/>        return res.status(401).send({<br/>          ok: false,<br/>          error: {<br/>            reason: "Invalid Sessiontoken",<br/>            code: 401<br/>          }<br/>        });<br/>      }<br/>    } else {<br/>      return res.status(401).send({<br/>        ok: false,<br/>        error: {<br/>          reason: "Missing Sessiontoken",<br/>          code: 401<br/>        }<br/>      });<br/>    }<br/>  }<br/>  next();<br/>})</span></pre><p id="8490" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过上面的代码，我们注入了另一个请求处理器，它将为所有API处理与会话相关的东西。首先，我们检查被调用的api是否需要一个新的会话。在这种情况下，我们创建一个随机的uuid和新的会话对象，并将其指定为express request对象的一个属性。但是我们还没有把这些数据发送到redis服务器上。我们以后再做。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="881b" class="mv mw it mr b gy mx my l mz na">let sessionID = generateRandomSessionID()<br/>req.session = new Session();<br/>req.session.sessionID = sessionID;<br/>req.sessionID = sessionID;</span></pre><p id="5424" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在另一个条件下，我们检查api是否需要一个有效的会话。这里有一点非常重要。通常的做法是以下列方式传递授权令牌报头:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="54bc" class="mv mw it mr b gy mx my l mz na">Authorization: Bearer a1194981-b541-416e-935</span></pre><p id="4b23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">头字段应该是“Authorization ”,值的第一部分应该是关键字“Bearer ”,然后由空格分隔的第二部分应该包含令牌。</p><p id="d159" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是W3C给出的一个标准。关键字“持票人”被用来区别于现有的基本认证。<strong class="kd iu">但在本文中，我们将使用自定义标题，只是为了展示我们也可以使用自定义标题字段。我们将在下一篇文章中使用不记名授权头。</strong></p><p id="13c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们希望客户端在请求头中发送会话令牌，字段名为<strong class="kd iu"> <em class="la"> sessiontoken </em> </strong></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="120e" class="mv mw it mr b gy mx my l mz na">let sessionID = req.header('sessiontoken');</span></pre><p id="10fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果sessionID丢失，我们将在api中返回一个错误。但是如果sessionID出现在头中，我们尝试访问redis服务器并获取传递的键的记录。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8f82" class="mv mw it mr b gy mx my l mz na">let redisData = await getRedisSessionData(redisClient, sessionID);</span></pre><p id="dc57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果redisData为null，那么我们将在api中返回一个错误，指出令牌无效。如果会话过期并从redis服务器中删除，或者在头中传递了随机无效值，就会发生这种情况。</p><p id="9c22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但如果我们从redis获取用户信息。我们解析相同的数据。{我们将在redis中以字符串形式存储我们的数据}。除了保留旧的值之外，我们为新的会话做了类似的事情。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="52f7" class="mv mw it mr b gy mx my l mz na">        redisData = JSON.parse(redisData);<br/>        req.session = new Session();<br/>        req.sessionID = sessionID;<br/>        req.session.sessionID = sessionID;<br/>        req.session.userData = redisData;</span></pre><p id="5422" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我们所有的路由注入之后，让我们也为所有的API添加一个响应处理程序。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a849" class="mv mw it mr b gy mx my l mz na">app.use((req, res, next) =&gt; {<br/>  if (!res.data) {<br/>    return res.status(404).send({<br/>      ok: false,<br/>      error: {<br/>        reason: "Invalid Endpoint", code: 404<br/>      }<br/>    });<br/>  }</span><span id="e1a8" class="mv mw it mr b gy nb my l mz na">  if (req.session &amp;&amp; req.sessionID) {<br/>    try {<br/>      req.session.save(redisClient);<br/>      res.setHeader('sessiontoken', req.sessionID);<br/>      res.data['sessiontoken'] = req.sessionID;<br/>    } catch (e) {<br/>      console.log('Error -&gt;:', e);<br/>    }<br/>  }<br/>  res.status(res.statusCode || 200)<br/>    .send({ ok: true, response: res.data });<br/>})</span></pre><p id="d23a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个响应处理程序中。我们首先检查响应对象是否具有<strong class="kd iu">数据</strong>属性。如果缺少数据属性，我们将在api响应中发送404错误。</p><p id="2198" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，如果设置了数据，我们会以定义好的格式发送响应，并附带所需的http状态代码。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="aac3" class="mv mw it mr b gy mx my l mz na">res.status(res.statusCode||200).send({ok: true, response:res.data});</span></pre><p id="f73b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果快速请求对象有一个sessionID字段，我们将执行两个操作:</p><p id="81ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们使用Session.save()方法将这些数据保存在redis服务器中。</p><p id="08de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> ii) </strong>我们将sessiontoken值添加到响应报头和响应有效载荷中。</p><p id="8e94" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们的app.js代码如下所示:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="f46c" class="mv mw it mr b gy mx my l mz na">import express from 'express';<br/>import bodyParser from 'body-parser';<br/>import user from './routes/user';<br/>import {MongoClient} from 'mongodb';<br/>import { clientApiKeyValidation, isNewSessionRequired, isAuthRequired, generateRandomSessionID, getRedisSessionData } from './common/authUtils';<br/>import redis from 'redis';<br/>import Session from './common/Session';</span><span id="6a12" class="mv mw it mr b gy nb my l mz na">const CONN_URL = 'mongodb://localhost:27017';</span><span id="7712" class="mv mw it mr b gy nb my l mz na">let mongoClient = null;</span><span id="41aa" class="mv mw it mr b gy nb my l mz na">MongoClient.connect(CONN_URL,{ useNewUrlParser: true }, function (err, client) {<br/>   mongoClient = client;<br/>})</span><span id="2efc" class="mv mw it mr b gy nb my l mz na">let redisClient = null;<br/>redisClient = redis.createClient({<br/>  prefix: 'node-sess:',<br/>  host: 'localhost'<br/>});</span><span id="547b" class="mv mw it mr b gy nb my l mz na">let app = express();</span><span id="e14b" class="mv mw it mr b gy nb my l mz na">// parse application/x-www-form-urlencoded<br/>app.use(bodyParser.urlencoded({ extended: false }));</span><span id="e7e1" class="mv mw it mr b gy nb my l mz na">// parse application/json<br/>app.use(bodyParser.json());</span><span id="45ef" class="mv mw it mr b gy nb my l mz na">app.use((req,res,next)=&gt;{<br/>   req.db = mongoClient.db('test');<br/>   next();<br/>})</span><span id="b4bb" class="mv mw it mr b gy nb my l mz na">app.get('/',(req,res,next)=&gt;{<br/>    res.status(200).send({<br/>      status:true,<br/>      response:'Hello World!'<br/>    });<br/>});</span><span id="e4bc" class="mv mw it mr b gy nb my l mz na">app.use(clientApiKeyValidation);</span><span id="70ce" class="mv mw it mr b gy nb my l mz na">app.use(async (req, res, next) =&gt; {<br/>  var apiUrl = req.originalUrl;<br/>  var httpMethod = req.method;</span><span id="99ae" class="mv mw it mr b gy nb my l mz na">if (isNewSessionRequired(httpMethod, apiUrl)) {<br/>    let sessionID = generateRandomSessionID()<br/>    req.session = new Session();<br/>    req.session.sessionID = sessionID;<br/>    req.sessionID = sessionID;<br/>  } else if (isAuthRequired(httpMethod, apiUrl)) {<br/>    let sessionID = req.header('sessiontoken');<br/>    if (sessionID) {<br/>      let redisData = await getRedisSessionData(redisClient, sessionID);<br/>      if (redisData) {<br/>        redisData = JSON.parse(redisData);<br/>        req.session = new Session();<br/>        req.sessionID = sessionID;<br/>        req.session.sessionID = sessionID;<br/>        req.session.userData = redisData;<br/>      } else {<br/>        return res.status(401).send({<br/>          ok: false,<br/>          error: {<br/>            reason: "Invalid Sessiontoken",<br/>            code: 401<br/>          }<br/>        });<br/>      }<br/>    } else {<br/>      return res.status(401).send({<br/>        ok: false,<br/>        error: {<br/>          reason: "Missing Sessiontoken",<br/>          code: 401<br/>        }<br/>      });<br/>    }<br/>  }<br/>  next();<br/>})</span><span id="0787" class="mv mw it mr b gy nb my l mz na">app.use('/user',user);</span><span id="f2f6" class="mv mw it mr b gy nb my l mz na">app.use((req, res, next) =&gt; {<br/>  if (!res.data) {<br/>    return res.status(404).send({<br/>      ok: false,<br/>      error: {<br/>        reason: "Invalid Endpoint", code: 404<br/>      }<br/>    });<br/>  }</span><span id="00c1" class="mv mw it mr b gy nb my l mz na">if (req.session &amp;&amp; req.sessionID) {<br/>    try {<br/>      req.session.save(redisClient);<br/>      res.setHeader('sessiontoken', req.sessionID);<br/>      res.data['sessiontoken'] = req.sessionID;<br/>    } catch (e) {<br/>      console.log('Error -&gt;:', e);<br/>    }<br/>  }<br/>  res.status(res.statusCode || 200)<br/>    .send({ ok: true, response: res.data });<br/>})</span><span id="4d49" class="mv mw it mr b gy nb my l mz na">app.listen(30006,()=&gt;{<br/>   console.log(' ********** : running on 30006');<br/>})</span><span id="46df" class="mv mw it mr b gy nb my l mz na">process.on('exit', (code) =&gt; {<br/>   mongoClient.close();<br/>   console.log(`About to exit with code: ${code}`);<br/>});</span><span id="f6f4" class="mv mw it mr b gy nb my l mz na">process.on('SIGINT', function() {<br/>   console.log("Caught interrupt signal");<br/>   process.exit();<br/>});</span><span id="eb3d" class="mv mw it mr b gy nb my l mz na">module.exports = app;</span></pre><p id="481c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们转到我们的<strong class="kd iu"> routes/user.js </strong>文件。在添加两个新的api路由之前，让我们编辑前面的路由"<em class="la"> /hello </em>"以使用新的响应处理程序。</p><p id="8703" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">早期的代码如下所示:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9244" class="mv mw it mr b gy mx my l mz na">router.post('/hello',async (req,res)=&gt;{<br/>  let uname = req.body.username;<br/>  let userDetails = await getUserDetails(req.db,uname)<br/>  res.status(200).send({<br/>    status:true,<br/>    response:userDetails<br/>  });<br/>});</span></pre><p id="9879" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在成功检索数据后，我们通常直接发送响应。现在让我们将上面的方法编辑成下面的方法:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7e40" class="mv mw it mr b gy mx my l mz na">router.post('/hello', async (req, res, next) =&gt; {<br/>  let uname = req.body.username;<br/>  let userDetails = await getUserDetails(req.db, uname)<br/>  res.data = {<br/>    status: true,<br/>    response: userDetails<br/>  };<br/>  next();<br/>});</span></pre><p id="6e16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们只是设置响应对象的数据属性并调用next()方法。</p><p id="e9fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更新import语句，使其也包含updateUserPassword方法</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c0a7" class="mv mw it mr b gy mx my l mz na">import { getUserDetails, updateUserPassword } from '../services/UserService';</span></pre><p id="333f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">登录api的代码如下:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7ed0" class="mv mw it mr b gy mx my l mz na">router.post('/login', async (req, res, next) =&gt; {<br/>  let uname = req.body.username;<br/>  let pwd = req.body.password;<br/>  let userDetails = await getUserDetails(req.db, uname);<br/>  if (userDetails) {<br/>    let { password } = userDetails;<br/>    if (pwd === password) {<br/>      res.data = {<br/>        status: true,<br/>        response: userDetails<br/>      };<br/>      req.session.set(userDetails);<br/>    } else {<br/>      res.statusCode = 400;<br/>      res.data = {<br/>        status: false,<br/>        error: 'Invalid Password'<br/>      };<br/>    }<br/>  } else {<br/>    res.statusCode = 400;<br/>    res.data = {<br/>      status: false,<br/>      error: 'Invalid Username'<br/>    };<br/>  }<br/>  next();<br/>});</span></pre><p id="e856" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们还可以添加另一个条件来检查请求数据中是否缺少用户名或密码。首先，我们尝试通过传递用户名来获取用户的详细信息。如果数据丢失，我们会发送一条错误消息，声明用户名无效。否则我们尝试比较密码。如果密码不匹配，我们会发送一个错误。否则，我们更新响应数据对象和请求会话对象中的用户数据。由于请求会话对象现在有了userdata，在我们的响应处理程序中调用的save()函数将把数据保存到我们的redis中。</p><p id="a217" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们为更新密码api添加代码。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="68a7" class="mv mw it mr b gy mx my l mz na">router.put('/password', async (req, res, next) =&gt; {<br/>  try {<br/>    let oldPwd = req.body.old_password;<br/>    let newPwd = req.body.new_password;<br/>    if (!oldPwd &amp;&amp; !newPwd) {<br/>      res.statusCode = 400;<br/>      res.data = {<br/>        status: false,<br/>        error: 'Invalid Parameters'<br/>      }<br/>    }<br/>    let uname = req.session.userData.username;<br/>    let userDetails = await getUserDetails(req.db, uname);<br/>    if (oldPwd !== userDetails.password) {<br/>      res.statusCode = 400;<br/>      res.data = {<br/>        status: false,<br/>        error: "Old Password doesn't match"<br/>      }<br/>    } else {<br/>      let updateRes = await updateUserPassword(req.db,uname,newPwd)<br/>      res.data = {<br/>        status: true,<br/>        response:updateRes,<br/>        message: "Password updated successfully"<br/>      }<br/>    }  <br/>    next();<br/>  } catch (e) {<br/>    next(e)<br/>  }<br/>})</span></pre><p id="51d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是代码中有趣的部分。在这里，我们将看到如何从会话令牌中获取所有用户详细信息。请求中没有提到用户详细信息或用户名。但是我们作为请求处理程序注入的会话处理程序必须在请求会话对象中注入用户数据。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0b55" class="mv mw it mr b gy mx my l mz na">let uname = req.session.userData.username;</span></pre><p id="7845" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从请求会话对象中获取用户名，然后执行更新用户密码所需的所有操作。</p><p id="5722" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">唷！！！！！</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/ad007796f5d739a4dbe5b54b253fe4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdPv489I_pHtbhjFkY9VCA.jpeg"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">肯德尔·詹姆斯在<a class="ae kz" href="https://unsplash.com/search/photos/tired?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="b662" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们测试我们的代码。使用node index.js命令运行项目。</p><p id="a37b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先点击我们的旧API“/hello”来检查我们的新响应处理程序。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/b89c225300ba50f0d819b78bd85f9c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5uRe7F25Y-_4Tf7X-JG-w.png"/></div></div></figure><p id="9773" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们点击登录api:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/d44a3afdb3cefa3ad98b8646ccdd2318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geDcpwLGZJruK6iOPNlLOg.png"/></div></div></figure><p id="11a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以在api响应中看到会话令牌。我们还可以检查redis实例，以确认我们有用户的详细信息。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/25a6fe0d8e4030f747ab25d9224c46f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMnK0tZEgp8cJDPx_fhiCQ.png"/></div></div></figure><p id="e53d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们尝试用一个无效的令牌来攻击更新密码api:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/059ffa2c9e20c82de1f49b44dfca42f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOb-Jm6OF5YipzDmDkSXKA.png"/></div></div></figure><p id="4818" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们复制之前在登录api响应中获得的会话令牌，并将其传递到更新密码api的头中。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/4fb26e364d3c2c07eeea699e85ddba58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSgByjJxgIZkME9EdYnqDg.png"/></div></div></figure><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/b0b10910424d2651eb257c131a4313ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7Zg19YszYRwxYyEYlvRUQ.png"/></div></div></figure><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/d619e7e2fefa66209a327c6144de7de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysBs8Qito0V4GnwEk_zoDw.png"/></div></div></figure><p id="d861" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望您喜欢这篇文章，在下一篇文章中，我们将看到如何使用JWT实现身份验证。</p><blockquote class="mf mg mh"><p id="43c3" class="kb kc la kd b ke kf kg kh ki kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ky im bi translated">您可以在此处找到代码:</p><p id="6217" class="kb kc la kd b ke kf kg kh ki kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ky im bi translated"><a class="ae kz" href="https://github.com/pankaj805/medium-06_redis" rel="noopener ugc nofollow" target="_blank">https://github.com/pankaj805/medium-06_redis</a></p></blockquote></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="509e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章，你可以👏并与他人分享。你可以在这里找到整个<a class="ae kz" href="https://medium.com/@pankaj.panigrahi/list-of-node-js-articles-ededa6dd304b" rel="noopener"> <strong class="kd iu"> <em class="la">文章系列</em> </strong> </a>。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/0bf5df4c347f4b7878add00ed9d2eeef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RIUq42rf1bjVzLSt"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">今天到此为止。</p></figure></div></div>    
</body>
</html>