<html>
<head>
<title>Effective Object Communication in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中有效的对象通信</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-ways-of-implementing-effective-communication-between-activities-fragments-and-objects-in-88f54ed7f4f6?source=collection_archive---------10-----------------------#2021-03-08">https://betterprogramming.pub/4-ways-of-implementing-effective-communication-between-activities-fragments-and-objects-in-88f54ed7f4f6?source=collection_archive---------10-----------------------#2021-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c895" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">接口、依赖注入等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a627ca6bfe4be596d82d08c18ca2783a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*er-T3scbLiYX1eoR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Volodymyr Hryshchenko 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面向对象编程是当今几乎所有伟大应用的基础。由于其巨大的灵活性，它已经成为许多开发人员选择的设计模式。</p><p id="ac85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使面向对象编程如此伟大的原因之一是能够在对象之间传递数据，并且有许多不同的方法可以做到这一点。作为一名Android开发人员，我遇到过许多新手——其中大多数是我的实习生——他们不能正确地进行对象间的通信。这促使他们编写大量样板代码，使得他们的工作很难管理和扩展。</p><p id="f6ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将介绍四种使用Kotlin有效实现基于Android的对象间通信的方法，但是这些方法也可以用于其他编程语言，只是实现的语法略有不同。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="10cb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.接口</h1><p id="4f83" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不涉及所有复杂的技术细节，在面向对象编程中，接口是程序员让不同的对象实现或能够以各种方式使用相同方法的一种方式(这种技术也称为多态性)。使用接口的最佳方式之一是使用它来监听对象状态的变化，执行一些任务，或者检测一个动作并对其做出响应，这通常是为了通信。</p><h2 id="01df" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">在Android中使用界面进行通信</h2><p id="4e0a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Android中，最推荐的对象间数据通信方式是使用接口作为对象状态变化的监听器，或者报告某个动作已经发生。侦听此更改的对象是实现接口的对象，然后通过使用依赖注入将其作为参数传递给要侦听的对象。</p><p id="2455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种带有接口的技术最适合活动和片段之间，以及活动/片段和适配器之间的通信。</p><h2 id="d8e1" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">待办事项列表示例(活动/适配器通信)</h2><p id="947b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们以一个待办事项app为例。有一个<code class="fe nl nm nn no b">TodoActivity</code>，这个活动有一个<code class="fe nl nm nn no b">RecyclerView</code>，它必须用数据库中的待办事项列表信息填充。<code class="fe nl nm nn no b">RecyclerView</code>只能通过使用自定义<code class="fe nl nm nn no b">RecyclerView.Adapter</code>来显示该信息。<code class="fe nl nm nn no b">RecyclerView.Adapter</code>需要与<code class="fe nl nm nn no b">TodoActivity</code>通信，以监听项目选择等动作，并长按<code class="fe nl nm nn no b">RecyclerView</code>中显示的任何待办事项，以便当这些动作发生时<code class="fe nl nm nn no b">TodoActivity</code>可以访问适配器中的项目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TodoItemActionListener.kt</p></figure><p id="3bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">TodoActivity</code>实现<code class="fe nl nm nn no b">TodoItemActionListener</code>接口并覆盖该接口的所有方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TodoActivity.kt</p></figure><p id="41dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nl nm nn no b">TodoActivity</code>的<code class="fe nl nm nn no b">onCreate()</code>方法中，<code class="fe nl nm nn no b">RecyclerView</code>被正确初始化，并且<code class="fe nl nm nn no b">TodoItem</code>对象从数据库中获取并添加到将用于填充<code class="fe nl nm nn no b">RecyclerView</code>的<code class="fe nl nm nn no b">ArrayList&lt;TodoItem&gt;</code>中。</p><p id="14ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe nl nm nn no b">ArrayList</code>、作为上下文的活动以及作为<code class="fe nl nm nn no b">TodoItemActionListener</code>的活动来初始化<code class="fe nl nm nn no b">TodoItemsAdapter</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TodoRecyclerAdapter.kt</p></figure><p id="4e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，上面的实现可以用活动/片段和片段/片段来完成。在下面关于注入的部分，我将演示如何向片段传递或注入复杂的参数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9c55" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.依赖注入</h1><p id="383f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在面向对象编程中，依赖注入是向需要或依赖所提供的资源来实现其预期目的的对象提供资源的过程。</p><p id="94dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入是您在创建接受参数的构造函数以及为对象中的变量创建setter方法时一直在做的事情。</p><p id="525c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Android中，注入是将信息传递给片段或定制适配器的最佳方式之一。</p><h2 id="c08d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">待办事项列表示例(从TodoActivity向TodoFragment传递数据)</h2><p id="e3fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Android Studio中，片段的默认实现假设您通过自定义片段对象的实例来创建片段，并且只能通过在片段实例化时使用Bundle对象来向它们传递数据，但是如果您不喜欢这种实现，也可以不遵循它。您可以使用自己选择的设计模式以许多不同的方式实现您的片段。</p><p id="953b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe nl nm nn no b">TodoActivity</code>必须向<code class="fe nl nm nn no b">TodoFragment</code>传递或注入一个<code class="fe nl nm nn no b">ArrayList&lt;TodoItem&gt;</code>，这样您就可以在片段中使用它。对<code class="fe nl nm nn no b">TodoFragment</code>进行了修改，在其主构造函数中加入了一个<code class="fe nl nm nn no b">ArrayList&lt;TodoItem&gt;</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TodoFragment.kt</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TodoActivity.kt</p></figure><p id="8f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在执行<code class="fe nl nm nn no b">onCreateView()</code>方法之前，<code class="fe nl nm nn no b">TodoFragment</code>接收<code class="fe nl nm nn no b">ArrayList&lt;TodoItem&gt;</code>初始化。如果您想使用<code class="fe nl nm nn no b">ArrayList&lt;TodoItem&gt;</code>来填充<code class="fe nl nm nn no b">RecyclerView</code>，那么您可以在片段的<code class="fe nl nm nn no b">onViewCreated()</code>方法中完成。</p><p id="565d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的依赖注入实现非常简单，只是为了解释一些基础知识。考虑使用<a class="ae ky" href="https://developer.android.com/training/dependency-injection/dagger-android" rel="noopener ugc nofollow" target="_blank"> Dagger库</a>进行所有最佳实践的依赖注入。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6866" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.单例类</h1><p id="4bbb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在面向对象的编程中，单例类是这样一个类，它只保存自身的一个实例，并提供对该实例的简单访问，以便处理其他对象。单例类总是有相同的实例，因此在应用程序中的任何时候都有相同的状态。单例类也可以从应用程序的任何地方访问。这两个特性使得单例类成为在整个应用程序中以双向方式传递数据的极好方式。</p><p id="49bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我演示完它的使用时，如果您的用例需要的话，singleton模式肯定会成为您在应用程序中实现通信时的首选模式。</p><p id="b69e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的单例类通常都有签名方法<code class="fe nl nm nn no b">getInstance()</code>，它返回单例类的静态实例。</p><h2 id="6dfa" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">更多优势</h2><ul class=""><li id="7537" class="nr ns it lb b lc mu lf mv li nt lm nu lq nv lu nw nx ny nz bi translated">单例类可以实现接口。</li><li id="4917" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">单体类可以通过依赖注入作为参数传递给其他对象。</li><li id="8ff7" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">单例类可以多态处理，所以你可以有多个实现。</li></ul><p id="c7f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现单例模式的一个很好的理由是，如果您需要在代码的许多部分同步数据，并在整个应用程序中保持一个中心控制点。</p><h2 id="193c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak"> <em class="of">示例(跨多个活动同步用户数据)</em> </strong></h2><p id="269f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这个例子中，用户数据是从云中的数据库获取的，并保存在一个名为<code class="fe nl nm nn no b">UserDataHolder</code>的单例类的实例中。<code class="fe nl nm nn no b">ActivityA</code>和<code class="fe nl nm nn no b">ActivityB</code>通过这个singleton类的实例访问这个用户数据，而不需要再次从云中的数据库请求用户数据，也不需要<code class="fe nl nm nn no b">ActivityA</code>通过<code class="fe nl nm nn no b">Intent</code>将数据传递给<code class="fe nl nm nn no b">ActivityB</code>。</p><p id="25ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kotlin中，单例类的创建被简化了。你只需要在创建一个类的时候使用<code class="fe nl nm nn no b">object</code>关键字来使它成为一个单例。<code class="fe nl nm nn no b">init{}</code>方法第一次初始化类，并且总是返回一个实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UserDataHolder.kt</p></figure><p id="3a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过调用<code class="fe nl nm nn no b">UserDataHolder</code> singleton类中的<code class="fe nl nm nn no b">getUserData()</code>和<code class="fe nl nm nn no b">updateUserData(user:UserModel)</code>方法，<code class="fe nl nm nn no b">ActivityA</code>和<code class="fe nl nm nn no b">ActivityB</code>可以轻松地共享和更新相同的数据，从而优化通信。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ActivityA.kt</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">活动B.kt</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e85" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.数据绑定</h1><p id="a84a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数据绑定，有时也称为视图绑定，是将显示元素(例如，用户界面控件或视图)与填充它的信息相连接的过程。这种连接使得信息可以自动提供给所需的视图或目的地，而不需要任何额外的代码。在实现MVVM(模型-视图-视图-模型)设计架构的应用程序中，数据绑定是非常常见的事情。</p><p id="9847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据绑定通常负责以下事项:</p><ul class=""><li id="c3f1" class="nr ns it lb b lc ld lf lg li og lm oh lq oi lu nw nx ny nz bi translated">显示最新数据。</li><li id="fd1d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">处理用户事件。</li><li id="17a4" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">对布局变量调用操作。</li></ul><p id="fbf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要向Kotlin Android项目添加数据绑定，您必须在项目的应用程序级<code class="fe nl nm nn no b">build.gradle</code>文件的顶部添加<code class="fe nl nm nn no b">apply pulgin:'kotlin-Kapt'</code>，并在<strong class="lb iu"> </strong>应用程序级<code class="fe nl nm nn no b">build.gradle</code>文件的Android配置部分添加<code class="fe nl nm nn no b">data Binding{enable true}</code> <strong class="lb iu"> </strong>。</p><h2 id="4624" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak"> <em class="of">示例(TodoActivity视图与ViewModel绑定)</em> </strong></h2><p id="5a17" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要在<code class="fe nl nm nn no b">TodoActivity</code>中实现数据绑定，必须将<code class="fe nl nm nn no b">activity_todo.xml</code>布局文件转换为数据绑定布局。为此，右键单击根元素，选择“显示上下文操作”，然后选择“转换为数据绑定布局”这将把布局转换成一个带有<code class="fe nl nm nn no b">&lt;data&gt;</code>部分的数据绑定布局，该部分将存放布局变量，这些变量将被绑定到布局其余部分的视图。</p><p id="7fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">activity_todo.xml</code>有一个ID为<code class="fe nl nm nn no b">status</code>的<code class="fe nl nm nn no b">TextView</code>和一个ID为<code class="fe nl nm nn no b">update_status</code>的按钮。每次按下按钮，<code class="fe nl nm nn no b">TextView</code>中的文本必须改变，指示状态更新。在这个例子中，我们将通过使用数据绑定和一个<code class="fe nl nm nn no b">ViewModel</code>来实现这个功能。</p><p id="f93e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，从将<code class="fe nl nm nn no b">activity_todo.xml</code>布局文件转换成数据绑定布局开始。在Android studio中，这很容易做到，只需右键单击根元素，选择“显示上下文操作”，然后选择“转换为数据绑定布局”</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/CodeBoy722/bd51bfe93293f9137dbfdfbae5384626#file-activity_todo-xml" rel="noopener ugc nofollow" target="_blank"><strong class="ak">activity _ todo . XML</strong></a></p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/CodeBoy722/38d8b2f8fa1c7d6197b245af01caf599#file-todoviewmodel-kt" rel="noopener ugc nofollow" target="_blank"><strong class="ak">todoviewmodel . kt</strong></a></p></figure><p id="78db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">TodoViewModel</code>保存了<code class="fe nl nm nn no b">activity_todo.xml</code>绑定的所有布局变量，因此在<code class="fe nl nm nn no b">activity_todo.xml</code>的<code class="fe nl nm nn no b">&lt;data&gt;</code>部分添加:</p><pre class="kj kk kl km gt oj no ok ol aw om bi"><span id="6367" class="mz md it no b gy on oo l op oq">&lt;data&gt; <br/>  &lt;variable name="viewModel" type=”com.android101.todolist.data.TodoViewModel”/&gt; <br/>&lt;/data&gt;</span></pre><p id="a974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在<code class="fe nl nm nn no b">activity_todo.xml</code>中，将状态<code class="fe nl nm nn no b">TextView </code>的<code class="fe nl nm nn no b">android:text</code>值设置为<code class="fe nl nm nn no b">android:text="@{viewModel}"</code>，将update_status按钮的<code class="fe nl nm nn no b">android:onClick</code>值设置为:</p><pre class="kj kk kl km gt oj no ok ol aw om bi"><span id="d68c" class="mz md it no b gy on oo l op oq">android:onClick=”@{()-&gt;viewModel.onUpdate()}”</span></pre><p id="f055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nl nm nn no b">TodoViewModel</code>中，status <code class="fe nl nm nn no b">TextView</code>绑定的status变量是一个可观察的字符串，每次点击update按钮都会改变。这种变化将反映在<code class="fe nl nm nn no b">TextView</code>的状态中。</p><p id="967d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个机制是通过使用<code class="fe nl nm nn no b"><a class="ae ky" href="https://developer.android.com/topic/libraries/data-binding/architecture?hl=es-419#livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>实现的:</p><pre class="kj kk kl km gt oj no ok ol aw om bi"><span id="3294" class="mz md it no b gy on oo l op oq">val status: LiveData&lt;String&gt; = Transformations.map(_state){                                     it -&gt;  "I can drink $it bottles of Reactor"                           }</span></pre><p id="7d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次用户点击更新按钮，可观察值<code class="fe nl nm nn no b">Int _state</code>增加，这触发可观察字符串状态的更新:</p><pre class="kj kk kl km gt oj no ok ol aw om bi"><span id="168d" class="mz md it no b gy on oo l op oq">fun onUpdate() {                               <br/>_state.value = (_state.value ?: 0) + 1                           <br/>}</span></pre><p id="b050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了总结一切，在<code class="fe nl nm nn no b">TodoActivity</code>中，为<code class="fe nl nm nn no b">TodoViewModel</code>创建一个变量。在<code class="fe nl nm nn no b">onCreate()</code>方法中，初始化一个新的绑定变量，将其<code class="fe nl nm nn no b">LifecycleOwner</code>设置为<code class="fe nl nm nn no b">TodoActivity</code>，将其<code class="fe nl nm nn no b">binding.viewModel</code>设置为您的<code class="fe nl nm nn no b">TodoViewModel</code>变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/CodeBoy722/4baf5abbf50f1ccef3b41908552c9368#file-todoactivitybinding-kt" rel="noopener ugc nofollow" target="_blank"> TodoActivityBinding.kt </a></p></figure><h2 id="70eb" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">结果</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/54375ec29b220c0edf1a9d62befd3449.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/1*RbMA31OZyiwWTah8iA97xA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据绑定</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="15d4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6bb6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">android中的对象通信有很多种类型，但是创建流畅无缝的应用程序的秘诀是根据你的应用程序架构，在最需要的地方应用正确的对象通信形式。在这一点上，快乐的编码。</p></div></div>    
</body>
</html>