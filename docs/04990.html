<html>
<head>
<title>Build Your Own In-Home Cloud Storage (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您自己的家庭云存储(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-own-in-home-cloud-storage-part-2-8fe86e9bd5bf?source=collection_archive---------3-----------------------#2020-05-28">https://betterprogramming.pub/build-your-own-in-home-cloud-storage-part-2-8fe86e9bd5bf?source=collection_archive---------3-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="efcb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Rook/EdgeFS向Kubernetes集群添加存储</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ff5bec0cd77e444b89a49728b792660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuAhlYqLWE-OAQstOCu7jQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帕特里克·林登伯格在<a class="ae ky" href="https://unsplash.com/s/photos/harddrives?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的文章“<a class="ae ky" href="https://medium.com/better-programming/build-your-own-in-home-cloud-storage-1aa74b5c6397" rel="noopener">构建你自己的家庭云存储(第一部分)</a>”中，我基于<a class="ae ky" href="https://www.gluster.org/" rel="noopener ugc nofollow" target="_blank"> GlusterFS </a>和<a class="ae ky" href="https://github.com/nfs-ganesha/nfs-ganesha" rel="noopener ugc nofollow" target="_blank">NFS·甘尼萨</a>构建了一个基本的网络附加存储系统(NAS)。在后续文章中，我展示了如何在您的家庭Kubernetes集群中使用新的存储解决方案。但我用作存储盒的电脑只有150的硬盘空间，如果你想处理大数据，这并不是很多。此外，在<a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>中，它是静态存储，您可以在其中预定义固定的持久卷。</p><p id="107d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要一个动态存储解决方案，允许我根据需要配置持久卷。要以这种方式使用GlusterFS，您需要使用<a class="ae ky" href="https://github.com/heketi/heketi" rel="noopener ugc nofollow" target="_blank"> Heketi </a>，并且深入了解一下，设置起来似乎相当复杂。此外，赫克提似乎处于某种准维持模式，没有足够的人来支持它。这太糟糕了，因为它看起来是一个非常灵活但复杂的存储分配系统。</p><p id="15c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我要扔掉所有的经验，我不得不在我的职业生涯中做了很多，并完全走向另一个方向。在谷歌上搜索，我发现很少有关于为Kubernetes创建存储系统的文章，其中很多文章都谈到了这有多难。所以这篇文章可能有点长，但是我会试着一步一步地解释，如何在不使用晦涩难懂的术语或者晦涩难懂的内核设置的情况下，设置一些有用的东西。它可能不是最佳的，但我决心让它发挥作用。这只是为了我的家庭沙盒。它不像是要为饥渴的互联网提供视频流。</p><p id="da85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你从云提供商那里运行你的Kubernetes集群，比如GCP或者AWS，你不需要这些。这些系统内置了动态卷分配。我在这里这样做是为了展示幕后可能发生的事情，这与我的文章“<a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-4691283e3995" rel="noopener"> Kubernetes from Scratch </a>”的意图是一致的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/6683cc00414fcb7b7dfb31630d126e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hxz3skFD8AVI0JTWmmXJOg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/jonathanmdana-2994675/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1547055" rel="noopener ugc nofollow" target="_blank">乔纳森·达纳</a>从<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1547055" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="2c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为由<a class="ae ky" href="http://edgefs.io/" rel="noopener ugc nofollow" target="_blank"> EdgeFS </a>支持的<a class="ae ky" href="https://rook.github.io/" rel="noopener ugc nofollow" target="_blank"> Rook </a>是一个相对简单但灵活的存储解决方案。Rook/EdgeFS是一个严格的Kubernetes解决方案，所以你不会有独立的存储；这些都将纳入Kubernetes系统。我将使用我现有的裸机系统，并添加三个新节点，作为一个EdgeFS集群来处理系统其余部分的所有持久存储。</p><p id="0c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从我在“<a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-4691283e3995" rel="noopener"> Kubernetes from Scratch </a>”和“<a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-part-2-e30b48f7ca6b" rel="noopener"> Kubernetes from Scratch(第2部分)】</a>”文章中构建的机器开始，添加三个新的虚拟机，每个虚拟机将完全控制一个新的4tb外部驱动器的三分之一。我选择3是因为，对于集群来说，3是工作良好的最小数字。我可能应该有三个1tb的驱动器，但他们在一个4T驱动器上有交易，我无法抗拒交易。</p><p id="d051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您没有遵循“Kubernetes从零开始”的文章，您将需要一台能够运行几个虚拟机的主机，至少有32g的RAM和十几个CPU核心。它还应该至少已经安装了控制面板Kubernetes节点，并与一组常用的附加组件(如网络和入口)一起运行。就我而言，我使用的是翻新的机架式服务器。它不是很漂亮，但它在一个扁平闪亮的盒子里集成了大量的计算能力。我的猫喜欢躺在上面，因为它很温暖。</p><p id="0049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，在我们创建虚拟机之前，我会将硬盘分成三个分区，这样每个新虚拟机都可以完全控制一个分区。</p><p id="32bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">插入外部驱动器后，使用<code class="fe lw lx ly lz b">lsblk</code>查找其名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c40e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我的电脑上只有一个4tb的驱动器，所以很容易推断出它是<code class="fe lw lx ly lz b">sdb</code>。它已经被分成了<code class="fe lw lx ly lz b">sdb1</code>和<code class="fe lw lx ly lz b">sdb2</code>，但是我们将撤销它。</p><p id="2621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Linux磁盘格式化的瑞士军刀是<code class="fe lw lx ly lz b">fdisk</code>。假设磁盘是<code class="fe lw lx ly lz b">sdb</code>，就像我的例子一样，然后运行<code class="fe lw lx ly lz b">sudo fdisk /dev/sdb</code>。当提示符出现时，键入“m”以获取命令列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="3f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要做的第一件事是‘g’创建一个新的空分区表:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="8381" class="mg mh it lz b gy mi mj l mk ml">Command (m for help): g<br/>Created a new GPT disklabel (GUID: 743C7681-2815-C044-B0F0-BB82C7427D0D).</span></pre><p id="19b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，“n”命令将创建一个新分区:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="2c27" class="mg mh it lz b gy mi mj l mk ml">Command (m for help): n<br/>Partition number (1-128, default 1): <br/>First sector (65535-976754640, default 65535): <br/>Last sector, +/-sectors or +/-size{K,M,G,T,P} (65535-976754640, default 976754640): 325584880</span></pre><p id="8a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前两个值是默认值。我用325584880作为第三个值，因为它是976754640的三分之一。现在，我们为第二个分区运行“n”命令:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="4857" class="mg mh it lz b gy mi mj l mk ml">Command (m for help): n<br/>Partition number (2-128, default 2): <br/>First sector (325584880-976754640, default 488432355): <br/>Last sector, +/-sectors or +/-size{K,M,G,T,P} (488432355-976754640, default 976754640): 651169760</span></pre><p id="2479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次我用651169760做最后一个扇区。为最后一个分区再键入一次“n”。</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="9188" class="mg mh it lz b gy mi mj l mk ml">Command (m for help): n<br/>Partition number (3-128, default 3): <br/>First sector (651169760-976754640, default 651169760): <br/>Last sector, +/-sectors or +/-size{K,M,G,T,P} (651169760-976754640, default 976754640):</span></pre><p id="9eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我可以接受所有的默认值。现在用' p '命令列出分区表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="01b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，键入“w”写出新的分区表。再次使用<code class="fe lw lx ly lz b">lsblk</code>命令查看您的块设备:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="ee6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以看到<code class="fe lw lx ly lz b">sdb</code>被平均分为<code class="fe lw lx ly lz b">sdb1, sdb2</code>和<code class="fe lw lx ly lz b">sdb3</code>。</p><p id="6561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要三台虚拟机，每台虚拟机都有一个分区。我使用<code class="fe lw lx ly lz b">virt-install</code> KVM命令创建了一个VM，它有一个<code class="fe lw lx ly lz b">vcpu</code>，2gb的RAM和一个新的磁盘分区。下面是该命令的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">名字会是<code class="fe lw lx ly lz b">node1</code>，磁盘会是<code class="fe lw lx ly lz b">/dev/sdb1</code>，第一个分区。</p><blockquote class="mm mn mo"><p id="ad23" class="kz la mp lb b lc ld ju le lf lg jx lh mq lj lk ll mr ln lo lp ms lr ls lt lu im bi translated">注意:我的经验是2048兆的内存是不够的，我已经把它改成了4096和2个vcpus。此外，重启后<code class="fe lw lx ly lz b">/dev/sdb1</code>不一致。我推荐用<code class="fe lw lx ly lz b">/dev/disk/by-partuuid/&lt;partition-uuid&gt;</code>代替。用<code class="fe lw lx ly lz b">lsblk -O</code>命令找到分区uuid。</p></blockquote><p id="93a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着虚拟机安装的进展，我们可以采用大多数选项的默认值。当它询问主机名时，为了一致起见，您应该使用<code class="fe lw lx ly lz b">node1</code>。</p><blockquote class="mm mn mo"><p id="26e4" class="kz la mp lb b lc ld ju le lf lg jx lh mq lj lk ll mr ln lo lp ms lr ls lt lu im bi translated">注意:从2020年6月6日开始，以下部分不再适用于安装程序。我建议使用默认分区，稍后创建<code class="fe lw lx ly lz b">/storage</code>目录。</p></blockquote><p id="e2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在准备磁盘时，您需要制作两个分区，一个20gb的分区用于操作系统，其余的用作存储区域。选择“引导—使用整个磁盘”并按照说明创建第一个格式化为<code class="fe lw lx ly lz b">xfs</code>的20 GB驱动器，可引导并安装在<code class="fe lw lx ly lz b">/</code>上。另一个分区也应该是<code class="fe lw lx ly lz b">xfs</code>并安装在<code class="fe lw lx ly lz b">/storage</code>上。你可以选择<code class="fe lw lx ly lz b">ext4</code>或者其他文件系统，但是<code class="fe lw lx ly lz b">xfs</code>听起来很酷，为什么不呢？您的最终屏幕将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/7de2b3343e5d5b04bfbe07a8123cb70c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7WL1xWMO4JlfNceiIqedQ.png"/></div></div></figure><p id="ca41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择“完成分区并将更改写入磁盘”,并在询问您是否确定时回答“是”。</p><p id="f467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将再次被提示问题。对于大部分，你可以采取默认或者合理的答案。当它问你要安装什么软件时，只需选择OpenSSH，我们将需要它来与服务器通信。</p><p id="5bb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，使用<code class="fe lw lx ly lz b">virsh domifaddr node1</code>找到IP地址并将其添加到您的<code class="fe lw lx ly lz b">/etc/hosts</code>中。然后就可以用<code class="fe lw lx ly lz b">ssh-copy-id node1</code>把主要主机的ssh密钥复制到新主机上。</p><p id="f7ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在对<code class="fe lw lx ly lz b">node2</code>和<code class="fe lw lx ly lz b">node3</code>做同样的操作。将名称改为<code class="fe lw lx ly lz b">node2</code>和<code class="fe lw lx ly lz b">node3</code>，并使用我们创建的第二个和第三个分区。对我来说，那是<code class="fe lw lx ly lz b">/dev/sdb2</code>和<code class="fe lw lx ly lz b">/dev/sdb3</code>。</p><p id="f6e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们有三个虚拟机，每个都有大约1.2的存储。下一步是使每个VM成为Kubernetes节点，并将其加入主集群。我们需要ssh到每个节点，并执行以下任务。</p><p id="2bbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要准备新虚拟机进行安装，首先要确保swap处于关闭状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="27fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过向您的<code class="fe lw lx ly lz b">/etc/modules-load.d/modules.conf</code>文件添加几行来启用桥接和覆盖:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="9886" class="mg mh it lz b gy mi mj l mk ml">overlay<br/>br_netfilter</span></pre><p id="2815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并在您的<code class="fe lw lx ly lz b">/etc/sysctl.conf</code>文件中添加几行:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="a163" class="mg mh it lz b gy mi mj l mk ml"># added for kubernetes bridge<br/>net.bridge.bridge-nf-call-ip6tables = 1<br/>net.ipv4.ip_forward                 = 1<br/>net.bridge.bridge-nf-call-iptables  = 1</span></pre><p id="2633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后重新启动你的虚拟机，使其生效。</p><p id="3f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Kubernetes是一个容器编排系统，我们需要一个它可以编排的容器系统。您可以使用许多容器系统，但是我们将使用<a class="ae ky" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank"> containerd </a>。这是一个两行的Ubuntu安装程序:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="cfae" class="mg mh it lz b gy mi mj l mk ml">sudo apt-get update <br/>sudo apt-get install containerd</span></pre><p id="9a30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以安装Kubernetes的神圣三位一体，<code class="fe lw lx ly lz b">kubeadm/kubectl/kubelet</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试<code class="fe lw lx ly lz b">kubeadm</code>可以访问我们之前安装的<code class="fe lw lx ly lz b">containerd</code>，我们可以运行<code class="fe lw lx ly lz b">sudo kubeadm config images pull</code>。它会花一些时间提取一些它需要的图像，我们知道它可以和<code class="fe lw lx ly lz b">containerd</code>对话。</p><p id="b0c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要将新节点<code class="fe lw lx ly lz b">join</code>到现有集群。您必须ssh到您的控制面板节点，在我的例子中是<code class="fe lw lx ly lz b">kube1</code>，并获得一个新令牌以允许新节点加入:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="7bf3" class="mg mh it lz b gy mi mj l mk ml">rkamradt@kube1:~$ kubeadm token create --print-join-command<br/>kubeadm join 192.168.122.39:6443 --token XXXXX.XXXXXXXXXXXXX \<br/>    --discovery-token-ca-cert-hash sha256:XXXXXXXXXXXXXX</span></pre><p id="172d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制它的输出，然后ssh到您的新节点并运行它(前缀为<code class="fe lw lx ly lz b">sudo</code>)。</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="03d0" class="mg mh it lz b gy mi mj l mk ml">sudo kubeadm join 192.168.122.39:6443 --token XXXXX.XXXXXXXXXXXXX \<br/>    --discovery-token-ca-cert-hash sha256:XXXXXXXXXXXXXX</span></pre><p id="8f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到您的主机，您可以列出节点:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="5a40" class="mg mh it lz b gy mi mj l mk ml">rkamradt@beast:~$ kubectl get nodes<br/>NAME    STATUS   ROLES    AGE   VERSION<br/>kube1   Ready    master   37d   v1.18.1<br/>kube2   Ready    &lt;none&gt;   37d   v1.18.1<br/>kube3   Ready    &lt;none&gt;   35d   v1.18.1<br/>kube4   Ready    &lt;none&gt;   35d   v1.18.1<br/>node1   Ready    &lt;none&gt;   13m   v1.18.2</span></pre><p id="f548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可能暂时不会显示准备就绪；花了几分钟时间来解决新节点和集群之间的所有问题。我们只给了节点2gb的内存，所以事情有点紧张，但我们应该在新节点上运行的唯一东西是与存储相关的。</p><p id="3a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在另外两个虚拟机上安装Kubernetes节点。</p><p id="3dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您的所有节点启动并运行，我们就可以安装Rook并启动一个存储集群。首先，启动基本系统。在您的主主机上，运行以下命令:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="5205" class="mg mh it lz b gy mi mj l mk ml">git clone --single-branch --branch master \<br/>          https://github.com/rook/rook.git<br/>cd rook/cluster/examples/kubernetes/edgefs<br/>kubectl create -f operator.yaml</span></pre><p id="98de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很简单。现在等一分钟，然后验证一切都在运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="cd62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到的一点是<code class="fe lw lx ly lz b">rook-discover</code>是一个<code class="fe lw lx ly lz b">daemonset</code>。一个<code class="fe lw lx ly lz b">daemonset</code>是一种特殊的<code class="fe lw lx ly lz b">replicaset</code>，它确保每个工作者节点上都有一个pod在运行。我们有六个工作节点，所以您应该有六个单元。</p><p id="0df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦一切运行完毕，我们就可以设置拓扑并将EdgeFS集群部署到Kubernetes pods中。在<code class="fe lw lx ly lz b">rook/cluster/examples/kubernetes/edgefs</code>目录中有一个名为<code class="fe lw lx ly lz b">cluster.yaml</code>的文件，需要稍加编辑。大部分都没问题，但是文件末尾的实际集群定义需要了解我们的节点和磁盘。这是我们刚刚创建的设置的新集群定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a3b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意对于<code class="fe lw lx ly lz b">spec.storage.directories.path</code>，只有一个条目。所有节点都需要有相同的路径指向我们之前设置的已装载驱动器。删除<code class="fe lw lx ly lz b">cluster.yaml</code>末尾的集群定义，并替换为上面的定义。然后就可以应用了:<code class="fe lw lx ly lz b">kubectl apply -f cluster.yaml</code>。</p><p id="19d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将所有这些文件复制到一个名为<a class="ae ky" href="https://github.com/rkamradt/storage-deploy/tree/v1.0" rel="noopener ugc nofollow" target="_blank"> storage-deploy </a>的GitHub存储库中。在上面，我将<code class="fe lw lx ly lz b">cluster.yaml</code>分成两个文件，<code class="fe lw lx ly lz b">clusterprep.yaml</code>和<code class="fe lw lx ly lz b">cluster.yaml</code>，最后一个文件只包含集群定义。</p><p id="f6ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过一会儿，您应该会看到这样的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="8025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你有一个<code class="fe lw lx ly lz b">rook-edgefs-mgr</code>吊舱和三个<code class="fe lw lx ly lz b">rook-edgefs-target</code>吊舱在运行。目标舱在你的每个节点上。我们刚刚创建的Kubernetes节点已经被转换为<code class="fe lw lx ly lz b">edgefs</code>节点1–3。请注意，您也有一个<code class="fe lw lx ly lz b">rook-edgefs-ui</code>。我将通过一个入口(你可以在上面提到的GitHub页面上找到的定义)来公开它，然后，在将<code class="fe lw lx ly lz b">rook.local</code>添加到我的<code class="fe lw lx ly lz b">/etc/hosts</code>文件后，我可以浏览到https://rook.local。使用用户<code class="fe lw lx ly lz b">admin</code>和密码<code class="fe lw lx ly lz b">edgefs</code>登录，并查看你的EdgeFS集群的所有GUI荣耀！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/f95d048d622c44c1dea125b129912e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfITUFiEUxKHCiWOU608pg.png"/></div></div></figure><p id="7cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的下一篇文章中，我承诺对我的Kubernetes集群中的所有新存储做一些事情。但在此之前，我将沉浸在EdgeFS集群实际启动和运行的喜悦中。</p><p id="5036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一次漫长的跋涉，如果你一路走到了终点，我为你鼓掌。如果你真的让它运行起来，那是一个很大的成就。在此过程中，我不得不解决许多不同的问题。仅仅因为我以线性叙述的方式解释了这一切，并不意味着我不需要回溯几次才能把事情做好。但是我希望我的努力已经给了你正确构建这个东西所需要的指导。</p><p id="56d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是本文脚本的GitHub存储库:<a class="ae ky" href="https://github.com/rkamradt/storage-deploy/tree/v1.0" rel="noopener ugc nofollow" target="_blank">https://github.com/rkamradt/storage-deploy/tree/v1.0</a></p><p id="72a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提到的其他文章:</p><ul class=""><li id="5f10" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated"><a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-4691283e3995" rel="noopener"> Kubernetes从零开始</a></li><li id="0672" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-part-2-e30b48f7ca6b" rel="noopener"> Kubernetes从零开始(第二部分)</a></li><li id="9073" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://medium.com/better-programming/build-your-own-in-home-cloud-storage-1aa74b5c6397" rel="noopener">打造您自己的家庭云存储(第一部分)</a></li></ul></div></div>    
</body>
</html>