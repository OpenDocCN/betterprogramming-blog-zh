<html>
<head>
<title>URLs in Swift: Common Scenarios Explained In-Depth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的URL:深入解释的常见场景</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/urls-in-swift-common-scenarios-explained-in-depth-316d606df6b2?source=collection_archive---------11-----------------------#2020-04-21">https://betterprogramming.pub/urls-in-swift-common-scenarios-explained-in-depth-316d606df6b2?source=collection_archive---------11-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="93b6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于Swift中的URL，您需要了解的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5dfc31a5d0d6e74f2d6d2c18b37bc696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm-rAM3-_QB1aLP9CFDynw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@marcsm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马克·森德拉·马托雷尔</a>在<a class="ae ky" href="https://unsplash.com/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="d865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">URL在我们构建的应用程序中无处不在。我们使用包路径引用本地文件，从指向API的路径获取数据，并获取图像以显示视觉效果。当使用URL时，我们经常需要验证一些东西，比如确保它指向一个文件或者设置了某个查询属性。</p><p id="ea6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一些操作可能很容易记住，不需要像这样的深入指导。然而，我发现自己经常搜索解释如何用一组给定的查询参数构建URL的一个堆栈溢出问题。作为一个博主，这是我决定为自己写一本手册与大家分享的时刻！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7094" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基本URL操作</h1><p id="a89f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这一切都从创建和使用链接的基本操作开始。例如，您可以将字符串值转换为URL，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5f50" class="ne md it na b gy nf ng l nh ni">let url = URL(string: "https://www.avanderlee.com")!</span></pre><p id="34c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个默认初始化器的缺点是我们可能不得不在整个代码库中复制强制解包。我们可以通过一个简单的扩展来防止这种情况:一个定制的初始化器:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="12ce" class="ne md it na b gy nf ng l nh ni">extension URL {<br/>    init(_ string: String) {<br/>        self.init(string: "\(string)")!<br/>    }<br/>}<br/><br/>var unwrappedURL = URL("https://www.avanderlee.com")</span></pre><p id="e24b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来要快得多，并且允许我们保持我们的实现代码干净，不被打开！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0382" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">将URL转换成字符串</strong></h1><p id="61d8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">还可以使用<code class="fe nj nk nl na b">absoluteString</code>属性将URL转换成<code class="fe nj nk nl na b">String</code>:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b95d" class="ne md it na b gy nf ng l nh ni">print(unwrappedURL.absoluteString) // Prints: <a class="ae ky" href="https://www.avanderlee.com" rel="noopener ugc nofollow" target="_blank">https://www.avanderlee.com</a></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e01" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">制作相对于基础URL的URL </strong></h1><p id="fd30" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Swift中构建API时经常使用的一个场景是通过使用基本URL来构建链接。例如，我们可以建立一个博客文章类别页面，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f5f7" class="ne md it na b gy nf ng l nh ni">let category = "swift"<br/>let baseURL = URL(string: "https://www.avanderlee.com")!<br/>let blogURL = URL(string: category, relativeTo: baseURL)!<br/>print(blogURL) // Prints: swift -- https://www.avanderlee.com<br/>print(blogURL.absoluteString) // Prints: <a class="ae ky" href="https://www.avanderlee.com/swift" rel="noopener ugc nofollow" target="_blank">https://www.avanderlee.com/swift</a></span></pre><p id="878e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，如果URL本身不是绝对的，您可以获得某个链接的基:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9da2" class="ne md it na b gy nf ng l nh ni">let absoluteURL = URL(string: "https://www.avanderlee.com")!<br/>let relativeURL = URL(string: "swift", relativeTo: baseURL)!<br/>print(absoluteURL.baseURL) // Prints: nil<br/>print(relativeURL.baseURL!) // Prints: <a class="ae ky" href="https://www.avanderlee.com" rel="noopener ugc nofollow" target="_blank">https://www.avanderlee.com</a></span></pre><p id="d4a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个基本URL经常与获取一个链接的主机相混淆，该链接打印出没有其方案的域。使用<code class="fe nj nk nl na b">scheme</code>参数可以得到方案:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e442" class="ne md it na b gy nf ng l nh ni">let swiftLeeURL = URL(string: "https://www.avanderlee.com")!<br/>print(absoluteURL.host!) // Prints: www.avanderlee.com<br/>print(absoluteURL.scheme!) // Prints: https</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="271d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">使用URL组件</strong></h1><p id="c150" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个链接基本上是由几个部分组成的。我们之前已经在打印语句中看到了一些，但是还有更多的组件需要介绍:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d535" class="ne md it na b gy nf ng l nh ni">let twitterAvatarURL = URL(string: "https://twitter.com/twannl/photo.png?width=200&amp;height=200")!<br/>print(twitterAvatarURL.path) // Prints: /twannl/photo.png<br/>print(twitterAvatarURL.pathComponents) // Prints: ["/", "twannl", "photo.png"]<br/>print(twitterAvatarURL.pathExtension) // Prints: png<br/>print(twitterAvatarURL.lastPathComponent) // Prints: photo.png</span></pre><p id="5d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些属性在很多情况下非常有用，比如获取文件名或扩展名，但是它们没有提供查询项。这就是<code class="fe nj nk nl na b">URLComponents</code>发挥作用的地方。</p><h2 id="d2c9" class="ne md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated"><strong class="ak">获取查询参数的值</strong></h2><p id="71c4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上面的Twitter头像链接包含两个描述图像宽度和高度的查询参数。这是很重要的信息，所以我们要确保图像以正确的比例显示。因此，我们需要能够获得这些查询参数及其值。</p><p id="d9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用一个用链接初始化的<code class="fe nj nk nl na b">URLComponents</code>实例来做到这一点，这使我们能够访问一个新的属性集合。您基本上可以将它视为一个URL解析器，它让我们能够访问例如查询项:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a796" class="ne md it na b gy nf ng l nh ni">let components = URLComponents(string: "https://twitter.com/twannl/photo.png?width=200&amp;height=200")!<br/>print(components.query!) // width=200&amp;height=200<br/>print(components.queryItems!) // [width=200, height=200]</span></pre><p id="edcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nx">注意URLComponents结构根据</em> <a class="ae ky" href="https://www.ietf.org/rfc/rfc3986.txt" rel="noopener ugc nofollow" target="_blank"> <em class="nx"> RFC 3986 </em> </a> <em class="nx">解析并构造URL。它的行为与URL结构的行为略有不同，后者符合较老的RFC。但是，您可以根据URLComponents值的内容轻松获得URL值，反之亦然。</em></p><p id="8441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们通过检查查询项数组来直接访问值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="084b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这仍然不是最漂亮的一段代码。我们用了很多未包装的东西，不太可读。我们可以使用一个自定义的下标，让代码看起来更漂亮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nx">自定义下标的新功能？查看我的博文</em> <a class="ae ky" href="https://www.avanderlee.com/swift/custom-subscripts/" rel="noopener ugc nofollow" target="_blank"> <em class="nx">用代码示例</em> </a>解释Swift中的自定义下标。</p><p id="bd62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，仍然有很多解包——我会让您通过使用保护来使解包看起来更好——但至少我们可以更容易地访问查询项。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="547a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">构造带参数的URL</strong></h1><p id="061d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一种方法是用字典中的查询参数构建一个URL。这通常在构建API框架时使用。</p><p id="7143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想要获取一个具有特定宽度和高度的虚拟形象，我们可以像这样构建它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里编写一个扩展可能也很有价值，这样可以更容易地将字典转换成一组查询项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="a7ca" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated"><strong class="ak">使用文件URL</strong></h1><p id="b0a1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当构建应用程序时，我们经常引用本地或远程文件。您可以从远程位置下载某个图像，也可以从本地包中获取图像。</p><p id="d920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解远程URL和本地URL之间的区别是有好处的。使用<code class="fe nj nk nl na b">isFileURL</code>参数时，只有后者被视为文件URL:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9243" class="ne md it na b gy nf ng l nh ni">var remoteFileURL = URL(string: "https://www.twitter.com/avatar.jpg")!<br/>var fileURL = URL(string: "file:///users/antoine/avatar.jpg")!<br/>print(remoteFileURL.isFileURL) // Prints: false<br/>print(fileURL.isFileURL) // Prints: true</span></pre><p id="2c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该属性基本上只在URL方案为<code class="fe nj nk nl na b">file:</code>时返回true。</p><h2 id="078a" class="ne md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated"><strong class="ak">从文件路径获取文件扩展名</strong></h2><p id="b3f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当处理文件时，您通常希望知道文件扩展名以确定文件类型。您可以通过使用路径扩展参数来实现这一点:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="01ac" class="ne md it na b gy nf ng l nh ni">print(fileURL.pathExtension) // Prints: jpg</span></pre><h2 id="913c" class="ne md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated"><strong class="ak">如何在Swift中从文件路径中获取文件名</strong></h2><p id="be4e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要从文件URL获取文件名，我们可以使用<code class="fe nj nk nl na b">lastPathComponent</code>并通过删除文件扩展名来提取文件名:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0853" class="ne md it na b gy nf ng l nh ni">print(fileURL.deletingPathExtension().lastPathComponent) // Prints: avatar</span></pre><p id="d88b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是很简单吗？如果您想在UI中显示文件名，这非常有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2457" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e744" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Swift中的URL有很多用途。我们使用API获取数据，图像来可视化我们的应用程序，我们经常使用我们的包中的本地文件。<code class="fe nj nk nl na b">Foundation</code>框架允许我们使用默认参数轻松访问许多URL组件。如果我们需要访问像查询项这样的URL组件，我们可以使用<code class="fe nj nk nl na b">URLComponents</code>类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="8b8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nx">你认为我错过了使用URL的重要部分吗？请，</em> <a class="ae ky" href="mailto:contact@avanderlee.com" rel="noopener ugc nofollow" target="_blank"> <em class="nx">让我知道</em> </a> <em class="nx">！</em></p><p id="6673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想继续提高您的Swift知识，请查看<a class="ae ky" href="https://www.avanderlee.com/category/swift/" rel="noopener ugc nofollow" target="_blank"> Swift类别页面</a>。如果您有任何其他建议或反馈，请随时<a class="ae ky" href="mailto:contact@avanderlee.com" rel="noopener ugc nofollow" target="_blank">联系我</a>或在<a class="ae ky" href="https://www.twitter.com/twannl" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上发推文给我。</p><p id="d7e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>