<html>
<head>
<title>Create and Test Custom React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建并测试定制的React挂钩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-and-test-custom-react-hooks-6e0fa4656561?source=collection_archive---------5-----------------------#2021-02-10">https://betterprogramming.pub/create-and-test-custom-react-hooks-6e0fa4656561?source=collection_archive---------5-----------------------#2021-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6144" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设置Next.js、TypeScript、Jest和React测试库，以便在React中使用和测试我们的定制挂钩</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a49bce745b176da074d7ed9d24259276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zvlJFWz9U1bbAV0M"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@padraigo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Padraig Treanor </a>拍摄的照片。</p></figure><p id="a580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React挂钩在2018年10月的React Conf上向世界推出，后来在2019年2月作为React版本<code class="fe lv lw lx ly b">16.8.0</code>的一部分发货。</p><p id="b003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是游戏规则的改变者，因为你不再需要对ES6类使用React。一切都可以通过<code class="fe lv lw lx ly b">React Functional Components</code>发生。</p><p id="4ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React钩子将取代你管理属性更新和状态的方式。这是一种更具声明性且更简单的方法。创建定制挂钩既简单又直观。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4d2d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一点背景知识</h1><p id="735b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在React挂钩之前，使用<code class="fe lv lw lx ly b">Render Props</code>方法或通过<code class="fe lv lw lx ly b">High Order Components</code>在组件间共享逻辑。</p><blockquote class="nd"><p id="01a5" class="ne nf it bd ng nh ni nj nk nl nm lu dk translated">“术语“<a class="ae ky" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank">渲染属性</a>”指的是一种使用属性值为函数的属性在React组件之间共享代码的技术。”— <a class="ae ky" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a></p></blockquote><p id="ee7f" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这两种方法看起来很粗糙，产生了非常混乱的JSX语法。你可能会以“渲染道具回调地狱”或“包装地狱”而告终。</p><p id="387c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了React钩子，我们可以以更好的方式重用和嵌入组件的逻辑。我们可以紧密耦合相关的逻辑。钩子是可测试和可组合的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d2ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论:</p><ol class=""><li id="8ec5" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">使用Next.js + Typescript创建和配置基本应用程序</li><li id="944d" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">重构应用程序，将一些逻辑封装在自定义的渲染挂钩中</li><li id="d0d6" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">使用库来测试新创建的定制钩子</li></ol><p id="fbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有很多要讲的，所以让我们开始吧！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2cf1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建我们的Next.js应用程序</h1><p id="c04a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了运行所有代码，我们将创建一个Next.js应用程序。</p><p id="ba72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从运行命令开始:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="1589" class="om mh it ly b gy on oo l op oq">npx create-next-app</span></pre><p id="b21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，有三个命令可用:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="7dac" class="om mh it ly b gy on oo l op oq">yarn dev<br/>    Starts the development server.</span><span id="d316" class="om mh it ly b gy or oo l op oq">yarn build<br/>    Builds the app for production.</span><span id="4f2e" class="om mh it ly b gy or oo l op oq">yarn start<br/>    Runs the built app in production mode.</span></pre><p id="35c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将TypeScript添加到项目中。Next.js通过几个步骤支持开箱即用。您可以查看官方文档<a class="ae ky" href="https://nextjs.org/docs/basic-features/typescript" rel="noopener ugc nofollow" target="_blank">了解更多信息</a>。</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="cb29" class="om mh it ly b gy on oo l op oq">touch tsconfig.json</span></pre><p id="9cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们安装TypeScript依赖项:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="086a" class="om mh it ly b gy on oo l op oq">yarn add --dev typescript <a class="ae ky" href="http://twitter.com/types/react" rel="noopener ugc nofollow" target="_blank">@types/react</a> <a class="ae ky" href="http://twitter.com/types/node" rel="noopener ugc nofollow" target="_blank">@types/node</a></span></pre><p id="41ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，让我们执行:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="2340" class="om mh it ly b gy on oo l op oq">npm run dev</span></pre><p id="66fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将检测到您的项目正在使用TypeScript，并将为您配置已创建的<code class="fe lv lw lx ly b">tsconfig</code>。它为您提供了一个简单的配置，您可以根据自己的需要进行定制。一旦完成了TypeScript，它将在端口3000上运行应用程序，并且应该可以在<a class="ae ky" href="https://localhost:3000." rel="noopener ugc nofollow" target="_blank"> https://localhost:3000 </a>上访问。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7802" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">示例应用程序</h1><p id="c440" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们创建一个简单的React可扩展组件。这个组件将把一个<code class="fe lv lw lx ly b">summary</code>和一个<code class="fe lv lw lx ly b">description</code>作为参数。只有按下<code class="fe lv lw lx ly b">button</code>才会显示描述。一旦再按，就会隐藏起来。<code class="fe lv lw lx ly b">button</code>将作为一个开关。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os nt l"/></div></figure><p id="628b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果文件匹配<code class="fe lv lw lx ly b">[name].module.css</code>模式，Next.js支持开箱即用的<code class="fe lv lw lx ly b">css-in-js</code>。我们的<code class="fe lv lw lx ly b">Expand.module.css</code>很简单:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="ddb5" class="om mh it ly b gy on oo l op oq">.container {<br/>  padding: 1rem 0;<br/>}</span></pre><p id="6b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ot">注意:通常情况下，需要在一个单独的文件中创建</em> <code class="fe lv lw lx ly b"><em class="ot">Block</em></code> <em class="ot">组件。我在一个地方做所有的事情，这样更容易想象。</em></p><p id="30ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们的组件在运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/cf2de540b12e1b5742d9f775501b8428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kWJpUACwG6dcARkN7Ejzhg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截屏。</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="424d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">React挂钩复习</h1><p id="99e4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们快速回顾一下关于挂钩的规则:</p><ul class=""><li id="bce2" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu ov oa ob oc bi translated">只调用顶层的钩子。不要在循环、条件或嵌套函数中调用钩子。</li><li id="f9fc" class="nu nv it lb b lc od lf oe li of lm og lq oh lu ov oa ob oc bi translated">只有React挂钩可以从React组件中调用。它们不会在React生态系统之外工作。</li><li id="0174" class="nu nv it lb b lc od lf oe li of lm og lq oh lu ov oa ob oc bi translated">钩子可以嵌套。</li></ul><p id="e888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保这些规则始终得到遵守，我们可以使用以下ESLint规则:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="d7e5" class="om mh it ly b gy on oo l op oq">yarn add --dev<!-- --> eslint-plugin-react-hooks</span></pre><p id="f161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并使用它:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="1aa3" class="om mh it ly b gy on oo l op oq">{<br/>  "plugins": [<br/>    // ...<br/>    "react-hooks"<br/>  ],<br/>  "rules": {<br/>    // ...<br/>    "react-hooks/rules-of-hooks": "error", // Checks rules of Hooks<br/>    "react-hooks/exhaustive-deps": "warn" // Checks effect dependencies<br/>  }<br/>}</span></pre><p id="3a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定制钩子需要总是重用基本的React逻辑来刷新组件。你可以把这些基础钩子看作钩子原语。这些是:</p><ul class=""><li id="5f4d" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu ov oa ob oc bi translated"><code class="fe lv lw lx ly b">useReducer</code></li><li id="0163" class="nu nv it lb b lc od lf oe li of lm og lq oh lu ov oa ob oc bi translated"><code class="fe lv lw lx ly b">useMemo</code></li><li id="a230" class="nu nv it lb b lc od lf oe li of lm og lq oh lu ov oa ob oc bi translated"><code class="fe lv lw lx ly b">useCallback</code></li><li id="8873" class="nu nv it lb b lc od lf oe li of lm og lq oh lu ov oa ob oc bi translated"><code class="fe lv lw lx ly b">useState</code></li></ul><p id="c5d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的定制钩子的输入和输出完全由我们决定。我们没有任何限制——只有惯例。用与React挂钩一致的方式创建定制挂钩将使它们使用起来更加直观。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4307" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">自定义挂钩</h1><p id="1b5f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们已经复习了一遍，我们准备创建一个React钩子。在这个例子中，我们将创建一个在<code class="fe lv lw lx ly b">true/false</code>状态之间切换的钩子。</p><p id="f18f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe lv lw lx ly b">Expandable</code>组件中使用的切换逻辑可以很容易地在应用程序的不同部分重用。</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="4d15" class="om mh it ly b gy on oo l op oq">const [show, setShow] = useState(false);</span><span id="0ae6" class="om mh it ly b gy or oo l op oq">const toggle = useCallback(() =&gt; {<br/>  setShow(!show);<br/>}, [show, setShow]);</span></pre><p id="55c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个定制的钩子来包装这个逻辑。我们需要做的第一件事是给它一个名字。按照惯例，所有的钩子都带有前缀<code class="fe lv lw lx ly b">use</code>。这种命名约定使得识别它们变得更加容易。因为我们不能有条件地使用它们，所以它们必须易于识别。</p><p id="3712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把我们的钩子命名为<code class="fe lv lw lx ly b">useToggle.ts</code>。我们将把它放在自己的<code class="fe lv lw lx ly b">hooks</code>文件夹中。我们不需要它有一个<code class="fe lv lw lx ly b">tsx</code>扩展，因为钩子将只保存JavaScript逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os nt l"/></div></figure><p id="3ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:注意<code class="fe lv lw lx ly b">return [state, toggle] as const;</code>中的<code class="fe lv lw lx ly b">as const</code>。这将告诉Typescript该数组是固定大小的，因此Typescript可以使用<code class="fe lv lw lx ly b">Tuple</code>来更好地公开数组项类型。</p><p id="c100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在我们的<code class="fe lv lw lx ly b">Expandable</code>组件中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os nt l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9322" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">测试我们的定制钩子</h1><p id="f383" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在是时候测试我们的定制钩子了。这确实能确保它像预期的那样工作，并且不会被未来的反应堆破坏。对于测试，我们将使用React测试库。</p><p id="67bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从安装库开始:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="6ef4" class="om mh it ly b gy on oo l op oq">// installing jest and it's Typescript tools<br/>yarn add --dev jest ts-jest <a class="ae ky" href="http://twitter.com/types/jest" rel="noopener ugc nofollow" target="_blank">@types/jest</a></span><span id="ee40" class="om mh it ly b gy or oo l op oq">// installing React Testing Library<br/>yarn add --dev @testing-library/react</span><span id="b2c6" class="om mh it ly b gy or oo l op oq">// Custom jsdom matchers for React Testing Library<br/>yarn add --dev<!-- --> @testing-library/jest-dom</span><span id="3816" class="om mh it ly b gy or oo l op oq">// User event utility for React Testing Library<br/>yarn add --dev @testing-library/user-event</span></pre><p id="4682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么您需要配置Jest:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="5b5a" class="om mh it ly b gy on oo l op oq">npx ts-jest config:init</span></pre><p id="e6cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Next.js应用程序需要在<code class="fe lv lw lx ly b">tsconfig.json</code>中有<code class="fe lv lw lx ly b">"jsx": “preserve"</code>设置，而这不能与React测试库一起工作，所以你需要一个自定义的<code class="fe lv lw lx ly b">tsconfig.jest.json</code>。但是不要担心，你不需要重新申报整个事情。您可以使用扩展:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="b23c" class="om mh it ly b gy on oo l op oq">module.exports = {<br/>  preset: 'ts-jest',<br/>  globals: {<br/>    "ts-jest": {<br/>      // using a custom tsconfig file<br/>      tsconfig: "tsconfig.jest.json"<br/>    }<br/>  }<br/>};</span></pre><p id="1181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后您的<code class="fe lv lw lx ly b">tsconfig.jest.json</code>文件将如下所示:</p><pre class="kj kk kl km gt oi ly oj ok aw ol bi"><span id="5e5f" class="om mh it ly b gy on oo l op oq">{<br/>  "extends": "./tsconfig.json",<br/>  "compilerOptions": {<br/>    "jsx": "react"<br/>  },<br/>}</span></pre><p id="8791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万岁！我们都是用Next.js + Typescript + Jest + React测试库设置的。我们现在可以专注于测试我们的组件。由于React测试库方法是基于用户行为的，我们将测试定制挂钩对组件的影响:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os nt l"/></div></figure><p id="e250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们使用<code class="fe lv lw lx ly b">TargetComponent</code>来显示/隐藏元素，以匹配定制钩子的输出。如果可能的话，你应该通过钩子的行为来测试它们，而不是它们的实现。<code class="fe lv lw lx ly b">React Testing Library</code>是围绕测试行为而不是方法构建的。如果用户不关心调用了哪些方法，你为什么要关心呢？</p><p id="90d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不可能，你可以随时回到<a class="ae ky" href="https://github.com/testing-library/react-hooks-testing-library" rel="noopener ugc nofollow" target="_blank">react-hooks-testing-library</a>。</p><p id="7d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们运行<code class="fe lv lw lx ly b">yarn jest</code>来看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/42008f7900ead3d873aa3369c1459136.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*lQcuiJfRSszqkxG2tlxjMw.png"/></div></figure><p id="15ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万岁！一切都在按预期工作！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8e2f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">包扎</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/5bb7b82d8316876f7d939b2e948caa22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_fxekubQ1ZrOa_xD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@davealmine?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达维德·扎维亚</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="dc3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到，将现有的React挂钩结合起来，创建一个新的定制挂钩来满足您的需求是多么容易。可能性是无穷的，它是传统的“渲染道具”方法的一个很好的替代品。您将有一个更好的工具来跨组件封装和重用一些逻辑。</p><p id="2c5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在测试方面，我们已经看到一旦我们设置好一切，测试钩子是多么容易。这就像测试一个常规组件。由于钩子被大量重复使用，所以应该对它们进行适当的测试。</p><p id="2757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在本文中找到更多测试见解:</p><div class="oy oz gp gr pa pb"><a href="https://medium.com/better-programming/react-enzyme-vs-react-testing-library-2cac3ad20c52" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">反应酶与反应测试库</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">比较用于测试React组件的两个对比库</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">medium.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pb"/></div></div></a></div><p id="af6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多的React内容将会出现在你面前。干杯！</p></div></div>    
</body>
</html>