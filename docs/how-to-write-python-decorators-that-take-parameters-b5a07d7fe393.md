# 如何编写带参数的 Python 装饰器

> 原文：<https://betterprogramming.pub/how-to-write-python-decorators-that-take-parameters-b5a07d7fe393>

## 超越基本的 Python 装饰器

![](img/21b6bec42280c8a90e352a676390cf24.png)

弗兰克·麦凯纳在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

作为一种通用的面向对象编程语言，Python 通过将数据和功能(包括函数)视为对象来实现其所有操作。像其他数据对象(例如，整数和字符串)一样，函数可以作为参数传递给其他函数，并由其他函数作为输出值返回。

这些使用其他函数作为输入和输出的函数通常被称为*高阶函数*。一种这样的高阶函数是 decorators，它是扩展其他函数(被修饰的函数)的行为而不显式修改它们的函数。请看下面的例子来感受一下。

如上面的代码所示，我们定义了一个 decorator 函数，它基本上返回两次调用传递的函数参数的`wrapper`函数。为了使用这个装饰函数，我们在要被装饰的函数的正上方使用@符号作为装饰函数名的前缀(例如，`echo_wrapper`)。当我们调用修饰函数时，我们可以看到`say_hello`函数确实被调用了两次。这很酷，不是吗？

# 突出的问题

使用上面代码片段中的同一个例子，让我们考虑一个稍微复杂一点的特性。我们如何指定装饰函数需要多少回声呢？到目前为止，它只回显一次(原来的那个加上回显产生了两个印记)。

为了实现这一点，decorator 函数必须有一个机制，允许它将该计数作为一个参数。为了解决这个问题，让我们后退一步，回顾一下装修工的工作。让我们考虑下面的例子。

如上面的代码所示，要利用`echo_wrapper`装饰器函数，我们只需将声明的函数(即`say_hi`)传递给装饰器并调用装饰器函数。正如你所看到的，我们能够通过说两次 Hi 来回应！换句话说，通过将函数发送给装饰器，函数被显式地装饰，并采用装饰器施加的改变的行为。因此,@符号只是一个语法糖，它隐式地改变了被修饰函数的行为。

# 试探性解决方案

通过理解场景背后的东西，考虑更新装饰函数的一个天真的方法是添加另一个参数，即回显次数的计数。这样的实现如下所示。

如您所见，我们能够通过显式使用装饰器来指定回显计数。让我们更进一步，看看我们是否可以简单地使用@符号。

不幸的是，这种方法似乎行不通。如上面的代码片段所示，错误告诉我们新的装饰器是`missing 1 required positional argument: ‘func’`，因此它无法装饰`greet`函数。由于这一失败，尝试调用该函数肯定是行不通的。

我们怎样才能用一种允许我们使用@ symbol 语法进行函数修饰的方式来解决这个问题呢？毕竟，我确实相信使用@符号比显式调用装饰器更好。

> “漂亮总比难看好。”-蟒蛇的禅

# 更好的解决方案

为了找到更好的解决方案，我们要解决的第一个问题是为什么会产生错误`missing 1 required positional argument: ‘func’`。错误信息非常清楚。当我们使用@符号进行修饰时，我们的 Python 解释器只能找到关键字参数`count`，而不能找到位置参数`func`。

为了防止解释器寻找`func`参数，下面是我们解决问题的方法。因为它不太简单，所以我包含了一些打印日志，这样我们就可以知道代码的哪些部分被准确地调用了。

在上面的代码中，我们声明了一个名为`better_echo_wrapper_count`的装饰器，它只接受一个`count`参数。在其中，我们声明了一个嵌套函数，它可以将待修饰的函数作为参数，并返回包装的函数。

为什么会这样？让我们来看一下装饰步骤，如下面的第 2 部分所示，它具有与这个装饰函数完全相同的打印输出。

下面是了解装修过程的关键。你可以认为`@better_echo_wrapper_count(count=3)`是调用`better_echo_wrapper_count`函数。重要的是，返回的装饰函数`decorator`装饰了`good_morning`函数。流程是这样的:`@better_echo_wrapper_count(count=3) -> @decorator -> decoration`。

基本上，您必须使用圆括号调用更好的装饰函数，如`better_echo_wrapper_count()`，以获得返回的嵌套装饰函数。如果您想省略括号，Python 解释器所做的就是假设您正在将待修饰的函数作为`count`参数传递，这根本行不通。考虑下面的例子，注意为`count`参数打印的粗体字。

可以接受的是，我们可以要求这个`better_echo_wrapper_count`的所有用户记得使用括号，使装饰按预期工作。但是如果有人忘记使用括号怎么办？从预防 bug 的角度来看，我们可能想现在就处理它。

我们如何做到这一点？

# 最佳解决方案—版本 1

为了得到最好的解决方案，我们只需要实现一种机制，能够处理装饰者被用作`@decorator`和`@decorator()`的情况。对于前一种情况，装饰函数将待装饰函数作为位置参数，而对于后一种情况，装饰函数执行并返回其嵌套的装饰函数，该函数随后装饰待装饰函数。

如果我们同意这种理解，我们可以继续下面的代码片段，看看如何创建正确的分支。

如上面的代码所示，我已经列出了处理我们上面讨论的两个场景的两个可能的分支，我们可以用下面的例子来尝试这两个分支。太好了，一切正常。

# 最佳解决方案—版本 2

我们很高兴我们得到了最好的解决方案，它允许用户根据需要省略括号或者指定`count`参数。然而，如果您更仔细地关注声明的 decorator `best_echo_wrapper_count`函数，您会发现许多代码都是重复的。让我们考虑下面缩短的伪代码。

如您所见，`outer_decorator0`和`outer_decorator1`函数具有完全相同的结构。因此，我们应该考虑称为 *currying* 的技术，它指的是通过应用部分参数从现有函数创建新函数。如果您有兴趣了解更多，我在以前的文章“Python 函数:Lambdas、Closures、decorator 和 Currying ”中介绍了这个主题和常规 decorator

因此，我们可以通过应用部分函数技术来更新我们的最佳解决方案。请看下面的代码。

如上面的代码所示，当`func`参数为`None`时，我们使用根据需要返回装饰函数的`partial`函数。我们用两个例子来测试更新的版本，两个例子都像预期的那样工作。

# 结论

在本文中，我们回顾了如何编写接受参数的装饰器。更重要的是，我们学会了编写更健壮的装饰器，可以处理不使用括号的默认装饰器语法(即`@decorator`)以及设置参数和显式调用装饰器函数的情况(即`decorator(count=x)`)。

感谢阅读。