<html>
<head>
<title>An Application-First Approach to DevOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发运维的应用优先方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/application-first-approach-to-devops-75653a51b6ee?source=collection_archive---------8-----------------------#2022-06-21">https://betterprogramming.pub/application-first-approach-to-devops-75653a51b6ee?source=collection_archive---------8-----------------------#2022-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ebd2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">标准化Kubernetes基础设施，让开发人员更轻松，运营人员更自由</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0395126ce5978fa3e388a4f51948f698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ueWpgWX4OUuAncC_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bd0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是关于快速开发环境中一个惊人且关键的概念——开放应用程序模型(OAM)的少数实现之一。</p><p id="6a0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OAM是一个概念，它提倡开发人员完全专注于他们的应用程序，而不是底层基础设施的知识。它指出，这种方法应该是应用程序优先的、可扩展的和运行时不可知的。你可以在这里了解更多信息<a class="ae kv" href="https://oam.dev/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/5e6cad542989133ade7a5eaba049374d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHdGB8D2gZ2VD7omnsN-oQ.png"/></div></div></figure><p id="caf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到我们的话题，我这里说的OAM的实现是KubeVela。我在Crossplane上的上一篇文章中简单地提到了它，并认为这是深入研究它的恰当时机。</p><div class="lt lu gp gr lv lw"><a href="https://rajputvaibhav.medium.com/crossplane-and-beyond-36a7cd855ce0" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">交叉平面和超越…</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">让我们将基础设施的最新发展视为代码，不要止步于此，而是要进一步全面见证…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">rajputvaibhav.medium.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kp lw"/></div></div></a></div><h1 id="6dc8" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated"><strong class="ak">设置</strong></h1><p id="9281" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">要开始使用KubeVela，只需遵循<a class="ae kv" href="https://kubevela.io/docs/platform-engineers/advanced-install#install-kubevela-with-existing-kubernetes-cluster" rel="noopener ugc nofollow" target="_blank">安装步骤</a>。<br/>为了更轻松地管理资源，您可以选择安装vela CLI。对于Mac系统，您可以像这样简单地使用<code class="fe ni nj nk nl b">brew</code></p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="28ff" class="nq mm iq nl b gy nr ns l nt nu">brew update<br/>brew install kubevela</span></pre><p id="2824" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">准备好vela CLI后，只需运行以下命令，就可以在集群上安装核心组件(CRD)</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="1682" class="nq mm iq nl b gy nr ns l nt nu">vela install --version v1.4.2</span></pre><p id="772a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望跳过vela CLI，您也可以像这样使用helm直接安装它</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="7d02" class="nq mm iq nl b gy nr ns l nt nu">helm repo add kubevela <a class="ae kv" href="https://charts.kubevela.net/core" rel="noopener ugc nofollow" target="_blank">https://charts.kubevela.net/core</a><br/>helm repo update<br/>helm install --create-namespace -n vela-system kubevela kubevela/vela-core --version 1.4.2 --wait</span></pre><p id="416e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到如下所示的输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/337c76f40adf169f389caa89bd9b3bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kw-k1lthIYj-Na4Wp3VnTg.png"/></div></div></figure><h1 id="f7fe" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">让我们探索一下</h1><p id="2f96" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">作为安装的一部分，安装了一些CRD。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/9f9ccde01cf5364b1671b1f320a3f60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcMbq8YUZ4-I5A6RVhGN8Q.png"/></div></div></figure><p id="4ba6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有相当多的东西，但我们将只关注突出的部分。</p><h1 id="a95f" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">应用程序. core.oam.dev</h1><p id="05a6" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">应用程序是开发人员要创建的东西，只包含特定于应用程序及其配置的细节。这个文件中没有提到Kubernetes资源。让我们在下面为自己创建一个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="3838" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地像这样应用这个清单:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/072d5916401bc4e16366ad005ac8cde0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GDQ3Q9NuA47K-AwF-omFg.png"/></div></div></figure><p id="db8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您查看参考资料，您会看到有相当多的参考资料是基于这段代码创建的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/01f7846fb4f859352fde12eb2a71ebb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DKtD_-zjXUGPnvxhyCuvA.png"/></div></div></figure><p id="7a14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我怎么知道我想要创建的所有资源是什么呢？</p><p id="b9c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，回头看一下清单的第8行。我们提到了<code class="fe ni nj nk nl b">webservice</code>作为我们应用程序的类型。这就把我们带到了下一个CRD</p><h1 id="f864" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">组件定义. core.oam.dev</h1><p id="b40e" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">有几个预定义的<code class="fe ni nj nk nl b">componentdefinitions</code>你可以使用。您可以像这样列出它们:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/e11cbe417dae0b188a5f6af4f11a634e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdd2-zP5rVZNSXqShJ-5Qg.png"/></div></div></figure><p id="b9a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用的是一个长期运行的、可伸缩的、容器化的服务，它有一个稳定的网络端点来接收来自客户的外部流量。因此，它创建了一个具有稳定网络端点(服务和入口)的部署(长期运行且可扩展)。</p><p id="fdcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多其他的<code class="fe ni nj nk nl b">componentdefinitions</code>你可以使用，但是说你有一个需求没有被任何人解决。说你要对其中一个做一些补充？还是一起做一个新的？嗯，两种都有可能。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="dda0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建一个自定义的<code class="fe ni nj nk nl b">componentdefinition</code>，你不必从头开始。使用现有的Kubernetes清单并运行<code class="fe ni nj nk nl b">vela def init</code>(更多细节<a class="ae kv" href="https://kubevela.io/docs/platform-engineers/components/custom-component" rel="noopener ugc nofollow" target="_blank">在这里</a>)。</p><p id="8746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你查看这些组件定义YAMLs中的一个，你会看到它们有一个<code class="fe ni nj nk nl b">schematic</code>块，可以写在<a class="ae kv" href="https://cuelang.org/" rel="noopener ugc nofollow" target="_blank"> cue </a>、Kube或helm中。</p><p id="18e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我个人更喜欢cue，因为它的灵活性，但这是以学习整个语言为代价的。如果你不想那样做，就去找赫尔姆或者库贝。此外，如果您熟悉Kustomize，Kube对您来说可能很容易(它是带有参数化的标准Kubernetes清单)。</p><h1 id="ba58" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">traitdefinitions.core.oam.dev</h1><p id="8e6b" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">最后，我们可以选择扩展现有的<code class="fe ni nj nk nl b">componentdefinition</code>。例如，您可以使用它将<a class="ae kv" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平窗格自动缩放</a>添加到您上面创建的现有webservice应用程序中。</p><p id="f5aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe ni nj nk nl b">TraitDefinition</code>资源的定义也与<code class="fe ni nj nk nl b">componentdefinition</code>非常相似，在<code class="fe ni nj nk nl b">schematic</code>部分下面写有一个模板代码。这里的一个区别是<code class="fe ni nj nk nl b">appliesToWorkloads</code>，它将定义何时触发这个特性。在我们的例子中，它将与部署相关，因此看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6ad2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这些参数有一个默认值<code class="fe ni nj nk nl b">min : 1</code>、<code class="fe ni nj nk nl b">max : 10</code>和<code class="fe ni nj nk nl b">cpuUtil : 50</code>，这意味着用户可能会也可能不会在应用程序定义文件中传递它们。</p><h1 id="548c" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">清除</h1><p id="b862" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">再补充一点，考虑到所有的资源被高效地打包在一个应用程序中，清理也同样容易。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/7b609fa35da9463a05e3ab2c3978340b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bqum0BMU2TUtPJ7c2TcpyA.png"/></div></div></figure><p id="6b88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您使用</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="aa78" class="nq mm iq nl b gy nr ns l nt nu">kubectl get all,ingress</span></pre><p id="15dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些你都找不到。</p><h1 id="9074" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">离别赠言</h1><p id="5bea" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">至少在我看来，OAM是DevOps社区中我们需要的那种标准化。KubeVela是一个很好的例子，它将如何使我们受益。</p><blockquote class="of og oh"><p id="74ea" class="kw kx oi ky b kz la jr lb lc ld ju le oj lg lh li ok lk ll lm ol lo lp lq lr ij bi translated">我应该提到这个工具有一个缺点。文档最初不是用英语写的，但被翻译成了英语。所以，它没有你想象的那么好。</p></blockquote></div></div>    
</body>
</html>