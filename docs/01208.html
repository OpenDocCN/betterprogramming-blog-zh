<html>
<head>
<title>Tenor API GIFs With Swift’s UICollectionViewCells and Objective-C AVFoundation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Swift uicollectionview cells和Objective-C AVFoundation的Tenor API GIFs</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tenor-api-gifs-with-swifts-uicollectionviewcells-objective-c-avfoundation-736c6e14e423?source=collection_archive---------6-----------------------#2019-08-22">https://betterprogramming.pub/tenor-api-gifs-with-swifts-uicollectionviewcells-objective-c-avfoundation-736c6e14e423?source=collection_archive---------6-----------------------#2019-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6d88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用Tenor的API文档的简单性来创建GIF播放单元格</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0f74331104d2aed403229762dc799658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2P-m9Ig596QttbRIrzmD-g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">雅各布·欧文在<a class="ae ky" href="https://unsplash.com/search/photos/image?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="86e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://tenor.com/" rel="noopener ugc nofollow" target="_blank">流行的GIF搜索引擎Tenor </a>是一个很好的API端点，可以用来演示如何使用Objective-C中的原生功能<code class="fe lv lw lx ly b">AVFoundation</code>实现Swift的水平和垂直滚动视图类！</p><p id="2fa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">凭借其丰富的文档、快速入门指南、最佳实践和详细的<code class="fe lv lw lx ly b">curl</code>命令，Tenor为iOS应用程序开发提供了充足的机会。</p><p id="ec42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些为了SDK的易用性而忘记了API集成的复杂性的人来说，这也是非常棒的！</p><div class="lz ma gp gr mb mc"><a href="https://tenor.com/gifapi/documentation#endpoints-registershare" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">GIF API —更好、更快、免费|期限文档</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">Tenor Search以30多种语言提供最相关的gif。将Tenor的GIF API集成到您的应用程序中</h3></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ks mc"/></div></div></a></div></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="19ae" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">你将完成什么</h1><p id="975e" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在这篇博客中，你将利用Tenor的API文档的简单性，用Swift的<code class="fe lv lw lx ly b">UICollectionViewCells</code>类创建GIF播放单元格。</p><p id="9ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是，您将展示以下内容:</p><ul class=""><li id="f6d4" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">Swift和Objective-C的知识，其中视图类在Swift中，视频播放器类在Objective-C中。</li><li id="7860" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">原生iOS UIKit(故事板、自动布局和大小类)。</li><li id="b322" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">合适的第三方网络或图像缓存框架，如<code class="fe lv lw lx ly b">Alamofire</code> / <code class="fe lv lw lx ly b">SDWebImage</code>。</li></ul><p id="4fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过展示这些内容，您将实现以下目标:</p><ul class=""><li id="f0e6" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">获取端点数据，将其显示在集合视图中。</li><li id="6eac" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">用户键入时更新收藏视图的搜索栏。</li><li id="6910" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">点击收藏视图单元格会导致应用程序开始播放视频。</li><li id="ec81" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">在iPhone和iPad上以所有四个方向正确显示。</li><li id="8711" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">单元测试。</li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="df35" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">设置</h1><p id="2c41" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在Xcode中打开一个单视图应用程序模板。通过命令行界面终端导航到根目录。</p><p id="4840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根目录下，写<code class="fe lv lw lx ly b">pod init</code>。在初始化一个pod之后，将<code class="fe lv lw lx ly b">Alamofire</code>和<code class="fe lv lw lx ly b">SDWebImage</code>添加到您的podfile中，并运行<code class="fe lv lw lx ly b">pod install</code>。</p><p id="4d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！你都准备好了。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="9a9b" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><strong class="ak">获取端点数据</strong></h1><p id="2b8c" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">下一步是获取端点数据。当你根据模型视图，视图模型结构构建你的应用时，你将构建四个<code class="fe lv lw lx ly b">structs</code>，每个都符合苹果全新的<code class="fe lv lw lx ly b">codable</code>协议。</p><p id="85ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个结构是GIF结构。</p><h2 id="4316" class="oi my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated">GIF <code class="fe lv lw lx ly b">struct</code></h2><p id="f352" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在你的GIF <code class="fe lv lw lx ly b">struct</code>中，声明以下常量:<code class="fe lv lw lx ly b">tags: [String]?</code>、<code class="fe lv lw lx ly b">url: URL?</code>、<code class="fe lv lw lx ly b">media: [MediaCollection]?</code>、<code class="fe lv lw lx ly b">created: Double?</code>、<code class="fe lv lw lx ly b">shares: Int?</code>、<code class="fe lv lw lx ly b">itemURL: URL?</code>、<code class="fe lv lw lx ly b">hasAudio: Bool?</code>、<code class="fe lv lw lx ly b">title: String?</code>、<code class="fe lv lw lx ly b">id: String?</code>和编码键。</p><p id="1f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的编码键，您将使用一个<code class="fe lv lw lx ly b">enum</code>和案例:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="a124" class="oi my it ly b gy oy oz l pa pb">enum CodingKeys: String, CodingKey {<br/>    case tags, url, media, created, shares<br/>    case itemURL = "itemURL"<br/>    case hasAudio = "has audio"<br/>    case title, id<br/>}</span></pre><h2 id="5838" class="oi my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated"><strong class="ak">media collection</strong>T14】</h2><p id="d0f4" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">你的下一个<code class="fe lv lw lx ly b">struct</code>叫<code class="fe lv lw lx ly b">MediaCollection</code>。它比其他结构简单得多，因为它只是将各种类型的媒体解码成一种快速类型。</p><p id="8c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你的<code class="fe lv lw lx ly b">MediaCollection</code> <code class="fe lv lw lx ly b">struct</code>中，声明以下常量:<code class="fe lv lw lx ly b">nanoMP4</code><code class="fe lv lw lx ly b">nanoWebM</code><code class="fe lv lw lx ly b">tinyGIF</code><code class="fe lv lw lx ly b">tinyMP4</code><code class="fe lv lw lx ly b">tinyWebM</code><code class="fe lv lw lx ly b">webM</code><code class="fe lv lw lx ly b">gif</code><code class="fe lv lw lx ly b">mp4</code><code class="fe lv lw lx ly b">loopedMP4</code><code class="fe lv lw lx ly b">mediumGIF</code><code class="fe lv lw lx ly b">nanoGIF</code>，作为类型可选<code class="fe lv lw lx ly b">Media</code>。</p><p id="8596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的编码键，您将使用带有cases的<code class="fe lv lw lx ly b">enum</code>，为除<code class="fe lv lw lx ly b">gif</code>或<code class="fe lv lw lx ly b">mp4</code>之外的所有键提供设置字符串值，这是显而易见的。</p><h2 id="2463" class="oi my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated"><strong class="ak">媒体</strong>媒体<code class="fe lv lw lx ly b"><strong class="ak">struct</strong></code></h2><p id="d60c" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">你的下一个结构叫做<code class="fe lv lw lx ly b">Media</code>。</p><p id="c93d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的<code class="fe lv lw lx ly b">Media</code>结构中，声明以下常量:<code class="fe lv lw lx ly b">url: URL?</code>、<code class="fe lv lw lx ly b">dimension: [Int]?</code>、<code class="fe lv lw lx ly b">duration: Double?</code>、<code class="fe lv lw lx ly b">preview: URL?</code>、<code class="fe lv lw lx ly b">size: Int64?</code>。</p><p id="517c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于您的编码键，枚举所有没有值的事例，除了<code class="fe lv lw lx ly b">dimension</code>，它的值将被设置为<code class="fe lv lw lx ly b">dims</code>。</p><h2 id="6430" class="oi my it bd mz oj ok dn nd ol om dp nh li on oo nj lm op oq nl lq or os nn ot bi translated"><strong class="ak">回应</strong> <code class="fe lv lw lx ly b"><strong class="ak">struct</strong></code></h2><p id="416b" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">最后但同样重要的是你的<code class="fe lv lw lx ly b">Response</code>结构。您将一般地声明这个结构，这样当且仅当<code class="fe lv lw lx ly b">Response</code>符合可解码协议时，它才是可解码的。</p><p id="02dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为<code class="fe lv lw lx ly b">webURL:URL?</code>、<code class="fe lv lw lx ly b">results: T?</code>和<code class="fe lv lw lx ly b">next: String?</code>声明常量。</p><p id="1716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于您的编码键，枚举所有常量的情况，除了<code class="fe lv lw lx ly b">webURL</code>，其值将设置为<code class="fe lv lw lx ly b">weburl</code>。</p><p id="78cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！您已经创建了自己的结构。这是获取端点数据的第一步。下一步是建立对API端点的调用。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="5fb9" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">端点</h1><p id="fa85" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">为将管理<code class="fe lv lw lx ly b">convertItems</code>、<code class="fe lv lw lx ly b">getURL</code>、<code class="fe lv lw lx ly b">getAuthenticationParameters</code>、<code class="fe lv lw lx ly b">getLimitingParameters</code>和<code class="fe lv lw lx ly b">getAnonymousIdParameters</code>方法的<code class="fe lv lw lx ly b">URLManager</code>创建一个<code class="fe lv lw lx ly b">struct</code>。</p><p id="5c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为私有常量的程序<code class="fe lv lw lx ly b">convertItems</code>:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="3416" class="oi my it ly b gy oy oz l pa pb">static private let convertItems: ((Parameters) -&gt; [URLQueryItem]) = { <br/>parameters in return parameters.map { <br/>      return URLQueryItem(name: $0, value: $1) <br/>     }    <br/>}</span></pre><p id="7675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为公共方法的TK程序<code class="fe lv lw lx ly b">getURL</code>:</p><p id="39fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为私有方法的程序<code class="fe lv lw lx ly b">getAuthenticationParameters</code>:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="6ab0" class="oi my it ly b gy oy oz l pa pb">static private func getAuthenticationParameters() -&gt; Parameters {            <br/>    return ["key"   : Configuration.key]    <br/>}</span></pre><p id="c252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为私有方法的程序<code class="fe lv lw lx ly b">getAnonymousIdParameters</code>:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="6df6" class="oi my it ly b gy oy oz l pa pb">static private func getAnonymousIdParameters() -&gt; Parameters? {        <br/>    guard let anonymoudId = UserDefaults.standard.string(forKey: kAnonymousIdKey) <br/>    else { return nil }        <br/>    return ["anon_id"   : anonymoudId]<br/>}</span></pre><p id="8121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序<code class="fe lv lw lx ly b">getLimitingParameters</code>作为私有方法:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="47cf" class="oi my it ly b gy oy oz l pa pb">static private func getLimitingParameters() -&gt; Parameters {          <br/>    return ["limit" : "\(Configuration.pageLimit)"]    <br/>}</span></pre><p id="48d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，但同样重要的是，在这个列表中用几个例子来编程一个<code class="fe lv lw lx ly b">enum</code>:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="2c02" class="oi my it ly b gy oy oz l pa pb">import Foundation <br/>enum EndPoint: String {        <br/>case anonymousId    =   "/v1/anonid"        <br/>case search         =   "/v1/search"<br/>}</span></pre><p id="5ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要再添加两个文件，一个叫<code class="fe lv lw lx ly b">Alias.swift</code>，一个叫<code class="fe lv lw lx ly b">Constants.swift</code>。首先，将a <code class="fe lv lw lx ly b">typealias</code>编程为:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="5603" class="oi my it ly b gy oy oz l pa pb">typealias Parameters = [String:String]</span></pre><p id="7e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，将常量<code class="fe lv lw lx ly b">kAnonymousIdKey</code>编程为<code class="fe lv lw lx ly b">AnonymousId</code>。将最后两个文件组合到一个名为Helper的文件夹中。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="fd09" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">搜索栏</h1><p id="8ef1" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们实现搜索栏的架构是双重的:首先，一个名为<code class="fe lv lw lx ly b">SearchVC.swift</code>的视图控制器，其次，一个名为<code class="fe lv lw lx ly b">SearchVC+CollectionView.swift</code>的类别扩展。</p><p id="f6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加一个名为<code class="fe lv lw lx ly b">SearchVC.swift</code>的文件。在文件内，导入:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="1c25" class="oi my it ly b gy oy oz l pa pb">import UIKit<br/>import Alamofire<br/>import AlamofireImage</span></pre><p id="8117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建网点:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="2188" class="oi my it ly b gy oy oz l pa pb">@IBOutlet weak var searchBar: UISearchBar!        <br/>@IBOutlet weak var resultCollectionView: UICollectionView!</span></pre><p id="0e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为数据创建属性:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="8607" class="oi my it ly b gy oy oz l pa pb">// MARK: - Data        <br/>internal lazy var resultsArray: [GIF] = []        <br/>internal let cellIdentifier = "PreviewCell"        <br/>internal let cellHeight: CGFloat = 250        <br/>private let anonIdViewModel = AnonIdViewModel()        <br/>private let searchViewModel = SearchViewModel()</span></pre><p id="d1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">viewDidLoad()</code>中调用<code class="fe lv lw lx ly b">fetchAnonymousId()</code>。</p><p id="5284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个获取匿名id的函数:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="b489" class="oi my it ly b gy oy oz l pa pb">private func fetchAnonymousId() {                </span><span id="e395" class="oi my it ly b gy pc oz l pa pb">    ActivityIndicator.startAnimating()                  <br/>    anonIdViewModel.getAnonymousId { <br/>[weak self] success in                        <br/>    ActivityIndicator.stopAnimating()                        <br/>         if success {                <br/>             self?.fetchResult()            <br/>             } else {<br/>                self?.showRetryAlert()<br/>            }<br/>        }<br/>    }</span></pre><p id="7cf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的调用成功，您将在一个名为<code class="fe lv lw lx ly b">fetchResult()</code>的函数中获取结果。</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="90b9" class="oi my it ly b gy oy oz l pa pb">private func fetchResult(for keyword: String = "") {                </span><span id="58c7" class="oi my it ly b gy pc oz l pa pb">ActivityIndicator.startAnimating()                </span><span id="c82f" class="oi my it ly b gy pc oz l pa pb">searchViewModel.search(using: keyword) </span><span id="13ce" class="oi my it ly b gy pc oz l pa pb">{ [weak self] (data, error) in                        </span><span id="30c5" class="oi my it ly b gy pc oz l pa pb">DispatchQueue.main.async {                <br/>    if let error = error {<br/>                    // if canceled, do not show alert<br/>                    guard (error as NSError).code != -999 else { return }<br/>                    self?.showErrorAlert(with: error.localizedDescription)<br/>                }<br/>                else if let data = data {                      self?.resultsArray = data                    self?.resultCollectionView.reloadData()<br/>                }                                ActivityIndicator.stopAnimating()<br/>            }<br/>        }<br/>    }</span></pre><p id="b912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程调用错误警报:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="1fce" class="oi my it ly b gy oy oz l pa pb">private func showErrorAlert(with message: String) {                </span><span id="6723" class="oi my it ly b gy pc oz l pa pb">let alertController = UIAlertController(title: "Error",                                                message: message,                                            preferredStyle: .alert)<br/>                let okayAction = UIAlertAction(title: "Okay", style: .default)<br/>        alertController.addAction(okayAction)                present(alertController, animated: true, completion: nil)<br/>    }}</span></pre><p id="6120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果调用失败，编程一个名为<code class="fe lv lw lx ly b">showRetryAlert()</code>的函数:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="a29e" class="oi my it ly b gy oy oz l pa pb">private func showRetryAlert() {<br/>                let alertController = UIAlertController(title: "Error",                                                message: "Unable to fetch anonymous id.",<br/>                                                preferredStyle: .alert)<br/>                let retryAction = UIAlertAction(title: "Retry", style: .default) { [weak self] _ in            </span><span id="0906" class="oi my it ly b gy pc oz l pa pb">self?.fetchAnonymousId()        }        </span><span id="a179" class="oi my it ly b gy pc oz l pa pb">alertController.addAction(retryAction)<br/>                let withoutAction = UIAlertAction(title: "Search without anonymous id.", style: .default) { [weak self] _ in            </span><span id="f134" class="oi my it ly b gy pc oz l pa pb">self?.fetchResult()        }        </span><span id="f92c" class="oi my it ly b gy pc oz l pa pb">alertController.addAction(withoutAction)                </span><span id="cd56" class="oi my it ly b gy pc oz l pa pb">present(alertController, animated: true, completion: nil)<br/>    }</span></pre><p id="af70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对方向变化进行编程:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="0f01" class="oi my it ly b gy oy oz l pa pb">@objc <br/>func orientationDidChange() { resultCollectionView.collectionViewLayout.invalidateLayout()<br/>}</span></pre><p id="d812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您需要编程来更新特征集合:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="6e9b" class="oi my it ly b gy oy oz l pa pb">override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {        resultCollectionView.collectionViewLayout.invalidateLayout()    <br/>}</span></pre></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="5585" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">定向观察员</h1><p id="06c2" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">如果用户改变方向，应用程序需要相应地更新集合视图的UI。为此，应用程序必须通过观察器接收通知。</p><p id="76d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察者观察状态的变化。如果方向状态发生变化，观察者会收到一个可以触发代码变化的通知。这两个文件都需要添加和删除关于方向变化的通知的观察者:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="34e7" class="oi my it ly b gy oy oz l pa pb">override func viewDidAppear(_ animated: Bool) {           <br/>    super.viewDidAppear(animated)                  <br/>    NotificationCenter.default.addObserver(self, selector: #selector(SearchVC.orientationDidChange), name: Notification.Name.UIDeviceOrientationDidChange, object: nil)    <br/>}        </span><span id="6dc1" class="oi my it ly b gy pc oz l pa pb">override func viewDidDisappear(_ animated: Bool) {          <br/>    super.viewDidDisappear(animated)                <br/>    NotificationCenter.default.removeObserver(self)    <br/>}</span></pre></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="5c64" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">对UISearchBarDelegate进行编程</h1><p id="21b6" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">前面，您添加了一个<code class="fe lv lw lx ly b">UISearchBar</code>实例作为出口。</p><p id="55e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe lv lw lx ly b">UISearchBar</code>的实例必须将它们的功能委托给声明它们的控制器。</p><p id="48ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何扩展搜索视图控制器的功能以处理搜索栏功能:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="75cb" class="oi my it ly b gy oy oz l pa pb">extension SearchVC: UISearchBarDelegate {        </span><span id="df6a" class="oi my it ly b gy pc oz l pa pb">func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {      <br/>          <br/>fetchResult(for: searchText) <br/>   <br/>   }<br/></span></pre><p id="b8fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码被添加到你的搜索栏控制器的底部。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="4128" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">对SearchVC+CollectionView.swift进行编程</h1><p id="c1ef" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated"><code class="fe lv lw lx ly b">SearchVC+CollectionView.swift</code>是<code class="fe lv lw lx ly b">SearchVC</code>的扩展，但是在一个单独的文件中，以保持视图控制器的集合视图代码组织良好(即分离关注点)。</p><p id="75dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一部分是采用<code class="fe lv lw lx ly b">UICollectionViewDataSource</code>的协议，为每个部分中的项目数和这些部分中每个项目的单元格实现其所需的方法:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="7bc9" class="oi my it ly b gy oy oz l pa pb">extension SearchVC: UICollectionViewDataSource {</span><span id="ba5b" class="oi my it ly b gy pc oz l pa pb">     func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {</span><span id="5141" class="oi my it ly b gy pc oz l pa pb">          return resultsArray.count</span><span id="5e9e" class="oi my it ly b gy pc oz l pa pb">    }</span><span id="189b" class="oi my it ly b gy pc oz l pa pb">    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {</span><span id="d333" class="oi my it ly b gy pc oz l pa pb">        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath) as? PreviewCell</span><span id="7465" class="oi my it ly b gy pc oz l pa pb">        if let url = resultsArray[indexPath.row].media?.first?.mp4?.preview {</span><span id="3a2e" class="oi my it ly b gy pc oz l pa pb">             cell?.thumbImageView.af_setImage(withURL: url,<br/>placeholderImage:  imageLiteral(resourceName: "placeholder"),imageTransition: .crossDissolve(0.1))</span><span id="50b2" class="oi my it ly b gy pc oz l pa pb">        }</span><span id="1424" class="oi my it ly b gy pc oz l pa pb">        return cell ?? UICollectionViewCell()</span><span id="cb68" class="oi my it ly b gy pc oz l pa pb">     }</span><span id="8126" class="oi my it ly b gy pc oz l pa pb">}</span></pre><p id="4afa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是实现集合视图委托:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="ca89" class="oi my it ly b gy oy oz l pa pb">extension SearchVC: UICollectionViewDelegate {     <br/>   func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {   <br/>             guard let url = resultsArray[indexPath.row].media?.first?.mp4?.url else { return }                let _ = VideoPlayer.playVideo(with: url)    <br/>             }<br/>}</span></pre><p id="1e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是为集合视图的委托实现流布局。</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="e2e4" class="oi my it ly b gy oy oz l pa pb">extension SearchVC: UICollectionViewDelegateFlowLayout {<br/>        func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize {          <br/>      switch UIDevice.current.userInterfaceIdiom {    <br/>      case .carPlay, .tv, .unspecified: fallthrough        <br/>      case .phone:            <br/>          return CGSize(width: collectionView.frame.width, height: cellHeight)        <br/>      case .pad: <br/>        return CGSize(width: collectionView.frame.width/2, height: cellHeight)        <br/>      }     <br/>    }<br/>}</span></pre></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="1fc1" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">播放视频</h1><p id="2958" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">你将根据语言来实现视频播放器。</p><p id="27f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AVFoundation</code>是苹果用于视频播放的原生SDK，但它是用Objective-C编写的，不是用Swift编写的。</p><p id="5eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们可以在Swift中实现它，但是在Objective-C中实现它并没有什么优势，因为它比Swift更接近于<code class="fe lv lw lx ly b">AVFoundation</code>的核心。</p><p id="fc40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建两个Objective-C文件，一个<code class="fe lv lw lx ly b">VideoPlayer.h</code>，另一个<code class="fe lv lw lx ly b">VideoPlayer.m</code>。</p><p id="0a2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在头文件中，添加以下内容:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="1303" class="oi my it ly b gy oy oz l pa pb">////  VideoPlayer.h<br/>//  Tenorize<br/>////  Created by Eric Giannini on 8/29/18.<br/>//  Copyright © 2018 Eric Giannini. All rights reserved.<br/>// <br/>#import &lt;AVKit/AVKit.h&gt;<br/>#import &lt;Foundation/Foundation.h&gt; <br/>@interface VideoPlayer : NSObject<br/> +(nonnull AVPlayerViewController *)playVideoWithURL:(NSURL *_Nonnull)url; <br/>@end</span></pre><p id="37d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您在头文件中声明该方法，但实际上是在实现文件中编写该方法。</p><p id="651c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是:</p><pre class="kj kk kl km gt ou ly ov ow aw ox bi"><span id="49c7" class="oi my it ly b gy oy oz l pa pb">#import "VideoPlayer.h"<br/>#import &lt;Foundation/Foundation.h&gt; <br/>@implementation VideoPlayer</span><span id="cd78" class="oi my it ly b gy pc oz l pa pb">+(AVPlayerViewController *)playVideoWithURL:(NSURL *)url {<br/>   AVPlayer *player = [[AVPlayer alloc] initWithURL:url];<br/>   AVPlayerViewController *playerVC = [[AVPlayerViewController alloc] init];    <br/>   [playerVC setPlayer:player];<br/>   UIWindow *window = [[[UIApplication sharedApplication] delegate] window];<br/>   [[window rootViewController] presentViewController:playerVC animated:YES completion:^{        <br/>   [player play];    <br/>}];<br/>    return playerVC;<br/>}</span><span id="76ca" class="oi my it ly b gy pc oz l pa pb">@end</span></pre><p id="dcef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的方法是用一个URL调用的(也就是Tenor API的GIF URL)。</p><p id="6f08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AVPlayer</code>的实例既是初始化的又是分配的资源。初始化<code class="fe lv lw lx ly b">AVPlayerViewController</code>的实例并分配资源。</p><p id="8d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，<code class="fe lv lw lx ly b">AVPlayer</code>的实例被设置为<code class="fe lv lw lx ly b">AVPlayerViewController</code>实例的播放器。视图控制器被设置为播放器。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="e5a8" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">摘要</h1><p id="a0bc" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">用<code class="fe lv lw lx ly b">Alamofire</code>从API端点获取数据，用<code class="fe lv lw lx ly b">SDWebImage</code>将数据显示在集合视图中。</p><p id="1af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以创建一个搜索栏，当用户键入新的单元格时，它会更新集合视图。您可以点击收藏视图单元格，以便播放gif。</p><p id="94b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您创建应用程序，以便它在iPhone和iPad上以所有四个方向正确呈现，本机使用iOS UIKit(即故事板、自动布局和大小类)。您创建单元测试。</p><ul class=""><li id="0a14" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">用户键入时更新收藏视图的搜索栏。</li><li id="f9df" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">点击收藏视图单元格会导致应用程序开始播放视频。</li><li id="7dfe" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">在iPhone和iPad上四个方向都能正确显示。</li><li id="24c7" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">单元测试测试功能</li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="7cea" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">代码库</h1><p id="dbd6" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">如果你想查看全功能应用程序的<a class="ae ky" href="https://github.com/ericgiannini/tenorize" rel="noopener ugc nofollow" target="_blank">源代码，请随意下载。</a></p></div></div>    
</body>
</html>