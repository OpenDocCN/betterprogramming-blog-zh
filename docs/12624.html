<html>
<head>
<title>Automate Changelog Generation with GitLab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitLab自动生成变更日志</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automate-changelog-generation-with-gitlab-dbd4e4c41d99?source=collection_archive---------3-----------------------#2022-06-17">https://betterprogramming.pub/automate-changelog-generation-with-gitlab-dbd4e4c41d99?source=collection_archive---------3-----------------------#2022-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0206" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让GitLab API去做那些无聊的事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c6e5cf1f3028f84226ece4c9a6df761f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNIgHke3eg_M1oCPUXp3kA.png"/></div></div></figure><p id="c03f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我是GitLab的超级粉丝，如果你跳到这篇文章，我相信你也是。不久前，我浏览了他们的<a class="ae lq" href="https://docs.gitlab.com/ee/api/api_resources.html" rel="noopener ugc nofollow" target="_blank"> API </a>来了解它提供的功能。到目前为止，我发现了一些节省了我很多时间的东西:</p><div class="lr ls gp gr lt lu"><a href="https://docs.gitlab.com/ee/api/repositories.html#add-changelog-data-to-a-changelog-file" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">仓库API | GitLab</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">将变更日志数据添加到变更日志文件中</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">docs.gitlab.com</p></div></div></div></a></div><p id="bcb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，您将发现如何使用GitLab API，通过一点点规则和一些魔力，自动更新您的发布说明。</p><h1 id="36ac" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">先决条件</h1><p id="9d14" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">先说一些基础知识，什么是发行说明？</p><p id="68aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个<em class="na">发布说明</em>(又名changelog)是一个文件，它列出了一个项目的新版本中引入的变更。这个文件习惯上被命名为<code class="fe nb nc nd ne b">CHANGELOG.md</code>。</p><p id="2985" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">变更日志条目根据它们的类型进行分组，无论是相关的<code class="fe nb nc nd ne b">fix</code>、<code class="fe nb nc nd ne b">feature change</code>、<code class="fe nb nc nd ne b">deprecation</code>、<code class="fe nb nc nd ne b">performance</code>、<code class="fe nb nc nd ne b">new feature</code>还是更多…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">CHANGELOG.md的一个例子</p></figure><p id="95f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更多真实的例子，你可以看看:</p><ul class=""><li id="6f24" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated"><a class="ae lq" href="https://github.com/angular/angular/blob/main/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank">角度变化记录</a></li><li id="ff4c" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><a class="ae lq" href="https://github.com/facebook/react/blob/main/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank"> React CHANGELOG </a>或</li><li id="7c3e" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><a class="ae lq" href="https://docs.python.org/3/whatsnew/changelog.html#python-next" rel="noopener ugc nofollow" target="_blank"> Python文档</a>。</li></ul><h1 id="aede" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">为什么更新更新日志是一件痛苦的事…但却是必要的？</h1><p id="0cff" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">列出两个版本之间的所有变化是一项令人厌烦的任务。你需要将(几乎)每一次提交都与一个具体的目的相匹配，就像上面提到的那样。</p><p id="ac68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着提交消息足够清晰，可以对它们进行分类。但是说实话，在每次提交时尽可能明确并不容易。</p><blockquote class="nz"><p id="9137" class="oa ob it bd oc od oe of og oh oi lp dk translated">但是，真的有必要跟踪这些变化吗？</p></blockquote><p id="4607" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">嗯，如果你正在使用或维护一个被社区使用的包，这是一个<strong class="kw iu">必须</strong>做的事情！您的发行说明将(部分)记录软件包每个版本的修改。这是引入新功能的一种方式，但也是对重大变化保持警惕的一种方式。因此，您的“客户”将被警告并调整他们的代码库。</p><p id="f479" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">变更日志也是记录项目历史的一种方式(不管它是什么类型)。最后，如果你与产品团队紧密合作，它是每个新版本内容的参考。</p><p id="66e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，如果手动的话，这是一个很无聊的任务。希望存在使用第三方库的解决方案，比如针对节点用户的<a class="ae lq" href="https://www.npmjs.com/package/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>，针对Python的<a class="ae lq" href="https://pypi.org/project/gitchangelog/" rel="noopener ugc nofollow" target="_blank"> gitchangelog </a>或针对的<a class="ae lq" href="https://marketplace.visualstudio.com/items?itemName=KnisterPeter.vscode-commitizen" rel="noopener ugc nofollow" target="_blank"> Commitizen </a>。NET开发人员。然而，这意味着配置和维护插件。</p><p id="9334" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你使用GitLab作为代码版本控制平台，那么你非常幸运，因为Tanuki可以为你更新发布说明！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/da7e30b47c84da7b62b12def6181c8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:50/format:webp/1*JG0AESOS5Tf3kqx1DN8Lsw.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来自<a class="ae lq" href="https://docs.gitlab.com/assets/images/gitlab-logo.svg" rel="noopener ugc nofollow" target="_blank"> GitLab </a>的Tanuki</p></figure><blockquote class="op oq or"><p id="5a74" class="ku kv na kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">警告:这个解决方案只有在你使用<a class="ae lq" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a>时才有效(例如:v X.Y.Z)。</p></blockquote><h1 id="9e32" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">GitLab API来拯救！</h1><p id="2b06" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">我确信你知道GitLab不仅仅是一个代码版本平台。您可以管理团队的积压工作，定义项目的持续集成，跟踪应用程序的性能，并监控组织的基础设施，…</p><p id="e8d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以使用GitLab API完成所有这些工作以及更多工作。</p><div class="lr ls gp gr lt lu"><a href="https://docs.gitlab.com/ee/api/" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">API文档| GitLab</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">使用GitLab APIs自动化GitLab。GitLab中提供了一个REST API。使用说明如下。例如…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">docs.gitlab.com</p></div></div></div></a></div><blockquote class="op oq or"><p id="8825" class="ku kv na kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">在安全问题上，许多这些操作需要一个认证令牌，我让您弄清楚如何用<a class="ae lq" href="https://docs.gitlab.com/ee/api/#authentication" rel="noopener ugc nofollow" target="_blank">文档</a>获得这样的令牌。</p></blockquote><h2 id="03da" class="ov me it bd mf ow ox dn mj oy oz dp mn ld pa pb mp lh pc pd mr ll pe pf mt pg bi translated">资源解释</h2><p id="cfc5" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">在API提供的所有可能性中，我们关注的资源是存储库API:</p><div class="lr ls gp gr lt lu"><a href="https://docs.gitlab.com/ee/api/repositories.html" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">仓库API | GitLab</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">获取项目中存储库文件和目录的列表。在以下情况下，无需身份验证即可访问此端点…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">docs.gitlab.com</p></div></div></div></a></div><p id="c85d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将与<a class="ae lq" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> changelog端点</a>交互，该端点负责生成两个版本之间的changelog条目，并将它们插入到<em class="na"> CHANGELOG.md </em>文件中。</p><blockquote class="op oq or"><p id="3f5a" class="ku kv na kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">如果您的存储库中不存在这个文件，GitLab会自动添加！</p></blockquote><h2 id="ec71" class="ov me it bd mf ow ox dn mj oy oz dp mn ld pa pb mp lh pc pd mr ll pe pf mt pg bi translated">首先，为了你的git历史，一个好习惯</h2><p id="ad6f" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">这个gitLab端点利用了一个不太为人所知的Git特性:<a class="ae lq" href="https://git-scm.com/docs/git-interpret-trailers" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Git拖车</strong> </a> <strong class="kw iu">。</strong>它们看起来像一个标记，标记你的提交，你需要在提交条目的末尾提供它们，如下所示:</p><pre class="kj kk kl km gt ph ne pi pj aw pk bi"><span id="0b40" class="ov me it ne b gy pl pm l pn po">&lt;commit message subject&gt;</span><span id="4061" class="ov me it ne b gy pp pm l pn po">&lt;Commit message description - optional&gt;</span><span id="9582" class="ov me it ne b gy pp pm l pn po">Changelog: &lt;value&gt;</span></pre><p id="8c6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，<code class="fe nb nc nd ne b">value</code>将代表您想要应用于该提交的类别，您可以给它取您想要的名称。<code class="fe nb nc nd ne b">Changelog</code>预告片接受以下值:<code class="fe nb nc nd ne b">added</code>、<code class="fe nb nc nd ne b">fixed</code>、<code class="fe nb nc nd ne b">changed</code>、<code class="fe nb nc nd ne b">deprecated</code>、<code class="fe nb nc nd ne b">removed</code>、<code class="fe nb nc nd ne b">security</code>、<code class="fe nb nc nd ne b">performance</code>、<code class="fe nb nc nd ne b">other</code>(关于变更日志条目<a class="ae lq" href="https://docs.gitlab.com/ee/development/changelog.html" rel="noopener ugc nofollow" target="_blank">的更多细节，请点击</a>)。</p><p id="2230" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，更现实的例子是:</p><pre class="kj kk kl km gt ph ne pi pj aw pk bi"><span id="c3bf" class="ov me it ne b gy pl pm l pn po">Service Layer: Refactor the BillingService</span><span id="0294" class="ov me it ne b gy pp pm l pn po">Remove useless files and make some other stuff</span><span id="3187" class="ov me it ne b gy pp pm l pn po"><strong class="ne iu">Changelog: changed</strong></span></pre><p id="6a18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最重要的是这个<code class="fe nb nc nd ne b">Changelog: changed</code>的用法。因此，一个新条目将出现在<code class="fe nb nc nd ne b">CHANGELOG.md</code>文件的更改列表中。</p><p id="69ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里找到更多关于git trailer使用GitLab API的细节:</p><div class="lr ls gp gr lt lu"><a href="https://docs.gitlab.com/ee/api/repositories.html#how-it-works" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">存储库API &gt;将变更日志数据添加到变更日志文件#工作原理| GitLab</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">变更日志条目基于提交标题。只有当提交包含特定的Git尾部时，才会包含提交。GitLab使用该预告片的值来对变化进行分类。gitLab使用Git拖车，因为Git拖车是由Git开箱即用支持的。</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">docs.gitlab.com</p></div></div></div></a></div><h1 id="bd5a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我的个人建议</h1><p id="3e0e" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">希望我们不会被迫在每次提交时都使用git trailer那会很乏味。</p><p id="4cff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想到了一个解决方案，只在合并请求提交消息中包含git尾部。合并后是否挤压提交；对于git预告片，它将只保留一次提交，因此，在发行说明中只有一个条目！</p><h2 id="d42a" class="ov me it bd mf ow ox dn mj oy oz dp mn ld pa pb mp lh pc pd mr ll pe pf mt pg bi translated">然后，一个自动化的小脚本</h2><p id="92ee" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">在深入研究代码之前，您需要在GitLab API上查询一些基本的细节。</p><p id="4be3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，一个<strong class="kw iu">项目访问令牌</strong>在调用GitLab API时被认证。你可以在这里找到创建一个<a class="ae lq" href="https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html" rel="noopener ugc nofollow" target="_blank">的所有细节</a>。这个令牌应该授予<code class="fe nb nc nd ne b">read_api</code>和<code class="fe nb nc nd ne b">read_repository</code>作用域。</p><p id="1ccd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其次，你项目的<code class="fe nb nc nd ne b"><strong class="kw iu">Project ID</strong></code>，你可以在你项目的<em class="na">通用设置</em>页面找到。</p><p id="7c87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，您可以在下面找到一个简单的nodeJS脚本，它检索应用程序版本并调用GitLab API:</p><blockquote class="op oq or"><p id="6c9f" class="ku kv na kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">在执行之前，您需要安装带有<code class="fe nb nc nd ne b"><em class="it">npm i --save-dev axios dotenv</em></code>或<code class="fe nb nc nd ne b"><em class="it">yarn add -D axios dotenv</em></code>的<a class="ae lq" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>和<a class="ae lq" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5386" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，这里有一个Bash版本，其中应用程序版本号存储在一个<code class="fe nb nc nd ne b">VERSION.md</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="a613" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">释放野兽！</h1><h2 id="d4aa" class="ov me it bd mf ow ox dn mj oy oz dp mn ld pa pb mp lh pc pd mr ll pe pf mt pg bi translated">最后，您选择脚本应该何时运行</h2><p id="90b9" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">这个脚本可以在任何时候运行，但是当然，最相关的时刻是在标记创建之后。有两种可能的选择:</p><ol class=""><li id="ad5a" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp pq nr ns nt bi translated">就在标记版本化之后</li><li id="e5b6" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp pq nr ns nt bi translated">在标记配置项管道的末端</li></ol><p id="ecc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的项目中，我添加了一个依赖于<code class="fe nb nc nd ne b">postversion</code>钩子的NPM命令，它将根据<em class="na"> package.json </em>中更新的版本号触发脚本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="9abb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个选择似乎更简洁。事实上，它确保您在远程存储库上创建的标记已经运行了完整的CI管道，并且正在被编译、测试和“打包”。在所有这些连续的检查之后，就可以发布发行说明了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl pr ps hx pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="im in io ip iq"><p id="28fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这里，你学到的是:</p><ol class=""><li id="86fa" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp pq nr ns nt bi translated">Git尾标是标记提交(或合并请求)的好办法</li><li id="39b3" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp pq nr ns nt bi translated">GitLab API使用它们来生成changelog条目</li><li id="b58b" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp pq nr ns nt bi translated">由于一个简单的脚本，您可以自动更新发行说明，而无需任何额外的操作</li></ol><h1 id="6f0a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">关于git版本管理的警告</h1><p id="c5d2" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">因为您可以在任何代码版本(分支)上运行脚本，所以您可能会遇到冲突。这取决于您使用的git版本管理。</p><blockquote class="op oq or"><p id="4093" class="ku kv na kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">最流行的git版本管理是基于主干的和Git流开发(更多细节<a class="ae lq" href="https://www.toptal.com/software/trunk-based-development-git-flow" rel="noopener ugc nofollow" target="_blank">在这里</a>)。如果你不熟悉这个概念，这只是你在特定环境下(集成、登台、预生产、生产)版本化代码和处理新变化的方式。</p></blockquote><h2 id="2c99" class="ov me it bd mf ow ox dn mj oy oz dp mn ld pa pb mp lh pc pd mr ll pe pf mt pg bi translated">基于主干的</h2><p id="f2ab" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">如果你使用基于主干的风格，那么没问题。发行说明将始终根据发布的最新版本进行更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/36919952c1cb9a03acbfe3e75bf02544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TErpM2XY_CMvv0pIDEjxOg.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:作者</p></figure><h2 id="8e14" class="ov me it bd mf ow ox dn mj oy oz dp mn ld pa pb mp lh pc pd mr ll pe pf mt pg bi translated">Git流</h2><p id="d89b" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">由于Git流是围绕几个分支设计的，因此需要分支同步。更改会被覆盖，不会出现在发行说明中。然后，技巧是指定不同的git尾部来标识分支之间的变化。</p><p id="6a26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">主要用例(如下所示)是来自<code class="fe nb nc nd ne b">master</code>的bug修复或热修复。在这里，从<code class="fe nb nc nd ne b">master</code>开始的变化用<em class="na"> Fix </em> git trailer标记。因此，在计算<code class="fe nb nc nd ne b">x.y+2.0</code>版本的changelog时，不会过滤掉带有此预告片的提交。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/2119d1a8c9c9d90970e9c139779e23ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgNxnO96HjSsQN_2SZv3tw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:作者</p></figure><p id="40ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在下面找到调用GitLab API的节点脚本的更新版本。您会注意到当前分支是使用<code class="fe nb nc nd ne b">exec</code>方法检索的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="91d0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">最后</h1><p id="ebed" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">用发布说明跟踪变更应该是软件项目的必做之事<strong class="kw iu"> </strong>。</p><p id="1b76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管是为了一个产品还是技术目的，都是一个透明的证明。你应该同意，这并不复杂，只是需要尽可能清晰地表达变更日志条目。</p><p id="4507" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GitLab再一次因为这个平台提供的各种可能性而大放异彩；这里是存储库API。也可以看看<a class="ae lq" href="https://docs.github.com/en/repositories/releasing-projects-on-github/automatically-generated-release-notes" rel="noopener ugc nofollow" target="_blank"> GitHub替代</a>如果更适合你的情况。</p><h1 id="f078" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">参考</h1><div class="lr ls gp gr lt lu"><a href="https://semver.org/" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">语义版本2.0.0</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">给定主要版本号。补丁，增加:主要版本当你做不兼容的API改变，次要…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">semver.org</p></div></div></div></a></div><div class="lr ls gp gr lt lu"><a href="https://docs.gitlab.com/ee/api/repositories.html#add-changelog-data-to-a-changelog-file" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">仓库API | GitLab</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">获取项目中存储库文件和目录的列表。在以下情况下，无需身份验证即可访问此端点…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">docs.gitlab.com</p></div></div></div></a></div><div class="lr ls gp gr lt lu"><a href="https://docs.gitlab.com/ee/api/" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">API文档| GitLab</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">使用GitLab APIs自动化GitLab。GitLab中提供了一个REST API。使用说明如下。例如…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">docs.gitlab.com</p></div></div></div></a></div><div class="lr ls gp gr lt lu"><a href="https://git-scm.com/docs/git-interpret-trailers" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">Git - git-interpret-trailers文档</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">帮助解析或添加尾部行，看起来类似于RFC 822电子邮件头，在其他…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">git-scm.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf ks lu"/></div></div></a></div></div></div>    
</body>
</html>