<html>
<head>
<title>Creating a REST API in Node.js with Express, Typescript, MongoDB and Docker — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Express、Typescript、MongoDB和Docker在Node.js中创建REST API第1部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-1-8428b0cd05d?source=collection_archive---------1-----------------------#2019-07-04">https://betterprogramming.pub/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-1-8428b0cd05d?source=collection_archive---------1-----------------------#2019-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="097e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Node.js中创建RESTful PokeAPI</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2412e6bececa735d1588750633e9d62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0MSEI9BpIi7uXaWOj3CLQ.png"/></div></div></figure><p id="1775" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是系列文章的第一部分，将向您展示如何使用Express、TypeScript、Docker和MongoDB在Node.js中创建REST API。以下是本系列的其余部分:</p><p id="280e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://medium.com/better-programming/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-2-38b48af52860" rel="noopener">用Express、Typescript、MongoDB和Docker在Node.js中创建REST API第二部分</a></p><p id="3014" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://medium.com/better-programming/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-3-1b173fc2a482" rel="noopener">用Express、Typescript、MongoDB和Docker在Node.js中创建REST API第三部分</a></p><p id="de7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里找到<a class="ae lq" href="https://github.com/puntotech/pokeAPI/" rel="noopener ugc nofollow" target="_blank">的完整代码。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f87b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">介绍</h1><p id="9174" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在这个系列中，我们将学习如何使用名为<a class="ae lq" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>的优秀web框架在Node.js中创建我们自己的RESTful API。然而，在我们开始之前，有一点理论:</p><p id="1cf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a>代表具象状态转移。Roy Fielding为他的博士论文设计的令人敬畏的软件架构风格。REST允许我们通过使用HTTP协议来设计松散耦合的应用程序。</p><p id="f204" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">HTTP为我们提供了以下动词，或者说方法:GET、POST、PUT和DELETE，分别对应于Read、Create、Update和Delete (CRUD操作)。还有一些其他的动词，但是它们不经常使用。我们将使用这些动词来发出请求，这些请求将对我们的数据执行各种操作。</p><p id="1d43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为(依我拙见)<a class="ae lq" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>是自切片面包以来最好的东西，这是我们将使用的语言。对于那些不熟悉它的人来说，TypeScript是JavaScript的一个类型化超集，我们将它编译成普通的JavaScript，它允许我们向JavaScript添加类型。</p><p id="5284" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们需要一个数据库来存储我们的数据，我们将使用MongoDB的一个dockerized实例，以及<a class="ae lq" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose，</a>一个ODM，它使得与MongoDB的交互更加容易。</p><p id="0ab6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们知道了我们将做什么以及如何做，让我们开始编码吧。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c5a2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">先决条件</h1><h2 id="e6a8" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">试映</h2><p id="3913" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在我们开始之前，我想向您展示一下在本系列结束时我们的目录树的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/a4cb255b34020687394d3808cbbe2a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*F6YcYYJnAU1daA_LHCNI9A.png"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">pokeApi part1目录树</p></figure><p id="ff99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nm">为了防止有人对我如何生成目录树映像感到好奇，我使用了Linux </em> <code class="fe nn no np nq b"><em class="nm">tree </em></code> <em class="nm">命令，并抓拍了一张我的终端的截图。</em></p><h2 id="015a" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">安装Node.js</h2><p id="9067" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">由于我们将在项目中使用Node.js，首先要做的是确保它安装在我们的机器上。</p><p id="1336" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nm">提示:打开您的终端并运行这个命令来检查是否安装了节点:</em> <code class="fe nn no np nq b"><em class="nm">node -v</em></code> <em class="nm">。</em></p><p id="8fbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有，可以在这里安装<a class="ae lq" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="6470" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">安装Docker和Docker-compose</h2><p id="0022" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Docker是一个奇妙的工具，它允许我们通过使用容器来创建、部署和运行应用程序(或者几乎任何我们想要的东西)。我们可以用几个简单的命令在几分钟内部署一个MongoDB数据库(或任何其他数据库)。</p><p id="6077" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提示:运行 <code class="fe nn no np nq b"><em class="nm">docker -v</em></code> <em class="nm">看看你的机器上是否有Docker。</em></p><p id="d33f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有，可以在这里安装<a class="ae lq" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cc57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我刚才提到的，Docker非常棒。然而，这纯粹是个人喜好，我更喜欢使用Docker Compose部署我的容器，这是Docker提供的一个简洁的工具。它允许我们创建一个<code class="fe nn no np nq b">.yml</code>配置文件，我们可以在其中指定容器的所有细节，并使用一个简单的命令部署该容器。</p><p id="accc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提示:运行 <code class="fe nn no np nq b"><em class="nm">docker-compose -v</em></code> <em class="nm">来检查你的机器上是否有Docker-Compose。</em></p><p id="22f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有，可以在这里安装<a class="ae lq" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1f67" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">设置</h1><h2 id="e780" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">入门指南</h2><p id="c27d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">有了所有的先决条件，我们现在可以开始真正的编码了。让我们开始吧:</p><p id="9324" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一步是创建我们的项目将要存在的文件。我将我们的项目目录命名为<code class="fe nn no np nq b">pokeApi</code>。如果你喜欢，可以随意选择不同的名字，这完全由你决定。要创建并进入我们的项目目录，请打开您的终端并键入以下命令:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="6812" class="mv lz it nq b gy nv nw l nx ny">mkdir pokeApi<br/>cd pokeApi</span></pre><p id="fede" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦进入我们的项目文件，我们想要创建我们的<code class="fe nn no np nq b">package.json</code>文件。为此，请在终端中键入以下命令:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="3e18" class="mv lz it nq b gy nv nw l nx ny">npm init</span></pre><p id="f1fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行这个命令后，我们会被问一系列问题，在回答这些问题后，我们的<code class="fe nn no np nq b">package.json</code>文件就会被创建。</p><p id="dd3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nm">提示:如果你不想回答npm的问题，可以用这个命令来代替:</em> <code class="fe nn no np nq b"><em class="nm">npm init -y</em></code> <em class="nm">。</em> <br/>您可以随时返回到<code class="fe nn no np nq b">package.json</code>文件，稍后再进行编辑。</p><h2 id="2fa3" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">安装依赖项</h2><p id="5ee7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">能够使用express，mongoose，TypeScript等。我们必须安装一些依赖项。为此，请运行以下命令:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="2aac" class="mv lz it nq b gy nv nw l nx ny">npm i body-parser cors express mongoose</span></pre><p id="98f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要安装几个开发所需的依赖项:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="996c" class="mv lz it nq b gy nv nw l nx ny">npm i -D @types/body-parser @types/cors @types/express @types/mongoose @types/node nodemon ts-node typescript</span></pre><p id="b9be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nm">提示:通过在</em> <code class="fe nn no np nq b"><em class="nm">npm i</em></code> <em class="nm">命令中添加</em> <code class="fe nn no np nq b"><em class="nm">-D</em></code> <em class="nm">或</em> <code class="fe nn no np nq b"><em class="nm">--save-dev</em></code> <em class="nm">命令，安装后的依赖项会列在</em> <code class="fe nn no np nq b"><em class="nm">package.json</em></code> <em class="nm">文件中的</em> <code class="fe nn no np nq b"><em class="nm">devDependencies </em></code> <em class="nm">下。</em></p><h2 id="018c" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">添加npm脚本</h2><p id="9c21" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了能够运行我们的项目，我们必须在我们的<code class="fe nn no np nq b">package.json</code>文件中创建以下脚本:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="da53" class="mv lz it nq b gy nv nw l nx ny">"scripts": {</span><span id="3d56" class="mv lz it nq b gy nz nw l nx ny">"start": "nodemon"</span><span id="ed91" class="mv lz it nq b gy nz nw l nx ny">},</span></pre><h2 id="87c4" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">配置nodemon</h2><p id="fee7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Nodemon是一个开发Node.js应用程序的优秀工具。每当检测到代码中的变化时，它会自动重新启动应用程序。(基本上，每当我们存钱的时候。)</p><p id="164f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建一个名为<code class="fe nn no np nq b">nodemon.json</code>的文件，并添加以下内容:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="2bc1" class="mv lz it nq b gy nv nw l nx ny">{<br/>"watch": ["src"],<br/>"ext": "ts",<br/>"exec": "ts-node ./src/server.ts"<br/>}</span></pre><p id="276d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这告诉nodemon应该监视和执行哪些文件。</p><h2 id="5fb4" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">配置TypeScript</h2><p id="bdfb" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要生成我们的<code class="fe nn no np nq b">tsconfig.json</code>文件，运行以下命令:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="4417" class="mv lz it nq b gy nv nw l nx ny">tsc --init</span></pre><p id="013d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，默认生成的<code class="fe nn no np nq b">tsconfig.json</code>文件包含许多配置选项，其中许多我们可能不需要使用。当然，您可以根据自己的喜好配置TypeScript。如果没有，下面是我使用的配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="e1cc" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">创建. gitignore文件</h2><p id="f851" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在这个文件中，我们可以列出希望git忽略的所有文件/目录。这意味着当我们添加并提交对项目所做的更改时，这些文件对git来说将保持“不可见”。</p><p id="6422" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nm">提示:非常非常，</em> <strong class="kw iu"> <em class="nm">非常</em> </strong> <em class="nm">重要补充</em> <code class="fe nn no np nq b"><em class="nm">node_modules</em></code> <em class="nm">到我们的</em> <code class="fe nn no np nq b"><em class="nm">.gitignore</em></code> <em class="nm">。我们绝对不希望这个巨大的文件被推送到我们的存储库中！</em></p><p id="6b4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要创建我们的<code class="fe nn no np nq b">.gitignore</code>文件，在根目录下运行以下命令:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="66a5" class="mv lz it nq b gy nv nw l nx ny">touch .gitignore</span></pre><p id="b395" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在文件中添加以下几行:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="9a72" class="mv lz it nq b gy nv nw l nx ny">node_modules<br/>dist</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2d7a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">让编码开始吧</h1><h2 id="688f" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">设置我们的服务器</h2><p id="e0ae" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们要做的第一件事是创建我们的基本目录结构。我们将创建一个名为<code class="fe nn no np nq b">src</code>的目录，其中将包含我们所有的项目文件，除了<code class="fe nn no np nq b">config</code>:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="a57e" class="mv lz it nq b gy nv nw l nx ny">mkdir src<br/>cd src <br/>mkdir constants<br/>touch server.ts<br/>touch app.ts </span></pre><p id="4712" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们打开刚刚创建的<code class="fe nn no np nq b">app.ts</code>文件，它将包含我们的快速配置。这看起来好像一下子有很多代码，但是不要担心！这只是express工作所需的基本配置，我们将仔细检查每一行，以便了解发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated"><a class="ae lq" href="https://gist.github.com/NyaGarcia/a2050d0366fc1dff5d6ed053ba084e2a" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/a 2050d 0366 fc 1 dff 5d 6 ed 053 ba 084 e2a</a></p></figure><p id="302f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们快速浏览一下快速配置:</p><ul class=""><li id="236d" class="oc od it kw b kx ky la lb ld oe lh of ll og lp oh oi oj ok bi translated">Body parser允许我们接收不同格式的数据请求，例如<code class="fe nn no np nq b">json</code>或<code class="fe nn no np nq b">x-www-form-urlencoded</code>。</li><li id="9ae7" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">CORS(跨源资源共享)使用额外的HTTP头，让我们的浏览器知道它必须允许在一个域上运行的web应用程序访问来自不同源的服务器的资源。</li></ul><p id="0549" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后，我们将创建一个文件来存储应用程序的常量。为什么？因为这样我们只需要声明每个常量一次。每当我们需要使用它的时候，我们只需要导入它。</p><p id="ad07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，如果我们需要改变常量的值(是的，即使它是一个常量，当我们需要改变它的值的时候可能会到来)，它将在我们项目的任何地方改变，因为它只在一个地方声明。综上所述，让我们创建我们的常量文件:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="0dce" class="mv lz it nq b gy nv nw l nx ny">cd constants<br/>touch pokeApi.constants.ts</span></pre><p id="d1f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们要声明的第一个常量是我们的<code class="fe nn no np nq b">PORT</code>，它将存储我们要为服务器打开的端口号:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="972a" class="mv lz it nq b gy nv nw l nx ny">//src/constants/pokeApi.constants.ts</span><span id="f855" class="mv lz it nq b gy nz nw l nx ny">export const PORT = 9001;</span></pre><p id="ad57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，转到我们的<code class="fe nn no np nq b">server.ts</code>文件，我们将在这里设置我们的服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated"><a class="ae lq" href="https://gist.github.com/NyaGarcia/abd9f3b020e74a9284437cef38daadb2" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/Abd 9 F3 b 020 e 74 a 9284437 cef 38 da ADB 2</a></p></figure><p id="8728" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nm">提示:如果有人不熟悉我在</em> <code class="fe nn no np nq b"><em class="nm">console.log</em></code> <em class="nm">中使用的语法，这是一种叫做模板文字的技术。您在坟墓引号(</em><strong class="kw iu"><em class="nm">`</em></strong><em class="nm">)内键入所有内容，并使用插值(</em><strong class="kw iu"><em class="nm">$ { }</em></strong><em class="nm">)来嵌入变量。更多关于此术</em> <a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"> <em class="nm">这里</em> </a> <em class="nm">。</em></p><p id="a2ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们正在导入之前创建的应用程序和我们的<code class="fe nn no np nq b">PORT </code>常量。</p><p id="e4e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就凭这三个lil文件，我们就创建了自己的服务器！启动您的终端并执行我们之前创建的npm启动脚本。您可以通过键入以下命令来完成此操作:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="6c27" class="mv lz it nq b gy nv nw l nx ny">npm run start (or just npm start for the pros)</span></pre><p id="1ae1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nm">提示:因为我们使用nodemon来查看我们的项目文件，所以我们只需要执行前面的命令一次。每次我们保存更改时，nodemon都会自动为我们重新启动应用程序。</em></p><p id="c7de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行该命令后，您应该在终端上看到<em class="nm">监听端口9001 </em>消息。厉害！我们现在已经启动并运行了我们的服务器。</p><p id="5e0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你也可以去你最喜欢的浏览器查看一下:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="9edc" class="mv lz it nq b gy nv nw l nx ny">localhost:9001</span></pre><p id="f0d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该会看到类似下面的消息:<em class="nm">无法获取/ </em>。我知道，不是很令人兴奋…但是如果你看到这条信息，它是有效的！如果没有，返回并重新检查您的代码，以确保没有任何遗漏。</p><h2 id="cbad" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">创建我们的第一条获取路线</h2><p id="08bf" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">既然我们现在已经启动并运行了服务器，我们将创建第一个GET路由并显示一条漂亮的欢迎消息。毕竟，“得不到/”并不怎么受欢迎。</p><p id="eb6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们需要创建一个名为<code class="fe nn no np nq b">pokemon.controller.ts</code>(在<code class="fe nn no np nq b">src</code>中)的文件，它将有一个公共的<code class="fe nn no np nq b">router</code>属性。该属性将保存Express路由器的一个实例，我们将使用它来定义我们的路由。我们的控制器最初应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated"><a class="ae lq" href="https://gist.github.com/NyaGarcia/2a8c2224fb4f62b31f723cae6326e650" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/2a8c 2224 FB 4 f 62 b 31 f 723 CAE 6326 e 650</a></p></figure><p id="1a4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的口袋妖怪控制器是我们将要定义所有口袋妖怪路线的地方。每条路线将执行不同的操作，例如:</p><ul class=""><li id="104e" class="oc od it kw b kx ky la lb ld oe lh of ll og lp oh oi oj ok bi translated">获取数据库中所有可用口袋妖怪的列表。</li><li id="c8ea" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">添加一个新的口袋妖怪。</li><li id="ee47" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">更新口袋妖怪。</li><li id="8932" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">删除一个口袋妖怪。</li><li id="4d5d" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">我们还想做什么。</li></ul><p id="aee6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们要定义的第一个路由是一个简单的GET路由，它将返回一条很好的欢迎消息。为此，我们需要创建一个<code class="fe nn no np nq b">setRoutes</code>方法，它将负责定义路线。在其中，我们可以定义第一个GET路径，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated"><a class="ae lq" href="https://gist.github.com/NyaGarcia/3e718df0ba1e43f9eba2d2e6376df971" rel="noopener ugc nofollow" target="_blank">口袋妖怪控制器版本2 https://gist . github . com/nya Garcia/3e 718 df 0 ba 1e 43 f 9 EBA 2d 2 e 6376 df 971</a></p></figure><p id="e3cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nm">提示:不要忘记调用控制器中的</em> <code class="fe nn no np nq b"><em class="nm">setRoutes</em></code> <em class="nm">方法，否则路线将不起作用！</em></p><p id="1dbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您在前面的代码中看到的，我们使用了快速路由器来定义GET路由，它接收两个参数:</p><ul class=""><li id="5f50" class="oc od it kw b kx ky la lb ld oe lh of ll og lp oh oi oj ok bi translated">第一个是我们将用来访问我们的路线的路径，我们将其定义为<code class="fe nn no np nq b">/</code>。</li><li id="6069" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated">第二个是回调函数，它依次接收两个参数(它可以接收可选的第三个参数<code class="fe nn no np nq b">next</code>，我们将在后面的其他路由中使用它):请求和响应对象。请求对象，顾名思义，表示HTTP请求，并具有请求查询字符串、参数、主体、HTTP头等属性。另一方面，Response对象表示我们的应用程序将发出的HTTP响应，以回答任何收到的HTTP请求。</li></ul><p id="61fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，通过使用响应对象，我们可以发出欢迎消息。很简单，不是吗？然而，我们的路线有点偏离…</p><h2 id="cb9a" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">关注点的分离</h2><p id="7dc4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">开发人员的主要目标应该是编写干净、可维护的代码。为什么？因为</p><p id="5b49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的代码不应该依赖于具体的实现。这到底是什么意思？请允许我举一个例子来说明:</p><p id="1554" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个项目，我们最初将使用MongoDB数据库。但是，让我们假设我们需要将数据库更改为MySQL。由于与数据库交互的所有函数都是在控制器内部定义的，所以为了对MySQL数据库进行更改，我们必须进入控制器，修改每一个函数。</p><p id="ba0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果我们在一个单独的文件中定义所有的MongoDB数据库函数，一个名为<code class="fe nn no np nq b">PokemonService</code>的文件实现了一个泛型，如果我们想要更改为MySQL，我们必须做的就是创建另一个服务，这次是用一个MySQL特定的泛型接口实现，并将所述服务注入到我们的控制器中，替换MongoDB服务。</p><p id="4a38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，通过使用服务与我们的数据库进行交互，我们保持了代码的松散耦合，因此是可维护的。</p><h2 id="0b6e" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">创建口袋妖怪服务</h2><p id="3a29" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">因此，我们现在将创建一个名为<code class="fe nn no np nq b">services</code>的目录，并在其中创建一个名为<code class="fe nn no np nq b">pokemon.service.ts</code>的文件。完成后，我们将添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">口袋妖怪服务版本1</p></figure><p id="2f81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个非常简单的函数，返回我们可爱的欢迎信息。现在，我们需要去我们的<code class="fe nn no np nq b">pokemon.controller</code>做两件事:</p><ol class=""><li id="c3e9" class="oc od it kw b kx ky la lb ld oe lh of ll og lp oq oi oj ok bi translated">导入我们刚刚创建的服务。</li><li id="63ca" class="oc od it kw b kx ol la om ld on lh oo ll op lp oq oi oj ok bi translated">从我们的主GET路径调用服务的<code class="fe nn no np nq b">getWelcomeMessage</code>函数。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated"><a class="ae lq" href="https://gist.github.com/NyaGarcia/b2d5acfc9181f34b064291d9633dea76" rel="noopener ugc nofollow" target="_blank">口袋妖怪控制器第三版https://gist . github . com/nya Garcia/B2 D5 acfc 9181 f 34 b 064291d 9633 DEA 76</a></p></figure><p id="8651" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，我们的主路由现在调用我们刚刚在PokemonService中创建的<code class="fe nn no np nq b">getWelcomeMessage</code>函数，并通过使用Response对象将其发送出去。</p><p id="1ddd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，一切顺利。是时候将我们的<code class="fe nn no np nq b">Controller </code>导入到我们的<code class="fe nn no np nq b">app.ts</code>中了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated"><a class="ae lq" href="https://gist.github.com/NyaGarcia/cd079617ebafad86f033190658813dde" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/CD 079617 EBA fad 86 f 033190658813 DDE</a></p></figure><p id="d004" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你在第28行看到的，我们再次使用了<code class="fe nn no np nq b">app.use</code>方法，它接收一个可选的<code class="fe nn no np nq b">path</code>参数以及中间件回调函数。基本上，我们在这里做的是告诉Express每当我们发出以<code class="fe nn no np nq b">/pokemon</code>开头的请求时就调用<code class="fe nn no np nq b">PokemonController</code>路由器。</p><p id="b1bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们完事了。转到您的浏览器，如果您做的一切都正确，您应该会看到显示的欢迎消息，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/c023edd1729d26119d3f19f145f0a7df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*zFMmXXjkNWUk9CgvAL9r2Q.png"/></div></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">欢迎信息</p></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6b75" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">是时候重构了</h1><h2 id="03f3" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">移除硬编码字符串</h2><p id="d804" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">还记得我们创建了一个存储所有常量的文件吗？您可能已经意识到，在我们的<code class="fe nn no np nq b">welcomeMessage </code>函数(在我们的pokemon服务中)中，我们返回了一个包含消息的<code class="fe nn no np nq b">String </code>，我们将它硬编码到了我们的服务中。不是很整齐，对吧？如果我们想改变信息呢？我们必须修改服务，这不是我们想要的。</p><p id="0752" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们将获取欢迎消息并在我们的<code class="fe nn no np nq b">constants</code>文件中声明它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated"><a class="ae lq" href="https://gist.github.com/NyaGarcia/42d25352eb9044781fef07c12ff3dd5f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/42d 25352 EB 9044781 fef 07 c 12 ff 3d D5 f</a></p></figure><p id="9540" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们做到了这一点，我们需要在我们的服务中导入常量文件，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated"><a class="ae lq" href="https://gist.github.com/NyaGarcia/77fdc298d1822fbc27d6cd96b3076cda" rel="noopener ugc nofollow" target="_blank">口袋妖怪服务第二版https://gist . github . com/nya Garcia/77 FDC 298d 1822 FBC 27 D6 CD 96 b 3076 CDA</a></p></figure><p id="2400" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您返回到浏览器，您应该仍然会看到欢迎消息。</p><h2 id="43bb" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">提取回调函数</h2><p id="44e9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们可以做的另一件事是将匿名回调函数提取到命名函数中，从而稍微清理一下代码。让我们来看看如何做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">口袋妖怪控制器第4版<a class="ae lq" href="https://gist.github.com/NyaGarcia/771a96a187bb25ee9a41bde14953f4f2" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/771 a96a 187 bb 25 ee 9 a 41 bde 14953 F4 f 2</a></p></figure><p id="760f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，通过将回调逻辑提取到<code class="fe nn no np nq b">sayHello</code>函数中，我们的路径看起来更加清晰。现在您可以一目了然地看到它接收的两个参数，路由和回调函数。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4261" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="349b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在这篇文章中，我们介绍了从项目配置的初始设置到定义第一条路由和成功地发出第一个GET请求的所有内容。</p><p id="c884" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想查看第一部分的代码，你可以在PokeAPI项目的这个分支中找到它。</p><p id="6851" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本系列的下一部分中，我们将把我们的应用程序连接到MongoDB的dockered实例，该实例是用Docker Compose部署的。我们还将使用Mongoose来创建数据模型和模式。这是下一部分的链接:</p><p id="21ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://medium.com/better-programming/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-2-38b48af52860" rel="noopener">用Express、Typescript、MongoDB和Docker在Node.js中创建REST API第二部分</a></p><p id="3d48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非常感谢你的阅读，我希望你能喜欢这篇文章并觉得有用。请随意与您的朋友和/或同事分享，如果您有任何意见，请随时联系我！</p></div></div>    
</body>
</html>