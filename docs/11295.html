<html>
<head>
<title>The Liskov Substitution Principle (LSP) Explained in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python解释的利斯科夫替换原理(LSP)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-liskov-substitution-principle-lsp-explained-in-python-6ab92b29d0b8?source=collection_archive---------9-----------------------#2022-03-07">https://betterprogramming.pub/the-liskov-substitution-principle-lsp-explained-in-python-6ab92b29d0b8?source=collection_archive---------9-----------------------#2022-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f539" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">迈向健壮的软件，坚实的原理3/5解释清楚！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f032fd0cfea013392d4f7bbf0c91ddc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OIMPmBvvHo_sl67G"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aaronburden?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">亚伦·伯顿</a> / <a class="ae ky" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="44c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于<a class="ae ky" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实</a>原则系列文章的第3部分。<br/>你可以在这里找到第二个帖子<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-open-closed-principle-explained-in-python-f5517488f990">。</a></p><p id="1246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入研究这个原则的推理以及它如何与最后两个原则相适应之前，让我们先来看一下定义。</p><p id="226a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利斯科夫替代原理被正式定义为:</p><blockquote class="lv lw lx"><p id="4868" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><em class="it">设</em> ϕ(x) <em class="it">是关于t类型的对象</em> x <em class="it">的一个可证性质那么</em> ϕ(y) <em class="it">对于s类型的对象</em> y <em class="it">应该是真的其中s是t的子类型来源:</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank"> <em class="it">芭芭拉·利斯科夫</em> </a></p></blockquote><p id="0493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面对现实吧，这对现代软件工程师来说毫无意义。</p><p id="5cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个更简单的定义:</p><blockquote class="lv lw lx"><p id="8baf" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">应该可以用一个子类的实例替换一个超类的实例，而不会导致破坏性的改变。</p></blockquote><p id="500f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你有一个从基类/超类派生的子类(继承)。假设你对子类做了一些改变，比如参数值类型的改变，也许还有返回类型的改变。在这种情况下，您将违反LSP原则，因为用子类的实例替换超类的实例将导致破坏性的变化。例如，依赖于基类的代码期望返回类型为<code class="fe mc md me mf b">str</code>，但是当你用子类替换实例时，它返回一个<code class="fe mc md me mf b">int</code>。这可能会导致代码崩溃或引发其他错误。</p><p id="f1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，基类的<strong class="lb iu"> <em class="ly">行为</em> </strong>必须符合超类的行为。一般来说，子类中的函数签名(函数参数)和返回类型必须保持不变。</p><p id="c95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个原则的主要目的是确保在引入新代码时旧的代码库不会中断。此外，它确保灵活的代码。</p><h1 id="423d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">密码</h1><p id="c724" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们看一个简单的例子。我们通过考虑汽车而不是汽车经销商来稍微改变以前帖子中的场景:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">Car</code>类定义了一辆汽车。我们用一个名字，齿轮的数量，速度和当前的齿轮位置来初始化它。<code class="fe mc md me mf b">changeGear</code>功能允许换档，而<code class="fe mc md me mf b">accelerate</code>功能将车速提高1。如果档位处于空档位置<code class="fe mc md me mf b">N</code>，我们不改变速度，而是通知用户。相当简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/2e94d70dffa57f5fa2beac452c6389dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*ruc4DBpZo4uijr99DCcbQQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">跑车继承汽车。来源:作者。</p></figure><p id="7343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们也想要一个<code class="fe mc md me mf b">SportsCar</code>模型。我们让它从基类<code class="fe mc md me mf b">Car</code>继承。在初始化时，我们还定义了一个<code class="fe mc md me mf b">turbos</code>变量，它是一个列表，显示汽车支持的涡轮级别。因为行为变化<strong class="lb iu"> <em class="ly"> </em> </strong>我们需要定义一个新的加速度函数，它以<code class="fe mc md me mf b">turbo</code>为参数。<code class="fe mc md me mf b">speed</code>增加了涡轮增压量，而不是<code class="fe mc md me mf b">1</code>，因此跑车可以加速更快。</p><p id="413f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mc md me mf b">__main__</code>函数中，我们定义了一辆普通汽车。</p><p id="e3fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是这样的:</p><p id="80f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图用一个<code class="fe mc md me mf b">SportsCar</code>的实例替换<code class="fe mc md me mf b">Car</code>实例，这会导致代码中断，因为<code class="fe mc md me mf b">SportsCar</code>中的<code class="fe mc md me mf b">accelerate</code>需要一个<code class="fe mc md me mf b">turbo</code>参数。</p><p id="1ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过LSP，替换上面的代码应该不会产生错误，代码应该正常运行。</p><p id="c7da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以解决这个问题。</p><h1 id="c0af" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">解决方案1</h1><p id="5324" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一个简单的解决方案是用具有固定值的<code class="fe mc md me mf b">turbo</code>变量替换<code class="fe mc md me mf b">turbos</code>变量。从<code class="fe mc md me mf b">accelerate</code>函数中删除参数<code class="fe mc md me mf b">turbo</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cdb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，函数签名现在与基类函数签名完全相同。这意味着我们可以用<code class="fe mc md me mf b">SportsCar</code>替换<code class="fe mc md me mf b">__main__</code>功能中的<code class="fe mc md me mf b">Car</code>代码，而不会出现代码断裂。耶！</p><p id="3601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你注意到我们在这种情况下有一个固定的涡轮值<code class="fe mc md me mf b">2</code>。如果我们想让用户像以前一样定义涡轮值，该怎么办？<br/>这需要使用一个抽象的<strong class="lb iu"> <em class="ly"> </em> </strong>类。我们走吧！</p><h1 id="6d5d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">解决方案2 —抽象类</h1><p id="99db" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">问题是我们制造汽车的方式。为了使上面的代码符合LSP并具有turbo choice的功能，我们必须创建一个<strong class="lb iu"> <em class="ly">抽象</em> </strong>基类<code class="fe mc md me mf b">Car</code>。然后我们创建两个继承它的子类，即:<code class="fe mc md me mf b">SportsCar</code>和<code class="fe mc md me mf b">RegularCar</code>。下图说明了这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/2b08e023cdacde7486d434cdbc96ad08.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*IANa-TDXz3V-1Rw4p6O-xQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汽车是抽象的。普通车和跑车实现抽象类。来源:作者。</p></figure><p id="2924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码会更有意义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe mc md me mf b">ABC</code>模块将<code class="fe mc md me mf b">Car</code>转换成一个抽象类。细节并不重要。<code class="fe mc md me mf b">init</code>函数以<code class="fe mc md me mf b">@abstractmethod</code>开始，表示抽象函数。这确保了<code class="fe mc md me mf b">Car</code>不会被实例化。只有从此继承的类才能被实例化。</p><p id="ac83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们创建两个继承自<code class="fe mc md me mf b">Car</code>的类:</p><ul class=""><li id="a225" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe mc md me mf b">RegularCar</code>表示没有涡轮增压的普通汽车</li><li id="90fe" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe mc md me mf b">SportsCar</code>表示带涡轮增压的跑车</li></ul><p id="d33f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">RegularCar</code>没有其他变化。在<code class="fe mc md me mf b">SportsCar</code>类中，我们可以做我们想要的修改。我们定义了包含额外的<code class="fe mc md me mf b">turbo</code>参数的<code class="fe mc md me mf b">turbos</code>数组和<code class="fe mc md me mf b">turboAccelerate</code>函数。</p><p id="42f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，改变<code class="fe mc md me mf b">SportsCar</code>中的函数签名并不违反LSP。为什么？因为基类<code class="fe mc md me mf b">Car</code>是抽象的，所以不能被实例化。<br/>不能实例化，就不能替换。</p><h1 id="0508" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="6f44" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这篇文章中，我们看了利斯科夫替代原理及其含义。我们看到了一个违反原则的例子，并用两种方法解决了这个问题。</p><p id="2bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LSP有助于提高代码的灵活性，并防止在用新代码扩展旧代码时出现问题。LSP确保代码的行为<strong class="lb iu"> <em class="ly"> </em> </strong>在新的和旧的代码库中保持相同，从而使代码不容易损坏。总的来说，代码的健壮性因此得到了提高。</p><p id="45af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章比以前的文章更复杂，特别是因为我们以迂回的方式处理了这个问题。我想探索一个稍微增加复杂性的有趣场景。我希望你喜欢这些内容！</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt oc mf od oe aw of bi"><span id="e281" class="og mh it mf b gy oh oi l oj ok"><strong class="mf iu">Want to Connect?</strong></span><span id="fd32" class="og mh it mf b gy ol oi l oj ok"><em class="ly">Originally published at </em><a class="ae ky" href="https://haseebkamal.com/the-liskov-substitution-principle-explained-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="ly">https://haseebkamal.com</em></a><em class="ly"> on</em></span></pre></div></div>    
</body>
</html>