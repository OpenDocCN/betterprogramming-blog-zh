<html>
<head>
<title>A Quick Guide to SwiftUI Essentials</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI基础知识快速指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/quick-guide-on-swiftui-essentials-8ba8fe007bcd?source=collection_archive---------1-----------------------#2020-10-18">https://betterprogramming.pub/quick-guide-on-swiftui-essentials-8ba8fe007bcd?source=collection_archive---------1-----------------------#2020-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a280" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">视图创建和状态管理的基本SwiftUI概念和术语</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e91f8c62975284507d534fefc6e22bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ijveadRYAhAJRKB_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0be1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WWDC 2019上听到苹果公司名为SwiftUI的新框架真是令人兴奋。本文是SwiftUI的快速入门指南。</p><p id="d9ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将看看SwiftUI中的视图是如何创建、布局和呈现的。然后，我们将研究如何使用SwiftUI管理状态。最后，我们将看看SwiftUI和UIKit是如何配合使用的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/31d2c8b0a047e77aa8938c5fa2ee8c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uBDuSUiinyjnQuyf.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="lw">这个世界太精彩了！</em></p></figure><h1 id="a448" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">SwiftUI中的视图</h1><p id="9e25" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">使用UIKit，我们有不同的方法来构建用户界面。关于是通过编程还是使用界面构建器来构建ui，人们进行了很多讨论。有了SwiftUI，这些问题都没有了。我们终于有了一种用代码编写UI的声明式方法——并且可以和代码一起预览。</p><h2 id="9ec9" class="mu ly it bd lz mv mw dn md mx my dp mh li mz na mj lm nb nc ml lq nd ne mn nf bi translated">基本SwiftUI视图</h2><p id="c676" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">SwiftUI视图只是一个普通的具有两种结构的<code class="fe ng nh ni nj b">.swift</code>文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/eb9673a82bbe536002707cd9e70eb3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AWdQLerHTRI_z4W8.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="lw">基本SwiftUI视图示例</em></p></figure><h2 id="8808" class="mu ly it bd lz mv mw dn md mx my dp mh li mz na mj lm nb nc ml lq nd ne mn nf bi translated">对齐视图</h2><p id="0ec7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当实现SwiftUI视图时，我们不必像使用UIKit视图那样设置约束。相反，SwiftUI会计算出每个视图的固有大小，并在默认情况下将其放置在其父视图的中心，而不会调整其大小。</p><p id="d1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI中对齐视图的核心概念是使用堆栈，使用<code class="fe ng nh ni nj b">VStack</code>进行垂直对齐，使用<code class="fe ng nh ni nj b">HStack</code>进行水平对齐。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/e6da806390bd6cdc15fb2b33cd36c6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kpwm5wPgnASYtgkm.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="lw">使用HStack和VStack对齐视图</em></p></figure><p id="d4a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如示例所示，我们可以嵌套不同的堆栈来实现所需的结果，这个概念非常直观。</p><p id="3d2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以在每个视图上使用不同的修改器来对齐和定位它们。例如，<code class="fe ng nh ni nj b">frame(width:height:alignment:)</code>将视图包装到一个给定大小的容器中，并在这个容器中对齐视图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/2ada3cd82c8b154b8df4e4637c2e8adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fYSnAw7m10MckG82.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="lw">使用框架修改器对齐视图</em></p></figure><p id="d738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe ng nh ni nj b">position(x:y:)</code>和<code class="fe ng nh ni nj b">offset(x:y:)</code>这样的其他修改器也可以用来在父对象的坐标空间中定位子对象。</p><p id="b004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以使用<code class="fe ng nh ni nj b">Spacer</code>来对齐视图。这是一个灵活的空间，只要有空间就会扩展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/3a0e4a308e605183e9b000434d3920e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*59E7wrW_BZIbEzDz.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="lw">使用“垫片”对齐视图</em></p></figure><p id="dc1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe ng nh ni nj b">Spacer</code>帮助我们将文本移动到父视图的右侧。</p><h2 id="69ae" class="mu ly it bd lz mv mw dn md mx my dp mh li mz na mj lm nb nc ml lq nd ne mn nf bi translated">视图修改器</h2><p id="6b04" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">视图的外观可以通过使用所谓的<em class="no">修改器来修改。SwiftUI提供的大多数修饰符都是不言自明的。我们已经在上面的例子中看到了其中的一些，比如<code class="fe ng nh ni nj b">font()</code>、<code class="fe ng nh ni nj b">background()</code>、<code class="fe ng nh ni nj b">padding()</code>等等。</em></p><p id="1da3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以创建我们自己的修改器，例如，如果我们想要重用样式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/3e8a8e6720ed09762e6cc9b82948fe2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8TtRnj4nSnev0VjL.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="lw">自定义视图修改器示例</em></p></figure><p id="0bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们定义了一个名为<code class="fe ng nh ni nj b">PrimaryButtonModifier</code>的自定义修饰符，我们现在可以用它来设计我们的按钮。如预览图所示，要将自定义修改器应用于视图，我们可以使用<code class="fe ng nh ni nj b">.modifier()</code>修改器。</p><h2 id="8e53" class="mu ly it bd lz mv mw dn md mx my dp mh li mz na mj lm nb nc ml lq nd ne mn nf bi translated">列表</h2><p id="ad93" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">创建视图列表是构建应用程序时的一项常见任务。在SwiftUI中使用<code class="fe ng nh ni nj b">List</code>视图非常简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/b634e5fa1a65b6e876663cb74046f624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-SEtl-yGg4mSc0m0.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="lw">“列表”视图示例</em></p></figure><p id="5fe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要将数据和ID传递到<code class="fe ng nh ni nj b">List</code>视图中，然后用这些数据配置行。</p><h2 id="e8c1" class="mu ly it bd lz mv mw dn md mx my dp mh li mz na mj lm nb nc ml lq nd ne mn nf bi translated">在视图间导航</h2><p id="a9eb" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">视图之间的导航是另一项常见任务，使用SwiftUI也很容易实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/1432392ce3f94d622942ceb826837a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Dw8cXfaaIEL906Yi.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="lw">导航视图示例</em></p></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="452e" class="lx ly it bd lz ma nz mc md me oa mg mh jz ob ka mj kc oc kd ml kf od kg mn mo bi translated">处理状态</h1><p id="3e9b" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">与UIKit相比，SwiftUI的一个重大变化是状态的处理方式。状态表示与视图相关联的数据。使用SwiftUI，当状态属性改变时，视图会自动更新。</p><p id="ec9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的视图，它显示了一些文本和一个文本字段。我们希望<code class="fe ng nh ni nj b">Text</code>视图总是显示来自<code class="fe ng nh ni nj b">TextField</code>视图的当前输入。</p><pre class="kj kk kl km gt oe nj of og aw oh bi"><span id="a4ca" class="mu ly it nj b gy oi oj l ok ol">struct ExampleView: View {</span><span id="398a" class="mu ly it nj b gy om oj l ok ol">    @State private var username: String = "" // 1</span><span id="5806" class="mu ly it nj b gy om oj l ok ol">    var body: some View {<br/>        VStack {<br/>            Text(username) // 2<br/>            TextField("username", text: $username) // 3<br/>        }<br/>        <br/>    }<br/>}</span></pre><p id="5a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一目标，我们:</p><ol class=""><li id="0021" class="on oo it lb b lc ld lf lg li op lm oq lq or lu os ot ou ov bi translated">创建一个名为<code class="fe ng nh ni nj b">username</code>的<code class="fe ng nh ni nj b">State</code>包装属性。</li><li id="19b3" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated">用这个属性初始化我们的<code class="fe ng nh ni nj b">Text</code>视图。从现在开始，每次<code class="fe ng nh ni nj b">username</code>发生变化，<code class="fe ng nh ni nj b">Text</code>视图都会自动更新。</li><li id="c0f0" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated">将<code class="fe ng nh ni nj b">username</code>属性绑定到文本字段。我们通过属性带有前缀<code class="fe ng nh ni nj b">$</code>的事实来识别绑定。从现在开始，每次文本字段的输入发生变化时，我们的<code class="fe ng nh ni nj b">username</code>属性也会更新。</li></ol><p id="1746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步中的绑定是可能的，因为<code class="fe ng nh ni nj b">TextField</code>的<code class="fe ng nh ni nj b">text</code>属性具有类型<code class="fe ng nh ni nj b">Binding&lt;String&gt;</code>。也就是说它内部包裹了<code class="fe ng nh ni nj b">Binding</code>。</p><p id="b7f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">Binding</code>和<code class="fe ng nh ni nj b">State</code>的区别在于<code class="fe ng nh ni nj b">State</code>用于视图的私有状态，而<code class="fe ng nh ni nj b">Binding</code>在视图和视图之外定义的状态属性之间创建双向连接。</p><h2 id="2e6e" class="mu ly it bd lz mv mw dn md mx my dp mh li mz na mj lm nb nc ml lq nd ne mn nf bi translated"><code class="fe ng nh ni nj b">'StateObject’</code>和<code class="fe ng nh ni nj b">'ObservedObject'</code></h2><p id="6b09" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当<code class="fe ng nh ni nj b">State</code>和<code class="fe ng nh ni nj b">Binding</code>用于值类型时，<code class="fe ng nh ni nj b">StateObject</code>和<code class="fe ng nh ni nj b">ObservedObject</code>可以用于引用类型。参考类型需要符合<code class="fe ng nh ni nj b">ObservableObject</code>。</p><p id="e4f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。</p><pre class="kj kk kl km gt oe nj of og aw oh bi"><span id="4efb" class="mu ly it nj b gy oi oj l ok ol">class User: ObservableObject { // 1<br/>    @Published var firstName: String = "" // 2<br/>    @Published var lastName: String = ""<br/>}</span><span id="5881" class="mu ly it nj b gy om oj l ok ol">struct ExampleView: View {<br/>    <br/>    @ObservedObject var user: User // 3<br/>    ...<br/>}</span></pre><p id="0af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了建立对象和视图之间的绑定，我们:</p><ol class=""><li id="e4fb" class="on oo it lb b lc ld lf lg li op lm oq lq or lu os ot ou ov bi translated">让<code class="fe ng nh ni nj b">User</code>对象符合<code class="fe ng nh ni nj b">ObservableObject</code>协议。</li><li id="4295" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated">使用<code class="fe ng nh ni nj b">@Published</code>修改时，包装应引起观察通知的属性。</li><li id="aea1" class="on oo it lb b lc ow lf ox li oy lm oz lq pa lu os ot ou ov bi translated">用<code class="fe ng nh ni nj b">StateObject</code>或<code class="fe ng nh ni nj b">@ObservedObject</code>包装我们视图中的<code class="fe ng nh ni nj b">user</code>属性。</li></ol><p id="4116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">StateObject</code>和<code class="fe ng nh ni nj b">ObservedObject</code>的区别与<code class="fe ng nh ni nj b">State</code>和<code class="fe ng nh ni nj b">Binding</code>的区别相同。当<code class="fe ng nh ni nj b">StateObject</code>用于视图的私有状态时，<code class="fe ng nh ni nj b">ObservedObject</code>在视图和视图之外定义的状态属性之间创建一个双向连接。视图不应该自己创建<code class="fe ng nh ni nj b">ObservedObject</code>的实例。</p><h2 id="1d90" class="mu ly it bd lz mv mw dn md mx my dp mh li mz na mj lm nb nc ml lq nd ne mn nf bi translated"><code class="fe ng nh ni nj b">'EnvironmentObject'</code></h2><p id="1449" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><code class="fe ng nh ni nj b">EnvironmentObject</code>在与<code class="fe ng nh ni nj b">ObservedObject</code>相同的情况下使用，不同之处在于我们不需要通过整个视图层次传递它。</p><p id="1360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于复杂的视图层次很有用，在到达需要它的视图之前，我们必须通过几个视图的初始化器传递<code class="fe ng nh ni nj b">ObservableObject</code>。使用<code class="fe ng nh ni nj b">EnvironmentObject</code>，我们只需要在一个视图的父视图中提供环境对象。SwiftUI会处理剩下的事情。</p><pre class="kj kk kl km gt oe nj of og aw oh bi"><span id="55c3" class="mu ly it nj b gy oi oj l ok ol">struct ExampleView: View {<br/>    @EnvironmentObject var user: User<br/>}</span><span id="03f2" class="mu ly it nj b gy om oj l ok ol">SomeParentViewOfExampleView()<br/>    .environmentObject(user)</span></pre><p id="6e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以通过将<code class="fe ng nh ni nj b">EnvironmentObject</code>传递到应用程序的根视图中，使其在整个应用程序中可用。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="03b9" class="lx ly it bd lz ma nz mc md me oa mg mh jz ob ka mj kc oc kd ml kf od kg mn mo bi translated">结合SwiftUI和UIKit</h1><p id="32b0" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在SwiftUI问世之前，UIKit是iOS中构建视图的方式。所以现在，当我们开始在现有项目中使用SwiftUI时，我们需要一种方法来结合这两个世界。好消息是，苹果提供了在SwiftUI视图中放置UIKit视图和视图控制器的工具，反之亦然。</p><h2 id="5b5e" class="mu ly it bd lz mv mw dn md mx my dp mh li mz na mj lm nb nc ml lq nd ne mn nf bi translated">在SwiftUI视图中使用UIKit视图</h2><p id="6bc4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为了在SwiftUI视图中使用UIKit视图，我们将UIKit视图包装在符合<code class="fe ng nh ni nj b">UIViewRepresentable</code>协议的SwiftUI视图中。</p><pre class="kj kk kl km gt oe nj of og aw oh bi"><span id="13c6" class="mu ly it nj b gy oi oj l ok ol">struct Label: UIViewRepresentable {<br/>    @Binding var title: String</span><span id="e72b" class="mu ly it nj b gy om oj l ok ol">    func makeUIView(context: Context) -&gt; UILabel {<br/>        let label = UILabel()<br/>        return label<br/>    }</span><span id="cb19" class="mu ly it nj b gy om oj l ok ol">    func updateUIView(_ label: UILabel, context: Context) {<br/>        label.text = title<br/>    }<br/>}</span></pre><p id="e895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实现<code class="fe ng nh ni nj b">UIViewRepresentable</code>协议时，我们需要实现两个方法<code class="fe ng nh ni nj b">makeUIView</code>和<code class="fe ng nh ni nj b">updateUIView</code>。在<code class="fe ng nh ni nj b">makeUIView</code>方法中，我们可以创建并返回我们的UIKit视图。每次有状态变化时，SwiftUI都会调用<code class="fe ng nh ni nj b">updateUIView</code>，因此我们可以手动更新UIKit视图。</p><p id="db15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI中，没有视图控制器的概念——一切都是视图。因此，我们可以使用与上面相同的方法在SwiftUI视图中使用UIKit视图控制器。只是这一次SwiftUI视图需要符合<code class="fe ng nh ni nj b">UIViewControllerRepresentable</code>协议，该协议具有与<code class="fe ng nh ni nj b">UIViewRepresentable</code>协议等效的方法。</p><h2 id="d839" class="mu ly it bd lz mv mw dn md mx my dp mh li mz na mj lm nb nc ml lq nd ne mn nf bi translated">在UIKit视图中使用SwiftUI视图</h2><p id="4e19" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为了在UIKit内部使用SwiftUI视图，Apple提供了一个名为<code class="fe ng nh ni nj b">UIHostingViewController</code>的类。我们简单地用SwiftUI视图初始化一个<code class="fe ng nh ni nj b">UIHostingController</code>，然后像使用标准视图控制器一样使用它。</p><pre class="kj kk kl km gt oe nj of og aw oh bi"><span id="c2da" class="mu ly it nj b gy oi oj l ok ol">let vc = UIHostingController(rootView: Text("Hi"))</span></pre></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="000f" class="lx ly it bd lz ma nz mc md me oa mg mh jz ob ka mj kc oc kd ml kf od kg mn mo bi translated">结论</h1><p id="20e8" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">就像当年Swift的引入一样，SwiftUI为iOS开发带来了一个全新的激动人心的世界。起初，这可能看起来势不可挡，但最终，SwiftUI通过利用Swift的全部功能，提供了一种构建用户界面的创新而简单的方法。</p></div></div>    
</body>
</html>