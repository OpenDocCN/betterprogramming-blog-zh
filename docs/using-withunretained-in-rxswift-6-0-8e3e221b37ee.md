# 使用 RxSwift 6.0 中的 withUnretained

> 原文：<https://betterprogramming.pub/using-withunretained-in-rxswift-6-0-8e3e221b37ee>

## 新功能导致新扩展的故事

![](img/118c58801bde651b50ab0e0102524acf.png)

通过 RxSwift GitHub 项目推出新的 RxSwift 6.0 徽标

(终于)新的一年到了，伴随着它，我们有了 RxSwift 的新版本。

6.0 版本带来了相当多的新功能和变化，但我今天想讨论的是`withUnretained`以及它如何解决——以及未能解决——我们 RxSwift 代码中最常见的问题之一。

# 虚弱的自我和保持循环

考虑以下代码:

订阅一个可观察对象并将结果交给一个类方法在 RxSwift 中是非常常见的事情。不幸的是，当在类实例内部使用时，它很容易保留循环，这就是为什么我们不断地在闭包中添加`[weak self]`并经常添加`guard`语句以确保我们的实例没有被释放。

就其本身而言，代码还不算太差。但是如果你添加了足够多的订阅处理程序，所有的`[weak self]`样板文件开始增加，它会模糊我们的意图，弄乱我们的代码。

社区 RxSwift 库， [RxSwiftExt](https://github.com/RxSwiftComunity/RxSwiftExt) ，有一个名为`withUnretained`的操作员负责这个案例。更重要的是，RxSwift 6.0 中现已提供该运算符。

让我们看看它是如何解决我们的一个问题的。

# 使用 withUnretained

这里，我们将`.withUnretained(self)`添加到我们的事件流中。这将我们的事件流从原始的单个值更改为一个元组，除了原始值之外，该元组还包含对 self 的有效引用。

注意，我说过我们正在获取一个有效的引用。事实上，传递的引用是*保证*有效。如果不是，并且引用已经超出范围，那么整个序列将会完成，我们的`onNext`处理程序将不会被调用。

仅此而已。现在所有的`[weak self]`样板文件都已经从我们的代码中移除，一切都变得更加清晰。

但是有一个条件——很明显，否则这篇文章就不算什么了！

# 错误处理

如果除了数据值之外，我们还需要处理错误或完成事件，那该怎么办？好吧，这样的话，我们又回到起点了。观察:

在我们的`onNext`处理程序中有一个对我们所有者的有效引用，但是我们的`onError`和`onCompleted`处理程序又回到了使用`[weak self]`的状态。为什么？

嗯，由于 RxSwift 中的`Event`枚举类型的性质，我们可以随意更改我们的`next`元素类型(`map`、`flatMap`等)。)，但`error`和`completed`事件有严格的现有定义:

因此，当事件发生时，根本没有办法使用事件将对我们所有者的引用传递到我们的订阅链。

因此`withUnretained`在这方面似乎没有什么价值，我们回到在错误和完成处理程序中使用`[weak self]`。

还是我们？

# 使用 Subscribe(带:)

让我们重申一下我们的问题:我们不能在我们的`error`和`completed`处理程序中使用我们的所有者，因为我们不能将对我们的所有者的引用传递给我们的订阅。

好...但是如果我们根本不用`withUnretained`呢？如果我们没有向下传递任何引用怎么办？如果我们抓住并维护我们在订阅本身中的弱引用会怎么样？

然后它将对我们所有的订阅关闭可用！

瞧吧。我给你`subscribe(with:)`:

这里，我们基本上将`withUnretained`功能直接嵌入到我们的订阅处理程序中。这让我们可以将对`self`的引用提供给我们的`onNext`、`onError`和`onCompleted`处理程序。

我认为去掉了`[weak self]`样板文件后，这段代码更加简洁。事实上，如果我们想使用未命名的参数，我们可以把它归结为:

其中`$0`是我们对自我的引用，而`$1`分别是我们的值或误差。我认为你不能做得比那更好了。

注意，就像`withUnretained`一样，如果我们的弱引用超出范围，我们的完成处理程序都不会被调用。当你认真对待它的时候，那是有意义的。我是说，如果我们的集装箱不见了，我们该找谁谈？

# Subscribe(带:)分机

不幸的是，`subscribe(with:)`不是 RxSwift 6.0 的一部分。幸运的是，作为我们自己的扩展之一，编写和添加到项目中是非常容易的:

这几乎就是你从我们之前的描述中所期待的。我们捕获对对象的弱引用，然后在将给定事件传递给任何处理程序之前检查它。如果引用是错误的，我们根本不调用处理程序。

对于那些仍在使用 RxSwift 5.1 的人来说，还要注意这个扩展是向后兼容的。

# 带未保留和平面图

您还可以将`withUnretained`与其他 RxSwift 运算符一起使用，以避免弱自保持循环问题:

在这里，`withUnretained`再次捕获 self 并确保后面的`flatMap`对其模型有一个有效的引用。

但是，请注意，如果您想要将`flatMaps`链接在一起，那么您将需要一个针对每一个的`withUnretained`语句。每个`flatMap`都直接返回它的可观察值，反过来，从流中删除模型元组。

一句话:虽然你可以这样做，但我不确定我会推荐你这样做。

# 奖励回合:属性绑定

RxSwift 6.0 中另一个很酷的特性是使用`@dynamicMemberLookup`自动合成属性绑定。

这意味着 RxSwift 6 将自动为其`.rx`类扩展之外的任何属性创建一个可绑定的引用。考虑一下这个:

这里，我们将来自我们的`viewModel`的一个可观察对象直接绑定到我们的`myString`属性。这种形式的`bind`堪比 Combine 的`assign`语句。

注意，这只适用于基于对象的类，如`UIViewControllers`、`UIViews`等。

# 完成块

今天就到这里吧。问题陈述并解决。

我要感谢来自 RxSwift Slack 频道的丹尼尔·塔尔塔利亚(danielt1263)。我提出了上述问题的`subscribe(with:)`解决方案，两分钟后，他带着一个潜在的实现回来了。我的有点不同，因为我也经常需要访问`onDisposed`处理程序，但功能上它们是相同的。

请注意，RxSwift 6.0 增加了许多其他很酷的新功能，你绝对应该看看[发布说明](https://github.com/ReactiveX/RxSwift/releases/tag/6.0.0)。毫无疑问，我将在以后的文章中介绍更多的新功能。

然而，一个缺点是，它是 RxSwift 5 的一个突破性变化——主要是在方法签名变化方面。像`.observeOn(...)`这样的事情现在变成了`observe(on: ...)`。

据我所知，没有重大的行为变化，所以请注意，如果您升级，您将需要花一点时间在您的项目中做一些全局搜索和替换工作。

下次见。