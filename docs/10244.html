<html>
<head>
<title>Architecting Distributed Systems: Usage of Random Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建分布式系统:随机数的使用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/architecting-distributed-systems-random-code-8db0cd9b87d1?source=collection_archive---------4-----------------------#2021-12-16">https://betterprogramming.pub/architecting-distributed-systems-random-code-8db0cd9b87d1?source=collection_archive---------4-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">随机数生成如何支持更健壮的分布式系统的开发</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe03e946a1831ee315943ce7b7d6e3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SOedECDX6NAPQIoJ.jpg"/></div></div></figure><p id="dfc6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不久前，我问了自己以下问题:“<em class="lq">我们的软件有多随机？</em>”。这导致了对从数据库和网络协议到基础设施和测试自动化的整个软件开发栈的解决方案的一个相当漫长而迷人的调查。在浏览了大量的文档并剖析了我过去参与的一些系统之后，我整理了一个在分布式系统中出于不同目的使用随机化的情况列表。其中一些用例非常明显，而另一些可能会让你大吃一惊。</p><p id="3309" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不打算给出诸如“掷骰子”或“选择一天中的随机引用”之类的明显用例的例子。相反，我们将探索随机数如何对常用的通用软件组件和库的功能做出贡献，以及为什么。</p><h1 id="6e69" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">💥重试策略</h1><p id="f31a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当执行某个<a class="ae mo" href="https://medium.com/geekculture/bulletproof-distributed-systems-how-to-fail-at-http-calls-e7f0b3240d19" rel="noopener">操作的初始尝试</a>失败时，比如调用另一个微服务，我们可能想要使用重试策略进行重试。重试时通常会使用以下一些策略:</p><ul class=""><li id="d4b9" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated"><strong class="kw iu">立即重试</strong>:失败后立即重试一次</li><li id="f274" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><strong class="kw iu">定期间隔</strong>:每3秒重试一次</li><li id="e15b" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><strong class="kw iu">线性回退</strong>:2、5、9、14秒后重试，依此类推</li><li id="e024" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><strong class="kw iu">指数回退</strong>:2、4、8、16秒后重试，依此类推</li></ul><p id="a458" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然根据系统需求，这些策略中的一个或组合非常有用，但简单地选择一个并在系统中的任何地方使用它可能会造成危害。</p><p id="1d0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，有几个实例向一个服务发出请求，这个服务在返回响应之前关闭了，关闭了所有活动的连接。指数回退策略开始生效，重试开始发生。然后，过了一会儿，服务最终重新启动，并被来自所有未能更早到达它的实例的请求淹没，所有这些同时发生，导致<strong class="kw iu">连接风暴</strong>和对新启动的应用程序的巨大压力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/6d57a103977ed5579858b49ab995d4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_mFLwPRljK81UQgoK6lkw.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">无随机化的指数退避策略</p></figure><p id="26f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在某些情况下，如果应用程序在启动时就收到大量请求的轰炸，它们可能会陷入无休止的崩溃和重启状态。这种风暴可以通过在重试间隔中添加一些随机化来防止，使它们在时间上分散开。在下面的例子中，说明了25%随机化的好处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/9faa2ccb2738d15308ddaac668fb75b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LpVY_UbIaAk04kBzFyMc3g.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">25%随机化的指数后退策略</p></figure><p id="87f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，Kafka将20%的随机化因子应用于他们的大多数政策，并结合默认的指数后退。你可以在他们的文档中读到。</p><h1 id="ae67" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">🤖基础设施</h1><p id="4a26" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">类似地，与测试一样，拥有可重复和可预测的基础设施变更有很大的优势。然而，即使在这里，网飞和亚马逊也发现了随机化的用例。</p><p id="593d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了确保工程师们开发出真正有弹性的软件，网飞开发并运行了<a class="ae mo" href="https://netflix.github.io/chaosmonkey/" rel="noopener ugc nofollow" target="_blank"> ChaosMonkey </a>:一种<strong class="kw iu">不时随机终止应用程序</strong>的工具。操作员可以配置终止之间的最短时间，以及终止之间的间隔，该工具将决定何时终止应用程序组的一个实例。</p><p id="1f22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当这样的工具在生产中使用时，工程师在设计他们的应用程序时被迫将<a class="ae mo" href="https://medium.com/geekculture/bulletproof-distributed-systems-how-to-fail-at-http-calls-e7f0b3240d19" rel="noopener">故障</a>考虑在内，因为它们<em class="lq">将</em>发生，而不仅仅是<em class="lq">可能</em>发生。近年来，在混沌工程学科中已经开发了大量类似的解决方案，显示了行业中不断增长的需求。</p><p id="e867" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外值得一提的是<strong class="kw iu">备份和维护窗口</strong>是随机的。通读<a class="ae mo" href="https://docs.aws.amazon.com/documentdb/latest/developerguide/db-instance-maintain.html#maintenance-window" rel="noopener ugc nofollow" target="_blank"> Amazon DocumentDB文档</a>，我发现他们会在每个地区更大的8小时维护窗口内随机选择一个30分钟的时间段，并执行必要的软件更新。同样的逻辑也适用于创建定期备份，在每个区域的8小时维护窗口内，以随机的30分钟间隔进行备份。</p><h1 id="1ddf" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">⚖️负载平衡</h1><p id="f81a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">通常，负载平衡器使用以下流行算法之一在组中的应用程序实例之间分配流量:</p><ul class=""><li id="61b8" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated"><strong class="kw iu">循环调度</strong>:计数器随着每个请求而递增，请求被路由到列表中的下一个实例</li><li id="916b" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><strong class="kw iu">最少连接数</strong>:打开连接数最少的实例获得请求</li><li id="4684" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><strong class="kw iu">基于资源的</strong>:利用率最低的实例(CPU、内存)获得请求</li><li id="9924" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">随机:一个随机选择的实例得到请求</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/346975cf9bd2968930c81644573b3ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xcMJ0IuAjtWr77LlJ4rrw.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">随机负载平衡器逻辑:通过实例数量来确定路由到哪里</p></figure><p id="137f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果应用程序组由具有相似资源配置(CPU、内存等)的实例组成。)，随机路由策略能够均匀有效地分发请求。这是最容易实现且开销最小的方法:循环算法需要一个共享的计数器，最少连接算法需要跟踪所有打开的连接，基于资源的策略需要在每个实例上运行一个代理来报告其利用率。</p><p id="49be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Kafka中可以观察到类似的行为，默认情况下，使用randomly将消息路由到主题分区，与所有其他可用策略相比，这导致了最均匀的分布。</p><h1 id="4940" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">🧪测试自动化</h1><p id="0ab4" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">通常，我们希望我们的自动化测试尽可能地可重复，以便最小化外部影响和减少剥落。当我们有一个有限的可能场景列表时，100%可重复的测试通常是首选的方式，并且它不会太长。然而，在一些更复杂的用例中，当可能的输入组合数量太大而无法手工覆盖时，生成一堆测试场景可以帮助更好地识别问题。例如，随机生成的测试可以用来识别<strong class="kw iu">竞争条件</strong>。</p><p id="2dab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当两个或多个进程试图同时修改相同的数据时，就会出现竞争情况，并且我们无法控制操作的执行顺序。假设我们正在开发一个协作绘图应用程序，10个用户几乎同时在画布上尝试给一个圆着色。该系统有一个简单的规则:<em class="lq">最后一次写操作赢得</em>，我们希望确保无论发生什么，所有10个用户最终都会观察到最后一次修改的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/f607b84a3f45d0194fbf9f78e9c519d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1eQtHkH0cyugL8H448X7A.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">多个用户同时修改同一资源—最后写入的用户胜出</p></figure><p id="d3ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">确保无论10个用户以何种顺序执行操作，最后一个用户总是获胜的方法之一是为每个输入案例编写场景。但是，它会导致10！= ~3.6M组合。</p><p id="d952" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不运行所有这些场景，可以随机生成1000–10000个可能的输入组合，并评估每个用户最终是否观察到预期的结果。虽然我们不会涵盖大约360万种可能的组合中的每一种，但几千次运行通常足以检测出可能的问题。</p><p id="d335" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，虽然生成的测试有助于检测有关竞争条件的问题，但它们有点像一把双刃剑，应该小心使用:运行数千个场景有时会产生不可靠的结果，并且根据运行这些测试所需的基础设施，最终会在资源和时间方面耗费大量资源。</p><h1 id="e9a7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">🤝共识协议</h1><p id="bef2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">共识协议用于确保两个或多个应用程序能够以容错方式就一个共同的值达成一致，这意味着只要大多数节点处于运行状态，群集就可以保持运行。Raft是一种流行的共识算法，广泛用于分布式系统中的领导者选举。领导者选举是大多数分布式系统的核心，包括Kafka、Riak和许多其他系统。</p><p id="0fe5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在5个节点的集群中，Raft允许集群中的节点使用投票机制选举一个领导者，结果正好是一个领导者和四个追随者。然后，领导者负责每隔几秒钟ping一次每个追随者节点，重置他们的选举超时。如果跟随者节点在选举超时内没有收到ping，它就认为领导者已经不在那里了。然后，它成为候选人，开始投票过程，并保持这种状态，直到选出新的领导人。</p><p id="b2b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果领导者崩溃，所有追随者节点同时超时，他们将同时成为候选人，并开始为自己投票，这使得很难选出一个领导者，因为所有节点都将为自己的权利而斗争。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/db97a9e7b9d5e740bd75ebbe35cf7594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9GyFWQftXX7qh0Q2nmmfA.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">多个追随者节点轮流成为候选人并同时开始选举</p></figure><p id="d9b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Raft <strong class="kw iu">将选举超时</strong>随机化，以减少多个节点同时成为候选节点的机会。相反，单个节点将超时，赢得选举，然后成为领导者，并在任何节点超时成为候选人之前开始win其他节点。</p><p id="4004" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更完整地解释Raft是如何工作的，我推荐观看<a class="ae mo" href="https://youtu.be/6xwMIYBp944" rel="noopener ugc nofollow" target="_blank">这个短视频</a>或者<a class="ae mo" href="https://raft.github.io/" rel="noopener ugc nofollow" target="_blank">查看他们的网站</a>。</p><h1 id="3078" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">摘要</h1><p id="c640" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们已经探讨了软件堆栈的不同部分如何在其功能核心利用随机数生成，或者提高其性能和可靠性。其中一些知识可以在编写软件时直接应用，例如重试策略，而其他的只是有趣地了解一下，除非你自己正在开发一个分布式共识协议。</p><p id="c55c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文有意忽略了密码学、惟一ID生成、数据库和蒙特卡罗模拟中的某些用例，只是因为它们非常广泛，需要专门的工作来解释。</p><p id="8fb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能有兴趣查看我在本系列中关于<a class="ae mo" href="https://medium.com/geekculture/bulletproof-distributed-systems-how-to-fail-at-http-calls-e7f0b3240d19" rel="noopener"> API故障</a>和<a class="ae mo" rel="noopener ugc nofollow" target="_blank" href="/architecting-distributed-systems-the-importance-of-idempotence-138722a6b88e">幂等性</a>的其他部分。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4228" class="nq ls it nm b gy nr ns l nt nu"><strong class="nm iu">Want to Connect With the Author?</strong></span><span id="47e7" class="nq ls it nm b gy nv ns l nt nu">Check out <a class="ae mo" href="https://konarskis.com/" rel="noopener ugc nofollow" target="_blank">konarskis.com</a>.</span></pre></div></div>    
</body>
</html>