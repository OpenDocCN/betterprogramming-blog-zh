<html>
<head>
<title>Even the Smallest Side Project Deserves Its K8s Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">即使是最小的边项目也配得上它的K8s集群</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/even-the-smallest-side-project-deserves-its-k8s-cluster-3fc6f8a65e13?source=collection_archive---------1-----------------------#2019-06-30">https://betterprogramming.pub/even-the-smallest-side-project-deserves-its-k8s-cluster-3fc6f8a65e13?source=collection_archive---------1-----------------------#2019-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/501e4e29bb4e8531c995955d601067d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBFGYik9_TE78TONWzm3Hw.png"/></div></div></figure><p id="aab7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一篇文章中，我详细介绍了为一个简单的附带项目设置CI/CD管道的步骤。这个设置中使用的主要组件是<a class="ae kz" href="https://gitlab.com" rel="noopener ugc nofollow" target="_blank"> GitLab </a>、<a class="ae kz" href="https://portainer.io" rel="noopener ugc nofollow" target="_blank"> Portainer </a>和一个单节点<a class="ae kz" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a> orchestrator。</p><p id="d306" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个CI/CD管道中执行了几个操作:</p><ul class=""><li id="f840" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">几个测试</li><li id="8b6e" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">构建新图像并上传到GitLab注册表中</li><li id="2e91" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">扫描图像以确保它没有cv，或者至少没有关键cv</li><li id="5bcc" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">通过Portainer webhook在群集上部署新图像</li></ul><p id="91c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以点击下面的链接了解所有的细节。</p><div class="lo lp gp gr lq lr"><a href="https://medium.com/better-programming/even-the-smallest-side-project-deserves-its-ci-cd-pipeline-281f80f39fdf" rel="noopener follow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd iu gy z fp lw fr fs lx fu fw is bi translated">即使最小的次要项目也值得拥有CI/CD管道</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">medium.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf jz lr"/></div></div></a></div><p id="4ab6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我非常喜欢Docker Swarm这是一个很好的解决方案，非常容易设置，并且具有强大的默认安全特性。但是当谈到今天的容器编排器时，Kubernetes是事实上的标准，所以我认为详述Kubernetes世界中的同类设置会很有趣。</p><p id="615b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该项目是一个简单的网站，列出了法国南部索菲亚安蒂波利斯地区的科技事件。这里没有什么特别的，只有一个很好的测试场地。</p><p id="2753" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将看到这个Docker Compose项目是如何设计的，因此它可以很容易地部署在Kubernetes上，并通过CI/CD管道进行更新。</p><h2 id="4c29" class="mg mh it bd mi mj mk dn ml mm mn dp mo km mp mq mr kq ms mt mu ku mv mw mx my bi translated">GitLab和Kubernetes</h2><p id="b312" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">第一步是建立一个小型Kubernetes集群。对于这个项目来说，一个节点就足够了，因为正如你所想象的，这不是一个关键的节点:)。这一步实际上很容易，因为几个月前，GitLab做出了一个决定性的举动，使得创建一个新的集群变得非常简单，<em class="ne">目前在GKE </em>上，或者将一个现有的集群，<em class="ne">不限于GKE </em>集成到GitLab存储库中。该功能可通过<em class="ne">操作&gt; Kubernetes </em>菜单获得。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/92031f67cbd8989705cbc90ae1862c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o02bTphuSR6gFHVytXjY9g.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">从GitLab界面集成K8s集群</p></figure><p id="a453" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个项目，我在GKE上设置了一个单节点Kubernetes集群，需要几分钟时间将集群部署到我们简单的web站点上。</p><h2 id="9831" class="mg mh it bd mi mj mk dn ml mm mn dp mo km mp mq mr kq ms mt mu ku mv mw mx my bi translated">从Docker Compose到Kubernetes资源</h2><p id="df51" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">在<em class="ne">甚至最小的项目</em>系列的第一篇文章中，我详细介绍了如何在Swarm上部署应用程序。它在Docker Compose格式中使用了以下规范。</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="3336" class="mg mh it np b gy nt nu l nv nw">// sophia.yaml<br/>version: '3.7'<br/>services:<br/>  www:<br/>    image: registry.gitlab.com/lucj/sophia.events<br/>    networks:<br/>      - proxy<br/>    deploy:<br/>      mode: replicated<br/>      replicas: 2<br/>      update_config:<br/>        parallelism: 1<br/>        delay: 10s<br/>      restart_policy:<br/>        condition: on-failure<br/><br/>networks:<br/>  proxy:<br/>    external: true</span></pre><p id="8c8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在一个集群上，它被部署为一个<strong class="kd iu">堆栈</strong>，命令如下:</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="a668" class="mg mh it np b gy nt nu l nv nw">$ docker stack deploy -c sophia.yaml</span></pre><p id="577c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于<strong class="kd iu">栈</strong>不是Kubernetes资源，上面的文件不能部署在我们的新集群上。在Kubernetes的世界中，我们需要创建部署和服务资源来部署我们的应用程序。</p><blockquote class="nx ny nz"><p id="e5bf" class="kb kc ne kd b ke kf kg kh ki kj kk kl oa kn ko kp ob kr ks kt oc kv kw kx ky im bi translated">注意:像Docker Enterprise这样的产品嵌入了自己的操作符和自定义资源，以使栈对象能够被Kubernetes理解。</p></blockquote><p id="b463" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用像<a class="ae kz" href="https://github.com/kubernetes/kompose" rel="noopener ugc nofollow" target="_blank"> Kompose </a>这样的工具将Docker Compose文件翻译成Kubernetes资源，但是对于我们这个简单的应用程序，手工翻译不成问题。</p><p id="86f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们首先定义一个部署资源。在这个示例中，我们指定了同一个Pod的两个副本(Kubernetes中最小的工作负载单元),因为只有一个基于您的应用程序映像的容器:</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="a354" class="mg mh it np b gy nt nu l nv nw">// deployment.yaml</span><span id="a332" class="mg mh it np b gy od nu l nv nw">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: sophia<br/>  labels:<br/>    app: sophia<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: sophia  <br/>  strategy:<br/>    type: RollingUpdate<br/>    rollingUpdate:<br/>      maxSurge: 1<br/>      maxUnavailable: 0<br/>  replicas: 2<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: sophia<br/>    spec:<br/>      containers:<br/>      - name: app<br/>        image: registry.gitlab.com/lucj/sophia.events</span></pre><blockquote class="nx ny nz"><p id="493a" class="kb kc ne kd b ke kf kg kh ki kj kk kl oa kn ko kp ob kr ks kt oc kv kw kx ky im bi translated">注意:策略键用于指定更新方式的附加配置。这与合成文件的<em class="it"> update_config </em>键相匹配。</p></blockquote><p id="527f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们定义服务资源来公开集群中由上述部署创建的pod。</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="31ef" class="mg mh it np b gy nt nu l nv nw">// service.yaml</span><span id="b8ea" class="mg mh it np b gy od nu l nv nw">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: sophia<br/>spec:<br/>  type: ClusterIP<br/>  ports:<br/>    - name: www<br/>      port: 80<br/>      targetPort: 80<br/>      protocol: TCP<br/>  selector:<br/>    app: sophia</span></pre><p id="5ff4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的应用程序的资源可以用通常的命令创建:</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="cfc7" class="mg mh it np b gy nt nu l nv nw">$ kubectl apply -f deployment.yaml<br/>$ kubectl apply -f service.yaml</span></pre><h2 id="269f" class="mg mh it bd mi mj mk dn ml mm mn dp mo km mp mq mr kq ms mt mu ku mv mw mx my bi translated">公开应用程序的入口</h2><p id="7ba4" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">为了向外界公开应用程序，我们将使用一个入口资源。它基本上是一种资源，定义了传入的请求应该如何路由到集群中运行的服务。在本例中，所有以域<em class="ne"> test.sophia.events </em>为目标的请求都将被转发到名为<em class="ne"> sophia — </em>的服务，从而公开网站。</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="6799" class="mg mh it np b gy nt nu l nv nw">// ingress.yaml</span><span id="0f10" class="mg mh it np b gy od nu l nv nw">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: sophia<br/>  annotations:<br/>    kubernetes.io/ingress.class: "nginx"<br/>spec:<br/>  rules:<br/>  - host: <strong class="np iu">test.sophia.events</strong><br/>    http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: sophia<br/>          servicePort: 80<br/>  tls:<br/>  - hosts:<br/>    - <strong class="np iu">test.sophia.events</strong><br/>    secretName: sophia-tls-cert</span></pre><blockquote class="nx ny nz"><p id="6232" class="kb kc ne kd b ke kf kg kh ki kj kk kl oa kn ko kp ob kr ks kt oc kv kw kx ky im bi translated">注意:入口资源也可以充当TLS终端，但我们不会在这里深入讨论细节。</p></blockquote><p id="83f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个资源是像Kubernetes中的其他资源一样创建的:</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="ca72" class="mg mh it np b gy nt nu l nv nw">$ kubectl apply -f ingress.yaml</span></pre><p id="d010" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单独创建入口资源不是很有用；我们需要运行一个入口控制器来使它工作。与Kubernetes中的几乎所有流程一样，这个在Pod中运行的流程是一个反向代理，使用集群上现有的入口资源进行配置。它侦听传入的请求，并根据其配置将每个请求转发给正确的内部服务。</p><p id="d59f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以按照官方文档的说明安装入口控制器:运行入口控制器Pod，然后创建服务以将其暴露给外部。</p><div class="lo lp gp gr lq lr"><a href="https://kubernetes.github.io/ingress-nginx/deploy/" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd iu gy z fp lw fr fs lx fu fw is bi translated">安装指南- NGINX入口控制器</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">在AWS中，我们使用弹性负载平衡器(ELB)来将NGINX入口控制器暴露在服务之后…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">kubernetes.github.io</p></div></div><div class="ma l"><div class="oe l mc md me ma mf jz lr"/></div></div></a></div><p id="4f9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果HELM服务器已经在集群中运行，也可以使用HELM — <em class="ne"> Kubernetes软件包管理器— </em>通过简单的命令安装入口控制器:</p><p id="54ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe of og oh np b">$ helm install nginx/nginx-ingress — version 0.3.0</code></p><blockquote class="nx ny nz"><p id="7a45" class="kb kc ne kd b ke kf kg kh ki kj kk kl oa kn ko kp ob kr ks kt oc kv kw kx ky im bi translated">注意:这里我们使用基于Nginx的入口控制器，我们也可以使用基于<a class="ae kz" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>或<a class="ae kz" href="https://traefik.io/" rel="noopener ugc nofollow" target="_blank"> Traefik </a>的入口控制器。</p></blockquote><p id="be26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个示例中，我们使用第一种方法来部署这个控制器，因为集群部署在云提供商上，所以我们使用负载平衡器服务类型来公开它。这将在GCP基础设施上创建一个外部负载平衡器，公开端口80和443，并将所有请求转发到集群中运行的入口控制器。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/daaa335e24a113b8e80ff40f11bb3db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_Dp9UXbbi2m9kuajXIr6g.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">负载平衡器类型的服务会触发在GCP创建负载平衡器</p></figure><p id="c1a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让每个以<em class="ne"> test.sophia.events </em>为目标的请求到达网站，应该更新该域的DNS条目，因此它围绕这个负载平衡器的IP旋转。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/ad8425625f5c5734bcee56489ac47568.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*stxWDbwIpG75gMvWafgiMg.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">请求的目标是公开入口控制器的负载平衡器服务</p></figure><p id="7ac2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们完了！部署、服务和入口资源是我们在集群中运行应用程序并使其对外部可用所需的全部资源。但是为了简化这个应用程序的整个生命周期，我们将看看如何以Kubernetes的方式对它进行打包。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="a976" class="mg mh it bd mi mj mk dn ml mm mn dp mo km mp mq mr kq ms mt mu ku mv mw mx my bi translated">带头盔的包装</h2><p id="f894" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">Kubernetes的包管理器Helm简化了复杂应用程序的打包、部署和升级。这是一个由<a class="ae kz" href="https://cncf.io" rel="noopener ugc nofollow" target="_blank"> CNCF </a>孵化的项目，在Kubernetes生态系统中被广泛使用。在这一部分中，我们将详细介绍如何使用这个工具来打包和更新我们的应用程序。</p><p id="935e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Helm包括helm客户端和helm服务器——名为<em class="ne"> tiller </em>。一旦下载了客户端，就需要一个简单的<em class="ne"> helm init </em>来将服务器组件运行到Pod中。</p><blockquote class="nx ny nz"><p id="4a14" class="kb kc ne kd b ke kf kg kh ki kj kk kl oa kn ko kp ob kr ks kt oc kv kw kx ky im bi translated">注意:helm服务器可以直接从Gitlab界面安装。其他组件，如入口控制器、Prometheus……可以在同一个界面上点击安装。</p></blockquote><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/987906492d64c10d06fd436388110b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNxDtq5F-9PL-lfIU7ifpg.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">GitLab接口使得在K8s中安装附加组件变得容易</p></figure><p id="8078" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦Helm设置完毕，我们就可以使用以下命令生成图表的框架——这就是Helm包的命名方式:</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="129e" class="mg mh it np b gy nt nu l nv nw">$ helm create k8s-chart</span></pre><p id="85a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将创建一个包含一些资源的文件夹，用于部署一个基于nginx的示例web服务器。</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="0d1e" class="mg mh it np b gy nt nu l nv nw">$ cd k8s-chart<br/>$ tree .<br/>.<br/>├── Chart.yaml<br/>├── charts<br/>├── templates<br/>│   ├── NOTES.txt<br/>│   ├── _helpers.tpl<br/>│   ├── deployment.yaml<br/>│   ├── ingress.yaml<br/>│   ├── service.yaml<br/>│   └── tests<br/>│       └── test-connection.yaml<br/>└── values.yaml</span><span id="c01e" class="mg mh it np b gy od nu l nv nw">3 directories, 8 files</span></pre><p id="b55a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们想要创建自己的图表，第一步是删除默认创建的资源，并用我们自己的<code class="fe of og oh np b"><em class="ne">deployment.yaml</em></code>、<code class="fe of og oh np b">service.yaml</code>、<em class="ne">、</em>和<code class="fe of og oh np b">ingress.yaml</code>替换它们。</p><p id="0287" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们更改YAML文件的内容，以便使一些字段更加动态。例如，我们可能不想在<code class="fe of og oh np b">deployment.yaml</code> <em class="ne">中硬编码所有内容。我们可以用下面的方式定义在容器中使用的图像:</em></p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="3b44" class="mg mh it np b gy nt nu l nv nw">// deployment.yaml</span><span id="dd7f" class="mg mh it np b gy od nu l nv nw">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: sophia<br/>  labels:<br/>    app: sophia<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: sophia  <br/>  strategy:<br/>    type: RollingUpdate<br/>    rollingUpdate:<br/>      maxSurge: 1<br/>      maxUnavailable: 0<br/>  replicas: 2<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: sophia<br/>    spec:<br/>      containers:<br/>      - name: app<br/>        <strong class="np iu">image: {{ .Values.image.registry }}/{{ .Values.image.repository }}:{{ .Values.image.tag }}</strong><br/>        ports:<br/>        - containerPort: 80</span></pre><p id="2c12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这同样适用于<code class="fe of og oh np b">service.yaml</code>文件，在这里我们可以<em class="ne">临时化</em>一些字段，就像服务的<code class="fe of og oh np b">type</code>一样——我们有时可能需要一个节点端口而不是集群IP——以及它公开的<code class="fe of og oh np b">port</code>。</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="aeb4" class="mg mh it np b gy nt nu l nv nw">// service.yaml</span><span id="7c8a" class="mg mh it np b gy od nu l nv nw">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: sophia<br/>spec:<br/>  type: {{ .Values.service.type }}<br/>  ports:<br/>    - name: www<br/>      port: {{ .Values.service.port }}<br/>      targetPort: 80<br/>      protocol: TCP<br/>  selector:<br/>    app: sophia</span></pre><p id="37e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以对入口资源使用相同的方法，并更改主机键的值，主机键是根据特定域名路由请求的键。</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="4020" class="mg mh it np b gy nt nu l nv nw">// ingress.yaml</span><span id="19f3" class="mg mh it np b gy od nu l nv nw">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: sophia<br/>  annotations:<br/>    kubernetes.io/ingress.class: "nginx"<br/>spec:<br/>  rules:<br/>  - <strong class="np iu">host: {{ .Values.domain }}</strong><br/>    http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: sophia<br/>          servicePort: 80<br/>  tls:<br/>  - hosts:<br/>    - <strong class="np iu">{{ .Values.domain }}</strong><br/>    secretName: sophia-tls-cert</span></pre><p id="e8fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe of og oh np b">{{ .Values.xxx }}</code>语法表示这些值是从位于<em class="ne"> k8s-chart </em>文件夹根目录下的<code class="fe of og oh np b">values.yaml</code>文件中读取的。</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="8e52" class="mg mh it np b gy nt nu l nv nw">// Definition of our own values.yaml</span><span id="2743" class="mg mh it np b gy od nu l nv nw">domain: test.sophia.events<br/><br/>image:<br/>  registry: registry.gitlab.com/lucj<br/>  repository: sophia.events<br/>  tag: latest<br/>  pullPolicy: Always<br/><br/>service:<br/>  type: ClusterIP<br/>  port: 80</span></pre><blockquote class="nx ny nz"><p id="6960" class="kb kc ne kd b ke kf kg kh ki kj kk kl oa kn ko kp ob kr ks kt oc kv kw kx ky im bi translated">注意:也可以从Chart.yaml文件中检索值，该文件也位于文件夹的根目录下，包含项目的元数据。</p></blockquote><p id="946f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总而言之，为了将我们的应用程序打包到一个舵图中，我们可以遵循以下步骤:</p><ul class=""><li id="4b99" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">创建图表框架</li><li id="b282" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">从模板文件夹中删除默认资源</li><li id="c88c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">将我们自己的资源复制到模板文件夹中</li><li id="be57" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">确定不应该硬编码的字段，并使用模板符号定义它们</li><li id="d03c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">在<code class="fe of og oh np b">values.yaml</code>文件中设置这些字段的值</li></ul><p id="0952" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们定义了所有资源，就可以使用以下命令创建图表:</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="789d" class="mg mh it np b gy nt nu l nv nw">$ helm install -f values.yaml -n sophia .</span></pre><p id="1066" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们可以确保图表及其包含的资源是正确创建的:</p><pre class="ng nh ni nj gt no np nq nr aw ns bi"><span id="5b8d" class="mg mh it np b gy nt nu l nv nw"><strong class="np iu">$ helm list<br/></strong>NAME   REV UPDATED     STATUS   CHART        APP VERSION NAMESPACE<br/>sophia 1   30/06 11:58 DEPLOYED sophia-0.1.0 1.0         default</span><span id="cfc0" class="mg mh it np b gy od nu l nv nw"><strong class="np iu">$ kubectl get deploy,po,svc,ingress</strong><br/>NAME                           READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.extensions/sophia   2/2     2            2           34s</span><span id="24c7" class="mg mh it np b gy od nu l nv nw">NAME                          READY   STATUS    RESTARTS   AGE<br/>pod/sophia-575d8486cf-bj6vj   1/1     Running   0          34s<br/>pod/sophia-575d8486cf-tz6z8   1/1     Running   0          34s</span><span id="a4dc" class="mg mh it np b gy od nu l nv nw">NAME               TYPE      CLUSTER-IP   EXTERNAL-IP PORT(S)   AGE<br/>service/kubernetes ClusterIP 10.245.0.1   &lt;none&gt;      443/TCP   26h<br/>service/sophia     ClusterIP 10.245.58.76 &lt;none&gt;      80/TCP    34s</span><span id="dd6c" class="mg mh it np b gy od nu l nv nw">NAME                       HOSTS              ADDRESS PORTS     AGE<br/>ingress.extensions/sophia  test.sophia.events         80, 443   34s</span></pre><p id="d90a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在将了解如何在CI/CD管道中自动升级。</p><h2 id="a3f7" class="mg mh it bd mi mj mk dn ml mm mn dp mo km mp mq mr kq ms mt mu ku mv mw mx my bi translated">管道中的部署步骤</h2><p id="3baf" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">在GitLab CI文件中，我们将添加一个将在<strong class="kd iu">部署</strong>阶段触发的额外步骤。它基本上连接到与存储库相关联的Kubernetes集群，并使用<em class="ne"> helm </em>用在<strong class="kd iu">构建</strong>阶段创建的新图像更新图表。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="35c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们更详细地描述一下这个步骤:</p><ul class=""><li id="b06d" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">L4:定义用于此步骤的图像。在下面的<em class="ne">脚本</em>键下执行的所有命令都将在一个从这个映像创建的容器中运行，其中嵌入了我们需要的两个工具:<em class="ne"> kubectl </em>和<em class="ne"> helm </em>客户端</li><li id="a463" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">l5–8:创建<code class="fe of og oh np b">kube config</code>上下文，helm客户端将使用该上下文与Kubernetes API服务器进行通信。GitLab通过环境变量自动提供创建这个上下文所需的信息:API服务器的URL、集群的CA、认证用户的令牌</li><li id="904d" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">L9:将新创建的上下文设置为当前上下文</li><li id="eaad" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">L10:使用<em class="ne"> helm </em>客户端升级应用程序。<code class="fe of og oh np b"><em class="ne">-- reuse-values</em></code>标志表示图表当前使用的所有值(在<code class="fe of og oh np b">values.yaml</code>文件中指定的值)需要保持原样。<code class="fe of og oh np b"> -<em class="ne">- set image.tag</em></code>指令用于用图像的最后一个标签更新路径<code class="fe of og oh np b">image.tag</code> <em class="ne"> </em>引用的值。<code class="fe of og oh np b"><em class="ne">$CI_BUILD_REF</em></code>是Gitlab提供的一个环境变量，它包含git提交散列，这是一个在构建步骤中用来标记当前图像的值。</li></ul><p id="28fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在当前的设置中，每次在<em class="ne"> events.json </em>文件中创建一个新事件时，都会执行几个操作，其中包括:触发管道、构建新的映像，以及自动更新部署在Kubernetes上的应用程序。</p><p id="4f71" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想仔细看看，可以在下面的存储库中找到整个项目:<a class="ae kz" href="https://gitlab.com/lucj/sophia.events" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/lucj/sophia.events</a>。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="b7b3" class="mg mh it bd mi mj mk dn ml mm mn dp mo km mp mq mr kq ms mt mu ku mv mw mx my bi translated">摘要</h2><p id="736e" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">显然还有其他方法来设置CI/CD和其他可用的有用工具。但是正如我们在这个例子中看到的，这个设置非常简单，允许我们测试和演示一些非常酷的东西，这些东西可以用在更雄心勃勃的项目上。</p></div></div>    
</body>
</html>