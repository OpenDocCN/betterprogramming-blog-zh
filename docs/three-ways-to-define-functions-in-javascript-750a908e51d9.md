# JavaScript 中定义函数的三种方法

> 原文：<https://betterprogramming.pub/three-ways-to-define-functions-in-javascript-750a908e51d9>

## 定义编程中的一个关键组件

![](img/4158d53d50ee630fdbf8ff76105746a6.png)

照片由[卢卡·布拉沃](https://unsplash.com/@lucabravo?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/search/photos/functions?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄

函数是编程的关键组成部分之一。它们被定义为执行特定的任务，并且可以被反复调用来执行。javascript 中的函数与其他编程语言的主要区别在于，Javascript 中的函数是一级对象，这意味着它们的行为类似于对象，可以被赋给变量、数组和其他对象。

这篇文章讨论了定义函数的三种不同方法:

1.  函数声明
2.  函数表达式
3.  发电机功能

# 1.函数声明

这可能是声明函数最常见的方式。让我们看看它的语法:

函数声明的语法

函数声明由关键字`function` 组成，后跟函数的强制名称，然后是一对括号内的参数(也可以定义不带参数的函数)。最后，在一对花括号内是函数体，它执行一个实际的任务。

*知道函数*的形参和实参之间的区别很重要。定义函数时，参数是一个变量。当调用一个函数时，实参是传递给函数形参的实际数据。

首先，让我们看一个简单的例子:

一个名为`hello`的函数用一个参数`name`声明，它在控制台中记录一条消息。正如您在示例中看到的，由于参数中没有指定类型，因此它对 string 和 number 都有效。但是如果我只想让我的函数问候一个名字，而不是一个数字呢？遗憾的是，在 Javascript 中没有预建的方法来实现这一点，所以我们必须手动检查函数中传递的参数类型，如下所示:

*默认情况下，函数返回未定义。若要返回任何其他值，函数必须有一个指定要返回值的 return 语句。*

*函数声明中的**`Hoisting`*是什么？**

*简单地说，这意味着当代码被执行时，无论你在哪里声明函数或变量，它们都被移动到它们作用域的顶部。这就是所谓的吊装。*

*让我们来看一个例子:*

*函数声明中的提升*

*在这里，我在声明之前就调用了这个函数，这就是提升。*

# *2.函数表达式*

*函数表达式与函数语句非常相似，语法也几乎相同。主要区别在于，函数表达式不是以关键字`function`开始，函数的`name`也是可选的，在这种情况下，它变成了一个*匿名函数*。如果函数有一个`name`，那么它被称为*命名函数表达式* **。***

*函数表达式示例*

*现在让我们看看定义上述函数的匿名方式。*

*匿名函数表达式*

**函数声明和函数表达式的一个重要区别在于，函数表达式中没有提升。如果你尝试与提升函数声明中相同的程序，你会遇到一个错误。**

*函数表达式中没有提升*

## ***life(立即调用函数表达式)***

*这意味着函数一定义就运行，这里函数表达式被包含在*分组运算符()*中。*

*为什么我们在典型的函数表达式中需要生命？我们定义了函数，然后在以后的某个时候调用它任意次，但是如果我只想调用函数一次来产生一个输出，就这样——我不想再使用它了，该怎么办呢？这是生命出现的地方。它会被立即执行，并且以后再也不会被程序访问。因为它不会被再次调用，所以它不需要名字，所以对于 IIFE 来说，匿名函数表达式是首选的。*

# *3.发电机功能*

*正常功能遵循*运行至完成*模型，在执行最后一行之前不能停止。如果你想在执行过程中退出，你必须返回或者抛出一个错误。*

**发电机功能可以在执行中途停止。当它被回调时，它从停止的地方继续。**

*它像一个普通的函数一样被声明，但是不同的是生成器函数在关键字`function`后面有一个星号*，并且在它们之间可以包含任意数量的空格。*

*还有一点需要注意:在 JavaScript 中，生成器是一个函数，它返回一个你可以调用`next()`的对象。每次调用`next()`都会返回一个结构如下的对象:*

*现在，这个对象有两个属性:`value`和`done`。`Value`是对象的实际值，而`done`是指定函数终止的属性——默认值为 false，当它变为 true 时，函数停止。*

*让我们用一个简单的例子来更好地理解它:*

*在函数体内，我们不使用 return 关键字—而是使用`yeild`，如果使用了`return`，它会将属性`done`更改为`true`，函数将结束—它之后的任何内容都不会执行。`Yield`给出赋予它的值。*

*首先，我们定义我们的函数，然后我们调用它，调用一个生成器函数产生一个生成器对象，它存储在变量 gen 中。*

*然后我们使用`next()`和`value`属性调用对象，*

*第一次使用`next()`时，功能开始执行。首先，它运行 console.log(“第一个执行”)并将其记录在控制台中，然后它遇到`yield` —产生值“暂停”，执行停止。*

*第二次调用`next()`时，它从上次离开的地方开始。同样，它首先运行`console.log()`，然后遇到`yield`，产生值“函数结束”，然后函数停止。*

*第三次调用`next()`时，结果显示为未定义。发生这种情况是因为从生成器函数生成的对象只能迭代一次——该对象现在没有用了，必须生成一个新对象，程序才能重新启动。*

**如果我使用* `*return*` *而不是* `*yield*` *，数据的值会更改为* `*true*` *，之后不会执行任何操作。**

*生成器与 Promises 结合使用时，是异步编程的一个非常强大的工具。他们减轻，如果不是完全消除，回调的问题。*

# *结论:哪种方式更好？*

*嗯，我们不能比较它们，说一个比另一个好——声明的类型取决于情况或条件。*

*您可以使用生成器函数来获得更好的异步功能，并对想要立即执行的函数使用匿名函数表达式。*

# *参考*

*[Mozilla Docs](https://developer.mozilla.org/en-US/)*