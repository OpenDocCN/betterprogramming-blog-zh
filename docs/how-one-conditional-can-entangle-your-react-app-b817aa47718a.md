# 一个条件如何让你的 React 应用纠结

> 原文：<https://betterprogramming.pub/how-one-conditional-can-entangle-your-react-app-b817aa47718a>

## *一个警示性的探索:缺乏有目的的写作会如何影响你的 React 项目*

![](img/22eb8f295de62f8b9513aa8416cc84fa.png)

[Jac Alexandru](https://unsplash.com/@rolls0ut?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在软件工程中，甚至一个应用程序代码中的一个字符都可能改变解释计算机的语义，这一点也许是显而易见的。

然而，随着时间的推移，一个简单的表达式，一个简单的条件，可能会影响 React 应用程序的设计模式和架构，这一点可能不太明显。

然而，我的团队已经直接经历了这样一个看似无关紧要的实现选择的痛苦后果。仔细想想，这一切都是可以避免的。

对于那些不熟悉我的文章的人，我喜欢指导新开发人员。我倾向于写一些关于我和我的团队或者我指导的新开发人员遇到的真实场景的文章。

在这种情况下，一个简单的条件表达式导致 UI 逻辑的复杂纠缠，变得难以推理，更难以维护和扩展，并最终影响整个应用程序。

希望通过阅读这个特殊的经历，你可以在将来的项目中避免这种情况。

为了充分理解这样一个复杂问题的简单起源，我们必须首先建立一个类似于**清单 1** 的基本组件，其中我们创建一个简单的用户输入表单来满足在应用程序中创建“联系人”的任务。

在这个上下文中，联系人只是一个包含`name`、`email`和`phoneNumber`属性的对象。以下是显示这些属性的一些代码:

清单 1 —简单用户输入表单的基本示例。

如您所见，这段代码相当简单。从我的角度来看，这里没有危险信号或担忧。

此外，没有理由怀疑我们应该基于这个看似无关紧要的用例进行全面的架构讨论。

因此，我们发布了这段代码，并获得了成功。使用它的客户很高兴，因为它最终改善了他们的生活。然后我们转移到其他优先的项目上。

然而，好心没好报。

此后不久，我们遇到了客户希望完成的另一个非常相似的用例。在这个新场景中，最终用户现在需要创建一个“潜在客户”

因为它太相似了，设计师回收了他以前的设计，并做了细微的改动。同样，知道我们之前已经构建了一个类似的组件，我们假设理论上的工作量应该是最小的。

所以，我们把它滑入了一个已经紧张的冲刺阶段，充满了故事点和迫在眉睫的最后期限。

最终，我们重用了之前的组件。为什么要重做工作，对吗？让我们保持代码干燥(不要重复自己)，不要从头开始重新构建一个新的组件，当这个组件具有大部分相同的结构和风格时——特别是因为我们没有很多时间花在这个特定的任务上。

为了捕捉差异，我们添加了一个“上下文标志”，如清单 2 中的**所示，以区分该组件何时呈现在“前景”上下文中。代码如下所示:**

清单 2 —更新了组件，在“prospect”页面上呈现时略有不同。

如您所见，`isProspect`的“上下文标志”在第 20 行实现，并在第 31 行引用，以便在“前景”上下文中呈现该组件时有条件地呈现新特性。

当我回顾这份公关的时候，我脑海中的某个角落一直萦绕着我。有些事情感觉不对劲，但我说不上来。我的潜意识漫游到一个关于组成的官方反应文件的记忆。

知道我们必须重构它的时间有多短，我批准了 PR，但仍然留下了一些关于合成的评论。毕竟，它只是一个单一的条件表达式——这能有多糟糕呢？

[](https://reactjs.org/docs/composition-vs-inheritance.html#gatsby-focus-wrapper) [## 组合与继承—反应

### React 有一个强大的组合模型，我们建议使用组合而不是继承来重用代码…

reactjs.org](https://reactjs.org/docs/composition-vs-inheritance.html#gatsby-focus-wrapper) 

巧合的是，在新代码发布后不久，我发现了 React 播客的一个精彩片段，其中的 [Jenn Creighton](https://medium.com/u/a6994650d589?source=post_page-----b817aa47718a--------------------------------) 围绕着同样的主题。我记得和我的团队讨论过这个问题，作为我留下的关于构图的评论是合理的证据。这是一篇很棒的讨论文章，如果你有时间，我强烈推荐这一集。

如果你没有时间听，播客的主旨是 React 项目中有意的架构和组成。她描述了好的合成如何利用 React 的声明式 API 来执行“显示不告诉”策略。

然而，许多工程师所做的却是实现无数必要的道具，她亲切地称这种策略为“末日”，从长远来看，这可能会导致一些难以置信的痛苦。

不幸的是，尽管围绕这个话题进行了很好的讨论，但“上下文标志”代码仍然存在于我们科技债务分类账的负债栏中。

我们根本没有时间回头去看，我们的客户对此没有任何抱怨。此外，由于它是如此小的一段代码，我们不想过度设计任何东西。在这种情况下讨论构图时，许多人争论 YAGNI(你不会需要它)原则。

然而，许多工程包括复制已建立的模式(不管是好是坏)。

一旦你在应用程序中建立了一个上下文标志，它就会像一个坏主意一样在整个代码库中不断扩散。电影《盗梦空间》提供了一个令人难以置信的观点:

> “想法就像病毒。有弹性。传染性极强。甚至一个想法的最小的种子也能成长。它可以定义你，也可以毁灭你。”—盗梦空间

在这个特定的组件中建立了单独的条件之后，随着时间的推移，逻辑最终被其他开发人员扩展了(尤其是那些没有参与我们的合成讨论的开发人员)。这导致了类似于下面的清单 3 中的场景:

清单 3——其他开发人员扩展了组件以处理更多用例。

甚至这可能是最终蛛网化成的淡化版本。当我看到这一切的时候，我所能想到的就是，“呀！”我认为重用这个组件的方法有着诚实的意图。

然而，如果没有一个可靠的组成或架构计划，最终的结果是一个可以在许多不同的上下文中使用的组件，但最终是非常脆弱的，而且肯定不灵活。

每当这个组件的公共元素需要在新的上下文中重新应用时，就必须添加额外的术语和条件语句。

`handleSubmit`方法要求将业务逻辑添加到组件中，以根据不同上下文标志的值来确定应该应用什么功能。

此外，`className`最终是基于这些上下文标志有条件地确定的，因此组件的风格可以在不同的上下文中改变。

![](img/e20a97713ec922f19e246de362a15d95.png)

照片由[托马斯·帕克](https://unsplash.com/@thomascpark?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

这个例子似乎很孤立于一个只需要重构的组件。然而，当这些上下文标志开始被引入业务逻辑时(如清单 3 中**的`handleSubmit`函数的情况)，它们最终也会悄悄进入状态管理和服务。这最终会导致一个完全纠缠在一起的应用程序，很难解开。**

# 回顾的

在对这个特定场景进行了一次非常有成效的回顾之后，我的团队认识到可重用性并不意味着单个组件应该处理所有上下文中的所有事情。

相反，如果您看到的设计在组件之间有相似的风格和结构，那么它们的相似之处应该被抽象成一个公共组件，可以用来组成新的组件。

有几种不同的方法来抽象组件，但是我们倾向于坚持 React 文档中的主要建议并使用子组件。

**清单 4** 展示了我们如何使用子元素重构前面清单中的代码，使其更具可组合性。代码如下:

清单 4 —一个新的、更加可组合的组件

既然已经抽象出了这些不同上下文的公共元素，我们就可以组成新的组件，这些组件可以实现它们自己独特的风格、结构和逻辑。这可以防止应用程序的其余部分陷入混乱，并依赖于这些不同上下文之间的共同点。

**清单 5** 展示了两个新组件，它们使用`UserForm`组件来实现特定上下文的必要需求，而不必重新实现它们共有的样式和结构。代码如下:

清单 5 —由用户表单组件组成的新组件

如您所见，`createProspect`上下文只需要关心新的`referredBy`属性，而`createTeamMember`上下文不关心这个。同时，`createTeamMember`只需要担心它自己独特的同步和提交逻辑，以及它对`role`属性的依赖。这种重构后的代码现在同样可重用，但是更加灵活和可扩展。

# 结论

我的团队现在认为“上下文标志”是一种[代码气味](/5-code-smells-react-beginners-should-avoid-480c97799162)。如果我们碰巧在 PR 中看到上下文标志，我们一定要深入讨论，以确保上下文标志是合理的。

否则，我们作为一个团队后退一步，尝试思考如何更好地抽象和重新构建组件，以使我们的代码更具可组合性。

希望您现在能够明白为什么始终保持代码尽可能可组合是如此重要。就像我们从艰难的道路中学到的，一旦一个设计模式——像这个单一的、简单的条件——被引入代码库，它很可能在未来被复制。没有人愿意使用会导致混乱的代码的设计模式。

React 是一个很棒的框架，具有声明式 API 和强大的可组合性功能，如果充分利用，从长远来看，可以避免前端应用程序中的许多问题。