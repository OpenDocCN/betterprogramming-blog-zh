<html>
<head>
<title>Big-O Notation: A Simple Explanation with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Big-O符号:简单的解释和例子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/big-o-notation-a-simple-explanation-with-examples-a56347d1daca?source=collection_archive---------0-----------------------#2020-01-13">https://betterprogramming.pub/big-o-notation-a-simple-explanation-with-examples-a56347d1daca?source=collection_archive---------0-----------------------#2020-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ce03" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">它可能会令人生畏，但不需要如此</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/78e1547145fa6af202447b52f041d4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NCP1Ee25E2K-gyfGkoStPQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">柴坦尼亚电视台在<a class="ae kv" href="https://unsplash.com/s/photos/circle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="1c72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为前端工程的讲师，当谈到大O符号时，我经常会遇到初级开发人员提出的一个问题:</p><blockquote class="ls lt lu"><p id="ab6c" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">“不知道这些事，做工程师就混不下去吗？尤其是一个前端工程师？”</p></blockquote><p id="e3a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然——没有什么能阻止任何人强行找到解决方案。</p><blockquote class="ls lt lu"><p id="30b6" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">“但让它发挥作用难道不是最重要的事情吗？”</p></blockquote><p id="dcae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很公平。工作是第一步(有时也是唯一的一步)，这取决于数据集的大小或你发货的最后期限。</p><p id="d2e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当你从处理10万个元素到处理1亿个元素时会发生什么呢？还是100亿？谈到可伸缩性，这些事情很重要。</p><p id="2cfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，你可以在不知道大O符号的来龙去脉的情况下编写代码。但是如果你不知道大O是什么，你就很难判断它是否是你在创建算法时应该考虑的东西。在我看来，忽视可以帮助你做出决策和编写更好代码的计算机科学基础知识，往好里说是愚蠢的，往坏里说是灾难性的。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="48bc" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">那么，什么是大O呢？</h1><p id="0898" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">大O符号是我们用来谈论一个算法运行多长时间(时间复杂度)或者一个算法使用多少内存(空间复杂度)的语言。大O符号可以表示算法的最佳、最差和平均运行时间。出于我们的目的，我们将主要关注Big-O，因为它与时间复杂性有关。</p><p id="52c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名软件工程师，你会发现大多数关于big O的讨论都集中在算法的上限运行时间上，这通常被称为最坏情况。需要注意的重要一点是，使用大O符号时的运行时间并不直接等同于我们所知道的时间(例如秒、毫秒、微秒等)。)运行时间的分析没有考虑某些因素，例如处理器、语言或运行时环境。相反，我们可以认为时间是完成一个大小为<em class="lv"> n </em>的问题所需要的操作或步骤的数量。换句话说，大O符号是一种跟踪运行时相对于输入大小增长速度的方法。</p><p id="bc90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们考虑最坏的情况时，问题变成了:对于大小为<em class="lv"> n </em>的输入，<em class="lv">可能发生的</em>最多<em class="lv">个操作/步骤是什么？</em></p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="5ad9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">O(1) →常数时间</h1><p id="a9fb" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><code class="fe nd ne nf ng b">O(1)</code>表示运行一个算法需要恒定的时间，与输入的大小无关。</p><p id="3347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">书签是一个很好的例子，说明恒定时间在现实世界中是如何进行的。书签允许读者以快速有效的方式找到您阅读的最后一页。不管你读的是30页的书还是1000页的书。只要你使用书签，一步就能找到最后一页。</p><p id="7285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程中，很多操作都是常量。以下是一些例子:</p><ul class=""><li id="4736" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">数学运算</li><li id="7e04" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">通过索引访问数组</li><li id="503b" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">通过密钥访问散列</li><li id="c67e" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">在堆栈上推动和弹出</li><li id="9744" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">从队列中插入和删除</li><li id="9593" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">从函数中返回值</li></ul><p id="f99a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看下面列出的<code class="fe nd ne nf ng b">findFirstIndex</code>、<strong class="ky ir">、</strong>。当访问<code class="fe nd ne nf ng b">0</code>索引时，传递<code class="fe nd ne nf ng b">smallCollection</code>或<code class="fe nd ne nf ng b">giganticCollection</code> <strong class="ky ir"> </strong>将产生与<code class="fe nd ne nf ng b">O(1)</code>相同的运行时间。<code class="fe nd ne nf ng b">firstIndex</code>的返回也是恒时操作。不管<em class="lv"> n的大小如何，</em>这两个操作都将花费恒定的时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/f91e8fac07aa60d545aae0e1f1f4b0a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPdouY69dluJoEa5bDZp0g.png"/></div></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="8036" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">O(n) →线性时间</h1><p id="e7b9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><code class="fe nd ne nf ng b">O(n)</code>表示运行时间与输入同步增长。</p><p id="833a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阅读一本书的行为是线性时间如何在现实世界中发挥作用的一个例子。让我们假设我只需要一分钟就可以读完一本大型印刷书籍的一页。有鉴于此，一本30页的书会花我30分钟去阅读。同样，一本1000页的书相当于1000分钟的阅读时间。现在，我不会强迫自己读完不太好的书，所以总有可能读不完那本1000页的书。但是，在我开始阅读之前，我可以知道，对于一本1000页的书，我最差的阅读时间是1000分钟。</p><p id="ed88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程中，最常见的线性时间操作之一是遍历数组。在JavaScript中，像<code class="fe nd ne nf ng b">forEach</code>、<code class="fe nd ne nf ng b">map</code>和<code class="fe nd ne nf ng b">reduce</code> <strong class="ky ir"> </strong>这样的方法贯穿整个数据集合，从开始到结束。</p><p id="8933" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看下面我们的<code class="fe nd ne nf ng b">printAllValues</code>函数。循环通过<em class="lv"> n </em>所需的运算次数与<em class="lv"> n </em>的大小直接相关。一般来说(但不总是)，看到一个循环是一个很好的指示，表明您正在检查的特定代码块的运行时间为<code class="fe nd ne nf ng b">O(n)</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/afacd498d071bb3eae18473c452100ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUeFdfyczc49EAs8z8jCnQ.png"/></div></div></figure><p id="5715" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是方法呢<code class="fe nd ne nf ng b">find</code>？既然不是一直贯穿整个系列，那么实际上是线性的吗？在下面的示例中，第一个小于3的值位于集合的索引<code class="fe nd ne nf ng b">0</code>处。为什么这不是恒定时间？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/d24802ba656ab0da90a759cf213584c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kz3-HEmJpaBsCzXvV25IWQ.png"/></div></div></figure><p id="34be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，由于我们在寻找最坏的情况，我们必须假设输入不是理想的，我们寻找的元素或值可能是数组中的最后一个值。在第二个场景中(如下)，您将会看到这一点。在最不理想的情况下，查找小于3的数字需要遍历整个数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/c667b1d56e6f49d44410b8d52fe04108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXLZdkuOD21LFKuRHwKrSQ.png"/></div></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="9c01" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">O(n ) →二次时间</h1><p id="b2e4" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><code class="fe nd ne nf ng b">O(n²)</code>表示计算以二次时间运行，即输入数据大小的平方。</p><p id="5dd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程中，许多更基本的排序算法的最坏情况运行时间为<code class="fe nd ne nf ng b">O(n²)</code>:</p><ul class=""><li id="4645" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">冒泡排序</li><li id="3382" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">插入排序</li><li id="2795" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">选择排序</li></ul><p id="8f90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面我们来看看<code class="fe nd ne nf ng b">countOperations</code>。这里我们有两个嵌套循环，在每次迭代后递增变量<code class="fe nd ne nf ng b">operations</code>。如果<code class="fe nd ne nf ng b"><em class="lv">n</em></code>是我们的<code class="fe nd ne nf ng b">smallCollection</code>，我们将以16次操作的计数结束。不可怕。但是如果<em class="lv"> n </em>是我们的<code class="fe nd ne nf ng b">gigantic collection</code>呢？十亿乘以十亿是一个万亿分之一，即10亿亿。呀。那可是一大堆操作。即使只有1000个元素的数组最终也会产生一百万次操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/4706afc24f6e586732d34be12e43499b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HtRl-qZ3lp_mi0PNyochrw.png"/></div></div></figure><p id="1347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说(但不总是)，看到两个嵌套循环通常是一个很好的指标，表明您正在查看的这段代码的运行时间为<code class="fe nd ne nf ng b">O(n²)</code>。同样——三个嵌套循环表示运行时间为<code class="fe nd ne nf ng b">O(n³)</code>！</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="3c81" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">O(log n) →对数时间</h1><p id="e7c2" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><code class="fe nd ne nf ng b">O(log n)</code>表示运行时间与输入大小的对数成比例增长。这意味着当您以指数方式增加输入时，运行时间几乎不会增加。</p><p id="69dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将我的样本大小减半，在物理词典中找到一个单词，这是对数时间在现实世界中如何工作的一个很好的例子。例如，当查找单词“senior”时，我可以准确地在中间打开词典，此时我可以确定以“s”开头的单词是在我当前查看的单词之前还是之后。一旦我确定“s”在书的后半部分，我就可以忽略前半部分的所有页面。然后我重复同样的过程。通过将这个算法进行到底，我可以将每次必须搜索的页数减少一半，直到找到单词。</p><p id="7afd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程中，这种在物理字典中搜索的行为是二分搜索法运算的一个例子，是讨论对数运行时间时最典型的例子。</p><p id="7d26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看我们的<code class="fe nd ne nf ng b">countOperations</code>函数的修改版本。注意<em class="lv"> n </em>现在是一个数字:<em class="lv"> n </em>可以是一个输入(数字)或者输入的大小(数组的长度)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/e67fd90725c9e5d969be11ab71560114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*cm4XX1y0nPW0Jl7Z2jLisQ.png"/></div></figure><p id="8acd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，如果<em class="lv"> n </em> = 2000，我们最终得到11个操作。如果<em class="lv">n</em>= 4000，我们最终得到12个操作。我们每增加一倍<em class="lv"> n </em>的量，运算量只增加一。当涉及到更大的输入时，以对数时间运行的算法有很大的意义。使用我们下面的例子，<code class="fe nd ne nf ng b">O(log(7))</code>将返回三个操作。一个<code class="fe nd ne nf ng b">O(log(1000000))</code>只会返回20个操作！</p><p id="7770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">注:</em> <code class="fe nd ne nf ng b"><em class="lv">O(n log n)</em></code> <em class="lv">，常与</em> <code class="fe nd ne nf ng b"><em class="lv">O(log n)</em></code> <em class="lv">混淆，表示算法的运行时间是线性的，是线性和对数复杂度的结合。利用分治策略的排序算法是线性算法，如下:</em></p><ul class=""><li id="be49" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><code class="fe nd ne nf ng b"><em class="lv">merge sort</em></code></li><li id="2524" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><code class="fe nd ne nf ng b"><em class="lv">timsort</em></code></li><li id="de5e" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><code class="fe nd ne nf ng b"><em class="lv">heapsort</em></code></li></ul><p id="6da5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">看时间复杂度的时候，</em> <code class="fe nd ne nf ng b"><em class="lv">O(n log n)</em></code> <em class="lv">落在</em> <code class="fe nd ne nf ng b"><em class="lv">O(n2)</em></code> <em class="lv">和</em> <code class="fe nd ne nf ng b"><em class="lv">O(n)</em></code> <em class="lv">之间。</em></p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="2e6b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Big-O备忘单</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/17838a00e08cb6c76de8a4f1b1492bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kIxfN2goP8qfFWjZmUvMQ.jpeg"/></div></div></figure><p id="eabe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最喜欢参考的大O网站之一是<a class="ae kv" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">大O小抄</a>。正如您从图表中看到的，其他运行时间具有非常可怕的时间复杂性，比如<code class="fe nd ne nf ng b">O(2^n)</code>和<code class="fe nd ne nf ng b">O(n!)</code>。</p><p id="07f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行在<code class="fe nd ne nf ng b">O(2^n)</code>和<code class="fe nd ne nf ng b">O(n!)</code>中的算法除了微小的数据集之外，什么都做不好。<code class="fe nd ne nf ng b">O(2^n)</code>或指数时间，每增加一次输入，时间加倍。<code class="fe nd ne nf ng b">O(n!)</code>，或者阶乘时间，就更惨了。任何时候<em class="lv"> n </em>增加1，运行时间增加n倍。</p><p id="646d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，没有固定的运行时间列表。然而，我们在这篇文章中提到的是一些最常见的。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="9686" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">计算大O</h1><p id="8eef" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">到目前为止，我们只是通过一次隔离几行代码来集中讨论big O。如果我们正在处理一个有几个部分的算法，我们如何计算大O？</p><h2 id="6fe8" class="oc mh iq bd mi od oe dn mm of og dp mq lf oh oi ms lj oj ok mu ln ol om mw on bi translated">放下常数</h2><p id="ac01" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">先说<code class="fe nd ne nf ng b">logEverythingTwice</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/3d5bcce96ffbf7712532ab7e0dc5a11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hvU1r7YS-Zxgz8hge19ww.png"/></div></div></figure><p id="930f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为大O关心的是我们的运行时间增长有多快，所以你要记住的第一条规则是当你分析一个算法的时候，去掉任何常量。</p><p id="17a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们有两个独立的循环，它们遍历一个数组的长度(线性的)。每个循环记录集合中的一个项目(常量)。由于我们不关心在恒定时间内运行的操作(它们在整体近似中几乎没有区别)，我们只考虑两个循环并将它们加在一起，这给了我们<code class="fe nd ne nf ng b">O(2n)</code>。由于数字2在这种情况下也是一个常数，我们把它扔掉，称之为<code class="fe nd ne nf ng b">O(n)</code>。</p><p id="79be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果这些循环是嵌套的呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/4b475964116e35a55620debb0f0e500b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVFUyEHFLZKH8JJwwUP1Tg.png"/></div></div></figure><p id="64d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过嵌套这些循环，我们不再记录<code class="fe nd ne nf ng b">items[i]</code>两次，而是五次！在这种情况下，我们乘以<code class="fe nd ne nf ng b">O(n) * O(n)</code>，而不是将运行时间相加。我们这样做是因为我们的日志的执行依赖于在我们能够递增<code class="fe nd ne nf ng b"><em class="lv">i</em></code>并通过我们的第一个循环移动到下一个索引之前迭代通过整个第二个循环(记录<code class="fe nd ne nf ng b"><em class="lv">i</em></code>五次)。下面是我们的日志最终返回的内容:</p><pre class="kg kh ki kj gt oq ng or os aw ot bi"><span id="2408" class="oc mh iq ng b gy ou ov l ow ox">1<br/>1<br/>1<br/>1<br/>1<br/>2<br/>2<br/>2<br/>2<br/>2<br/>3<br/>3<br/>....</span></pre><p id="e585" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像第一个例子一样，我们仍然希望从日志中删除常量。最后，<code class="fe nd ne nf ng b">O(n * n)</code>给了我们<code class="fe nd ne nf ng b">O(n²)</code>。</p><p id="aab9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不应该因为性能影响而总是避免嵌套循环。毫无疑问，您会遇到需要这种解决方案的情况(微型数据集、操作多维数组等)。).但是，您应该知道这可能会影响性能，具体取决于您正在做什么。</p><h2 id="92e4" class="oc mh iq bd mi od oe dn mm of og dp mq lf oh oi ms lj oj ok mu ln ol om mw on bi translated">去掉非主导术语</h2><p id="9a62" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">让我们看另一个例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/bd9c74c6047db0b20e092d49eb53eec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dKIsePmD0JicPFqvnhcq5A.png"/></div></div></figure><p id="fc9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">放下<code class="fe nd ne nf ng b">printMultiplesThenSum</code>、<strong class="ky ir">、</strong>中的常数后，我们可以看到这个函数的大O符号将是<code class="fe nd ne nf ng b">O(n² + n)</code>。由于大O也不关心非支配项，我们放弃了<code class="fe nd ne nf ng b"><em class="lv">n</em></code>(二次型获胜，因为它比线性时间差)。在分析算法的运行时间时，要遵循的第二条规则是抛弃非主导项。最后，<code class="fe nd ne nf ng b">O(n² + n)</code>给了我们<code class="fe nd ne nf ng b">O(n²)</code>。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="f9f6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">结论</strong></h1><p id="e5f7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如前所述，您可以在不了解big O的来龙去脉的情况下编写代码。您还应该知道这是一个近似值，因为当性能受到环境、处理器和语言等因素的影响时，您手动计算的运行时间可能不会在生产中运行。</p><p id="4590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这不应该阻止你学习big O。对big O符号有一个很好的理解会给你更多的关于设计算法时什么是重要的，什么是不重要的上下文。谁不想这样呢？</p></div></div>    
</body>
</html>