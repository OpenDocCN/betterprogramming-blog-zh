<html>
<head>
<title>A Visual Tutorial on Every Type of Test You Can Write</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可以编写的每一种测试的可视化教程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-visual-tutorial-on-every-type-of-test-you-can-write-ec9b83edcf35?source=collection_archive---------15-----------------------#2020-03-24">https://betterprogramming.pub/a-visual-tutorial-on-every-type-of-test-you-can-write-ec9b83edcf35?source=collection_archive---------15-----------------------#2020-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c10b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">所有类型的测试都在一个地方进行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c84fbe8e617afcc00fd5c887920c06e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvvBWQxusiU0clRdrDE09Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><blockquote class="ky"><p id="6ddd" class="kz la it bd lb lc ld le lf lg lh li dk translated">从理论上讲，每次修复后，都必须运行之前针对系统运行的整个测试用例库，以确保系统没有受到不为人知的破坏— <a class="ae lj" href="https://en.wikipedia.org/wiki/Regression_testing" rel="noopener ugc nofollow" target="_blank">弗雷德·布鲁克斯，神话中的人月</a></p></blockquote><p id="08ad" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me li im bi translated">一段时间以前，一位经理让我告诉他一个可靠的资源，在那里他可以找到集成和单元测试之间区别的清晰描述。我回答说，这是显而易见的，他可以在维基百科上找到这个描述以及堆栈溢出。</p><p id="6837" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">过了一会儿，经理给我发来一条消息，简短地描述了测试之间的差异，以重新检查并批准它。我感兴趣的是为什么这是必要的。原来其中一个软件开发人员辩称单元测试是主要方式，不需要集成测试。他也没有时间阅读关于这个话题的文章。因此，经理决定做一个简洁的描述，这将有助于改变开发者的想法。我建议他发一张会有视觉差异的图。研究一个视觉方案比阅读一篇文章更快，也许更有效。</p><p id="c01b" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">我开始搜索这张图片，但我无法通过谷歌快速找到任何东西。最后，我自己在MacBook上用Keynote做了这个图表。</p><p id="8276" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">奇怪的是，这张图片很有帮助，开发者没有进一步的问题。实际上，这就是我写这篇关于不同测试类型可视化的小文章的动机。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f8b6" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">TST(全系统测试)</h1><p id="f723" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">我喜欢TST哲学。没有不必要的测试。许多开发人员说他们没有时间进行某些形式的测试。想象一下，一位医生给你开了很多药，并建议你每天服用，但不看你的检查结果。或者想象一下买了一辆没有通过所有必要测试的汽车。或者在飞行前没有经过适当测试的飞机上飞行。情况不妙，对吧？</p><p id="290c" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">争取全面完整的系统测试总是必要的。是的，100%不可能，但努力争取是可以的。单元测试只检查系统中孤立的小部分。谁来检查他们的团队合作？谁来检查他们的通信？系统测试就是为此而开发的。供应情况如何？</p><p id="3037" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">通过提供带有公共API的服务，您必须用集成测试来测试这个API。否则，每当有人对系统进行更改时，您都必须雇用一组人工测试人员。当然，开发人员会说那里一切正常。一切都是孤立的，这个终点没有触及其余部分。你认出你自己了吗？但是保障在哪里呢？因此，集成测试是系统稳定的保证。</p><p id="a007" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">同时，您应该记住，我们与企业合作，也是为了企业。在这种现实中，TST是不可能的。用迈克·科恩的测试金字塔<em class="no">或者肯特·c·多兹的测试奖杯更合适:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/854b5f146ca2e8bbfef2bf1643f26dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pylVT3kydZCSYAkA14cYlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试方法。</p></figure><p id="8950" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">你应该记得:自动化应该像钢铁侠——而不是奥创。</p><p id="120b" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">我将为您提供一个测试列表，在我看来，这些测试应该由开发人员编写。不是自动化工程师。他们用可伸缩性测试、负载测试、压力测试、浸泡测试等来补充测试环境。我说的是我们，开发商。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="bcfa" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">单元测试、块测试或组件测试</h1><p id="791b" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">单元测试用于测试逻辑分配和隔离的系统单元。在大多数情况下，它是一个类方法或一个简单的函数(尽管它可以是整个类)。被测单元的隔离是在短截线、模型和实物模型的帮助下实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/285e3e0b1c0793ad09a866e6eadd3d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0pVZsx7-rBLpthLlsQUnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单元测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="c1ff" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">系统测试或服务测试</h1><blockquote class="nq nr ns"><p id="7276" class="lk ll no lm b ln mf ju lp lq mg jx ls nt mh lv lw nu mi lz ma nv mj md me li im bi translated"><em class="it"> " </em>几年来，我一直成功地使用下面的<br/>经验法则来安排软件任务:</p><p id="88c8" class="lk ll no lm b ln mf ju lp lq mg jx ls nt mh lv lw nu mi lz ma nv mj md me li im bi translated">1/3规划</p><p id="a14d" class="lk ll no lm b ln mf ju lp lq mg jx ls nt mh lv lw nu mi lz ma nv mj md me li im bi translated">1/6编码</p><p id="959b" class="lk ll no lm b ln mf ju lp lq mg jx ls nt mh lv lw nu mi lz ma nv mj md me li im bi translated">1/4组件测试和早期系统测试</p><p id="a6b5" class="lk ll no lm b ln mf ju lp lq mg jx ls nt mh lv lw nu mi lz ma nv mj md me li im bi translated">1/4系统测试所有组件在手”</p><p id="6d5d" class="lk ll no lm b ln mf ju lp lq mg jx ls nt mh lv lw nu mi lz ma nv mj md me li im bi translated">- <a class="ae lj" href="https://www.cs.drexel.edu/~yfcai/CS451/RequiredReadings/MythicalManMonth.pdf" rel="noopener ugc nofollow" target="_blank">弗雷德·布鲁克斯，神话人月</a></p></blockquote><p id="ee19" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">这是一个复杂的测试，一次测试几个组件。在这种情况下，系统被视为一个黑盒。我们可以说这是一个单元测试，其中模块是一组组件。这个包由一个提供适当API的外观联合在一起。这个API的方法是我们应该用测试来覆盖的。在<code class="fe nw nx ny nz b">Stubs</code>、<code class="fe nw nx ny nz b">Dummies</code>和<code class="fe nw nx ny nz b">Mockups</code>的帮助下实现线束的隔离。借助所谓的<code class="fe nw nx ny nz b">Spies</code>连接部件并检查它们之间的通信格式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/08ae99cd7aaf562509d18d67321f69b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzlAid2oJfN3n9qwpEv4jg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">系统测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="35b7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">集成测试、契约测试或API驱动的测试</h1><p id="2553" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">其实这是一种系统测试。更常见的是，这个术语用于测试覆盖服务的公共API。重点是根据“服务-客户”的原则测试不同系统的交互例如，数据访问层方法包含在系统测试中。系统测试还涵盖了调用计算业务信息(业务层)的函数的控制器方法。</p><p id="0abb" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">但是HTTP请求的处理程序(调用控制器的方法)包含在集成测试中。对于这样的测试，请求应该以与该服务的最终用户相同的方式发出(例如，单页应用程序或使用Postman/Swagger的测试人员)。这意味着，实际上，对于这样的测试，有必要重新创建一个几乎全功能的环境。最困难的事情是隔离测试并生成测试数据。为了形成这样的环境，使用了<code class="fe nw nx ny nz b">TestBed</code>和<code class="fe nw nx ny nz b">Fixture</code>(脚手架)模板。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/44fce63a13067cd1fe5e2a529179e37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ia5mkPCN_8IJHkCJGwgz2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">集成测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ac0d" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">功能或端到端测试、GUI测试、走查测试</h1><p id="9016" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">这是为了模拟系统最终用户的行为而开发的测试。实际上，您必须编写一个将在测试环境中使用您的系统的机器人。更常见的是，该术语用于GUI(即用户交互和图形系统界面)。</p><p id="8338" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">使编写这样的测试变得更容易的最流行的模板之一是页面对象(屏幕对象)。一个好的实践是以无头浏览器的风格实现这样的测试，这样它们可以在没有图形界面的情况下作为CI(持续集成)过程的一部分运行。这些测试大部分是由自动化工程师编写的，但是开发人员应该添加基本集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac53738b60959c8b0e7ad0ae225d88e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3HQmcY1aBQEAg4nErf2dnQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">功能/E2E测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b8ec" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">快照测试</h1><p id="0f76" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">快照是一种介于集成和功能测试之间的测试。大多数情况下，这些测试与用户界面及其组件相关，因为它们检查组件的可视化表示。但是，这种测试也可以应用于系统的其他部分，例如，检查数据库转储或代码转换结果。</p><p id="7edf" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">测试的本质非常简单，使用专门的工具，我们创建一个UI组件或页面的参考图像(快照)——这实际上是渲染的结果。</p><p id="ecc0" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">在测试中，我们用特定的输入数据挂载一个UI组件，并在每次开始时创建一个新的快照。接下来，我们比较存储的快照和测试期间生成的快照。</p><p id="2b42" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">快照可以是<em class="no">文本</em>(一个带有HTML标记的文件，就像<a class="ae lj" href="https://jestjs.io/docs/en/snapshot-testing" rel="noopener ugc nofollow" target="_blank">玩笑中的快照</a>)和<em class="no">视觉</em>(事实上，这是一个截图——工具像<em class="no"> </em> <a class="ae lj" href="https://percy.io/" rel="noopener ugc nofollow" target="_blank">珀西</a> <em class="no">、</em> <a class="ae lj" href="https://www.chromaticqa.com/" rel="noopener ugc nofollow" target="_blank">彩色</a> <em class="no">或</em> <a class="ae lj" href="https://github.com/mapbox/pixelmatch" rel="noopener ugc nofollow" target="_blank">像素匹配</a>)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0331db84c3812caad13ece52e3f0acea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8LxpTwzpo6Ta-MP8AWTxg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">快照测试图</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="63a2" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">冒烟测试或健全性检查</h1><p id="c5ce" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">这是集成测试的一个特例。通常，这些都是在系统启动前运行的非常小的测试，以确保第三方软件正常工作，这是系统正常运行所必需的。如果此类测试失败，我们可以通知用户有关问题或完全停止系统的启动。</p><blockquote class="ky"><p id="c817" class="kz la it bd lb lc oc od oe of og li dk translated">冒烟测试起源于硬件测试，以确定给设备通电是否会导致设备开始冒烟，这表明存在重大问题— <a class="ae lj" href="https://books.google.ca/books?id=6e5FDAAAQBAJ&amp;pg=PA186&amp;lpg=PA186&amp;dq=Smoke+tests+originated+with+hardware+testing+to+determine+whether+powering+on+a+device+would+cause+it+to+start+smoking,+an+indication+of+a+major+problem.&amp;source=bl&amp;ots=-XfcbaRU01&amp;sig=ACfU3U2MPtDne2PbgjCTkU6I2odqT8oblw&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwip2d_92LPoAhUjc98KHWMDAGkQ6AEwAHoECAgQAQ#v=onepage&amp;q=Smoke%20tests%20originated%20with%20hardware%20testing%20to%20determine%20whether%20powering%20on%20a%20device%20would%20cause%20it%20to%20start%20smoking%2C%20an%20indication%20of%20a%20major%20problem.&amp;f=false" rel="noopener ugc nofollow" target="_blank">有效的开发工作:建立大规模的协作、亲和和工具文化</a></p></blockquote><figure class="oh oi oj ok ol kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a30e32fc4b39212c7bd2822af16b1dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlq5nd7ef0MiejeEJaYoDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">烟雾测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1ad3" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">学习测试</h1><p id="8113" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">这是一种由客户开发人员(集成人员)编写的集成测试，作为研究他以后必须集成的系统的过程的一部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a3bccbccda940196708588d1f7c8ff18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTnewrVNDK2xArDO0vPakA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">学习测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3d25" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">回归测试</h1><p id="10de" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">这可以是上面描述的任何一种测试，但是它是在检测到问题之后编写的。测试应该模拟完全相同的步骤来重现问题。在修复问题后进行这样的测试可以保证相同的错误不会再出现在系统中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/8355fc9b7485f443e2ba41de3c83d5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6INCVO2H6jmND7AO2Hwy0w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">回归测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b92e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">验收测试或故事测试</h1><p id="8ac0" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">这可以是上述测试中的任何一种。主要思想是，一个这样的测试对应于一个特定的用户故事(也就是说，验收测试的正面结果是一个保证，即您完全按照客户希望的方式实现了功能)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ad5dba65cae84c588e8281fc83e7d1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xng3CAbSBKqRW3It3kDxEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">验收测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4914" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">渗透试验</h1><p id="1d4a" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">系统检查各种漏洞。一个很好的例子是检查SQL命令的转义(注入保护)、数据可用性和使用过期令牌的授权等的测试。编写这样的测试的困难是所有瓶颈的原因。通常，关于平台的已知漏洞和利用的公开信息用于此目的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/54fe20fca11b8421ff24ddfde3764700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IanaJ4L91sBnst1HW7XdtQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">渗透测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="c938" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">模糊测试，模糊测试，随机测试</h1><p id="2713" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">这通常是一种系统测试或漏洞检查。其思想是将随机的、故意不正确的或意外的输入数据流输入到系统输入端。此测试的目的是尝试检测验证逻辑和验证的违反情况、边界情况下的应用程序逻辑、突然的服务器崩溃、尝试检测内存泄漏或通过未处理的错误消息(stacktrace)泄漏有关系统内部设备的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5598ba0f9175277eedf3a341649e34a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KN-l2_i8NYSKgjxXAVZaw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模糊测试图。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a3f6" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">测试模式</h1><p id="523d" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated"><code class="fe nw nx ny nz b">Stub (Dummy, Noop)</code>是一个类的函数或方法，它替换了原始函数的实现，并且在不执行任何有意义的操作的情况下，返回一个空结果或测试数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/afa2307cea55cafebaea4bbdad0d195f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJ_2KRna1-XQnBOs4ZmxlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">存根图。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4402" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated"><code class="fe nw nx ny nz b">Mockup</code>是对象的实例，表示接口的特定虚拟实现。一般来说，实体模型旨在替代原始系统对象，仅用于测试被测组件的交互和隔离。通常，对象的方法是<code class="fe nw nx ny nz b">Stubs</code>和<code class="fe nw nx ny nz b">Dummies</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/2c76414ab5ff9889af763f270677eb2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jV7kV5lwaVMotLoWORh9Jg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模拟图。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ea8f" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated"><code class="fe nw nx ny nz b">Spy</code>是一个包装器对象，一种监听调用并存储原始系统对象的调用信息(参数、调用次数、上下文)的代理。此外，<code class="fe nw nx ny nz b">spy</code>-保存的数据用于测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e21b" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated"><code class="fe nw nx ny nz b">TestBed</code>是专门重新创建的测试环境，一个测试的平台(可能是一组<code class="fe nw nx ny nz b">Mockups</code>、<code class="fe nw nx ny nz b">Stubs</code>、<code class="fe nw nx ny nz b">Spies</code>)。它用于单个组件包或整个系统的复杂测试。也可以作为实验的操场。</p><p id="ee75" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated">JavaScript中的例子有<a class="ae lj" href="https://github.com/hapijs/lab" rel="noopener ugc nofollow" target="_blank"> lab </a>和<a class="ae lj" href="https://hapi.dev/api/?v=19.1.1#-await-serverinjectoptions" rel="noopener ugc nofollow" target="_blank"> hapi.js server.inject </a>，<a class="ae lj" href="https://github.com/visionmedia/supertest" rel="noopener ugc nofollow" target="_blank"> supertest </a>和<a class="ae lj" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> express.js </a> app，组件的<a class="ae lj" href="https://angular.io/api/core/testing/TestBed" rel="noopener ugc nofollow" target="_blank"> angular 2 testbed </a>，react.js组件的<a class="ae lj" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> enzyme </a>和<a class="ae lj" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> react-testing-library </a>，sinonjs中的<a class="ae lj" href="https://sinonjs.org/releases/v1.17.6/sandbox" rel="noopener ugc nofollow" target="_blank">沙箱</a>。</p><p id="cf01" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated"><code class="fe nw nx ny nz b">Fixture</code> (Scaffolding)是将对象或整个系统带入某种状态，并固定这种状态进行测试的机制。通常，fixture指的是正确启动测试所必需的测试数据，以及将这些数据上传/下载到存储库的机制(也就是说，fixture的主要目的是将系统数据带到一个特定的状态——固定的——这将在测试执行过程中确切地知道)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="09e3" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated"><code class="fe nw nx ny nz b">Page Object</code>或<code class="fe nw nx ny nz b">Screen Object</code>是一个结构重复页面元素的对象。对象提供了使用相应的UI页面(单击按钮、填充字段、切换到其他页面)和访问该页面上的信息(标题、各种文本、标签)的方法。这个领域最流行的工具之一是<a class="ae lj" href="https://www.selenium.dev" rel="noopener ugc nofollow" target="_blank"> Selenium WebDriver </a>和它上面的各种包装器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f656" class="pw-post-body-paragraph lk ll it lm b ln mf ju lp lq mg jx ls lt mh lv lw lx mi lz ma mb mj md me li im bi translated"><code class="fe nw nx ny nz b">Asserts</code>是一组函数，允许您比较两个或多个函数的结果。它可以提供深入比较结构的可能性，使用内省机制来检查对象是否存在某些属性。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b40c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="eedc" class="pw-post-body-paragraph lk ll it lm b ln nj ju lp lq nk jx ls lt nl lv lw lx nm lz ma mb nn md me li im bi translated">以上所写的一切都代表了我谦虚的主观看法和解释。你的呢？我很高兴在评论中看到它们。</p></div></div>    
</body>
</html>