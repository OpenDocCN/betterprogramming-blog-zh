<html>
<head>
<title>The Internals of Asynchronous Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步编程的内部原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asynchronous-programming-8aaae83cd9f3?source=collection_archive---------10-----------------------#2022-07-04">https://betterprogramming.pub/asynchronous-programming-8aaae83cd9f3?source=collection_archive---------10-----------------------#2022-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af7f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Kotlin实现示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f54175698be585685782e52175a911da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BZpeRuDu3n4rY-JC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@howardbouchevereau?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Howard Bouchevereau </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="679d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Go、Rust、Kotlin等大多数编程语言都提供了非常“轻量级”的线程抽象。</p><p id="517a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它允许您生成数千个这样的轻量级线程，而不会产生任何操作系统上下文切换开销！</p><p id="2b07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这些语言使用不同的语义来提供这种轻量级线程，但这种框架的底层构建块和实现模式非常相似。</p><p id="c0f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将尝试提供底层实现的高级概念概述，这样您就可以对这种编程模型有一种直觉，并且理解这些语言中的大多数在理论上可以提供相同级别的性能保证。</p><p id="119a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了这篇博客，我将使用术语“<code class="fe lv lw lx ly b">xroutine</code>”来标识一个单独的计算单元(也称为轻量级线程)——Golang称之为“Go routine”，Kotlin称之为“coroutine”，Rust只是将这个单独的计算单元称为“Future”，但这些原语的目标和实现模式非常相似。</p><h1 id="f8d2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">系统设计</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/7588cf2ac0ff51b14753cd8fd6e8d30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WC-VgRdjnUB6wbiotKjvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">高级设计</p></figure><p id="2bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括地说，主要组件是——执行器、反应器和XRoutine。让我们来详细看看这些组件，以及它们如何协同工作来提供高性能的轻量级线程</p><h2 id="1ff2" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">反应堆</h2><p id="6600" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">这个组件的主要职责是监控文件描述符！</p><p id="c3b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，Rust、Go、Kotlin、Nodejs等所有语言之所以能够提供轻量级线程，唯一的原因是操作系统提供了非常高效的系统调用来执行非阻塞IO操作。</p><p id="9361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去，每次您执行系统调用来读取或写入文件描述符时，您的调用线程可能会被阻塞。这是低效的，因为操作系统需要进行上下文切换(这是非常昂贵的)来调度其他线程。</p><p id="3aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是由于现代操作系统提供了像<a class="ae ky" href="https://man7.org/linux/man-pages/man2/select.2.html" rel="noopener ugc nofollow" target="_blank"> select </a>和<a class="ae ky" href="https://man7.org/linux/man-pages/man7/epoll.7.html" rel="noopener ugc nofollow" target="_blank"> epoll </a>这样的系统调用，这些系统调用使我们能够在不阻塞调用线程的情况下执行IO操作！</p><p id="3b28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以阅读API规范以了解更多有关epoll如何工作的信息，但本质上，它提供了一种请求IO操作的方式，并允许您<strong class="lb iu">轮询</strong>一堆文件描述符以检查活动，API的设计方式使您可以在单个线程中轮询数百或数千个文件描述符——这正是rector所做的！</p><p id="c059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应器的工作是轮询/监视文件描述符——当反应器注意到IO现在可以在特定的文件描述符上执行时，它会找到相应的正在等待该特定描述符的XRoutine，并将它移动到就绪队列中执行！</p><p id="dfb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能注意到没有操作系统线程在文件描述符上被阻塞，唯一处理IO的线程是Reactor，它轮询描述符(没有阻塞),每当文件描述符准备好被使用时,<strong class="lb iu">将XRoutine从等待队列移动到就绪队列</strong>。</p><h2 id="f8e2" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">执行者</h2><p id="8575" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">执行器的主要职责是运行/执行“就绪队列”中的<code class="fe lv lw lx ly b">XRoutines</code>，它由多个调度器(通常每个CPU内核一个)组成，使用众所周知的worker模式处理负载。</p><p id="499b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让执行器执行Xroutine，它使用了一个固定的API契约——运行XRoutine的执行器的简化伪代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">契约的重要元素是“上下文”，当执行器调用Xroutine时，它还传递上下文以及xroutine需要的其他参数。</p><p id="db85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果xroutine需要等待一个文件描述符，它会返回一个值(“Blocked”)，指示执行器<code class="fe lv lw lx ly b">xroutine</code>被阻塞，这使得执行器能够将<code class="fe lv lw lx ly b">xroutine</code>添加到一个单独的队列中，并继续执行就绪队列中的其他<code class="fe lv lw lx ly b">xroutines</code>。</p><p id="13b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lv lw lx ly b">xroutine</code>调用另一个<code class="fe lv lw lx ly b">xroutine</code>时，上下文会一直传播到负责监控IO文件描述符并将初始<code class="fe lv lw lx ly b">xroutine</code>移动(唤醒)到就绪队列的反应器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/89131ed103530e3aae1c78dcd67b279d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*CbyHnRUOjSl4a7J6L2IcRQ.png"/></div></figure><h2 id="bee7" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">x例程</h2><p id="d2a1" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在上一节中，您可能已经注意到，每当reactor注意到文件描述符已经准备好使用时，它就会遵循上下文传播树，将第一个xroutine移动到就绪队列，以便执行器能够获得它。</p><p id="81a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着每个xroutine都应该从先前停止的地方“恢复”!</p><p id="7d18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这带来了一个新的挑战，Xroutines不能只是一个简单的函数，它应该是一个智能的状态机，将它的状态保存到上下文中，并使用它从被阻塞的地方恢复执行。</p><p id="57f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以下面的函数为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d9f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想把函数<code class="fe lv lw lx ly b">incrementTwice</code>当作一个xroutine，它应该是智能的和有状态的，这样多次调用/执行它将会从它之前被阻塞的地方恢复它的执行。</p><p id="b02a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是编译器帮助我们的地方，只需用特定于语言的关键字/注释来注释函数(如golang中的“go”、rust中的“async”和kotlin中的“suspend”)，编译器就可以将函数转换成处理恢复逻辑的状态机。</p><p id="7264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的状态机的伪代码可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在伪代码中看到的，编译器会将原始函数转换为有状态函数，当调用该函数时，它会根据上下文中出现的<code class="fe lv lw lx ly b">suspensionPoint</code>的值跳转到代码中的特定块。</p><p id="c62a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当它第一次被调用时，它运行<code class="fe lv lw lx ly b">initial</code>块，将结果递增1，然后当它调用logger.log(..)它注意到底层记录器被阻塞，因此将<code class="fe lv lw lx ly b">suspensionPoint</code>保存为“final ”,并返回<code class="fe lv lw lx ly b">Blocked</code>响应供上游代码进行类似处理——还要注意，上下文被传播到记录器，记录器最终被传递到反应器，反应器使用它将初始xroutine移动到就绪队列。</p><p id="a1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当xroutine被executor从就绪队列中取出并第二次调用它时，xroutine使用上下文值"<code class="fe lv lw lx ly b">suspensionPoint</code>"并直接跳转到<code class="fe lv lw lx ly b">final</code>块，从上一次执行中暂停的地方重新开始执行。</p><p id="aa99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅通过添加一些编译器关键字，我们现在得到了一个xroutine，它是最小的执行单元，可以在没有任何操作系统上下文切换的情况下被执行、阻塞和恢复！</p><h2 id="03e0" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">结论</h2><p id="59d3" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">总之，前面提到的所有语言都使用非常相似的设计来支持<code class="fe lv lw lx ly b">XRoutine</code>(在kotlin中是coroutine，在golang中是goroutine，在Rust中是Future)。</p><p id="bf9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">XRoutine</code>只是一个编译器生成的状态机，它将上下文相互传播到反应器，反应器是运行时的核心，它监控文件描述符并确定要重新调度的特定XRoutine，并将它从等待队列移动到就绪队列。</p><p id="b077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于每个XRoutine只不过是内存中的一个对象，所以您可以在不增加任何操作系统上下文切换开销的情况下生成数千个XRoutine！</p></div></div>    
</body>
</html>