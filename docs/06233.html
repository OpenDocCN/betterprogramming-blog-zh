<html>
<head>
<title>What Are the Simplest State Management Solutions in Flutter?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter中最简单的状态管理解决方案有哪些？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-the-simplest-state-management-solutions-in-flutter-56326797a28f?source=collection_archive---------7-----------------------#2020-09-11">https://betterprogramming.pub/what-are-the-simplest-state-management-solutions-in-flutter-56326797a28f?source=collection_archive---------7-----------------------#2020-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="695b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">下一次面试的超级简单对比</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/62be4d50974a49933e38afe6522cc2cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jvjo3vmxDmEsdn27zIdkig@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自inovex博客。</p></figure><p id="b4af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将探索Flutter内置的状态管理解决方案。</p><p id="95f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下所有示例中，我们将通过点击按钮来更改应用背景:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/66ee2510ad18a7546457261b0d0e5190.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/1*sXJRr4GUilCnOX2cxsdy7A.gif"/></div></figure><p id="f78f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于本文的目的，假设我们的<code class="fe lw lx ly lz b">backgroundColor</code>是某个复杂的应用程序状态。</p><p id="ab0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，第一个解决方案是一个简单的<code class="fe lw lx ly lz b">StatefulWidget</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/910ed5c3b6769fd3922c16df1b063c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MTNOMy9fzsCaip_Bm8aKYA.png"/></div></div></figure><p id="dbf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lw lx ly lz b">State</code>对象中引入了<code class="fe lw lx ly lz b">currentColor</code>变量，在这里，每次点击按钮，都会生成一个新值。通过调用<code class="fe lw lx ly lz b">setState()</code>，整个用户界面被重绘。</p><p id="a70f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个效果很好，但是想象一下这个颜色是更复杂的东西。如果我们能够将UI与逻辑分离开来，那就更好了(这样我们以后就可以很容易地只更改UI或者只更改逻辑)。对于不简单的应用程序，这些层应该分开。</p><p id="e3a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将介绍<code class="fe lw lx ly lz b">ChangeNotifier</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mb"><img src="../Images/74b7e8c2f1f6c1a57b9212c809de548e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YrFGazqfCGL54NOGEVtLiw.png"/></div></div></figure><p id="c21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经将我们的逻辑移到了<code class="fe lw lx ly lz b">Notifier</code>类，该类被扩展为<code class="fe lw lx ly lz b">ChangeNotifier</code>。<code class="fe lw lx ly lz b">ChangeNotifier</code>有能力通知它的监听器它已经发生了一些变化。当我们检测到监听器方法中的变化时(在<code class="fe lw lx ly lz b">initState()</code>方法中)，我们通过调用<code class="fe lw lx ly lz b">setState()</code>来重绘整个UI。</p><p id="7bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，这样更好，但是我们是否应该在每次<code class="fe lw lx ly lz b">Container</code>的颜色改变时重新绘制整个UI？大概不会。</p><p id="282d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将介绍一个<code class="fe lw lx ly lz b">ValueNotifier</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/2d337c4b70b68ec49c9f453a85dd3c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwV1JL7L0LyFPm8Pjqa9QQ.png"/></div></div></figure><p id="c3db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">ValueNotifier</code>基本上是一个只保存一个值的<code class="fe lw lx ly lz b">ChangeNotifier</code>，当它发生变化时，监听它变化的人会得到通知。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/6bf490ea9c3c51c60f16dd184dc071c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBjT30VW_UBTXSWkVu8v3Q.png"/></div></div></figure><p id="2975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以向<code class="fe lw lx ly lz b">ValueNotifier</code> <strong class="lb iu"> </strong>对象添加监听器并重新绘制整个UI，但是现在有一种更方便的方式来显示更改:<code class="fe lw lx ly lz b">ValueListenableBuilder</code>！</p><p id="8291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">ValueListenableBuilder</code>是一个小部件，当它的<code class="fe lw lx ly lz b">ValueListenable</code>(在我们的例子中是<code class="fe lw lx ly lz b">notifier</code>)改变值时，它会被重画:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/c7db6ff4aa13797e2ca2bc836f0996e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwNb_uiuCgQpsUCSt8qaEw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/2a5979be707bebafb801624b03e332fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Hez2MDdGUgvGO_Ib7Ie9Q.png"/></div></div></figure><p id="9abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">ValueListenableBuilder</code>将自动注册为<code class="fe lw lx ly lz b">notifier</code>变更的监听器，每次变更时将执行<code class="fe lw lx ly lz b">builder</code>方法。所以现在，当我们按下按钮进行背景更改时，只有<code class="fe lw lx ly lz b">builder</code>方法部分会被执行，UI的这一部分会被重画——而不是整个屏幕。</p><p id="2686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您需要在应用程序的多个位置显示值的变化，在不同文件的不同部件中，会发生什么情况呢？当然，您不希望在小部件构造函数中传递这些值。</p><p id="9a0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们现在介绍<code class="fe lw lx ly lz b">InheritedWidget</code>的原因。</p><p id="23e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在其中定义一个<code class="fe lw lx ly lz b">ValueNotifier</code>，然后从UI的不同部分访问它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/df31f181e444313a521508cf91bbcd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h58nJEmyn3pwvJkMzNzuCQ.png"/></div></div></figure><p id="ccbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问<code class="fe lw lx ly lz b">InheritedWidget</code>字段的代码如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/d2640c8335f658473bc0ca45c46fcd6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPhfcDUBukQ_7ScmlHH_9A.png"/></div></div></figure><p id="3d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，它是这样说的:从<code class="fe lw lx ly lz b">builderContext</code>开始，在树中向上，找到一个<code class="fe lw lx ly lz b">InheritedWidgetWithNotifier</code>类型的<code class="fe lw lx ly lz b">InheritedWidget</code>。</p><p id="fdc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而现在，UI是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/6433107a08432c82fe8aeb9f72c80a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*d_-rCgZPlTHN8avv-Tv_dg.gif"/></div></figure><p id="865a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在，我们能够从不同的小部件访问<code class="fe lw lx ly lz b">ValueNotifier</code>。两个“条纹”都是从<code class="fe lw lx ly lz b">InheritedWidget</code>听<code class="fe lw lx ly lz b">ValueNotifier</code>的变化。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="91ee" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="dc83" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">任何事情<em class="nn">都可以用任何一种状态管理在Flutter中完成，但是<em class="nn">应该这样做吗？</em></em></p><p id="4b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于简单的应用程序，即使只使用有状态/继承的小部件也完全没问题，但是如果您正在制作具有大量屏幕和需要从多个小部件或屏幕获取的复杂状态的大型/复杂应用程序，您可能应该采用更高级的方法，如<a class="ae ky" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"> provider </a>或<a class="ae ky" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank"> bloc </a>。</p><p id="2af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>