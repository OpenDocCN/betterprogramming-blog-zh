<html>
<head>
<title>Approaching a Problem With Fresh Eyes and Testing Properly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用全新的视角处理问题，并正确测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/approaching-a-problem-with-fresh-eyes-and-testing-properly-88e1baf3578d?source=collection_archive---------17-----------------------#2019-12-16">https://betterprogramming.pub/approaching-a-problem-with-fresh-eyes-and-testing-properly-88e1baf3578d?source=collection_archive---------17-----------------------#2019-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bb66" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有时候解决问题的最好方法是休息一下</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/da038eab6d9d9c57070a58261cb483bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-70oIxlNkFLP1aKLxiXeaA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@olav_ahrens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">奥拉夫·阿伦斯·罗特内</a>在<a class="ae kv" href="https://unsplash.com/s/photos/problem-solving?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="e34c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">背景</h1><p id="ea3a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本周，我参加了纽约市编码员会议，了解二分搜索法树。我们学习了二分搜索法树、插入方法、广度优先搜索方法和深度优先搜索方法。Catherine关于二分搜索法树的博客很好地解释了二叉查找树的目的、概念和特征。</p><p id="6606" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">至于二叉查找树方法，这篇博客将深入探讨广度优先搜索方法(因为我相信有大量的资源已经涵盖了从零开始创建其他二叉查找树方法)。展示广度优先搜索树方法的目的是回顾正确测试的基本概念和编码时的心态。</p><p id="22a2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这听起来可能有点模糊——在这篇文章的结尾，你会确切地知道我的意思。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="6c47" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">递归…诅咒…离子…</h1><p id="1ab8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">将极大地帮助你理解这篇文章中的代码的一个关键概念是递归。如果这是你第一次听说这个概念，我强烈推荐你在继续之前阅读这个<a class="ae kv" href="https://medium.com/free-code-camp/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9" rel="noopener">博客</a>。你不需要理解如何实现递归本身(虽然我推荐它，因为一旦你习惯了它，它实际上很有趣)，但是你需要理解这个概念本身。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="bd90" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">广度优先搜索方法</h1><p id="0129" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">广度优先搜索方法是为该课程创建的最后一种方法。以前，所有其他方法(即插入、包含和深度优先搜索)都是用递归创建的。遵循这个共同的思路，我和我的结对编程伙伴同意我们应该递归地这样做。下面的代码是我们宽度优先搜索方法的递归方法。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="5aed" class="ng kx iq nc b gy nh ni l nj nk">class BinarySearchTree {<br/>  constructor(val) {<br/>    this.val = val;<br/>    this.left = null;<br/>    this.right = null;<br/>  }<br/>  <br/>  //inserstion method<br/>  insert(data) {<br/>    //your code goes here!<br/>    if (data &gt; this.val) {<br/>      if (this.right != null)<br/>        this.right.insert(data);<br/>      else<br/>        this.right = new BinarySearchTree(data);<br/>    }<br/>    else if (data &lt; this.val) {<br/>      if (this.left != null)<br/>        this.left.insert(data);<br/>      else<br/>        this.left = new BinarySearchTree(data);<br/>    }<br/>  }<br/>  <br/>  //breadth-first search method<br/>  bfs(arr=[this.val]) {<br/>    if(this.left) {<br/>      arr.push(this.left.val);<br/>    }<br/>    if(this.right){<br/>      arr.push(this.right.val)<br/>    }<br/>    (this.left)?this.left.bfs(arr):null;<br/>    (this.right)?this.right.bfs(arr):null;    <br/>    return arr;<br/>  }<br/>  <br/>}</span></pre><p id="f8c1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的要点中，插入方法在第9–23行。我们将多次调用这个实例方法，因此您可以看到在幕后发生了什么，并作为递归如何工作的一个例子。让我们使用<code class="fe nl nm nn nc b">insert</code>方法创建二叉查找树:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="bd56" class="ng kx iq nc b gy nh ni l nj nk">//Creating our binary search tree<br/>let bst = new BinarySearchTree(13);<br/>bst.insert(8);<br/>bst.insert(15);<br/>bst.insert(7);<br/>bst.insert(10);<br/>bst.insert(20);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/49be4ad8041255c7fbc9d3ccd2ae303a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*ZHFQqUOwaiVHFbS8fnTXKw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">二叉查找树的创建</p></figure><p id="75e7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">根据<code class="fe nl nm nn nc b">insert</code>方法的顺序，这就是我们的二叉查找树目前的样子。呼吸优先搜索方法应该按照从上到下、从左到右的顺序返回一个值数组。这意味着该方法应该为我们的二叉查找树输出<code class="fe nl nm nn nc b">[13, 8, 15, 7, 10, 20]</code>。让我们调用广度优先搜索方法和console.log结果来确认它。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="6cdb" class="ng kx iq nc b gy nh ni l nj nk">//invoking the breadth-first search method and printing out the result<br/>console.log(bst.bfs());<br/>//[ 13, 8, 15, 7, 10, 20 ]</span></pre><p id="9ab1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看起来该方法正在按预期工作！</p><p id="b7f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是为了确保万无一失，我和我的搭档在树中又插入了两个数字，增加了额外的高度，以测试我们的函数是否正常工作。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="03a9" class="ng kx iq nc b gy nh ni l nj nk">//inserting two more values to test the breadth-first search function<br/>bst.insert(14)<br/>bst.insert(22)</span></pre><p id="2d41" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当前树如下图所示。红色的圆圈和线条是新添加的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/bc2aa821489f88e2c6a8f4a6c1c4bc83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fM2yknx-J4TgTSBhrLw_w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">向当前二叉查找树插入两个新值(即14和22)</p></figure><p id="0fde" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">随着二叉查找树的更新，广度优先搜索方法应该返回<code class="fe nl nm nn nc b">[13, 8, 15, 7, 10, 14, 20, 22]</code>。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="bbdf" class="ng kx iq nc b gy nh ni l nj nk">//testing breadth-first search method with newly inserted values<br/>console.log(bst.bfs());<br/>// [ 13, 8, 15, 7, 10, 14, 20, 22 ]</span></pre><p id="7f58" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看起来广度优先搜索方法正在如预期的那样工作！或者是？</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="d022" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">递归的细微差别</h1><p id="ea34" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我们在meetup中与其他人分享广度优先搜索功能时，似乎只有我和我的伙伴使用递归创建了这个功能。Eric，这次活动的共同主持人/老师，对我们的代码很好奇，因为他只见过使用队列堆栈的方法。</p><p id="38b6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在检查了我们的代码后，他说，理论上，它不应该工作。他让我们在二叉查找树中插入一个12，并再次运行广度优先搜索方法。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="f9ed" class="ng kx iq nc b gy nh ni l nj nk">//inserting the value 12 to test the breadth-first search function again<br/>bst.insert(12)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/d584814da80fc75d35858c615be9fa62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dk0Opx8_tluw8yH6oMsrFw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">插入12后的当前二叉查找树</p></figure><p id="74ba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上图是我们插入12后的二叉查找树。红色表示这是最新添加到树中的数字。</p><p id="d2fa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了测试广度优先搜索方法，应该打印出<code class="fe nl nm nn nc b">[13, 8, 15, 7, 10, 14, 20, 12, 22]</code>。让我们用当前树再次运行这个方法，并打印出结果。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="4172" class="ng kx iq nc b gy nh ni l nj nk">//printing out the array after inserting 12 in the binary search tree<br/>console.log(bst.bfs());<br/>// [ 13, 8, 15, 7, 10, 12, 14, 20, 22 ]</span></pre><p id="9f98" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看来控制台日志<em class="nr">并没有</em> <strong class="lq ir"> <em class="nr"> </em> </strong> <em class="nr">符合我们的预期输出。不用说，我和我的搭档都感到震惊和困惑。我问Eric是什么促使他认为这个功能不起作用。他回应道:</em></p><blockquote class="ns nt nu"><p id="82d3" class="lo lp nr lq b lr mk jr lt lu ml ju lw nv mm lz ma nw mn md me nx mo mh mi mj ij bi translated">由于递归的性质，每当函数再次递归调用自身时，递归调用不需要知道该递归调用范围之外的信息。</p></blockquote><p id="629f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们通过使用我们当前的广度优先搜索方法来分解他的意思。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="5dcd" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">分解递归广度优先搜索方法</h1><p id="f740" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了解开Eric的陈述，我们要看看递归广度优先搜索方法在做什么。为了便于阅读，我将复制并粘贴本节中的方法和我们当前的树。注意，<code class="fe nl nm nn nc b">bfs</code>方法指的是广度优先搜索方法。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="9475" class="ng kx iq nc b gy nh ni l nj nk">bfs(arr=[this.val]) {<br/>  if(this.left) {<br/>    arr.push(this.left.val);<br/>  }<br/>  if(this.right){<br/>    arr.push(this.right.val)<br/>  }<br/>  (this.left)?this.left.bfs(arr):null;<br/>  (this.right)?this.right.bfs(arr):null;    <br/>  return arr;<br/>}<br/><br/>//invoking the function<br/>bst.bfs()2 ]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/d8c98e8e8d43fa8e1fa115ad97784f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOaXZqnzOPKd2XRnYICa8g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当前二叉查找树</p></figure><p id="5968" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第一个递归调用语句中，考虑了整个树(即，在根节点)。这意味着<code class="fe nl nm nn nc b">arr</code>已经有了<code class="fe nl nm nn nc b">[13]</code>,因为这是调用<code class="fe nl nm nn nc b">bfs</code>方法时的默认参数。在第2–7行，有两个if语句分别确认左右子树是否存在。如果是，则将这两个子树的值推入<code class="fe nl nm nn nc b">arr</code>。在这种情况下，两个子树都存在，这意味着8和15被推入。现在，<code class="fe nl nm nn nc b">arr = [13, 8, 5]</code>。到目前为止一切顺利。第8行是我们递归调用<code class="fe nl nm nn nc b">bfs</code>方法的地方。现在我们必须在继续之前解决这个递归调用。</p><p id="d261" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第二个递归调用语句中，左子树被考虑在内(即<code class="fe nl nm nn nc b">[8, 7, null, null, 10, null, 12]</code>)，而<code class="fe nl nm nn nc b">arr</code>作为参数被传入。注意，在第二次递归调用中，<code class="fe nl nm nn nc b">arr = [13, 8, 15]</code>，保留了我们从第一次递归调用中推出的内容。</p><p id="a68d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，重复第二行到第七行的逻辑。由于左右子树都存在，我们从左边推<code class="fe nl nm nn nc b">val</code>并骑子树。现在，<code class="fe nl nm nn nc b">arr = [13, 8, 15, 7, 10]</code>。在第八行，我们再次递归调用了<code class="fe nl nm nn nc b">bfs</code>方法——现在我们必须在继续之前解决这个递归调用。</p><p id="fdf0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第三个递归调用语句中，左子树被考虑在内(即<code class="fe nl nm nn nc b">[7, null, null]</code>)，并且<code class="fe nl nm nn nc b">arr</code>作为参数被传入。<code class="fe nl nm nn nc b">arr</code>当前为本次通话的<code class="fe nl nm nn nc b">[13, 8, 15, 7, 10]</code>。因为这个子树没有左或右子树，所以不调用方法中的任何逻辑，返回<code class="fe nl nm nn nc b">arr</code>。既然这个递归调用已经解决了，我们可以从第二个递归调用语句继续到第九行。</p><p id="3f70" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">回到第二个递归调用语句，因为第八行已经解析，我们移到第九行，再次递归调用<code class="fe nl nm nn nc b">bfs</code>方法，但是是针对右边的子树。现在我们必须在继续之前解决这个递归调用。</p><p id="f67d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第四个递归调用语句中，考虑了右边的子树(即<code class="fe nl nm nn nc b">[10, null, 12]</code>),<code class="fe nl nm nn nc b">arr</code>仍然是<code class="fe nl nm nn nc b">[13, 8, 15, 7, 10]</code>。第二到第四行被跳过，因为这个子树没有左子树，但是第五到第七行被调用。右边子树的值是12，在哪里推入<code class="fe nl nm nn nc b">arr</code>。这现在使得<code class="fe nl nm nn nc b">arr = [13, 8, 15, 7, 10, 12]</code>。</p><p id="5909" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nr">这就是错误的根本原因所在。</em></p><p id="efef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要读的东西太多了，所以如果需要的话，可以休息一下！</p><p id="d225" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">递归<code class="fe nl nm nn nc b">bfs</code>方法的流程首先关注根节点左边的子树。在遍历了左子树中的所有子树之后，它将关注右子树中的所有子树。这个<code class="fe nl nm nn nc b">bfs</code>方法流程是先向左倾斜，然后向右倾斜。而应该是从上到下，从左到右。</p><p id="7da9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们再来看看第二个递归调用。至此，<code class="fe nl nm nn nc b">arr = [13, 8, 15, 7, 10]</code>。它应该按下的下一个数字是14，位于右边的子树中。然而，这是不可能的，因为第二次递归调用期间的子树是[8，7，null，null，10，null 12]。为了推送14，我们需要引用原始树，这个引用超出了第二个递归调用的范围。这就是埃里克的意思</p><blockquote class="ns nt nu"><p id="866b" class="lo lp nr lq b lr mk jr lt lu ml ju lw nv mm lz ma nw mn md me nx mo mh mi mj ij bi translated">…递归调用不需要知道递归调用范围之外的信息。</p></blockquote><p id="aee2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以在<code class="fe nl nm nn nc b">bfs</code>方法中传递原始的二叉查找树作为参数，但是每当我们递归调用函数时，我需要以某种方式跟踪高度以及我已经遍历了哪些子树，以便不会意外地重复任何数字。这将是不必要的困难。</p><p id="a3f0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这表明递归可能不是创建<code class="fe nl nm nn nc b">bfs</code>方法的最佳方法。最后，我和我的结对编程伙伴改用了队列堆栈方法。我不会把我们的解决方案贴在这里，尽管我建议你先自己想办法解决。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="4f13" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">关键要点</h1><p id="61bb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我从这次经历中学到了两个教训:</p><h2 id="bde4" class="ng kx iq bd ky nz oa dn lc ob oc dp lg lx od oe li mb of og lk mf oh oi lm oj bi translated">1.不要陷入与前面问题相同的实现中</h2><p id="2744" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我和我的搭档立即尝试用递归创建<code class="fe nl nm nn nc b">bfs</code>方法，因为之前所有其他的二叉查找树方法都使用了递归。我们隐含地假设二叉查找树的所有方法都是基于递归的，这是不正确的。相反，我们应该后退一步，用全新的思维对方法进行伪代码化，并认识到递归只是一种解决方案，而不是解决方案。</p><h2 id="15fe" class="ng kx iq bd ky nz oa dn lc ob oc dp lg lx od oe li mb of og lk mf oh oi lm oj bi translated">2.测试每一个可能的场景</h2><p id="e216" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我和我的伙伴插入两个值(即14和22)来测试我们的<code class="fe nl nm nn nc b">bfs</code>方法时，它是成功的，我们就到此为止了。我们没有注意到这两个值被插入到了右边的子树中，这在默认情况下可以与我们的<code class="fe nl nm nn nc b">bfs</code>方法一起工作。我们没有测试在左子树中插入一个值的情况，因为我们太兴奋了，以至于想出了<code class="fe nl nm nn nc b">bfs</code>方法。我知道几乎不可能想出每一个潜在的测试用例，但是至少要有覆盖方法本身不同方面的各种测试用例。</p></div></div>    
</body>
</html>