<html>
<head>
<title>Build a SwiftUI Animal Crossing Application (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建SwiftUI动物穿越应用程序(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-swiftui-animal-crossing-application-part-2-82b4ac6695e6?source=collection_archive---------7-----------------------#2020-05-08">https://betterprogramming.pub/build-a-swiftui-animal-crossing-application-part-2-82b4ac6695e6?source=collection_archive---------7-----------------------#2020-05-08</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9009" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">对视图和视图模型的深入研究</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d49a9396202a9a2bbbd6a122a7bc040d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uywS4tXTX02BS0_m2j_-EQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者照片。</p></figure><p id="63ed" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">本系列文章的第一部分向您介绍了应用程序的本质及其架构的核心。</p><p id="58ad" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这一章中，我们将深入了解组成应用程序的各种视图，以及它们如何与我们的数据源和视图模型一起工作。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="59f2" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">案例研究</h1><p id="0159" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">让我们来看看<code class="fe na nb nc nd b">ItemsListView</code>和<code class="fe na nb nc nd b">ItemsViewModel</code>。这里有一个简短的视频，让你看看这个屏幕的所有功能:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ne"><img src="../Images/ef8fe2122f324261068ae8cf6b6bb9a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/1*Fk_Q62dvUdIZNwMw30lvnA.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">项目列表视图</p></figure><p id="06b4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们需要考虑屏幕的几个特性:</p><ul class=""><li id="53e7" class="nf ng iu lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">它显示特定项目类别中的项目列表。</li><li id="79e9" class="nf ng iu lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">它提供了两种显示模式:紧凑行和大行。</li><li id="9ea9" class="nf ng iu lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们可以根据物品的不同属性对它们进行分类。</li><li id="f227" class="nf ng iu lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们可以从该列表中搜索项目。</li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="db87" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">ItemsViewModel</h1><p id="8347" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">列出所有这些之后，我们现在可以开始制作我们的<code class="fe na nb nc nd b">ItemsViewModel</code>,目标是从我们的后端/数据源准备和获取我们需要的所有数据(在这种情况下，从特定类别中获取项目),然后计算这些数据，使它们准备好被我们的视图显示。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="b931" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们从视图模型开始。因为我们知道SwiftUI视图将使用它，所以我们将其设为<code class="fe na nb nc nd b">ObservableObject</code>。这意味着我们现在可以将属性包装在一个<code class="fe na nb nc nd b"><a class="ae lv" href="https://developer.apple.com/documentation/combine/published" rel="noopener ugc nofollow" target="_blank">Published</a></code>属性包装器中。SwiftUI视图将能够订阅这些属性，并在它们发生变化时更新相关视图。</p><p id="62ad" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">正如我们在特性列表中看到的，视图模型需要为我们提供一个列表<code class="fe na nb nc nd b">Items</code>、一个列表<code class="fe na nb nc nd b">sortedItems</code>和一个列表<code class="fe na nb nc nd b">searchedItems</code>。它还需要保存我们将绑定到用于搜索界面的TextField的<code class="fe na nb nc nd b">searchText</code>。</p><p id="725b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe na nb nc nd b">itemCancellable</code>和<code class="fe na nb nc nd b">searchCancellable</code>来自联合收割机的<code class="fe na nb nc nd b">Cancellable</code>。我们将使用它们来保存我们的<code class="fe na nb nc nd b">Subscriber</code>,我们将从后端获取数据。</p><p id="ac94" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在让我们看看在我们的<code class="fe na nb nc nd b">ItemsViewModel</code>的初始化器中发生了什么:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="5e70" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在初始化器中，我们将把两个<code class="fe na nb nc nd b">subscribers</code>都连接到它们的<code class="fe na nb nc nd b">publisher</code>。</p><p id="0b96" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于<code class="fe na nb nc nd b">searchCancellable</code>，我们想认购我们的<code class="fe na nb nc nd b">searchText</code> <code class="fe na nb nc nd b">String</code>房产。为什么？因为它允许我们在<code class="fe na nb nc nd b">TextField</code>中接收用户输入的新值。让我们看看联合收割机流程:</p><ol class=""><li id="4bf7" class="nf ng iu lb b lc ld lf lg li nh lm ni lq nj lu nv nl nm nn bi translated">我们想先<code class="fe na nb nc nd b">debounce</code>一下。这意味着我们希望等待发布者暂停事件的交付。我们希望只在用户停止输入300毫秒后接收事件。</li><li id="353d" class="nf ng iu lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">然后我们删除重复的。如果我们多次收到相同的文本，我们不希望在数据源中触发对相同值的搜索。</li><li id="33bb" class="nf ng iu lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">如果文本为空，我们也不想触发任何搜索。</li><li id="7674" class="nf ng iu lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">最后，我们使用<code class="fe na nb nc nd b">map</code>执行非常简单的搜索功能。我们的函数将接受文本输入并过滤我们的项目，只返回一个具有匹配名称的项目:</li></ol><pre class="kk kl km kn gu nw nd nx ny aw nz bi"><span id="c50d" class="oa me iu nd b gz ob oc l od oe">private func items(with string: String) -&gt; [Item] {<br/>     items.filter {<br/>        $0.name.lowercased().contains(string.lowercased())<br/>     }<br/>}</span></pre><p id="54c0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">5.我们使用<code class="fe na nb nc nd b">sink</code>(我们也可以使用<code class="fe na nb nc nd b">assign</code>)将收到的最终值赋给我们的<code class="fe na nb nc nd b">ItemsViewModel</code> <code class="fe na nb nc nd b">searchItems</code> published属性。</p><p id="7fe4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">6.UI中使用视图模型中的<code class="fe na nb nc nd b">searchItems</code>的部分将得到更新。</p><p id="367a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们的第二个<code class="fe na nb nc nd b">Cancellable</code>，实际获取所有项目的那个，要简单得多。我们有一个名为Items的共享对象，它有一个published <code class="fe na nb nc nd b">categories</code>属性，如下所示:</p><pre class="kk kl km kn gu nw nd nx ny aw nz bi"><span id="2b2f" class="oa me iu nd b gz ob oc l od oe">public class Items: ObservableObject {<br/>      public static let shared = Items()<br/>      @Published public var categories: [Category: [Item]] = [:]</span></pre><p id="2502" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">发布的部分很重要，因为它是一个服务/ <code class="fe na nb nc nd b">observableObject</code>，我们不知道它何时何地会被更新。因此，我们希望确保收到最新的值。</p><p id="7fea" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这就是为什么，在我们的<code class="fe na nb nc nd b">ItemsViewModel</code>中，我们订阅了<code class="fe na nb nc nd b">categories</code>，并在收到的值发生变化时对其赋值(无论如何，我们都会在第一次订阅时收到它)。</p><p id="d9e1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我花时间解释所有的<code class="fe na nb nc nd b">Combine</code>流程，因为它最终也会帮助我。这是一种与更标准的编程技能截然不同的心态。一开始我觉得一点也不自然。但是最后，它看起来比链接函数或完成闭包要干净得多。我们可以一次清楚地看到整个订户操作——从初始值到转换，直到赋值。</p><p id="84dd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们还遗漏了一个部分:排序。大部分都很无聊，我就不花时间在这上面了。但是我把<code class="fe na nb nc nd b">ItemsViewModel</code>留在这里作为完整的要点，这样你就可以看到它是如何完成的。这很重要，因为我们将在下一部分的<code class="fe na nb nc nd b">View</code>中使用它:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="88e7" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">项目列表视图</h1><p id="7665" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">现在我们对视图模型有了相当准确的理解，让我们开始视图:</p><pre class="kk kl km kn gu nw nd nx ny aw nz bi"><span id="956d" class="oa me iu nd b gz ob oc l od oe">struct ItemsListView: View {<br/>    @ObservedObject var viewModel: ItemsViewModel<br/>    @State private var showSortSheet = false<br/>    @State private var itemRowsDisplayMode: ItemRowView.DisplayMode = .large</span></pre><p id="8387" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">正如我们在屏幕的案例研究中所提到的，我们需要在视图模型上添加一些东西。<code class="fe na nb nc nd b">showShortSheet</code>状态跟踪分拣单。稍后点击排序按钮时，我们会将其设置为<code class="fe na nb nc nd b">true</code>。并且<code class="fe na nb nc nd b">itemRowsDisplayMode</code>跟踪当前行的显示模式:<code class="fe na nb nc nd b">Compact</code>或<code class="fe na nb nc nd b">Large</code>。</p><p id="9535" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在顶部，我们还有我们的<code class="fe na nb nc nd b">ItemsViewModel</code>。在应用程序的当前流程中，我们有一个类别屏幕，它负责用适当的<code class="fe na nb nc nd b">ItemsViewModel</code>创建<code class="fe na nb nc nd b">ItemsListView</code>，因为父类将提供类别。</p><p id="496c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以你可以想象我们有一个看起来像这样的<code class="fe na nb nc nd b">CategoryRowView</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="9475" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在回到我们的<code class="fe na nb nc nd b">ItemsListView</code>。为了显示适当的项目，我们有一个计算属性:<code class="fe na nb nc nd b">currentItems</code>。每当我们的视图模型的发布属性改变时，我们的视图体将被计算并使用适当的项目，因为<code class="fe na nb nc nd b">currentItems</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="9577" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们来看看我们的<code class="fe na nb nc nd b">View</code>的身体:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="cb6c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这里有一些新的东西。我们使用<code class="fe na nb nc nd b">List</code>，因为它是合适的组件，我们在案例研究中看到了这一点。包装在<code class="fe na nb nc nd b">ScrollView</code>中的<code class="fe na nb nc nd b">VStack</code>不适合使用。因为这是一个很长的条目列表，我们想使用<code class="fe na nb nc nd b">List</code>(目前由UITableView支持)。它重用它的行，并且只在需要的时候才让它们出队(当它将要显示在屏幕上的时候)。</p><p id="f701" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我知道这听起来对你们几乎所有人来说都是显而易见的，但是由于SwiftUI允许完全的自由，提醒一下这一点可能是个好主意。</p><p id="ae99" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">正如我们看到的，我们需要一个<code class="fe na nb nc nd b">TextField</code>来进行搜索。由于我们希望它看起来像一个搜索栏(由于某种原因，SwiftUI缺少一个到<code class="fe na nb nc nd b">UISearchBar</code>的桥梁)，我将它包装在一个名为<code class="fe na nb nc nd b">SearchField</code>的视图中。</p><p id="a7cd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">视图看起来像这样:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj of"><img src="../Images/2e173bdae456f3a99d330d99b9f66ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TeJNTgj-Yb_GjglCgPr0GQ.png"/></div></div></figure><p id="b2bc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">借助SwiftUI及其预览的强大功能，拥有自包含视图并预览其所有状态变得超级简单。在这种情况下，正如你在上面的截图中看到的，我预览了正常状态和编辑状态。</p><p id="df6c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">预览是一个非常强大的工具。我不经常使用它们，但是对于那些独立的视图，比如我们的搜索栏，使用它们是很有意义的。然后，您可以非常快速地在UI上迭代各种状态。</p><p id="e940" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">回到我们的<code class="fe na nb nc nd b">ItemsListView</code>。下一部分是对我们的计算属性<code class="fe na nb nc nd b">currentItems</code>使用<code class="fe na nb nc nd b">ForEach</code>。正如我之前说过的，只要用户触发了对<code class="fe na nb nc nd b">currentItems</code>的更改(因为用户开始搜索或排序项目)，就会触发我们身体的重新加载(因为我们的<code class="fe na nb nc nd b">ItemsViewModel</code>已经发布了属性)。因此，我们的列表将始终显示正确和相关的项目。</p><p id="8808" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后我们显示我们的<code class="fe na nb nc nd b">ItemRowView</code>，这个视图将显示列表中的一个条目。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/fcb78675398b9f042fc03c858306d0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tw4LNmeZgZakz6wBIyX82w.png"/></div></div></figure><p id="af6d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有了预览功能，并且因为我们在案例研究中看到该行应该有一个紧凑模式和一个大模式，所以我们可以同时显示这两种模式。当你在UI上工作时非常方便。</p><p id="0458" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于<code class="fe na nb nc nd b"><a class="ae lv" href="https://github.com/Dimillian/ACHNBrowserUI/blob/master/ACHNBrowserUI/ACHNBrowserUI/views/items/ItemRowView.swift" rel="noopener ugc nofollow" target="_blank">ItemRowView</a></code>，我就不多赘述了。你可以在我们的GitHub上找到代码。仔细看看enum <code class="fe na nb nc nd b">DisplayMode</code>就知道了。<code class="fe na nb nc nd b">ItemRowView</code>具有这种类型的属性，因此父视图可以决定其显示模式。</p><p id="5782" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">回到<code class="fe na nb nc nd b">ItemsListView</code>的身上。您会注意到我们在<code class="fe na nb nc nd b">NavigationLink</code>中包装了我们的行。因此，当点击该行时，它将打开带有选定项目的<code class="fe na nb nc nd b">ItemDetailView</code>:</p><pre class="kk kl km kn gu nw nd nx ny aw nz bi"><span id="0e66" class="oa me iu nd b gz ob oc l od oe">NavigationLink(destination: ItemDetailView(item: item)) {<br/>    ItemRowView(displayMode: self.itemRowsDisplayMode, item: item)<br/>  }<br/>}</span></pre><p id="ef66" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如你所见，我们使用<code class="fe na nb nc nd b">ItemsListView</code>的当前<code class="fe na nb nc nd b">displayMode</code>。</p><h2 id="3eef" class="oa me iu bd mf oh oi dn mj oj ok dp mn li ol om mp lm on oo mr lq op oq mt or bi translated">但是我们如何改变显示模式呢？</h2><p id="351e" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">借助<code class="fe na nb nc nd b">State</code>属性包装器的强大功能，我们之前已经看到:</p><pre class="kk kl km kn gu nw nd nx ny aw nz bi"><span id="298f" class="oa me iu nd b gz ob oc l od oe">@State private var itemRowsDisplayMode: ItemRowView.DisplayMode</span></pre><p id="3f37" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以现在缺少的部分是触发变化。如果你回头看看我们的<code class="fe na nb nc nd b">ItemsListView</code>的身体，你会注意到这样的东西:</p><pre class="kk kl km kn gu nw nd nx ny aw nz bi"><span id="381a" class="oa me iu nd b gz ob oc l od oe">.navigationBarItems(trailing: HStack(spacing: 16) { <br/>                                 layoutButton <br/>                                 sortButton <br/>                               }<br/>                    )</span></pre><p id="9f32" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有了列表中的这个修饰符，我们将添加两个我们需要的按钮:改变显示模式和排序按钮到我们当前视图的导航栏中。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj os"><img src="../Images/5db29eca27e3625b3bbd5cb28defc253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9rNAymFu6wIbqXxsnXlIQ.png"/></div></div></figure><p id="2b77" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们看看两个计算视图<code class="fe na nb nc nd b">layoutButton</code>和<code class="fe na nb nc nd b">sortButton</code>的代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="8e19" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">每当您觉得您的视图体变得阻塞时，不要犹豫提取视图的一部分作为计算属性或者创建一个新的视图结构。你的身体应该始终保持小巧易读。在SwiftUI中制作独立的组件/视图比在UIKit中要容易和快速得多。</p><p id="9e91" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这两个按钮中的操作非常简单。<code class="fe na nb nc nd b">sortButton</code>将切换控制我们排序表的<code class="fe na nb nc nd b">Bool</code>，如果你回头看看我们的视图体，我们有这样一行:</p><pre class="kk kl km kn gu nw nd nx ny aw nz bi"><span id="871d" class="oa me iu nd b gz ob oc l od oe">.actionSheet(isPresented: $showSortSheet, content: { self.sortSheet })</span></pre><p id="d281" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因此它将显示由属性<code class="fe na nb nc nd b">sortSheet</code>计算的<code class="fe na nb nc nd b">ActionSheet</code>，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="835e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">它构造并返回我们的排序<code class="fe na nb nc nd b">ActionSheet</code>。每当我们在这个<code class="fe na nb nc nd b">ActionSheet</code>中选择一个动作时，它将在我们的<code class="fe na nb nc nd b">ItemsViewModel</code>上设置排序，这将在这个视图模型中设置我们的<code class="fe na nb nc nd b">sortedItems</code>发布属性，并触发我们的<code class="fe na nb nc nd b">currentItems</code>的更新。这就是你的排序逻辑。</p><p id="9cee" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">而<code class="fe na nb nc nd b">layoutButton</code>就简单多了。它只是将当前的<code class="fe na nb nc nd b">displayMode</code>更改为另一个。它将触发所有行的更新，并以新的显示模式显示它们。</p><p id="944b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">大概就是这样。以下是整个<code class="fe na nb nc nd b">ItemsListView</code>的要点，供参考:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5762" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="0dde" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">感谢阅读！</p><p id="fef6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我希望您喜欢这个系列的第二部分，并欢迎您的所有反馈。我试图解释一切，以便对iOS编程和SwiftUI的初学者以及想在这里抓住一些花边新闻的老手有所帮助。</p><p id="db5e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">第3部分应该是关于更复杂的视图布局和动画——一个稍微高级一点的主题。</p><p id="8b82" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">回头见！</p></div></div>    
</body>
</html>