<html>
<head>
<title>How to Deploy Portus and Docker Registry in Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swarm中部署Portus和Docker注册表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-deploy-portus-in-swam-a3b71c7519b5?source=collection_archive---------1-----------------------#2019-12-21">https://betterprogramming.pub/how-to-deploy-portus-in-swam-a3b71c7519b5?source=collection_archive---------1-----------------------#2019-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c15c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Portus是下一代Docker注册中心的开源授权服务和用户界面</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/441f700e784957d1794aed2ee24d626a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wg3wqp5PPJ5dUWgwNE-PFw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sir_moon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">月亮</a>在<a class="ae ky" href="https://unsplash.com/s/photos/swarm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">破浪</a>的照片</p></figure><p id="e862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">托管你自己的私有<a class="ae ky" href="https://docs.docker.com/registry/" rel="noopener ugc nofollow" target="_blank"> Docker注册表</a>是一个相对简单的任务，只要执行一个<code class="fe lv lw lx ly b">docker</code>命令或者在<code class="fe lv lw lx ly b">docker</code>命令变成一个长命令的情况下创建一个<code class="fe lv lw lx ly b">docker-compose</code>文件就可以了。</p><p id="36ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，Docker Registry没有提供一个复杂的UI来查看和浏览托管的Docker图像。</p><p id="b77b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，没有内置的用户身份验证和用户操作授权功能。(Docker注册表只提供基本的auth。)</p><p id="6a6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Docker Registry可以配置/扩展为支持用户认证和授权。可以用来扩展Docker Registry以提供这些特性和更多特性的开源项目之一是<a class="ae ky" href="https://github.com/SUSE/Portus" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> Portus </em> </a>。</p><p id="6f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释如何部署Docker注册中心，并使用Portus扩展它以提供以下特性:</p><ul class=""><li id="2e16" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">用户认证:只有通过认证的用户才可以使用UI并将Docker图像推送到注册中心。</li><li id="e534" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">用户授权:推和拉操作在执行之前都是经过授权的。</li><li id="f039" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">经过验证的用户可以搜索Docker图像。</li></ul><p id="e05e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用<a class="ae ky" href="https://github.com/wshihadeh/swarm_orca" rel="noopener ugc nofollow" target="_blank"> Swarm Orca </a>作为编排和部署工具来部署提议的解决方案。</p><p id="0e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，Swarm Orca是一个Ruby gem，可以帮助部署应用程序和编排Docker部署到集群。(你可以查看我的<a class="ae ky" href="https://medium.com/@wshihadeh/orchestrating-rails-docker-deployment-in-swarm-474aa6b8d35b" rel="noopener">帖子</a>了解更多关于这个工具的信息。)</p><div class="mo mp gp gr mq mr"><a href="https://medium.com/faun/orchestrating-rails-docker-deployment-in-swarm-474aa6b8d35b" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">在Swarm中协调Rails Docker部署</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">使用swarm orca gem简化docker swarm部署</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">medium.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ks mr"/></div></div></a></div><p id="2f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够实现上述堆栈，我们需要使用Swarm Orca部署以下服务:</p><ul class=""><li id="23c1" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">Docker注册表</li><li id="2720" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">葡萄牙语</li><li id="c6e5" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">NGINX</li></ul><p id="032c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本地环境，我们还需要以下依赖项:</p><ul class=""><li id="4d4e" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">MySQL:这是Portus能够持久保存用户信息的依赖项。</li><li id="47fb" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">LDAP服务器:用于管理用户帐户。</li><li id="c87e" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">LDAP服务器管理:LDAP服务器的管理UI界面。</li></ul><p id="4929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然现在已经清楚了部署需要什么服务，让我们从部署依赖项开始。第一步是使用下面的命令创建一个新的Swarm Orca项目:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="6fea" class="nk nl it ly b gy nm nn l no np">$&gt; gem instal swarm_orca<br/>$&gt; orca new platform_services wshihadeh platform</span></pre><p id="29b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，默认项目包括我们的堆栈所需的两个服务的堆栈，MySQL和NGINX。</p><p id="aca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是为<code class="fe lv lw lx ly b">mysql</code>服务渲染的swarm堆栈(您可以替换堆栈中的变量，并使用Docker命令部署它)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="ad41" class="nz nl it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated"><strong class="ak"> LDAP </strong></h1><p id="9f45" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">我们需要LDAP服务器作为Portus管理本地环境中的用户帐户的依赖项。对于其他环境(尤其是生产环境)，您需要一个外部LDAP服务器。</p><p id="73e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个swarm堆栈文件，包含两个服务的定义，<code class="fe lv lw lx ly b">ldap server</code>和<code class="fe lv lw lx ly b">ldap admin interface</code>。在替换文件中的所有占位符后，您可以使用<code class="fe lv lw lx ly b">docker deploy</code>命令部署这个堆栈。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="67da" class="nz nl it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated"><strong class="ak"> Docker注册表</strong></h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ddff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述Docker栈可用于部署Docker注册应用程序。栈本身没什么特别的。但是，该堆栈允许按照下面的说明配置Docker注册中心来启用Portus集成。</p><p id="d474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">覆盖<code class="fe lv lw lx ly b">registry</code>命令，以便能够信任Portus的自签名证书。(如果您不使用自签名证书，则不需要这样做。)</p><p id="a65e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">init脚本将自签名证书复制到注册表容器内的信任路径，然后启动Docker注册表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="dd72" class="nk nl it bd oa ov ow dn oe ox oy dp oi li oz pa ok lm pb pc om lq pd pe oo pf bi translated"><strong class="ak">设置Docker注册表配置</strong></h2><p id="04e5" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">注册表配置文件涵盖多个主题或章节。</p><p id="cd5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一部分是存储部分。在此部分，我们可以选择是将图像保存在<code class="fe lv lw lx ly b">filesystem</code>还是<code class="fe lv lw lx ly b">cloud</code>中。第二部分用于设置注册中心<code class="fe lv lw lx ly b">http</code>端点配置。</p><p id="08d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三部分是<code class="fe lv lw lx ly b">auth</code>部分，在这个部分中，我们可以配置注册表认证方法。注册表支持三种类型的身份验证提供程序:</p><ul class=""><li id="b352" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">silly</code> : <strong class="lb iu"> </strong>这个<strong class="lb iu"> </strong>提供程序应该只用于测试或开发目的，因为它只检查授权头的存在，而不检查授权头的值。</li><li id="45de" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">htpasswd</code>:这个提供者允许我们使用Apache <code class="fe lv lw lx ly b">htpasswd</code>文件配置注册中心的基本认证。</li><li id="778a" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">token</code> : <strong class="lb iu"> </strong>这个提供者允许我们基于令牌将认证过程从Docker注册中心分离出来。(这是Portus集成所需的部分。)</li></ul><p id="2bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Portus提供了一个可以与Docker注册中心集成的认证系统，将认证和授权从Docker注册中心本身分离出来。</p><p id="346a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注册表配置文件的最后一部分是<code class="fe lv lw lx ly b">notifications</code>部分，我们在这里配置Docker注册表，以便在注册表事件被触发和执行时通知<code class="fe lv lw lx ly b">portus</code>。</p><p id="9972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是完整的注册表配置文件，包含上述所有部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果您对<code class="fe lv lw lx ly b">portus</code>域名使用HTTPS，上述文件中的URL需要更改。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="c5e9" class="nz nl it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated"><strong class="ak">葡萄牙语</strong></h1><p id="5604" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">堆栈中的最后一个服务是Portus应用程序本身，为了成功部署Portus <strong class="lb iu"> <em class="lz"> </em> </strong>并扩展Docker注册表，我们需要涵盖以下几点。</p><ul class=""><li id="2964" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">Portus</code>应用部署。</li><li id="8a7d" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">Portus和Docker注册表的NGINX配置。</li></ul><p id="2bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现第一点可以通过部署下面的Docker栈来完成。该堆栈将创建两个Docker服务，一个用于Portus web服务器，另一个用于处理异步作业的Portus后台作业。</p><p id="d0fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该堆栈提供了一种配置LDAP服务器身份验证和自动Docker映像清理的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b1a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe lv lw lx ly b">extra_host</code>部分仅在Portus的域名仅由<code class="fe lv lw lx ly b">/etc/hosts</code>管理且不包含在任何DNS服务器中的情况下才需要。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="7190" class="nz nl it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">NGINX配置</h1><p id="bb1a" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">Docker注册中心和Portus的NGINX配置可以合并，由相同的NGINX服务器定义提供服务。</p><p id="4f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以配置NGINX在同一个域名<code class="fe lv lw lx ly b">hub.shihadeh.intern</code>上为Portus用户界面和Docker API提供服务。服务器定义需要包括以下路径的路由:</p><ul class=""><li id="1daa" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">/v2/*</code>:对这个路径的请求是发送到Docker Registry API的请求，因此，它们应该被代理到Docker Registry服务。</li><li id="cb58" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">/v2/token</code>:请求此端点为认证过程生成令牌。这个请求应该由Portus来处理，因为Portus将基于LDAP认证而不是注册表来生成令牌。此端点需要从第一条路径中排除。</li><li id="da1a" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">Docker注册中心将调用这个端点来通知Portus关于注册中心的事件，比如推送图片或标签。</li><li id="5416" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">/</code>:这将作为根路由和上述路径不包括的所有端点。所有这些请求都将被代理给Portus，以便能够显示Portus用户界面并与之交互。</li></ul><p id="daab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的NGINX配置文件显示了<code class="fe lv lw lx ly b">hub.*</code>域名所需的NGINX配置。如上所述，该服务器定义对注册中心和Portus的代理请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="677a" class="nz nl it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated"><strong class="ak">蜂群部署</strong></h1><p id="f338" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">这篇文章中描述的步骤在<a class="ae ky" href="https://github.com/wshihadeh/platform_services" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中实现。您可以执行以下指令，将相同的堆栈重新部署到您的本地机器或集成新的环境。</p><p id="920d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">克隆回购。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="7f53" class="nk nl it ly b gy nm nn l no np">git clone <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:wshihadeh/platform_services.git</span></pre><p id="2fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为奥卡安装所需的宝石。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="604e" class="nk nl it ly b gy nm nn l no np">$&gt; cd platform_services/capistrano<br/>$&gt; gem install bundler<br/>$&gt; bundle install</span></pre><p id="016f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新本地环境文件<code class="fe lv lw lx ly b">capistrano/config/deploy/local.rb</code>中的以下配置项:</p><ul class=""><li id="1330" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">user</code>:这应该是你的用户名，</li><li id="e6b5" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">只有在使用<code class="fe lv lw lx ly b">/etc/hosts</code>管理DNS记录时，才需要<code class="fe lv lw lx ly b">registry_domain</code>和<code class="fe lv lw lx ly b">registry_ip</code>。否则，您可以删除它们。</li><li id="e6c8" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lv lw lx ly b">deploy_to</code>:更新该变量中的路径，并确保创建了该文件夹，以及<code class="fe lv lw lx ly b">local.rb</code>文件中提到的所有子文件夹，如<code class="fe lv lw lx ly b">config_path</code>。您还可以修改任何其他值来满足您的规范。</li></ul><p id="371e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要，请更新配置文件夹。Docker注册表配置存储在项目的根路径下的<code class="fe lv lw lx ly b">configs</code>文件夹中。您可以更新注册表配置文件以及创建自己的自签名证书。</p><p id="54c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要，更新NGINX配置。NGINX配置存储在项目根目录下的<code class="fe lv lw lx ly b">nginx</code>文件夹中。</p><p id="c13b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，Swarm Orca将在部署期间为NGINX构建Docker映像，因此如果您需要对NGINX配置进行任何更改，您需要检查<code class="fe lv lw lx ly b">nginx</code>下的文件并相应地修改它们。</p><h2 id="18ff" class="nk nl it bd oa ov ow dn oe ox oy dp oi li oz pa ok lm pb pc om lq pd pe oo pf bi translated">开始服务部署</h2><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="863d" class="nk nl it ly b gy nm nn l no np">SCM=copy bundle exec cap local deploy:setup<br/>SCM=copy bundle exec cap local copy_configs</span><span id="ed8b" class="nk nl it ly b gy pg nn l no np">SCM=copy bundle exec cap local deploy:ldap<br/>SCM=copy bundle exec cap local deploy:mysql<br/>SCM=copy bundle exec cap local deploy:registry<br/>SCM=copy bundle exec cap local deploy:portus<br/>SCM=copy bundle exec cap local deploy:nginx</span></pre><p id="2ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于LDAP服务器，您可以导入下面的<a class="ae ky" href="https://gist.github.com/wshihadeh/9056bd847d98485cd2d9f8862a601a2e" rel="noopener ugc nofollow" target="_blank">文件</a>来填充一些用户和组。</p><p id="c305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">docker login</code>命令进行测试:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="2ac5" class="nk nl it ly b gy nm nn l no np">docker login -u ${user} ${domain}</span></pre></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="839f" class="nz nl it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated"><strong class="ak">结论</strong></h1><p id="4055" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">出于安全原因，用认证和授权机制来保护私有Docker注册中心是非常重要的。</p><p id="963e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然Docker注册中心没有提供这些特性，但是可以通过使用<a class="ae ky" href="http://port.us.org/" rel="noopener ugc nofollow" target="_blank"> Portus </a>来扩展注册中心以支持这些特性。</p><p id="c7d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我解释了如何完成这项任务，并提供了一个本地部署的实现。</p></div></div>    
</body>
</html>