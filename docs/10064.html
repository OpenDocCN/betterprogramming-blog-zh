<html>
<head>
<title>Using TypeScript With React: A Step by Step Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将TypeScript与React一起使用:分步指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-typescript-with-react-a-step-by-step-guide-64f58cbbc004?source=collection_archive---------5-----------------------#2021-11-22">https://betterprogramming.pub/using-typescript-with-react-a-step-by-step-guide-64f58cbbc004?source=collection_archive---------5-----------------------#2021-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8d86" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解TypeScript中有关接口、枚举、类型别名、泛型、属性类型和函数的所有信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07b7e9b6613bb112967a6fc8fa97c6cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ba8MWIsQTd372gXTl6o5Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">科林·阿姆斯壮在<a class="ae ky" href="https://unsplash.com/s/photos/bouncer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="336b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用带有React的TypeScript开始一项新工作。我以前从来没有这样做过，但是我有单独使用两者的经验。我认为学习新东西的最好方法是把它教给其他人，所以这就是我在这里要尝试做的。</p><p id="d401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将构建一个夜总会客人名单应用程序，灵感来自赫伯特·沃尔弗森的<a class="ae ky" href="https://www.amazon.co.uk/dp/B09BK8Q6GY/ref=dp-kindle-redirect?_encoding=UTF8&amp;btkr=1" rel="noopener ugc nofollow" target="_blank"> <em class="lv">手把手</em>的一个例子。该应用程序将显示夜总会的所有参与者，每个人的名字都根据他们是否被允许进入、拒绝、禁止或添加到“特殊”客人列表中而着色。我们还会有一个添加新客人的表格。</a></p><p id="4e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript非常庞大，涵盖所有概念需要很长时间，所以我在这里的目的是坚持基础知识；提供一个基础，从这里你可以建立更先进的知识。我们将涉及的主题是接口、枚举、类型别名、泛型、属性类型和函数。</p><h2 id="1005" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">你需要知道的是</h2><p id="422d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">你必须知道反应；我不会解释的。你不需要知道任何打字稿。</p><p id="9679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以<a class="ae ky" href="https://github.com/skepticspectresceptre/react-typescript-nightclub" rel="noopener ugc nofollow" target="_blank">在这里</a>找到完成的代码。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="d6c0" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">创建新的TypeScript和React应用程序</h2><p id="14c5" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">使用<em class="lv"> Create-React App </em>进行设置很简单。在你的终端上运行这个。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="dfeb" class="lw lx it nc b gy ng nh l ni nj">npx create-react-app — template typescript nightclub</span></pre><p id="2b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="4c73" class="lw lx it nc b gy ng nh l ni nj">npm start</span></pre><h2 id="9820" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">领域建模</h2><p id="664a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当我开始一件新的事情时，我通常从领域建模开始。实际上，这意味着首先要定义应用程序的数据结构。</p><p id="fc96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是设计软件的好方法，因为它迫使你在编码前仔细考虑它的用法。有了预定义的类型，我们确切地知道我们需要做什么来支持它们，我们就不会陷入编写无用代码的陷阱(如果它与数据没有任何关系，为什么它会在那里？)，它帮助我们命名我们的组件和功能(因为我们知道领域)，并且它对其他开发人员来说是很好的文档。</p><p id="6734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nk nl nm nc b">src/</code>文件夹中创建一个<code class="fe nk nl nm nc b">types/</code>文件夹，并在其中添加一个名为<code class="fe nk nl nm nc b">index.ts</code>的文件。<code class="fe nk nl nm nc b">.ts</code>扩展名是我们用于普通类型脚本文件的扩展名。我们用<code class="fe nk nl nm nc b">.tsx</code>来表示反应。</p><h2 id="62e0" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">创建与会者界面</strong></h2><p id="37e0" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们从我们领域中最重要的部分开始:参与者。我们需要确切地知道关于他们的三件事:他们的名字、他们的年龄和他们所拥有的权限级别(允许、拒绝、禁止或特殊客人)。</p><p id="4f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在TpeScript中，捕捉这些信息的最佳方式是使用一个<em class="lv">接口</em>:一个封装了许多字段的结构，每个字段都有自己的类型。我们的与会者界面如下所示:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="d1c0" class="lw lx it nc b gy ng nh l ni nj">interface Attendee {<br/>    name: string,<br/>    age: number,<br/>    permission: string<br/>}</span></pre><p id="264e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这类似于javascript对象，但是有了TypeScript接口，我们获得了更大的能力。例如，我们现在可以告诉一个函数，我们希望它接受一个Attendee类型的参数。这是它的样子。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="93b5" class="lw lx it nc b gy ng nh l ni nj">const printAttendee = (attendee: Attendee) =&gt; {<br/>    console.log(attendee)<br/>}</span></pre><p id="0ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您试图用一个不同类型的参数(一个看起来不像上面的结构)调用它，您将得到一个错误消息。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="1f52" class="lw lx it nc b gy ng nh l ni nj">printAttendee({ name: 'John' });</span></pre><p id="9ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="4961" class="lw lx it nc b gy ng nh l ni nj">Argument of type '{ name: string; }' is not assignable to parameter of type 'Attendee'.<br/>  Type '{ name: string; }' is missing the following properties from type 'Attendee': age, permission</span></pre><p id="755a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这仍然会运行。TypeScript不同于Rust或Go，它仍然可以执行程序。但是只要注意它给你带来的错误，你就可以确信你正在按照最初的意图使用你的函数。</p><p id="8e79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，这也适用于返回类型。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="efc9" class="lw lx it nc b gy ng nh l ni nj">const changeAttendeeToBryan = (attendee: Attendee): Attendee =&gt; {<br/>    const newAttendee = { ...attendee, name: 'Bryan' }<br/>    return newAttendee<br/>}</span></pre><p id="2de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数有<strong class="lb iu"> </strong>返回一个<code class="fe nk nl nm nc b">Attendee</code> <em class="lv"> </em>对象否则TypeScript会报错。</p><p id="ecce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nk nl nm nc b">src/types/index.ts</code>中创建您的<code class="fe nk nl nm nc b">Attendee</code>接口，并确保导出它。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7944" class="lw lx it nc b gy ng nh l ni nj">export interface Attendee {<br/>    name: string,<br/>    age: number,<br/>    permission: string<br/>}</span></pre><p id="60c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建AttendeePermission枚举</strong></p><p id="e40e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe nk nl nm nc b">Attendee</code>的<code class="fe nk nl nm nc b">permission</code>字段是一个字符串，但是我们知道它只能保存一组特定的值:允许、拒绝、禁止或特殊来宾。我们可以继续我们所拥有的，并且只希望我们只将这些值中的一个赋值给<code class="fe nk nl nm nc b">permission</code>属性。或者我们可以显式地使用枚举。</p><p id="b39e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript中的枚举如下所示。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b8bc" class="lw lx it nc b gy ng nh l ni nj">enum AttendeePermission {<br/>    Admitted,<br/>    Refused,<br/>    Banned,<br/>    SpecialGuest<br/>}</span></pre><p id="d68a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举是一种特殊类型，它只能包含一组特定的<em class="lv">变量</em>(值)。这意味着如果某个东西属于类型<code class="fe nk nl nm nc b">AttendeePermission</code>，它只能被指定为我们指定的四个变量中的一个。</p><p id="d310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以更改Attendee接口的permission属性，如果我们使用不当，TypeScript会警告我们。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="232c" class="lw lx it nc b gy ng nh l ni nj">export interface Attendee {<br/>    name: string,<br/>    age: number,<br/>    permission: AttendeePermission<br/>}</span></pre><p id="d16a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图不正确地使用它，像这样:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2470" class="lw lx it nc b gy ng nh l ni nj">const attendee: Attendee = {<br/>    name: "john",<br/>    age: 2000,<br/>    permission: 'Hello'<br/>}</span></pre><p id="bb23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们会得到一个错误:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3b0e" class="lw lx it nc b gy ng nh l ni nj">Type 'string' is not assignable to type 'AttendeePermission'.ts(2322)</span></pre><p id="f6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是正确的做法:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="06cb" class="lw lx it nc b gy ng nh l ni nj">const attendee: Attendee = {<br/>    name: "john",<br/>    age: 2000,<br/>    permission: AttendeePermission.Admitted<br/>}</span></pre><p id="d0fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。我们已经模拟了我们的领域。您的<code class="fe nk nl nm nc b">src/types/index.ts</code>文件应该是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以转到应用程序了。</p><h1 id="3df2" class="np lx it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">React应用程序</h1><p id="faa8" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">夜总会应用程序将有一个页面。它将显示所有的与会者，加上一个表单来添加一个新的。一个真实的来宾名单应用程序可能会获取一些初始数据:预先预订或已知的特殊来宾。我们将用一个定制的钩子来模拟这种情况，该钩子处理返回与会者并添加一个新的与会者。这也是我们第一次使用我们刚刚定义的一些类型。</p><h2 id="51d7" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">用户定制挂钩</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="482a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中很多都是普通的React代码，希望大家熟悉。</p><p id="329e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4行，我们已经创建了一个初始参与者列表，所以我们从一些数据开始。为了告诉TypeScript我们想要使用某种类型的数组，我们必须编写<code class="fe nk nl nm nc b">type[]</code>，这就是我们在这里为与会者列表所做的。现在，如果我们试图向列表中添加任何内容，TypeScript将会抱怨。</p><p id="855a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第17行，我们为我们的<code class="fe nk nl nm nc b">addAttendee</code> <em class="lv"> </em>函数创建一个<em class="lv">类型</em>别名<em class="lv"> </em>并导出它。我将更详细地解释那件事。</p><h2 id="a9ff" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">键入别名</h2><p id="4779" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">一个<em class="lv">类型别名</em>只是你给一个现有类型的名字。类似于给朋友起外号。它们可以用来缩短原始类型或使您的代码更具可读性。例如，如果我正在创建一个电话簿应用程序，并且除了电话号码之外，我对号码类型没有其他用途，我可能会为基本的<em class="lv">号码</em>类型创建一个别名，名为<em class="lv">电话号码</em>。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a807" class="lw lx it nc b gy ng nh l ni nj">type PhoneNumber = number;</span></pre><p id="c5ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对编译器来说没什么区别，但是该应用程序的贡献者可以在他们可能使用<code class="fe nk nl nm nc b">number</code> <em class="lv">、</em>的任何地方使用<code class="fe nk nl nm nc b">PhoneNumber</code> <em class="lv"> </em>，这将使代码的意图更加清晰。</p><p id="6332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我为函数签名创建了一个类型别名。我们知道<code class="fe nk nl nm nc b">addAttendees</code> <em class="lv"> </em>函数的签名是<code class="fe nk nl nm nc b">(attendee: Attendee) =&gt; void</code>——也就是说，它接收一个attendee对象，并且不返回任何内容——当我们稍后想要将该函数作为一个道具传递时，我们需要能够告诉接收组件它应该期待什么函数签名。</p><p id="7762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不这样做，我们就不会得到类型检查，也不会得到编译器提示。但是我们不希望每次需要使用它的时候都要写<code class="fe nk nl nm nc b">attendee: Attendee) =&gt; void</code>，因为它又丑又烦人。通过别名化，我们可以使用<code class="fe nk nl nm nc b">AddAttendeeFunction</code>作为道具的类型。希望这是有意义的，但是如果没有意义，一秒钟后就会有意义，因为我们在下一行使用它。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="3279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的代码片段，在第19行，我们给<code class="fe nk nl nm nc b">useAttendees</code>钩子添加了一个返回类型。这是一个有两个索引的数组。第一个索引是与会者的列表，所以我们用<code class="fe nk nl nm nc b">Attendee[]</code>指定了它。第二个索引将是我们的<code class="fe nk nl nm nc b">addAttendee</code> <em class="lv"> </em>函数，正如我们刚刚讨论的，它有一个签名<code class="fe nk nl nm nc b">attendee: Attendee) =&gt; void</code>。但是我们已经给它起了别名，所以我们不需要把整个事情写出来。我们可以只使用<code class="fe nk nl nm nc b">AddAttendeeFunction</code>。</p><p id="854e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第20行，我们使用了一个名为<a class="ae ky" href="https://www.tutorialsteacher.com/typescript/typescript-generic" rel="noopener ugc nofollow" target="_blank"> <em class="lv">泛型</em> </a>的类型脚本特性。<em class="lv">泛型</em>是一种编写函数(和其他东西)的方式，能够接收和处理所有不同类型的参数。这是一个复杂的话题，但我会给出一个非常基本的例子。</p><h2 id="8357" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">类型脚本泛型</h2><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="4f55" class="lw lx it nc b gy ng nh l ni nj">const printType = &lt;T&gt;(type: T): T =&gt; {<br/>    console.log(typeof type);<br/>    return type;<br/>}</span></pre><p id="cfff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nc b">&lt;T&gt;</code>部分是使这个函数通用的部分。当我们调用它时，我们可以为T指定一个类型，它将被用作参数的类型和返回类型。为T指定一个类型如下所示。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="856f" class="lw lx it nc b gy ng nh l ni nj">printType&lt;string&gt;("Hello")</span></pre><p id="1706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你写的时候，你可以想象这个函数是这样的。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="71da" class="lw lx it nc b gy ng nh l ni nj">const printType = &lt;string&gt;(type: string): string =&gt; {<br/>    console.log(typeof type);<br/>    return type;<br/>}</span></pre><p id="91ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您指定数字<em class="lv"> </em>作为类型，它将看起来像这样。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="0dfa" class="lw lx it nc b gy ng nh l ni nj">const printType = &lt;number&gt;(type: number): number =&gt; {<br/>    console.log(typeof type);<br/>    return type;<br/>}</span></pre><p id="4eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以任意多次调用通用函数<em class="lv">并每次指定不同的类型。只要你遵守规则，它就会起作用。不是<strong class="lb iu"> </strong>遵守规则长这样。</em></p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7daa" class="lw lx it nc b gy ng nh l ni nj">printType&lt;string&gt;(1)</span></pre><p id="9a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以创建只接受一组特定类型的函数。这是首选。越清楚应该如何使用一个函数越好。下面是将一个函数约束为字符串类型和数字类型的情况。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="fd7c" class="lw lx it nc b gy ng nh l ni nj">const printType = &lt;T extends string | number&gt;(type: T): T =&gt; {<br/>    console.log(typeof type);<br/>    return type;<br/>}</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="8d7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe nk nl nm nc b">useAttendees</code> <em class="lv"> </em>钩子，我们可以看到我们将第20行的<code class="fe nk nl nm nc b">useState</code> <em class="lv"> </em>调用约束为类型<code class="fe nk nl nm nc b">Attendees[]</code>。我们实际上并不需要这样做，但是正如我所说的，这使得我们的意图更加清晰，并且为我们提供了方便的编译器提示。</p><p id="e9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们代码片段的最后一部分是第22行，在这里我们确保将一个<code class="fe nk nl nm nc b">Attendee</code>类型传递给<code class="fe nk nl nm nc b">addAttendee</code>函数。</p><p id="8e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">app . tsx组件</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a7ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">App组件很简单，没有显式的类型脚本。我们还没有创建<code class="fe nk nl nm nc b">AttendeeList</code>组件，但是我们现在会这样做。</p><p id="bce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">attendee list . tsx组件</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这很容易理解。我们已经看过大部分这些东西了。</p><p id="108d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第7行，我们为我们的道具定义了一个接口。我们不会将它出口到任何其他地方；每个组件都有自己的props接口。我们还可以看到我们的<code class="fe nk nl nm nc b">AddAttendeeFunction</code>类型别名也在使用中。</p><p id="2a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第12行，我们告诉React，传递给这个组件的道具必须符合<code class="fe nk nl nm nc b">AttendeeListProps</code> <em class="lv"> </em>接口。我们还返回了一个<code class="fe nk nl nm nc b">ReactElement</code>:React用于其jsx结构的类型。</p><p id="37df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是这个组件的全部内容。如果您返回到<code class="fe nk nl nm nc b">App.tsx</code>并试图向<code class="fe nk nl nm nc b">AttendeeList</code>组件传递一个没有在<em class="lv"> AttendeeListProps </em>中定义的道具，您应该会得到一个错误。如果你漏掉了其中一个，你也会得到一个错误。也试着给<code class="fe nk nl nm nc b">addAttendee</code> <em class="lv"> </em>传递一个不符合别名的函数:应该不行。</p><p id="1ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们将创建<code class="fe nk nl nm nc b">AttendeeInformation</code>组件，最后创建<code class="fe nk nl nm nc b">CreateAttendee</code>组件。</p><p id="1b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【The AttendeeInformation.tsx组件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nc b">AttendeeInformation</code>组件只做两件事:显示与会者的详细信息，并根据他们的许可给每个人分配一种颜色。</p><p id="c4a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第8行，<code class="fe nk nl nm nc b">getBackgroundColor</code>函数使用一个switch语句来计算传递给它的permission属性。这很好，我认为这很清楚发生了什么，但有一个替代方案值得一提。</p><p id="e9df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在TypeScript枚举定义中，可以为每个变量赋值，如下所示。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="255f" class="lw lx it nc b gy ng nh l ni nj">export enum AttendeePermission {<br/>    Admitted = "green",<br/>    Refused = "red",<br/>    Banned = "grey",<br/>    SpecialGuest = "gold"<br/>}</span></pre><p id="7110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以直接将permission的值赋给<em class="lv"> background </em>属性，而不是切换permission，就像这样。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b7a0" class="lw lx it nc b gy ng nh l ni nj">&lt;div style={{ backgroundColor: <em class="lv">props</em>.attendee.permission }}&gt;</span></pre><p id="bc4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可行的，这意味着你可以去掉整个<code class="fe nk nl nm nc b">getBackgroundColor</code>函数。然而，这也意味着你必须在你的<code class="fe nk nl nm nc b">types</code>文件和你的<code class="fe nk nl nm nc b">AttendeeInformation</code>组件之间来回跳转，以确定什么是什么，并且在一个更复杂的应用程序中，你的<code class="fe nk nl nm nc b">AttendeePermission</code>枚举可能有更多的用途，而不仅仅是设置一个背景颜色，因此将它与颜色如此紧密地联系在一起可能是不合适的。做出这些选择取决于您，但是我在这里展示它是为了演示您可以做什么。</p><p id="581f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论你决定走哪条路，我们现在应该有一个这样的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/e7cfa88713994c367409d3ce51eab7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2uxPMQJS9Fch23hqD4iyg.png"/></div></div></figure><p id="fb1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是最后一个部分。</p><p id="5835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【The CreateAttendee.tsx组件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8e72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是迄今为止最大的组件，但主要是因为jsx。</p><p id="8018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第9行，我们创建了一个<code class="fe nk nl nm nc b">PermissionsOptions</code>记录。一个<code class="fe nk nl nm nc b">Record</code>就像一个JavaScript对象，但是我们可以使用泛型来约束类型。在这个例子中，我说过我想要一个键是字符串，值是<code class="fe nk nl nm nc b">AttendeePermission</code>类型的记录。</p><p id="aac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该记录的存在是因为我们需要创建一个select元素来为每个新参与者选择权限，并且我们需要一种方法来将select字段值映射到一个实际的<code class="fe nk nl nm nc b">AttendeePermission</code>变量。这里的<code class="fe nk nl nm nc b">Record</code>也很好，因为它使选择选项和它们对应的值紧密耦合，所以只要我们只在选择元素中引用这个记录，我们就可以确保我们不会试图引用不存在的变量，比如<code class="fe nk nl nm nc b">TooDrunkToEnter</code>或其他什么。</p><p id="7fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的其他东西你都已经看过了。如果你通读一遍，应该就很清楚了。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="58e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，你应该有一个工作的应用程序，你可以添加新的与会者到客人名单，他们会根据他们的权限级别分配不同的背景颜色。</p><h1 id="56eb" class="np lx it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated"><strong class="ak">包装完毕</strong></h1><p id="5a5d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这个应用不会赢得任何设计奖项，而且你可以用TypeScript做这么多事情，我甚至不会说它很棒。但这是一个<em class="lv">好的</em>起点。你在这里学到的概念——<em class="lv">接口、枚举、类型别名、泛型、属性类型、函数</em>——已经可以提高你的应用程序的安全性，消除错误，为你和你的团队提供更好的开发体验。不过，你应该继续调查。</p><p id="1b11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript很有趣，而且还有更多的东西可以玩。</p></div></div>    
</body>
</html>