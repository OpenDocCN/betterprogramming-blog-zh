<html>
<head>
<title>Swift 5’s Lazy Keyword Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5的懒惰关键字解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-5-lazy-keyword-explained-484cc00f600d?source=collection_archive---------20-----------------------#2020-04-27">https://betterprogramming.pub/swift-5-lazy-keyword-explained-484cc00f600d?source=collection_archive---------20-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5e84" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当你准备好的时候，如何运行你的类的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d71d952f588cc58462547b8fed2db168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcp24P2lwWaQ594yeqjSDA.jpeg"/></div></div></figure><p id="ee0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理解的先决条件:</p><ul class=""><li id="fbba" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">Swift 5语法</li></ul><p id="7765" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能看到过别人的Swift代码中包含关键字<code class="fe lw lx ly lz b">lazy</code>，但这是什么意思呢？<code class="fe lw lx ly lz b">lazy</code>关键字用于解决处理速度的问题。</p><p id="22f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们有一个结构:</p><pre class="kg kh ki kj gt ma lz mb mc aw md bi"><span id="235a" class="me mf iq lz b gy mg mh l mi mj">struct Person {</span><span id="1759" class="me mf iq lz b gy mk mh l mi mj">  var age: Int = 16</span><span id="c7a7" class="me mf iq lz b gy mk mh l mi mj">}</span></pre><p id="6f98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个非常简单的结构。如果我们想访问一个<code class="fe lw lx ly lz b">Person</code>实例的年龄属性，速度会非常快。我的意思是…我们所做的只是返回一个值。</p><p id="cded" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，让我们这样做:</p><pre class="kg kh ki kj gt ma lz mb mc aw md bi"><span id="7485" class="me mf iq lz b gy mg mh l mi mj">let person: Person = Person()<br/>print(person.age)</span></pre><p id="df83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里没有问题…</p><p id="09a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们在这个结构中有一个极难计算的属性呢？如果仅仅计算这个属性就花了6秒钟呢？</p><p id="e45c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看实例化实例时实际发生了什么。</p><p id="302d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们将<code class="fe lw lx ly lz b">person</code>变量赋给一个新的<code class="fe lw lx ly lz b">Person()</code>时，属性的值被计算并赋值。然后，当我们想要访问它们时，就从它们在内存中的位置检索它们。</p><p id="6731" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们使用常见的斐波那契算法来介绍这个问题，这是一种众所周知会引入“计算时间”问题的算法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="afee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在在我们的<code class="fe lw lx ly lz b">Person</code>结构上有了一个属性，这可能会给我们带来一些问题。</p><p id="36ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">问题是:每次实例化一个类时，都要计算属性来产生实例。</p><p id="fe0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着每次我们只想这样走:</p><pre class="kg kh ki kj gt ma lz mb mc aw md bi"><span id="c0f8" class="me mf iq lz b gy mg mh l mi mj">let person: Person = Person()</span></pre><p id="e1fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的代码将计算<code class="fe lw lx ly lz b">fibonacciOfAge</code>属性。</p><p id="aeba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为这种递归算法可能会在初始化时造成一点延迟，我们基本上想告诉我们的类如下:“嘿，不要在初始化时计算那个<code class="fe lw lx ly lz b">fibonacciOfAge</code>属性，只有在我要求时才计算它。”</p><p id="feae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是我们使用<code class="fe lw lx ly lz b">lazy</code>关键字的目的。让我们解决我们的问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="abb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过向该属性添加<code class="fe lw lx ly lz b">lazy</code>，我们告诉我们的结构不要计算该属性，除非我们特别需要它。</p><p id="02f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是将要发生的事情:</p><pre class="kg kh ki kj gt ma lz mb mc aw md bi"><span id="acb7" class="me mf iq lz b gy mg mh l mi mj">let person: Person = Person() // fibonacciOfAge NOT computed<br/>print(person.fibonacciOfAge) // fibonacciOfAge IS computed</span></pre><p id="58a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个强大的工具。假设我们想要用十亿人来填充一个游戏，他们都拥有<code class="fe lw lx ly lz b">fibonacciOfAge</code>属性。当我们开始游戏时，我们不想花费大量的时间来计算他们所有的<code class="fe lw lx ly lz b">fibonacciOfAge</code>属性。</p><p id="da79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们只想实例化所有的人，并且在逐个案例的基础上只计算一个人的<code class="fe lw lx ly lz b">fibonacciOfAge</code>。</p><p id="d612" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，你可能会问这样一个问题:“为什么不是所有东西都是懒惰变量呢？”</p><p id="0e92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不把所有东西都分配为惰性变量的原因是，我们仍然希望简单变量有闪电般的响应时间。</p><p id="4825" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果每次我们想要访问一个属性时，我们都必须计算它，我们的游戏会运行得更慢。</p><p id="919b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望这对一些人有帮助！</p><p id="47b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">快乐编码。</p><p id="49da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">干杯。</p></div></div>    
</body>
</html>