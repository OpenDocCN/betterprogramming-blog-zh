<html>
<head>
<title>Optimizing Docker Image Creation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Docker图像创建</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/optimizing-docker-image-creation-fa06bb42733d?source=collection_archive---------10-----------------------#2019-08-23">https://betterprogramming.pub/optimizing-docker-image-creation-fa06bb42733d?source=collection_archive---------10-----------------------#2019-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba9b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们优化创建码头工人形象的经验以及从中我们学到了什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3bf8d5792b25b8cd357a0447e581daf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WH7AKdhi0HarwHgr3F6T4w.png"/></div></div></figure><h1 id="c8c6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">语境</h1><p id="f94b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们的大多数微服务都是基于Python的容器，它们是通过持续集成过程创建的。该过程描述如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/428748179601b88136a93a09ce170f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*6YNIttrr5JLmj1EJJj3nQg.png"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">容器生成和容器推广流程</p></figure><p id="fb69" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">正如您在这个过程中看到的，只要开发人员提出一个拉请求，集成过程就开始了。创建映像后，会对映像进行UT和功能测试。如果他们通过了，PR将被提供给同行评审。如果同行评审者提供了任何注释，那么开发人员将处理该注释，这可能会导致新的提交，如果发生这种情况，循环将会重复。否则，评审者可能会批准拉取请求。批准后，提交被标记，映像被再次创建，生成的映像被发布到容器注册中心。</p><p id="599f" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">经过仔细分析，优化Docker图像创建实际上有助于我们优化整体流程。因此，我们开始了改进我们的容器构建过程的旅程。</p><p id="c07c" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated"><em class="ms">注意:我交替使用容器和图像。我仍在习惯这些术语</em></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="335e" class="ku kv it bd kw kx na kz la lb nb ld le jz nc ka lg kc nd kd li kf ne kg lk ll bi translated">Docker图像创建流程</h1><p id="127d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们先来了解一下Docker的形象创建过程。</p><p id="39ef" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">首先，我们将看到一个Dockerfile文件。Docker文件示例如下所示:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="184a" class="nk kv it ng b gy nl nm l nn no">#This is a example Dockerfile <br/>FROM ubuntu <br/>MAINTAINER myself@somedomain.com <br/><br/>RUN apt-get update &amp;&amp; \<br/>    apt-get -y upgrade<br/>CMD [“echo”,”Image created”]</span></pre><p id="5bc8" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在上面的Dockerfile中，第一行告诉我们这个图像应该从基础图像:<code class="fe np nq nr ng b">docker.io/library/ubuntu:latest</code>创建。</p><p id="9329" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">下一行添加了关于谁在维护运行docker构建过程所创建的映像的元数据。</p><p id="d48a" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">下面一行更新容器中的包。</p><p id="e8aa" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">最后一行向容器添加了另一段元数据，一旦容器启动，它就会回显命令<code class="fe np nq nr ng b">Image created</code>。</p><p id="2dca" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">以下是docker映像创建过程的高级表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/662673779fba381bb5ad31a61465d14f.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*ftgooBV5zTNM3qM9vZba-g.png"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">Docker图像创建流程</p></figure><p id="0b44" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">当映像创建过程开始时，docker守护进程做的第一件事就是检查docker文件中指定的基本映像是否在本地机器中。如果不存在，它就从注册表中取出图像。然后它移动到docker文件中的下一行。它读取下一行，并验证构建缓存中是否有一个映像具有docker文件中提到的这种更改。如果它有图像，它就移动到下一行，并重复这个过程，直到遇到Dockerfile中的一行，该行有一个没有图像被缓存的更改。同样的过程已经在"<strong class="lo iu"> <em class="ms">绿色"</em> </strong>章节中描述过了。</p><p id="db44" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">此时，或者如果没有缓存中间图像，Docker守护程序会创建一个容器，应用该行中提到的更改，从中创建一个图像，然后移动到下一行，重复相同的过程，直到到达Docker文件的末尾。这已经描绘在“<strong class="lo iu"><em class="ms"/></strong>桃子”的彩色方框中。</p><p id="bb2c" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">(<em class="ms">请注意:这是Docker图像创建过程的一个非常简化的版本，为了让我们集中注意力，我故意省略了很多细节</em>)</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="d183" class="ku kv it bd kw kx na kz la lb nb ld le jz nc ka lg kc nd kd li kf ne kg lk ll bi translated">这个想法</h1><p id="57b0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">随着我们对Docker构建过程理解的加深，我们开始意识到，如果我们能够以某种方式最小化构建过程进入"<strong class="lo iu"><em class="ms">【peach】</em></strong>"部分的次数，并最大化它进入构建过程工作流的"<strong class="lo iu"><em class="ms">【green】</em></strong>"部分的次数，我们也许能够使图像创建过程更快。</p><p id="e8cb" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">以此为起点，我们开始分析我们的docker文件。在我们的大多数案例中，docker文件包含以下内容:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="fb41" class="nk kv it ng b gy nl nm l nn no"><em class="ms">1. Base Image<br/>2. Shell Scripts (Entrypoint files)<br/>3. Dependencies (Third Party Libraries)<br/>4. Actual Code/Artifacts related to the Microservice<br/>5. Metadata Information(Maintainer, Ports, etc)</em></span></pre><p id="9681" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在我们分析这些问题时，我们意识到这些问题可以分为以下几类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/f87bab381adc232d5dcc638e14285637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OLoXOQZLiOMD6sa_m-cTWA.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">docker文件组件的分类</p></figure><p id="d318" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">这是一个启示。我们现在需要做的就是将docker文件重新组织成以下结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/46fbef7227141581b153eb179191b858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P413rcqRZ3TbEzdmDbeheA.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">我们文档的理想结构</p></figure><p id="3f74" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">这就是我们所做的！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="4522" class="ku kv it bd kw kx na kz la lb nb ld le jz nc ka lg kc nd kd li kf ne kg lk ll bi translated">结果呢</h1><p id="390c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/3dc4a9b3d93c02a9ab51a891b8fb577c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84h5mJOxlRSPTAbSZ83m-g.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">优化的docker文件需要45秒来生成图像</p></figure><p id="51ba" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">由于对Docker构建过程有了更好的理解，这一小小的改变带来了相当大的优化。</p><p id="4b71" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated"><strong class="lo iu">这有什么影响？</strong></p><ul class=""><li id="2639" class="nw nx it lo b lp mn ls mo lv ny lz nz md oa mh ob oc od oe bi translated">优化的图像创建</li><li id="ab1b" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated">优化的构建机器存储，因为Docker使用了缓存的层/图像</li><li id="d1f6" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated">由于Docker只提取非缓存层，因此映像的部署速度总体更快</li><li id="3e15" class="nw nx it lo b lp of ls og lv oh lz oi md oj mh ob oc od oe bi translated">由于Docker层的原因，上传到注册表也相对较快</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="d5ac" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">对我们所有参与其中的人来说，这是一个伟大的学习过程。对我们来说，这仍是一项进行中的工作。</p></div></div>    
</body>
</html>