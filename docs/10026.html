<html>
<head>
<title>What’s New in TypeScript 4.5?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.5有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-4-5-57d6b88b1e72?source=collection_archive---------1-----------------------#2021-11-16">https://betterprogramming.pub/whats-new-in-typescript-4-5-57d6b88b1e72?source=collection_archive---------1-----------------------#2021-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">等待的实用程序类型、仅类型修饰符、导入断言等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b52f3a5395127cace5aba7b7cefbe32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k69ANfBEggLKA5G258OjHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a019" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打字稿<code class="fe lu lv lw lx b">4.5</code>版本于11月17日发布🎉。很久没有一个TypeScript版本被如此打包了。这是一个激动人心的时刻。</p><p id="31e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是第一次尝试将ES模块引入NodeJs世界的实验版本。</p><p id="369c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是唯一受到关注的领域。进口领域有了很多改进。它们将带来更多的可读性，并控制我们如何导入我们的类型和变量。</p><p id="4c92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面我们来看看这个版本的主要变化。</p><h1 id="036e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">等待的类型</h1><p id="442e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">在此版本之前，要获得承诺的返回类型，您必须使用<code class="fe lu lv lw lx b">infer</code>功能，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0a85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为此次发布的一部分，有一个新的实用程序类型<code class="fe lu lv lw lx b">Awaited</code>。您不需要像上面代码中描述的<code class="fe lu lv lw lx b">Unwarp</code>那样的自定义映射类型。</p><p id="e493" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它的用法与其他任何实用程序类型一样直观:</p><pre class="kj kk kl km gt mx lx my mz aw na bi"><span id="9186" class="nb lz it lx b gy nc nd l ne nf">type Result = <strong class="lx iu">Awaited</strong>&lt;T&gt;;</span></pre><p id="0595" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该实用程序具有以下功能:</p><ul class=""><li id="3a59" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">递归展开</li><li id="ce32" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">不依靠<code class="fe lu lv lw lx b">PromiseLike</code>变得更加强大</li><li id="e0da" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">非承诺“奖品”解析为<code class="fe lu lv lw lx b">never</code></li><li id="8831" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">向<code class="fe lu lv lw lx b">Promise.all</code>、<code class="fe lu lv lw lx b">Promise.race</code>、<code class="fe lu lv lw lx b">Promise.allSettled</code>和<code class="fe lu lv lw lx b">Promise.any</code>添加过载，以利用<code class="fe lu lv lw lx b">Awaited&lt;T&gt;</code></li></ul><p id="5665" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一些不同的用例示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仅限类型的导入说明符</p></figure><h1 id="eb7e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">禁用导入省略</h1><p id="4f6f" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">在编译时，tile TypeScript检测该模块是否在发出的Javascript中使用。如果模块没有被使用或用作类型注释，则该模块不会被导入到发出的代码中。这种省略是一种很好的性能优化。</p><p id="d2d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常这一切都工作正常。但是在某些情况下，这个特性可能会妨碍我们。什么时候？例如，当使用像Svelte这样的框架和它们特定的文件格式时。为此，有一个新的标志<code class="fe lu lv lw lx b">--preserveValueImports</code>可以使用。</p><pre class="kj kk kl km gt mx lx my mz aw na bi"><span id="1a2d" class="nb lz it lx b gy nc nd l ne nf">Disabling Import Elision&lt;script&gt;<br/>  import { <strong class="lx iu">bookAppointment</strong> } from "./appointment.js";<br/>&lt;/script&gt;</span><span id="375e" class="nb lz it lx b gy nu nd l ne nf">&lt;button on:click={<strong class="lx iu">bookAppointment</strong>}&gt;Book&lt;/button&gt;</span></pre><p id="faa5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，TypeScript将删除<code class="fe lu lv lw lx b">bookAppointment</code>导入，因为它只“看到”包装在<code class="fe lu lv lw lx b">&lt;script /&gt;</code>标签中的代码。</p><h1 id="2946" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">仅限类型的导入说明符</h1><p id="0630" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这是我最喜欢的这个版本的功能。从版本<code class="fe lu lv lw lx b">3.8</code>开始，您可以通过将<code class="fe lu lv lw lx b">type</code>附加到<code class="fe lu lv lw lx b">import</code>关键字来显式使用类型导入。这确实告诉TSC编译器该导入只包括TypeScript类型。TSC稍后可以对导入进行条带化。</p><pre class="kj kk kl km gt mx lx my mz aw na bi"><span id="1e57" class="nb lz it lx b gy nc nd l ne nf">import <strong class="lx iu">type</strong> { FC } from 'react';<br/>import { useEffect } from 'react';</span></pre><p id="1577" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在上面看到的，问题在于，如果您想要明确您的导入类型，有时您需要导入语句。您仍然可以执行以下操作:</p><pre class="kj kk kl km gt mx lx my mz aw na bi"><span id="9d7d" class="nb lz it lx b gy nc nd l ne nf">import { FC, useEffect } from 'react';</span></pre><p id="0334" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是你牺牲了一点可读性。从版本<code class="fe lu lv lw lx b">4.5</code>开始，可以把它们混在一起。</p><pre class="kj kk kl km gt mx lx my mz aw na bi"><span id="1316" class="nb lz it lx b gy nc nd l ne nf">import { <strong class="lx iu">type</strong> FC, useEffect } from 'react';</span></pre><p id="d5ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得代码更加清晰，而没有添加任何额外的样板文件。</p><h1 id="d29b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">导入断言</h1><p id="7f46" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这个特性是ECMAScript提案<code class="fe lu lv lw lx b">import assertions</code>的实现。它目前处于ECMAScript管道的第3阶段。</p><p id="9ca9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是怎么回事？它确保导入具有预期的格式。</p><pre class="kj kk kl km gt mx lx my mz aw na bi"><span id="0736" class="nb lz it lx b gy nc nd l ne nf">// ✅ regular importYou might want to<br/>import students from "./students.json" <strong class="lx iu">assert { type: "json" }</strong>;</span><span id="1b35" class="nb lz it lx b gy nu nd l ne nf">// ✅ dynamic import<br/>const students = await import("./students.json", {<br/>    <strong class="lx iu">assert: { type: "json" }</strong><br/>})</span></pre><p id="ecbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，TypeScript不会做任何事情。它会不去管它，以便浏览器和运行时可以处理这些问题。</p><h1 id="c817" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Node.js中的实验性ECMAScript模块支持</h1><p id="15ff" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">⚠️ A <em class="nv">仅在夜间发布时可用，未来可能会有变化</em></p><p id="079b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Node.js的模块基础一直是CommonJS。随着多态应用程序的转变，支持ECMAScript模块的呼声越来越高。在过去的几年里，Node.js一直致力于支持这些。从Node 12版本开始，对ES模块的支持已广泛提供。</p><p id="d0bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在有两个新的<code class="fe lu lv lw lx b">module</code>配置设置:<code class="fe lu lv lw lx b">nodenext</code>和<code class="fe lu lv lw lx b">node12</code>。</p><pre class="kj kk kl km gt mx lx my mz aw na bi"><span id="bf3d" class="nb lz it lx b gy nc nd l ne nf">{<br/>  "compilerOptions": {<br/>    <strong class="lx iu">"module": "nodenext"</strong><br/>  }<br/>}</span></pre><h2 id="bfc8" class="nb lz it bd ma nw nx dn me ny nz dp mi lh oa ob mk ll oc od mm lp oe of mo og bi translated">package.json中的“类型”属性</h2><p id="26a4" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><code class="fe lu lv lw lx b">"type"</code>字段定义了模块格式，该节点将用于所有的<code class="fe lu lv lw lx b">.js</code>文件，对于这些文件来说<code class="fe lu lv lw lx b">package.json</code>文件是其最近的父文件。您可以选择<code class="fe lu lv lw lx b">module</code>用于ES模块或<code class="fe lu lv lw lx b">commonjs</code>用于传统的CommonJS模块。</p><p id="b372" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TypeScript将通过它的<code class="fe lu lv lw lx b">.ts</code>文件包含相同的系统行为。当TypeScript找到一个<code class="fe lu lv lw lx b">.ts/.tsx/.js/.jsx</code>时，它会查看最近的<code class="fe lu lv lw lx b">package.json</code>文件来确定它的模块风格。</p><h2 id="0058" class="nb lz it bd ma nw nx dn me ny nz dp mi lh oa ob mk ll oc od mm lp oe of mo og bi translated">定制文件模块系统</h2><p id="854e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">单个文件如何确定自己的模块系统？只要改变它的文件扩展名。</p><ul class=""><li id="4f23" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">.cjs/.cjx</code>:不管最近的父<code class="fe lu lv lw lx b">"type"</code>配置如何，文件将以CommonJS格式导入。</li><li id="7eb8" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">.cts/.ctx/.d.cts</code>:不管父<code class="fe lu lv lw lx b">"type"</code>规格如何，文件将以CommonJS格式导入。当发送文件时，它将输出其对应的<code class="fe lu lv lw lx b">.</code> et，看看我们现在可以使用什么扩展名:<code class="fe lu lv lw lx b">mjs</code>、<code class="fe lu lv lw lx b">.mjx</code>或带有<code class="fe lu lv lw lx b">.d.cts </code>扩展名的声明。</li><li id="97ef" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">.mjs/.mts/.mtx/d.mts</code>:文件将以ECMAScript模块格式导入，不考虑父<code class="fe lu lv lw lx b">"type"</code>规范。发出文件时会输出对应的<code class="fe lu lv lw lx b">.mjs</code>、<code class="fe lu lv lw lx b">.mjx</code>或扩展名为<code class="fe lu lv lw lx b">.d.mts</code>的声明。</li></ul><h2 id="9584" class="nb lz it bd ma nw nx dn me ny nz dp mi lh oa ob mk ll oc od mm lp oe of mo og bi translated">互用性</h2><p id="270d" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">现在你可以通过调整文件系统来导入不同的模块类型，它们需要协同工作。ES模块很简单，因为它只是一个翻译的问题。对于要导入CommonJS的ES模块，它会将它们视为默认导出。</p><p id="5b0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="0909" class="nb lz it bd ma nw nx dn me ny nz dp mi lh oa ob mk ll oc od mm lp oe of mo og bi translated">ES模块的要点</h2><p id="b406" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">es模块带来了哪些特性？需要注意什么？让我们来看一个摘要列表:</p><ul class=""><li id="bb91" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated"><em class="nv">功能:</em>使用<code class="fe lu lv lw lx b">import/export</code>语句语法</li><li id="c806" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><em class="nv">特性:</em>顶层等待可与<code class="fe lu lv lw lx b">nodenext</code>一起使用</li><li id="07fc" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><em class="nv">注意:</em>因为现在有不同的模块策略es模块相对进口需要完整的文件扩展名:<code class="fe lu lv lw lx b">import fade from ./utils<strong class="la iu">.js</strong></code></li><li id="c0d1" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><em class="nv">互操作:</em>一些像<code class="fe lu lv lw lx b">require</code>这样的全局关键字在ES模块上不起作用</li><li id="d2a6" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><em class="nv">互操作:</em> CommonJS将传输类似<code class="fe lu lv lw lx b">import/export</code>语法的特性</li></ul><h1 id="0f5a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">在node_modules中解析@typescript[lib]</h1><p id="340b" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">TypeScript捆绑了某些库，以确保它能与Javascript很好地协同工作。但是，您可能希望将它们更改为另一种类型的库实现。</p><ul class=""><li id="ecdf" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">lib.dom.d.ts</code>-&gt;-<code class="fe lu lv lw lx b">@typescript/dom</code></li><li id="6d23" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">lib.dom.iterable.d.ts</code>-&gt;-<code class="fe lu lv lw lx b">@typescript/dom/iterable</code></li><li id="4070" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated"><code class="fe lu lv lw lx b">lib.es2015.symbol.wellknown.d.ts</code>-&gt;-<code class="fe lu lv lw lx b">@typescript/es2015/symbol-wellknown</code></li></ul><p id="2fe2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来做一个例子。让我们选择不同版本的<code class="fe lu lv lw lx b">@typescript/dom</code>。现在，您只需执行以下操作即可实现这一点:</p><pre class="kj kk kl km gt mx lx my mz aw na bi"><span id="9442" class="nb lz it lx b gy nc nd l ne nf">{<br/>  "dependencies": {<br/>    <strong class="lx iu">"@typescript/lib-dom": "npm:@types/web"</strong><br/>  }<br/>}</span></pre><p id="06ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这与<code class="fe lu lv lw lx b">@types</code>的行为类似，现在您可以选择合适的类型定义。</p><h1 id="df73" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">模块es2022</h1><p id="04a2" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">TypeScript现在支持新的模块设置:<code class="fe lu lv lw lx b">es2022</code>。它最显著的特点是<code class="fe lu lv lw lx b">top-level await</code>那个。这使得我们能够在顶层模块中使用<code class="fe lu lv lw lx b">async</code>函数之外的<code class="fe lu lv lw lx b">await</code>。</p><p id="c1ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是用<code class="fe lu lv lw lx b">nodenext</code>支撑的，<code class="fe lu lv lw lx b">es2022</code>只是一个稳定的目标。</p><h1 id="1208" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">JSX属性的代码片段完成</h1><p id="f5aa" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">使用JSX语法编写组件时，Typescript不执行自动完成。有了代码片段补全，这个问题就解决了。在React应用程序中编写组件时，您将获得自动完成功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/e5bb6934997daa5fe35fed719d485cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhyClBkB_KHUKtgJRDwZwg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动完成的示例</p></figure><h1 id="d9c3" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">模板字符串类型作为判别式</h1><p id="9b6c" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">模板文字类型是一个自发布以来一直在不断完善的特性。作为这个新版本的一部分，我们现在可以使用模板字符串类型作为判别器。在以前的版本中，代码可以工作，但是什么也不会发生。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="bb0b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">包裹</h1><p id="fd5e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">尽管在Node.js中为支持ES模块付出了巨大的努力，但还是觉得有点仓促。这个功能还需要一些改进。随着实验性的发布，TypeScript团队将有机会收集早期的反馈。这可能会在下一个版本中正式推出。</p><p id="837d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很高兴看到模板字符串类型仍在变得越来越好。导入名称上的类型修饰符非常有用。为类型添加特定的导入太冗长了。</p><p id="1050" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">升级一个应该是相当容易的。截至11月6日，没有太多重大变化。</p><p id="5713" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯。如果你喜欢你所读到的，看看下面这个故事:</p><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/mastering-typescript-template-literal-types-f4131a94ffb1"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">掌握TypeScript模板文本类型</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">如何使用awesome模板文字类型特性</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">better编程. pub</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/7-typescript-common-mistakes-to-avoid-581c30e514d6"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">要避免的7个打字稿常见错误</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">通过避免这些错误来改进您的TypeScript的代码库</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">better编程. pub</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>