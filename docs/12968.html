<html>
<head>
<title>Create and Deploy Your First JavaScript Serverless Worker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建并部署您的第一个JavaScript无服务器工作器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-and-deploy-your-first-javascript-serverless-worker-e234f3f69cea?source=collection_archive---------4-----------------------#2022-07-15">https://betterprogramming.pub/create-and-deploy-your-first-javascript-serverless-worker-e234f3f69cea?source=collection_archive---------4-----------------------#2022-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4e81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">免费构建和部署无服务器工作器的初学者指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c26cd8b6ee4000fdd5c1d57d80cbf8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LTndfKrg-ZoCpqBl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@viktorijalankauskaite?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Viktorija lankauskait</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="3b7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周我写了一篇关于我在使用JavaScript 时最常用的工具<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/my-favourite-tools-for-working-with-javascript-84eb836750b0">的文章。Cloudflare工人和牧马人都在名单上。今天，你将了解我为什么以及如何使用它们。</a></p><p id="432c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将学习部署一个无服务器的worker，这在许多情况下非常有用。</p><p id="3429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以在一个简单的工人请求中压缩IPFS锁定，并允许用户上传到IPFS，同时仍然像在传统后端中一样屏蔽您的API键。</p><p id="41f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还计划把这个系列做成一个系列，涵盖在CF workers上创建API，并解释诸如处理CORS、与原生KV store交互等主题。如果您真的想构建可伸缩的无服务器API，请继续关注。</p><h1 id="e92c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是Cloudflare Workers？</h1><p id="9821" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">先说基础的，什么是CF工作者，他们是怎么工作的？</p><p id="a403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CF workers提供了一个创建应用程序的环境，而无需维护基础设施。它们直接由Cloudflare网络运行，该网络由分布在全球各地的各种服务器组成。此外，运行时提供了在现代浏览器上实现的大多数API。</p><p id="69fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为无服务器的直接结果，它们非常容易设置，并且由于Cloudflare的设计，工作脚本也很容易构建。</p><p id="224c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当向工作域(或cf管理的域)发出请求时，Cloudflare都会将事件传递给工作域的处理程序。从那里，工作脚本可以按照脚本中的代码计算响应。</p><h1 id="6f15" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置</h1><p id="fdbb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您首先需要一个Cloudflare帐户。然后还得装牧马人(最好版本&gt; 2.0，<code class="fe ms mt mu mv b">npm install -g wrangler</code>)。Wrangler是一个CLI工具，我们将使用它来测试和发布我们的无服务器应用程序(以及KV stores等其他应用程序)。).</p><p id="aef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在一切都准备好了，只需要创建一个新项目。为了简单(在这种情况下也是为了效率)，我们将开始一个空白项目。打开你的终端，输入:<code class="fe ms mt mu mv b">wrangler init serverlessworker</code>，然后进入目录。<code class="fe ms mt mu mv b">wrangler init</code>命令会询问一些事情，你可以按照自己的意愿去做，也可以按照我在本文中使用的配置来做:<code class="fe ms mt mu mv b">use git? &gt; n, create package.json? &gt; Y, use typescript? &gt; n, create worker at index.js? &gt; fetch bundle </code>。</p><h1 id="7b15" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基本处理程序</h1><p id="3d14" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如我之前介绍的，根据请求，一个事件被传递给我们的worker的处理程序。<code class="fe ms mt mu mv b">index.js</code>文件是处理这个事件的地方。默认情况下，该处理程序如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f966" class="na lw it mv b gy nb nc l nd ne">export default {<br/> async fetch(request) {<br/>  return new Response("Hello World!");<br/> },<br/>};</span></pre><p id="fb0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到处理程序将请求作为参数，然后返回一个<code class="fe ms mt mu mv b">Response</code>。您将总是使用request参数，除非您的工作人员只需要执行一项任务，并且每次请求都是相同的任务，这是一种不太可能的情况。</p><p id="ef9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们想要构建一个完成两项任务的worker，所以我们需要像URL模式、头(如果您计划使用身份验证/授权)、主体、方法等数据。</p><p id="61ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们想要返回一个端点，该端点返回关于我们工人的信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ae98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到我们正在查看请求的URL是否与端点匹配(为了简单起见，我显式地匹配了整个URL，而没有构造对象，只对端点进行了are)。</p><p id="9a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它匹配<code class="fe ms mt mu mv b">/info</code>端点，它将返回工人信息，如果不是默认的hello world。我们不打算构建我们的路由器，但是这个例子展示了一个非常基本的cf worker handler应该是什么样子。您可以继续用<code class="fe ms mt mu mv b">wrangler dev</code>测试它(记得将URL改为您的worker)。</p><h1 id="391d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">简单的工人</h1><p id="764c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这一段中，我们将创建一个非常简单的worker函数，并以类似API的格式发布。我们将创建一个端点，它用一个数组作为JSON主体接受POST请求，然后返回规范化的(求和)数组。当然，让一个工人只执行这样的任务是没有效率的，但是这是一个很好的例子来展示一个非常简单的工人如何工作:</p><ul class=""><li id="7657" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">接收用户数据</li><li id="0900" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">用修改的数据响应</li></ul><p id="ddb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做的第一件事是路由我们工人的流量，例如，我们希望<code class="fe ms mt mu mv b">/info</code>端点返回工人信息，而<code class="fe ms mt mu mv b">/normalize</code>端点返回规范化数据。为此，我们将使用<code class="fe ms mt mu mv b">itty-router</code>，您可以使用<code class="fe ms mt mu mv b">npm install itty-router</code>安装它。这款路由器专为cf工作人员打造，完全符合我们的目标。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要注意的是，在第32行，我们监听我们在介绍性段落中讨论的fetch事件，并用路由器的输出进行响应。在第12行，我们创建了路由器，然后我们将使用它来构建URL和方法模式以匹配请求。注意第15行的<code class="fe ms mt mu mv b">/info</code> GET端点，以及第29行返回404错误的通配符端点。</p><p id="0058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">/normalize</code>端点只接受post请求，它的回调函数使用请求事件作为参数。在第21行，我们读取请求的JSON主体，然后将<code class="fe ms mt mu mv b">body.array</code>(这是我们将随请求一起发送的数组)传递给<code class="fe ms mt mu mv b">normalized()</code>函数。最后，在第24行，我们返回一个带有规范化数组的响应对象。</p><p id="6a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续运行<code class="fe ms mt mu mv b">wrangler dev</code>来测试它，在本地主机上启动worker，并用下面的JSON主体创建一个post请求:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0fdf" class="na lw it mv b gy nb nc l nd ne">{"array":[1,2,3,4,5]}</span></pre><p id="725d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用httpie ( <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/using-mitmproxy-and-httpie-to-improve-api-development-and-testing-3c6c8b0b82c9">，正如我在本文</a>中解释的那样):</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3db7" class="na lw it mv b gy nb nc l nd ne">~/.../serverlessworker ❯ http localhost:8787/normalize array=\[1,2,3,4,5\]</span><span id="6fc2" class="na lw it mv b gy nv nc l nd ne">HTTP/1.1 200 OK<br/>...<br/>{<br/>  "array": [<br/>    0.0625,<br/>    0.125,<br/>    0.1875,<br/>    0.25,<br/>    0.3125<br/>  ]<br/>}</span></pre><p id="bdfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候将我们的工作人员部署到Cloudflare网络了，除非您需要更低的延迟或其他自定义功能，否则您将能够免费完成这些工作。</p><h1 id="e51f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">发布您的员工</h1><p id="835d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是最简单的一步，事实上，你只需要做两件事:</p><ol class=""><li id="24fe" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nw nn no np bi translated">用牧马人登录cloud flare:<code class="fe ms mt mu mv b">wrangler login</code></li><li id="8bb9" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nw nn no np bi translated">发布工人:在工人的根目录下，<code class="fe ms mt mu mv b">wrangler publish</code></li></ol><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d682" class="na lw it mv b gy nb nc l nd ne">~/.../medium/serverlessworker ❯ wrangler publish<br/>Delegating to locally-installed version of wrangler @ v2.0.17<br/>⛅️ wrangler 2.0.17 (update available 2.0.19)<br/>-------------------------------------------------------<br/>Retrieving cached values for account from node_modules/.cache/wrangler<br/>Total Upload: 1.61 KiB / gzip: 0.88 KiB<br/>Uploaded serverlessworker (2.73 sec)<br/>Published serverlessworker (6.65 sec)   </span><span id="cf96" class="na lw it mv b gy nv nc l nd ne">  serverlessworker.tdep.workers.dev</span></pre><p id="364e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经设置好了，如果您愿意，您可以使用下面的httpie命令来测试我的worker并规范化一个数组:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e058" class="na lw it mv b gy nb nc l nd ne">http serverlessworker.tdep.workers.dev/normalize array=\[1,2,3,4,5\]</span></pre></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="0597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这篇文章来说，这已经足够了，如果你对无服务器工人感兴趣，我建议继续关注，因为我计划就这个主题写更多(和更多中级)的文章。</p><p id="495c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>