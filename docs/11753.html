<html>
<head>
<title>Testing Kafka Applications —Libraries for Unit and Integration Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试Kafka应用程序——用于单元和集成测试的库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-kafka-applications-libraries-for-unit-and-integration-tests-732c0f13b915?source=collection_archive---------7-----------------------#2022-04-13">https://betterprogramming.pub/testing-kafka-applications-libraries-for-unit-and-integration-tests-732c0f13b915?source=collection_archive---------7-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="548a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为了卡夫卡消费者，卡夫卡生产者，溪流和春天——卡夫卡</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7abb4c974e0bf47fa3ba9001c7d18908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BeDBwQAte8kU2Dv9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@siora18?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Siora摄影</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5966" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你被赋予了一项涉及使用Kafka的任务，或者你正在设计一个全新的应用程序？即使不尝试使用TDD(测试驱动开发),牢记测试也是一个很好的实践。我在这里的目的不是给你测试的例子，网上有很多，大多数只是测试的框架，我发现通常非常有用的是在一个地方总结的信息，列表和要点(这是我的难题)。更重要的是，如果你最近才开始研究卡夫卡，你可能甚至不知道那里有什么。</p><p id="7788" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，这将是一个类和库的列表，您可以根据您已经决定在您的主实现中使用的库和类来用于您的单元和集成测试。</p><h1 id="3f4d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">卡夫卡消费者</h1><p id="c45f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了对您的简单消费者进行单元测试，您可以使用由<code class="fe mp mq mr ms b">org.apache.kafka:kafka-clients:X.X.X</code>库提供的<code class="fe mp mq mr ms b"><a class="ae kv" href="https://javadoc.io/doc/org.apache.kafka/kafka-clients/latest/org/apache/kafka/clients/consumer/MockConsumer.html" rel="noopener ugc nofollow" target="_blank">MockConsumer</a></code>。设置所有的测试非常简单和直观。在设计应用程序(或稍后进行重构)时，您需要记住的唯一一件事是使使用或包装KafkaConsumer实例的类是可测试的。这意味着让他们期待一个<code class="fe mp mq mr ms b">Consumer&lt;K, V&gt;</code>被传入，无论是通过调用工厂方法，直接在构造函数中，还是作为bean注入。</p><p id="2232" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建MockConsumer的实例，您只需匹配记录的键和值的类型，并“告诉”它从哪里开始读取:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="76fd" class="mx lt iq ms b gy my mz l na nb">val mockConsumer = MockConsumer&lt;String, String&gt;(OffsetResetStrategy.LATEST)</span></pre><p id="3e2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">KafkaConsumer</code>和<code class="fe mp mq mr ms b">MockConsumer</code>都实现了<code class="fe mp mq mr ms b">Consumer&lt;K,V&gt;</code>接口，所以一旦你把它传递给你正在测试的类，它就会像一个真正的消费者一样与之交互。这里的不同之处在于，您可以使用其他方法来为测试准备条件:</p><ul class=""><li id="e472" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">本质上是在开始测试之前准备要读取的记录</li><li id="8aeb" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe mp mq mr ms b">schedulePollTask()</code>在这里您可以传递任何Runnable以在随后的轮询中执行</li><li id="9377" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe mp mq mr ms b">setPollException()</code>检查您的消费者在异常情况下的行为</li></ul><p id="2ca4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这仅仅意味着单元测试，所以您在这里测试的基本上是您的真正消费者是否:</p><ul class=""><li id="7b0e" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">可以反序列化它要读取的记录</li><li id="b676" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">按预期处理记录——理想情况下是有责任划分的，所以这里的“处理”可能只是指将预期值传递给另一个处理业务逻辑的类，该类是单独进行单元测试的</li><li id="d14e" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">过滤任何记录(如果需要的话)</li><li id="841e" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">处理反序列化或处理中的错误</li><li id="af95" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">处理与Kafka的连接相关的错误——关于订阅、轮询或提交</li><li id="8c97" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">正确处理偏移量—是否提交、何时提交以及提交的频率</li></ul><p id="0a05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果您的用户以非标准的方式操作偏移量，那么您可以在所有的单元测试之间继续使用相同的实例，除了<code class="fe mp mq mr ms b">updateBeginningOffsets()</code>和<code class="fe mp mq mr ms b">updateEndOffsets().</code></p><h1 id="6fa4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">卡夫卡作品</h1><p id="8f2a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">kafka-clients</code>库还包括一个<code class="fe mp mq mr ms b"><a class="ae kv" href="https://javadoc.io/doc/org.apache.kafka/kafka-clients/latest/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">MockProducer</strong></a></code> <strong class="ky ir"> <em class="nq"> </em> </strong>类，它实现了与<code class="fe mp mq mr ms b">KafkaProducer</code>相同的接口<code class="fe mp mq mr ms b">Producer&lt;K, V&gt;</code>。因此，与上面的消费者测试类似，您的生产类应该以允许您传入模拟的方式来设计。</p><p id="75e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建一个<code class="fe mp mq mr ms b">MockProducer</code>的实例，您需要匹配键的类型和记录的值，并“告诉”它是自动成功完成<code class="fe mp mq mr ms b">send</code>请求(autocomplete=true ),还是希望通过调用<code class="fe mp mq mr ms b">completeNext()</code>或<code class="fe mp mq mr ms b">errorNext()</code>来显式完成它们。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="edff" class="mx lt iq ms b gy my mz l na nb">val mockProduer = MockProducer(true, StringSerializer(), StringSerializer())</span></pre><p id="3755" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试您的生产者的正常工作流程，您将希望为您的生产者安排一些工作，使用autocomplete，然后使用MockProducer上的<code class="fe mp mq mr ms b">history()</code>方法检查已经发送了什么。这将返回自上次您在模拟上调用<code class="fe mp mq mr ms b">clear()</code>以来发送的所有ProducerRecord-s的列表。</p><p id="ca0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试您如何处理异常，您可以将autocomplete设置为false，并将<code class="fe mp mq mr ms b">errorNext()</code>设置为，这将在下一个未完成的<code class="fe mp mq mr ms b">send</code>调用中抛出您传递的任何RuntimeException。</p><p id="fc22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，测试能力也仅限于单元测试，所以你要验证的是你的生产者是否:</p><ul class=""><li id="9f07" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">可以序列化它需要的记录</li><li id="05fe" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">处理序列化错误</li><li id="884a" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">处理与Kafka连接相关的错误-即在<code class="fe mp mq mr ms b">send()</code>上</li><li id="6ad3" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">正确应用任何过滤，即实际发送的记录数量与您预期的数量相匹配</li><li id="4aa6" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">以预期的格式发送记录—任何丰富或重新格式化都被正确应用</li></ul><h1 id="70b4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">卡夫卡流</h1><p id="8b4e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于流来说，测试类和生产类被划分到不同的库中，所以您需要添加<code class="fe mp mq mr ms b">org.apache.kafka:kafka-streams:X.X.X</code>依赖项来使用流，然后添加<code class="fe mp mq mr ms b">org.apache.kafka:kafka-streams-test-utils:X.X.X</code>依赖项来使用方便的测试类。</p><p id="b99b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，事情反过来进行——不是创建一个模拟并将其传递给测试的类，而是通过传入拓扑和属性来创建一个<code class="fe mp mq mr ms b"><a class="ae kv" href="https://kafka.apache.org/30/javadoc/org/apache/kafka/streams/TopologyTestDriver.html" rel="noopener ugc nofollow" target="_blank">TopologyTestDriver</a></code>的实例。因此，在这里使您的应用程序单元可测试意味着有一种方法来创建您的拓扑并将其传递给测试驱动程序。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0279" class="mx lt iq ms b gy my mz l na nb">val driver = TopologyTestDriver(myTopology, myProperties)</span></pre><p id="ac74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦有了驱动程序实例，就需要为拓扑显式地创建所有主题:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="2f1b" class="mx lt iq ms b gy my mz l na nb">val myInputTopic = driver.<strong class="ms ir">createInputTopic</strong>(<br/>       inputTopicName, <br/>       Serdes.String().serializer(), // key type<br/>       Serdes.String().serializer()  // value type<br/>)</span><span id="c18e" class="mx lt iq ms b gy nr mz l na nb">val myOutputTopic = driver.<strong class="ms ir">createOutputTopic</strong>(<br/>       outputTopicName, <br/>       Serdes.String().deserializer(), //  key type<br/>       Serdes.String().deserializer()  //  value type<br/>)</span><span id="cd55" class="mx lt iq ms b gy nr mz l na nb">.... // create as many output topics as your topology has</span><span id="5689" class="mx lt iq ms b gy nr mz l na nb">val myDlqTopic = driver.<strong class="ms ir">createOutputTopic</strong>(<br/>       dlqTopicName, <br/>       Serdes.String().deserializer(), //  key type<br/>       Serdes.String().deserializer()  //  value type<br/>)</span></pre><p id="7716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将所有的<a class="ae kv" href="https://kafka.apache.org/30/javadoc/org/apache/kafka/streams/TestInputTopic.html" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nq">TestInputTopic</em></strong></a>和<a class="ae kv" href="https://kafka.apache.org/30/javadoc/org/apache/kafka/streams/TestOutputTopic.html" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nq">TestOutputTopic</em></strong></a>设置好，就可以开始测试了！激动人心！</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="87d9" class="mx lt iq ms b gy my mz l na nb">myInputTopic.<strong class="ms ir">pipeInput</strong>(key, validValue)<br/>...<br/>assertTrue(myDlqTopic.isEmpty)<br/>assertFalse(myOutputTopic.isEmpty)</span><span id="c6f1" class="mx lt iq ms b gy nr mz l na nb">val actualRecord = myOutputTopic.<strong class="ms ir">readRecord</strong>()<br/>assertEquals(expectedRecord, actualRecord, "Oh no, records don't match)</span></pre><p id="33e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以同时处理多个输入值:</p><ul class=""><li id="7de0" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><code class="fe mp mq mr ms b">pipeValueList(List&lt;V&gt;)</code> —如果您的测试类只关心值</li><li id="a02c" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe mp mq mr ms b">pipeKeyValueList(List&lt;KeyValue&lt;K,V&gt;&gt;</code> —如果你的测试类只关心键和值</li><li id="721f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe mp mq mr ms b">pipeRecordList(List&lt;TestRecord&lt;K,V&gt;&gt;</code>——如果您的测试类只使用任何标题或时间戳</li></ul><p id="0700" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，对于输出:</p><ul class=""><li id="64d4" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><code class="fe mp mq mr ms b">readValuesToList()</code> —如果您只需要验证输出值</li><li id="7380" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe mp mq mr ms b">readKeyValuesToList()</code>或<code class="fe mp mq mr ms b">readKeyValuesToMap()</code> —如果您只需要验证输出的键和值</li><li id="f631" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe mp mq mr ms b">readRecordsToList()</code> —如果您需要检查输出的标题和时间戳</li></ul><p id="89c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们仍然在这里讨论单元测试，所以检查是非常基本的——您验证您的流:</p><ul class=""><li id="9055" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">可以序列化和反序列化它需要的记录</li><li id="60b9" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">以期望的方式处理任何异常</li><li id="e88c" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">按预期处理记录—输出格式与预期格式匹配，将流视为黑盒</li><li id="930a" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">是否按预期进行过滤—无论输入了多少条记录，输出记录的数量都与预期的数量相匹配</li></ul><h1 id="0b77" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">流处理器</h1><p id="2fdd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你正在使用一个处理器来处理你可以使用一个<a class="ae kv" href="https://kafka.apache.org/28/javadoc/org/apache/kafka/streams/processor/MockProcessorContext" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nq">MockProcessorContext</em></strong></a>来初始化你的那个接口的实现。使用它，您可以检查记录是否被转发到正确的主题，以及偏移量是否被提交。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="13b5" class="mx lt iq ms b gy my mz l na nb">val mockContext = MockProcessorContext&lt;String, String&gt;()<br/>val processor = MyProcessor() // implementing Processor<br/>processor.init(mockContext)</span><span id="ce8e" class="mx lt iq ms b gy nr mz l na nb">...</span><span id="5cd7" class="mx lt iq ms b gy nr mz l na nb">processor.process(record)<br/>val forwardedRecords = mockContext.forwareded()<br/>assertEquals(1, forwardedRecords.size)<br/>assertEquals(expectedRecord, forwardedRecords.map{it.record()}.first())<br/>assertEqual(expectedTopic, forwardedRecords[0].childName().get())</span><span id="80c1" class="mx lt iq ms b gy nr mz l na nb">// if you have scheduled commit (or other action) manipulate time by</span><span id="4ff0" class="mx lt iq ms b gy nr mz l na nb">mockContext.scheduledPunctuators()[0].punctuator.punctuate(time)</span><span id="77fa" class="mx lt iq ms b gy nr mz l na nb">// check if scheduled task is done</span><span id="bf9c" class="mx lt iq ms b gy nr mz l na nb">assertTrue(mockContext.committed())</span></pre><h1 id="6e6f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">集成测试</h1><p id="bbd4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有多种方法可以做到这一点，因此我将列出一些方法，您可以探索并测试哪些方法适合您:</p><h2 id="f8e6" class="mx lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">KafkaStreams的嵌入式KafkaCluster</h2><p id="62a9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在<code class="fe mp mq mr ms b">org.apache.kafka:kafka-streams-test-utils</code>库中，有几个更有帮助的类，其中一个是<a class="ae kv" href="https://github.com/a0x8o/kafka/blob/master/streams/src/test/java/org/apache/kafka/streams/integration/utils/EmbeddedKafkaCluster.java" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nq">embeddedcafkacluster</em></strong></a><strong class="ky ir"><em class="nq">。</em> </strong>这将启动一个带有1个zookeeper实例和可配置数量的代理的内存Kafka集群。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="b1fb" class="mx lt iq ms b gy my mz l na nb">class MyKafkaStreamIntegrationTest{<br/>    @ClassRule<br/>    val cluster = EmbeddedSingleNodeKafkaCluster()<br/>     <br/>    @BeforeAll<br/>    fun setup() {<br/>        cluster.createTopic(myTopic)<br/>        // ... other setup<br/>    }<br/>  <br/>    // ... startup app and test</span></pre><h2 id="b5c5" class="mx lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">春天的嵌入式卡夫卡</h2><p id="d0fb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用<code class="fe mp mq mr ms b">org.springframework.kafka:spring-kafka-test</code>库，你可以访问运行在<code class="fe mp mq mr ms b">localhost:9092.</code>的kafka的“嵌入式”内存实例。要使用它，你只需要用<a class="ae kv" href="https://docs.spring.io/spring-kafka/reference/html/#embedded-kafka-annotation" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nq">embedded Kafka</em></strong></a>来注释你的测试类</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="ed03" class="mx lt iq ms b gy my mz l na nb">@SpringBootTest<br/>@DirtiesContext // if have more than one test class using kafka<br/>@EmbeddedKafka(partitions=1, brokerProperties = {..}<br/>class MySpringIntegrationTest{<br/>    // startup your app and assert <br/>}</span></pre><h2 id="85b3" class="mx lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">测试容器</h2><p id="d445" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">内存中的实例很可能与Kafka和Zookeeper的实际实现不同，因此也可以选择为您的<code class="fe mp mq mr ms b"><a class="ae kv" href="https://www.testcontainers.org/modules/kafka/" rel="noopener ugc nofollow" target="_blank">KafkaContainer</a></code> <strong class="ky ir"> <em class="nq">使用docker容器。</em>T29】</strong></p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="870d" class="mx lt iq ms b gy my mz l na nb">KafkaContainer kafka = KafkaContainer(DockerImageName.parse(“confluentinc/cp-kafka:6.2.1”))<br/>// configure<br/>kafka.start()</span></pre><h2 id="6e57" class="mx lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">查理特的卡夫卡-朱尼特</h2><p id="b30a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是一个不太标准的<a class="ae kv" href="https://github.com/charithe/kafka-junit" rel="noopener ugc nofollow" target="_blank">库</a>，但是它完成了工作并提供了一些方便的方法，你可能会发现这些方法很有用，因此值得在这里提及。它有一个junit4和5实现:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="3b28" class="mx lt iq ms b gy my mz l na nb"><a class="ae kv" href="http://twitter.com/ClassRule" rel="noopener ugc nofollow" target="_blank">@ClassRule</a><br/>public static KafkaJunitRule kafkaRule = new KafkaJunitRule(EphemeralKafkaBroker.create());</span><span id="578e" class="mx lt iq ms b gy nr mz l na nb">@ExtendWith(KafkaJunitExtension.class)<br/>@KafkaJunitExtensionConfig(startupMode = StartupMode.WAIT_FOR_STARTUP)</span></pre><p id="98dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你能在这里找到一些有用的信息。</p><p id="7596" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>