<html>
<head>
<title>Currying Inside JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Currying</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/currying-inside-javascript-a19f29600880?source=collection_archive---------5-----------------------#2019-09-09">https://betterprogramming.pub/currying-inside-javascript-a19f29600880?source=collection_archive---------5-----------------------#2019-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">适用于任何地方的概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67c4091d6d1b20d7fa05293854041b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KajCJ8_Yl4BW98JU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Currying </strong>是处理函数时的一种高级技术，在多种编程语言中都有使用。</p><p id="5fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你把一个接受多个参数的函数分解成一系列嵌套函数时，你就有了一个<em class="lv">库里</em>。每个嵌套函数都应该有函数的下一个参数。</p><p id="86d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">curry函数每次都会返回一个新函数，直到每次调用都收到所有的参数。这些参数可以贯穿整个闭包过程，并将全部用于执行最终的函数。</p><p id="617b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个非常基本的例子是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="adaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用它，您可以多次调用该函数，直到它到达最后一个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="665e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在发生的是<code class="fe ly lz ma mb b">combineWords</code>是一个固化的函数(很明显),在它执行系列中的下一个函数之前等待一个单词。您可以将<code class="fe ly lz ma mb b">'wow!'</code>到<code class="fe ly lz ma mb b">combineWords</code>绑定到一个变量，并重用它来创建其他以<code class="fe ly lz ma mb b">'wow!'</code>开头的问候语:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个概念有点难以理解，可以试着这样理解:“母亲在烹饪前期待所有四个鸡蛋(论点)，她的四个孩子将每人拿一个给她，一次一个。”</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于要调用的<code class="fe ly lz ma mb b">cook</code>回调，需要一个接一个地传入所有四个鸡蛋，每个鸡蛋都预先填充下一个函数，等待调用。</p><p id="54af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你停在第三个蛋上:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="535d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，由于还没有到达期望的最后一个函数<code class="fe ly lz ma mb b">egg4</code>，所以<code class="fe ly lz ma mb b">collect</code>的值就是那个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="fe9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完成咖喱，收集最后一个鸡蛋:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="ca43" class="mg mh it mb b gy mi mj l mk ml">let collect = start(new Egg())<br/>collect = collect(new Egg())<br/>collect = collect(new Egg())<br/>collect = collect(new Egg())</span><span id="8752" class="mg mh it mb b gy mm mj l mk ml"><em class="lv">// collect === 'served'</em></span></pre><p id="86dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，重要的是要知道每个嵌套函数都可以访问curry函数的外部作用域。了解了这一点，您就可以在每个嵌套函数之间提供定制逻辑，以适应特定的情况。但是最好留下一个咖喱作为咖喱，不要其他的。</p><p id="6f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更高级的curry函数可以如下图。我将提供一个<code class="fe ly lz ma mb b">ES5</code>版本和一个<code class="fe ly lz ma mb b">ES6</code>版本，因为有很多展示ES5语法的旧教程，对于新的JavaScript开发人员来说可能有点难以阅读。</p><p id="1d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES5:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="dad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES6:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更详细地解释这个例子。</p><p id="6859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您调用<code class="fe ly lz ma mb b">curry(fn)</code>时，它将返回内部的<code class="fe ly lz ma mb b">curried</code>函数，该函数将在调用时等待下一个参数。当你调用这个内部函数时，它会计算两个条件:</p><ol class=""><li id="22f4" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">调用者传入的参数是否足够满足<code class="fe ly lz ma mb b">fn</code>的所有参数？</li><li id="d8fd" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">还是仍然缺少<code class="fe ly lz ma mb b">fn</code>需要的参数？</li></ol><p id="1276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<em class="lv">1</em>是这种情况，我们就有了<code class="fe ly lz ma mb b">fn</code>声明的所有我们需要的参数，库里将通过返回对<code class="fe ly lz ma mb b">fn</code>的调用并将所有收到的参数传递给它(现在基本上正常调用<code class="fe ly lz ma mb b">fn</code>)来结束。</p><p id="02dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果<em class="lv">数字2 </em>是这种情况，咖喱必须继续，我们必须以某种方式回到内部<code class="fe ly lz ma mb b">curried</code>函数，以便我们可以继续接收更多的参数，直到它满足<code class="fe ly lz ma mb b">fn</code>的参数。代码<code class="fe ly lz ma mb b">return (...args2) =&gt; curried.apply(this, [...args, ...args2])</code>累积了到目前为止公开的所有参数，并使用它们继续这种情况下的搜索。</p><p id="30f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一条重要的规则:</p><p id="2300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在等待收集所有参数之前要调用的函数必须有固定数量的参数。这意味着该函数不能有扩展参数(如<code class="fe ly lz ma mb b">fn(...args)</code>)</p><p id="8a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="393f" class="ni mh it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">结论</h1><p id="cf3d" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我认为咖喱是一个有趣的技术，因为创造一个咖喱涉及到其他先进的技术。这里涉及到闭包、高阶函数和递归。</p><p id="6a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章到此结束。我希望你找到了一些有价值的东西，并在未来寻找更多！</p></div></div>    
</body>
</html>