<html>
<head>
<title>The Power of Simplifying Large Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中简化大型组件的强大功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-simplifying-large-components-in-react-c0d15fa88f70?source=collection_archive---------14-----------------------#2020-01-03">https://betterprogramming.pub/the-power-of-simplifying-large-components-in-react-c0d15fa88f70?source=collection_archive---------14-----------------------#2020-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e4c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简化是一种增强</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/da5d50bc3f27f755bf320593ee217617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFiicJQ5YmouaBdwJvpaCA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">照片由</em> <a class="ae kz" href="https://unsplash.com/@plushdesignstudio" rel="noopener ugc nofollow" target="_blank"> <em class="ky">毛绒设计工作室</em></a><em class="ky"/><a class="ae kz" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"><em class="ky">Unsplash</em></a></p></figure><p id="ec83" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">拥有大型组件并不总是一件坏事，但是利用可以进一步简化组件的机会是一个很好的实践——特别是当它提供额外的好处时。</p><p id="de88" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当您有一个大的组件时，这可能会变得不利，因为组件越大，随着时间的推移维护和读取就越困难。</p><p id="c498" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们看看下面的这个组件，看看为什么我们最好简化它。</p><p id="a2f0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">(这是来自生产应用的代码，所以这实际上是一个真实的例子。)</p><p id="3572" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面的组件<code class="fe lw lx ly lz b">SidebarSection</code>使用了一些道具——其中<code class="fe lw lx ly lz b">props.ids</code>是一个字符串形式的条目id数组，而<code class="fe lw lx ly lz b">props.items</code>是一个使用每个条目的<code class="fe lw lx ly lz b">id</code>作为键来映射侧栏条目的对象。它使用这些属性来呈现侧栏项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="1515" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">组件实际上看起来没那么糟糕。但是如果你想一想，每当我们编辑组件时，我们必须在引入更改之前理解每一行代码，因为我们不知道更改某些东西是否会破坏组件的其他部分。</p><p id="a30e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一个例子是在开关盒中创建的<code class="fe lw lx ly lz b">onHoverAction</code>函数。它不必要地膨胀了我们的组件，并且根据<code class="fe lw lx ly lz b">SidebarItem</code>的实现，它有可能导致一个无限循环，因为每次组件重新呈现时，对它的引用都会被重新创建。</p><p id="1be8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这也使得整个组件对单元测试更加敏感，因为我们委托<code class="fe lw lx ly lz b">SidebarSection</code>组件负责<code class="fe lw lx ly lz b">onHoverAction</code>的实现细节。</p><p id="76a8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我们的单元测试中，当我们测试<code class="fe lw lx ly lz b">SidebarSection</code>组件行为正确时，我们必须知道<code class="fe lw lx ly lz b">onHoverAction</code>的实现细节。这没有太大意义。(这意味着要注意语法错误之类的事情——因为函数中的一个输入错误可能会破坏<code class="fe lw lx ly lz b">SidebarSection</code>的呈现，我们会责怪组件做得不好。)</p><p id="7a0d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以通过简单地将它提取到外部来简化这一点，这样我们就不必再将责任推给组件了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="25fb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们所做的只是将该功能转移到另一个地方，几乎不用付出任何额外的努力，它已经给我们带来了巨大的好处:</p><ol class=""><li id="70ad" class="mc md it lc b ld le lg lh lj me ln mf lr mg lv mh mi mj mk bi translated">对该函数的引用将保持不变。</li><li id="df74" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">现在可以过平静的生活了。因为它不再需要担心正确实现<code class="fe lw lx ly lz b">onHoverAction</code>。它所需要做的就是通过<code class="fe lw lx ly lz b">onHoverAction</code>所期望的争论。</li><li id="091e" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">我们现在可以单独对<code class="fe lw lx ly lz b">onHoverAction</code>进行单元测试，因为它可以作为导出来使用。想看看这是否如预期的那样工作吗？简单地导入它，传入三个参数，看看它返回什么。</li><li id="6884" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated"><code class="fe lw lx ly lz b">SidebarSection</code>变得更容易阅读和维护。</li></ol><p id="8239" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这实际上并不是我们能简化它的全部。我们还有机会进一步简化组件。这两个开关模块中有重复的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d385" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让它保持原样实际上可能不会成为太大的问题。然而，我确信任何阅读这段代码的开发人员都有义务一行一行地阅读每一个prop，以便100%确定它们没有那么不同。</p><p id="a6bc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">毕竟，在理想情况下，我们愿意相信有重要的原因导致看起来相似的代码被分离，那么为什么这些代码会被分离呢？在我们的例子中，没有太多好的理由，所以简化它是一个好主意，这样未来的开发人员在尝试调试这个组件时就不会陷入这种尴尬的场景。</p><p id="451f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以通过简单地这样做来简化它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="45cf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">简单来说，这提供了几个重要的好处:</p><ol class=""><li id="4c79" class="mc md it lc b ld le lg lh lj me ln mf lr mg lv mh mi mj mk bi translated">我们消除了重复的代码。</li><li id="e2c2" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">现在阅读起来更容易了，因为我们只需要查看代码的一个副本。</li><li id="8cb6" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">自文档化代码(它基本上告诉我们类型为<code class="fe lw lx ly lz b">notebook</code>和<code class="fe lw lx ly lz b">static</code>的项目几乎完全相同——类型为<code class="fe lw lx ly lz b">notebook</code>的项目可以点击，而类型为<code class="fe lw lx ly lz b">static</code>的项目不能点击)。</li></ol></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="9f9a" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">当简化适得其反</h1><p id="a8f1" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">现在还有一些我们可以简化的东西。尽管我们的开关盒变短了一点，但看起来还是有点难看。</p><p id="9a95" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是我们的<code class="fe lw lx ly lz b">SidebarSection </code>组件在应用了简化更改后的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="eec1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们在这里可能会遇到的一个问题是，我们给了每个项目的渲染块太多的责任，让它负责将正确的道具传递给正确的组件。</p><p id="a930" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们是这样想的，那么这样写可能更好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="85c1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，我们进一步将<code class="fe lw lx ly lz b">SidebarSection</code>简化为只负责调用<code class="fe lw lx ly lz b">getProps</code>来提供相关的道具，并根据<code class="fe lw lx ly lz b">item.type</code>分配正确的<code class="fe lw lx ly lz b">Component</code>。我们现在可以对<code class="fe lw lx ly lz b">getProps</code>进行单元测试，以确保他们根据<code class="fe lw lx ly lz b">item.type</code>返回正确的道具。</p><p id="e8c2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是简化React代码的好尝试吗？让我们来看看获得的好处与引入的缺点:</p><p id="2daf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好处:</p><ol class=""><li id="6d76" class="mc md it lc b ld le lg lh lj me ln mf lr mg lv mh mi mj mk bi translated"><code class="fe lw lx ly lz b">SidebarSection</code>减轻了自己的责任。</li><li id="2a19" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated"><code class="fe lw lx ly lz b">SidebarSection</code>变小了。</li><li id="dc99" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">我们可以清楚地看到什么道具被注入到哪个组件中。</li><li id="3397" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">我们现在不必在<code class="fe lw lx ly lz b">key={key}</code>中传递四次，而是像<code class="fe lw lx ly lz b">&lt;Component key={key}</code>一样传递</li></ol><p id="b33a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">缺点:</p><ol class=""><li id="6ca7" class="mc md it lc b ld le lg lh lj me ln mf lr mg lv mh mi mj mk bi translated"><code class="fe lw lx ly lz b">SidebarSection</code>变小，但文件变大。</li><li id="7957" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">一个实体(所有的东西都在<code class="fe lw lx ly lz b">SidebarSection</code>里面)变成了三个实体(现在分成了<code class="fe lw lx ly lz b">SidebarSection</code>、<code class="fe lw lx ly lz b">onHoverAction</code>和<code class="fe lw lx ly lz b">getProps</code>)。</li><li id="d212" class="mc md it lc b ld ml lg mm lj mn ln mo lr mp lv mh mi mj mk bi translated">通过从上到下滚动来完成整个过程，给我们的鼠标施加更多的压力。</li></ol></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="3aee" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">这值得吗？</h1><p id="9fd6" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">在我看来，如果最后一杆花的时间太长，那就不值得。这个故事的寓意是，当不需要太多努力就能提供多种好处时，简化代码绝对是值得的。</p><p id="e78d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以在我们的文章中，我支持前两个简化的尝试，而我对第三个有点犹豫不决。</p><p id="9dc8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，我们现在已经看到了在React中简化大型组件的力量。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="e3f3" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">结论</h1><p id="2e4f" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated">这部分就结束了。我希望你发现这是有价值的，并期待在未来更多。</p></div></div>    
</body>
</html>