<html>
<head>
<title>Python Loops Performance Compared: The Fastest Is…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python循环性能比较:最快的是…</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-loops-performance-compared-the-fastest-is-b4638744a1ff?source=collection_archive---------3-----------------------#2022-07-08">https://betterprogramming.pub/python-loops-performance-compared-the-fastest-is-b4638744a1ff?source=collection_archive---------3-----------------------#2022-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abc0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入分析Python for-each、for-range和while循环，以找到最佳循环</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b515f130f72fd4dd7b8b7321bca1cb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8-7GBn78ThsLxslp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jon_chng?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jonathan Chng </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，主要有三种迭代对象集合的方法:for-each循环、for-range循环和while循环。虽然他们都完成相同的基本目标，但他们在幕后的工作方式不同。因此，它们的性能会有很大差异，并导致程序的执行速度不理想。</p><p id="5d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将首先比较遍历性能基准的三种方式。然后，我们将探索每个循环对Python虚拟机来说实际上是什么样子，并讨论为什么一种方法比其他方法好。</p><h1 id="d020" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">性能基准</h1><p id="4239" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在进入Python循环的工作细节之前，我们首先确定哪种方法是最快的。下面的脚本比较了完成相同任务的三个函数的执行速度，使用<code class="fe ms mt mu mv b">timeit</code>模块以不同的方式循环遍历一个列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能猜出哪个循环最快，哪个效率最低吗？准备好之后，看看控制台输出的基准测试结果:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="23f2" class="nc lw it mv b gy nd ne l nf ng">Foreach loop:       0.011 seconds<br/>While loop:         0.076 seconds<br/>For range loop:     0.042 seconds</span><span id="dfcd" class="nc lw it mv b gy nh ne l nf ng">The fastest method is Foreach loop with 0.011 seconds</span></pre><p id="0b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，for-each循环比其竞争对手的表现好得多。此外，最快的竞争者和较宽松的while循环之间的执行速度差异很大:for-each循环比while循环快六倍以上。甚至for-range循环也比while循环快近两倍。</p><p id="e148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，停一会儿，想想你用得最多的是哪个循环。是时候改变你的编程风格了吗？无论如何，无论您已经使用了最有效的方法还是任何其他较差的方法，都是时候探究一下为什么for-each循环比它的对应循环快得多了。</p><h1 id="2655" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Python如何看待循环</h1><p id="89c7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可能已经知道，Python源代码首先被编译成特定的Python字节码，由Python虚拟机运行，该程序将这种与架构无关的字节码转换成机器指令，供CPU执行。为了分析Python你的源代码循环如何看到你的代码，我们可以看一下生成的字节码(你有没有注意到那些<code class="fe ms mt mu mv b">.pyc</code>文件？).</p><p id="7b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让我们的生活更轻松，我们将使用<a class="ae ky" href="https://godbolt.org/" rel="noopener ugc nofollow" target="_blank">编译器资源管理器</a>，这是一个非常棒的在线工具，让您可以在舒适的网络浏览器中轻松分析编译后的源代码。</p><p id="55d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来看看翻译成Python字节码的while循环。别担心，我会根据需要通过评论仔细解释一切。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="dae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是人们所期望的工作方式，不是吗？现在让我们更仔细地看一下for-range循环。不过，在这里我会开得快一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="20ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里可以看到使用了内置的<code class="fe ms mt mu mv b">range()</code>函数和<code class="fe ms mt mu mv b">FOR_ITER</code>指令，而不是手动增加索引。速度优势在于使用内置特性，因为它们是用C实现的(因此已经编译成机器码)。更多信息，请看一下用c编写的默认Python解释器<a class="ae ky" href="https://en.wikipedia.org/wiki/CPython" rel="noopener ugc nofollow" target="_blank"> CPython </a></p><p id="6fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，下面是for-each循环生成的字节代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这里我们几乎只使用了内置特性，这些特性总是比纯Python要快。这就是为什么for-each循环比它的对应循环快得多，因为繁重的负载是由Python解释器本身以一种优化的方式处理的。</p><p id="6241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，for-each循环需要更少的指令，从而使您的程序更小。你几乎不会注意到现实世界中的任何差异，但这仍然是一个理论上的好处。</p><p id="1f31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，有些人可能会说，您的应用程序并不总是需要最高的性能，使用效率最低的循环类型对于许多用例来说并没有太大的区别。虽然这有时是正确的，例如在测试或原型开发时，编写优化的代码总是更好，特别是如果唯一需要的工作是使用内置的函数和特性，而不是在纯Python中自己实现它们。</p><p id="baaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在考虑改变您的技术堆栈或在CPU内核或RAM等系统资源上花费更多之前，您应该检查您的软件是否有类似这样的潜在优化。</p><h2 id="095f" class="nc lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">但是我还需要索引和元素</h2><p id="89e9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果需要元素和列表索引，可以考虑使用for-range循环类型。然而，有一个Python内置函数<code class="fe ms mt mu mv b">enumerate()</code>可以做到这一点。下面是这两种方法的性能比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基准测试结果:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="ae46" class="nc lw it mv b gy nd ne l nf ng">For range loop:     0.043 seconds<br/>For enumerate loop: 0.036 seconds</span><span id="073f" class="nc lw it mv b gy nh ne l nf ng">The fastest method is For enumerate loop with 0.036 seconds</span></pre><p id="6aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以清楚地看到，内置函数总是比纯Python代码有优势。在这种情况下，索引列表和获取第I个元素的负担就从代码的肩上卸下来了，由CPython来处理。</p><p id="43ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您感兴趣，下面是for-enumerate循环的注释字节代码，它与for-each和for-range循环非常相似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="8517" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关键要点</h1><p id="f5d3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总结一下，虽然Python中有很多循环方式，但显然更好的方法是使用for-each循环。一般来说，您应该总是更喜欢内置的Python函数和结构，因为它们比纯Python版本更优化，因为它们是用C编写的，并且已经编译成机器代码。</p><blockquote class="nt"><p id="1fe5" class="nu nv it bd nw nx ny nz oa ob oc lu dk translated">走向精通的第一步是了解你的武器，它们的长处和短处，并以最佳状态使用它们。</p></blockquote><p id="4fd2" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">我希望你喜欢这篇文章。如果你有什么要补充的，请在评论中分享你的想法。感谢阅读！</p><p id="5a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣了解关于编译器资源管理器的更多信息，我建议您查看下面的故事:</p><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/compiler-explorer-a-must-have-tool-for-software-developers-98e7f4d6e94c"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">编译器资源管理器:软件开发人员的必备工具</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">从一个舒适的浏览器选项卡中轻松分析、比较和优化源代码</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">better编程. pub</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>