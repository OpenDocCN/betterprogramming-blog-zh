<html>
<head>
<title>Reusable Customisable Views in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中可重复使用的可定制视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reusable-customisable-views-in-swiftui-db6af84639fa?source=collection_archive---------12-----------------------#2022-08-24">https://betterprogramming.pub/reusable-customisable-views-in-swiftui-db6af84639fa?source=collection_archive---------12-----------------------#2022-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="33af" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过两个实现来理解</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1c5ef1ec00b344c27fe38486a1cb868d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1gnwD2mIejeYfnEBwWgTdg.png"/></div></div></figure><p id="74c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SwiftUI在重用视图方面非常出色，但创建可定制的可重用视图可能非常棘手，因为SwiftUI需要在编译时知道视图层次结构中每个视图的类型。让我们考虑下面的设计(这里设计的质量不是问题，只是想法)。</p><p id="6019" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有四个工具栏对应四个不同的屏幕。它们都有一些共同的特点，如<em class="ln">完成</em>按钮和标题。此外，一些屏幕在侧面有一个或两个自定义视图，如倾斜<strong class="kt ir"> ⁽ ⁾ </strong>和尺寸<strong class="kt ir"> ⁽ ⁾ </strong>指示器以及颜色指示器<strong class="kt ir"> ⁽ ⁾ </strong>和尺寸步进器<strong class="kt ir"> ⁽⁴⁾ </strong>。</p><p id="1726" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该工具栏将成为可定制可重用视图的绝佳候选，因为我们有一个通用的重复模式，并且有一个适用于每个非通用组件的概念——定制视图只能位于工具栏的左侧和右侧。</p><p id="9372" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有两种方法可以做到。</p><ol class=""><li id="366e" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">通过创建包含所有(自定义和公共)视图的视图，并基于配置模型显示它们</li><li id="b430" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">通过创建描述基本模板的视图并接受自定义视图作为参数</li></ol><p id="226a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第一种方法</strong>更容易实现和理解，但从长远来看，更难维护和添加新的变体。首先，我们需要有一个模型来描述所有可能的布局。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="49ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面代码中描述的<code class="fe me mf mg mh b">HeaderViewModel</code>、<em class="ln">、</em>，涵盖了工具栏的任何变体。我们现在需要的是一个理解这个模型的视图，并且可以根据模型配置显示任何视图组合。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="543c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，<code class="fe me mf mg mh b">HeaderView</code> <em class="ln">，</em>总是<em class="ln"> </em>显示标题，并根据所提供的模型有条件地显示左边的<em class="ln"> </em>按钮和任何自定义视图。</p><p id="411e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法的问题是，如果我们有一个工具栏设计的新变体，我们将需要修改<code class="fe me mf mg mh b">HeaderView</code> <em class="ln"> </em>和<code class="fe me mf mg mh b">HeaderViewModel</code> <em class="ln"> </em>来提供要显示的配置和UI。</p><p id="d50b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更好的方法是让<code class="fe me mf mg mh b">HeaderView</code> <em class="ln"> </em>的客户端在初始化阶段提供自定义的左右视图，这样<code class="fe me mf mg mh b">HeaderView</code> <em class="ln"> </em>就不需要知道除了通用UI和通用配置之外的任何东西。</p><p id="5d6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第二种方法</strong>描述了<code class="fe me mf mg mh b">HeaderView</code> <em class="ln"> </em>的客户端如何重用公共UI和功能，并直接构造和提供自定义控件。这种方法更具可伸缩性，因为定制控件总是由客户端提供，而不需要更新<code class="fe me mf mg mh b">HeaderView</code> <em class="ln"> </em>或<code class="fe me mf mg mh b">HeaderViewModel</code><em class="ln"/>。这种方法也更灵活，因为客户端可以访问正在显示的实际定制视图，而不是只访问模型。</p><p id="b598" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要让<code class="fe me mf mg mh b">HeaderView</code>接受描述左自定义视图和右自定义视图的两个视图。由于<code class="fe me mf mg mh b">HeaderView</code>不能像我们在UIKit中使用UIView一样，只接受SwiftUI中任何视图的基本类型(技术上我们可以使用<code class="fe me mf mg mh b">AnyView</code>，但这会带来性能损失，并且需要客户端在<code class="fe me mf mg mh b">AnyView</code>中包装自定义视图，这并不理想)，我们将向<code class="fe me mf mg mh b">HeaderView</code>添加两个符合视图协议的通用参数，它将保存客户端提供的视图类型。</p><blockquote class="mi mj mk"><p id="7141" class="kr ks ln kt b ku kv jr kw kx ky ju kz ml lb lc ld mm lf lg lh mn lj lk ll lm ij bi translated"><strong class="kt ir">注意:</strong> SwiftUI在编译时需要知道视图层次结构中每个视图的类型，这就是为什么提供带有通用参数的定制视图类型是必要的。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="e860" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们有一个更新的<code class="fe me mf mg mh b">HeaderView</code> <em class="ln"> </em>可以显示任何种类的视图作为左控件和右控件。这些视图的类型总是某种类型的<em class="ln">视图</em>并且客户端负责提供它。我们将自定义视图作为用<em class="ln"> ViewBuilder </em>属性修饰的闭包传递给<code class="fe me mf mg mh b">HeadingView</code>初始化器，以便在表达自定义视图的构造时给予客户端最大的灵活性。</p><p id="9c65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，客户端可以在<code class="fe me mf mg mh b">HeaderView</code>初始化阶段提供左右控件，并且不会溢出任何与定制视图相关的功能<em class="ln">。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="253e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当提供左视图和右视图时，这种方法非常有效，但是当我们不需要左视图和右视图，或者除了标题和左按钮之外不需要任何自定义视图时，该怎么办呢？SwiftUI为我们提供了一个叫做<code class="fe me mf mg mh b">EmptyView</code> <em class="ln">的占位符视图。</em>对于不需要左控制键、右控制键或两者都不需要的情况，我们可以传递一个<code class="fe me mf mg mh b">EmptyView</code> <em class="ln"> </em>。</p><blockquote class="mi mj mk"><p id="3c57" class="kr ks ln kt b ku kv jr kw kx ky ju kz ml lb lc ld mm lf lg lh mn lj lk ll lm ij bi translated"><strong class="kt ir">注意:</strong>记住，我们需要为<code class="fe me mf mg mh b">rightControls</code>和<code class="fe me mf mg mh b">leftControls</code> <em class="iq"> </em>传递一些东西，为<code class="fe me mf mg mh b">HeaderView</code> <em class="iq"> </em>的泛型参数提供类型。</p></blockquote><p id="fd3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">举个例子，下面是<code class="fe me mf mg mh b">Tilt</code> <em class="ln"> </em>工具栏变体初始化，它指定了<code class="fe me mf mg mh b">rightControls</code> <em class="ln"> </em>，并为<code class="fe me mf mg mh b">leftControls</code> <em class="ln">提供了一个<code class="fe me mf mg mh b">EmptyView</code> <em class="ln"> </em>。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="93c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然它完美地解决了这个问题，但它并不理想，因为客户端需要关注实现细节，并显式地传递一个<code class="fe me mf mg mh b">EmptyView</code> <em class="ln"> </em>来满足编译器。有一种更干净的方法。我们作为<code class="fe me mf mg mh b">HeaderView</code> <em class="ln">、</em>的作者，可以把这种常见的情况提取成一种扩展。假设<code class="fe me mf mg mh b">LeftControls</code> <em class="ln"> </em>泛型参数是一个<code class="fe me mf mg mh b">EmptyView</code> <em class="ln"> </em>，我们可以提供一个初始化器，它会将一个<code class="fe me mf mg mh b">EmptyView</code> <em class="ln"> </em>传递给标题视图初始化器，并且只接受<code class="fe me mf mg mh b">rightControls</code> <em class="ln"> </em>，因为<code class="fe me mf mg mh b">leftControls</code> <em class="ln"> </em>已经被认为是一个<code class="fe me mf mg mh b">EmptyView</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="0bd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以为空的<code class="fe me mf mg mh b">RightControls</code> <em class="ln"> </em>创建另一个扩展作为<code class="fe me mf mg mh b">EmptyView</code> <em class="ln"> </em>，并为左右控件都应该是空视图的情况创建另一个扩展。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="1c0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以用一种更简洁的方式重写<code class="fe me mf mg mh b">Tilt</code> <em class="ln"> </em>头变量，允许客户端只指定它需要的视图，而不需要考虑<code class="fe me mf mg mh b">HeaderView</code> <em class="ln">的实现细节。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="954e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们最终实现了两种方法的完美结合。客户端通过配置<code class="fe me mf mg mh b">ViewModel</code>提供标题和左按钮数据，因为相应的视图对于工具栏的任何变体都是相同的，并且它们的数据是唯一不通用的东西。此外，客户端仅在使用定制视图的地方提供定制视图，并且仅在需要时才提供。</p><p id="d367" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在<a class="ae mo" href="https://github.com/lutes1/DemoProject" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到描述这两种方法的工作示例。</p></div></div>    
</body>
</html>