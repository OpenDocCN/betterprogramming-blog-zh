<html>
<head>
<title>Implementing Unit Tests and Integration Tests in Python With Test Database and Mock Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用测试数据库和模拟服务器在Python中实现单元测试和集成测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-unit-test-and-integration-test-using-test-database-and-mock-server-in-python-5c1d6314fdd5?source=collection_archive---------0-----------------------#2022-03-29">https://betterprogramming.pub/how-to-implement-unit-test-and-integration-test-using-test-database-and-mock-server-in-python-5c1d6314fdd5?source=collection_archive---------0-----------------------#2022-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="17f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">软件测试简要指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6fa4c80c39eb94576ba9af20c917eb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76Fa4pdDzhda2hARNCLUmA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">晒衣夹(<a class="ae kv" href="https://www.flickr.com/photos/toprakucar/16394952041/" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><p id="e767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“应用程序在上周之前一直正常工作？！？!"，“希望我们不会破坏现有服务中的任何东西？”，“在分期中，我们应该涵盖边缘案例，让我们写下一些场景！”，而且“我们只添加了一些日志来跟踪服务更好的人，我不知道发生了什么？?"。</p><p id="3a06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很确定你对它们非常熟悉，而且如果你不得不与开发人员一起工作(？？)他们通常不重视测试和良好的编码原则。如果我冒犯了你，很抱歉——但是，我从事软件工作已经快7年了，毫无疑问，以这种方式进步的开发人员会留下非常糟糕的应用程序。此外，这个问题甚至会导致人们离职，因为它会把申请带到无法处理的地步。今天，我想提一下应用程序中的测试，它是开发的保证。</p><p id="3511" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的文章中，将简要介绍软件测试的定义及其细节。然后，接下来是一个示例，指导如何实现单元测试和集成测试，包括一个测试数据库，其中包含docker来测试存储库操作，以及一个假客户端来测试应用程序中的外部API。</p><h1 id="12b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是软件测试？</h1><p id="578c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如维基百科所说[1]；</p><blockquote class="mp mq mr"><p id="4bfc" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">软件测试是通过确认和验证来检查被测软件的工件和行为的行为。</p></blockquote><p id="7e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博文中，我不会提到由验证测试和用户测试组成的应用程序的业务或客户端。通过简要描述理论和分享实践，将只提到内部服务的验证。</p><p id="eae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我的理解，测试的定义是“应用程序在我的本地机器上工作，你可以克隆存储库，然后你可以在你的本地机器上运行它”这句话的保证，使用相同的环境特性。为了在实现新功能或修复/修改现有功能之前验证应用程序，测试应该自动化并在合并之前通过，测试套件应该包括单元、集成和功能测试，断言应该大量编写。</p><p id="0f8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了验证软件测试的好处之外，它还鼓励开发者以最简单的方式设计一个合适的应用程序结构。为设计糟糕的应用程序实现单元或集成测试对开发人员来说是个挑战，甚至开发人员可能会放弃为这些糟糕的应用程序添加测试。</p><h1 id="d03f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是单元测试？</h1><p id="6ffe" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Kent Beck在他的书<em class="ms">测试驱动开发</em> [2]中将单元测试定义为:</p><blockquote class="mp mq mr"><p id="0f55" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">单元测试测试独立于程序其余部分的单个单元(模块、函数、类)。</p></blockquote><p id="f00e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这些单元测试只验证单个的单元，所以只有需要的单元/类应该在测试类中初始化。为了忽略外部服务或外部技术依赖，如数据源，我们可以使用模拟来模仿它们的行为。单元测试时间应该很短，因为它们不依赖于任何外部资源或服务。</p><h1 id="64fe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是集成测试？</h1><p id="f8fc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Martin Fowler [4]提到了集成测试的定义:</p><blockquote class="mp mq mr"><p id="c9ba" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">顾名思义，集成测试的目的是测试许多单独开发的模块是否如预期的那样一起工作。它是通过激活许多模块并对所有模块运行更高级别的测试来执行的，以确保它们一起运行。这些模块可以是单个可执行程序的一部分，也可以是独立的。</p></blockquote><p id="4340" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与单元测试相比，集成测试的主要区别在于所有内部服务都是初始化的。对于外部数据源，例如数据库，可以实现与生产数据库具有相同表名和列名的测试数据库来测试外部层。集成测试的最大好处之一是应用程序的最外层，控制器，可以用给定的请求参数进行测试。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="33a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开始这个例子之前，我想给出一些关于代码的简单细节。这是一个获取和插入音乐家的rest API。API的功能如下:</p><ul class=""><li id="ce12" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">叫一个音乐家的名字</li><li id="dc2e" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">获取所有音乐家</li><li id="bac7" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">音乐家的加入</li></ul><p id="b71a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在该应用中，使用两个外部源:音乐家数据库和音乐家客户服务来获取信息。实现了一个dockerized <code class="fe nr ns nt nu b">test-database</code>来访问音乐家数据库，并为音乐家客户端服务实现了一个使用Flask的假端点来进行集成测试。还有一个<code class="fe nr ns nt nu b">ConcertService</code>设计得很糟糕，用来展示如何捕捉内部服务并模仿它。</p><p id="f6c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以从<a class="ae kv" href="https://github.com/ktoprakucar/unit-and-integration-test-implementation" rel="noopener ugc nofollow" target="_blank">库</a>中获得整个应用程序。</p><h1 id="7e4f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">密码</h1><h2 id="4cdf" class="nv lt iq bd lu nw nx dn ly ny nz dp mc lf oa ob me lj oc od mg ln oe of mi og bi translated">应用</h2><p id="9f1e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在进入测试之前，将会正确地解释服务，以理解领域以及执行和验证什么测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/0b1573b7cb6321e36e57e16715fbcf66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNJqByLbRr6GlltSyp384A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/0vB20AT_39o" rel="noopener ugc nofollow" target="_blank">信号源</a></p></figure><p id="6f6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有服务和外部数据源都在<code class="fe nr ns nt nu b">MusicianApplication</code>类中实现，以管理依赖注入。FastAPI用于生成应用程序。</p><p id="2d82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有使用任何配置服务来简化应用程序。您还可以使用该类运行应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="e982" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我上面提到的，应用程序有3个端点/行为。在这个类中，唯一的依赖是<code class="fe nr ns nt nu b">MusicianService</code>。<code class="fe nr ns nt nu b">fetch_musician_by_name() </code>和<code class="fe nr ns nt nu b">fetch_all_musicians()</code> <em class="ms"> </em>方法返回一个<em class="ms">音乐家</em>对象或音乐家列表。</p><p id="0361" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">音乐家对象包含:</p><ul class=""><li id="55cc" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><code class="fe nr ns nt nu b">name</code></li><li id="0b39" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><code class="fe nr ns nt nu b">surname</code></li><li id="7fbc" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><code class="fe nr ns nt nu b">age</code></li><li id="9cc0" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><code class="fe nr ns nt nu b">instrument</code></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="64c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nr ns nt nu b">MusicianService</code> class是调用和管理所有外部资源的类。</p><p id="599b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nr ns nt nu b">get_musician_by_name</code> <em class="ms"> </em>法中；首先，对名字进行验证，然后存储库返回音乐家(如果存在的话)。</p><p id="a457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nr ns nt nu b">external_musician_client</code>检索所有音乐家的名字，然后使用这些名字从<code class="fe nr ns nt nu b">get_all_musicians</code>方法的储存库中获取音乐家。</p><p id="70c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最后一个方法<em class="ms">保存</em>中，音乐家通过给定的<code class="fe nr ns nt nu b">name</code>、<code class="fe nr ns nt nu b">surname</code>、<code class="fe nr ns nt nu b">age</code>和<code class="fe nr ns nt nu b">instrument</code>信息使用存储库被插入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="94eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nr ns nt nu b">MusicianRepository</code>使用<code class="fe nr ns nt nu b">postgres_client</code>管理数据库客户端上的读取和插入操作。它使用映射器和访问数据库来处理数据对象和值对象之间的转换。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="f978" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nr ns nt nu b">PostgresClient</code>是唯一依赖于使用pandas dataframe的数据库的类。<code class="fe nr ns nt nu b">PostgresClientConfig</code>用于配置数据库设置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1b4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nr ns nt nu b">ExternalMusicianClient</code>用于获取储存库中使用的音乐家姓名。<code class="fe nr ns nt nu b">ExternalMusicianClientConfig</code>包含HTTP请求的<code class="fe nr ns nt nu b">url</code>和<code class="fe nr ns nt nu b">port</code>信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="ebbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解释<em class="ms">打补丁</em>(将在测试部分解释)，执行<code class="fe nr ns nt nu b">ConcertService</code>。它没有任何逻辑，直接调用<code class="fe nr ns nt nu b">OrganizationService</code>和<code class="fe nr ns nt nu b">TicketService</code>创建一个由<code class="fe nr ns nt nu b">band</code>和<code class="fe nr ns nt nu b">ticket_price</code>组成的字典。<code class="fe nr ns nt nu b">OrganizationService</code>使用<code class="fe nr ns nt nu b">choose_band</code>方法返回一个静态值，<code class="fe nr ns nt nu b">TicketService</code>根据乐队名称的长度定义票价。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="c3ed" class="nv lt iq bd lu nw nx dn ly ny nz dp mc lf oa ob me lj oc od mg ln oe of mi og bi translated">试验</h2><p id="683c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在解释完服务之后，我们可以转移到应用程序的单元测试和集成测试部分。我没有为存储库和客户端实现单元测试，因为集成测试已经实现了，这有点过度工程化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/c5ba4bdafd39f4f91c93f92c5ed58a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p1po8WoKwnWBzdZ6DOV76g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/i22gbC3gFm4" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="59ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在测试中，<code class="fe nr ns nt nu b">unittest</code> [5]包用于断言。每个测试有3个部分。<em class="ms">给定的</em>是将用于测试的信息或服务部分。<em class="ms">当</em>是要测试的阶段。<em class="ms">那么</em>就是使用断言特性的验证部分。</p><p id="c5c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于单元测试；我们将从嘲讽和补丁功能中获益。<code class="fe nr ns nt nu b">Assertion</code>用于比较预期结果和实际结果。<code class="fe nr ns nt nu b">Mock</code>被用来初始化服务以控制它们的行为。<code class="fe nr ns nt nu b">Patch</code> <em class="ms"> </em>用于捕捉内部服务的方法来改变它们的输出。</p><p id="afe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想从<code class="fe nr ns nt nu b">MapperTest</code>开始，因为它是最简单的一个，无需任何模仿或修补就能验证输出。在第一次测试中，<code class="fe nr ns nt nu b">test_should_convert_dataframe_to_musician</code>做了简要说明。</p><ul class=""><li id="d0d3" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">一代音乐家<code class="fe nr ns nt nu b">dataframe</code></li><li id="a6e4" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><code class="fe nr ns nt nu b">dataframe</code>是对音乐家的皈依</li><li id="8028" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">音乐家对象属性的验证</li></ul><p id="80b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最后一个测试<code class="fe nr ns nt nu b">test_should_convert_musician_to_dataframe</code>中，它执行相反的操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nr ns nt nu b">MusicianRepositoryTest</code>比<code class="fe nr ns nt nu b">MapperTest</code>复杂一点，因为它使用了模拟。如上所述，因为只测试了单个单元，所以客户端被<code class="fe nr ns nt nu b">Mock()</code>方法模仿。</p><p id="4a79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们模仿客户端类之后，我们可以定义被模仿类的任何方法的返回值。为<code class="fe nr ns nt nu b">retrieve_musician</code>方法定义了一个预定义的音乐家对象。<code class="fe nr ns nt nu b">MusicianRepository</code>使用模拟对象生成对象，以执行和验证行为。最后，我们能够验证输出的属性。在第二个测试中，相同的逻辑被应用于存储库的另一个方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2238" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nr ns nt nu b">MusicianValidationServiceTest</code>不同于其他测试，因为它捕捉并验证异常，而不管输出的断言。</p><p id="ebde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nr ns nt nu b">MusicianValidationService</code>中，如果名称不仅仅包含字母值，它会引发一个“名称无效”的异常消息。</p><p id="cbfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个测试<code class="fe nr ns nt nu b">test_should_raise_an_exception_when_name_is_invalid</code>，使用<code class="fe nr ns nt nu b">with self.assertRaises(Exception) as context</code>调用验证，然后捕获并验证异常。</p><p id="6a15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二个测试中，它没有引发任何异常，因为名称是有效的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="f008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在进入集成测试之前，我想提一下<code class="fe nr ns nt nu b">ConcertServiceTest</code>来解释补丁注释。</p><p id="0c33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，<code class="fe nr ns nt nu b">ConcertService</code> <em class="ms"> </em>没有任何逻辑，内部服务也没有作为构造函数的参数使用(糟糕的设计)。在第一次测试中，<code class="fe nr ns nt nu b">organize_concert()</code>方法工作正常并返回默认结果。</p><p id="c1d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nr ns nt nu b">test_should_organize_concert_with_mocked_values</code>中，补丁注释用于捕获内部服务的方法，并定义这些方法的输出值。每个模仿的方法都应该添加到方法参数中，以定义输出值(注释和模仿对象的顺序是相反的，如您所见:<code class="fe nr ns nt nu b">define_ticket_price:choose_band</code> <code class="fe nr ns nt nu b">-&gt; mock_choose_band:mock_define_ticket_price</code>)。</p><p id="ce78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在返回值中，<code class="fe nr ns nt nu b">choose_band()</code> <em class="ms"> </em>方法的输出被定义为“Abba”。</p><p id="c451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe nr ns nt nu b">define_ticket_price()</code>，默认情况下它应该返回20，但是因为我们将返回类型改为100，所以它返回100。之后，比较预期结果和实际结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8087" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于集成测试；一个文档化的数据库和一个使用Flask的假客户端被用来管理外部资源。<br/> <br/> <code class="fe nr ns nt nu b">AbstractIntegrationTestClass</code>被实现来组织这两个资源，这个类在所有集成测试中都被实现。</p><p id="8d54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个抽象类有两个主要方法，<code class="fe nr ns nt nu b">setup()</code>和<code class="fe nr ns nt nu b">tear_down()</code>来初始化<code class="fe nr ns nt nu b">test-database</code>和<code class="fe nr ns nt nu b">test-client</code>。<code class="fe nr ns nt nu b">testcontainers</code>包装是给码头工人用的。</p><p id="6043" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nr ns nt nu b">docker-compose.yml</code>中，定义了<code class="fe nr ns nt nu b">test-database</code>的属性，模式、表格和记录的初始脚本被写入<code class="fe nr ns nt nu b">init.sql</code>文件。<code class="fe nr ns nt nu b">MockServer</code>【8】用于添加伪端点。对于给定的<code class="fe nr ns nt nu b">url</code>和<code class="fe nr ns nt nu b">port</code>值，可以通过初始化Flask服务返回期望的响应。</p><p id="55d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提供了一个<code class="fe nr ns nt nu b">test-client</code>和<code class="fe nr ns nt nu b">test-database</code>来调用端点，并从数据库中获取信息用于集成测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="ed5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nr ns nt nu b">ExternalMusicianClientIntegrationTest</code>中，调用一个初始化的模拟服务器来验证响应。在配置文件中设置<code class="fe nr ns nt nu b">Url</code>和<code class="fe nr ns nt nu b">port</code>值，并创建<code class="fe nr ns nt nu b">ExternalMusicianClient</code>。</p><p id="ce65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe nr ns nt nu b">get_all_musician_names()</code>并验证响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4229" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nr ns nt nu b">PostgresClientIntegrationTest</code> <em class="ms"> </em>使用<code class="fe nr ns nt nu b">test-database</code>验证数据库客户端上的<em class="ms"> </em>读写操作。</p><p id="0c0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个测试通过名字读取音乐家，第二个测试通过<code class="fe nr ns nt nu b">test-database</code>中的名字列表读取音乐家。最后一个测试将音乐家记录插入到<code class="fe nr ns nt nu b">test-database</code>中，并验证插入。</p><p id="da9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了创建一个数据库连接，测试使用<code class="fe nr ns nt nu b">AbstractIntegrationTestClass</code> <em class="ms"> </em>的<code class="fe nr ns nt nu b">create_connection()</code>方法，然后获取最近插入的记录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="25e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nr ns nt nu b">MusicianServiceIntegrationTest</code> <em class="ms"> </em>是测试端点之前的最新集成测试。</p><p id="9aea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我在客户端和数据库存储库的集成测试中提到的，两个服务都用配置文件初始化，然后使用这些服务初始化<code class="fe nr ns nt nu b">MusicianService</code> <em class="ms"> </em>。</p><p id="6d2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为它具有与上面演示的相同的执行和验证，所以我不会重新解释它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9baf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试端点的最终集成测试<code class="fe nr ns nt nu b"><em class="ms">MusicianRestApiIntegrationTest</em></code>，调用每个端点并验证响应。</p><p id="15db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然是HTTP调用，我们需要使用<code class="fe nr ns nt nu b"><em class="ms">url</em></code>和<code class="fe nr ns nt nu b"><em class="ms">parameters</em></code>。在第一个测试中，它使用参数<code class="fe nr ns nt nu b">kurt</code>发出一个<code class="fe nr ns nt nu b">get</code>请求，并使用<code class="fe nr ns nt nu b">json()</code>提取响应，然后验证结果。</p><p id="cfaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二个测试中，由于参数无效，断言了一个异常。由于名为<code class="fe nr ns nt nu b">paul</code>的音乐家不存在，第三个测试验证了空结果。<code class="fe nr ns nt nu b">fetch-all-musicians</code>和<code class="fe nr ns nt nu b">save-musician</code>端点分别在第4次和第5次测试中测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h1 id="a953" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运行测试</h1><p id="2fb1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了运行测试，您可以同时使用终端和IDE。我将共享终端的命令。<code class="fe nr ns nt nu b">pytest</code>包可以用来运行测试。</p><p id="0cb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要运行所有测试:</p><pre class="kg kh ki kj gt ol nu om on aw oo bi"><span id="5bd8" class="nv lt iq nu b gy op oq l or os">pytest test</span></pre><p id="ca50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就个人而言，我不喜欢将单元测试和集成测试分离到不同的文件夹中。因此，我们可以使用<code class="fe nr ns nt nu b">regex</code>单独运行这些测试套件。这在CI/CD操作中也是有用的</p><p id="aa66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">若要仅运行单元测试:</p><pre class="kg kh ki kj gt ol nu om on aw oo bi"><span id="80a2" class="nv lt iq nu b gy op oq l or os">pytest test/ -k 'test and not integration'</span></pre><p id="b26c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">若要仅运行集成测试:</p><pre class="kg kh ki kj gt ol nu om on aw oo bi"><span id="2807" class="nv lt iq nu b gy op oq l or os">pytest test/ -k 'integration'</span></pre><h1 id="8bb2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">新闻报道</h1><p id="3193" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了测量应用程序测试的代码覆盖率，我们可以使用<code class="fe nr ns nt nu b">coverage</code> [9]包。</p><p id="0dd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，<code class="fe nr ns nt nu b">coverage_file</code>被初始化:</p><pre class="kg kh ki kj gt ol nu om on aw oo bi"><span id="d5fa" class="nv lt iq nu b gy op oq l or os">export COVERAGE_FILE=.coverage</span></pre><p id="bff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，将执行测试来测量代码覆盖率:</p><pre class="kg kh ki kj gt ol nu om on aw oo bi"><span id="e8e5" class="nv lt iq nu b gy op oq l or os">python -m coverage run -m pytest test</span></pre><p id="3c66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，指出所有服务的代码覆盖率和覆盖率细节:</p><pre class="kg kh ki kj gt ol nu om on aw oo bi"><span id="ed3d" class="nv lt iq nu b gy op oq l or os">python -m coverage report -m</span></pre><h1 id="29db" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后的话</h1><p id="25b7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">简而言之，我想谈谈单元测试和集成测试是如何在应用程序中开发的。通过参考我的帖子，您可以使用<code class="fe nr ns nt nu b">test-database</code>和<code class="fe nr ns nt nu b">mock-servers</code>为存储库和客户端轻松地从头开始实现测试。</p><p id="a790" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于进行单元测试的一些建议:</p><ul class=""><li id="176d" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">在部署新功能之前，至少要实现单元测试和集成测试</li><li id="35b3" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">当应用程序中的逻辑没有改变时，避免改变断言。如果您打算更改验证，请重新考虑您在应用程序中所做的事情</li><li id="a5e2" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">避免注释掉测试。这些被忽视的测试可能会在未来导致非常大的灾难性事件</li><li id="d9f8" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">尝试在最外层的服务层实现所有边缘情况/可能的用户场景</li><li id="e3bb" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">通过为简单的get和set方法编写单元测试来避免过度工程化</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="8032" class="ls lt iq bd lu lv ot lx ly lz ou mb mc jw ov jx me jz ow ka mg kc ox kd mi mj bi translated">参考</h1><ol class=""><li id="198c" class="nd ne iq ky b kz mk lc ml lf oy lj oz ln pa lr pb nj nk nl bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Software_testing" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Software_testing</a></li><li id="5e00" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr pb nj nk nl bi translated"><a class="ae kv" href="https://www.amazon.com/dp/0321146530/ref=cm_sw_r_tw_dp_6E8DCVQJP9WV5FWHZR13" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/DP/0321146530/ref = cm _ SW _ r _ tw _ DP _ 6 e 8 dcvqjp 9 wv5 fwhzr 13</a></li><li id="433a" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr pb nj nk nl bi translated"><a class="ae kv" href="https://martinfowler.com/bliki/UnitTest.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/bliki/UnitTest.html</a></li><li id="28e9" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr pb nj nk nl bi translated"><a class="ae kv" href="https://martinfowler.com/bliki/IntegrationTest.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/bliki/IntegrationTest.html</a></li><li id="80ea" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr pb nj nk nl bi translated"><a class="ae kv" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/unittest.html</a></li><li id="2884" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr pb nj nk nl bi translated"><a class="ae kv" href="https://docs.docker.com/get-started/overview/#:~:text=Docker%20is%20an%20open%20platform,ways%20you%20manage%20your%20applications" rel="noopener ugc nofollow" target="_blank">https://docs . Docker . com/get-started/overview/#:~:text = Docker % 20 is % 20 an % 20 open % 20 platform，ways % 20 you % 20 manage % 20 your % 20 applications</a>。</li><li id="413d" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr pb nj nk nl bi translated"><a class="ae kv" href="https://medium.com/swlh/testcontainers-in-python-testing-docker-dependent-python-apps-bd34935f55b5" rel="noopener">https://medium . com/swlh/test containers-in-python-testing-docker-dependent-python-apps-BD 34935 f55 b 5</a></li><li id="1990" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr pb nj nk nl bi translated"><a class="ae kv" href="https://gist.github.com/eruvanos/f6f62edb368a20aaa880e12976620db8" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/eru vanos/f6f 62 EDB 368 a 20 AAA 880 e 12976620 db 8</a></li><li id="1af5" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr pb nj nk nl bi translated">【https://coverage.readthedocs.io/en/6.3.2/ T4】</li></ol><pre class="kg kh ki kj gt ol nu om on aw oo bi"><span id="1a07" class="nv lt iq nu b gy op oq l or os"><strong class="nu ir">Want to Connect?</strong></span><span id="be00" class="nv lt iq nu b gy pc oq l or os">LinkedIn: <a class="ae kv" href="https://www.linkedin.com/in/ktoprakucar/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/ktoprakucar/</a></span><span id="3f2b" class="nv lt iq nu b gy pc oq l or os">GitHub: <a class="ae kv" href="https://github.com/ktoprakucar" rel="noopener ugc nofollow" target="_blank">https://github.com/ktoprakucar</a></span></pre></div></div>    
</body>
</html>