<html>
<head>
<title>The State of GraalVM Native Image for Mobile Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向移动开发的GraalVM原生映像的现状</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/graalvm-native-image-for-mobile-development-49eb87a00eee?source=collection_archive---------5-----------------------#2022-10-31">https://betterprogramming.pub/graalvm-native-image-for-mobile-development-49eb87a00eee?source=collection_archive---------5-----------------------#2022-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ab10" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">随着KMM和即将到来的Java变化，未来看起来越来越本地化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/31b69ba6fee10e78eddba564046b4862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K2Rbj9GBnyfrPwOj"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弗朗切斯科在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GraalVM本机映像从Java字节码产生本机代码。它主要用于需要快速启动时间的应用或功能，即微服务。它使用AOT(提前)编译。</p><p id="9391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将简要探讨GraalVM上移动开发的现状。</p><p id="a525" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@philip.han_66842/making-multiplatform-mobile-apps-with-graalvm-native-image-7e9131fb185f" rel="noopener">的后续文章</a>中，我们将创建一个可以驱动Android和iOS应用的共享核心组件。演示应用程序将包含本文中介绍的所有想法，并更详细地研究它们。</p><p id="f8ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将看到Android和iOS之间共享逻辑的好处是否大于连接两个世界的互操作层的开销。</p><h1 id="0d52" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">内部操作</h1><p id="5551" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，我将列举这一努力中最大的障碍:c。</p><p id="b08b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，没错。C.</p><p id="02aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在完成这个项目的过程中，我了解到大多数语言的互操作特性都在C层。如果你多考虑一下，就有点道理了。还可以用什么？</p><p id="dda1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GraalVM C API使用C函数入口点生成机器可执行文件或库。虽然这可以用Java或Kotlin编写，但它只在Java中运行良好，对我来说用Kotlin就不行了。你可以用Kotlin编写你的应用程序代码，但是C interop代码必须用Java编写。也许，在科特林是有可能的，只是我还没管好。</p><p id="ddc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在这种情况下，消费者Swift必须使用C代码。幸运的是，Swift有一个非常好的C互操作层。这个项目不需要Objective-C。当然，如果需要，也可以使用Objective-C。</p><p id="3371" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，事情是这样的:</p><p id="4716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JVM组件GraalVM C APISwift C APISwift</p><p id="9902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JVM组件可以用任何JVM语言编写，即Java、Kotlin、Clojure等。</p><p id="0d30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在某些情况下，您必须注意堆的分配和释放。</p><h1 id="db1c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">体系结构</h1><p id="5a02" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">该架构必须是平台无关的，以最大化平台之间的代码共享。主机平台上的viewmodel应该包含您的多平台组件和特定于平台的转换。在本文的其余部分，我们将这个组件称为核心组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/60a574e891f1c50908652b4ed7336246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9Rg9D2XhOSP-8q2mglUoQ.png"/></div></div></figure><h1 id="010e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">核心组件</h1><p id="886b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">核心组件由Android和iOS之间通用的所有应用程序代码组成。它可能因情况而异，但最有可能包含域、视图模型(以平台不可知的方式)、数据访问和网络等。</p><p id="e0bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它需要抽象来访问主机平台的基础设施服务，如蓝牙、语音识别或用户偏好。这是通过将主机平台的服务公开为C函数指针和C数据结构来实现的。</p><p id="bc93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，这个组件应该是平台无关的。它将促进良好的架构，并提供针对其他环境的额外好处，例如桌面(Windows、macOS、Linux)和可能的WebAssembly。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/a2ce2f37ad77a7251557ed5939be5d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KbQKURkAqegxjFiLfm1U5w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">该组件可以用Kotlin或Java编写，用于Android，也可以编译成Xcode的iOS对象文件。请注意，平台基础设施实现需要由主机提供，并在运行时连接。</p></figure><h1 id="a548" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">穿线</h1><p id="d947" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您熟悉Java的线程和内存模型，那么您已经非常熟悉了。你不需要学习其他范例。Java线程、ExecutorService和Kotlin协同程序工作得很好。不需要特殊的库。</p><p id="7096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，当Project Loom发布后，它将立即或很快获得好处。或者如果你使用协同程序，只要Kotlin协同程序包含了Loom。</p><p id="aa45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在C互操作层上，需要一种叫做Isolate的东西。Isolate是一个小型的Java运行时环境，用于将JVM代码作为机器码执行，并驻留在创建它的线程上。它需要由调用者初始化并传递给所有导出的函数。</p><p id="0b3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">隔离可能会导致协程之类的问题，因为当延续恢复时，它们可能不在同一个调度程序线程上。当这种情况发生时，隔离将会丢失或不是正确的。</p><h1 id="7f03" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第三方库</h1><p id="1397" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">理论上，迄今为止编写的所有Java库都是兼容的。不需要修改，但是您必须找出反射操作并提供一个配置文件来为您的最终对象或可执行文件保留所需的类。</p><p id="768b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，GraalVM AOT提供了解决这个问题的机制。</p><p id="6db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先是代理。该检测监视代码的执行，记录所有反射调用，并为您生成一个配置文件。您需要执行您的代码，并确保在这个检测运行期间到达所有相关的代码。</p><p id="c501" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次是特色。这允许您在AOT编译阶段插入操作。你可以在这里包含一些被编译器排除的类。所以，这与其说是代理，不如说是人工操作。但是有了这两种机制，大多数库都可以与您的项目兼容。</p><p id="d6ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样值得一提的是，Oracle最近创建了一个由用户驱动的库的反射配置库。希望库作者将开始把它包含在他们的发行版中，就像少数人已经做的那样。</p><p id="66e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我到目前为止测试过的库，括号中是移动环境下的问题:</p><ul class=""><li id="d03e" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">Java 11 HttpClient(安卓暂时不包含，在iOS中工作)</li><li id="4be8" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">Moshi(工作正常，包括反射绑定，需要编译文件调整)</li><li id="7d54" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">Kotlin(需要内置的配置文件)</li><li id="70d2" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">Ktor(无问题)</li><li id="7ed6" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">Kotlin序列化(工作正常，包括反射绑定)</li><li id="9d69" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">Koin(无问题)</li><li id="9a5e" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">Kotlin协程/流/通道(没有问题，缺少主调度程序)</li><li id="2c17" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">SQLDelight(适用于H2，而非SQLite)</li><li id="d4e9" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">JDBC — SQLite(缺少iOS原生库，但可以在macOS目标上工作)</li><li id="8255" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">JDBC——H2/光(无问题)</li><li id="46e2" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">OkHttp(退出延迟60秒，即隔离拆除)</li><li id="05ad" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">改造(OkHttp的问题，可能适用于其他Http客户端？)</li></ul><h1 id="37c3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">构建问题</h1><p id="8751" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">目标文件必须是可重定位的，这意味着所有的函数都有空的加载地址，然后在Xcode中完成最终的链接和汇编，以生成可执行代码。GraalVM AOT编译器为此提供了<code class="fe nf ng nh ni b">H:+ExitAfterRelocatableImageWrite</code>选项。您需要定制您的构建环境和一些其他特性标志来自动化这个过程。</p><p id="3330" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用于链接最终框架的iOS-Aarch64和iOS-x86_64的Java静态库并不容易获得。它必须从一家私人公司下载，使其可用于基于JavaFX的多平台产品。</p><h1 id="09ae" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">发展环境</h1><p id="d0ab" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">目前唯一支持的IDE是VS代码。Oracle提供了<a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm-pack" rel="noopener ugc nofollow" target="_blank"> GraalVM扩展包</a>插件来支持开发。它包括自己的Java语言服务器(Apache NetBeans语言服务器)，所以您需要禁用您可能正在使用的任何其他Java语言服务器。</p><p id="ceb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Apache NetBeans语言服务器不提供Kotlin的符号解析。当编写引用任何Kotlin组件的Java互操作代码时，它会使自动导入和代码完成中断。很烦人。由于符号解析问题，重构部分中断。</p><p id="9841" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该插件还管理GraalVM中的GraalVM安装和插件，例如本机映像、LLVM工具链、Python和其他支持的语言。</p><p id="a01e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它自带了一个原生模式的调试器，但到目前为止我根本没用过。</p><p id="4f21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，它提供了与Maven和Gradle构建环境的集成。</p><h1 id="b9ad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将来的</h1><p id="c0c3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这一点上，移动开发环境中的GraalVM原生映像相当不确定。</p><p id="1c22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">甲骨文对这一领域还不太感兴趣。它非常专注于企业和微服务。而围绕它的移动社区几乎为零，虽然有企业社区，比如Micronaut和Quarkus。</p><p id="b4ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java本身也在进化。更具体地说，带来外来函数和内存API的Project Panama将与当前的C API重叠，并可能取代当前的实现。Oracle最近表示，Project Panama将允许访问除c之外的外部内存和函数，但这不会在<a class="ae kv" href="https://youtu.be/RBUP7DeyXsc?t=407" rel="noopener ugc nofollow" target="_blank"> Java 19中作为</a>外部函数和内存API预览版提供。而Swift是否会被收录为目标语言在这一点上是完全未知的，在我看来，可能性非常小。</p><p id="35be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后是项目Valhalla和Loom，它们会给Java带来值类型和虚拟线程。</p><p id="3019" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，您今天编写的互操作代码明天就可能过时。</p><h1 id="ced0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">与Kotlin多平台的比较</h1><p id="38b6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Kotlin Multiplatform (KMM)比GraalVM mobile更有优势。</p><p id="ef50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，KMM有一家实力雄厚的公司JetBrains的支持。甲骨文对移动领域没有表现出任何热情。信不信由你，他们的官方产品仍然是Java ME。</p><p id="032b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">KMM周围有一个健康而热情的社区。由于JetBrains已经取消了对KMM内存管理器的限制，库支持可能会增加。</p><p id="e822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">KMM有直接的Objective-C接口，这意味着你不必处理C接口，尽管那个选项是可用的。Swift界面正在开发中。</p><p id="4993" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我的经验，KMM上的反射支持不如GraalVM好。</p><p id="ba8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Java/JVM在KMM的发展，同样的问题依然存在。它将如何采用虚拟线程、值类型和FFI？</p><h1 id="956a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="eaf0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">核心组件拥有单一代码库的好处是不可否认的。同时两边C接口的负担也是实实在在的。</p><p id="caaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://dropbox.tech/mobile/the-not-so-hidden-cost-of-sharing-code-between-ios-and-android" rel="noopener ugc nofollow" target="_blank">过去为Android/iOS开发基于C/C++的内核的尝试都失败了，因为随着时间的推移，开销变得越来越复杂和昂贵。</a></p><p id="ca81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">平心而论，GraalVM原生映像离共享C++代码还很远。然而，这篇文章中的一些结论在这里也适用，依我看。</p><h1 id="471a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">事后思考</h1><p id="7b8a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我在研究和实现演示应用程序的过程中获得了很多乐趣。我想做这个项目纯粹是出于好奇。我知道在这个过程中我会学到很多东西。</p><p id="cc47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着KMM和即将到来的Java变化，未来看起来越来越本地化。至少在某种程度上，长期流程仍将由JIT主导，但native肯定会有一席之地。</p><p id="2651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我鼓励任何着眼于未来的Java/Kotlin开发人员更仔细地研究本机代码，即C、C++和LLVM。</p><p id="5b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LLVM是实现KMM的核心，GraalVM AOT也有一个LLVM后端作为选项。</p></div></div>    
</body>
</html>