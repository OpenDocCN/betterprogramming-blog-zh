<html>
<head>
<title>5 Recipes for Setting Default Props in React and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React和TypeScript中设置默认属性的5种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-recipes-for-setting-default-props-in-react-typescript-b52d8b6a842c?source=collection_archive---------2-----------------------#2022-09-27">https://betterprogramming.pub/5-recipes-for-setting-default-props-in-react-typescript-b52d8b6a842c?source=collection_archive---------2-----------------------#2022-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="526e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们学习如何正确烹饪我们的道具！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aa44fa4bff0fdd89b54729f27cb526e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WRCjCkSP8kxpkzWxTWHGAQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b57b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数参数和对象属性中的默认值非常强大。它们允许消费者保持代码简单，同时为定制敞开大门。</p><p id="03e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将分享我设置默认属性的五个最佳方法——每个都有自己的用例。</p><h1 id="db41" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">简单的道具🍳</h1><p id="a231" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我将从最简单的开始，您可能已经在使用了。这个模式将覆盖80%的用例。</p><p id="8d34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设您想要实现一个在列表中查找对象的函数，允许调用者指定一个可选的索引开始搜索。因为索引是可选的，所以您可以直接在函数的头部为它指定一个默认值。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a0fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，您不必为<code class="fe mq mr ms mt b">fromIndex</code>指定类型，因为由于默认值(<code class="fe mq mr ms mt b">0</code>)，TypeScript隐式假定它是一个<code class="fe mq mr ms mt b">number</code>。</p><p id="e22b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样的技术也适用于功能组件(它们毕竟是功能)。因此，为了完整起见，我们也来看一个简单的例子。</p><p id="b215" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有问题的组件有一个可选的<code class="fe mq mr ms mt b">variant</code>属性，用于确定对它应用什么样式。您也可以直接在函数头中设置默认值。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4c1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意<code class="fe mq mr ms mt b">Props</code>是一个对象，我们将它析构为三个变量:</p><ol class=""><li id="3a3a" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated"><code class="fe mq mr ms mt b">value</code>，不可选</li><li id="549c" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated"><code class="fe mq mr ms mt b">variant</code>，可选，初始化为默认值(<code class="fe mq mr ms mt b">"filled"</code>)</li><li id="5143" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated"><code class="fe mq mr ms mt b">others</code>，对象中的其余属性</li></ol><h2 id="6dde" class="ni ls iq bd lt nj nk dn lx nl nm dp mb le nn no md li np nq mf lm nr ns mh nt bi translated"><strong class="ak">奖金</strong></h2><p id="0025" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果你的可选属性是一个<code class="fe mq mr ms mt b">boolean</code>并且它的默认值是<code class="fe mq mr ms mt b">false</code>，那么调用代码可以被简化。</p><p id="068b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果您有一个<code class="fe mq mr ms mt b">Button</code>组件，其<code class="fe mq mr ms mt b">disabled</code>属性默认设置为<code class="fe mq mr ms mt b">false</code>，例如:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="32e5" class="ni ls iq mt b gy ny nz l oa ob">export function Button({ disabled = false } : Props) { /* ... */ }</span></pre><p id="03a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，您可以向<code class="fe mq mr ms mt b">Button</code>添加一个无值的<code class="fe mq mr ms mt b">disabled</code>属性:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="58e2" class="ni ls iq mt b gy ny nz l oa ob">&lt;Button disabled /&gt;</span></pre><p id="7b8c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果该属性存在，该属性将自动设置为<code class="fe mq mr ms mt b">true</code>，如果省略，则为<code class="fe mq mr ms mt b">false</code>(感谢默认值)。</p><h1 id="7a4b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">分层道具🍰</h1><p id="7941" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">从这一点开始，我将不再区分函数和组件，因为正如我们已经看到的，它们是相同的(它们都是函数)。</p><p id="3dad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们假设你想接受一个更复杂的参数:一个对象。该对象本身是可选的，其属性也是可选的。因此，您希望确保来电者能够通过以下任一方式给您打电话:</p><ul class=""><li id="b7f7" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq oc na nb nc bi translated">包含所有属性的对象</li><li id="99b5" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq oc na nb nc bi translated">包含一些属性的对象—对其余属性使用默认值</li><li id="1b06" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq oc na nb nc bi translated">无对象—始终使用默认值</li></ul><p id="28db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您想要提供选项或接受param中的配置时，通常会这样做。然后，开发人员可以使用您的代码的普通版本，或者调整它以获得更大的粒度。</p><p id="16a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们实现一个定制的钩子(它仍然是一个函数)。这个挂钩提供了一个计数器，您可以使用选项对其进行定制，例如增加的步数或最小/最大边界。</p><p id="af14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终的代码可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a00b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们创建了一个<code class="fe mq mr ms mt b">CounterOptions</code>类型的第3行，其中所有字段都被标记为可选，其中<code class="fe mq mr ms mt b">bounds</code>是一个对象(因为我们喜欢挑战)。</p><p id="388c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，第11行我们声明了<code class="fe mq mr ms mt b">useCounter</code>函数。它有两个参数:一个可选的<code class="fe mq mr ms mt b">initial</code>值(默认设置为<code class="fe mq mr ms mt b">0</code>—第14行)和一个带有<code class="fe mq mr ms mt b">CounterOptions</code>的可选对象(设置为空对象<code class="fe mq mr ms mt b">{}</code> —第19行)。</p><p id="23c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">神奇的事情发生在第13-19行。在那里，我们析构了选项，并给它们赋了一个默认值。由于<code class="fe mq mr ms mt b">bounds</code>是一个可选对象，我们也确保在默认情况下给它分配一个空对象<code class="fe mq mr ms mt b">{}</code>，这样人们就可以不用设置<code class="fe mq mr ms mt b">bounds</code>就可以使用我们的选项。<code class="fe mq mr ms mt b">bounds</code>中的每个属性也被赋予一个默认值(第16–17行)。</p><blockquote class="od"><p id="6872" class="oe of iq bd og oh oi oj ok ol om lq dk translated">无论嵌套级别如何，都可以为嵌套对象中的属性设置默认值。</p></blockquote><p id="fceb" class="pw-post-body-paragraph kv kw iq kx b ky on jr la lb oo ju ld le op lg lh li oq lk ll lm or lo lp lq ij bi translated">钩子本身的实现很简单:代码不需要检查参数是否被初始化(它们总是被初始化)，它可以直接访问嵌套的props(我们已经将它们析构到单独的变量中——不需要键入<code class="fe mq mr ms mt b">props.bounds.max</code>来访问<code class="fe mq mr ms mt b">max</code>)。</p><p id="b780" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在您可以在代码中最灵活地使用<code class="fe mq mr ms mt b">useCounter</code>钩子了！这些都是有效的用例:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="fdf0" class="ni ls iq mt b gy ny nz l oa ob">const counter = useCounter();<br/>const counter = useCounter(1);<br/>const counter = useCounter(0, { steps: 2 });<br/>const counter = useCounter(10, { bounds: { min: 0 } });<br/>const counter = useCounter(0, { bounds: { max: 10 } });<br/>const counter = useCounter(<br/>  0,<br/>  { steps: 2, bounds: { min: 0, max: 10 } }<br/>);</span></pre><p id="5768" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在<a class="ae os" href="https://codesandbox.io/s/usecounter-oqhhb9" rel="noopener ugc nofollow" target="_blank">这个沙盒</a>中看到它的运行。</p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="16ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您想导出默认值，也可以为它们创建常量。例如，看看这段代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="bf71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">老实说，我不喜欢这种设置默认值的方式。我们失去了一些声明性语法，并且引入了冗余。所以，如果你要用它，确保你有一个好的理由。</p><p id="d0b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，你可能还想知道为什么我们不用:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="89fb" class="ni ls iq mt b gy ny nz l oa ob">export function useCounter(initial = 1, options = defaultOptions)</span></pre><p id="8069" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，如果我们这样做，我们让开发人员负责使用他们自己的选项来确保他们提供对象中的每一个属性…这是一个要么接受要么放弃的情况。我们不能再依赖于初始化所有的选项，我们也失去了对象析构的好处。</p><h1 id="fdbb" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">充值道具🍕</h1><p id="a367" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">有时，您的组件充当另一个组件的包装。在这种情况下，您可能希望返回一个带有默认属性的组件，并让消费者添加他们自己的属性。</p><p id="fc34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了演示这一点，让我们为YouTube视频创建一个包装器。如果你去YouTube点击“嵌入”按钮，你会得到一个代码片段，里面有一个iframe和视频的URL。</p><p id="ac62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们将把视频的ID提取到一个属性中，并自己编写其余的标记。由于嵌入的视频是一个iframe，我们将让消费者覆盖它的属性。下面是实际运行中的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="3008" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq oc na nb nc bi translated">第4行，我们扩展了“iframe”组件，以便继承它的属性。然后我们添加了一个<code class="fe mq mr ms mt b">vid</code>属性来指定视频的标识符，以及另一个接收<code class="fe mq mr ms mt b">start</code>时间的可选属性。</li><li id="f47d" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq oc na nb nc bi translated">第12行，我们提取了我们的<code class="fe mq mr ms mt b">vid</code>和<code class="fe mq mr ms mt b">start</code>属性，以及剩余的属性(<code class="fe mq mr ms mt b">others</code>)。我们还为<code class="fe mq mr ms mt b">start</code>设置了一个默认值<code class="fe mq mr ms mt b">0</code>，这样我们就可以再一次练习设置简单的道具。我们还添加了一个<code class="fe mq mr ms mt b">ref</code>参数，但我们稍后会回到它。</li><li id="9921" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq oc na nb nc bi translated">第14行，我们返回了一个iframe，带有计算的<code class="fe mq mr ms mt b">src</code>，以及YouTube给我们的一些默认属性(<code class="fe mq mr ms mt b">width</code>、<code class="fe mq mr ms mt b">height</code>、<code class="fe mq mr ms mt b">title</code>等)。).</li><li id="2bbf" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq oc na nb nc bi translated">但是有趣的部分在第23行:<code class="fe mq mr ms mt b">{…others}</code>。得益于此，调用者可以向我们的组件提供任何支持的iframe属性，并让它们覆盖我们的默认值(包括<code class="fe mq mr ms mt b">width</code>、<code class="fe mq mr ms mt b">height</code>、<code class="fe mq mr ms mt b">title</code>等)。).因为<code class="fe mq mr ms mt b">{…others}</code>在iframe的所有其他道具之后，它将总是覆盖我们的值。如果我们想防止我们的值被覆盖，我们可以将它们移动到<code class="fe mq mr ms mt b">{…others}</code>之后(例如:<code class="fe mq mr ms mt b">&lt;iframe {…others} src={`https…`} /&gt;</code>)。</li></ul><p id="e36a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该模式支持以下所有用例:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="9d9d" class="ni ls iq mt b gy ny nz l oa ob">&lt;YouTubeVideo vid="eX2qFMC8cFo" /&gt;<br/>&lt;YouTubeVideo vid="eX2qFMC8cFo" start={10} /&gt;<br/>&lt;YouTubeVideo vid="eX2qFMC8cFo" width="800" height="600" /&gt;<br/>&lt;YouTubeVideo vid="eX2qFMC8cFo" allowFullScreen={false} /&gt;<br/>&lt;YouTubeVideo vid="eX2qFMC8cFo" style={{border: '1px solid red'}} /&gt;</span></pre><p id="6468" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在<a class="ae os" href="https://codesandbox.io/s/youtubevideo-bt298u?file=/src/YouTubeVideo.tsx" rel="noopener ugc nofollow" target="_blank">这个沙盒</a>里玩。</p><p id="6eec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这个方法，您可以扩展任何HTML元素(iframe、button、div等)。)，甚至更高级的组件，如<a class="ae os" href="https://mui.com/material-ui/react-button/" rel="noopener ugc nofollow" target="_blank"> MUI按钮</a>或<a class="ae os" href="https://mui.com/material-ui/react-text-field/" rel="noopener ugc nofollow" target="_blank">文本字段</a>。</p><h2 id="f269" class="ni ls iq bd lt nj nk dn lx nl nm dp mb le nn no md li np nq mf lm nr ns mh nt bi translated">裁判怎么了？</h2><p id="bc14" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果您查看代码，您可能想知道<code class="fe mq mr ms mt b">ref</code>参数是什么(第12行)？没错。最容易理解的方法就是把它和<code class="fe mq mr ms mt b">React.forwardRef</code>(第9行)一起去掉。</p><p id="8513" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后尝试<a class="ae os" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">在你的应用程序中获取对iframe元素</a>的引用，就像你对“普通”iframe所做的那样:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="2f3d" class="ni ls iq mt b gy ny nz l oa ob">const ref = useRef&lt;HTMLIframeElement&gt;();<br/>// ...<br/>&lt;YouTubeVideo vid="eX2qFMC8cFo" ref={ref} /&gt;</span></pre><p id="5c96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您将在控制台中得到一个警告:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="7b7d" class="ni ls iq mt b gy ny nz l oa ob">Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</span><span id="1daa" class="ni ls iq mt b gy pa nz l oa ob">Check the render method of `App`.<br/> at YouTubeVideo (<a class="ae os" href="https://bt298u.csb.app/src/YouTubeVideo.tsx:25:18" rel="noopener ugc nofollow" target="_blank">https://bt298u.csb.app/src/YouTubeVideo.tsx:25:18</a>)<br/> at div<br/> at App</span></pre><p id="d80c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们添加到组件中的代码修复了这个问题。因此，如果您希望您的消费者使用ref，不要忘记将其转发给包装的元素，因为它不是自动的。你可以在React文档中了解更多信息。</p><h1 id="27ce" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">带孔道具🧀</h1><p id="cf9e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">与前面的例子类似，有时您只想创建一个带有默认属性的组件，并让调用者根据需要覆盖它们。</p><p id="f78e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我喜欢在单元测试中使用的模式。它使用TypeScript的<a class="ae os" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype" rel="noopener ugc nofollow" target="_blank">分部类型</a>使所有属性成为可选的(甚至那些没有被标记为可选的)。</p><p id="2e87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，让我们为之前实现的<code class="fe mq mr ms mt b">YouTubeVideo</code>组件编写一些测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cc51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第4–6行，我们定义了一个<code class="fe mq mr ms mt b">renderVideo</code>函数，它是流行的<a class="ae os" href="https://testing-library.com/docs/react-testing-library/intro/" rel="noopener ugc nofollow" target="_blank"> React测试库</a>的包装器。在其中，我们简单地用默认道具(<code class="fe mq mr ms mt b">vid=eX2qFMC8cFo</code>)呈现了一个<code class="fe mq mr ms mt b">YouTubeVideo</code>组件，并让调用者用部分<code class="fe mq mr ms mt b">YouTubeVideoProps</code>覆盖它们。</p><p id="1ff5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们能够在每个测试用例中调用<code class="fe mq mr ms mt b">renderVideo</code>。我们可以在没有属性的情况下调用它，以验证组件使用默认值工作(第8-10行)，或者我们可以单独覆盖每个属性，并测试它的行为是否正常(<code class="fe mq mr ms mt b">vid</code>第12-18行和<code class="fe mq mr ms mt b">start</code>第20-26行)。</p><p id="f28e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，你可以在单元测试之外使用这个方法。只要记住，如果你想提供一种方法来给一个物体提供‘洞’，那么<code class="fe mq mr ms mt b"><a class="ae os" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype" rel="noopener ugc nofollow" target="_blank">Partial</a></code>就是你的朋友。</p><h1 id="addc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">加工过的道具🥫</h1><p id="860a" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">你知道道具的默认值可以在调用时动态计算吗？是的，你可以用一个函数来计算它。还可以实例化一个新对象或使用模板字符串。您甚至可以访问早期的参数来计算它！</p><p id="cd4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们调用<code class="fe mq mr ms mt b">Date.now()</code>函数来初始化时间戳，如果调用者没有提供的话:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="220b" class="ni ls iq mt b gy ny nz l oa ob">function addEntry(text: string, timestamp = Date.now())</span></pre><p id="a16a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整洁！</p><p id="418d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于我们在设置默认值时可以访问早期的参数，因此我们也可以这样做:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="a77b" class="ni ls iq mt b gy ny nz l oa ob">function addEvent(<br/>  title: string,<br/>  start = new Date(),<br/>  end = addMinutes(start, 30)<br/>)</span></pre><p id="f662" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们将可选的开始日期初始化为当前日期(<code class="fe mq mr ms mt b">start = new Date()</code>)，然后我们用一个函数将可选的结束日期初始化为开始日期加30分钟(<code class="fe mq mr ms mt b">end = addMinutes(start, 30)</code>)。</p><p id="4bd5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是另一个使用模板字符串初始化用户全名的示例:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="2b2b" class="ni ls iq mt b gy ny nz l oa ob">function createUser(<br/>  name: string, <br/>  surname: string, <br/>  fullname = <!-- -->`${name} ${surname}`<br/>)</span></pre><p id="a073" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还想提一下，你也可以在一个析构的对象中访问早期的属性。这意味着下面的方法也有效(注意花括号——这次我们在param中取一个对象):</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="2dda" class="ni ls iq mt b gy ny nz l oa ob">function createUser({<br/>  name: string, <br/>  surname: string, <br/>  fullname = <!-- -->`${name} ${surname}`<br/>})</span></pre><p id="ca82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天就到这里吧！</p><p id="7ec5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你喜欢我的食谱，跟着我做更多这样的。🧑‍🍳</p><h1 id="61b2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">参考</h1><div class="pb pc gp gr pd pe"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd ir gy z fp pj fr fs pk fu fw ip bi translated">默认参数— JavaScript | MDN</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">在JavaScript中，函数参数默认为。但是，设置不同的默认值通常很有用。这是…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">developer.mozilla.org</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps kp pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd ir gy z fp pj fr fs pk fu fw ip bi translated">析构赋值JavaScript | MDN</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">基本赋值给新变量名一个属性可以从一个对象中解包并赋给一个变量…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">developer.mozilla.org</p></div></div><div class="pn l"><div class="pt l pp pq pr pn ps kp pe"/></div></div></a></div></div></div>    
</body>
</html>