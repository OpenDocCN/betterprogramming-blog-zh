<html>
<head>
<title>Host a Secure Private Gem Server With LDAP Authentication and Authorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">托管一个具有LDAP身份验证和授权的安全私有Gem服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hosting-a-private-gem-server-2288249caf77?source=collection_archive---------7-----------------------#2019-11-29">https://betterprogramming.pub/hosting-a-private-gem-server-2288249caf77?source=collection_archive---------7-----------------------#2019-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="804f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们开始使用自己的gem服务器进行内部开发和私有gem</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58ca5bb8c40ad435311a2f72ef5cd210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pJ5uqVhg9lV08n9e"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4b54" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">背景</h1><p id="c6ca" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Ruby软件开发包括在包或库中构建和发布软件。在Ruby世界中，这些包被称为gems，它们通常发布在<a class="ae ky" href="https://rubygems.org/" rel="noopener ugc nofollow" target="_blank"> RubyGems </a>上。来自世界各地的开发人员可以搜索这些宝石，安装它们，并将其集成到自己的项目中。RubyGems还提供了一个很好的命令行来管理gem，允许用户推拉gem。</p><p id="d02d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">到目前为止，这很好，但如果有必要开发一些不应该为世界上每个人提供的私人宝石呢？不幸的是，RubyGems不支持这一点，并且需要托管一个私有的gem服务器，以便能够在开发团队内部共享私有的gem。</p><p id="c4c4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这篇文章中，我将展示我托管自己的Ruby gem服务器的尝试。我将涉及以下几点:</p><ul class=""><li id="257e" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">RubyGems的替代品有哪些？</li><li id="aa26" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">我的托管Ruby gem服务器的解决方案的描述。</li><li id="85fe" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">解决方案的进一步改进。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0da7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">寻找现有的解决方案</h1><p id="653d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在我开始<strong class="ma iu"> </strong>开发任何代码或解决方案之前，我通常会花一些时间来搜索我可以重用来完成任务的替代方案或现有解决方案。我们并不总是需要从头开始重新发明一切。经过一些快速的研究，我发现<a class="ae ky" href="https://guides.rubygems.org/run-your-own-gem-server/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>描述了托管你自己的<code class="fe nn no np nq b">gem</code>服务器的几个选项。下面介绍了这些选项，并对每个选项进行了简短描述。</p><ul class=""><li id="554e" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">内置gem服务器:该服务器自带<code class="fe nn no np nq b">Rubygems</code>，只能用于查看已安装的gem。它不支持推或拉宝石。</li><li id="8d28" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/PierreRambaud/gemirro" rel="noopener ugc nofollow" target="_blank"> Gemirro </a>:这个gem服务器侧重于镜像，也不支持推或者拉宝石。如果您想将您的管道和应用程序配置到一个私有的gem服务器，该服务器负责从RubyGems下载和兑现gem，那么这是一个不错的选择。因此，如果RubyGems宕机，您仍然可以从内部服务器安装Gems。</li><li id="63fe" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">这是另一个现有的开源Gem服务器。幸运的是，该服务器既支持从命令行推送gem，也支持从web UI上传和删除gem。</li></ul><p id="ae51" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这一点上，我很清楚，实现我的任务的最佳选择将是Gem in a Box，因为它比其他选项支持更多的功能。因此，我开始深入研究这个项目，以了解如何开始托管我自己的带有gem的Ruby gem服务器，以及这些项目支持哪些特性。因此，我提出了以下内置特性列表和一些问题的解决方法:</p><ul class=""><li id="3e54" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">该项目提供了一个web UI，允许查看、搜索、上传和删除gem。</li><li id="6a8f" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">该项目提供了一个名为<code class="fe nn no np nq b">inabox</code>的命令行工具。</li><li id="1ea5" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">命令<code class="fe nn no np nq b">gem</code>可以用来从服务器上推送宝石。</li><li id="fad5" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">该项目的<a class="ae ky" href="https://github.com/geminabox/geminabox/wiki" rel="noopener ugc nofollow" target="_blank"> wiki </a>描述了一个扩展项目以支持<code class="fe nn no np nq b">HTTP BASIC AUTH</code>、<code class="fe nn no np nq b">Alternative UI styling</code>、<code class="fe nn no np nq b">ssl configs</code>和其他特性的变通方法。</li></ul><p id="5e76" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不幸的是，这些特征对我的情况来说是不够的，我缺少以下特征:</p><ul class=""><li id="2f69" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">LDAP基于角色的认证和授权。</li><li id="3042" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">API密钥生成。</li><li id="1f0b" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">支持<code class="fe nn no np nq b">gem signin</code>命令。</li><li id="49aa" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">支持<code class="fe nn no np nq b"><a class="ae ky" href="http://localhost/sginup" rel="noopener ugc nofollow" target="_blank">http://localhost/sginup</a></code>请求。</li></ul><p id="e04c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">因此，我决定在项目wiki上发布的一些解决方案的帮助下，用缺失的特性来扩展Gem in a Box项目。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5cd0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">解决方案</h1><h2 id="04ca" class="nr lh it bd li ns nt dn lm nu nv dp lq mh nw nx ls ml ny nz lu mp oa ob lw oc bi translated">建筑决策</h2><p id="4f4a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">实现上述特性意味着需要持久存储一些数据。我们至少需要为每个gem的用户和所有者存储API密钥。因此，我开始在这里探索我的选择，因为我想尽可能简单，并且不集成任何数据库，如<a class="ae ky" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>、<a class="ae ky" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>等。我最终决定将数据保存在文本文件中。</p><p id="de2c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">编写软件来管理文本文件中的数据超出了我的范围。因此，我花了一些时间来寻找这个功能的现有解决方案。幸运的是，我发现Ruby提供了两个类来完成这项任务，它们有一个漂亮而简单的接口。这些类别是:</p><ul class=""><li id="a24a" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated"><code class="fe nn no np nq b"><a class="ae ky" href="https://ruby-doc.org/stdlib-2.5.3/libdoc/pstore/rdoc/PStore.html" rel="noopener ugc nofollow" target="_blank">PStore</a></code>:基于哈希实现基于文件的持久化机制。</li><li id="39d6" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nn no np nq b"><a class="ae ky" href="https://ruby-doc.org/stdlib-2.4.0/libdoc/yaml/rdoc/YAML/Store.html" rel="noopener ugc nofollow" target="_blank">YAML::Store</a></code>:提供与<code class="fe nn no np nq b">PStore</code>相同的功能，除了它使用<a class="ae ky" href="https://ruby-doc.org/stdlib-2.4.0/libdoc/yaml/rdoc/YAML.html" rel="noopener ugc nofollow" target="_blank"> YAML </a>来转储对象而不是编组。</li></ul><p id="a648" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">因为这两个类使用相同的接口，所以我决定在我的解决方案中支持它们，并允许通过环境变量在它们之间进行选择。</p><h2 id="ccfa" class="nr lh it bd li ns nt dn lm nu nv dp lq mh nw nx ls ml ny nz lu mp oa ob lw oc bi translated">数据模型</h2><p id="089e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">仅仅出于简单的原因，我决定制作实现预期特性所需的最简单的数据模型。我想出了以下三个模型:</p><ul class=""><li id="231e" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">用户:该模型持久化以下用户数据(<code class="fe nn no np nq b">username</code>、<code class="fe nn no np nq b">api_key</code>、<code class="fe nn no np nq b">ldap_groups</code>)。</li><li id="0a3e" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">ApikeyIndex:该模型将API键与用户相关联。您可能会说API键已经与用户模型中的用户相关联了。是的，这是真的，但是因为我们在这里使用的是散列对象，所以使用反向索引比遍历用户对象来查找用户API键更容易。</li><li id="1368" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">GemIndex:该模型将推送的宝石与其所有者(推送宝石的第一个用户)相关联。</li></ul><h2 id="ac2b" class="nr lh it bd li ns nt dn lm nu nv dp lq mh nw nx ls ml ny nz lu mp oa ob lw oc bi translated">基于角色的授权</h2><p id="152a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我对基于角色的身份验证和授权的要求非常简单，可以通过以下几点来满足:</p><ul class=""><li id="d522" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">下载和观看宝石是开放给任何人，无需任何认证。</li><li id="9470" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">推送、上传、拉取和删除gems受到LDAP认证的保护。</li><li id="9f6a" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">授权操作支持两个LDAP组(maintainer和admin)。</li><li id="0345" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">维护者只能推/拉他们自己的宝石。</li><li id="50ee" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">管理员可以推/拉任何宝石。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8036" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">功能实现</h1><p id="a660" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">既然Gem in a Box使用了<a class="ae ky" href="https://github.com/sinatra/sinatra" rel="noopener ugc nofollow" target="_blank"> Sinatra </a>，那么它也使用了<a class="ae ky" href="https://github.com/rack/rack" rel="noopener ugc nofollow" target="_blank"> Rack </a>和Rack中间件。因此，我决定通过实现处理每个所需请求的中间件类来扩展解决方案。下面是对实现的中间件类及其用法的描述。</p><h2 id="121a" class="nr lh it bd li ns nt dn lm nu nv dp lq mh nw nx ls ml ny nz lu mp oa ob lw oc bi translated">GeminaboxApp::中间件::健康检查</h2><p id="0fab" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这个中间件提供了一个静态健康检查端点，该端点在应用程序的根路由上可用:<a class="ae ky" href="http://localhost:8080/health" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/health</a><em class="od">。</em>这个端点返回一个静态字符串<code class="fe nn no np nq b">OK</code>。它可用于检查应用程序是否启动并响应<code class="fe nn no np nq b">http</code>请求。</p><h2 id="bb0a" class="nr lh it bd li ns nt dn lm nu nv dp lq mh nw nx ls ml ny nz lu mp oa ob lw oc bi translated"><strong class="ak"> GeminaboxApp::中间件::注册</strong></h2><p id="9bf8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">不幸的是，端点<code class="fe nn no np nq b">signup</code>并没有在盒子里的宝石中实现。因此，我编写了这个中间件来处理请求和收集用户数据。该中间件执行以下操作:</p><ul class=""><li id="e086" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">要求用户输入他们的LDAP凭据。这是由<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/Ultragreen/rack-auth-ldap" rel="noopener ugc nofollow" target="_blank">Rack::Auth::Ldap</a></code>中间件支持的。</li><li id="a98f" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">如果用户凭证有效，中间件将为用户创建一个<code class="fe nn no np nq b">api_key</code>(如果他们还没有的话)，将用户信息(LDAP组、用户名、API密钥)保存在用户存储中，并将<code class="fe nn no np nq b">api_key</code>关联保存在API密钥存储中。最后，它将为用户显示API密钥。</li><li id="877b" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">如果用户凭证无效，它将继续要求输入有效凭证。</li></ul><p id="7045" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">多次注册不会为同一个用户生成多个API密钥。只有当用户在商店中没有API密钥时，中间件才会生成用户API密钥。另一方面，LDAP组将在用户每次注册时更新。</p><h2 id="b2e7" class="nr lh it bd li ns nt dn lm nu nv dp lq mh nw nx ls ml ny nz lu mp oa ob lw oc bi translated">GeminaboxApp::中间件::ApiKey</h2><p id="ddab" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这个中间件做的事情几乎和<code class="fe nn no np nq b">SignUp</code> <strong class="ma iu"> </strong>中间件一样，除了它处理API请求<code class="fe nn no np nq b">/api/v1/api_key</code>而不是注册请求。每当用户试图使用<code class="fe nn no np nq b">gem</code>命令行登录时，或者当用户试图在没有首先登录的情况下推送gem时，都会请求这个端点。</p><pre class="kj kk kl km gt oe nq of og aw oh bi"><span id="ce02" class="nr lh it nq b gy oi oj l ok ol">gem signin --host <a class="ae ky" href="http://localhost:9292" rel="noopener ugc nofollow" target="_blank">http://localhost:9292</a><br/>gem push myge-0.11.2.gem --host <a class="ae ky" href="http://localhost:9292" rel="noopener ugc nofollow" target="_blank">http://localhost:9292</a></span></pre><p id="522f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">作为LDAP认证成功的结果，中间件将把用户和<code class="fe nn no np nq b">api_key</code>数据持久化到相关的store对象中，并以文本格式返回<code class="fe nn no np nq b">api_key</code>，以便将其添加到本地凭证文件中。</p><pre class="kj kk kl km gt oe nq of og aw oh bi"><span id="98d8" class="nr lh it nq b gy oi oj l ok ol">➜  : cat ~/.gem/credentials                                                                                                                                                               <br/>---<br/><a class="ae ky" href="http://localhost:9292" rel="noopener ugc nofollow" target="_blank">http://localhost:9292</a>: 7459f3d7-3ba6-4d44-b0f1-4e103690286c<br/><a class="ae ky" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a>: 1bf46c2f-3cf0-4f2d-9715-e9e6d0c5d604</span></pre><h2 id="19e6" class="nr lh it bd li ns nt dn lm nu nv dp lq mh nw nx ls ml ny nz lu mp oa ob lw oc bi translated">GeminaboxApp::中间件::ApiGem</h2><p id="a1f4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Gem in a Box提供了两个API端点，用于从服务器推送和拉出Gem。这些终点是:</p><ul class=""><li id="dff5" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated"><code class="fe nn no np nq b">POST /api/v1/gems</code>:用于将gems推送到服务器。每当使用以下命令行时，都会请求此端点。</li></ul><pre class="kj kk kl km gt oe nq of og aw oh bi"><span id="4b4e" class="nr lh it nq b gy oi oj l ok ol">$&gt; gem push mygem-<!-- -->0.11.2<!-- -->.gem — host <a class="ae ky" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></span></pre><ul class=""><li id="2c92" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated"><code class="fe nn no np nq b">DELETE /api/v1/gems/yank</code>:用于从服务器上拉(删除)宝石。每当使用以下命令行时，都会请求此端点。</li></ul><pre class="kj kk kl km gt oe nq of og aw oh bi"><span id="83e8" class="nr lh it nq b gy oi oj l ok ol">gem yank <!-- -->mygem<!-- --> -v 0.11.2 --host <a class="ae ky" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></span></pre><p id="1552" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">ApiGem</code> <strong class="ma iu"> </strong>中间件拦截上述请求的API调用，并执行以下操作:</p><ul class=""><li id="f4d5" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">验证API密钥是否存在。</li><li id="b12f" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">验证是否允许API键推动或拉动宝石。</li><li id="9eb3" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">更新<code class="fe nn no np nq b">GemIndex</code> <strong class="ma iu"> </strong>关联用户和gem。如果执行的请求是<code class="fe nn no np nq b">POST /api/v1/gems </code>请求，并且gem是新的gem，那么中间件将在<code class="fe nn no np nq b">GemIndex</code> <strong class="ma iu"> </strong>存储中添加一个条目。另一方面，如果请求是一个<code class="fe nn no np nq b">DELETE /api/v1/gems/yank</code>请求，并且这是服务器上gem的最后版本，那么中间件将从<code class="fe nn no np nq b">GemIndex</code> <strong class="ma iu"> </strong>存储中删除索引条目。</li></ul><h2 id="e9b3" class="nr lh it bd li ns nt dn lm nu nv dp lq mh nw nx ls ml ny nz lu mp oa ob lw oc bi translated"><strong class="ak"> GeminaboxApp::中间件::WebRequestsLdapAuth </strong></h2><p id="b22b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe nn no np nq b">WebRequestsLdapAuth</code> <strong class="ma iu"> </strong>中间件在一个盒子里截取Gem提供的三个web端点。这些端点如下所列:</p><ul class=""><li id="dd79" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated"><code class="fe nn no np nq b">GET /upload</code>:该请求用于从UI查看上传的gem。中间件只通过LDAP身份验证保护这个端点，不执行任何其他操作。</li><li id="93ac" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nn no np nq b">POST /upload</code>:当用户点击上传web表单上的上传按钮时，会请求这个端点。</li><li id="c5f2" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nn no np nq b">POST /gems/.*gem</code>:当用户点击主页上的gem删除链接时，会请求这个端点。</li></ul><p id="b987" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于最后两个请求，中间件将执行以下操作:</p><ul class=""><li id="df1f" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">要求用户输入他们的LDAP凭据。</li><li id="226e" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">验证是否允许LDAP用户管理相应的gem。</li><li id="c020" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">更新<code class="fe nn no np nq b">GemIndex</code> <strong class="ma iu"> </strong>存储，与<code class="fe nn no np nq b">ApiGem</code> <strong class="ma iu"> </strong>中间件<strong class="ma iu">相同。</strong></li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2a32" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">码头支持</h1><p id="1dbc" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了最终确定解决方案，我想添加对Docker的支持。因此，我在解决方案中添加了一个Docker文件，以便能够为gem服务器生成Docker映像。这些映像可以用来启动Docker容器中的gem服务器。下面是一个gem服务器的<code class="fe nn no np nq b">docker-compose</code>文件示例，包含所有支持的环境变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d4ce" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您想尝试gem服务器，只需复制上面的<code class="fe nn no np nq b">docker-compose</code>模板，修改LDAP配置，并执行以下命令:</p><pre class="kj kk kl km gt oe nq of og aw oh bi"><span id="c1c6" class="nr lh it nq b gy oi oj l ok ol">$&gt; docker-compose up -d</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f12e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="9200" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果你想开始开发私有gem，运行一个gem服务器是必须的。运行自己的gem服务器有几个解决方案。目前，盒子里的宝石是最先进的，也是最接近RubyGems的。然而，该项目仍然缺少一些安全特性，如防止恶意代码注入(任何有权访问服务器的人都可以推送、上传或删除gem)和基于角色的授权。</p><p id="e48b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这篇文章提出了一个在盒子中扩展Gem并支持上述特性的解决方案。完整的源代码解决方案可以在<a class="ae ky" href="https://github.com/wshihadeh/ruby_gems" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到，gem服务器的Docker镜像在这个库中发布<a class="ae ky" href="https://hub.docker.com/repository/docker/wshihadeh/rubygems" rel="noopener ugc nofollow" target="_blank">。该解决方案仍然需要一些改进和增强，任何贡献都是非常受欢迎的。</a></p></div></div>    
</body>
</html>