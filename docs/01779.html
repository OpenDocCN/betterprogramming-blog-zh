<html>
<head>
<title>Constraints in Code — Different Layout Options to SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码中的约束SwiftUI的不同布局选项</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/layout-aside-from-swiftui-92aaa542c6c4?source=collection_archive---------3-----------------------#2019-10-13">https://betterprogramming.pub/layout-aside-from-swiftui-92aaa542c6c4?source=collection_archive---------3-----------------------#2019-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9093" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">NSLayoutConstraints vs . snap kit vs . Visual Format Language</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/596620ee7d84f1de78dfcccea2282fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3n_-FKkMgcoCZvCV-iaO1w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@palon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">邓阳</a>在<a class="ae ky" href="https://unsplash.com/s/photos/layout?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="009d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着iOS 13的推出，开发者现在可以开始在他们的应用中使用SwiftUI了。但也许你不是那种可以在一片绿地上起步，需要支持比最新iOS版本更多的东西的幸运儿。</p><p id="ac69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论你是在开发一个已经开发了多年的大型应用程序，还是你的用户仍然主要在iOS 12上，都有很多很好的理由说明UIKit在未来一年左右仍然是相关的。</p><p id="d8b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在故事板或xib中使用<code class="fe lv lw lx ly b">NSLayoutConstraints</code>也是相当痛苦的，因为文件会变得很大很混乱，需要的约束也越多。如果您使用版本控制，您将会诅咒当前版本和新版本之间的每一个令人困惑的差异，并且讨厌合并冲突。</p><p id="42e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如果SwiftUI还不是一个好的解决方案，故事板也不适合所有人，那么剩下的是什么呢？嗯，仍然可以选择在代码中使用<code class="fe lv lw lx ly b">NSLayoutConstraints</code>,或者使用可视化格式语言Apples DSL来布局视图。</p><p id="1bcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程将向您介绍这两者，并将它们与<a class="ae ky" href="https://github.com/SnapKit/SnapKit" rel="noopener ugc nofollow" target="_blank"> SnapKit </a>进行比较，后者是一个可通过<a class="ae ky" href="https://cocoapods.org/" rel="noopener ugc nofollow" target="_blank"> CocoaPods </a>获得的框架，使在代码中使用约束更具吸引力。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9fdc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">视图的结构</h1><p id="bd9e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">但是在我们深入例子之前，让我们首先探索视图的结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0e44d556b614f391736da40b140413e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*7fW1gRLqOYh1OhA9MAI1lQ.png"/></div></figure><p id="404c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定蓝色框作为视图，它有一个中心点、顶部和底部，以及左侧和右侧。</p><p id="92a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以通过leading和trailing来引用后两者，但是有一个很小但很重要的区别:left将始终是视图的左侧，而leading将是阅读方向的起始端。</p><p id="b941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，右始终是右，尾随是视图在阅读方向上的结束。此外，视图有宽度和高度。</p><p id="4230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过使用<code class="fe lv lw lx ly b">NSLayoutAnchors</code>来引用这些属性。x轴有锚(所谓的<code class="fe lv lw lx ly b">NSLayoutXAxisAnchors</code>)，包含<code class="fe lv lw lx ly b">leadingAnchor</code>、<code class="fe lv lw lx ly b">trailingAnchor</code>、<code class="fe lv lw lx ly b">leftAnchor</code>、<code class="fe lv lw lx ly b">rightAnchor</code>、<code class="fe lv lw lx ly b">centerXAnchor</code>。</p><p id="63f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">y轴的锚点(<code class="fe lv lw lx ly b">NSLayoutYAchsisAnchors</code>)，分别是<code class="fe lv lw lx ly b">topAnchor</code>、<code class="fe lv lw lx ly b">bottomAnchor</code>、<code class="fe lv lw lx ly b">firstBaselineAnchor</code>、<code class="fe lv lw lx ly b">lastBaselineAnchor</code>和<code class="fe lv lw lx ly b">centerYAnchor</code>。</p><p id="fa7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个基线锚将用于<code class="fe lv lw lx ly b">UITextViews</code>。此外，还有两个<code class="fe lv lw lx ly b">NSLayoutDimensions</code>、<code class="fe lv lw lx ly b">widthAnchor</code>和<code class="fe lv lw lx ly b">heightAnchor</code>，以及<code class="fe lv lw lx ly b">UILayoutGuides</code>、<code class="fe lv lw lx ly b">layoutMarginsGuide</code>、<code class="fe lv lw lx ly b">readableContentGuide</code>和<code class="fe lv lw lx ly b">safeAreaLayoutGuide</code>，它们是在iOS 11中引入的，用于处理没有home键的iPhones上的ui。</p><p id="243a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些锚点、尺寸和引导允许我们在屏幕上完全指定视图的位置和大小。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ec6d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">例子</h1><p id="7e0c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了比较上面提到的在代码中创建约束的三个选项，我们将看五个用例，它们可以在下面的GIF中看到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/caf0261806803ee67796142db099aeda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/1*QqzbT7xZFcFbSvaRultuxQ.gif"/></div></figure><ol class=""><li id="96b8" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">在视图的超级视图中定位视图。</li><li id="7eef" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">更改视图的大小。</li><li id="6391" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">相对于另一个视图定位视图。</li><li id="3c33" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">处理冲突和使用优先级。</li><li id="de7e" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">动画变化。</li></ol><p id="4c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将探索如何用plain <code class="fe lv lw lx ly b">NSLayoutConstraints</code>来做这些事情。在下一节中，我们将了解SnapKit如何帮助我们改进代码，最后，我们将了解如何使用可视化格式语言。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8686" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">添加NSLayoutConstraints</h1><p id="5eea" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们从第一个例子开始:如何在其超级视图中定位一个视图。</p><p id="fe01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在动手之前，我们需要创建并准备一个超级视图和一个子视图，并将其添加到超级视图中。对于我们要看的每个例子，这个设置都是一样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="754d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —我们创建一个白色背景的简单二次视图。此视图将用作超级视图，它将包含所有其他视图。</p><p id="f68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —我们创建一个新视图，这次用绿色来区分它和它的超级视图。我们还需要将它的<code class="fe lv lw lx ly b">translatesAutoresizingMaskIntoConstraints</code>属性设置为<code class="fe lv lw lx ly b">false</code>，表明我们将使用自动布局和约束。</p><p id="ab0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了添加一个约束，我们使用一个视图的锚属性，我们已经在前面讨论过了。每个锚点都有一个约束方法来创建一个新的<code class="fe lv lw lx ly b">NSLayoutConstraints</code>。</p><p id="3370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法被传递给与约束相关的另一个锚点，以及其他一些参数。确保将新创建的约束的<code class="fe lv lw lx ly b">isActive</code>属性设置为<code class="fe lv lw lx ly b">true</code>，否则该约束不会对您的视图产生任何视觉效果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用NSLayoutConstraints在视图的superview中定位视图</p></figure><p id="ced5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们添加了一些约束条件，以将视图置于其超级视图的中心，每边距离为20。我们使用子视图<code class="fe lv lw lx ly b">topAnchor</code>、<code class="fe lv lw lx ly b">leadingAnchor</code>、<code class="fe lv lw lx ly b">bottomAnchor</code>和<code class="fe lv lw lx ly b">trailingAnchor</code>，并将它们放置在被查看者的相应锚点旁边的20个点处。</p><p id="498b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这很简单，但是完成这样一个简单的任务需要很多代码。</p><p id="8546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们改变子视图的大小！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用NSLayoutConstraints调整视图大小</p></figure><p id="8b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们没有相对于超级视图的锚点来放置视图的锚点，而是将常量赋值给<code class="fe lv lw lx ly b">heightAnchor</code>和<code class="fe lv lw lx ly b">widthAnchor</code>。由于该职位不再有任何限制，它将位于其超级视图的左上角。</p><p id="5e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在定位一个视图时，我们不需要只使用它的superview的锚，我们可以自由地使用任何我们想要的锚！这可以在下一个例子中看到，我们将一个视图放在另一个视图的旁边。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用NSLayoutConstraints相对于另一个视图定位视图</p></figure><p id="0ac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —首先，我们在容器中放置一个视图。这几乎与第一个例子相同，除了我们给了<code class="fe lv lw lx ly b">trailingAnchor</code>和<code class="fe lv lw lx ly b">bottomAnchor</code>一点点空间来放置另一个视图。</p><p id="c068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —现在，我们可以在前一个视图旁边添加第二个视图。通过将其<code class="fe lv lw lx ly b">topAnchor</code>分配给<code class="fe lv lw lx ly b">firstView</code>的<code class="fe lv lw lx ly b">topAnchor</code>，两者都从与它们的被监督对象相同的高度开始。我们也相对于另一个视图的<code class="fe lv lw lx ly b">trailingAnchor</code>设置<code class="fe lv lw lx ly b">leadingAnchor</code>，并给它一半的尺寸。</p><p id="bfe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，构造约束很容易，但是非常冗长！</p><p id="2a2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们所看到的所有约束都是明确定义的，但是可能会出现约束冲突的情况。让我们看看如何使用优先级来解决这种冲突。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用NSLayoutConstraints添加优先级</p></figure><p id="45fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —和往常一样，我们从简单的约束开始，将视图放入容器中。</p><p id="b07c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这一次，我们添加了相互冲突的尾部和宽度约束。视图不能在它的<code class="fe lv lw lx ly b">trailingAnchor</code>和超级视图的<code class="fe lv lw lx ly b">trailingAnchor</code>之间有0空间，同时仍然有它的一半宽度。</p><p id="518d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —因此，我们需要分清主次。我们可以使用0到1000之间的任何值，但是我们可以使用三个缺省值。<code class="fe lv lw lx ly b">UILayoutPriority.required</code>对应<code class="fe lv lw lx ly b">1000</code>，最高可能值，<code class="fe lv lw lx ly b">.defaultHigh</code>等于<code class="fe lv lw lx ly b">750</code>，<code class="fe lv lw lx ly b">.defaultLow</code>表示<code class="fe lv lw lx ly b">250</code>。</p><p id="2c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有两个值属于优先级:<code class="fe lv lw lx ly b">ContentHuggingPriority</code>和<code class="fe lv lw lx ly b">ContentCompressionResistancePriority</code>。</p><p id="cf5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当两个视图彼此相邻时，它们的大小也由所谓的内在内容大小决定。该值是视图内容的大小，例如，对于<code class="fe lv lw lx ly b">UILabel</code>来说，它显示的文本影响其大小，或者对于<code class="fe lv lw lx ly b">UIImageView</code>来说，其图像的大小很重要。</p><p id="e4a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ContentHuggingPriority</code>描述了一个视图在多大程度上阻止了其内容大小的增长。如果视图有一个高的<code class="fe lv lw lx ly b">ContentHuggingPriority</code>，它会强烈地抵制增长，但是如果它是一个低的值，如果环境所迫，它可能会变得更大。</p><p id="87f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ContentCompressionResistancePriority</code>与此非常相似，除了它没有表达视图增长的可能性有多大，而是表达视图缩小到小于其内在内容大小的可能性有多大。</p><p id="d692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的是展示这两个优先事项之间差异的绝佳图片。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拥抱和抗压性能</p></figure><p id="fc30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改变这些值很容易。您只需要在视图上调用这些方法中的任何一个，并传递一个优先级和一个轴。</p><p id="8166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，让我们制作<code class="fe lv lw lx ly b">NSLayoutConstraints</code>变化的动画。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用NSLayoutConstraints制作约束更改的动画</p></figure><p id="7550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —就像之前一样，我们向视图添加约束。</p><p id="ab45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —但是，这一次，我们将在变量中保存一个约束。这是我们以后想要改变的。别忘了激活它！</p><p id="1193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们将这个约束保存在一个变量中，所以我们可以在以后修改它。这里，我们将常量属性从20更改为50，因此<code class="fe lv lw lx ly b">topAnchor</code>将下移30点。</p><p id="c796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —我们可以使用<code class="fe lv lw lx ly b">UIView</code>的静态动画方法来制作这种变化的动画。在闭包里面，我们调用<code class="fe lv lw lx ly b">layoutIfNeeded</code>，这将触发动画。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8439" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用SnapKit改进约束</h1><p id="9cca" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">既然你已经看到了如何在你的代码中使用<code class="fe lv lw lx ly b">NSLayoutConstraints</code>，你可能不喜欢使用它们，因为它们太冗长了。但是不要担心，其他人也有同样的担忧——并且创造了SnapKit。</p><p id="5781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个框架使得用更少的代码创建约束变得更加容易。</p><p id="731d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看第一个例子，它和第一个例子<code class="fe lv lw lx ly b">NSLayoutConstraints</code>做的一样:在它的超级视图中放置一个简单的视图，每边20点的距离。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用SnapKit在视图的超级视图中定位视图</p></figure><p id="f56d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们不需要将视图的<code class="fe lv lw lx ly b">translatesAutoresizingMaskIntoConstraints</code>设置为<code class="fe lv lw lx ly b">false</code>，这意味着我们再也不能忘记它了！</p><p id="1fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用更少的代码就可以得到同样的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用SnapKit在视图的superview中定位视图</p></figure><p id="1367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太神奇了！这看起来比使用普通的<code class="fe lv lw lx ly b">NSLayoutConstraints</code>要干净漂亮得多。但是还有更多。这里，我们做第二个例子，给出一个高度和宽度为100的视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用SnapKit调整视图大小</p></figure><p id="fbd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想要将两个视图相邻放置时，我们也可以参考其他视图的SNP属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用SnapKit相对于另一个视图定位一个视图</p></figure><p id="0be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子显示了另外两个有趣的点:</p><p id="d1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —我们可以使用<code class="fe lv lw lx ly b">UIEdgeInsets</code>来指定距离。<code class="fe lv lw lx ly b">firstView</code>现在到其超级视图的顶部和左侧有20点的距离，到右侧和底部有100点的距离。</p><p id="6797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —通过链接<code class="fe lv lw lx ly b">dividedBy</code>或<code class="fe lv lw lx ly b">multipliedBy</code>方法，我们可以引用其他锚点并同时操作它们。</p><p id="c6d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们看看如何处理冲突和使用优先级。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用SnapKit添加优先级</p></figure><p id="3539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —通过链接带标签的方法，我们可以给约束一个明确的名称。如果有任何涉及此约束的冲突，此名称将被打印到控制台。</p><p id="80f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —我们也可以链接方法优先级。顾名思义，这将为生成的约束赋予优先级。</p><p id="5916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们看到的<code class="fe lv lw lx ly b">NSLayoutConstraints</code>的正常<code class="fe lv lw lx ly b">UILayoutConstraints</code>，我们可以使用值<code class="fe lv lw lx ly b">.required</code> (= 1000)、<code class="fe lv lw lx ly b">.high</code> (= 750)和<code class="fe lv lw lx ly b">.low</code> (= 250)。</p><p id="5e49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，SnapKit知道优先级<code class="fe lv lw lx ly b">.medium</code>，macOS是<code class="fe lv lw lx ly b">501</code>，iOS是<code class="fe lv lw lx ly b">500</code>。</p><p id="1ab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">NSLayoutConstraints</code>相反，我们不能通过SnapKit访问视图的<code class="fe lv lw lx ly b">ContentHuggingPriority</code>和<code class="fe lv lw lx ly b">ContentCompressionResistancePriority</code>。</p><p id="a5ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一个真正的问题，因为我们可以自由地混合使用<code class="fe lv lw lx ly b">NSLayoutConstraints</code>和SnapKit，因此只使用前面介绍的两种方法。</p><p id="20d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为对SnapKit的最后一次观察，让我们用动画演示对视图约束的更改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用SnapKit制作约束更改的动画</p></figure><p id="b6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —首先，我们添加我们想要用其初始约束制作动画的视图。</p><p id="93f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —同样，我们可以使用<code class="fe lv lw lx ly b">UIView</code>的静态方法animate。通过调用动画闭包内的方法<code class="fe lv lw lx ly b">updateConstraints</code>，我们可以给约束一个新的偏移量。</p><p id="50c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —和之前一样，我们可以通过调用<code class="fe lv lw lx ly b">layoutIfNeeded</code>来触发更新。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fe75" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用可视化格式语言</h1><p id="dcfe" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">还有另一种在代码中定义约束的方法——可视化格式语言。也许你听说过这种奇怪的DSL来布局视图，但是如果你没有，让我们快速地看一下它是如何构造的。</p><p id="43b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VFL有多个组成部分:</p><ul class=""><li id="1d7b" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nv nl nm nn bi translated">方位可以用<code class="fe lv lw lx ly b">H</code>表示水平，用<code class="fe lv lw lx ly b">V</code>表示垂直。</li><li id="1fad" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">Superview以<code class="fe lv lw lx ly b">|</code>为代表。</li><li id="6f0e" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">默认距离可与符号<code class="fe lv lw lx ly b">-</code>一起使用。</li><li id="792a" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">要使用任意距离x，使用<code class="fe lv lw lx ly b">-x-</code>。</li><li id="0f72" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">数值可以与<code class="fe lv lw lx ly b">==</code>、<code class="fe lv lw lx ly b">&gt;=</code>或<code class="fe lv lw lx ly b">&lt;=</code>进行比较。</li><li id="1f28" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">优先级用<code class="fe lv lw lx ly b">@</code>表示。</li><li id="4bfa" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">要引用一个视图，需要将其嵌入到<code class="fe lv lw lx ly b">[]</code>中。</li></ul><p id="ebf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一些简单的例子来习惯这种符号。</p><p id="ee51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串<code class="fe lv lw lx ly b">“H:|-[button]-|”</code>定义了水平约束，其中一个名为<code class="fe lv lw lx ly b">button</code>的视图具有到其超级视图的前导和尾随标准距离。</p><p id="47f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个有效的字符串是<code class="fe lv lw lx ly b">„V: |-20-[image]-20-[button]-|“</code>。这个表达了一个名为<code class="fe lv lw lx ly b">image</code>的视图和一个名为<code class="fe lv lw lx ly b">button</code>的视图之间的垂直约束。</p><p id="8f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像的顶部锚点比它的超级视图低20磅，图像的底部锚点和按钮的顶部锚点之间也是20磅。最后，按钮到它的超级视图有8个点的距离。</p><p id="15f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以查看雷·温德里希关于VFL的教程以获得关于VFL更详细的介绍。</p><p id="6fb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，使用VFL有一个明显的缺点，你应该知道。当您使用原始字符串创建约束时，错误将会进入这些定义。</p><p id="5733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许您在视图的标识符中输入了错误，或者您忘记了定义一个您想要在约束中使用的常量值。如果出现这种情况，应用程序将会崩溃。</p><p id="ccbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是现在，让我们看看我们已经探索过的其他技术的用例，从简单地将一个视图定位在其superview中开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用VFL的观点来定位它的监督</p></figure><p id="2d7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —为了在VFL字符串中使用我们的视图，我们需要创建一个包含我们的视图和标识符的字典。</p><p id="8b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该字典稍后将被赋予方法<code class="fe lv lw lx ly b">constraints(withVisualFormat:metrics:views:)</code>，该方法创建给定VFL字符串的所有约束。参数metrics需要另一个字典，我们将在后面的示例中看到。</p><p id="7c9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">// 2 </strong></code> —现在我们可以创建两个字符串了——一个用于水平约束，一个用于垂直约束。在这种情况下，这些字符串是很容易理解的，我们给20点的距离，每一边我们的看法。</p><p id="69d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —最后，我们可以创建并激活约束。这可以用前面提到的方法<code class="fe lv lw lx ly b">constraints(withVisualFormat:metrics:views:)</code>来完成，该方法返回一个数组<code class="fe lv lw lx ly b">NSLayoutConstraints</code>。我们还需要激活这些约束，使它们处于活动状态。</p><p id="2969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以看看如何给视图一个特定的大小。在下面的代码中，我们做了几乎和以前一样的事情，首先我们创建一个<code class="fe lv lw lx ly b">views-dictionary</code>，然后我们在一个VFL字符串中指定约束，只是为了在最后一步创建和激活约束。</p><p id="a64c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的示例中，您也将看到这个过程。这里的主要区别是两根弦。要给视图一个高度和宽度值，可以在括号中添加尺寸。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用VFL调整视图大小</p></figure><p id="5d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将两个视图相邻放置会变得非常复杂。您可以从一开始就添加<em class="nw">描述两个视图</em>，但是在下面的例子中，我们将采用另一种方法。</p><p id="78b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将为第一个视图定义、创建和激活所有约束，然后我们将添加第二个视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用VFL相对于另一个视图定位一个视图</p></figure><p id="8321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —我们首先创建一个包含第一个视图的字典，定义字符串，将第一个视图放在它的超级视图中，并创建和激活这些约束。</p><p id="584a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —要添加第二个视图，我们需要更新视图的字典来包含第二个视图。</p><p id="e6e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —这一次，我们还需要一个度量字典，存储我们想要在VFL字符串中使用的值。在这种情况下，我们希望第二个视图的高度是第一个视图的一半，因此我们可以在标识符<code class="fe lv lw lx ly b">halfHeight</code>下访问这个值。</p><p id="0b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —给定更新视图的字典和新的度量字典，我们可以指定第二个视图的位置和大小。</p><p id="1826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 5</code> —最后，我们可以为第二个视图创建并激活所有约束。这里，我们还将度量字典传递给方法。</p><p id="61cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这又是如此多的工作要做，只是显示两个视图相邻！它可能看起来比使用<code class="fe lv lw lx ly b">NSLayoutConstraints</code>时要干净一点，但同样冗长。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用VFL调整视图大小</p></figure><p id="1c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们来看看可视化格式语言中的优先级。正如在关于其组件的章节中所描述的，我们可以通过使用<code class="fe lv lw lx ly b">@</code>加上一个数字来添加优先级。</p><p id="3750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和往常一样，我们可以使用0到1000之间的数字，但是这一次，没有我们可以使用的常量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">与VFL一起添加优先级</p></figure><p id="0c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —同样，我们创建了一个视图和一个指标字典。后一个值是容器宽度的一半，这将被用来引发冲突，我们需要优先级。</p><p id="4ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以创建VFL弦了。这里，我们告诉视图的左右两边和被观察对象的左右两边之间没有距离。同样，我们期望它是容器宽度的一半——当然，这是行不通的。因此，我们需要在冲突的价值观后面加上优先权。</p><p id="c28d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —作为最后一步，我们创建并激活这些约束。</p><p id="20db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，让我们看看如何动画变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用VFL制作约束变化的动画</p></figure><p id="96b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —第一部分看起来很熟悉，但这一次，我们将两个约束数组存储在单独的变量中，以便以后再次访问它们。</p><p id="c9f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与VFL一起改变约束是一项艰巨的任务。首先，我们需要解除旧的约束。</p><p id="8e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —然后，我们需要创建并激活新的约束，我们不能重用旧的约束。</p><p id="2f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4 </code> —为了触发动画，我们在animate方法的闭包中使用<code class="fe lv lw lx ly b">layoutIfNeeded</code>，就像往常一样。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2f0b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="9e1a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">正如你在例子中看到的，使用纯粹的<code class="fe lv lw lx ly b">NSLayoutConstraints</code>会变得像用故事板管理许多约束一样复杂和混乱。</p><p id="9c4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VFL允许对我们的用户界面进行更简洁的描述，但是由于使用了字符串，所以很容易出错。而且，也不比上一篇啰嗦。</p><p id="c078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SnapKit结合了VFL的简洁描述和更容易使用的<code class="fe lv lw lx ly b">NSLayoutConstraints</code>，因此，如果你想用代码构建你的视图，似乎是最好的选择。</p><p id="d168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它可以与<code class="fe lv lw lx ly b">NSLayoutConstraints</code>并行使用，因此可以只改进一大堆约束或逐步引入。</p><p id="d1df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！现在你已经看到了用pure <code class="fe lv lw lx ly b">NSLayoutConstraints</code>、SnapKit和可视化格式语言完成的多个用例。</p><p id="cc4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想在代码中创建约束，我希望您知道应该使用哪一个。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b520" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">资源</h1><ul class=""><li id="91aa" class="nf ng it lb b lc my lf mz li nx lm ny lq nz lu nv nl nm nn bi translated">snap kit:<a class="ae ky" href="http://snapkit.io" rel="noopener ugc nofollow" target="_blank">http://snap kit . io</a></li><li id="a6d5" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">Raywenderlich视觉格式语言教程:<a class="ae ky" href="https://www.raywenderlich.com/277-auto-layout-visual-format-language-tutorial" rel="noopener ugc nofollow" target="_blank">https://www . raywenderlich . com/277-auto-layout-Visual-Format-Language-tutorial</a></li></ul></div></div>    
</body>
</html>