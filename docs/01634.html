<html>
<head>
<title>Mastering Software Engineering in iOS: Single Responsibility Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握iOS中的软件工程:单一责任原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-software-engineering-in-ios-solid-part-1-5a256e1d3b43?source=collection_archive---------18-----------------------#2019-09-30">https://betterprogramming.pub/mastering-software-engineering-in-ios-solid-part-1-5a256e1d3b43?source=collection_archive---------18-----------------------#2019-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4fb2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">SRP:软件开发基础易于解释</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c2726b27b25a93aad62883e910b86072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mf3OUn0fh8rQYHQR"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@writecodenow?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">博伊图梅洛·菲特拉</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="dd24" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="7250" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这一系列文章中，我将尝试在iOS开发的背景下布局好的软件工程基础。</p><p id="62df" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">那么就从每次求职面试都会提到的话题开始:<em class="mp">扎实</em>原则。</p><h1 id="4b77" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">固体</h1><p id="e45f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="mp"> SOLID </em>是Bob叔叔<a class="ae kv" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">提出的5个原则的首字母缩写，这些原则是编写好的面向对象代码的基础:</a></p><ul class=""><li id="afee" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">单一责任原则</li><li id="3703" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">开闭原理</li><li id="769f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">利斯科夫替代原理</li><li id="c6e6" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">界面分离原理</li><li id="b12f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">从属倒置原则</li></ul><p id="9ea7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">也许你已经听说过那些原则，甚至还记得它们。但是如果我向你要一个例子，你能为每个原则写一个代码，然后解释它吗？</p><p id="54c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是大多数人的问题所在:在日常的实际使用中。为了写出好的代码，你需要理解为什么坏代码是坏的。为了让你们了解全貌，我将:</p><ul class=""><li id="949e" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">给出每个<em class="mp">固体</em>原理的简单定义</li><li id="4312" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">举一个糟糕的代码的例子，它在某种程度上破坏了所讨论的原则</li><li id="06dd" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">解释为什么这个原则在给定的例子中被打破</li><li id="51a6" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">重构代码，因此该示例符合所讨论的原则</li><li id="cd3d" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">解释为什么现在它符合它</li></ul><p id="78f3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我将向大家展示的每个例子都将在<em class="mp"> Swift Playground </em>中发挥作用</p><p id="bfeb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了使这篇文章的篇幅合理，我将按每部分的每个<em class="mp">固体</em>原理来拆分。所以还是从第一个开始吧！</p><h1 id="c037" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">单一责任原则</h1><blockquote class="ne nf ng"><p id="6977" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated"><em class="iq">“一个类应该只有一个改变的理由”</em></p></blockquote><p id="9f35" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这条规则说的是一个给定的类应该只有一个存在的理由，因此也应该只有一个改变它的理由。</p><p id="3e4f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当创建一个类时，你应该严格定义它是什么<em class="mp">存在的理由</em>并坚持下去。开设有一个特定目的的课程，这样你就清楚了。</p><h2 id="3a98" class="nk kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">示例1</h2><p id="d8e3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们看一个非常简单的例子，这个类应该发送带有附件的电子邮件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b945" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">类<code class="fe ny nz oa ob b">EmailSender</code>打破了<em class="mp">单一责任原则</em>，因为有2个原因要改变它:</p><ol class=""><li id="5c9f" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj oc mw mx my bi translated">发送电子邮件逻辑的任何改变都需要改变<code class="fe ny nz oa ob b">EmailSender</code>类。</li><li id="1d3f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj oc mw mx my bi translated">我们从操作系统加载文件的逻辑的改变也需要改变<code class="fe ny nz oa ob b">EmailSender</code>类。</li></ol><p id="6d70" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">只有第一个改变的原因是有意义的。发送电子邮件本身不应该与从我们的操作系统获取文件有任何关系。应该拥有发送电子邮件所需的所有数据，并且不应该关心这些数据是如何获得的。</p><p id="d64a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">编译成<em class="mp">单一责任原则</em>的示例如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6b17" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在有两个班，每个班只有一个责任。<code class="fe ny nz oa ob b">FileReader</code>处理文件，<code class="fe ny nz oa ob b">EmailSender</code>发送电子邮件(不管附件是如何创建的)。</p><h2 id="d6fd" class="nk kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">示例2</h2><p id="53f5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">前面的例子以一种非常简单的方式打破了SRP，但是在现实生活中，人们倾向于以一种更加微妙的方式打破它。下面的例子乍一看似乎是正确的，但是当你仔细观察时，你会发现它实际上违反了SRP。</p><p id="49ec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">设想一个酒店应用程序，它保存房间预订、客人的个人信息、房间细节(床位数、浴室数等)。).</p><p id="d8f4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一个典型的违反单一责任原则的真实例子应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="248e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果酒店老板为其中一个房间购买了空调，存储这些信息将会改变<code class="fe ny nz oa ob b">Room</code>类的实现，这是完全可以理解的。</p><p id="4de5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设有一项新的法律，禁止酒店收集顾客的年龄数据。为了实现这个改变，我们需要改变<code class="fe ny nz oa ob b">Room</code>和<code class="fe ny nz oa ob b">Guest</code>两个类。为什么从我们的应用程序中删除客人的年龄会影响到<code class="fe ny nz oa ob b">Room</code>类的实现？！类<code class="fe ny nz oa ob b">Room</code>打破了<em class="mp">单一责任原则</em>，因为有2个原因要改变它:</p><ol class=""><li id="b9b6" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj oc mw mx my bi translated">酒店房间逻辑的任何改变都需要改变<code class="fe ny nz oa ob b">Room</code>类。比如:加空调。</li><li id="a7a1" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj oc mw mx my bi translated">创建guest的逻辑的变化也需要在<code class="fe ny nz oa ob b">addGuestThatWillOccupyTheRoom(guestFirstName:guestLastName:age:)</code>方法中的<code class="fe ny nz oa ob b">Room</code>类的变化。</li></ol><p id="0d4d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如你所看到的，所需要做的只是在一个错误的地方调用一个构造函数，创建一个有不止一个理由要改变的类。</p><p id="d166" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">符合<em class="mp">单一责任原则</em>的示例如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="99e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们已经通过移除<code class="fe ny nz oa ob b">Guest</code>的构造函数调用，使<code class="fe ny nz oa ob b">addGuestToTheRoom(guest:)</code>的实现独立于<code class="fe ny nz oa ob b">Guest</code>的实现。</p><p id="7f88" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这种方式的<code class="fe ny nz oa ob b">addGuestToTheRoom(guest:)</code>方法并不真正关心<code class="fe ny nz oa ob b">Guest</code>对象是如何创建的。只要将<code class="fe ny nz oa ob b">Guest</code>对象(不管它是如何初始化的)传递给它，它就会工作。</p><p id="3342" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以现在我们在法律上的改变完全可以在不影响<code class="fe ny nz oa ob b">Room</code>类的情况下实现，因为现在它只有一个改变的理由(房间逻辑本身)。</p><h2 id="7c29" class="nk kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">如何定义改变的理由？</h2><p id="aff5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">并不是每个例子都像我们的电子邮件和酒店应用程序那样黑白分明。如果一个类存在的理由足够广泛，我们总是可以假装我们只有一个理由去改变它。</p><p id="1056" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可以创建一个类<code class="fe ny nz oa ob b">DataManager</code>，而不是两个独立的类:<code class="fe ny nz oa ob b">InputReader</code>和<code class="fe ny nz oa ob b">OutputWriter</code>。输入和输出都将由<code class="fe ny nz oa ob b">DataManager</code>管理。这个类显然有两个改变的理由(处理输入和处理输出)，但是用我们巧妙的措辞看起来只有一个理由:数据管理。这可以说仍然是一个糟糕的设计选择！</p><p id="5cdf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是这是双向的:太具体了，你会得到数百个可笑的相互关联的类，这很容易成为一个。</p><p id="af5c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看一下<code class="fe ny nz oa ob b">String</code>结构。它做了很多，但所有这些在一个给定的上下文中都是有意义的。我们不希望有像<code class="fe ny nz oa ob b">StringCapitalizer</code>、<code class="fe ny nz oa ob b">StringUppercaser</code>、<code class="fe ny nz oa ob b">StringLowercasser</code>这样过于专门化的结构/类。那太荒谬了！</p><p id="ad8d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，类及其存在(和变化)的原因应该足够专门化。精细平衡是这里的关键。</p><p id="fdf5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">考虑到这一点，原来的原则也可以(<a class="ae kv" href="https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="noopener ugc nofollow" target="_blank">和被！</a>)这样措辞:</p><blockquote class="ne nf ng"><p id="3d8a" class="lo lp mp lq b lr mk jr lt lu ml ju lw nh mm lz ma ni mn md me nj mo mh mi mj ij bi translated"><em class="iq">“把因为相同原因而改变的东西聚集在一起。把那些因为不同原因而改变的东西分开。”</em></p></blockquote><h1 id="12c0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">原来如此！</h1><p id="be30" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在你已经知道了<em class="mp">单一责任原则</em>的全部内容，并且应该能够自己想出例子来！</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="209a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">值得注意的是，有时术语“软件模块”被用来代替“类”，以使这个原则更加通用。</p></div></div>    
</body>
</html>