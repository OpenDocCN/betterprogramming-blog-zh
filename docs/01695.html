<html>
<head>
<title>How To Train a Core ML Model in Your iOS App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在你的iOS应用中训练一个核心ML模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-train-a-core-ml-model-on-your-device-cccd0bee19d?source=collection_archive---------5-----------------------#2019-10-06">https://betterprogramming.pub/how-to-train-a-core-ml-model-on-your-device-cccd0bee19d?source=collection_archive---------5-----------------------#2019-10-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0005" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">“如何使用Core ML 3创建可更新的模型”的续篇</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/49a9f4297a94b274fa3cbc8e0b9185f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKZtrhNo5xHSWeJh7c9Ptg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@nervum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">千斤顶B </a>在<a class="ae kz" href="https://unsplash.com/s/photos/dragon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">防溅器</a>上拍照</p></figure><p id="d671" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是上一篇文章<a class="ae kz" href="https://medium.com/better-programming/how-to-create-updatable-models-using-core-ml-3-cc7decd517d5" rel="noopener">如何使用Core ML 3 </a>创建可更新模型的续篇。</p><p id="2eb4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了<a class="ae kz" href="https://developer.apple.com/machine-learning/core-ml/" rel="noopener ugc nofollow" target="_blank"> Core ML 3 </a>，在一个设备上训练一个Core ML模型比驯服一条龙容易多了！</p><p id="aa0f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">先决条件:</p><ul class=""><li id="3f12" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">从<a class="ae kz" href="https://medium.com/better-programming/how-to-create-updatable-models-using-core-ml-3-cc7decd517d5" rel="noopener">之前的</a>帖子中获取可更新的<code class="fe mf mg mh mi b">mlmodel</code>。</li><li id="eb99" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated">只需将<code class="fe mf mg mh mi b">mlmodel</code>拖到您的<a class="ae kz" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank"> Xcode </a>项目中。</li></ul></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="6d41" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">行动（或活动、袭击）计划</h1><ul class=""><li id="ff5c" class="lw lx iu lc b ld nn lg no lj np ln nq lr nr lv mb mc md me bi translated">通过用相反的标签重新标记预测的图像，在设备上重新训练猫与狗分类器核心ML模型。</li><li id="89d2" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated">用我们的可更新模型在设备上训练这批重新标记的图像。</li><li id="e884" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated">将新的更新模型保存在设备上应用程序的文档目录中，并使用该新模型进行未来预测或重新训练。</li></ul></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="6792" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">最终目的地</h1><p id="e4ec" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated">一幅图像胜过千言万语。GIF由成千上万的图片组成。这是本文结束时您将得到的最终结果。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nv"><img src="../Images/1e0dae7c3b564206152046904d5d1fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/1*S7f1Ck4udTsZ8Vd7A133VQ.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">输出屏幕记录</p></figure><p id="7515" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如你在屏幕截图中看到的，我们允许用反向标签重新训练预测图像。</p><p id="8cf9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">重新标记和重新训练模型并不总是保证不同的预测。</p><p id="4340" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们知道了最终结果，让我们开始在设备上训练您的ML模型的旅程。在我们深入研究代码之前，让我们先了解一下我们将要使用的核心ML类和API。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="ade3" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">简要了解核心ML API</h1><p id="1000" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated"><code class="fe mf mg mh mi b">MLModel</code>是封装模型的类。</p><p id="99cf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将在接下来的章节中讨论以下重要的类和协议:</p><ul class=""><li id="a27f" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><code class="fe mf mg mh mi b">MLFeatureValue</code></li><li id="58a7" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated"><code class="fe mf mg mh mi b">MLImageConstraints</code></li><li id="ab88" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated"><code class="fe mf mg mh mi b">MLFeatureProvider</code></li><li id="86d3" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated"><code class="fe mf mg mh mi b">MLBatchProvider</code></li><li id="bf31" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated"><code class="fe mf mg mh mi b">MLUpdateTask</code></li></ul><h2 id="6477" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">MLFeatureValue</h2><p id="f4b3" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated"><code class="fe mf mg mh mi b">MLFeatureValue</code>充当数据的包装器。核心ML模型以<code class="fe mf mg mh mi b">MLFeatureValue</code>的形式接受输入和输出。</p><p id="bed8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mf mg mh mi b">MLFeatureValue</code>让我们直接使用一个<code class="fe mf mg mh mi b">CGImage</code>。与此同时，我们可以传递模型的图像约束。它从<code class="fe mf mg mh mi b">CGImage</code>中为您创建了<code class="fe mf mg mh mi b">CVPixelBuffer</code>，从而避免了编写助手方法的需要。</p><p id="caae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面这段代码从图像中创建了一个<code class="fe mf mg mh mi b">MLFeatureValue</code>实例。</p><pre class="kk kl km kn gu oi mi oj ok aw ol bi"><span id="3da0" class="nw mw iu mi b gz om on l oo op">let featureValue = try MLFeatureValue(cgImage: image.cgImage!, constraint: imageConstraint, options: nil)</span></pre><p id="0d59" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们来看看<code class="fe mf mg mh mi b">MLImageConstraints</code>。</p><h2 id="9c6e" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">MLImageConstraints</h2><p id="49a2" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated"><code class="fe mf mg mh mi b">MLImageConstraints</code>负责向模型输入正确尺寸的图像。它包含输入信息。在我们的例子中，这就是图像大小和图像格式。</p><p id="17e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以使用下面这段代码轻松地从模型中检索图像约束对象:</p><pre class="kk kl km kn gu oi mi oj ok aw ol bi"><span id="451d" class="nw mw iu mi b gz om on l oo op">let imageConstraint = model?.modelDescription.inputDescriptionsByName["image"]!.imageConstraint!</span></pre><p id="3e28" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们只需要将输入名称(<code class="fe mf mg mh mi b">“image”</code>，在我们的例子中)传递给模型描述。</p><h2 id="10eb" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">MLFeatureProvider</h2><p id="f54d" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated">一个<code class="fe mf mg mh mi b">MLFeatureValue</code>没有直接传入模型。需要包裹在<code class="fe mf mg mh mi b">MLFeatureProvider</code>里面。</p><p id="14dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您检查<code class="fe mf mg mh mi b">mlmodel</code> Swift文件，该模型实现了<code class="fe mf mg mh mi b">MLFeatureProvider</code>协议。为了从<code class="fe mf mg mh mi b">MLFeatureProvider</code>访问<code class="fe mf mg mh mi b">MLFeatureValue</code>，有一个<code class="fe mf mg mh mi b">featureValue</code>访问器方法。</p><p id="6c57" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mf mg mh mi b">MLDictionaryFeatureProvider</code>是一个方便的包装器，以字典格式保存数据。它需要输入名称(在我们的例子中是<code class="fe mf mg mh mi b">"image"</code>作为键，需要<code class="fe mf mg mh mi b">MLFeatureValue</code>作为值。</p><p id="dd6c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果输入超过，只需将它们添加到同一个字典中。</p><h2 id="46c8" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">MLBatchProvider</h2><p id="233f" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated">这保存了用于批处理的<code class="fe mf mg mh mi b">MLFeatureProviders</code>的集合。</p><p id="debb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们可以预测多个特性提供者，或者训练一批封装在<code class="fe mf mg mh mi b">MLBatchProvider</code>中的训练输入。在本文中，我们将采用后者。</p><p id="efd6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一个<code class="fe mf mg mh mi b">MLArrayBatchProviders</code>包含一组批处理提供者。</p><h2 id="4aec" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">MLUpdateTask</h2><p id="b5ac" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated">一个<code class="fe mf mg mh mi b">MLUpdateTask</code>负责用新的训练输入更新模型。</p><h2 id="8eba" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated"><strong class="ak">所需参数</strong></h2><ul class=""><li id="2387" class="lw lx iu lc b ld nn lg no lj np ln nq lr nr lv mb mc md me bi translated">模型URL —编译模型的位置(<code class="fe mf mg mh mi b">mlmodelc</code>扩展名)。</li><li id="3e0b" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated">训练数据— <code class="fe mf mg mh mi b">MLArrayBatchProviders</code>。</li><li id="fd18" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated">车型配置——这里我们通过<code class="fe mf mg mh mi b">MLModelConfiguration</code>。我们可以使用现有模型的配置或对其进行定制。例如，我们可以强制模型在CPU和/或GPU和/或神经引擎上运行。</li><li id="842c" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated">完成处理程序——它返回<code class="fe mf mg mh mi b">context</code>,从中我们可以访问更新后的模型。然后我们可以将模型写回文档目录。</li></ul><h2 id="3889" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated"><strong class="ak">可选参数</strong></h2><ul class=""><li id="67a8" class="lw lx iu lc b ld nn lg no lj np ln nq lr nr lv mb mc md me bi translated"><code class="fe mf mg mh mi b">progressHandlers</code> —这里您通过<code class="fe mf mg mh mi b">MLUpdateProgressHandlers</code>传递您想要收听的一系列事件，例如纪元开始/结束、训练开始/结束。</li><li id="aea8" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated"><code class="fe mf mg mh mi b">progressHandler</code> —每当第一个案例中定义的任何事件被触发时，就会调用这个函数。</li></ul><p id="6b03" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要开始训练，只需调用<code class="fe mf mg mh mi b">updateTask</code>实例上的<code class="fe mf mg mh mi b">resume()</code>函数。</p><p id="0877" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是一个在设备上训练数据的伪代码:</p><pre class="kk kl km kn gu oi mi oj ok aw ol bi"><span id="63d0" class="nw mw iu mi b gz om on l oo op">let updateTask = try MLUpdateTask(forModelAt: updatableModelURL, trainingData: trainingData, configuration: model.configuration, completionHandler: { context in </span><span id="e2e0" class="nw mw iu mi b gz oq on l oo op">} </span><span id="4da4" class="nw mw iu mi b gz oq on l oo op">updateTask.resume()</span></pre><p id="40af" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们已经对不同的组件及其角色有了一个概念，让我们构建我们的iOS应用程序，在设备上训练模型。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="6f95" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">密码</h1><h2 id="f7c9" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">我们的故事板</h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj or"><img src="../Images/926a6f99d7516f68e3c62c6a64c864b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xPp2uinV1mci1-ZN.png"/></div></div></figure><h2 id="1202" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">从URL加载模型</h2><p id="0651" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated">首先，让我们尝试将我们的<code class="fe mf mg mh mi b">mlmodel</code>加载到一个单独的URL上的documents目录中:</p><pre class="kk kl km kn gu oi mi oj ok aw ol bi"><span id="1d58" class="nw mw iu mi b gz om on l oo op">private func loadModel(url: URL) -&gt; MLModel? {<br/>      do {<br/>        let config = MLModelConfiguration()<br/>        config.computeUnits = .all<br/>        return try MLModel(contentsOf: url, configuration: config)<br/>      } catch {<br/>        print("Error loading model: \(error)")<br/>        return nil<br/>      }<br/>}</span><span id="8dba" class="nw mw iu mi b gz oq on l oo op">let modelURL = Bundle.main.url(forResource: "CatDogUpdatable", withExtension: "mlmodelc")<br/>let updatableModel = loadModel(url: modelURL)</span></pre><h2 id="ba5f" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">使用MLModel预测图像</h2><p id="a17c" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated">既然我们已经从URL中获得了<code class="fe mf mg mh mi b">MLModel</code>，我们将运行预测代码，假设我们已经从<code class="fe mf mg mh mi b">ImagePickerController</code>中获得了图像。</p><pre class="kk kl km kn gu oi mi oj ok aw ol bi"><span id="b06c" class="nw mw iu mi b gz om on l oo op">func predict(image: UIImage) -&gt; Animal? {<br/>        let imageConstraint = model.modelDescription.inputDescriptionsByName["image"]!.imageConstraint! <br/>    <br/>        do{<br/>            <br/>            let imageOptions: [MLFeatureValue.ImageOption: Any] = [<br/>                .cropAndScale: VNImageCropAndScaleOption.scaleFill.rawValue<br/>            ]<br/>            <br/>            let featureValue = try MLFeatureValue(cgImage: image.cgImage!, constraint: imageConstraint, options: imageOptions)<br/>            let featureProviderDict = try MLDictionaryFeatureProvider(dictionary: ["image" : featureValue])<br/>            let prediction = try updatableModel?.prediction(from: featureProviderDict)<br/>            let value = prediction?.featureValue(for: "classLabel")?.stringValue<br/>            if value == "Dog"{<br/>                return .dog<br/>            }<br/>            else{<br/>                return .cat<br/>            }<br/>        }catch(let error){<br/>            print("error is \(error.localizedDescription)")<br/>        }<br/>        return nil<br/>}</span></pre><p id="f8a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们只是将<code class="fe mf mg mh mi b">UIImage</code>作为<code class="fe mf mg mh mi b">CGImage</code>传递给带有模型输入的<code class="fe mf mg mh mi b">MLImageConstraints</code>的<code class="fe mf mg mh mi b">MLFeatureValue</code>，然后<code class="fe mf mg mh mi b">MLDictionaryFeatureProvider</code>在<code class="fe mf mg mh mi b">MLModel</code>上运行预测。</p><p id="82b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mf mg mh mi b">featureValue</code>返回一组<code class="fe mf mg mh mi b">featureNames</code>。在我们的例子中，<code class="fe mf mg mh mi b">classLabel</code>包含标签<code class="fe mf mg mh mi b">cat</code>或<code class="fe mf mg mh mi b">dog</code>。</p><p id="74af" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们有一个<code class="fe mf mg mh mi b">UIImage</code>和<code class="fe mf mg mh mi b">Label</code>的查找字典，称为<code class="fe mf mg mh mi b">imageLabelDictionary</code>。如果我们想要将图像添加到训练输入，我们在字典中设置图像和预测输出(猫/狗)的逆。</p><p id="3450" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们从<code class="fe mf mg mh mi b">imageLabelDictionary</code>中创建一个批处理提供者。</p><h2 id="c2ea" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">创建批处理提供程序</h2><p id="4e30" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated">我们的批处理提供者从需要<code class="fe mf mg mh mi b">image</code>作为<code class="fe mf mg mh mi b">CVPixelBuffer</code>和<code class="fe mf mg mh mi b">classLabel</code>作为猫或狗的<code class="fe mf mg mh mi b">TrainingInput</code>实例中创建了一个<code class="fe mf mg mh mi b">MLArrayBatchProvider</code>。</p><pre class="kk kl km kn gu oi mi oj ok aw ol bi"><span id="58c2" class="nw mw iu mi b gz om on l oo op">private func batchProvider() -&gt; MLArrayBatchProvider<br/>    {</span><span id="e9d1" class="nw mw iu mi b gz oq on l oo op">var batchInputs: [MLFeatureProvider] = []<br/>        let imageOptions: [MLFeatureValue.ImageOption: Any] = [<br/>          .cropAndScale: VNImageCropAndScaleOption.scaleFill.rawValue<br/>        ]<br/>        for (image,label) in imageLabelDictionary {<br/>            <br/>            do{<br/>                let featureValue = try MLFeatureValue(cgImage: image.cgImage!, constraint: imageConstraint, options: imageOptions)<br/>              <br/>                if let pixelBuffer = featureValue.imageBufferValue{<br/>                    let x = CatDogUpdatableTrainingInput(image: pixelBuffer, classLabel: label)<br/>                    batchInputs.append(x)<br/>                }<br/>            }<br/>            catch(let error){<br/>                print("error description is \(error.localizedDescription)")<br/>            }<br/>        }<br/>     return MLArrayBatchProvider(array: batchInputs)<br/>}</span></pre><p id="374b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">多亏了<code class="fe mf mg mh mi b">MLFeatureValue</code>，我们可以很容易地从<code class="fe mf mg mh mi b">featureValue</code>函数中检索到<code class="fe mf mg mh mi b">pixelBuffer</code>。</p><h2 id="9cf6" class="nw mw iu bd mx nx ny dn nb nz oa dp nf lj ob oc nh ln od oe nj lr of og nl oh bi translated">检索MLModel的URL</h2><p id="e9bd" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated">我们需要将模型URL传递给<code class="fe mf mg mh mi b">MLUpdateTask</code>。为此，我们需要从应用程序的文档目录中检索URL。我们需要使用<code class="fe mf mg mh mi b">FileManager</code>。</p><p id="2ff5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">代码很简单:</p><pre class="kk kl km kn gu oi mi oj ok aw ol bi"><span id="6450" class="nw mw iu mi b gz om on l oo op">let fileManager = FileManager.default</span><span id="4237" class="nw mw iu mi b gz oq on l oo op">let documentDirectory = try fileManager.url(for: .documentDirectory, in: .userDomainMask, appropriateFor:nil, create:true)</span><span id="83fc" class="nw mw iu mi b gz oq on l oo op">let modelURL = documentDirectory.appendingPathComponent("CatDog.mlmodelc")</span></pre><p id="68fb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们准备用新图像再次训练我们的模型。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="c2d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mf mg mh mi b">finalContext.model.write(to: fileURL)</code>覆盖文档目录中URL处的模型。这个核心ML模型被设置为只运行一个时期。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="14ad" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated"><strong class="ak">完整源代码</strong></h1><p id="4af4" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj ns ll lm ln nt lp lq lr nu lt lu lv in bi translated">核心的ML设备上培训到此结束。下面的完整源代码将上述所有概念合并到一个可行的iOS应用程序中。除此之外，模型和Python脚本也可以在<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/iOSCoreMLOnDeviceTraining" rel="noopener ugc nofollow" target="_blank"> GitHub仓库</a>中获得。</p><div class="ou ov gq gs ow ox"><a href="https://github.com/anupamchugh/iowncode/tree/master/iOSCoreMLOnDeviceTraining" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fp"><div class="oz ab pa cl cj pb"><h2 class="bd iv gz z fq pc fs ft pd fv fx it bi translated">anupamchugh/iowncode</h2><div class="pe l"><h3 class="bd b gz z fq pc fs ft pd fv fx dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pf l"><p class="bd b dl z fq pc fs ft pd fv fx dk translated">github.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl kt ox"/></div></div></a></div></div></div>    
</body>
</html>