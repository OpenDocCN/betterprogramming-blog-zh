<html>
<head>
<title>4 Useful Reactive Programming Implementation Styles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4种有用的反应式编程实现风格</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-useful-reactive-programming-implementations-5b17d6fe53d3?source=collection_archive---------0-----------------------#2021-06-20">https://betterprogramming.pub/4-useful-reactive-programming-implementations-5b17d6fe53d3?source=collection_archive---------0-----------------------#2021-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae26" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用RxJS和Angular构建web应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35aa03507b6c6750431fe0d27eff0723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ay9b3CtelTzpl3ZbhLYtgA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/users/coffeebeanworks-558718/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2017978" rel="noopener ugc nofollow" target="_blank">咖啡豆</a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2017978" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="1d7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇帖子是我之前关于RxJS操作符的<a class="ae ky" href="https://javascript.plainenglish.io/reactive-programming-using-rxjs-operators-6b803c0ed7de" rel="noopener ugc nofollow" target="_blank">帖子的后续。我将直接跳过在构建web应用程序中使用反应式编程的实际例子。</a></p><p id="9582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我所有的代码示例都使用RxJS和用TypeScript编写的Angular。每一部分都将以最终结果的GIF开始。</p><h1 id="bb67" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">按钮点击事件</h1><p id="5adc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我先举一个简单的例子。我们有一个按钮，当它被点击时会触发一个事件——这是web开发中的一个日常用例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b30146ce89c4f2824ef853e1314cebb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*qxsI3GfaH0ZMiL6oX8G0cw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的按钮点击示例。</p></figure><p id="ca01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发出事件的按钮将被视为具有事件流的可观察对象。让我们来看一个按钮，当它被点击时会打印到浏览器控制台。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="09f4" class="my lw it mu b gy mz na l nb nc">&lt;button id="mybutton"&gt;Click me&lt;/button&gt;</span></pre><p id="05cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将首先从按钮初始化一个可观察对象，我们可以为点击事件订阅它。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d564" class="my lw it mu b gy mz na l nb nc">const observableButton: rxjs.Observable = rxjs.fromEvent(document, 'click');</span></pre><p id="821d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为我们初始化的可观察对象订阅一个函数。该函数应该打印到web控制台。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="eac7" class="my lw it mu b gy mz na l nb nc">observableButton.subscribe(e =&gt; {console.log(e.type)});</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码示例。</p></figure><h1 id="0bf0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">来自文本输入更改的事件</h1><p id="ba3e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们以搜索输入字段为例。我们正在输入字段中键入文本。文本中的每个变化都会引发一个事件。我们的前端代码将在适当的时候调用一个搜索API，而不是在每次发生变更事件时调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4f6d26d75b07b346b17a08e563c81af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/1*fp_xy1XpSmQUsGkyNN3E5w.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输入作者更改截屏。</p></figure><p id="dabf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从接受搜索文本输入的HTML输入标签开始。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8b65" class="my lw it mu b gy mz na l nb nc">&lt;input type="text" [(ngModel)]="data" (ngModelChange)="inputChanged($event)" placeholder="Search" name="data"&gt;</span></pre><p id="d69e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们搜索文本的每一个变化都会触发<code class="fe ng nh ni mu b">inputChanged()</code>方法。</p><p id="4890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们将搜索主题观察者初始化为一个(适当命名的)<a class="ae ky" href="https://rxjs.dev/guide/subject" rel="noopener ugc nofollow" target="_blank"> RxJS主题</a>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f3bf" class="my lw it mu b gy mz na l nb nc">searchSubject$ = new Subject&lt;string&gt;();</span></pre><p id="6182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe ng nh ni mu b">inputChanged()</code>方法将打印到web控制台，并将事件对象发送给我们的搜索主题观察者。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9ea7" class="my lw it mu b gy mz na l nb nc">inputChanged($event) {<br/>    console.log("input changed: ", $event);<br/>    this.searchSubject$.next($event);  <br/>}</span></pre><p id="3db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在我们的观察器中使用<code class="fe ng nh ni mu b">debounceTime</code>,这样就不会在每次输入文本发生变化时触发我们的API调用函数。我们的API调用函数在输入事件流在指定时间内停止后被调用。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="66ca" class="my lw it mu b gy mz na l nb nc">ngOnInit() {<br/>    this.searchSubject$<br/>      .pipe(debounceTime(200))<br/>      // replace this with a search API call<br/>      .subscribe(x =&gt; console.log("call search API: ", x));<br/>}</span></pre><p id="ec9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试用StackBlitz中的代码示例。尝试移除<code class="fe ng nh ni mu b">debounceTime</code>并观察其表现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码示例。</p></figure><h1 id="ec67" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">REST API请求</h1><p id="674e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们通过查询Reddit搜索API来扩展我们之前的“来自文本输入更改的事件”示例。然后，我们的示例页面将显示从API中检索到的meme图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5b9668180df58dc55bc52db03659cfda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*HKr3uNPw5pSb-1-Ow4jgsw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截屏。</p></figure><p id="8878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了方便起见，我们通过添加一个清除按钮来扩展HTML代码。该按钮清除输入文本。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6a90" class="my lw it mu b gy mz na l nb nc">&lt;input<br/>  type="text"<br/>  [(ngModel)]="searchString"<br/>  (ngModelChange)="inputChanged($event)"<br/>  placeholder="Search"<br/>  name="searchString"<br/>/&gt;<br/>&lt;button (click)="searchString = ''"&gt;Clear&lt;/button&gt;</span></pre><p id="ace0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们现在将处理一个API请求，所以让我们使用Angular的HTTPClient。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="eae3" class="my lw it mu b gy mz na l nb nc">import { HttpClient } from '<a class="ae ky" href="http://twitter.com/angular/common" rel="noopener ugc nofollow" target="_blank">@angular/common</a>/http';</span></pre><p id="2022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并连接我们将调用Reddit API的方法。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="38b0" class="my lw it mu b gy mz na l nb nc">queryAPI(searchString) {<br/>    return this.http<br/>      .get(`<a class="ae ky" href="https://www.reddit.com/r/memes/search.json?q=${searchString}`" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/memes/search.json?q=${searchString}`</a>)<br/>      .pipe(map(result =&gt; result['data']['children']));<br/>}</span></pre><p id="7096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们现在将在页面上显示搜索结果，所以让我们初始化结果Observable。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="88b1" class="my lw it mu b gy mz na l nb nc">results$: Observable&lt;any&gt;;</span></pre><p id="a5c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们目前在<code class="fe ng nh ni mu b">searchSubject</code>中使用了两个新的操作符。<code class="fe ng nh ni mu b">distinctUntilChanged()</code>确保我们只在搜索主题发生变化时触发事件。而<code class="fe ng nh ni mu b">switchMap()</code>将“切换”到一个新的可观测值——这就是<code class="fe ng nh ni mu b">queryAPI</code>方法。在我之前关于反应式编程的<a class="ae ky" href="https://javascript.plainenglish.io/reactive-programming-using-rxjs-operators-6b803c0ed7de" rel="noopener ugc nofollow" target="_blank">帖子</a>中，我也用示例代码覆盖了switchMap。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="57eb" class="my lw it mu b gy mz na l nb nc">ngOnInit() {<br/>    this.results$ = this.searchSubject$.pipe(<br/>      debounceTime(200),<br/>      distinctUntilChanged(),<br/>      switchMap(searchString =&gt; this.queryAPI(searchString))<br/>    );<br/>}</span></pre><p id="462b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了结果可观察集，让我们在HTML代码中使用它来显示我们的API搜索结果。我们遍历API调用的响应，并显示每个结果元素的图像。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="eb85" class="my lw it mu b gy mz na l nb nc">&lt;div *ngFor="let result of results$ | async"&gt;<br/>  &lt;div<br/>    *ngIf="result.data.thumbnail != 'default' &amp;&amp; result.data.thumbnail != 'self'"<br/>  &gt;<br/>    &lt;a [href]="result.data.url"&gt;<br/>      &lt;img [src]="result.data.thumbnail" alt="" /&gt;<br/>    &lt;/a&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="f347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面的StackBlitz中找到完整的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码示例。</p></figure><h1 id="17d1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">移动响应网站布局</h1><p id="09c7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">observables的另一个优秀应用是在web应用程序中实现移动响应。例如，我们的网站为桌面视图显示两个垂直列，为移动视图显示两个水平行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b8597d78932ab3793ddf2269d45035e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*LisAzXnM7L6yTNUoGhxkKw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截屏。</p></figure><p id="b73c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从观察到的窗口大小变化开始。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b00f" class="my lw it mu b gy mz na l nb nc">resizeObservable$: Observable&lt;Event&gt;;</span></pre><p id="ea93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用RxJS的<code class="fe ng nh ni mu b">fromEvent</code>，我们可以监听窗口调整事件。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e207" class="my lw it mu b gy mz na l nb nc">this.resizeObservable$ = fromEvent(window, 'resize');</span></pre><p id="f3a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个resize Observable，让我们订阅它。一旦我们订阅了窗口调整大小事件流，我们现在就可以访问每个调整大小事件的窗口大小。在调整窗口大小时，我们将根据当前的窗口大小改变我们网站的布局。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="75a7" class="my lw it mu b gy mz na l nb nc">ngOnInit() {<br/>    this.resizeObservable$ = fromEvent(window, 'resize');<br/>    this.resizeSubscription$ = this.resizeObservable$.subscribe(e =&gt; {<br/>      if (window.innerWidth &lt;= 400) {<br/>        this.renderMobileView();<br/>      } else {<br/>        this.renderDesktopView();<br/>      }<br/>    });<br/>}</span></pre><p id="63ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的渲染移动和桌面方法将改变布尔值<code class="fe ng nh ni mu b">mobileView</code>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9920" class="my lw it mu b gy mz na l nb nc">renderMobileView() {<br/>    console.log('render mobile view');<br/>    this.mobileView = true;<br/>  }</span><span id="f8f2" class="my lw it mu b gy nk na l nb nc">renderDesktopView() {<br/>    console.log('render desktop view');<br/>    this.mobileView = false;<br/>}</span></pre><p id="81f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ng nh ni mu b">mobileView</code>布尔值，我们可以改变HTML元素的CSS类。更改CSS类意味着我们可以轻松地在移动和桌面视图之间切换。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="84d1" class="my lw it mu b gy mz na l nb nc">&lt;div class="container" [ngClass]="{<br/>  'mobile': mobileView,<br/>  'desktop': !mobileView}"&gt;<br/>  &lt;div class="col1"&gt;col1&lt;/div&gt;<br/>  &lt;div class="col2"&gt;col2&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="4fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">StackBlitz中提供了完整的示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码示例。</p></figure><p id="e096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这对您有所帮助，并且您可以在构建下一个web应用程序时应用它！</p><p id="1ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你可能也会喜欢:</p><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/9-useful-functional-programming-solutions-you-can-learn-with-typescript-and-node-2eab5ba097f0"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">您可以学习的9个有用的函数式编程解决方案(在TypeScript和Node中)</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">web开发人员易于理解的编码示例</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">better编程. pub</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ks no"/></div></div></a></div></div></div>    
</body>
</html>