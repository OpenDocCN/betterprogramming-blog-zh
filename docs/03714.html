<html>
<head>
<title>Sentiment Analysis on iOS Using SwiftUI, Natural Language, and Combine: Hacker News Top Stories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI、自然语言和Combine在iOS上进行情感分析:黑客新闻头条</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sentiment-analysis-on-ios-using-swift-natural-language-and-combine-hacker-news-top-stories-d1b8d8f4f798?source=collection_archive---------11-----------------------#2020-02-28">https://betterprogramming.pub/sentiment-analysis-on-ios-using-swift-natural-language-and-combine-hacker-news-top-stories-d1b8d8f4f798?source=collection_archive---------11-----------------------#2020-02-28</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="758e" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">利用苹果的反应式编程框架来处理异步任务，同时实时进行自然语言处理</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/7073deee98f2c71b70b7099e8670ce36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4d5sOjVozBE6pq8Df5vgA.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@goodgoodgood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">好的好的好的</a>在<a class="ae kw" href="https://unsplash.com/s/photos/news?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d5dc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让应用程序具有理解文本的自然语言的能力总是让我感到惊讶。苹果去年(2019年)在自然语言框架方面取得了一些重大进展。具体来说，引入内置的情感分析功能只能帮助构建更智能的基于NLP的iOS应用程序。</p><p id="ab9d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">除了对自然语言框架的改进，SwiftUI和Combine是WWDC 2019期间推出的两大亮点。</p><p id="c8f0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">SwiftUI是用Swift编写的声明式框架，帮助开发者快速构建用户界面。另一方面，Combine是苹果自己的反应式编程框架，旨在推动现代应用程序开发，尤其是在处理异步任务时。</p><h1 id="5376" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">我们的目标</h1><ul class=""><li id="bcb4" class="ml mm ir kz b la mn ld mo lg mp lk mq lo mr ls ms mt mu mv bi translated">我们将使用黑客新闻API，通过一个由Combine提供动力的URLSession来获取头条新闻。</li><li id="7906" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls ms mt mu mv bi translated">随后，我们将对每个故事的顶级评论运行自然语言的内置情感分析，以了解总体反应。</li><li id="5ae0" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls ms mt mu mv bi translated">在本教程中，我们将看到反应式编程如何使链接多个网络请求、转换并将结果传递给订户变得更加容易。</li></ul><blockquote class="nb nc nd"><p id="5e98" class="kx ky ne kz b la lb js lc ld le jv lf nf lh li lj ng ll lm ln nh lp lq lr ls ik bi translated">先决条件:对Combine框架有一个简单的概念会很有帮助。这里有一个<a class="ae kw" href="https://medium.com/better-programming/a-deep-dive-into-the-combine-framework-in-swift-cffdfcc6f32c" rel="noopener">片段</a>可以在Swift中使用Combine来启动。</p></blockquote><h1 id="be68" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">入门指南</h1><p id="7ec6" class="pw-post-body-paragraph kx ky ir kz b la mn js lc ld mo jv lf lg ni li lj lk nj lm ln lo nk lq lr ls ik bi translated">首先，让我们创建一个新的Xcode SwiftUI项目。我们将使用官方的<a class="ae kw" href="https://github.com/HackerNews/API" rel="noopener ugc nofollow" target="_blank">黑客新闻API </a>，它提供几乎实时的数据。</p><p id="a0a1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了创建一个包含黑客新闻头条的SwiftUI列表，我们需要设置我们的<code class="fe nl nm nn no b">ObservableObject</code>类。这个类负责从API获取故事，并将它们传递给SwiftUI列表。以下代码为您完成了这项工作:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="c2e5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">上面的代码中发生了很多事情。让我们来分解一下:</p><ul class=""><li id="db91" class="ml mm ir kz b la lb ld le lg nr lk ns lo nt ls ms mt mu mv bi translated"><code class="fe nl nm nn no b">fetchTopStories</code>负责返回故事的整数id数组。</li><li id="206b" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls ms mt mu mv bi translated">为了节省时间，我们将前10个故事标识符传递给<code class="fe nl nm nn no b">fetchStoryById</code>函数，在这里我们使用自定义发布者<code class="fe nl nm nn no b">FetchItem</code>获取黑客新闻故事，并合并结果。</li><li id="c179" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls ms mt mu mv bi translated">Combine的<code class="fe nl nm nn no b">collect()</code>操作符负责将从API获取的所有故事合并到一个数组中。</li></ul><p id="9fdd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">接下来让我们看看如何构建我们的自定义组合发布器。</p><h1 id="ea17" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">创建自定义联合发布器</h1><p id="6c4a" class="pw-post-body-paragraph kx ky ir kz b la mn js lc ld mo jv lf lg ni li lj lk nj lm ln lo nk lq lr ls ik bi translated">要创建一个定制的发布者，我们需要使结构符合<code class="fe nl nm nn no b">Publisher</code>协议，并设置流的<code class="fe nl nm nn no b">Output</code>和<code class="fe nl nm nn no b">Failure</code>类型，如下所示:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="np nq l"/></div></figure><ul class=""><li id="5d43" class="ml mm ir kz b la lb ld le lg nr lk ns lo nt ls ms mt mu mv bi translated">定义的<code class="fe nl nm nn no b">id</code>表示在初始化器中传递的故事标识符。</li><li id="5cdc" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls ms mt mu mv bi translated">实现<code class="fe nl nm nn no b">receive(subscriber:)</code>方法至关重要。它将发布者连接到订阅者，我们需要确保发布者的输出与订阅者的输入具有相同的类型。</li><li id="686b" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls ms mt mu mv bi translated">在<code class="fe nl nm nn no b">receive&lt;S&gt;(subscriber: S)</code>方法内部，我们正在发出另一个API请求。这一次，我们使用一个<code class="fe nl nm nn no b">StoryItem</code>模型获取故事并解码，定义如下:</li></ul><pre class="kh ki kj kk gu nu no nv nw aw nx bi"><span id="2bff" class="ny lu ir no b gz nz oa l ob oc">struct StoryItem : Identifiable, Codable {<br/>    let by: String<br/>    let id: Int<br/>    let kids: [Int]?<br/>    let title: String?</span><span id="9583" class="ny lu ir no b gz od oa l ob oc">private enum CodingKeys: String, CodingKey {<br/>            case by, id, kids, title<br/>        }<br/>}</span></pre><p id="d039" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后将<code class="fe nl nm nn no b">StoryItems</code>的数组发布到SwiftUI视图，以获取具有内置订阅者的。以下代码负责在SwiftUI列表中显示黑客新闻:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="d93a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nl nm nn no b">NavigationLink</code>负责将用户带到目的地屏幕，在那里显示注释。我们已经将我们的目的地视图—<code class="fe nl nm nn no b">CommentView</code>—包装在一个惰性视图中。这样做是为了只有当用户导航到目标视图时才加载该视图。这是 <code class="fe nl nm nn no b"><a class="ae kw" href="https://medium.com/better-programming/swiftui-navigation-links-and-the-common-pitfalls-faced-505cbfd8029b" rel="noopener">NavigationLink</a></code> <a class="ae kw" href="https://medium.com/better-programming/swiftui-navigation-links-and-the-common-pitfalls-faced-505cbfd8029b" rel="noopener"> s </a>中的<a class="ae kw" href="https://medium.com/better-programming/swiftui-navigation-links-and-the-common-pitfalls-faced-505cbfd8029b" rel="noopener">常见陷阱。</a></p><p id="5316" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在我们进入评论部分和后续的使用NLP的情感分析之前，让我们先来看看目前为止我们已经建立了什么:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oe"><img src="../Images/42de792f974009ef78da359298429d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uq9OYI4LpYaq9TPE73fRDA.gif"/></div></div></figure><h1 id="ad3c" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">获取黑客新闻评论并分析情感得分</h1><p id="5b45" class="pw-post-body-paragraph kx ky ir kz b la mn js lc ld mo jv lf lg ni li lj lk nj lm ln lo nk lq lr ls ik bi translated"><code class="fe nl nm nn no b">StoryItem</code>模型中的<code class="fe nl nm nn no b">kids</code>属性包含顶级注释的id。对于多个网络请求，我们将使用与前面类似的方法，使用组合发布者。</p><p id="8d7d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里的区别是包含了自然语言的内置情感分析，为每个评论给出一个情感分数，然后计算该故事的平均情感分数。</p><p id="981d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面的代码来自于<code class="fe nl nm nn no b">HNCommentFeed</code>类，它扩展了<code class="fe nl nm nn no b">ObservableObject</code>:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="faca" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一旦使用自定义发布器从API获取了<code class="fe nl nm nn no b">comments</code>属性，一旦我们计算了平均情感分数并将其设置在<code class="fe nl nm nn no b">sentimentAvg</code>属性上，就通过调用<code class="fe nl nm nn no b">didChange.send()</code>来手动发布该属性，该属性本身就是一个<code class="fe nl nm nn no b">@Published</code>属性包装器。</p><p id="0470" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在我们查看保存评论及其各自分数的SwiftUI视图之前，让我们先来看看定制的Combine publisher <code class="fe nl nm nn no b">FetchComment</code>，如下所示:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="fef7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">与之前的定制发布者非常相似，我们需要定义<code class="fe nl nm nn no b">Output</code>和<code class="fe nl nm nn no b">Failure</code>类型。除此之外，我们在<code class="fe nl nm nn no b">map</code>操作符中做了相当多的事情，将<code class="fe nl nm nn no b">CommentItem</code>转换成另一个新的实例，它也保存了情感分数。</p><p id="48ec" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们来看看那些重要的标有注释的。</p><ol class=""><li id="982c" class="ml mm ir kz b la lb ld le lg nr lk ns lo nt ls of mt mu mv bi translated">从<code class="fe nl nm nn no b">HNCommentFeed</code>中传递注释的<code class="fe nl nm nn no b">id</code>和<code class="fe nl nm nn no b">nlTagger</code>实例。<code class="fe nl nm nn no b">nlTagger</code>负责将文本分割成句子或段落单元，并处理各部分的信息。在我们的例子中，我们将它设置为处理<code class="fe nl nm nn no b">sentimentScore</code>，这是一个基于文本的正负程度在-1到1之间的浮点值。</li><li id="74a5" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls of mt mu mv bi translated">从<code class="fe nl nm nn no b">CommentItem</code>实例中的API请求返回的注释文本是一个HTML字符串。通过检索数据部分(使用<code class="fe nl nm nn no b">utf8</code>，我们将它转换成一个格式化的字符串，没有HTML转义字符。</li><li id="52d8" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls of mt mu mv bi translated">接下来，我们已经在<code class="fe nl nm nn no b">nlTagger’s</code> <code class="fe nl nm nn no b">string</code>属性上设置了格式化字符串。这个字符串由语言标记器分析。</li><li id="36c3" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls of mt mu mv bi translated">最后，我们创建了一个新的保存<code class="fe nl nm nn no b">sentimentScore</code>的<code class="fe nl nm nn no b">CommentItem</code>实例。这个结果被向下游传递给订户。</li></ol><p id="70ef" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面给出了保存注释及其分数的<code class="fe nl nm nn no b">CommentView</code> SwiftUI结构的代码:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="682b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们设置了一个SF符号(iOS 13中的新功能)作为导航栏按钮，其颜色代表该故事顶级评论的整体情绪。</p><p id="65bd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，我们在应用程序中得到以下输出:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj og"><img src="../Images/f9a584231d854131a52f61422ebd1d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/1*ZnuTLJdRiyR88EcFcNSB3A.gif"/></div></figure></div><div class="ab cl oh oi hv oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ik il im in io"><h1 id="45e2" class="lt lu ir bd lv lw oo ly lz ma op mc md jx oq jy mf ka or kb mh kd os ke mj mk bi translated">结论</h1><p id="2347" class="pw-post-body-paragraph kx ky ir kz b la mn js lc ld mo jv lf lg ni li lj lk nj lm ln lo nk lq lr ls ik bi translated">使用苹果内置的NLP情感评分，我们看到大多数头条新闻在黑客新闻上吸引了两极分化的观点。虽然许多评论都很模糊，这可能会导致情绪分析甚至是定制模型的准确性问题，但苹果的内置情绪分析做得很好。自然语言框架已经取得了一些良好的进展，WWDC 2020还有很多值得期待的地方。</p><p id="ed76" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们后退一步，看看我们在这篇文章中学到了什么。</p><p id="2d4c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们看到:</p><ul class=""><li id="eb70" class="ml mm ir kz b la lb ld le lg nr lk ns lo nt ls ms mt mu mv bi translated">Combine框架如何使用URLSession轻松处理多个网络请求。我们设法链接请求，设置依赖API请求，并通过避免可怕的回调地狱来同步API结果。</li><li id="5f24" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls ms mt mu mv bi translated">如何创建自定义发布者并确保发布者和订阅者之间的契约得到维护(访问<code class="fe nl nm nn no b">receive</code>方法中的where子句)。</li><li id="f9b4" class="ml mm ir kz b la mw ld mx lg my lk mz lo na ls ms mt mu mv bi translated">如何使用组合运算符为我们带来优势？我们通过在Combine操作符中执行自然语言处理，成功地转换了一堆评论，添加了一个额外的属性——情感分数。</li></ul><p id="56fd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">接下来，您可以通过添加无限滚动功能来扩展上述实现。这给你所有的顶级黑客新闻故事。这里有一个在基于SwiftUI的应用程序中实现无限滚动的好参考。</p><p id="ea2a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">上述应用程序的完整源代码可以在这个<a class="ae kw" href="https://github.com/anupamchugh/iowncode/tree/master/SwiftUIHNSentiments" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><p id="7673" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这一个到此为止。感谢您的阅读，我希望您喜欢Combine和自然语言框架的结合。</p></div></div>    
</body>
</html>