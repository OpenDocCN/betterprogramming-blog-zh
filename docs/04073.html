<html>
<head>
<title>How to Write a Discord Bot in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Rust中编写不和谐机器人</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-a-discord-bot-in-rust-2d0e50869f64?source=collection_archive---------2-----------------------#2020-03-22">https://betterprogramming.pub/writing-a-discord-bot-in-rust-2d0e50869f64?source=collection_archive---------2-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6e9a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">机器人是不和的命脉，所以让我们写一个我们自己的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49634ba5b225b3d10786997344977f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5YVAyCRREKgv8Euq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不和谐机器人是许多社区的生命线| <a class="ae ky" href="https://www.wibidata.com/storage/2019/03/Discord-Bots-696x348.png" rel="noopener ugc nofollow" target="_blank">不和谐机器人</a>由<a class="ae ky" href="https://www.wibidata.com/writer/stereomax12/" rel="noopener ugc nofollow" target="_blank">立体声玛克辛</a></p></figure><p id="fc77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很多圈子里，不和已经成为一种相当普遍的交流方式。例如，在游戏中，玩家为了与他人交流而不和是许多游戏的要求<em class="lv"> </em>。随着这种流行，人们也越来越渴望创建扩展程序来增强用户体验。这就是机器人发挥作用的地方。</p><p id="553e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Rust中编写一个不和谐机器人主要是关于抽象。Rust是这样一种语言，在这种语言中，您可以选择项目的抽象级别，同时对性能的影响最小。对于我们的目的来说，这是一个非常有用的特性，因为Discord应用程序编程接口(或API)往往非常简单，并且会使以可理解的方式编程变得非常困难。</p><p id="6077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们来说幸运的是，也有一些了不起的人花了相当多的时间来创建库，使我们可以做出设计选择，而除了组件如何交互之外，根本不用担心它的内部工作，在我看来，这是标准的做法。</p><p id="d23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个这样的库是<a class="ae ky" href="https://github.com/serenity-rs/serenity" rel="noopener ugc nofollow" target="_blank"> Serenity </a>，它抽象出我们不需要担心的东西，同时保持我们的选项可用。它包含了Discord API，而且大部分功能都很完整，有语音支持和所有的功能。</p><p id="ddf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Serenity是一个全方位的神奇图书馆，但它也有缺点，就像所有东西一样。这个库最大的，也是唯一的缺点是它把多线程留给了库的用户。这不是一个交易断路器的使用；对于利用Rust的异步特性来说，这只是一个小小的抱怨，但是对于一些人来说，我认为这是一个很大的损失。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6fd0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">入门指南</h1><p id="a428" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">与任何项目一样，首要任务是实际创建项目。因此，在我们开始研究代码之前，继续进行您的项目。你想怎么命名都行，因为这并不重要。我的名字叫做“examplebot ”,因为我不想想出一个更好的名字。</p><p id="5680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，我将在GitHub上主持这个项目。代码是免费的，你可以随意使用，我会为这个项目更新它。</p><p id="3c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经创建了项目，我们需要做的第一件事就是添加我们的依赖项，即<code class="fe na nb nc nd b">serenity</code>。为此，我们将进入我们的<code class="fe na nb nc nd b">Cargo.toml</code>，并在<code class="fe na nb nc nd b">[dependencies]</code>条目下添加以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ab46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将Serenity crate作为依赖项添加到您的项目中。现在，我们可以开始初始化一个基本的机器人。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9f28" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">放弃</h1><p id="7a03" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这篇文章本质上是对Serenity library的认可，尽管它不一定是有意的。Serenity不是唯一一个用Rust编写的Discord API包装器，但它是我见过的最先进的。</p><p id="6bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文还假设读者对Rust语言有一定程度的熟悉。如果你还没有完全做到，或者你是一个寻找有趣的第一个项目的初学者，我将很快为这个特定的主题写一篇文章。当我这样做的时候，我会更新这篇文章的链接。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="78d9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">乒乓机器人</h1><p id="b557" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这是许多指南开始和结束的地方。他们向你展示如何用他们兜售的框架和语言建立一个基本的机器人，他们通常不会走得更远。我们将更进一步，查看宁静图书馆的细节。</p><p id="3532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们应该建立客户端。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们打开刚才做的东西。</p><p id="d25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b"><strong class="lb iu">use</strong></code> <strong class="lb iu">语句</strong> —文件顶部的<code class="fe na nb nc nd b">use</code>语句从<code class="fe na nb nc nd b">serenity</code>箱中导入我们需要的所有东西。<code class="fe na nb nc nd b">prelude</code>模块包含Serenity的面向公众的导出，如<code class="fe na nb nc nd b">Context</code>结构，<code class="fe na nb nc nd b">model::prelude</code>包含API调度的映射对象，如<code class="fe na nb nc nd b">Message</code> s。</p><p id="c34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"/><code class="fe na nb nc nd b"><strong class="lb iu">Handler</strong></code><strong class="lb iu"/>—<code class="fe na nb nc nd b">Handler</code>结构是一个没有字段的单元结构，只实现来自<code class="fe na nb nc nd b">prelude</code>模块的<code class="fe na nb nc nd b">EventHandler</code>特征。在<code class="fe na nb nc nd b">message</code>方法中，宏<code class="fe na nb nc nd b">unimplemented!()</code>告诉程序在调用该方法时死机，因为它没有被实现。当我们在ping bot中使用这个方法时，我们将删除它。</p><p id="ef52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"/><code class="fe na nb nc nd b"><strong class="lb iu">main</strong></code><strong class="lb iu">函数</strong> — <strong class="lb iu"> </strong>在我们的主函数中，我们创建了一个<code class="fe na nb nc nd b">Client</code>的新实例。这里使用的<code class="fe na nb nc nd b">.expect()</code>方法调用告诉我们创建是否以及何时失败并返回一个<code class="fe na nb nc nd b">Result</code>。</p><p id="a1f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端初始化已经完成，让我们创建一个配置模块。该模块将保存与应用程序配置相关的数据和逻辑。为了节省时间，我们姑且称之为<code class="fe na nb nc nd b">config</code>。现在，我们创建几个常量来保存程序的重要数据，比如我们的bot帐户需要的Discord API令牌，或者我们要为将要创建的命令使用的前缀。</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="1bd5" class="nk me it nd b gy nl nm l nn no">//in src/config.rs<br/>pub const TOKEN: &amp;'static str = "TOKEN HERE";<br/>pub const PREFIX: &amp;'static str = "PREFIX HERE";</span></pre><p id="c671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用<code class="fe na nb nc nd b">ron</code>的力量将我们的配置序列化为Rusty Object Notation，因为在我看来，它比JSON或YAML更好。为了能够使用<code class="fe na nb nc nd b">ron</code>，我们必须将板条箱添加到我们的依赖项中，如下所示:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="213d" class="nk me it nd b gy nl nm l nn no">[dependencies]<br/>ron = "0.5.1"</span></pre><p id="cb6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们在依赖项中有了它，我们将在<code class="fe na nb nc nd b">src/main.rs</code>中将其声明为<code class="fe na nb nc nd b">extern crate</code>。一旦我们完成了这些，我们将开始在<code class="fe na nb nc nd b">config</code>模块中创建一个<code class="fe na nb nc nd b">save</code>函数，但是在此之前，让我们想想我们到底需要做什么。</p><p id="5665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要这个函数将私有模块中的数据加载到一个<code class="fe na nb nc nd b">Config</code>结构中。我们需要这个函数来序列化该结构，并将序列化后的数据输出到一个文件中，当我们需要时，可以用另一个函数加载该文件。</p><p id="6728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住所有这些，让我们将以下内容添加到我们的<code class="fe na nb nc nd b">config</code>模块中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="305b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数正是我们需要它做的。它序列化我们的结构并根据我们的喜好格式化它，然后它将数据写入一个名为<code class="fe na nb nc nd b">config.ron</code>的文件；太完美了。</p><p id="c31c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个<code class="fe na nb nc nd b">save</code>函数，我们需要一个<code class="fe na nb nc nd b">load</code>函数来反序列化配置文件并初始化我们应用程序的设置。这是一个相当简单的任务，可以用几种不同的方法来完成，但是我们将选择最简单的方法。我们将以类似于使用<code class="fe na nb nc nd b">save</code>函数的方式使用<code class="fe na nb nc nd b">std::fs::File</code>结构。</p><p id="cae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe na nb nc nd b">save</code>功能下面开始，添加一个名为<code class="fe na nb nc nd b">load</code>的新<code class="fe na nb nc nd b">pub fn</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="da5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这里到底发生了什么。首先，我们从<code class="fe na nb nc nd b">ron</code>机箱中导入了<code class="fe na nb nc nd b">de</code>模块。这允许我们将来呼叫<code class="fe na nb nc nd b">de::from_reader</code>。然后我们声明了一个类型为<code class="fe na nb nc nd b">std::io::Result&lt;Config&gt;</code>的<code class="fe na nb nc nd b">pub fn</code>。你可能会问，当我们可以直接返回配置实例时，为什么我们要返回结果？因为错误。</p><p id="74f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举允许简洁的错误处理。通过返回<code class="fe na nb nc nd b">Ok(config)</code>，我们告诉编译器一切按计划进行。现在，如果我们返回了<code class="fe na nb nc nd b">Err(config)</code>,这将告诉编译器出错了。这叫做软恐慌。这对你的程序来说不是致命的；这是一个可恢复的错误，因为锈书提到他们。可恢复的错误可以在一个<code class="fe na nb nc nd b">match</code>或<code class="fe na nb nc nd b">if let</code>语句中处理，这就是我们在项目后面要做的。</p><p id="4164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经设置好了<code class="fe na nb nc nd b">config</code>模块，让我们看看它整体应该是什么样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ea6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经回顾了我们在配置模块中的工作，让我们再次看看根模块，<code class="fe na nb nc nd b">src/main.rs</code>。</p><p id="f955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以利用在<code class="fe na nb nc nd b">config</code>模块中声明的<code class="fe na nb nc nd b">Config</code>结构将数据传递给客户端初始化。为此，我们必须首先创建一个新的结构实例(<code class="fe na nb nc nd b">Config::new()</code>)，然后，如果文件还不存在，<code class="fe na nb nc nd b">save</code>配置。如果文件已经存在，那么我们设置调用<code class="fe na nb nc nd b">Config::load()</code>。</p><p id="3bea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编辑<code class="fe na nb nc nd b">main</code>函数并添加一个变量来保存<code class="fe na nb nc nd b">Config</code>实例。在函数的顶部，添加<code class="fe na nb nc nd b">let config = Config::new();</code>。这创建了一个新的<code class="fe na nb nc nd b">Config</code>结构实例，所以我们可以将<code class="fe na nb nc nd b">Config</code>T21到一个文件，或者，如果文件存在，我们可以<code class="fe na nb nc nd b">load</code>它。这可能是你需要使用某种<code class="fe na nb nc nd b">match</code>或<code class="fe na nb nc nd b">if let</code>语句来完成的地方，这取决于文件是否存在。这是可选的，但出于我们的目的，我们将省略它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="99bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经启动并运行了我们的<code class="fe na nb nc nd b">Config</code>。既然我们这样做了，我们将使用<code class="fe na nb nc nd b">serenity</code>提供的<code class="fe na nb nc nd b">command</code>框架来实现我们的机器人的<code class="fe na nb nc nd b">ping</code>功能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="80f9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">实现Pings和Pongs</h1><p id="fb9d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以通过实现来自<code class="fe na nb nc nd b">EventHandler</code>特征的<code class="fe na nb nc nd b">message</code>方法来实现一个基本的ping程序。</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="a371" class="nk me it nd b gy nl nm l nn no">impl EventHandler for Handler {<br/>  fn message(&amp;self, context: Context, msg: Message) {<br/>    if msg.content == "!ping" {<br/>      if let Err(why) = msg.channel_id.say(&amp;context.http, "Pong!") {<br/>        println!("Error sending message: {}", why);<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="823b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码片段可以让包含<code class="fe na nb nc nd b">!ping</code>的消息触发来自机器人的消息，说“Pong！”很简单，但这不是我们在这个项目中要做的。</p><p id="4e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe na nb nc nd b">EventHandler</code>特性处理命令的问题是，它不是特别具有可伸缩性。想象一下，有数百条命令都要通过一条庞大的<code class="fe na nb nc nd b">match</code>语句来检查。对于负责维护它的可怜的开发人员来说，那将是地狱，更不用说对于最初编写它的人了。</p><p id="f367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如果我们不想手动处理我们的命令，我们能做什么呢？嗯，<code class="fe na nb nc nd b">serenity</code>恰好提供了一个不错的命令框架。该库有一个导出的程序宏(属性),它带来了许多实用工具，除了为命令编写代码之外，我们实际上不必做任何事情。</p><h2 id="9632" class="nk me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">命令</h2><p id="33c8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">创建命令主要涉及使用<code class="fe na nb nc nd b">Context</code>类型。不需要太多的努力，因为这实际上取决于您希望您的命令如何呈现给最终用户。</p><p id="a6ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当编写我们的第一个命令时，有几件事情我们需要考虑:这个命令将在什么样的上下文中使用，以及我们希望用户如何能够与它交互。</p><p id="fad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，使用我们的ping命令，我们并不真的需要用户与之交互，我们也不真的需要担心调用它的上下文。我们所需要做的就是当用户发送符合我们标准的消息时，用一个设置好的消息进行回复。</p><p id="b10a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这段代码为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数有两个参数:一个类型为<code class="fe na nb nc nd b">Context</code>的可变引用和一个<code class="fe na nb nc nd b">Message</code>。它返回一个<code class="fe na nb nc nd b">CommandResult</code>。这两个参数是自动填充的，我们永远不用担心手动调用这个函数，因为它由库来处理。</p><p id="1bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们拥有的ping命令与我们之前在<code class="fe na nb nc nd b">EventHandler</code>中编写的命令相同，但是它有一些关键的不同。最主要的一点是，它是在自己的函数中声明的，这样更容易维护。然后，还有对<code class="fe na nb nc nd b">CommandResult</code>的使用，<code class="fe na nb nc nd b">serenity</code>使用它在内部处理错误。</p><p id="20ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个命令也被设置为一个组的一部分，我们可以在一个没有字段的类似单元的结构上用<code class="fe na nb nc nd b">group</code>属性来设置。</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="5edd" class="nk me it nd b gy nl nm l nn no">#[group]<br/>#[commands(ping)]<br/>struct Public;</span></pre><p id="bc8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就创建了一个名为<code class="fe na nb nc nd b">Public</code>的组，其中包含了<code class="fe na nb nc nd b">ping</code>命令。</p><p id="1daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在<code class="fe na nb nc nd b">src/main.rs</code>中，我们将添加一个框架配置。</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="5da5" class="nk me it nd b gy nl nm l nn no">client.with_framework(StandardFramework::new()<br/>    .configure(|c |<br/>      c.prefix(config.prefix()))<br/>    .group(&amp;PUBLIC_GROUP));</span></pre><p id="0508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将标准的<code class="fe na nb nc nd b">serenity</code>框架添加到客户机实例中，它还会配置前缀并将命令组添加到实例中。</p><p id="6d33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住所有这些片段，我们的<a class="ae ky" href="https://gist.github.com/Jakender/72b058b7c63303c0b7c84716de7685d6" rel="noopener ugc nofollow" target="_blank">项目应该看起来像这样</a>。</p><p id="d714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在有了一个用Rust编写的功能不和谐的机器人，它响应一个<code class="fe na nb nc nd b">ping</code>命令。这一切都很好，但是在这个故事结束之前，我还想提到一件事:<strong class="lb iu">嵌入。</strong></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b9ce" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">嵌入宁静中</h1><p id="8b98" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在<code class="fe na nb nc nd b">serenity</code>中嵌入是相当容易创建的。您可以利用<code class="fe na nb nc nd b">send_message</code>方法并创建一个嵌入作为参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将向接收命令的通道发送消息。在邮件中，创建一个嵌入并应用于该邮件。这是一种快速简单的方式来构建您想要的嵌入，并且您可以创建更多的字段，如<code class="fe na nb nc nd b">footer</code>。在我们的示例中，我们可以通过向embed方法参数添加一个<code class="fe na nb nc nd b">e.footer()</code>来向embed添加一个页脚。</p><p id="8bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在函数中利用这一点。尝试将此添加到您的<code class="fe na nb nc nd b">src/commands.rs</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="8eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你有了这些你以前(完全)没有的知识，出去为你的Discord服务器做一些精彩的东西，或者，如果你想，和你的朋友们一起为一个群DM做一些，看看你能从中得到什么乐趣！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="61d3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><p id="171b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/serenity-rs/serenity" rel="noopener ugc nofollow" target="_blank">Serenity</a>:Serenity库的GitHub源代码库</p><p id="cb08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.rs/serenity/0.8.0/serenity/" rel="noopener ugc nofollow" target="_blank">文档</a>:Serenity库的源代码文档</p><p id="b9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用Serenity用Rust编写的例子Discord bot</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="3528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，祝您度过美好的一天！</p></div></div>    
</body>
</html>