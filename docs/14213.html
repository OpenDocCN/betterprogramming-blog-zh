<html>
<head>
<title>How To Implement Retries Without Cluttering Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不弄乱代码的情况下实现重试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-retries-without-cluttering-your-code-10dd7b51f11c?source=collection_archive---------5-----------------------#2022-11-17">https://betterprogramming.pub/how-to-implement-retries-without-cluttering-your-code-10dd7b51f11c?source=collection_archive---------5-----------------------#2022-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6d9a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">派对鹦鹉来救援了！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bad2cc5f67ee5fdd55c7adab96aaeea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6bQ1WCLqWM5ob_cF8As9g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://chrome.google.com/webstore/detail/universal-party-parrot/bjlicnjijlfodoekhjpnagodmcppabmc" rel="noopener ugc nofollow" target="_blank">分机</a></p></figure><p id="7341" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名软件工程师，我在生产行业工作多年，学到了一个重要的经验:</p><blockquote class="ls"><p id="47c5" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">有些事情第一次尝试就不行。</p></blockquote><p id="2d11" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">我接触和工作过的现实世界的硬件和对应的驱动总是有一些diva的做作。</p><ul class=""><li id="3ed3" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated">一些硬件有时会断开连接。</li><li id="9370" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">当命令一个接一个执行得太快时，一些驱动程序会抛出异常。</li><li id="c61b" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">有些传感器根本不回应你的命令。也许在第三次尝试之后。</li></ul><blockquote class="ls"><p id="8212" class="lt lu iq bd lv lw mv mw mx my mz lr dk translated">世界并不完美；每个人都会犯错。大多数时候，硬件和驱动程序并不像你想象的那样工作。</p></blockquote><p id="a79a" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">如果根本原因无法解决，避免这些不规则影响的常见解决方案是为您的操作引入重试逻辑。这通常类似于以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="66b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一段很棒的代码！它很容易阅读，每个瞥见它的人都知道这是一些重试逻辑。他们甚至可以调整允许的重试次数，而无需深入研究代码——这也是可维护的！</p><p id="925b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是随着代码库的增长，您会发现解决方案中到处都是这种结构。更糟糕的是:总是有点不同。</p><ul class=""><li id="1fcd" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated">大多数时候，变量名是不同的</li><li id="c6c7" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">有时设置最大尝试次数，有时设置最大重试次数。</li><li id="5493" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">有些类对异常进行重试，有些对特定结果进行重试，有些对两者都进行重试。</li></ul><p id="29e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些重复会导致混乱，从而产生错误。</p><blockquote class="nc nd ne"><p id="5f0c" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">不要重复自己！</p></blockquote><p id="432d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，一个聪明的团队会注意到这个缺陷，并试图消除它。让我们提取重试逻辑，以便可以重用它！这些年来，我看到了几种解决方案:</p><ul class=""><li id="dbce" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated">类似<code class="fe nj nk nl nm b">IRetryService.Retry(...)</code>的重试专用服务</li><li id="990c" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">关于<code class="fe nj nk nl nm b">Action</code>或<code class="fe nj nk nl nm b">Func</code>的扩展方法</li></ul><p id="7dd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些解决方案大部分时间都有效。但是他们做了很多工作！尤其是如果您希望同时支持同步和异步操作的重试。尽管如此，几乎每个更大的项目都包含一些这样的功能。</p><h1 id="8fdc" class="nn no iq bd np nq nr ns nt nu nv nw nx jw ny jx nz jz oa ka ob kc oc kd od oe bi translated">派对鹦鹉来救援了！</h1><p id="b28d" class="pw-post-body-paragraph kw kx iq ky b kz of jr lb lc og ju le lf oh lh li lj oi ll lm ln oj lp lq lr ij bi translated">这个问题已经有了一个很好的解决方案！你可以使用库Polly，<a class="ae kv" href="https://github.com/App-vNext/Polly" rel="noopener ugc nofollow" target="_blank"> </a>来整理你的代码。这个图书馆的图标是一只彩色的鹦鹉。这就是为什么我不能停止制造糟糕的派对鹦鹉笑话——派对或者死亡！</p><blockquote class="nc nd ne"><p id="166f" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">不要多此一举！</p></blockquote><p id="61e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是Polly就位时上面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a137" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码少得多。在这个例子中，只有五行代码。而且还是清晰精准的。这是我们已经实现的巨大优势！</p><p id="c12a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">越来越好了。你还记得我说过硬件有时会表现得很奇怪吗？我曾经遇到过一个传感器有时会返回<code class="fe nj nk nl nm b">double.NaN</code>。如果有，你只需要让它休息几秒钟，然后安排一次重试。</p><p id="2c3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">波利也能做到这一点。下面是我如何额外处理无效结果，并在每次重试之间引入一个等待时间:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7bec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来关注一下使用Polly进行重试的优势:</p><ul class=""><li id="8ee4" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated">伟大的API:简短、精确、易读。</li><li id="1c5d" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">Polly被广泛使用和测试。不要重新发明一个错误的解决方案。</li><li id="2845" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">您可以通过在类之间共享公共策略来重用它们。</li></ul><p id="2395" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想再次强调API。考虑下面的方法:<code class="fe nj nk nl nm b">public double DoSomethingCool(CancellationToken token).</code>我喜欢它需要一个<code class="fe nj nk nl nm b">CancellationToken</code>。</p><p id="94e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么？因为这个方法的任何用户，每个客户端，都知道它支持取消！更好的是:这种方法的每个用户都可以决定如何处理取消。他们可以超时取消，当用户点击某个中止按钮时取消，或者按他们想要的方式取消。</p><blockquote class="nc nd ne"><p id="de5f" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">一个优秀的API会迫使用户正确使用它。</p></blockquote><p id="0fab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将同样的想法用于Polly的重试逻辑。看下面更新后的方法原型:<code class="fe nj nk nl nm b">public double DoSomethingCool(ISyncPolicy policy, CancellationToken token)</code>。</p><p id="906d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢！这个方法似乎支持取消和执行策略——我只需看看原型就知道了。</p><p id="9c79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想怎么叫都行！也许对异常重试五次？也许在<code class="fe nj nk nl nm b">double.NaN</code>上重试三次，最多超时两秒？这取决于您的客户——无论他们做出什么决定，您的方法都会支持它。感谢Polly和伟大的API设计！</p><p id="f2d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一定要看看Polly的自述文件<a class="ae kv" href="https://github.com/App-vNext/Polly" rel="noopener ugc nofollow" target="_blank">,因为它可以做得更多:</a></p><ul class=""><li id="b396" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated">限速的</li><li id="c21c" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">超时设定</li><li id="1aba" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">贮藏</li></ul><p id="4770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>