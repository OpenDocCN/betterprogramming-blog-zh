<html>
<head>
<title>Six (or So) Flavors of Dependency Injection in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中依赖注入的六种风格</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/six-or-so-flavors-of-dependency-injection-in-swift-cd3d72651662?source=collection_archive---------0-----------------------#2021-10-09">https://betterprogramming.pub/six-or-so-flavors-of-dependency-injection-in-swift-cd3d72651662?source=collection_archive---------0-----------------------#2021-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="742d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">依赖注入是每个程序员首先应该学习的技术之一。让我们看看它在Swift中是如何工作的(也许还有为什么)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c9bfc754a4572fda41cf9b4dc8d0005c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lEst1m6Bs8KaM96x"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@matthewhenry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马太·亨利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="688d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我遇到过的一个程序员新手曾经对我说(深深沉思):我以为类越大越好……你知道，这样它就能做更多的事情！</p><p id="fab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间久了，新手变得有经验了，大威武班也就失去了吸引力。程序员开始意识到，他们需要一次又一次地返回到相同的代码，为了保持代码维护的有效性，代码应该是可测试的和易于理解的。这就是<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>派上用场的地方。</p><p id="f61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:这个帖子不被认为是高级的，更适合初级到中级的程序员。然而，即使你是一个经验丰富的工程师，温习基础知识总是有用的。特别是因为我喜欢在我的博客文章中更深入地讨论主要焦点，并且也涉及有用的配套技术。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b655" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动机</h1><p id="28a1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该技术的主要原则是识别一个类的额外职责，该职责可以被提取出来并安装到另一个类上(<a class="ae ky" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>)。</p><p id="e8dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它是如何发生的。假设我们有这样的东西:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d0fb" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">import</strong> UIKit</span><span id="26bd" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> SomeViewController: UIViewController {</span><span id="3417" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">override</strong> <strong class="na iu">func</strong> viewDidLoad() {<br/>    <strong class="na iu">super.viewDidLoad()</strong><br/>    positionView(view)<br/>  }</span><span id="5801" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">private</strong> <strong class="na iu">func</strong> positionView(_ view: UIView) {<br/>    <em class="nk">// ...<br/>  </em>}</span><span id="efaf" class="ne md it na b gy nj ng l nh ni">}</span></pre><p id="30de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一小段无害的代码。还是没有？嗯，我们有一个隐藏在类的实现细节深处的逻辑。即使现在也很难测试它，如果可能的话。但是简单的重构可以使逻辑易于测试，也便于以后的维护。为了实现这一点，我们需要:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c100" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> PositionCalculator {<br/>  <strong class="na iu">func</strong> getPositionOfView(<br/>    _ view: UIView, in viewController: UIViewController<br/>  ) -&gt; CGRect {<br/>    <strong class="na iu">var</strong> rect = CGRect()<br/>    <em class="nk">// ...</em></span><span id="4ab0" class="ne md it na b gy nj ng l nh ni">    <strong class="na iu">return</strong> rect<br/>  }<br/>}</span></pre><p id="c501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此这个逻辑处理程序的客户端可以从这个外部对象接收位置:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7c6c" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">private</strong> <strong class="na iu">func</strong> positionView(_ view: UIView) {<br/>  view.frame = PositionCalculator().getPositionOfView(view,<br/>                                                      in: self)<br/>}</span></pre><p id="0738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一场胜利？不完全是。尽管位置计算现在可以独立于其客户端进行测试和维护，但是客户端本身与其依赖关系是紧密耦合的。如果<code class="fe nl nm nn na b">PositionCalculator</code>改变了它的依赖关系和初始化过程怎么办？<code class="fe nl nm nn na b">SomeViewController</code>也需要更新，也许是以某种复杂的方式。为了避免这种情况，我们可以从外部传递<code class="fe nl nm nn na b">PositionCalculator</code>，让<code class="fe nl nm nn na b">SomeViewController</code>直接使用它。一般的技术被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank">控制反转</a>。依赖注入是实现它的方法之一。</p><p id="4110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中注入依赖关系有多种方式。让我们一次看一个。</p><h1 id="d727" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">1.财产</h1><p id="bae5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于可选的依赖项，此选项很方便。Delegate是iOS世界的一个典型例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6181" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> SomeViewController: UIViewController {<br/>  <strong class="na iu">weak</strong> <strong class="na iu">var</strong> delegate: SomeViewControllerDelegate?<br/>}</span></pre><p id="74b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖关系可以在其客户端生命周期的任何时刻注入:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c495" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">let</strong> vc = SomeViewController()<br/>vc.delegate = someDelegate</span></pre><p id="35d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，这不是我们的选择。在最初的例子中，我们希望<code class="fe nl nm nn na b">PositionCalculator</code>始终可用，因为它对于<code class="fe nl nm nn na b">SomeViewController</code>的运行至关重要。</p><h1 id="2739" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">2.作曲者</h1><p id="4ed3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于客户端在注入依赖项之前就已经存在的情况，尽管它只是在注入之后才开始工作，但是这个选项非常方便。从那一刻起，我们不希望依赖消失。<a class="ae ky" href="https://medium.com/swlh/my-journey-on-the-ui-design-patterns-in-ios-universe-9ded70ac1b3b" rel="noopener">模型-视图-展示者UI设计模式</a>可能是一个很好的例子。你身边有一个演示者，然后在某个时候你给演示者设置一个视图，后者开始真正的工作:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a946" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> SomePresenter {</span><span id="cf10" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">private</strong> <strong class="na iu">var</strong> view: SomeViewController? {<br/>    <strong class="na iu">didSet</strong> {<br/>      <strong class="na iu">guard</strong> <strong class="na iu">let</strong> view = view <strong class="na iu">else</strong> {<br/>        <strong class="na iu">return</strong><br/>      }<br/>      presentView(view)<br/>    }<br/>  }</span><span id="3679" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">func</strong> setView(_ view: SomeViewController) {<br/>    <strong class="na iu">self</strong>.view = view<br/>  }</span><span id="bce4" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">private</strong> <strong class="na iu">func</strong> presentView(_ view: SomeViewController) {<br/>    <em class="nk">// ...<br/>  </em>}</span><span id="9f92" class="ne md it na b gy nj ng l nh ni">}</span></pre><p id="5ca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通话地点:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a165" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">let</strong> presenter = SomePresenter()</span><span id="8658" class="ne md it na b gy nj ng l nh ni"><em class="nk">// ...</em></span><span id="f515" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">let</strong> view = SomeViewController()<br/>presenter.setView(view)<br/>// After this presenter start its engine and never stops!</span></pre><h2 id="b899" class="ne md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">2a。连接</h2><p id="29d3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时这被称为界面注入。更好的是:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8851" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">protocol</strong> SomePresenter {<br/>  <strong class="na iu">func</strong> setView(_ view: SomeViewController)<br/>}</span></pre><p id="748c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者甚至像这样，把某种可注射的东西的意图协议化:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0a6b" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">protocol</strong> SomeViewControllerSettable {<br/>  <strong class="na iu">func</strong> setView(_ view: SomeViewController)<br/>}</span><span id="26c3" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">protocol</strong> Presenter: SomeViewControllerSettable {<br/>  // Other protocol requirements.<br/>}</span><span id="6f74" class="ne md it na b gy nj ng l nh ni">// Implementation goes without change.</span></pre><h1 id="a6c2" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">3.初始化</h1><p id="aedc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们需要<code class="fe nl nm nn na b">PositionCalculator</code>在整个<code class="fe nl nm nn na b">SomeViewController</code>的生命周期中立即可用。在这种情况下，通过初始化器传递依赖关系的解决方案就行了:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b13c" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> SomeViewController: UIViewController {</span><span id="010a" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">private</strong> <strong class="na iu">let</strong> positionCalculator: PositionCalculator</span><span id="a8a5" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">init</strong>(positionCalculator: PositionCalculator) {<br/>    <strong class="na iu">self</strong>.positionCalculator = positionCalculator<br/>    <strong class="na iu">super</strong>.init(nibName: nil, bundle: nil)<br/>  }</span><span id="dc9e" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">@available</strong>(*, unavailable)<br/>  <strong class="na iu">required</strong> init?(coder aDecoder: NSCoder) {<br/>    fatalError("init(coder:) has not been implemented")<br/>  }</span><span id="a9cb" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">override</strong> <strong class="na iu">func</strong> viewDidLoad() {<br/>    <strong class="na iu">super</strong>.viewDidLoad()<br/>    positionView(view)<br/>  }</span><span id="dd7f" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">private</strong> <strong class="na iu">func</strong> positionView(_ view: UIView) {<br/>    view.frame = positionCalculator.getPositionOfView(view,<br/>                                                      in: self)<br/>  }</span><span id="297d" class="ne md it na b gy nj ng l nh ni">}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="8482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们朝着可测试性和低耦合性再走几步，让我们抽象掉依赖性，这样它可能有不同的实现或者在单元测试中被模仿(客户端类可以保持不变):</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="11aa" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">protocol</strong> PositionCalculatorProtocol {<br/>  <strong class="na iu">func</strong> getPositionOfView(<br/>    _ view: UIView, in viewController: UIViewController<br/>  ) -&gt; CGRect<br/>}</span><span id="624b" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> PositionCalculator: PositionCalculatorProtocol {<br/>  <strong class="na iu">func</strong> getPositionOfView(<br/>    _ view: UIView, in viewController: UIViewController<br/>  ) -&gt; CGRect {<br/>    <strong class="na iu">var</strong> rect = CGRect()<br/>    <em class="nk">// ...</em></span><span id="65cc" class="ne md it na b gy nj ng l nh ni">    <strong class="na iu">return</strong> rect<br/>  }<br/>}</span></pre><p id="3794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果只有一个实现，我们总是可以通过为初始化器提供一个默认值来节省一些编码工作:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="839e" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> SomeViewController: UIViewController {</span><span id="8437" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">private</strong> <strong class="na iu">let</strong> positionCalculator: PositionCalculator</span><span id="589d" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">init</strong>(<br/>    positionCalculator: PositionCalculator = PositionCalculator()<br/>  ) {<br/>    <strong class="na iu">self</strong>.positionCalculator = positionCalculator<br/>    <strong class="na iu">super</strong>.init(nibName: nil, bundle: nil)<br/>  }</span><span id="a432" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">@available</strong>(*, unavailable)<br/>  <strong class="na iu">required</strong> <strong class="na iu">init</strong>?(coder aDecoder: NSCoder) {<br/>    fatalError("init(coder:) has not been implemented")<br/>  }</span><span id="ce36" class="ne md it na b gy nj ng l nh ni">}</span></pre><h1 id="1d43" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">4.容器</h1><p id="253c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">又名注册表、解析器或<a class="ae ky" href="https://en.wikipedia.org/wiki/Service_locator_pattern" rel="noopener ugc nofollow" target="_blank">服务定位器</a>，这种方式适用于一次又一次注入相同依赖项(相同类型、相同实例)的大型项目。根据我的经验，它在Android世界中被广泛使用(见<a class="ae ky" href="https://github.com/google/dagger" rel="noopener ugc nofollow" target="_blank"> Dagger </a>)，在iOS项目中不太受欢迎。</p><p id="6e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其思想是将所有可能的依赖关系存储在一个容器中，而不是单独传递依赖关系(有时通过多个初始化器，从一个类传递到另一个类)，而是注入将提供必要的现场依赖关系的容器。</p><p id="2659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的实现可能如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a187" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> DependencyContainer {</span><span id="1f4f" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">static</strong> <strong class="na iu">let</strong> shared = DependencyContainer()<br/>  <strong class="na iu">private</strong> <strong class="na iu">var</strong> dependencies = [String : Any]()</span><span id="7935" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">private</strong> <strong class="na iu">init</strong>() { }</span><span id="eb00" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">func</strong> register&lt;Dependency&gt;(dependency: Any,<br/>                            ofType type: Dependency.Type) {<br/>    dependencies["\(type)"] = dependency<br/>  }</span><span id="607a" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">func</strong> resolve&lt;Dependency&gt;(<br/>    ofType type: Dependency.Type<br/>  ) -&gt; Dependency? {<br/>    <strong class="na iu">return</strong> dependencies["\(type)"] <strong class="na iu">as</strong>? Dependency<br/>  }</span><span id="62e6" class="ne md it na b gy nj ng l nh ni">}</span></pre><p id="09aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在离客户端模块的根更近的地方，注册所有要使用的依赖项:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7a1d" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">let</strong> positionCalculator = PositionCalculator()<br/>DependencyContainer.shared.register(<br/>  dependency: positionCalculator,<br/>  ofType: PositionCalculatorProtocol.self<br/>)</span></pre><p id="fd99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注射本身现在看起来像这样:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4e0e" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> SomeViewController: UIViewController {<br/><br/>  <strong class="na iu">private</strong> <strong class="na iu">let</strong> positionCalculator: PositionCalculatorProtocol</span><span id="9725" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">init</strong>(positionCalculator: PositionCalculatorProtocol<br/>    = DependencyContainer<br/>      .shared<br/>      .resolve(ofType: PositionCalculatorProtocol.self)!) {<br/>    <strong class="na iu">self</strong>.positionCalculator = positionCalculator<br/>    <strong class="na iu">super</strong>.init(nibName: nil, bundle: nil)<br/>  }</span><span id="5c80" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">@available</strong>(*, unavailable)<br/>  <strong class="na iu">required</strong> <strong class="na iu">init</strong>?(coder aDecoder: NSCoder) {<br/>    fatalError("init(coder:) has not been implemented")<br/>  }</span><span id="5373" class="ne md it na b gy nj ng l nh ni">}</span></pre><p id="e091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有注意到一个潜伏的强行解开操作者？是的，这就是代价——少量的运行时不安全性。当然，您可以将这个又小又丑的<code class="fe nl nm nn na b">!</code>移动到容器中，但是这并不能解决任何问题——如果您忘记注册一个依赖项，您还是会崩溃:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="28f9" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">func</strong> resolve&lt;Dependency&gt;(<br/>  ofType type: Dependency.Type<br/>) -&gt; Dependency {<br/>  <strong class="na iu">return</strong> dependencies["\(type)"] <strong class="na iu">as</strong>! Dependency<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及在Android世界中，有一些库可以基于这种方法的思想提供现成的解决方案。比如<a class="ae ky" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank">解析器</a>和<a class="ae ky" href="https://github.com/Swinject/Swinject" rel="noopener ugc nofollow" target="_blank">s对象</a>。</p><h2 id="c10d" class="ne md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">4a。属性包装</h2><p id="e805" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">容器方法的现代风格隐藏在属性包装器之后，这是一个相对较新的Swift特性，大致类似于Java的注释。下面是一个可能的实现(高度受<a class="ae ky" href="https://www.avanderlee.com" rel="noopener ugc nofollow" target="_blank"> Antoine van der Lee </a>在Swift中使用最新Swift特性 的<a class="ae ky" href="https://www.avanderlee.com/swift/dependency-injection/" rel="noopener ugc nofollow" target="_blank"> <em class="nk">依赖注入的启发):</em></a></p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aa91" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">protocol</strong> DependencyContainerKey {<br/>  <strong class="na iu">associatedtype</strong> Dependency<br/>  <strong class="na iu">static</strong> <strong class="na iu">var</strong> value: Dependency { <strong class="na iu">get</strong> <strong class="na iu">set</strong> }<br/>}</span><span id="10d4" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">struct</strong> DependencyContainer {</span><span id="6a74" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">var</strong> positionCalculator: PositionCalculatorProtocol {<br/>    <strong class="na iu">get</strong> { Self[PositionCalculatorKey.self] }<br/>    <strong class="na iu">set</strong> { Self[PositionCalculatorKey.self] = newValue }<br/>  }<br/>  <strong class="na iu">private</strong> <strong class="na iu">static</strong> <strong class="na iu">var</strong> current = DependencyContainer()</span><span id="5a0a" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">static</strong> <strong class="na iu">subscript</strong>&lt;Dependency&gt;(<br/>    _ keyPath: WritableKeyPath&lt;DependencyContainer, Dependency&gt;<br/>  ) -&gt; Dependency {<br/>    <strong class="na iu">get</strong> { current[keyPath: keyPath] }<br/>    <strong class="na iu">set</strong> { current[keyPath: keyPath] = newValue }<br/>  }<br/>  <strong class="na iu">private</strong> <strong class="na iu">static</strong> subscript&lt;Key&gt;(<br/>    key: Key.Type<br/>  ) -&gt; Dependency where Key: DependencyContainerKey {<br/>    <strong class="na iu">get</strong> { key.value }<br/>    <strong class="na iu">set</strong> { key.value = newValue }<br/>  }</span><span id="54e5" class="ne md it na b gy nj ng l nh ni">}</span><span id="dc12" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">@propertyWrapper</strong><br/><strong class="na iu">struct</strong> Injected&lt;Dependency&gt; {</span><span id="81da" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">var</strong> wrappedValue: Dependency {<br/>    <strong class="na iu">get</strong> { DependencyContainer[keyPath] }<br/>    <strong class="na iu">set</strong> { DependencyContainer[keyPath] = newValue }<br/>  }<br/>  <strong class="na iu">private</strong> <strong class="na iu">let</strong> keyPath: WritableKeyPath&lt;DependencyContainer,<br/>                                       Dependency&gt;<br/><br/>  <strong class="na iu">init</strong>(<br/>    _ keyPath: WritableKeyPath&lt;DependencyContainer, Dependency&gt;<br/>  ) {<br/>    <strong class="na iu">self</strong>.keyPath = keyPath<br/>  }</span><span id="c026" class="ne md it na b gy nj ng l nh ni">}</span></pre><p id="2628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要向容器添加可注入的依赖项，我们只需添加一个相应的容器键实现和一个属性:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cb1c" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">extension</strong> DependencyContainer {<br/>  <strong class="na iu">var</strong> positionCalculator: PositionCalculatorProtocol {<br/>    <strong class="na iu">get</strong> { Self[PositionCalculatorKey.self] }<br/>    <strong class="na iu">set</strong> { Self[PositionCalculatorKey.self] = newValue }<br/>  }<br/>  <strong class="na iu">private</strong> <strong class="na iu">struct</strong> PositionCalculatorKey: DependencyContainerKey {<br/>    <strong class="na iu">static</strong> <strong class="na iu">var</strong> value: PositionCalculatorProtocol<br/>      = PositionCalculator()<br/>  }<br/>}</span></pre><p id="3847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注入的依赖项如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d8f2" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">final</strong> <strong class="na iu">class</strong> SomeViewController: UIViewController {</span><span id="4f13" class="ne md it na b gy nj ng l nh ni">  <strong class="na iu">@Injected</strong>(\.positionCalculator)<br/>  <strong class="na iu">private</strong> <strong class="na iu">var</strong> positionCalculator: PositionCalculatorProtocol</span><span id="4ff0" class="ne md it na b gy nj ng l nh ni">}</span></pre><p id="efdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一个好处是运行时安全性。没有强制解包，如果您忘记向容器添加依赖项，代码就不会编译。</p><p id="71ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，最好将系统<code class="fe nl nm nn na b">private</code>的所有副本与<code class="fe nl nm nn na b">Injected</code>声明放在同一个文件中。否则，没有什么能阻止你误用容器，比如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="38f3" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">let</strong> positionCalculator = DependencyContainer().positionCalculator</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b50d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8b6f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我的另一个同事，当时职位比我高，曾经教我如何开始编写单元测试。事实是，没有经验的程序员避免单元测试的主要原因之一是他们的类不是真正可测试的。</p><p id="f897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，首先要做的是分解那些类。如果在分解之后，它们仍然是不可测试的，那么分解产生的类——重复直到类最终是可测试的。依赖注入是一种非常有用的技术，它使你的代码可测试，并且通常遵循传说中的<a class="ae ky" href="https://levelup.gitconnected.com/beyond-the-single-responsibility-principle-d4103418e2e2" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>。</p></div></div>    
</body>
</html>