<html>
<head>
<title>Comparing the Same Feature Written in React and Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较用React和Angular编写的相同特征</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/comparing-the-same-feature-written-in-react-and-angular-3f6ae04ceef6?source=collection_archive---------15-----------------------#2019-11-11">https://betterprogramming.pub/comparing-the-same-feature-written-in-react-and-angular-3f6ae04ceef6?source=collection_archive---------15-----------------------#2019-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该功能的要求是将文件上传到Azure Blob存储，然后允许用户列出、删除和下载上传的项目。这两种解决方案都依赖于<code class="fe kl km kn ko b"><a class="ae kp" href="https://www.npmjs.com/package/@azure/storage-blob" rel="noopener ugc nofollow" target="_blank">@azure/storage-blob</a></code> NPM包，并且<code class="fe kl km kn ko b"><a class="ae kp" href="https://www.npmjs.com/package/rxjs" rel="noopener ugc nofollow" target="_blank">rxjs</a></code>已经被添加到React项目中。</p><p id="aa9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些项目使用TypeScript、React 16.11、Angular 8.2.13和RxJS 6.4.0。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/48cc402b8f7937aecc5113e1f24cc563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BUmHwr2GcOQD6CUr.png"/></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="6db1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">背景</h1><p id="4015" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我最近写了两篇关于使用<a class="ae kp" href="https://medium.com/@stuarttottle/upload-to-azure-blob-storage-with-react-34f37805fdfc" rel="noopener"> React </a>和<a class="ae kp" href="https://medium.com/@stuarttottle/upload-to-azure-blob-storage-with-angular-8-2ed80dfc6672" rel="noopener"> Angular </a>上传到Azure Blob存储的文章，并最终创建了两个具有相同组件和服务的项目，它们在两个解决方案中具有相同的名称和相同的功能。所以我认为写一个特定特性的比较比描述高层次的差异更有趣。</p><p id="931a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在GitHub上找到解决方案，这些解决方案是使用相关的CLI工具(<a class="ae kp" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>、<a class="ae kp" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create React App </a>)创建的</p><ul class=""><li id="81d6" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated"><a class="ae kp" href="https://github.com/stottle-uk/stottle-angular-blob-storage" rel="noopener ugc nofollow" target="_blank">有角度的</a></li><li id="e4dc" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><a class="ae kp" href="https://github.com/stottle-uk/stottle-react-blob-storage" rel="noopener ugc nofollow" target="_blank">做出反应</a></li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="8351" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解决方案概述</h1><p id="c050" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">这两种解决方案都利用了<code class="fe kl km kn ko b">viewState</code>服务，并有一个专门的服务将功能包装在<code class="fe kl km kn ko b">@azure/blob-storage</code> NPM包中。我避免了Redux，因为我不想给项目增加更多的依赖。</p><p id="2263" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当显示数据时，组件订阅<code class="fe kl km kn ko b">viewState</code>服务中的observables，并调用<code class="fe kl km kn ko b">viewState</code>服务上的函数来共享捕获的数据。他们的职责很少，不包含任何业务逻辑。</p><p id="e9c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种解决方案在结构上的主要区别是:</p><ul class=""><li id="3de5" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">文件命名约定</li><li id="31e9" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">角度解决方案有一个<code class="fe kl km kn ko b">azure-storage</code>特征模块，因此可以导入到其他模块中。</li><li id="5774" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">角度解决方案有一个<code class="fe kl km kn ko b">token.ts</code>文件，其中包含为注入令牌创建<code class="fe kl km kn ko b">BlobServiceClient</code>的工厂函数</li><li id="43e4" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">React解决方案有一个上下文文件来管理组件如何与<code class="fe kl km kn ko b">viewState</code>服务交互</li></ul><p id="50b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个解决方案中使用了相同的样式表，这是非常基本和简单的。</p><p id="043b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将比较解决方案中的几个组件以突出差异，并且我已经包含了一个关于如何在框架中实现类似功能的观点。</p><p id="8fd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样值得注意的是，除了用于依赖注入的Angular <code class="fe kl km kn ko b">@Injectable</code>装饰器之外，这些服务是相同的。</p><p id="6c09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不打算讨论依赖注入——如果您还不熟悉这个概念，React可能是您更好的选择。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="ae39" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">应用程序组件</h1><p id="35fc" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">app组件将我们布局的所有组件集合在一起，是特性的入口点。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/f63ff630eb27f2c98309f6da38709ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1bQWAnDn02hA6IO0Nu5wAg.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">左边有棱角；向右反应</p></figure><p id="828e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Angular中，CSS类被添加到组件中，就像DOM中的HTML元素一样。</p><p id="65c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React中，CSS类是在这个解决方案的组件内部声明的。值得注意的是，如果不改变共享的CSS结构，我们无法在Angular中做到这一点(CSS的结构很糟糕——对Angular没有限制)。</p><p id="7e5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，React组件更直观。它有许多导入，但这更容易找到正在使用的组件(并且拼写错误会很明显)。此外，没有子元素的组件可以用简写语法关闭。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="eb60" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">文件上传组件</h1><p id="fc76" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">该组件显示一个按钮，单击该按钮将打开输入文件对话框。所选文件随后被提供给<code class="fe kl km kn ko b">viewState</code>状态服务上的<code class="fe kl km kn ko b">uploadItems</code>功能。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nf"><img src="../Images/1a84c5e32f020357dadb96a3ee011351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3xXn4uP_Vne9DmVdaaiQQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">左边有棱角；向右反应</p></figure><h2 id="1667" class="ng lg iq bd lh nh ni dn ll nj nk dp lp jy nl nm lt kc nn no lx kg np nq mb nr bi translated">引用组件-HTML元素</h2><p id="aec6" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在Angular中，组件上的<code class="fe kl km kn ko b">fileInput</code>属性使用<code class="fe kl km kn ko b">@ViewChild</code>装饰器和<code class="fe kl km kn ko b">#fileInput</code>属性来引用输入元素。</p><p id="a2e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React中，<code class="fe kl km kn ko b">inputFileRef</code> const被分配给输入的<code class="fe kl km kn ko b">ref</code> prop，并使用<code class="fe kl km kn ko b">useRef</code>钩子来获取引用。</p><p id="b3b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不能决定哪种方法是最直观的。</p><h2 id="5c26" class="ng lg iq bd lh nh ni dn ll nj nk dp lp jy nl nm lt kc nn no lx kg np nq mb nr bi translated">处理事件</h2><p id="22da" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在Angular中，输入上的<code class="fe kl km kn ko b">(change)</code>事件被绑定到<code class="fe kl km kn ko b">onSelected</code>函数。它使用框架括号约定绑定到事件，并使用<code class="fe kl km kn ko b">$event</code>关键字获取对事件数据的引用。</p><p id="c82a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React中，<code class="fe kl km kn ko b">onChange</code>事件被绑定到一个函数，该函数使用所选文件调用<code class="fe kl km kn ko b">showFileDialog</code>方法。</p><p id="8414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React方法对我来说更直观，因为它不依赖于特定于框架的约定，并且都是强类型的。</p><h2 id="3238" class="ng lg iq bd lh nh ni dn ll nj nk dp lp jy nl nm lt kc nn no lx kg np nq mb nr bi translated">更新视图状态</h2><p id="79e6" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在Angular中，<code class="fe kl km kn ko b">BlobUploadsViewStateService</code>被注入到组件中，<code class="fe kl km kn ko b">onSelected</code>方法调用服务上的<code class="fe kl km kn ko b">uploadItems</code>方法。</p><p id="5a64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React中，我们用<code class="fe kl km kn ko b">useContext</code>钩子获得了对<code class="fe kl km kn ko b">BlobUploadsViewState</code>服务的引用，以调用上下文中的<code class="fe kl km kn ko b">uploadItems</code>方法。</p><p id="6a9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我更喜欢Angular方法，因为依赖注入和Angular模块倾向于更明显的应用程序结构，因为每个模块都是具有特定功能的特性。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="5baa" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">项目-上传的组件</h1><p id="353b" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">该组件显示用户已上传的文件列表以及上传进度。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ns"><img src="../Images/23c56831b52631564f0cf95527407935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4zmFCD3emjsWwflHgycew.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">左边有棱角；向右反应</p></figure><h2 id="9ada" class="ng lg iq bd lh nh ni dn ll nj nk dp lp jy nl nm lt kc nn no lx kg np nq mb nr bi translated">获取视图状态数据</h2><p id="82b1" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在Angular中，组件上的<code class="fe kl km kn ko b">uploads$</code>属性被分配给来自<code class="fe kl km kn ko b">viewState</code>服务的<code class="fe kl km kn ko b">uploadedItems$</code>属性的值。模板中的<code class="fe kl km kn ko b">async</code>管道管理对可观察对象的订阅，我们使用特定于<code class="fe kl km kn ko b">*ngFor</code>框架的语法遍历每个项目。</p><p id="2f9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React中，我们使用<code class="fe kl km kn ko b">useEffect.</code>时，有更多的仪式来管理可观察对象的订阅</p><p id="868b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过，我仍然更喜欢React版本，因为我们可以创建一个挂钩(或者使用一个<a class="ae kp" href="https://www.npmjs.com/package/rxjs-hooks" rel="noopener ugc nofollow" target="_blank">库</a>)来管理可观察的订阅，并消除围绕效果的仪式。我们还使用JavaScript将数组中的项目映射到HTML/JSX元素，而不是使用特定于框架的语法/管道。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="a24b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">选定容器组件</h1><p id="9547" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">该组件显示用户在UI中选择的Azure Blob容器的相关信息。它还呈现依赖于<code class="fe kl km kn ko b">viewState</code>服务中容器名称的子组件。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nt"><img src="../Images/12eae17bd126563321e2dd7ab0312b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qqdD_mXnTS1iU0Yyv4D8w.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">左边有棱角；向右反应</p></figure><h2 id="e23f" class="ng lg iq bd lh nh ni dn ll nj nk dp lp jy nl nm lt kc nn no lx kg np nq mb nr bi translated">显示-子组件</h2><p id="be7e" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在Angular中，<code class="fe kl km kn ko b">&lt;ng-content&gt;</code>用于呈现子组件和特定于框架的<code class="fe kl km kn ko b">&lt;ng-container&gt;</code>元素，而<code class="fe kl km kn ko b">*ngIf</code>用于在用户尚未选择容器时隐藏内容。<code class="fe kl km kn ko b">selectedContainer$</code>的订阅由特定于框架的<code class="fe kl km kn ko b">async</code>管道管理。</p><p id="5c2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React中，<code class="fe kl km kn ko b">children</code> prop用于呈现子组件，当用户没有在UI中选择容器时，将返回特定于库的<code class="fe kl km kn ko b">&lt;&gt;&lt;/&gt;</code>。组件的属性也被设置为一个<code class="fe kl km kn ko b">HTMLDivElement</code>类型，这样我们可以在引用组件时添加HTML属性。然后用<code class="fe kl km kn ko b">{...rest}</code>将属性添加到div元素中。</p><p id="ef95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再说一次，我更喜欢React版本，因为我们避免了特定于框架的语法，并且效果周围的仪式可以被删除，所以一个小的紧凑的函数组件将会保留。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="83eb" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="06a9" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">Angular和React对同一个问题提供了不同的解决方法，我做过的Angular项目比React多，并且首先学习了Angular，但是我很高兴我知道这两者并且觉得我是一个更好的开发者。</p><p id="5f4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Angular做了更多的开箱即用的事情，并且是一个带有观点的框架，当遵循它时，可以有助于快速开发。但是您将花费大量时间阅读文档，并且RxJS有一个陡峭的学习曲线。如果你不了解RxJS，你可能无法充分利用Angular。</p><p id="2f93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React的启动和运行更简单，Hooks API也非常有用——但是我认为，如果在项目增长时没有时间进行重构，那么创建一个意大利面项目是非常容易的。</p><p id="e502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，最好理解和欣赏差异，而不是偏袒一方，固执己见。</p></div></div>    
</body>
</html>