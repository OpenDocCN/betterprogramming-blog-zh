# 属性包装器:三个真实场景

> 原文：<https://betterprogramming.pub/property-wrappers-three-real-case-scenarios-bd3e60a7c1ae>

## 验证、解码和依赖注入

![](img/4bbd0f6a73804e434b74b3f44693407e.png)

# 介绍

属性包装器并不是一个新概念。其他语言如 Java、 [Kotlin](https://kotlinlang.org/) 和 JavaScript 已经使用这种常见模式有一段时间了。

这些带有@前缀的属性有着不同的名称(注释、装饰等等)和不同的作用域，已经成为许多开发人员日常工作的一部分。

Swift 是一种非常强大的函数式编程语言，有如此多的工具可用，而且相对较新。许多人想知道为什么 Swift 不支持注释，特别是考虑到苹果已经在使用注释:`@objc`、`@IBOutlet`和`@discardableResult`就是一些例子。

虽然只是支持实例属性，但自从在 Swift 5.1 中引入属性包装器以来，苹果已经为美国开发者打开了无数的可能性。

例如，通过用这些属性包装字段，我们能够很容易地从我们的类/结构中删除大量样板文件。

在本教程中，我们将展示三个属性包装器派上用场的真实场景:

*   属性验证。
*   解码 JSON 结构。
*   依赖注入。

# 属性验证

我想我们在模拟银行卡。大多数 cvv 都是三位数长。在属性包装器出现之前，我们将这个属性建模为一个字符串，并在需要使用它的时候检查它的长度:

在 Swift 5.1 中，我们可以定义一个`CVV`属性包装器，并在包装器内完成所有这些验证:

这样，我们现在可以使用`CVV`来包装我们的属性:

# 解码 JSON 结构

如果您曾经使用过 PHP 内置的 API，您会注意到，有时，两个不同的端点返回相同的模型，但格式不同，也就是说，模型属性根据端点的不同而具有不同的类型。这是由于后端的 JSON 编码。

虽然这并不理想，应该得到解决，但是我们总是可以手动实现`Decodable`协议，并尝试解码 JSON 密钥，例如，作为一个`Integer`，如果失败，作为一个`String`:

正如你所看到的，这并不是世界上最好的任务，如果结构体封装了大量的信息，它会变得非常混乱。

此外，如果这个问题发生一次，它很可能会发生在另一个端点的另一个模型上。我们不得不再次遵循同样的策略…

拯救财产包装者！我们可以定义一个属性包装器来处理这种情况。这样，我们可以让编译器替我们完成工作，自己处理`Decodable`:

使用`Converted`，很容易将前面的例子改写为:

# 依赖注入

我们可以使用属性包装器的另一个应用是将依赖关系注入到我们的对象中。想法和 SwiftUI *里的`EnvironmentObject`挺像的。*

假设我们有以下模型:

如您所见，`C`有`A`和`B`作为依赖项。我们可以将依赖关系存储在容器中，并使用属性包装器根据类型或名称注入这些依赖关系:

下面是你如何使用它:

# 结论

虽然这不是一个新概念，但是属性包装器是一颗未经雕琢的钻石。他们可以帮助我们:

*   从我们的文件中删除样板文件。
*   重用代码。
*   保持我们的代码更干净。
*   用新功能装饰房产。