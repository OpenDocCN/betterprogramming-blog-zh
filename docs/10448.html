<html>
<head>
<title>Unit Testing Asynchronous Combine Code in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中异步组合代码的单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-asynchronous-combine-code-using-xctest-framework-3066f570f200?source=collection_archive---------3-----------------------#2022-01-08">https://betterprogramming.pub/unit-testing-asynchronous-combine-code-using-xctest-framework-3066f570f200?source=collection_archive---------3-----------------------#2022-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f294" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们使用iOS中的XCTest框架来测试一个组合代码库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2a3d4580616dc628530596bb83d407aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FXIV-DnyvdkE6wr-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">普通技术人员在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="66a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Combine是苹果在iOS 13中发布的一个反应式编程框架，允许我们处理异步数据流。</p><p id="d06b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">根据苹果</a>的说法，联合收割机可以让我们:</p><blockquote class="ls lt lu"><p id="b415" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">通过组合事件处理运算符来自定义异步事件的处理。</p></blockquote><p id="e869" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将探讨如何使用XCTest Apple的框架对基于Combine的代码进行单元测试。</p><p id="bcfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了做到这一点，我们将为一个示例应用程序编写单元测试，该程序将显示一个作业列表。我们将使用的核心类是:</p><p id="f0bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lz ma mb mc b">Job</code>:表示作业实体。我们的模型。</p><p id="af54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lz ma mb mc b">JobsViewModel</code>:负责处理所有的展现逻辑。我们将使用两种视图状态:<code class="fe lz ma mb mc b">Populated</code>和<code class="fe lz ma mb mc b">Empty</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ec74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv"> </em> <code class="fe lz ma mb mc b">JobClientProtocol</code>协议将作为我们网络逻辑的门面。</p><p id="0000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的应用程序中，您应该有一个符合它的<code class="fe lz ma mb mc b">JobClient</code>类型，但我们不会在本文中实现它(特别是因为我们不需要它):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="a550" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:为了简单起见，<code class="fe lz ma mb mc b">JobsViewModel</code>将<code class="fe lz ma mb mc b">JobClientProtocol</code>作为依赖项(理想情况下，我们希望有一个额外的层，这样我们的视图模型就不会直接与网络代码交互)。</p><h1 id="85c7" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">将测试什么</h1><p id="2119" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们的主要目标是测试视图模型中的所有视图状态是否根据提取的作业正确设置。</p><p id="329b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将测试的两种状态及其条件是:</p><ol class=""><li id="153d" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><code class="fe lz ma mb mc b">Populated</code>:如果我们有一个或多个提取的作业。</li><li id="238e" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe lz ma mb mc b">Empty</code>:如果没有要显示的提取作业。</li></ol><h1 id="a256" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated"><strong class="ak">创建模拟</strong></h1><p id="7c5d" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们先来嘲讽一下我们的<code class="fe lz ma mb mc b">JobClientProtocol</code>。这应该不是一个困难的任务，因为我们的视图模型依赖于抽象(在这种情况下是一个协议)而不是具体的类型。所以一个<code class="fe lz ma mb mc b">MockJobClient</code>应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="07ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将允许我们按照自己的意愿控制网络客户端的行为，为我们编写单元测试提供了很大的灵活性。</p><p id="16d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:我们使用<code class="fe lz ma mb mc b">AnyPublisher</code>是因为这种形式的类型擦除保留了抽象，因此隐藏了我们网络客户端的底层实现。</p><h1 id="072d" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">定义我们存储的属性</h1><p id="b2ee" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">首先，我们需要声明两个存储属性:</p><ol class=""><li id="06c1" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><code class="fe lz ma mb mc b">viewModelToTest</code>:这将是将要测试的视图模型的实例。也称为SUT(被测系统)。</li><li id="1c20" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe lz ma mb mc b">mockJobClient</code>:我们被嘲笑的一个实例<code class="fe lz ma mb mc b">JobClientProtocol</code>。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="fbd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要为其中的每一个存储属性，因为我们将直接修改<code class="fe lz ma mb mc b">mockJobClient</code> <em class="lv"> </em>来模拟我们需要的不同场景(<code class="fe lz ma mb mc b">MockJobClient</code> <em class="lv">是</em>类<em class="lv">，</em>因此它将作为视图模型初始化器中的引用被传递，并且在<code class="fe lz ma mb mc b">MockJobClient</code>实例上执行的任何更新或修改都将影响视图模型行为)<em class="lv">。</em></p><p id="7d1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将有一个<code class="fe lz ma mb mc b">AnyCancellable</code> <em class="lv"> </em>集合<em class="lv">，</em>的实例，因为我们将一个订阅者附加到由<code class="fe lz ma mb mc b">mockJobClient</code>返回的发布者，并且这个订阅者需要被保留；否则，它将立即被释放:</p><pre class="kg kh ki kj gt nq mc nr ns aw nt bi"><span id="0a01" class="nu mg iq mc b gy nv nw l nx ny"><strong class="mc ir">private</strong> <strong class="mc ir">var</strong> cancellables: Set&lt;AnyCancellable&gt; = []</span></pre><h1 id="df08" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">编写我们的单元测试</h1><p id="0f89" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">为了执行我们的单元测试，我们需要订阅<code class="fe lz ma mb mc b">JobsViewModel</code>中的<code class="fe lz ma mb mc b">viewState</code>发布者。为此，我们将使用<code class="fe lz ma mb mc b">sink</code>方法，该方法将使用基于闭包的行为将订户附加到<code class="fe lz ma mb mc b">viewState</code> <em class="lv"> </em>:</p><pre class="kg kh ki kj gt nq mc nr ns aw nt bi"><span id="6dc3" class="nu mg iq mc b gy nv nw l nx ny">viewModelToTest.$viewState.dropFirst().sink { state <strong class="mc ir">in</strong></span><span id="71ea" class="nu mg iq mc b gy nz nw l nx ny">    // Evaluate state here</span><span id="ad41" class="nu mg iq mc b gy nz nw l nx ny">}.store(<strong class="mc ir">in</strong>: &amp;cancellables)</span></pre><p id="260d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是模拟网络客户端响应。通过使用我们的<code class="fe lz ma mb mc b">MockJobClient</code>，我们可以很容易地做到这一点。要模拟空响应，我们应该这样做:</p><pre class="kg kh ki kj gt nq mc nr ns aw nt bi"><span id="031a" class="nu mg iq mc b gy nv nw l nx ny">mockJobClient.fetchJobsResult = Result.success([]).publisher.eraseToAnyPublisher()</span></pre><p id="b8f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了模拟群体反应:</p><pre class="kg kh ki kj gt nq mc nr ns aw nt bi"><span id="93ea" class="nu mg iq mc b gy nv nw l nx ny"><strong class="mc ir">let</strong> jobsToTest = [Job(id: "1", title: "title", description: "desc")]</span><span id="1394" class="nu mg iq mc b gy nz nw l nx ny">mockJobClient.fetchJobsResult = Result.success(jobsToTest).publisher.eraseToAnyPublisher()</span></pre><p id="2b06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是调用<code class="fe lz ma mb mc b">loadJobs</code>方法，该方法将使用<code class="fe lz ma mb mc b">MockJobClient</code> <em class="lv"> : </em>启动检索过程</p><pre class="kg kh ki kj gt nq mc nr ns aw nt bi"><span id="1aab" class="nu mg iq mc b gy nv nw l nx ny">viewModelToTest.loadJobs()</span></pre><p id="dfb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:重要的是在前面的步骤(附加订户和模拟联网响应)之后调用<code class="fe lz ma mb mc b">loadJobs</code>方法；否则，我们的<code class="fe lz ma mb mc b">viewState</code>发布者将不会发出任何值，因为在这一点上，还没有订阅者被附加(如果没有订阅者被附加，那么Combine的发布者不会发出任何值)。</p><p id="d61b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了验证我们正在接收正确的状态，我们将使用<code class="fe lz ma mb mc b">XCTestExpectation</code>，这是Apple为我们提供的一个类，用于创建异步测试。</p><p id="5d55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终的测试类如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="717a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。您可以在这个资源库中找到完整的示例代码:</p><div class="oa ob gp gr oc od"><a href="https://github.com/DeluxeAlonso/CombinePlayground/blob/development/Combine.playground/Pages/Unit%20testing.xcplaygroundpage/Contents.swift" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">combine playground/contents . swift at development DeluxeAlonso/combine playground</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or kp od"/></div></div></a></div></div></div>    
</body>
</html>