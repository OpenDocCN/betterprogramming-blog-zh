<html>
<head>
<title>Build a Rubik Cube Using SceneView and SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SceneView和SwiftUI构建一个魔方</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-rubik-cube-using-sceneview-and-swiftui-dea9e622ef43?source=collection_archive---------17-----------------------#2022-03-08">https://betterprogramming.pub/build-a-rubik-cube-using-sceneview-and-swiftui-dea9e622ef43?source=collection_archive---------17-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在您的应用程序中求解立方体</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1796e7bcbb15c5148e9c12bb0d0df0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YDVDjQVBQlB0YbQxviWefA.gif"/></div></div></figure><p id="81d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上周我发表了一篇文章，讲述了现在用SwiftUI实现SceneKit是多么容易。可悲的是，我发现我在这个领域的下一个项目肯定不会这么简单。</p><p id="a1a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单来说就是使用SwiftUI的SceneView操作符构建一个虚拟的魔方。我将在这里描述我是如何实现本文的动画GIF标题图像的。</p><h1 id="3167" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">挑战</h1><ul class=""><li id="06b4" class="mi mj it kw b kx mk la ml ld mm lh mn ll mo lp mp mq mr ms bi translated">我需要画一个立方体来代表一个魔方，然后我会将这个立方体组装成54个立方体的集合。</li><li id="47fd" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">我需要实现一个相机视图，这将允许我改变视图来解决立方体。</li><li id="ae76" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">我需要实现一种方法来点击它的一个立方体来改变它的方向。</li></ul><p id="a8ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅仅三个要求听起来很简单，但事实证明是一个相当大的挑战。</p><h1 id="6218" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">立方体</h1><p id="844d" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">bon——正如您所料，构建立方体并为其着色的代码是项目中最简单的部分。我几乎只用了4行代码就完成了这项工作。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="8fd9" class="ng lr it nc b gy nh ni l nj nk">func addBox(xAxis: Float, yAxis: Float, zAxis: Float) {<br/>  let cubeNode = SCNNode(geometry: cubeGeometry)<br/>  cubeNode.position = SCNVector3(xAxis, yAxis, zAxis)<br/>  scene?.rootNode.addChildNode(cubeNode)<br/>}</span></pre><p id="9e4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，我把它过于简单化了；质地[颜色]又花了十来行。就像上一个项目一样的照明而言，我想保持简单，并添加了四盏灯来淹没图像。我通过一些嵌套循环添加的节点[盒子]。</p><h1 id="c3d5" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">照相机</h1><p id="c7fe" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">我必须承认，我在实现这一点上得到了一些帮助。在早期构建中，我简单地使用了SceneKit <code class="fe nl nm nn nc b"><strong class="kw iu">allowsCameraControl</strong></code> <strong class="kw iu"> </strong>选项。除了不能和拖动手势一起使用之外，这个选项工作得很好。我需要一个手势来移动单独的立方体。所以我只能自己卷了。</p><p id="26c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我创建了一个共享类来记录SwiftUI中注册的拖动的位置和事务值。然后我做了一个虚拟的节点[cameraOrbit],我把它放在我的魔方的正中央，并把这个相机连接到它上面。</p><p id="ec32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，每次调用拖动手势时，我都将值存储在我的公共类中。</p><p id="01b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我用来改变<code class="fe nl nm nn nc b">cameraOrbit</code>节点上的<code class="fe nl nm nn nc b">eular</code>角度的值。我根据这个<a class="ae no" href="https://stackoverflow.com/questions/25654772/rotate-scncamera-node-looking-at-an-object-around-an-imaginary-sphere/25674762#25674762" rel="noopener ugc nofollow" target="_blank"> SO帖子</a>重新设计了一个解决方案——这个帖子值得一看，因为它对这里发生的事情也有很好的描述。我的代码版本是这样的。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b23a" class="ng lr it nc b gy nh ni l nj nk">func changeCamera() {<br/>  let dx = cameraOrbit.eulerAngles.x<br/>  let dy = cameraOrbit.eulerAngles.y<br/>  let scrollWidthRatio = Float(settings.translation.width / screenWidth) / 16<br/>  let scrollHeightRatio = Float(settings.translation.height / screenHeight) / 16<br/>  cameraOrbit.eulerAngles.y = Float(-2 * Float.pi) * scrollWidthRatio + dy<br/>  cameraOrbit.eulerAngles.x = Float(-Float.pi) * scrollHeightRatio + dx<br/>}</span></pre><h1 id="f31b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">立方体选择</h1><p id="52a7" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">这是迄今为止最具挑战性的方面，因为<code class="fe nl nm nn nc b">hitTest</code>方法似乎有点问题。</p><p id="cfd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最初尝试使用我基于我在这里找到的解决方案<a class="ae no" href="https://github.com/Thunor/HitTestApp?ref=iosexample.com" rel="noopener ugc nofollow" target="_blank">创建的公共类来实现</a>。我找到了另一个很好的参考，虽然遗憾的是，这个解决方案中的hittest对我不起作用。</p><p id="5816" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，我在SceneView的delegate方法中用这里使用的代码实现了相同类型的循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="68bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，它将拖动手势从旋转立方体集合切换到旋转单个立方体。一个转弯就是一个<code class="fe nl nm nn nc b">SCNAction</code>。</p><p id="026d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它工作得相当好，尽管它并不完全正确，是吗，我相信你会同意——要使它正确需要我进行更多的横向思考，我现在要离线了。</p><p id="b0c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这让我想到了这篇关于SceneKit的文章的结尾。</p><p id="8cc0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以从bitbucket <a class="ae no" href="https://bitbucket.org/wizard1066/scenekits/commits/6082b58451cc307fa128a57a46d8ca8bd3d7c326" rel="noopener ugc nofollow" target="_blank">这里</a>下载完整的代码副本。</p></div></div>    
</body>
</html>