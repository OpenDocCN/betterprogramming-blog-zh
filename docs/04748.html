<html>
<head>
<title>Swift vs. Kotlin: The Similarities and Differences You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斯威夫特与科特林:你应该知道的异同</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-vs-kotlin-the-similarities-and-differences-you-should-know-b2f1be201888?source=collection_archive---------2-----------------------#2020-05-06">https://betterprogramming.pub/swift-vs-kotlin-the-similarities-and-differences-you-should-know-b2f1be201888?source=collection_archive---------2-----------------------#2020-05-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a8bd" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">比较移动开发的两种主流语言</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/7c76454bbd84039900c8bb214560802a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CvO-ZVS_Osc0yRdR"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@teo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Teo Zac </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9543" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS和Android之间的霸权之战已经持续了十年。不管你选择什么样的生态系统，开发人员都无法停止比较这两种主要用于构建原生移动应用程序的语言。</p><p id="df77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Swift由苹果开发，于2014年首次出现。另一方面，Kotlin由JetBrains团队设计，并于2011年首次亮相。但直到2017年谷歌将其作为Android开发的官方语言，它才得到应有的重视。</p><p id="0e60" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Swift和Kotlin带来了更多的函数式编程，并且可以分别与它们的面向对象前辈Objective-C和Java进行互操作。了解Swift和Kotlin之间的明显相似性和主要差异应该有助于您在它们之间轻松切换。</p><p id="e891" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们比较一下它们的语法、风格和实现。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj lw"><img src="../Images/8bedcfd28a954fa05d16490ef96db789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHDD7O-swNslEAo-e37qjg.png"/></div></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="3c8e" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">可选和可空类型</h1><p id="2c04" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Swift和Kotlin努力确保您不会意外地遇到空指针异常。</p><p id="2e4b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">两者都使用一种包装器类型，让您可以安全地访问底层值。Swift称这种类型为<code class="fe nb nc nd ne b">Optional</code> s，而Kotlin称之为nullables。你需要做的就是在变量类型后设置一个<code class="fe nb nc nd ne b">?</code>。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="7059" class="nj mf iu ne b gz nk nl l nm nn"><strong class="ne iv">//Swift</strong><br/>var id: String? = "007"<br/>print(username) //Optional(007)<br/>username = nil</span><span id="2f8a" class="nj mf iu ne b gz no nl l nm nn">var password : String = nil //invalid</span><span id="a98c" class="nj mf iu ne b gz no nl l nm nn"><strong class="ne iv">//Kotlin</strong><br/>var number: String? = "123"<br/>print(username) // 123</span></pre><p id="30e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如您所见，Kotlin可空字符串在实际使用时，打印出与不可空类型相同的字符串。与Swift不同，它不将自己包装在可选的包装器中。这种差异是由于<code class="fe nb nc nd ne b">Optional</code>在Swift中的实现方式——它们本质上是一个枚举。</p><p id="3fce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，Kotlin nullables固有地包含一个<code class="fe nb nc nd ne b">null</code>类型检查器，当生成字节码时，编译器使用它来为您处理<code class="fe nb nc nd ne b">null</code>引用。</p><h2 id="a0f0" class="nj mf iu bd mg np nq dn mk nr ns dp mo lj nt nu mq ln nv nw ms lr nx ny mu nz bi translated">可选链接与安全调用</h2><p id="567a" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在Swift和Kotlin中都需要在查询属性或调用函数的对象后放置一个<code class="fe nb nc nd ne b">?</code>。在Swift中，这种行为被称为<em class="oa">可选链接，</em>而在Kotlin中，它被称为<em class="oa">安全调用。</em></p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="9086" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>print(string?.length) // prints Optional("3")</span><span id="1159" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>print(string?.length) //prints 3</span></pre><h2 id="4276" class="nj mf iu bd mg np nq dn mk nr ns dp mo lj nt nu mq ln nv nw ms lr nx ny mu nz bi translated"><strong class="ak">可选处理</strong></h2><p id="8aac" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Swift有一个nil-coalescing操作符，<em class="oa"> </em> <code class="fe nb nc nd ne b">??</code>，它让您安全地展开一个值(如果它存在的话),或者当值为空时提供一个默认值。在Kotlin中，使用<code class="fe nb nc nd ne b">?:</code> Elvis操作符也可以做到这一点。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="758b" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>let id: Int? = nil<br/>var x = id ?? -1 //prints -1</span><span id="ef64" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>val x: String? = "foo"<br/>val y: String = x ?: "bar"</span></pre><p id="55b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您想优雅地处理<code class="fe nb nc nd ne b">Optional</code>并对展开的值应用一些额外的操作，您可以在Kotlin中使用一个简单的<code class="fe nb nc nd ne b">null</code>检查器或智能转换(<code class="fe nb nc nd ne b">is </code>或<code class="fe nb nc nd ne b">as</code>)。另一方面，Swift为我们提供了可读性更强的<code class="fe nb nc nd ne b">if let</code>和<code class="fe nb nc nd ne b">guard let</code>语句。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="35aa" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>let name: String? = nil<br/>if let name = name {<br/>  print(name)<br/>} else {<br/>  print("name is nil")<br/>}</span><span id="229a" class="nj mf iu ne b gz no nl l nm nn">guard let name = name else{ return }<br/>//use name in the rest of the scope....</span></pre><p id="5a55" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然Kotlin没有类似的可选绑定语法，但它确实提供了一个<code class="fe nb nc nd ne b">let()</code> lambda函数，该函数仅在值不可为空时执行操作。但是这不同于<code class="fe nb nc nd ne b">if let</code>和<code class="fe nb nc nd ne b">guard let</code>方法，因为它不允许您访问作用域中的局部变量，如下所示:</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="e252" class="nj mf iu ne b gz nk nl l nm nn">//Kotlin<br/>name?.let { name -&gt;<br/>    if (name is String) {<br/>        //If name is not not null<br/>    }<br/>}</span></pre><h2 id="9ec1" class="nj mf iu bd mg np nq dn mk nr ns dp mo lj nt nu mq ln nv nw ms lr nx ny mu nz bi translated">强制包装和隐式包装</h2><p id="6c27" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">虽然Swift和Kotlin都不推荐使用强制解包或非空断言，但对于Swift来说，这样做的语法是<code class="fe nb nc nd ne b">!</code>，对于Kotlin来说是<code class="fe nb nc nd ne b">!!</code>。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="cf3e" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>var string : String? = nil<br/>string<strong class="ne iv">!.</strong>lowercased() //crashes</span><span id="fd4b" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>var string : String? = null<br/>string<strong class="ne iv">!!.</strong>toLowerCase() //crashes</span></pre><p id="90d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Swift中的隐式包装指示编译器忽略安全展开，因为该属性将始终有一个可用的值。在Kotlin中，通过在变量声明中使用<code class="fe nb nc nd ne b">lateinit</code>关键字也可以做到这一点:</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="fe5e" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>var string: String!</span><span id="f3ed" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>lateinit var string : String</span></pre><p id="fc60" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Kotlin和Swift都允许使用<code class="fe nb nc nd ne b">as?</code>安全施法。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="88fd" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">控制流程</h1><p id="e4cf" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated"><code class="fe nb nc nd ne b">if-else</code>、<code class="fe nb nc nd ne b">for</code>和<code class="fe nb nc nd ne b">switch</code>是大多数语言中可用的基本控制流语句。</p><h2 id="86e2" class="nj mf iu bd mg np nq dn mk nr ns dp mo lj nt nu mq ln nv nw ms lr nx ny mu nz bi translated">如果-否则</h2><p id="858d" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在Swift中，条件周围的括号不是必需的，但是在<code class="fe nb nc nd ne b">if-else</code>条件周围设置花括号是强制性的。相反，科特林做的正好相反。它仍然受到Java问题的困扰，并且让您在单行条件中不用花括号，因此由于悬空的<code class="fe nb nc nd ne b">else</code>问题而造成了歧义。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="3a99" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>if i == 0{<br/>}</span><span id="c5f8" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>if(i == 1)<br/>  return true</span></pre><h2 id="19f4" class="nj mf iu bd mg np nq dn mk nr ns dp mo lj nt nu mq ln nv nw ms lr nx ny mu nz bi translated">对于循环</h2><p id="0705" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">科特林和斯威夫特都有意识地远离C风格的<code class="fe nb nc nd ne b">for</code>循环，而是更加重视<code class="fe nb nc nd ne b">for in</code>循环。此外，它们还提供了使用范围操作符创建<code class="fe nb nc nd ne b">for</code>循环的方法。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="c4b6" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>for i in 0..5 {<br/>  print(i)<br/>}</span><span id="4b6c" class="nj mf iu ne b gz no nl l nm nn">for i in 0..&lt;5 {<br/>  print(i)<br/>}</span><span id="6119" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>for (i in 1..5) {<br/>  print(i)<br/>}</span><span id="57da" class="nj mf iu ne b gz no nl l nm nn">for (x in 0 until 5) println(x)</span></pre><p id="c827" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Kotlin中的<code class="fe nb nc nd ne b">until</code>操作符类似于Swift中的<code class="fe nb nc nd ne b">..&lt;</code>。两者都不包括最后一个值。在<code class="fe nb nc nd ne b">for</code>循环迭代中还有一种增加或减少值的替代方法。</p><p id="cfb8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Swift为我们呈现了一个<code class="fe nb nc nd ne b">stride</code>操作符，它有两个变体:<code class="fe nb nc nd ne b">stride(from:to:by:)</code>(不包括<code class="fe nb nc nd ne b">to</code>值)和<code class="fe nb nc nd ne b">stride(from:through:by:)</code>(包括直通值)。</p><p id="ada6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">科特林为我们提供了<code class="fe nb nc nd ne b">step</code>来控制增量，以及<code class="fe nb nc nd ne b">downTo</code>来以相反的顺序创建步骤。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="5f91" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>for i in stride(from: 0, to: 1, by: 0.2) {<br/>    print(i)<br/>}</span><span id="c281" class="nj mf iu ne b gz no nl l nm nn">for i in stride(from: 5, through: 0, by: -1) {<br/>    print(i)<br/>}</span><span id="4ebb" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>for (i in 0..1 step 0.2) print(i)</span><span id="26f1" class="nj mf iu ne b gz no nl l nm nn">for (i in 5 downTo 0 step 1) print(i)</span></pre><h2 id="8399" class="nj mf iu bd mg np nq dn mk nr ns dp mo lj nt nu mq ln nv nw ms lr nx ny mu nz bi translated">交换语句</h2><p id="da37" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Swift中的<code class="fe nb nc nd ne b">switch</code>语句在Kotlin中被称为<code class="fe nb nc nd ne b">when</code>。虽然Swift <code class="fe nb nc nd ne b">switch</code>需要详尽，但Kotlin的<code class="fe nb nc nd ne b">when</code>语句不需要(除非该语句返回值)。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="3d2e" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>let x = 2<br/>switch x {<br/>  case 0:<br/>    print("x is 0")<br/>  case 1:<br/>    print("x is 1")<br/>  default:<br/>    print("x is neither 0 nor 1")<br/>}</span><span id="ed43" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>val x = 2</span><span id="45f7" class="nj mf iu ne b gz no nl l nm nn">when (x) {<br/>    0 -&gt; print("x is 0")<br/>    1 -&gt; print("x is 1")<br/>    else -&gt; {<br/>        print("x is neither 0 nor 1")<br/>    }<br/>}</span></pre><p id="e5e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nb nc nd ne b">switch</code>和<code class="fe nb nc nd ne b">when</code>语句都非常强大，提供的不仅仅是嵌套条件——模式匹配、多案例和类型转换。在Swift中，通过使用<code class="fe nb nc nd ne b">case let</code>或范围操作符，您可以进行部分匹配。以下示例显示了带有<code class="fe nb nc nd ne b">Optional</code> s和多个案例的模式匹配。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="693e" class="nj mf iu ne b gz nk nl l nm nn"><br/>let name : String? = "Anupam"<br/>let password : Int = 123</span><span id="f113" class="nj mf iu ne b gz no nl l nm nn">let info = (name, password)</span><span id="6c02" class="nj mf iu ne b gz no nl l nm nn">switch info {<br/>case let (.some(name), .some(password)):<br/>    print("\(name) password is \(password)")<br/>case let (.some(name), nil):<br/>    print("\(name) cannot recall the password.")<br/>case (.none, .some(_)):<br/>    print("Some password but no name.")<br/>case (.none, _):<br/>    print("No username or password. ")<br/>}</span></pre><p id="6978" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Kotlin为我们提供了<code class="fe nb nc nd ne b">in</code>(参数范围)和<code class="fe nb nc nd ne b">is</code>(智能转换)操作符，同时还允许您在<code class="fe nb nc nd ne b">when</code>语句中不传递任何参数。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="1715" class="nj mf iu ne b gz nk nl l nm nn">val x = 20<br/>when (x) {<br/>    in 0..7, 8, 9 -&gt; print("single digit")<br/>    10 -&gt; println("10")<br/>    in 11..99 -&gt; print("double digits")<br/>    !in 100...999 -&gt; print("four or more digits")<br/>    else -&gt; print("three digits")<br/>}</span><span id="1f57" class="nj mf iu ne b gz no nl l nm nn">when{<br/>   x &gt; 5 -&gt; print("Greater than 5")<br/>   else  -&gt; print("Anything")<br/>}</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="e9e1" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">类、函数、构造函数和继承</h1><p id="f905" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">尽管Kotlin和Swift中的类和函数的基本声明几乎相同，但还是有一些对比差异。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="328d" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>class Vehicle {<br/>    var numberOfWheels = 2<br/>    func describeMe() -&gt; String {<br/>        return "Classy"<br/>    }<br/>}</span><span id="b14f" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>class Vehicle {<br/>    var numberOfWheels = 2<br/>    fun describeMe() : String {<br/>        return "Classy"<br/>    }<br/>}</span></pre><p id="5892" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认情况下，上面定义的Kotlin类、函数和属性是<code class="fe nb nc nd ne b">final</code>。这意味着它们不能被遗传。为了允许子类化或覆盖，我们需要将它们声明为<code class="fe nb nc nd ne b">open class</code>和<code class="fe nb nc nd ne b">open fun</code>。</p><p id="ced8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，Swift函数支持内部和外部参数名，这极大地提高了函数的可读性。在Kotlin中，可以使用<code class="fe nb nc nd ne b">fun sum(<strong class="lc iv">vararg</strong> numbers: Int)</code>指定可变数量的参数，而在Swift中，使用以下签名:<code class="fe nb nc nd ne b">func sum(_ numbers: Int<strong class="lc iv">...</strong>)</code>。</p><p id="7ab5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Kotlin和Swift中的构造函数以不同的方式实现。Kotlin允许您在类头本身中声明主构造函数，并带有设置默认值的选项。在类体中使用<code class="fe nb nc nd ne b">constructor</code>关键字声明二级构造函数。如果类包含一个主构造函数，那么次构造函数必须使用<code class="fe nb nc nd ne b">this</code>来引用它。此外，还有一个<code class="fe nb nc nd ne b">init</code>块，每当类被初始化时它就运行。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ob oc l"/></div></figure><p id="b721" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认情况下，构造函数参数是<code class="fe nb nc nd ne b">val</code>，除非您将它们指定为<code class="fe nb nc nd ne b">var</code>。对于Kotlin中的子类，如果没有定义主构造函数，则次构造函数必须使用<code class="fe nb nc nd ne b">super</code>关键字来调用基类或委托给另一个使用<code class="fe nb nc nd ne b">this</code>的构造函数。</p><p id="744c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Swift中，<code class="fe nb nc nd ne b">init</code>块实际上代表了主构造函数。它是一个指定的初始化器，负责设置这个类的所有属性。Swift还有一个被称为<code class="fe nb nc nd ne b">convenience</code>初始值设定项的二级初始值设定项——它通过让您为一些属性分配默认值来指定一级初始值设定项。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ob oc l"/></div></figure><p id="cb30" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Swift实际上通过包含<code class="fe nb nc nd ne b">required</code>和自动初始化器继承抢了Kotlin的风头。在任何初始化式上设置的<code class="fe nb nc nd ne b">required</code>关键字强制你在子类中实现该初始化式。自动初始化器继承遵循两条规则:</p><ul class=""><li id="a901" class="od oe iu lc b ld le lg lh lj of ln og lr oh lv oi oj ok ol bi translated">不要在子类中定义任何指定的初始化器——它们会被自动继承</li><li id="856c" class="od oe iu lc b ld om lg on lj oo ln op lr oq lv oi oj ok ol bi translated">实现基类的所有指定的初始化器。所有方便的初始化器都将被隐式继承。</li></ul></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="a4e4" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">结构和数据类</h1><p id="2b27" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Kotlin的主构造函数语法使得创建数据类——用于存储数据——变得容易。但是Kotlin没有办法像Swift中的结构那样创建一个自定义类型来按值传递数据。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="b51a" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>struct Point {<br/>  let lat: Double<br/>  let lng: Double<br/>}</span><span id="a63b" class="nj mf iu ne b gz no nl l nm nn">var point = Point(lat: 23.33, lng: 75.55)</span><span id="f2fe" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>data class Point(val lat: Double, val lng: Double)</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="1460" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">关闭</h1><p id="c829" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Lambda表达式不仅仅是没有名字的函数。闭包是一种lambda类型，它允许您捕获定义范围之外的值。在Swift和Kotlin中，闭包的返回类型都是在<code class="fe nb nc nd ne b">-&gt;</code>之后指定的。Kotlin为单值闭包提供了一个<code class="fe nb nc nd ne b">it</code>参数，可以对<code class="fe nb nc nd ne b">-&gt;</code>进行转义。相反，Swift让你使用<code class="fe nb nc nd ne b">$0</code>、<code class="fe nb nc nd ne b">$1</code>、<code class="fe nb nc nd ne b">$2</code>等等。</p><p id="9efc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然Swift闭包可以定义为<code class="fe nb nc nd ne b">escaping</code>和<code class="fe nb nc nd ne b">non-escaping</code>，但Kotlin闭包默认为<code class="fe nb nc nd ne b">escaping</code>。这与两种语言的内存管理系统有很大关系——Swift使用自动引用计数，而Kotlin使用垃圾收集器。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="326e" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>var square = { (x: Int) -&gt; Int in<br/>  return x * x<br/>}</span><span id="7101" class="nj mf iu ne b gz no nl l nm nn">var cube = {  $0 * $0 * $0}</span><span id="508f" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>var result = 0<br/>myList = listOf(1,2,3,4,5,6,7,8,9,10)<br/>myList.forEach { result+=it }</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="2412" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">扩展ˌ扩张</h1><p id="5742" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Swift中的扩展允许您向类、结构、枚举和协议添加额外的功能，而无需实际扩展它们。在Kotlin中，扩展更像是Java的静态方法。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="1edf" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>extension Double {<br/>    var km: Double { return self * 1_000.0 }<br/>}</span><span id="dcf3" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>val Double.km: Double get() = this * 1000</span></pre><p id="12d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">注意:</strong> Kotlin默认为所有属性声明提供了<code class="fe nb nc nd ne b">get()</code>和<code class="fe nb nc nd ne b">set(value)</code>方法。另一方面，Swift使用更加灵活的computed property语法，包括<code class="fe nb nc nd ne b">get{}</code>和<code class="fe nb nc nd ne b">set{}</code>以及属性观察器<code class="fe nb nc nd ne b">didSet </code>和<code class="fe nb nc nd ne b">willSet</code>，当值发生变化时会被触发。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="ea25" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">接口和协议</h1><p id="b007" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Kotlin中的接口在Swift中被称为<em class="oa">协议</em>。两者都负责定义该类可以遵循的一组函数或属性。不同之处在于Kotlin允许我们在接口中设置默认实现。作为Swift的变通办法，您可以在协议上使用扩展。</p><p id="19a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样对于泛型，Swift允许您在协议中定义一个<code class="fe nb nc nd ne b">associatedType</code>；而对于Kotlin，您可以在定义中使用泛型类型<code class="fe nb nc nd ne b">T</code>。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="566a" class="nj mf iu ne b gz nk nl l nm nn">//Kotlin<br/>interface MyInterface {<br/> var myVariable<strong class="ne iv">:</strong> Int<br/> get() = 0</span><span id="fcce" class="nj mf iu ne b gz no nl l nm nn"> fun printMe()<br/> fun implementMe() {<br/> // do stuff here<br/> }<br/>}</span><span id="dbf4" class="nj mf iu ne b gz no nl l nm nn">//Swift<br/>protocol MyProtocol {<br/>  var myVariable: Int {get}<br/>   <br/>  func printMe()<br/>  func implementMe()</span><span id="c87e" class="nj mf iu ne b gz no nl l nm nn">}<br/><br/>extension MyProtocol {<br/>  var myVariable: Int {<br/>    return 0<br/>  }<br/>}</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="688c" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">列举</h1><p id="9f9b" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Kotlin中的枚举是一个类，它保存一组自定义数据类型的常量。另一方面，在Swift中，<code class="fe nb nc nd ne b">enum</code> s是一等公民，让我们可以为每个案例指定任何类型的相关价值。另一方面，Kotlin的每种类型只能有一个对象。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="c0a6" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/>enum AppVersion {<br/>    case Name(String)<br/>    case Version(Int)<br/>}</span><span id="93e4" class="nj mf iu ne b gz no nl l nm nn">//Kotlin Enum<br/>enum class Week(var shortform: String) {     <br/>Monday("MON"),     <br/>Tuesday("TUE"),     <br/>Wednesday("WED") <br/>}</span><span id="9fcd" class="nj mf iu ne b gz no nl l nm nn">var x = Week.Monday     <br/>println(x.shortform) //prints MON</span></pre><p id="d1fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，Kotlin确实有一个解决方法，就是使用<em class="oa">密封类和</em>来创建不同类型的实例。但是同样，密封类是一个引用类型，它完全复制了Swift的值类型。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="9ac3" class="nj mf iu ne b gz nk nl l nm nn">//Kotlin Sealed Class<br/>sealed class <!-- -->AppVersion<!-- --> {     <br/>class <!-- -->Name<!-- -->(var shortHand: String) : <!-- -->AppVersion<!-- -->()     <br/>class <!-- -->Version<!-- -->(var number: Int) : <!-- -->AppVersion<!-- -->()     <br/>}</span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="9435" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">结束语</h1><p id="4f12" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">最后，Swift中的<code class="fe nb nc nd ne b">lazy</code>允许您将属性的初始化推迟到首次访问。在Kotlin中，同样可以使用delegated properties <code class="fe nb nc nd ne b">by</code>特性来实现。而在Swift中，<code class="fe nb nc nd ne b">lazy</code>是一个只适用于可变属性的关键字——<code class="fe nb nc nd ne b">by lazy</code>接受lambda函数，只适用于不可变的属性(一旦设置就不能更改)。</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="1ee0" class="nj mf iu ne b gz nk nl l nm nn">//Swift<br/><strong class="ne iv">lazy</strong> var name = "ABC"</span><span id="f8b3" class="nj mf iu ne b gz no nl l nm nn">//Kotlin<br/>val name <strong class="ne iv">by lazy</strong> { "ABC" }</span></pre><p id="14f4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望上面提到的Swift和Kotlin的语法和语言实现之间的比较有助于您实现跨平台的平稳过渡。</p><p id="e27f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是一个总结。感谢阅读。</p></div></div>    
</body>
</html>