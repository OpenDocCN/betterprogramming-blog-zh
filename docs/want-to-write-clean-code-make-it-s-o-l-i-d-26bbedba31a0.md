# 想写干净的代码？让它成为神盾局！

> 原文：<https://betterprogramming.pub/want-to-write-clean-code-make-it-s-o-l-i-d-26bbedba31a0>

## 编写功能性的、可重用的、干净的代码的简单原则

![](img/1b40bef663a36269a17bc3e2965c1d0e.png)

在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 上 [Engin Akyurt](https://unsplash.com/@enginakyurt?utm_source=medium&utm_medium=referral) 拍摄的照片

> 代码就像幽默。当你不得不解释它的时候，它是糟糕的。
> 
> —科里屋

作为软件工程师，我们必须牢记的一件重要事情是，我们编写的代码将被其他人看到，他们可能希望在我们所创建的基础上进行构建。请不要让他们的生活更加艰难！

如果您希望您的代码在将来尽可能多地被使用和重用，并且只需要最小的更改，那么您需要编写简洁的代码:

*   很容易理解
*   很容易发现漏洞
*   编辑起来很舒服

当设计一个系统时，这是通过将许多模块组合在一起完成的。

把一个复杂的设计系统想象成一个拼图。模块是拼图块，拼图中的每一块都有且只有一个位置，与特定形状的拼图相连，不能在任何其他位置。

另一方面，设计良好的系统应该更像乐高积木。任何两块乐高积木都可以毫不费力地连接在一起——所有的乐高积木都是兼容的。

在设计一个软件系统的时候，你想把它做得像乐高一样。您希望能够轻松地将模块连接在一起，重用它们，并且仍然了解每个模块在未来的用途。

这就是为什么找到一种评估设计复杂性的方法真的很重要——它将帮助你更好地应用面向对象的设计原则，并构建可控的系统。

任何软件的开发都有两个相关的评估概念:*耦合*和*内聚。*

## **联轴器**

关注一个模块和其他模块之间的复杂性。模块的耦合捕获了模块之间和模块之间连接的*复杂性。*

如果这些模块强烈地相互依赖，那么这个模块就是所谓的*紧耦合* 模块——这就像拼图。如果一个模块不强烈依赖于其他模块，并且发现很容易连接到其他模块，那么这个模块就*松散耦合* 到其他模块——这就像乐高。

耦合是通过模块间关系的数量来衡量的。也就是说，随着模块间调用次数的增加或共享数据量的增加，耦合度也会增加。所以，从逻辑上讲，高耦合的设计会有更多的错误。

## **衔接**

关注模块内部的复杂性。它测量给定模块中各功能之间的关系强度。

如果一个模块有明确的目的，并且执行一个且只有一个任务，这意味着这个模块有*高内聚。*另一方面，如果模块试图执行一个以上的任务，并且封装一个以上的目的，那么这个模块就有*低内聚*。

最佳实践表明，如果模块有不止一个职责，那么可能是时候将模块的职责分开了。

您希望您的模块具有低耦合性或松散耦合性，而不是紧密耦合性，并且具有高内聚性。

因此，面向对象编程包含了帮助您理解特定设计模式和软件架构需求的原则。

在面向对象编程的世界里，有许多设计规则、模式和原则。这些原则中的五条通常被归为一类，称为 S.O.L.I.D 原则——由[罗伯特·c·马丁(鲍勃叔叔)](https://en.wikipedia.org/wiki/Robert_Cecil_Martin)定义的规则。

坚实的原则告诉我们如何将函数和数据结构组织成类，以及这些类应该如何一起工作。

# 什么是神盾局？

![](img/0a3aa4c622c2fc413ed961264d672987.png)

照片由[亨特·哈利](https://unsplash.com/@hnhmarketing?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 上拍摄

*   单一责任原则。(SRP)
*   o:开闭原则。(铬)
*   l:利斯科夫替代原理。(LSP)
*   I:界面分离原理。(ISP)
*   d:依存倒置原则。(蘸)

再来多讲讲每个原理。

# 单一责任原则

> 一个类应该只有一个责任。

这个原则说，类应该只有一个明确的工作和一个责任。

## **但是什么是责任呢？**

一个类必须被改变的原因应该只有一个。

你的类的职责越多，你就越需要经常改变它。

在你做出任何改变之前，你需要问一个简单的问题:“你的班级的职责是什么？”

如果你的答案中包含“和”这个词，你很可能违反了单一责任原则。

用一个例子就能很好地理解原理。想象一个执行以下操作的类雇员:

*   计算付款。
*   提交报告。
*   将数据保存在数据库中。

在这里，类有多重责任，有太多不同的理由改变。因此，它不符合单一责任原则。

为了应用单一责任原则，你需要将不同的责任分成不同的类别。

这一原则使软件更容易实现，防止未来变化后的意外副作用，并减少耦合。

*注意:这个原则不仅适用于类，也适用于软件组件和微服务。*

# o:开闭原则(CR)

> 软件实体(类、模块、功能)应该对扩展开放，但对修改关闭。

Robert C. Martin 认为这个原则是“面向对象设计最重要的原则”

需求会随着时间而变化。开闭原则的目标是编写不必在每次需求变化时都要改变的代码。

*我们如何在不改变模块本身的情况下改变模块的功能？*

开闭原则指出，如果需求发生变化，这些变化应该通过添加新代码来实现，而不是通过更改已经工作的旧代码来实现。

## **抽象是关键**

一个模块操纵一个抽象是可能的。该模块可以关闭进行修改，因为它依赖于一个固定的抽象。并且可以通过创建抽象的新衍生物来扩展模块的行为。

这个原则使您能够编写健壮的、可维护的和可重用的软件组件。

开闭原则说:永远不要重写代码。

# l:利斯科夫替代原理。(LSP)

> 基本类型必须可由其子类型替换

这个原则定义了一个子类的对象必须可以替换其超类的对象，而不会破坏应用程序。

这就要求子类的对象有和它们的超类相同的行为，如果一个超类能做一件事，那么子类也必须能做和它的超类一样的事。

利斯科夫替代原理与遗传密切相关。它通过关注超类及其子类型的行为扩展了开闭原则。

*举个例子就能很好的理解原理。*

假设有一个类`Animal`执行以下操作:

*   `Speak`
*   `Eat`
*   `Walk`

我们有子类`cat`，是动物，继承了超类`Animal`，有它的行为，说话，吃饭，走路。因此，这适用利斯科夫替代原则。

但是假设有一个子类`snail`，它仍然是动物，但是不能说话，所以它不能继承超类`Animal`。这打破了利斯科夫替代原理。

总而言之，如果你说的关于父类型的事情是真的，那么它在整个链中都必须是真的。如果您声明父类型可以做一些事情，那么所有子类型也需要能够做这些事情。

# I:界面分离原理。(ISP)

> 不应该强迫客户依赖他们不使用的接口。

根据接口分离原则，客户永远不应该被迫实现他们不需要或对他们不重要的方法。

这意味着小的特定接口比大的接口更好。

分离=分裂

因此，接口分离原则意味着将你的接口分成更小的部分。

*举个例子就能很好的理解原理。*

假设您有一个类`Restaurant interface`，它执行以下操作:

*   `Pay Online`
*   `Order Online`
*   `Pay in Person`
*   `Order in person`

`Restaurant`接口定义了四种方法:`online payment`、`in-person payment`、`online order`、`in-person order`。

我们有两个子类:

*   在线客户端
*   面对面的客户

由于这四个方法是`Restaurant`接口的一部分，任何子类都必须实现这四个方法。但是由于子类`Online Client`不需要实现`Pay in Person`或者`Order in person`，所以即使它不需要，也会被强制使用这些方法。

此处的`Restaurant`接口打破了接口分离原则和单一责任原则，因为不同的支付方式被分组到单一接口中。

为了克服这个问题，我们需要将支付和订单功能分成两个独立的类:`Payment`接口和`order`接口。

每个客户端分别使用`Payment interface`和`Order interface`的一个实现。比如`Online Client`会用`Online Payment`和`Online Order`。

接口分离原则有助于保持类和接口的清晰、紧凑和切题。

# d:依存倒置原则。(蘸)

> 抽象不应该依赖于细节。细节应该依赖于抽象。

这个原则声明高级模块不应该依赖于低级模块，但是两者都应该依赖于抽象。

抽象不应该依赖于细节，但是细节应该依赖于抽象。

这与开闭原则和利斯科夫替换原则密切相关，因为它们都依赖于接口。

用一个例子就可以很好地理解这个原理。

电脑鼠标有很多种。现在，假设每台计算机只使用特定类型的鼠标。您必须购买您的计算机系统支持的确切类型的鼠标。在这种情况下，如果您的电脑只能使用无线鼠标，那么有线或轨迹球鼠标或任何其他类型的鼠标都不能在您的电脑上使用。幸运的是，它不是这样工作的，因为计算机不依赖于特定的鼠标端口或类型。无论你的鼠标是什么类型，它都有一个通用的界面(至少有两个按钮和移动屏幕指针的能力)。

关键点:

*   为了挽救团队的生命，最好编写可读性强、可重用且切中要点的代码。
*   坚实的原则是编写更好代码的 OOP 规则。
*   固体的五个原则服务于同一点。