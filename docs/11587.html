<html>
<head>
<title>Solana Programming Primer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">索拉纳编程初级读本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solana-programming-primer-1c8aae509346?source=collection_archive---------8-----------------------#2022-04-01">https://betterprogramming.pub/solana-programming-primer-1c8aae509346?source=collection_archive---------8-----------------------#2022-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ae3a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">茄遇锈(无锚)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fe34f8cb9872911762e43c735aab4d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YERF5M-9BwJilj3uBwpNEw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>在<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在2022年2月的最后一刻写了这篇文章，以便在Illini Blockchain的Solana Onboarding期间提供额外的指导/资源。</p><p id="ab34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它伴随着我2022年1月参加的Jump Crypto x Solana Labs x pyt boot camp的<a class="ae kv" href="https://github.com/IlliniBlockchain/solana-onboarding/tree/master/echo-skeleton" rel="noopener ugc nofollow" target="_blank"> echo项目</a>。</p><p id="dfa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想我应该把这个作为公开记录。这概述了用Rust编写的Solana程序开发的基础，没有流行的框架锚。</p><h1 id="cf3f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先决条件</h1><p id="04e2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对<a class="ae kv" href="https://docs.solana.com/developing/programming-model/overview" rel="noopener ugc nofollow" target="_blank"> Solana编程模型</a>的基本理解。<br/>基本<a class="ae kv" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">生锈</a> ( <a class="ae kv" href="https://doc.rust-lang.org/rust-by-example/" rel="noopener ugc nofollow" target="_blank">以身作则</a>)。</p><h1 id="c194" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">项目文件结构</h1><p id="104e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是一个索拉纳项目将包括什么的基本例子。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a6b0" class="mu lt iq mq b gy mv mw l mx my">project/<br/>  js/<br/>  program/<br/>    src/<br/>      entrypoint.rs<br/>      error.rs<br/>      instruction.rs<br/>      lib.rs<br/>      processor.rs<br/>      state.rs<br/>    tests/<br/>    Cargo.toml</span></pre><p id="101f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单解释一下主要元素:</p><ul class=""><li id="a4bc" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated"><code class="fe ni nj nk mq b">js/</code> —用于测试的客户端脚本。</li><li id="f777" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated"><code class="fe ni nj nk mq b">entrypoint.rs</code>—<code class="fe ni nj nk mq b">processor.rs</code>上的包装器，提供区块链上的接入点。</li><li id="85ac" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated"><code class="fe ni nj nk mq b">error.rs</code> —自定义错误定义。</li><li id="25e7" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated"><code class="fe ni nj nk mq b">instruction.rs</code> —表示不同指令及其参数的枚举定义。</li><li id="00f1" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated"><code class="fe ni nj nk mq b">lib.rs</code> —导出模块，以便在其他板条箱中轻松访问。</li><li id="1cad" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated"><code class="fe ni nj nk mq b">processor.rs</code> —实际运行代码的定义。</li><li id="ce73" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated"><code class="fe ni nj nk mq b">state.rs</code> —账户数据序列化的结构定义。</li><li id="9ba4" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated"><code class="fe ni nj nk mq b">Cargo.toml</code> —定义板条箱元数据和依赖关系。</li></ul><h1 id="4f93" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">开发流程</h1><ol class=""><li id="3d59" class="mz na iq ky b kz mk lc ml lf nq lj nr ln ns lr nt nf ng nh bi translated">修改程序并部署。</li></ol><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8a2f" class="mu lt iq mq b gy mv mw l mx my">cargo build-bpf // builds your program - make sure you're in your program's root directory</span><span id="0404" class="mu lt iq mq b gy nu mw l mx my">solana program deploy [PATH_TO_DOT_SO_FILE]</span><span id="237c" class="mu lt iq mq b gy nu mw l mx my">// example: solana program deploy /Users/alecchen/Documents/Code/solana-onboarding/echo-skeleton/program/target/deploy/echo.so</span></pre><p id="9218" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.运行客户端脚本进行测试。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c9bb" class="mu lt iq mq b gy mv mw l mx my">// javascript<br/>node [SCRIPT_FILENAME]<br/>// example: node index.js</span></pre><p id="5f60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.客户端要么成功并在块浏览器上打印到事务的链接，要么它将发出失败事务的散列，然后您将它复制并粘贴到块浏览器中。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4ceb" class="mu lt iq mq b gy mv mw l mx my">// example success output:<br/>&lt;https://explorer.solana.com/tx/85CVVw4CrmNbzqCXEmRDF3LEUFEymc4s1pUtDK1urcV6R3jbRjdJNWGjb24Trbt8bZjN5fJkqA55GjNvoBLubfE?cluster=devnet&gt;<br/>Echo Buffer Text: asdfff<br/>Success<br/><br/>// example fail output:<br/>Error: Transaction 4MDQWBNkuRAf59gjqgoFBDLq76UPVS73LUktTP1TJ8op1Qtvw2UsxcRw6tMHKo5mjsWEaZWC5CLePtV44YTFsUA3 failed ({"err":{"InstructionError":[1,"InvalidInstructionData"]}})<br/>    at sendAndConfirmTransaction (/Users/alecchen/Documents/Code/solana-onboarding/echo-skeleton/js/node_modules/@solana/web3.js/lib/index.cjs.js:2981:11)<br/>    at processTicksAndRejections (node:internal/process/task_queues:96:5)<br/>    at async main (/Users/alecchen/Documents/Code/solana-onboarding/echo-skeleton/js/index.js:75:14)<br/>// copy 4MDQWBNkuRAf59gjqgoFBDLq76UPVS73LUktTP1TJ8op1Qtvw2UsxcRw6t into a block explorer (make sure you're on devnet!)</span></pre><p id="f160" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Solana的块资源管理器对调试非常有帮助！花些时间探索输出的一切。它将显示许多有用的信息，包括帐户输入、它们的可写/签名者标志、SOL和<code class="fe ni nj nk mq b">spl-token</code>余额变化、指令和调用的子指令，以及程序日志，您可以在其中找到打印语句和错误消息。</p><p id="804f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.重复步骤1–3。</p><h1 id="bd8e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">程序代码</h1><p id="3bfc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当您实现Solana程序指令时，您的代码通常由3个主要部分组成:</p><ol class=""><li id="1205" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr nt nf ng nh bi translated">获取帐户和反序列化</li><li id="f147" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nt nf ng nh bi translated">帐户验证</li><li id="242d" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nt nf ng nh bi translated">逻辑和功能</li></ol><h1 id="7c45" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">获取帐户和反序列化</h1><p id="d99f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">帐户以数组<code class="fe ni nj nk mq b">AccountInfo</code>的形式传入。要使用这些，您将定义一个迭代器并检索对帐户的引用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是你怎么知道哪个账户是哪个账户呢？您需要在某处指定您期望的帐户，然后1)由客户端传递正确的帐户数量和顺序，2)由您作为程序开发人员确保您的程序仅在您收到正确的帐户时运行(这部分是帐户验证部分)。您应该注意到在echo框架中，在客户端上定义指令时传递的帐户与<code class="fe ni nj nk mq b">instruction.rs</code>中预期/概述的帐户相匹配。</p><p id="f572" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，关于反序列化。默认情况下，帐户数据只是一个字节数组。如果您希望某个帐户的数据以某种特定的结构到达，您可以反序列化它以有组织的方式访问该数据。您需要预先定义该结构，并在其中包含某种反序列化字节的方法(这些方法通常被定义为Rust中的特征)。SPL程序通常有使用<code class="fe ni nj nk mq b">Pack</code>特征的反序列化方法。如果您正在定义自己的结构，<a class="ae kv" href="https://github.com/near/borsh" rel="noopener ugc nofollow" target="_blank"> Borsh </a>是一个为常见数据类型预定义方法的库。</p><p id="3a9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe ni nj nk mq b">spl-token</code>计划薄荷账户的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="994c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们自己定义的结构示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="dc63" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">帐户验证</h1><p id="6e66" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如前所述，您依赖于客户端传递符合您期望的帐户。这为客户端传递可能会破坏代码功能的帐户提供了机会。</p><p id="a5d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您有一个基本的交换程序，其中该程序需要这4个帐户(以及其他帐户):您的令牌a保管库、您的令牌b保管库、交换程序的令牌a保管库以及交换程序的令牌b保管库。它从您的保管库中取出一定数量的令牌a，存入其自己的保管库，然后从其自己的保管库取出一定数量的令牌b，并存入您的保管库。现在，如果您为自己的令牌提供一个保险库来代替交换程序的保险库，会怎么样呢？如果它没有验证帐户，那么它会将令牌a存入您的金库，而您将免费获得令牌b！真实的Solana程序中的一个例子:二月初的虫洞漏洞是由于使用了一个不赞成使用的助手函数，该函数没有正确地验证帐户。</p><p id="6573" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">验证帐户最常见的情况是使包含特定数据的帐户无效，确保帐户是特定的PDA，并检查程序是否是特定的程序。</p><h2 id="dd0e" class="mu lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated"><strong class="ak">验证账户数据</strong></h2><p id="6648" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了验证数据，有两个部分:</p><ol class=""><li id="f2ce" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr nt nf ng nh bi translated">确保帐户可以正确反序列化</li><li id="7fe5" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nt nf ng nh bi translated">确保数据符合特定的约束条件。</li></ol><p id="998b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，确保发送交易的用户实际上是他们想要从中转移令牌的令牌帐户的所有者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d919" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在开始，我将省略imports和getting accounts部分，使事情不那么混乱。</p><h2 id="2a5e" class="mu lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated"><strong class="ak">验证PDA</strong></h2><p id="7cd2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">另一种验证帐户的常见方法是使用PDA。如果帐户是PDA，您可以通过自己查找PDA并检查密钥是否匹配来确保它是正确的帐户。你可以通过两种方式做到这一点:1)如果你只有种子而没有凸起，<code class="fe ni nj nk mq b">find_program_address</code>和2)如果你有凸起和种子，<code class="fe ni nj nk mq b">create_program_address</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="621e" class="mu lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated"><strong class="ak">检查程序id</strong></h2><p id="50b6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所有的程序都是账户，如你所知，如果你的程序与某个账户交互，它必须被传递到指令中。因此，如果你的程序调用另一个程序，客户必须传递那个程序的帐号。</p><p id="b7be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这带来了一个安全问题。现在，客户端可以传入一个程序，该程序实现了您的程序试图访问的相同指令，但却附加了一些恶意行为。为此，我们必须检查传入的程序帐户是否正确。</p><p id="29f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常你会和一些著名的程序一起工作，他们会有公开的Rust crates，暴露出某种<code class="fe ni nj nk mq b">id()</code>功能，让你很容易检查，例如索拉纳本地程序，SPL程序。其他时候，您可能只需要硬编码程序id。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="4f1f" class="mu lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated"><strong class="ak"> assert_msg helper </strong></h2><p id="a7d5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我在训练营中被介绍的一个很好的助手功能是<code class="fe ni nj nk mq b">assert_msg</code>。当您抛出一个错误时，它只会打印出与该错误类型相关的消息。您可能在不同的上下文中使用相同的错误，在不同的上下文中，额外的消息将有助于调试。<code class="fe ni nj nk mq b">assert_msg</code>正是如此。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="2e36" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">逻辑和功能</h1><p id="b8ee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在你确保了你的账户都是正确的之后，你实际上可以写代码了。在这里，你可以随心所欲地做任何事情，但无论如何，你可能会做以下两件事情中的一件或两件:</p><ol class=""><li id="fd15" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr nt nf ng nh bi translated">修改帐户数据</li><li id="794f" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nt nf ng nh bi translated">调用其他程序</li></ol><h2 id="6776" class="mu lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated"><strong class="ak">修改账户数据</strong></h2><p id="8cc8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">修改帐户数据的两种方法:1)直接修改字节，2)定义一个结构并将数据序列化到帐户字节数组中。</p><p id="44d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直接修改:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9e8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">序列化数据(使用Borsh):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="8259" class="mu lt iq bd lu nx ny dn ly nz oa dp mc lf ob oc me lj od oe mg ln of og mi oh bi translated"><strong class="ak">跨程序调用</strong></h2><p id="c30a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通常在程序中，你会写你必须调用区块链上的其他程序。对于这些，您将主要使用两个函数:<code class="fe ni nj nk mq b">[invoke](&lt;https://docs.rs/solana-program/1.6.4/solana_program/program/fn.invoke.html&gt;)</code>用于常规的跨程序调用，而<code class="fe ni nj nk mq b">[invoke_signed](&lt;https://docs.rs/solana-program/1.6.4/solana_program/program/fn.invoke_signed.html&gt;)</code>用于PDA需要签名的跨程序调用。</p><p id="fde9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们本质上是一样的，除了<code class="fe ni nj nk mq b">invoke_signed</code>你为PDA传递种子(附加了凹凸)。</p><p id="90c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两者的例子在<a class="ae kv" href="https://gist.github.com/alecchendev/c872ed76541b339ce3d71c72783c7d7b" rel="noopener ugc nofollow" target="_blank">这里</a>都有。</p><p id="f6d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到第一个参数采用了<code class="fe ni nj nk mq b">Instruction</code>类型。像所有指令一样，它包括帐户、程序id和输入数据。</p><p id="0036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，正如你在例子中看到的，通常程序会有包装函数来创建指令，这使得我们更容易做到这一点。您可以通过检查源代码来了解如何创建原始指令。</p></div></div>    
</body>
</html>