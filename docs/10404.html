<html>
<head>
<title>SOLID Principles With (almost) Real-Life Examples in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的原则和(几乎)真实的Java实例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solid-principles-with-almost-real-life-examples-in-java-b292a4e2c18b?source=collection_archive---------0-----------------------#2022-01-05">https://betterprogramming.pub/solid-principles-with-almost-real-life-examples-in-java-b292a4e2c18b?source=collection_archive---------0-----------------------#2022-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4ad2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对5个坚实原则的不同看法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/4f3444c7ffcd3df249831f381c0dcac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*cRdO9c0N4P0QSg9LnJPTeg.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Adobe股票图像</p></figure><p id="5e91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">坚实的原则是软件世界中一些最古老的规则。它们使我们能够编写可维护、可读、可重用的代码。在这篇文章中，我试图完成一个有点真实的例子，遵守坚实的原则。</p><h1 id="4c2b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">1.单一责任</h1><p id="a279" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">每个类应该只有一个唯一的目的，不要充满过多的功能。考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="299d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顾名思义，这个类是为散列密码而实现的。它不应该负责将它们保存到数据库中。每个班级都应该有一个要完成的责任。</p><p id="17f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不应该有“<a class="ae mm" href="https://herownhelloworld.medium.com/heres-all-one-should-know-about-god-class-in-java-e318acbb9717" rel="noopener">god classes”</a>有各种各样的功能，有太多的事情要完成。相反，我们应该尽可能模块化地编写我们的类。在另一个类中实现保存操作。</p><h1 id="2bf1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">2.开闭原理</h1><p id="f55d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">类应该对扩展开放，对修改关闭。</p><p id="59ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">换句话说，您不应该为了实现新特性而重写现有的类。</p><p id="9833" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们继续我们的密码哈希例子。假设我们希望我们的类能够使用多种算法选项进行哈希运算。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d93f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们用这种方式实现，我们会把O破坏得很糟糕。每实现一个新的算法，我们都需要修改现有的类，看起来很难看。</p><p id="d136" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢OOP，我们有了抽象。我们应该使我们的初始类成为一个接口/抽象类，并在具体的类中实现算法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">这些类的排序可能会很奇怪，但不幸的是，当把它们放在一起时，gist是按字母顺序排序的。</p></figure><p id="2422" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们可以在不触及现有代码库的情况下添加新算法。</p><h1 id="55ac" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">3.利斯科夫替代原理</h1><p id="67c6" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">子类应该能够实现其父类的每个特性，并且可以被视为其父类。</p><p id="caf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了演示我们的例子，让我们创建模型(数据)类来使用我们的散列算法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="07f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们为其他编码实现了同样的功能…</p><p id="83ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了满足Liskov规则，Hashed的每个其他扩展都应该使用散列函数的有效实现并返回一个散列。</p><p id="e85d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果我们使用一个名为“NoHash”的类来扩展Hashed类，该类使用一个返回完全相同的密码而没有任何编码的实现，这将违反规则，因为Hashed的一个子类应该具有密码的散列值。</p><h1 id="6a17" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">4.界面分离原理</h1><p id="ffee" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">接口不应该强迫类实现它们不能做的事情。大的接口要分成小的。</p><p id="1abb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑我们给接口增加解码功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="62cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将打破这条定律，因为我们的算法之一SHA256实际上是不可解密的(它是一个单向函数)。相反，我们可以向适用的类添加另一个接口来实现它们的解码算法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="0d60" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">5.从属倒置原则</h1><p id="1122" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">组件应该依赖于抽象，而不是具体化。</p><p id="a31f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有如下的密码服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="cbed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们违反了原则，因为我们将<code class="fe mn mo mp mq b">Base64Hasher</code>和<code class="fe mn mo mp mq b">PasswordService</code>紧密耦合。</p><p id="5f6b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将它们解耦，让客户端注入构造函数所需的哈希服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="44db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好多了。我们可以很容易地改变散列算法。我们的服务不关心算法，由客户选择。我们不依赖于具体的实现，而是依赖于抽象。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="a923" class="my lo iq bd lp mz na dn lt nb nc dp lx la nd ne lz le nf ng mb li nh ni md nj bi translated">参考</h2><p id="b885" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">https://www.baeldung.com/solid-principles<a class="ae mm" href="https://www.baeldung.com/solid-principles" rel="noopener ugc nofollow" target="_blank"/></p><p id="1997" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mm" href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design" rel="noopener ugc nofollow" target="_blank">https://www . digital ocean . com/community/conceptual _ articles/s-o-l-I-d-first-five-principles-of-object-oriented-design</a></p></div></div>    
</body>
</html>