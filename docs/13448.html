<html>
<head>
<title>FastAPI Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FastAPI最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fastapi-best-practices-1f0deeba4fce?source=collection_archive---------0-----------------------#2022-08-29">https://betterprogramming.pub/fastapi-best-practices-1f0deeba4fce?source=collection_archive---------0-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fe59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们在初创公司生产了1.5年之后，形成了一份坚持己见的最佳实践和惯例清单。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/b42cd7adb284d1c1c2c24babaa8c3750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WtrpbdU2MHnQvoyt5VOtUg.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">DALL-E生成的图像，一个潮人坐在宽大的垂直屏幕前</p></figure><p id="49af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管FastAPI是一个很棒的框架，有很棒的文档，但如何为初学者构建更大的项目并不十分明显。</p><p id="a4cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去1.5年的生产中，我们一直在做一些好的和坏的决定，这些决定极大地影响了我们的开发者体验。其中有一些值得分享。</p><p id="f9cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">内容</strong></p><ol class=""><li id="bf9c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">项目结构。一致且可预测</li><li id="e69a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">过度使用Pydantic进行数据验证</li><li id="4438" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用数据验证与数据库的依赖关系</li><li id="ae1f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">分离和重用依赖关系。依赖关系调用被缓存</li><li id="f92c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果您只有阻塞I/O操作，请不要让您的路由异步</li><li id="1e59" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">迁徙。蒸馏器</li><li id="1cdc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">background tasks &gt; asyncio . create _ task</li><li id="6af9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">小心动态重力场</li><li id="0d17" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">分块保存文件</li><li id="725e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果必须使用sync SDK，那么在线程池中运行它。</li></ol><p id="643b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">本文只包含了我们遵循的部分指南，所以请随意查找github的原始资源库</em><a class="ae mh" href="https://github.com/zhanymkanov/fastapi-best-practices" rel="noopener ugc nofollow" target="_blank"><em class="mg"/></a><em class="mg">，其中有详细的最佳实践的完整列表，已经获得了一些积极的反馈(在</em><a class="ae mh" href="https://www.reddit.com/r/Python/comments/wrt7om/fastapi_best_practices/" rel="noopener ugc nofollow" target="_blank"><em class="mg">r/Python</em></a><em class="mg">中有一天排名第一的热帖，在GitHub上第一周就获得了250颗星)。</em></p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="f1b4" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">1.项目结构。一致且可预测</h1><p id="bef5" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">有许多方法来构建项目，但是最好的结构是一致的、直接的、没有惊喜的结构。</p><ul class=""><li id="f39d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nm ly lz ma bi translated">如果看项目结构不能给你一个项目是关于什么的概念，那么结构可能是不清楚的。</li><li id="8a47" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nm ly lz ma bi translated">如果你不得不打开包来理解什么模块位于其中，那么你的结构是不清楚的。</li><li id="16e6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nm ly lz ma bi translated">如果文件的频率和位置感觉是随机的，那么你的项目结构是坏的。</li><li id="3ba4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nm ly lz ma bi translated">如果看模块的位置和名字不能让你知道里面是什么，那么你的结构是非常糟糕的。</li></ul><p id="1daa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然Sebastián Ramírez 提出的项目结构(其中我们根据文件的类型(例如api、crud、模型、模式)来分离文件)对于范围较少的微服务或项目来说是很好的，但是我们不能将其放入我们具有大量域和模块的monolith中。</p><p id="984f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现一个更具可扩展性和可发展性的结构受到了网飞<a class="ae mh" href="https://github.com/Netflix/dispatch" rel="noopener ugc nofollow" target="_blank">调度</a>的启发，做了一些小的修改。</p><pre class="kh ki kj kk gt np nq nr ns aw nt bi"><span id="4cde" class="nu mq iq nq b gy nv nw l nx ny">fastapi-project<br/>├── alembic/<br/>├── src<br/>│   ├── auth<br/>│   │   ├── router.py<br/>│   │   ├── schemas.py  # pydantic models<br/>│   │   ├── models.py  # db models<br/>│   │   ├── dependencies.py<br/>│   │   ├── config.py  # local configs<br/>│   │   ├── constants.py<br/>│   │   ├── exceptions.py<br/>│   │   ├── service.py<br/>│   │   └── utils.py<br/>│   ├── aws<br/>│   │   ├── client.py  # client model for external service communication<br/>│   │   ├── schemas.py<br/>│   │   ├── config.py<br/>│   │   ├── constants.py<br/>│   │   ├── exceptions.py<br/>│   │   └── utils.py<br/>│   └── posts<br/>│   │   ├── router.py<br/>│   │   ├── schemas.py<br/>│   │   ├── models.py<br/>│   │   ├── dependencies.py<br/>│   │   ├── constants.py<br/>│   │   ├── exceptions.py<br/>│   │   ├── service.py<br/>│   │   └── utils.py<br/>│   ├── config.py  # global configs<br/>│   ├── models.py  # global models<br/>│   ├── exceptions.py  # global exceptions<br/>│   ├── pagination.py  # global module e.g. pagination<br/>│   ├── database.py  # db connection related stuff<br/>│   └── main.py<br/>├── tests/<br/>│   ├── auth<br/>│   ├── aws<br/>│   └── posts<br/>├── templates/<br/>│   └── index.html<br/>├── requirements<br/>│   ├── base.txt<br/>│   ├── dev.txt<br/>│   └── prod.txt<br/>├── .env<br/>├── .gitignore<br/>├── logging.ini<br/>└── alembic.ini</span></pre><p id="8787" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个包需要来自其他包的服务或依赖项时—使用显式模块名称导入它们。</p><pre class="kh ki kj kk gt np nq nr ns aw nt bi"><span id="9318" class="nu mq iq nq b gy nv nw l nx ny">from src.auth import constants as auth_constants<br/>from src.notifications import service as notification_service<br/>from src.posts.constants import ErrorCode as PostsErrorCode</span></pre><h1 id="27d5" class="mp mq iq bd mr ms nz mu mv mw oa my mz jw ob jx nb jz oc ka nd kc od kd nf ng bi translated">2.过度使用Pydantic进行数据验证</h1><p id="7813" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">Pydantic有一组丰富的特性来验证和转换数据。</p><p id="3eb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了具有默认值的必填和非必填字段等常规功能外，Pydantic还内置了全面的数据处理工具，如regex、有限选项的枚举、长度验证、电子邮件验证等。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="7c45" class="mp mq iq bd mr ms nz mu mv mw oa my mz jw ob jx nb jz oc ka nd kc od kd nf ng bi translated">3.使用数据验证与数据库的依赖关系</h1><p id="908d" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">Pydantic只能验证客户端输入的值。使用依赖关系根据数据库约束(如电子邮件已存在、找不到用户等)验证数据。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">额外的好处是，使用一个公共的依赖项消除了为每条路由编写测试来验证post_id的需要。</p><h1 id="b02e" class="mp mq iq bd mr ms nz mu mv mw oa my mz jw ob jx nb jz oc ka nd kc od kd nf ng bi translated">4.分离和重用依赖关系。依赖关系调用被缓存</h1><p id="0e46" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">依赖项可以被多次重用，并且不会被重新计算——默认情况下，FastAPI在请求的范围内缓存依赖项的结果，也就是说，如果我们有一个调用服务<code class="fe og oh oi nq b">get_post_by_id</code>的依赖项，我们不会在每次调用这个依赖项时都访问DB——只有第一次函数调用时。</p><p id="f668" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">知道了这一点，我们就可以很容易地将依赖关系分解成多个更小的功能，这些功能在一个更小的域上运行，并且更容易在其他路由中重用。例如，在下面的代码中，我们使用了三次<code class="fe og oh oi nq b">parse_jwt_data</code>依赖:</p><ol class=""><li id="fadc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe og oh oi nq b">valid_owned_post</code></li><li id="c5fd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe og oh oi nq b">valid_active_creator</code></li><li id="d0b4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe og oh oi nq b">get_user_post</code>，</li></ol><p id="90d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<code class="fe og oh oi nq b">parse_jwt_data</code>只被调用一次，在第一次调用中。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="bf36" class="mp mq iq bd mr ms nz mu mv mw oa my mz jw ob jx nb jz oc ka nd kc od kd nf ng bi translated">5.如果您只有阻塞I/O操作，请不要让您的路由异步</h1><p id="2c68" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">在幕后，FastAPI可以有效地处理异步和同步I/O操作。</p><ul class=""><li id="cd17" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nm ly lz ma bi translated">FastAPI在<a class="ae mh" href="https://en.wikipedia.org/wiki/Thread_pool" rel="noopener ugc nofollow" target="_blank">线程池</a>中运行<code class="fe og oh oi nq b">sync</code>路径，阻塞I/O操作不会阻止<a class="ae mh" href="https://docs.python.org/3/library/asyncio-eventloop.html" rel="noopener ugc nofollow" target="_blank">事件循环</a>执行任务。</li><li id="452e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nm ly lz ma bi translated">否则，如果路由被定义了<code class="fe og oh oi nq b">async</code>，那么它会通过<code class="fe og oh oi nq b">await</code>被定期调用，FastAPI相信你只做非阻塞的I/O操作。</li></ul><p id="cb1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，如果在异步路由中信任失败并执行阻塞操作，事件循环将无法运行下一个任务，直到阻塞操作完成。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="fd15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个警告是，非阻塞可访问的或发送到线程池的操作必须是I/O密集型任务(例如，打开文件、数据库调用、外部API调用)。</p><ul class=""><li id="f52d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nm ly lz ma bi translated">等待CPU密集型任务(例如繁重的计算、数据处理、视频转码)是没有价值的，因为CPU必须工作才能完成任务，而I/O操作是外部的，服务器在等待该操作完成时什么也不做，因此它可以继续下一个任务。</li><li id="f1c8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nm ly lz ma bi translated">由于<a class="ae mh" href="https://realpython.com/python-gil/" rel="noopener ugc nofollow" target="_blank"> GIL </a>，在其他线程中运行CPU密集型任务也是无效的。简而言之，GIL一次只允许一个线程工作，这使得它对CPU任务毫无用处。</li><li id="2de2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nm ly lz ma bi translated">如果您想优化CPU密集型任务，您应该将它们发送给另一个进程中的工作人员。</li></ul><h1 id="7c4c" class="mp mq iq bd mr ms nz mu mv mw oa my mz jw ob jx nb jz oc ka nd kc od kd nf ng bi translated">6.迁徙。阿伦比奇。</h1><ol class=""><li id="2bcf" class="ls lt iq ky b kz nh lc ni lf oj lj ok ln ol lr lx ly lz ma bi translated">迁移必须是静态和可逆的。如果您的迁移依赖于动态生成的数据，那么请确保唯一动态的是数据本身，而不是其结构。</li><li id="c844" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用描述性名称和slugs生成迁移。Slug是必需的，并且应该解释这些变化。</li><li id="0eb8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">为新迁移设置人类可读的文件模板。我们使用<code class="fe og oh oi nq b">*date*_*slug*.py</code>模式，例如<code class="fe og oh oi nq b">2022-08-24_post_content_idx.py</code></li></ol><pre class="kh ki kj kk gt np nq nr ns aw nt bi"><span id="186f" class="nu mq iq nq b gy nv nw l nx ny"># alembic.ini<br/>file_template = %%(year)d-%%(month).2d-%%(day).2d_%%(slug)s</span></pre><h1 id="d5b9" class="mp mq iq bd mr ms nz mu mv mw oa my mz jw ob jx nb jz oc ka nd kc od kd nf ng bi translated">7.background tasks &gt; asyncio . create _ task</h1><p id="8ec0" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">背景任务可以像处理路由一样有效地运行阻塞和非阻塞I/O操作(<code class="fe og oh oi nq b">sync</code>函数在线程池中运行，而<code class="fe og oh oi nq b">async</code>函数在后面等待)</p><ul class=""><li id="d8a8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nm ly lz ma bi translated">不要对工作人员撒谎，不要将阻塞的I/O操作标记为<code class="fe og oh oi nq b">async</code></li><li id="51f5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nm ly lz ma bi translated">不要将它用于繁重的CPU密集型任务。</li></ul><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="2829" class="mp mq iq bd mr ms nz mu mv mw oa my mz jw ob jx nb jz oc ka nd kc od kd nf ng bi translated">8.分块保存文件</h1><p id="a9d3" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">不要希望你的客户会发送小文件。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="77a0" class="mp mq iq bd mr ms nz mu mv mw oa my mz jw ob jx nb jz oc ka nd kc od kd nf ng bi translated">9.小心动态重力场</h1><p id="d20e" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">如果您有一个可以接受类型联合的pydantic字段，请确保验证器明确知道这些类型之间的区别。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="b8f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">不可怕的解决方案:</strong></p><ol class=""><li id="053e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">正确排序字段类型:从最严格的到宽松的。</li></ol><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="a219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.验证输入只有有效字段。</p><p id="2b43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Pydantic忽略联合类型的ValueErrors并迭代它们。如果没有有效的类型，则引发最后一个异常。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="d1cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.如果字段很简单，请使用Pydantic的智能联合(&gt; 1.9版)</p><p id="263a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果字段是简单的，比如<code class="fe og oh oi nq b">int</code>或<code class="fe og oh oi nq b">bool</code>，这是一个很好的解决方案，但是对于复杂的字段，比如类，这是行不通的。</p><p id="1567" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有Smart Union:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用智能联盟:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="363c" class="mp mq iq bd mr ms nz mu mv mw oa my mz jw ob jx nb jz oc ka nd kc od kd nf ng bi translated">10.如果您必须使用sync SDK，那么在线程池中运行它</h1><p id="aec3" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">如果您必须使用SDK与外部服务交互，而它不是<code class="fe og oh oi nq b">async</code>，那么在外部工作线程中进行HTTP调用。</p><p id="5d23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个简单的例子，我们可以使用starlette中众所周知的<code class="fe og oh oi nq b">run_in_threadpool</code>。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="dce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">FastAPI是一个工具，可以用来轻松地构建简单得令人捧腹的项目和复杂得令人恐惧的项目。这并不是说缺乏来自上面的约定是不可维护项目的根源，而是缺乏一致性。</p><p id="6e32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管你有什么规则，唯一应该遵守的规则是与你的规则保持一致。找到一套行之有效的约定，迭代它们，并向他人倡导它们。如果您已经有了，请在<a class="ae mh" href="https://github.com/zhanymkanov/fastapi-best-practices/issues" rel="noopener ugc nofollow" target="_blank">问题页面</a>上与其他人分享。</p><pre class="kh ki kj kk gt np nq nr ns aw nt bi"><span id="7a85" class="nu mq iq nq b gy nv nw l nx ny"><strong class="nq ir">Want to Connect?</strong></span><span id="01f9" class="nu mq iq nq b gy om nw l nx ny">If you liked the article— follow me on <a class="ae mh" href="http://twitter.com/zhanymkanov" rel="noopener ugc nofollow" target="_blank">twitter</a>, I will share my experience with startups, development, and crypto.</span></pre></div></div>    
</body>
</html>