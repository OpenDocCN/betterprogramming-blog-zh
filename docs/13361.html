<html>
<head>
<title>Debugging HTTP Requests in .Net Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中调试HTTP请求。网络核心</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/debugging-http-requests-in-net-core-2d26cb5d4295?source=collection_archive---------0-----------------------#2022-08-20">https://betterprogramming.pub/debugging-http-requests-in-net-core-2d26cb5d4295?source=collection_archive---------0-----------------------#2022-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="83d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">拦截请求并自动生成curl命令</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20c2979340f54d487ac2d9083597def3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sC4TixY-WUYA3YYSD9RQQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://pixabay.com/pt/users/guvo59-9285194/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3540378" rel="noopener ugc nofollow" target="_blank">冈杜拉·沃格尔</a>从<a class="ae ky" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><p id="b133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当收到Web APIs的HTTP请求导致的错误时，通常会通过提取应用程序正在执行的确切请求并准备curl命令或postman调用来重现问题，从而开始调查问题。</p><blockquote class="lv lw lx"><p id="bd1a" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">P <!-- --> OST更新</p><p id="b281" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果你在这里只是因为你正在寻找一种简单的方法来记录你的HTTP呼叫，你可以使用我在这篇文章中创建的NuGet包。</p><p id="4c3e" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">但是如果你来这里是为了更好地理解它是如何工作的，那就更好了，享受它吧。</p></blockquote><p id="0394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一个复杂的任务，但它消耗了很多时间，因为我们需要运行我们的应用程序，识别请求，检查地址，参数，头，键等，将其复制到一个文件，并建立curl命令。</p><p id="4c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些人甚至花了一些时间，安装嗅探器应用程序，如<a class="ae ky" href="https://www.telerik.com/fiddler" rel="noopener ugc nofollow" target="_blank"> Fiddler </a>和<a class="ae ky" href="https://www.wireshark.org/" rel="noopener ugc nofollow" target="_blank"> Wireshark </a>来检查来自计算机的所有HTTP流量，甚至序列化请求并将其记录到文本文件中，这些方法当然有助于解决问题，但需要安装额外的应用程序或多次编写自定义日志例程。</p><p id="c986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将展示如何使用<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/http-message-handlers" rel="noopener ugc nofollow" target="_blank"> HTTP消息处理程序</a>来拦截HTTP请求，并以一种非常简单快捷的方式为您的请求自动生成curl命令。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="b9c6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">等等，这样做不需要定制代码</h1><blockquote class="lv lw lx"><p id="9a15" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果你正在考虑Asp.Net 6.0中的本地HTTP日志处理程序，你是完全正确的，我们不需要定制代码。</p><p id="be72" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果你使用的是Asp.Net 6.0，查看这里的文档<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-logging/?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">并记录你所有的请求，这比本文介绍的技术更容易</a></p></blockquote><p id="fe84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您使用的是旧版本，比如5.0或3.1(或更旧)，那么这篇文章可能会对您有所帮助。</p><p id="6ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续阅读的另一个原因是了解我们如何利用定制消息处理程序，不仅是为了日志目的，也是为了任何其他需要(如本文后面提到的)</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="31ea" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">HTTP消息处理程序</h1><p id="e4c8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">一个<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/http-message-handlers" rel="noopener ugc nofollow" target="_blank"> HTTP消息处理器</a>是一个接收HTTP请求并返回HTTP响应的类(就这么简单)。</p><p id="60fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Asp.Net Web API有几个内置的消息处理程序，可以创建一个嵌套的(本地的)调用管道。</p><p id="604e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个从<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=net-6.0" rel="noopener ugc nofollow" target="_blank">delegateing handler</a>类继承的自定义处理程序，并将其添加到管道中。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="fd9e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">免费测试API</h1><p id="47a2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在开始创建我们的示例Web API之前，我正在搜索用于测试的免费API，我发现了两个非常有趣的API:</p><ul class=""><li id="f022" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><a class="ae ky" href="https://nationalize.io/" rel="noopener ugc nofollow" target="_blank"> Nationalize IO </a> —这个API使用一个GET方法，它预测一个给定名字的人的国籍。</li><li id="4b59" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://funtranslations.com/api/yoda/" rel="noopener ugc nofollow" target="_blank">Yoda Translator API</a>—Yoda Translator API使用POST方法，将一个英语短语翻译成Yoda语言，基本上是倒排原句。</li></ul><p id="4ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，基于这两个API，我的建议是创建一个新的Web API，它根据名字预测一个人的国籍，并向Yoda翻译器请求短语<code class="fe nu nv nw nx b">Master {NAME} has lost {COUNTRY}</code>并期待类似于<code class="fe nu nv nw nx b">Lost {COUNTRY}, master {NAME} has</code>的结果</p><p id="a07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好看又简单不是，那我们来造吧。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="4761" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">创建Web API</h1><p id="6f81" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在我们的电脑上创建一个新文件夹，在命令行中键入<code class="fe nu nv nw nx b">mkdir http-to-curl</code>，然后按回车键。</p><p id="d0ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后进入运行<code class="fe nu nv nw nx b">cd http-to-curl</code>的文件夹，创建一个新的运行<code class="fe nu nv nw nx b">dotnet new webapi</code>的Web API</p><p id="8724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们安装<a class="ae ky" href="https://github.com/reactiveui/refit" rel="noopener ugc nofollow" target="_blank">改装</a>依赖项，以便能够用它轻松地发出请求，运行<code class="fe nu nv nw nx b">dotnet add package Refit --version 6.3.2</code>和<code class="fe nu nv nw nx b">dotnet add package Refit.HttpClientFactory --version 6.3.2</code></p><p id="8e47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开运行<code class="fe nu nv nw nx b">code .</code>的Visual Studio代码，结构肯定和那个很像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/59c1cba56ba2348598e87ca3f824b46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEKkXI3cKMzfZJmhm9SH2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始应用程序结构</p></figure><p id="c25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建一个新的API文件夹并添加<code class="fe nu nv nw nx b">INationalizeApi.cs</code>类</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">INationalizeApi类</p></figure><p id="659e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，添加<code class="fe nu nv nw nx b">IYodaTranslationApi.cs</code>类</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">IYodaTranslationApi类</p></figure><p id="ab8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在<code class="fe nu nv nw nx b">Program.cs</code>文件中添加改装客户端(第10行和第14行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">程序类</p></figure><p id="1696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">删除<code class="fe nu nv nw nx b">WeatherForecastController</code>和<code class="fe nu nv nw nx b">WeatherForecast</code>类，增加如下<code class="fe nu nv nw nx b">CompositeApiController</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CompositeApiController类</p></figure><p id="e2a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的API已经准备好运行了，在控制台中键入<code class="fe nu nv nw nx b">dotnet run</code>，并通过键入<code class="fe nu nv nw nx b">curl --location --insecure --request GET 'https://localhost:7127/Pietro' --header 'keya:valuea' --header 'keyb:valueb'</code>发出请求(注意，标题只是为了举例，不安全的选项是为了避免证书，可能您需要将端口调整为与您的应用程序运行时相同)</p><p id="9e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切正常，您将在命令行上看到以下结果消息:<code class="fe nu nv nw nx b">Lost italia, Pietro has</code></p><p id="0f31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任务完成，我们有一个示例应用程序。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="cbde" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">以卷曲形式转换请求</h1><p id="95ee" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在，准备好最精彩的部分，让我们创建我们的定制处理程序，创建检查请求的逻辑，并构建curl。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">HttpToCurlHandlers类</p></figure><p id="2efc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类非常简单，首先，我们覆盖了<code class="fe nu nv nw nx b">SendAsync</code>方法，它将在请求发生之前执行，对于这里的拦截，基本上需要添加方法来记录请求和响应。</p><p id="3eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更容易地在日志中搜索，我生成了一个GUID，以便将请求与日志中的响应进行匹配。</p><p id="1401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">日志方法也非常简单，它们开始记录一些硬编码curl语法，然后记录地址、方法、头和请求对象的主体。</p><p id="0753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的要点是，应该是完全可定制的，你可以做任何你想做的事情。</p><p id="bf7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是将处理程序与我们的Refit客户端关联起来，为了做到这一点，我们需要在<code class="fe nu nv nw nx b">Program.cs</code>中添加一个对<code class="fe nu nv nw nx b">.addHttpMessageHandler&lt;HttpToCurlHandler&gt;</code>方法的调用，以便您可以使用处理程序(第4行和第9行)并在服务中注册处理程序(第11行)</p><p id="317f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修改我们的现有代码以使用处理程序，看起来必须完全像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加处理程序后的程序类</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="aead" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">检查日志</h1><p id="c674" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">由于我使用<code class="fe nu nv nw nx b">System.Diagnostics.Debug.WriteLine()</code>方法来记录日志，我们只能在调试模式下运行应用程序时才能看到日志，如果你需要不同的东西，你只需要改变处理程序记录信息的方式。</p><p id="088b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按F5以调试模式启动应用程序，并像我们在上一步中所做的那样再次请求。</p><p id="e5b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nu nv nw nx b">Debug Console</code>窗口中查看并过滤<code class="fe nu nv nw nx b">REFIT LOG</code>，你将能够看到由处理程序生成的所有卷发。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/6d49211b6d06eea8e49845eae430deff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQuovp4vNl8MiTZr9a1AGQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Visual Studio代码上调试控制台窗口</p></figure><p id="a718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是啊，这是工作。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="1433" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">其他用途</h1><p id="6739" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">正如我在本文开始时解释的那样，HTTP消息处理程序可以用于任何其他需求，比如授权、头定制、补充信息、加密等等，请放心明智地使用它</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="60ef" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">示例项目和最终考虑事项</h1><p id="b283" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果您想运行我用来创建本文的示例项目，请随意从我的GitHub代表 o中克隆它<a class="ae ky" href="https://github.com/edsondiasalves/http-to-curl" rel="noopener ugc nofollow" target="_blank"/></p><p id="5319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能像对我一样对你有用，谢谢你读到这里，下次再见</p></div></div>    
</body>
</html>