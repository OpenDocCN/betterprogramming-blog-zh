<html>
<head>
<title>Getting Started With Unit Testing Software in 2023</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2023年单元测试软件入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-software-in-2022-b3ac00962c65?source=collection_archive---------10-----------------------#2022-01-08">https://betterprogramming.pub/unit-testing-software-in-2022-b3ac00962c65?source=collection_archive---------10-----------------------#2022-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b42e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以荒唐的速度开发顶级软件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7ba07f84c808bc876dd38a9358ae8eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMNQS-D0NyCsLCWh0K6HCQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个开发人员支持一个经过良好测试的存储库的图像(拉塞德西恩/<a class="ae kv" href="http://shutterstock.com/" rel="noopener ugc nofollow" target="_blank">Shutterstock.com</a></p></figure><p id="6806" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除非你一生都生活在拇指插在耳朵里哼着<a class="ae kv" href="https://www.youtube.com/watch?v=uZW4vbIstoo" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a>的日子里，否则你可能已经听说过测试你的软件有多重要。</p><p id="73f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你没有听说过测试软件很重要，你可能需要更好的朋友！</p><p id="2308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章将探讨测试软件的原因和方法，这样你就可以花更少的时间破坏东西，花更多的时间跳舞和交新朋友。</p><p id="5a98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的配套资源库可以在<a class="ae kv" href="https://github.com/bobbyg603/unit-testing-in-2022" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="89ec" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">为什么我要写测试？</h1><p id="0a60" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">编写测试是应对不断增长的应用程序的复杂性的最佳方式。以下是为什么应该在应用程序中添加测试的一系列理由:</p><ul class=""><li id="23ab" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">测试提供了关于代码实际如何工作的活文档，因此您不必依赖模糊的记忆和糟糕的假设。</li><li id="9a87" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">编写测试需要编写可测试的代码，这鼓励良好的软件架构模式。</li><li id="9de7" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">自动化测试的执行速度比同等的手动测试快几个数量级，并且可以添加到拉请求的自动化构建检查中，以确保贡献不会破坏现有的功能。</li></ul><p id="7879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对任何新的贡献者来说，你能做的最好的事情就是向他们介绍一个架构良好、文档完善、测试良好的代码库。</p><p id="ed1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一大套写得很好的测试可以快速准确地捕获代码行为的回归，允许团队有效地操作可有效伸缩的过程。</p><h1 id="6e8d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">建立新项目</strong></h1><p id="9de9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">启动您选择的开发环境。本文将关注VS代码，但是任何合理的IDE都足够了。您还需要Node.js。在撰写本文时，当前的LTS版本是16.13.1。</p><p id="3c55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们初始化一个新的Node.js项目</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="3360" class="nj lu iq nf b be nk nl l nm nn">npm init</span></pre><p id="e31a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们安装引导TypeScript项目所需的所有包。在本教程中，我们将使用<a class="ae kv" href="https://jasmine.github.io" rel="noopener ugc nofollow" target="_blank"> Jasmine </a>测试框架。</p><p id="4950" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的例子也将使用<a class="ae kv" href="https://www.npmjs.com/package/node-fetch" rel="noopener ugc nofollow" target="_blank">节点获取</a>。我不会在这里详细说明，但是节点模块可能会引起混乱，所以我们将在主版本2中保留节点获取。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="643f" class="nj lu iq nf b be nk nl l nm nn">npm i typescript ts-node jasmine @types/jasmine node-fetch@^2.0.0 @types/node-fetch@^2.0.0</span></pre><p id="341c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来配置Jasmine。在项目的根目录下创建一个文件<code class="fe no np nq nf b">jasmine.json</code>。将以下内容粘贴到JSON文件中:</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="4944" class="nj lu iq nf b be nk nl l nm nn">{<br/>    "spec_dir": "src",<br/>    "spec_files": ["**/*[sS]pec.ts"],<br/>    "helpers": ["helpers/**/*.ts"],<br/>    "random": true,<br/>    "stopSpecOnExpectationFailure": true<br/>}</span></pre><p id="7ba4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢在他们测试的代码旁边定义测试，因此你会注意到<code class="fe no np nq nf b">spec_folder</code>属性指向<code class="fe no np nq nf b">src</code>，这也是我们放置源代码的地方。</p><p id="c3f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将以下脚本添加到您的<code class="fe no np nq nf b">package.json</code>文件中:</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="892d" class="nj lu iq nf b be nk nl l nm nn">"scripts": {<br/>    "test": "ts-node node_modules/jasmine/bin/jasmine --config=jasmine.json"<br/>},</span></pre><p id="e21c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在VS代码测试浏览器UI中查看您的测试，您需要安装<a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-jasmine-test-adapter" rel="noopener ugc nofollow" target="_blank"> Jasmine测试浏览器扩展</a>。</p><p id="ab38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你安装了扩展，创建一个新的文件<code class="fe no np nq nf b">.vscode/settings.json</code>，确保你创建了<code class="fe no np nq nf b">.vscode</code>文件夹，如果它还不存在的话。</p><p id="ce4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将以下内容粘贴到<code class="fe no np nq nf b">settings.json</code>中，以便将Jasmine测试浏览器配置为使用我们的TypeScript设置:</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="3218" class="nj lu iq nf b be nk nl l nm nn">{<br/>    "testExplorer.useNativeTesting": true,<br/>    "jasmineExplorer.config": "jasmine.json",<br/>    "jasmineExplorer.nodeArgv": [<br/>        "-r",<br/>        "ts-node/register",<br/>    ]<br/>}</span></pre><h1 id="221b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">如何编写测试？</h1><p id="1628" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在你写测试之前，你需要测试一些东西。让我们完成创建一个简单服务的练习，该服务返回一个URL，该URL指向给定特定品种的狗的随机图像。</p><p id="09e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新文件<code class="fe no np nq nf b">src/dog.service.ts</code>，并将下面的代码片段粘贴到该文件中:</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="a0fa" class="nj lu iq nf b be nk nl l nm nn">import fetch from "node-fetch";<br/>export class DogService {<br/>    async getDogImageUrl(breed: string): Promise&lt;string&gt; {<br/>        const response = await fetch(`https://dog.ceo/api/breed/${breed}/images/random`);<br/>        const json = await response.json() as DogResponse;<br/>        return json.message;<br/>    }<br/>}<br/>export interface DogResponse {<br/>    status: 'success' | 'error';<br/>    message: string;<br/>}</span></pre><p id="96e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可能想要确保我们的函数不被传递一个空字符串，这似乎是合理的。让我们添加一个在品种字符串为空时抛出的保护。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="0a2f" class="nj lu iq nf b be nk nl l nm nn">import fetch from "node-fetch";<br/>export class DogService {<br/>    async getDogImageUrl(breed: string): Promise&lt;string&gt; {<br/>        if (!breed) {<br/>            throw new Error('Must specify a valid doggo!');<br/>        }<br/>        const response = await fetch(`https://dog.ceo/api/breed/${breed}/images/random`);<br/>        const json = await response.json() as DogResponse;<br/>        return json.message;<br/>    }<br/>}</span></pre><p id="1b32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们添加一个测试来练习guard子句。在<code class="fe no np nq nf b">src</code>文件夹中创建一个文件<code class="fe no np nq nf b">dog.service.spec.ts</code>。在新的等级库文件中粘贴以下内容:</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="0328" class="nj lu iq nf b be nk nl l nm nn">import { DogService } from './dog.service';<br/>describe('DogService', () =&gt; {<br/>    describe('getDogImageUrl', () =&gt; {<br/>        it('should throw if breed is empty', async () =&gt; {<br/>            return expectAsync(new DogService().getDogImageUrl('')).toBeRejected();<br/>        });<br/>    });<br/>});</span></pre><p id="315d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个测试应该显示在您的测试浏览器UI中。让我们运行它！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/631bc7c0da100a25d0c8144810b4e1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMwQT8WLzcMonIxu1NIjwQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">VS代码测试资源管理器UI</p></figure><p id="6b25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您右击列表中的一个测试并选择<strong class="ky ir"> Debug Test </strong>，您还应该能够设置一个断点并在所需的行上停止调试器。</p><h1 id="bd3b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">潜得更深</strong></h1><p id="306e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">到目前为止，我们已经编写了一个非常简单的测试，让我们把它提高一个档次，探索一些更高级的概念。测试我们用包含我们传递给<code class="fe no np nq nf b">getDogImageUrl</code>的品种的字符串调用fetch似乎是合理的。</p><p id="014e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试我们是否正确地调用了<code class="fe no np nq nf b">fetch</code>,需要我们稍微重新架构一下我们的函数。我们需要引入一个seem，它允许我们用一个模拟的版本替换真实的fetch实现，这个版本允许我们检查fetch被调用的方式。使代码可测试的一个常见方法是引入依赖注入。</p><p id="50d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">依赖注入有3种类型:构造函数、参数和属性注入。当对象中的大多数函数使用特定的依赖关系时，构造函数注入最有意义。当只有一个函数使用依赖项时，将依赖项作为参数注入到函数中是一个可接受的选择。第三种方法是使用属性注入。当一个类有一个很少需要替换的合理的默认依赖时，属性注入是有意义的。</p><p id="0c53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，构造函数注入是最有意义的，但是为了好玩，我们来看一下这三个例子。</p><h1 id="0801" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">创建一个伪实现</strong></h1><p id="1d96" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在开始我们的依赖注入示例之前，让我们创建一个假的实现，我们可以用它来验证周围的实现是否工作正常。</p><p id="9f6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们给<code class="fe no np nq nf b">dog.service.spec.ts</code>添加一个<code class="fe no np nq nf b">beforeEach</code>块来配置一个<a class="ae kv" href="https://jasmine.github.io/tutorials/your_first_suite#section-Spies" rel="noopener ugc nofollow" target="_blank"> Jasmine Spy </a>。间谍是可以跟踪它们被调用的方式，并返回预先配置的值的函数。我们的间谍将模拟来自<a class="ae kv" href="https://dog.ceo" rel="noopener ugc nofollow" target="_blank"> dog.ceo </a> API的返回值。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="6206" class="nj lu iq nf b be nk nl l nm nn">let fetch: jasmine.Spy;<br/>let message: string;<br/>beforeEach(() =&gt; {<br/>    const status = 'success';<br/>    message = 'https://images.dog.ceo/breeds/pug/n02110958_12589.jpg';<br/>    fetch = jasmine.createSpy();<br/>    fetch.and.resolveTo({<br/>        json: async() =&gt; ({<br/>            status,<br/>            message<br/>        })<br/>    });<br/>});</span></pre><h1 id="caab" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">构造函数注入</strong></h1><p id="3ed9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">构造函数注入是最可取的方法，框架通常提供工具来简化这一过程。让我们修改<code class="fe no np nq nf b">dog.service.ts</code>，这样我们就可以将我们的假获取实现注入到构造函数中。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="f277" class="nj lu iq nf b be nk nl l nm nn">import { RequestInfo, RequestInit, Response } from "node-fetch";<br/>export class DogService {<br/>    constructor(private _fetch: Fetch) { }<br/>    async getDogImageUrl(breed: string): Promise&lt;string&gt; {<br/>        if (!breed) {<br/>            throw new Error('Must specify a valid doggo!');<br/>        }<br/>        <br/>        const response = await this._fetch(`https://dog.ceo/api/breed/${breed}/images/random`);<br/>        const json = await response.json() as DogResponse;<br/>        return json.message;<br/>    }<br/>}<br/>export type Fetch = (url: RequestInfo, init?: RequestInit) =&gt; Promise&lt;Response&gt;;</span></pre><p id="365b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们为参数定义了一个接口。这个接口是从节点获取声明文件中复制的，所以我们的<code class="fe no np nq nf b">DogService</code>类可以准确地指定它需要什么。</p><p id="2c87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们写一个测试来验证我们在<code class="fe no np nq nf b">getDogImageUrl</code>中正确地使用了fetch:</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="6e7a" class="nj lu iq nf b be nk nl l nm nn">it('should call fetch with url containing breed', async () =&gt; {<br/>    const breed = 'pug';<br/>    await new DogService(fetch).getDogImageUrl(breed);<br/>    expect(fetch).toHaveBeenCalledWith(jasmine.stringMatching(/pug/));<br/>});</span></pre><h1 id="d213" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">参数注入</strong></h1><p id="4f78" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在某些情况下，通过函数参数注入依赖项可能是有意义的。下面是一个示例(您需要从构造函数注入示例中复制Fetch的类型声明):</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="0628" class="nj lu iq nf b be nk nl l nm nn">async getDogImageUrl(fetch: Fetch, breed: string): Promise&lt;string&gt; {<br/>    if (!breed) {<br/>        throw new Error('Must specify a valid doggo!');<br/>    }<br/>    const response = await fetch(`https://dog.ceo/api/breed/${breed}/images/random`);<br/>    const json = await response.json() as DogResponse;<br/>    return json.message;<br/>}</span></pre><p id="7d89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的测试现在将如下所示:</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="a34a" class="nj lu iq nf b be nk nl l nm nn">it('should call fetch with url containing breed', async () =&gt; {<br/>    const breed = 'pug';<br/>    await new DogService().getDogImageUrl(fetch, breed);<br/>    expect(fetch).toHaveBeenCalledWith(jasmine.stringMatching(/pug/));<br/>});</span></pre><h1 id="db5f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">物业注入</strong></h1><p id="5821" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">资产注入曾经是我远离的一种方法。有了TypeScript，我改变了主意。如果你正在使用一个自动注入依赖项的框架，你应该总是在属性注入上使用它。让我们稍微尝试一下属性注入。</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="78a3" class="nj lu iq nf b be nk nl l nm nn">import fetch from 'node-fetch';<br/>export class DogService {<br/>    private _fetch: Fetch = fetch;<br/>async getDogImageUrl(breed: string): Promise&lt;string&gt; {<br/>        if (!breed) {<br/>            throw new Error('Most specify a valid doggo!');<br/>        }<br/>        <br/>        const response = await this._fetch(`https://dog.ceo/api/breed/${breed}/images/random`);<br/>        const json = await response.json() as DogResponse;<br/>        return json.message;<br/>    }<br/>}</span></pre><p id="903b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能已经注意到了<code class="fe no np nq nf b">_fetch</code>是私有的。这是故意的。这是因为在生产场景中，我们真的不想让任何人交换这种依赖性。我们通过将它设为私有来明确表示我们不打算让任何人覆盖这种依赖性。</p><p id="4ac4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeScript允许我们做一些真正有趣的事情。下面的技巧是我建议你永远不要在产品代码中使用的。然而，出于测试的目的，这是一个合理的技巧:</p><pre class="kg kh ki kj gt ne nf ng bn nh ni bi"><span id="461d" class="nj lu iq nf b be nk nl l nm nn">it('should call fetch with url containing breed', async () =&gt; {<br/>    const breed = 'pug';<br/>    const service = new DogService();<br/>    (service as any)._fetch = fetch;<br/>    await service.getDogImageUrl(fetch, breed);<br/>    expect(fetch).toHaveBeenCalledWith(jasmine.stringMatching(/pug/));<br/>});</span></pre><p id="9194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将我们的服务强制转换为<code class="fe no np nq nf b">any</code>,我们能够消除关于访问私有属性的TypeScript警告，并仍然进行属性注入。您也可以使用一个公共属性，但这意味着您打算让消费者在产品代码中覆盖该属性，这在本例中没有多大意义。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="3828" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文概述了为什么您应该测试您的软件，并提供了如何开始的基本示例。</p><pre class="kg kh ki kj gt ne nf nz oa aw ob bi"><span id="9deb" class="oc lu iq nf b gy od oe l of nn"><strong class="nf ir">Want to Connect?</strong></span><span id="c072" class="oc lu iq nf b gy og oe l of nn">If you found the information in this tutorial useful please subscribe on <a class="ae kv" href="http://bobbyg603.medium.com" rel="noopener">Medium</a>, follow me on <a class="ae kv" href="https://github.com/bobbyg603" rel="noopener ugc nofollow" target="_blank">GitHub</a>, and/or subscribe to my <a class="ae kv" href="https://www.youtube.com/c/bobbyg603" rel="noopener ugc nofollow" target="_blank">YouTube</a> channel.</span></pre></div></div>    
</body>
</html>