<html>
<head>
<title>Spring Boot Integration: Inversion of Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot积分:控制反转</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/spring-boot-integration-inversion-of-control-d65c1a1dcf2a?source=collection_archive---------8-----------------------#2020-09-11">https://betterprogramming.pub/spring-boot-integration-inversion-of-control-d65c1a1dcf2a?source=collection_archive---------8-----------------------#2020-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="450f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">超越依赖注入</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/65aa4b5da4706e24e1d5ccb376c116f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7WonQWwzYxbFonugQ--Jg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Mary jo Bautista<a class="kv kw ep" href="https://medium.com/u/a00cc4c4b2f9?source=post_page-----d65c1a1dcf2a--------------------------------" rel="noopener" target="_blank">拍摄的照片</a></p></figure><p id="889d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">很多时候，每当提到控制反转的概念时，第一个想到的就是依赖注入。对于本文，我还想介绍一下方法调用，这是Spring Integration大量使用的概念。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="52be" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">类型级耦合和系统级耦合</h1><p id="43eb" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">在深入代码之前，我们先来说说控制反转解决的耦合类型:类型级耦合和系统级耦合。</p><p id="9529" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">类型级耦合可能是最容易理解的——它是类型之间的耦合，通过使用依赖注入来解决。我打赌你们中的大多数人已经知道了这一点，但是为了清楚起见，让我在下面包括一个例子来演示这个概念。</p><p id="36ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设我们有一个<code class="fe mx my mz na b">OrderService</code>类，它正在其他类中被实例化。</p><p id="9744" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">具有类型级耦合的代码(在这种情况下，明确的类型耦合):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6240" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对<code class="fe mx my mz na b">OrderService</code>的构造函数的改变将会影响其他所有实例化<code class="fe mx my mz na b">OrderService</code>的类。</p><p id="d2f6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有了依赖注入——具体实例的创建被委托给框架，这是通过创建一个<code class="fe mx my mz na b">OrderService</code>bean并使用XML或Java DSL自动连接来实现的——这就不是问题了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="24ac" class="nd mb iq bd mc ne nf dn mg ng nh dp mk lg ni nj mm lk nk nl mo lo nm nn mq no bi translated">方法调用</h2><p id="ce55" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">关于依赖注入就说这么多了——现在让我们深入研究方法调用，它解决了系统级的耦合。</p><p id="b120" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">想象一下，我们正在使用之前的<code class="fe mx my mz na b">OrderService</code>类的例子处理多个相互连接的系统:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4cfd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">鉴于上述情况，如果由于某种原因<code class="fe mx my mz na b">warehouseService</code>不可用，那么我们将无法下订单。这可能是当前的业务规则，但是如果企业决定至少在仓库服务不可用时暂停订单，该怎么办呢？</p><p id="622f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这就是Spring Integration的方法调用通过解决系统级耦合而派上用场的地方。</p><p id="7a54" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我将演示一个简单的解决方案(用于演示目的),其中<code class="fe mx my mz na b">Order</code>将被成功放置在<code class="fe mx my mz na b">orderQueue</code>上，不管<code class="fe mx my mz na b">warehouseService</code>是否可用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4cd7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">正如我们在这里看到的，我们仍然在使用<code class="fe mx my mz na b">warehouseService</code>，但是现在即使仓库服务不可用，一旦仓库服务再次可用，我们仍然能够处理订单。运行上面的代码将向<code class="fe mx my mz na b">orderQueue</code>下订单。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/3a60b1cf729fa920f273f1800bfd0d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0LZN-BrA_AxvlaInYiRvg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ActiveMQ管理控制台</p></figure><p id="845b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一条消息排队！你可能已经注意到消费者的数量是<code class="fe mx my mz na b">0</code>。这是因为我们还没有创建<code class="fe mx my mz na b">warehouseService</code>本身，考虑到这个场景，我们可以得出结论，尽管没有意识到<code class="fe mx my mz na b">warehouseService</code>，但是<code class="fe mx my mz na b">OrderService</code>仍然在工作。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="020d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">实现“仓库服务”</h1><p id="e119" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">我们现在已经解决了之前在Spring集成中使用的系统级耦合，它大量使用了方法调用。如果你还在这里，那么和我一起实现<code class="fe mx my mz na b">warehouseService</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9aa3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在让我们运行我们已经创建的<code class="fe mx my mz na b">warehouseService</code>并检查ActiveMQ。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/b2b534fd0e204c61573987cdbf7ed667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAxwtfCFb43i3bdrQ_LAog.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ActiveMQ管理控制台</p></figure><p id="cffc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们有一个消费者，一个消息入队，一个消息出队。</p><p id="3647" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们再次看到了Spring Integration的方法调用的美妙之处，它允许我们用<code class="fe mx my mz na b">@ServiceActivator</code>声明性地标记<code class="fe mx my mz na b">updateInventory</code>来处理来自<code class="fe mx my mz na b">orderQueue</code>的消息。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f80b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="6498" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">我希望你喜欢这篇文章。</p><p id="abc6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">编码快乐！</p></div></div>    
</body>
</html>