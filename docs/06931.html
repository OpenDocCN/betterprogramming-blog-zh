<html>
<head>
<title>Nest.js and the Custom Validation Pipe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nest.js和自定义验证管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/nest-js-and-the-custom-validation-pipe-231130fda040?source=collection_archive---------2-----------------------#2020-11-18">https://betterprogramming.pub/nest-js-and-the-custom-validation-pipe-231130fda040?source=collection_archive---------2-----------------------#2020-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c18" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好的验证</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/28d0be64f5d9c0be63021b86a903712a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQf1E11CilN0Kwb8THX9yA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://morioh.com/p/f42cae11dbd4" rel="noopener ugc nofollow" target="_blank"> Morioh </a>。</p></figure><p id="7d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> Nest.js </a>是一个用于构建服务器端应用的渐进式Node.js框架。在引擎盖下，它使用<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>框架，也可以配置为使用<a class="ae ky" href="https://github.com/fastify/fastify" rel="noopener ugc nofollow" target="_blank"> Fastify </a>。它是用TypeScript构建的，并且完全支持TypeScript(这也是我喜欢这个框架的原因之一)。</p><p id="1cc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和Angular一样，Nest为我们提供了管道。管道基本上是可以接受输入数据、转换数据并输出转换后的数据的类或函数。</p><p id="cf44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Nest中的管道用<code class="fe lv lw lx ly b">@injectable()</code>装饰器进行了注释。通常，在所有应用程序中，管道都可以用于转换和验证。在本文中，我将写关于管道的验证用例。</p><p id="eb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在构建一个应用程序，该应用程序公开一个POST端点来在购物列表上创建一个新项目，您需要用户向端点提供以下内容作为有效负载:</p><ul class=""><li id="fdcb" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">名称(必填)</li><li id="6ed4" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">描述(必填)</li><li id="a2df" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">数量(可选)</li><li id="fd63" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">单价(必填)</li></ul><p id="73c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要创建一个处理请求的控制器，并且我们需要指定控制器应该期望一个body对象作为来自请求的数据。数据类型为<code class="fe lv lw lx ly b">any</code>(暂时):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/b49177ec8df695cd7e920fdfd2a0d9e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jofu9xT-UGqkXuAVCwRbDg.png"/></div></div></figure><p id="8353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要验证有效负载，以确保它符合端点的期望。为此，我们需要安装这两个包——类验证器和类转换器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/736a928c3e80d8c1229eb30e8ccfcfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnRvK3xsrXWa28Dapcmhdw.png"/></div></div></figure><p id="8242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要创建一个d to(数据传输对象)，它更像是一个描述数据应该是什么样子的模型。我们称它为<code class="fe lv lw lx ly b">ItemDTO</code>。创建一个名为<code class="fe lv lw lx ly b">item.dto.ts</code>的新文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/86a1612217991a8821031f5f4b2d78c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRyeGjmrwpeJxWwwGdLlXg.png"/></div></div></figure><p id="b293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">class-validator库为我们提供了几个可以用来描述数据类型的装饰器。从上面的片段来看:</p><p id="856c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.<code class="fe lv lw lx ly b">name</code>被声明为字符串。<code class="fe lv lw lx ly b">IsNotEmpty()</code>装饰器确保它是必填字段。</p><p id="1120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<code class="fe lv lw lx ly b">description</code> <strong class="lb iu">也是如此。</strong></p><p id="f354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe lv lw lx ly b">unitPrice</code>预计是一个数字，也是必需的。</p><p id="35d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.注意<code class="fe lv lw lx ly b">quantity</code>没有装饰器。但是，它被声明为一个数字。</p><p id="3120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要将控制器上的有效负载类型改为<code class="fe lv lw lx ly b">ItemDTO</code>类型，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/0e53d4123495e0191737d8dce37e6bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPg9apGgP0NU-pBuTEJCkw.png"/></div></div></figure><p id="d230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，到目前为止，我们所做的是通知我们的控制器，希望用户发送类型为<code class="fe lv lw lx ly b">itemDTO</code>的有效载荷。但是，如果端点没有获得任何有效负载或者有效负载不符合预期的数据类型，会发生什么呢？我们不希望我们的应用程序崩溃，是吗？作为指导，我们还必须告知用户正确的数据类型。这就是我们的定制验证器的用武之地。Nest为我们提供了内置的验证器管道。你可以在文档中读到它<a class="ae ky" href="https://docs.nestjs.com/techniques/validation#using-the-built-in-validationpipe" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="376e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建一个名为<code class="fe lv lw lx ly b">validation.pipe.ts</code>的新文件。我们应该创造一个新的阶级叫做<code class="fe lv lw lx ly b">CustomValidationPipe</code>。这个类应该实现<code class="fe lv lw lx ly b">PipeTransform</code>接口，这将使我们提供一个<code class="fe lv lw lx ly b">transform</code>方法。<code class="fe lv lw lx ly b">transform</code>方法接受像<code class="fe lv lw lx ly b">value</code>(我们的有效负载)和<code class="fe lv lw lx ly b">metaData</code>(显示更多关于我们的有效负载的元数据)这样的参数。将下面的代码粘贴到文件中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/664db41ccba0176bc5bf60f1d2b822d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hG7YK3LrYs_KuFAyZpwfxA.png"/></div></div></figure><p id="4113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.我们需要检查我们的有效载荷不为空:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/f73fbfa04ccb17084c006533dd4be219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9j2t9AN0tGAzIdOKQVjsg.png"/></div></div></figure><p id="9a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe lv lw lx ly b">HttpStatus</code>是如何使用的。Nest有一个可以利用的不同HTTP状态的枚举，因此您不必自己设置状态代码。在这一点上，我们确信我们将有一个有效载荷。</p><p id="82e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.我们需要根据注册的d to来验证有效载荷:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/20fdc71d8e93b8fcaf68d82782918da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sL_Vb3NBp3AaYRsFWSMH3w.png"/></div></div></figure><p id="24fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们使用了class-transformer中的<code class="fe lv lw lx ly b">plainToClass</code>方法。这将普通(文字)对象转换为类(构造函数)对象。这是必要的，因为我们需要验证我们的有效载荷是一个类对象。这就是为什么我们必须使用来自类验证器库的<code class="fe lv lw lx ly b">validate</code>方法。它返回一个错误数组的承诺(<code class="fe lv lw lx ly b">Promise&lt;ValidationError[]&gt;</code>)。这将确保我们的有效负载根据提供的DTO类进行验证。</p><p id="04d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.我们需要格式化<code class="fe lv lw lx ly b">errors</code>数组，使其更加用户友好:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/a7b8e20da115e45312810c874ac6e0ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t89KX03KogZBKqIlegMRDw.png"/></div></div></figure><p id="ce30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.我们需要将验证管道的类添加到控制器中。我们通过将它放入<code class="fe lv lw lx ly b">@UsePipes()</code>装饰器中来实现，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/efda0481d52752dbda63c2f23e6e6699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFtEgy1vmF8sflgco5CJMA.png"/></div></div></figure><p id="60ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以你有它。管道在Nest中是一个非常有用的概念。使用我们创建的验证类，我们可以验证应用程序中的所有控制器。这是非常可重用的，并且可以很容易地在单元测试中测试。这就是管道在应用程序中的用处。</p><p id="0c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。请随时在下面发表评论。</p></div></div>    
</body>
</html>