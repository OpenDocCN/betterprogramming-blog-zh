<html>
<head>
<title>4 Reasons Why You Should Be Using Python Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该使用Python生成器的4个理由</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-reasons-why-should-be-using-python-generators-660458b0085d?source=collection_archive---------4-----------------------#2021-03-09">https://betterprogramming.pub/4-reasons-why-should-be-using-python-generators-660458b0085d?source=collection_archive---------4-----------------------#2021-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ddd8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中的生成器不仅仅是列表的替代品</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e953896eadc2a3932942f38f67099a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bG4vqupVu7xsXPzJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@karsten_wuerth?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Karsten Würth </a>拍摄的照片。</p></figure><p id="92bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器是Python中的一个构造，它允许延迟或临时加载数据流。它们可以像列表一样工作并被循环，但是生成器具有维护状态的能力。</p><p id="283a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我知道没有例子对你来说毫无意义，所以让我们从下面的代码片段开始吧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/7f3b890c4899a43bcdd755dae73b0e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3mK0sa3Xd9q3GrUGavQHA.png"/></div></div></figure><p id="726f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看上面的函数，您可能会看到一个不熟悉的关键字<code class="fe lw lx ly lz b">yield</code>。这个类似于<code class="fe lw lx ly lz b">return</code>。但是，它特定于生成器。它允许你返回数据，但也存储了调用<code class="fe lw lx ly lz b">yield</code>的点。这允许在下一次调用时跳过之前的<code class="fe lw lx ly lz b">yield</code>(这将很快有意义)。</p><p id="011e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们按照<em class="ma">发生器</em>的运行方式运行该功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mb"><img src="../Images/bb3d7703a81a28302c6694ffdfcf3e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0Or_lQqQtXSff-V20H60Q.png"/></div></div></figure><p id="d596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先用<code class="fe lw lx ly lz b">temp_gen1 = gen1()</code>初始化我们的生成器对象。接下来，我们使用<code class="fe lw lx ly lz b">next</code>关键字。这允许我们跳到我们的<code class="fe lw lx ly lz b">yield</code>语句的下一个迭代。鉴于这是第一次调用<code class="fe lw lx ly lz b">next</code>关键字，它应该转到我们的<code class="fe lw lx ly lz b">“I am the bone of my sword”</code>。</p><p id="175e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来测试一下！</p><p id="ee90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="7b20" class="mg mh it lz b gy mi mj l mk ml">I am the bone of my sword</span></pre><p id="a604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，它返回了第一个<code class="fe lw lx ly lz b">yield</code>语句。没什么意思。让我们添加另一个<code class="fe lw lx ly lz b">next(temp_gen1)</code>并打印到控制台:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="2eaf" class="mg mh it lz b gy mi mj l mk ml">print(  next(temp_gen1) )</span></pre><p id="7c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="e1d4" class="mg mh it lz b gy mi mj l mk ml">I am the bone of my sword<br/>Steel is my body and fire is my blood</span></pre><p id="7c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在看看发生了什么？直接跳到了下一条<code class="fe lw lx ly lz b">yield</code>语句！</p><p id="73b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加另一个<code class="fe lw lx ly lz b">next(temp_gen1)</code>并将其打印到控制台:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="fc90" class="mg mh it lz b gy mi mj l mk ml">print(  next(temp_gen1) )</span></pre><p id="91a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="1233" class="mg mh it lz b gy mi mj l mk ml">I am the bone of my sword<br/>Steel is my body and fire is my blood<br/>I have created over a thousand blades</span></pre><p id="2255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到模式了吗？正如我们之前所讨论的，它允许您返回一组特定的数据，但也存储了调用<code class="fe lw lx ly lz b">yield</code>的点，如果您希望在下一次调用时跳过它。</p><p id="d12f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论何时调用<code class="fe lw lx ly lz b">next</code>关键字，它都会跳转到下一个<code class="fe lw lx ly lz b">yield</code>调用。如果您愿意，您可以轻松存储每次<code class="fe lw lx ly lz b">yield</code>呼叫的结果。</p><p id="f4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/21fec8b4f12b87f304f08a4ecbad3433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NsHHLPH437U5c_-HelECg.png"/></div></div></figure><p id="5118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能很好奇如果没有下一个<code class="fe lw lx ly lz b">yield</code>电话会发生什么，对吗？嗯，它会简单地抛出一个<code class="fe lw lx ly lz b">StopIteration</code>异常。</p><p id="a74b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过打印另一个<code class="fe lw lx ly lz b">next(temp_gen1)</code>并执行来尝试一下。</p><p id="902e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="aa13" class="mg mh it lz b gy mi mj l mk ml">I am the bone of my sword<br/>Steel is my body and fire is my blood<br/>I have created over a thousand blades<br/>Traceback (most recent call last):<br/>  File "d:/Jordan_Williams/coding1/Coding/Medium/idea 9/main.py", line 16, in &lt;module&gt;<br/>    print(  next(temp_gen1) )<br/>StopIteration</span></pre><p id="7567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抛出一个<code class="fe lw lx ly lz b">StopIteration</code>。要重新开始，必须重新分配发电机。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="7e56" class="mw mh it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">保持状态</h1><p id="df9a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">发电机不会简单地在每一个呼叫中进入下一个<code class="fe lw lx ly lz b">yield</code>。他们也维持着一种状态。</p><p id="de4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面使用相同函数的示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/79c0cd63c5e0835589a5c10911b0180d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxgvFBLuKNLVCjTP7mN9XQ.png"/></div></div></figure><p id="e5e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们声明了一个生成前三个偶数的生成器。在生成器中，<code class="fe lw lx ly lz b">even</code>变量每次由<code class="fe lw lx ly lz b">2</code>递增，然后传递给<code class="fe lw lx ly lz b">yield</code>每次返回。</p><p id="53e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这些打印出来，看看它们的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/d7c02e93cb901c3824b3d672495fdef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3WD3eH2R2Xq47NGrxPEGA.png"/></div></div></figure><p id="e751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="65f0" class="mg mh it lz b gy mi mj l mk ml">initialize counter<br/>First even:<br/>2<br/>Second even:<br/>4<br/>Third even:<br/>6</span></pre><p id="e744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该函数能够打印前三个偶数。在整个函数中，<code class="fe lw lx ly lz b">even</code>变量一直保持不变。</p><p id="6fed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="4fa1" class="mw mh it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">循环发生器</h1><p id="6d1d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">生成器也可以像常规列表一样循环。</p><p id="fbca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一个循环，而不是像前面的例子那样打印:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3bcbfa27e21a88e0a3e512ce989181c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*0ACTl9m_jeHhazgonyU1zg.png"/></div></figure><p id="a886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="21d6" class="mg mh it lz b gy mi mj l mk ml">initialize counter<br/>First even:<br/>2<br/>Second even:<br/>4<br/>Third even:<br/>6</span></pre><p id="3bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用循环的好处是它将从头到尾贯穿所有的<code class="fe lw lx ly lz b">yield</code>。这样，我们就不必担心当没有更多数据需要处理时，函数会出现<code class="fe lw lx ly lz b">StopIteration</code>异常。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="8794" class="mw mh it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">记忆效率</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/4499fda0e98f798fecc969edd4c3c46e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0poXpT51IlnJ1OCOKqzPA.png"/></div></div></figure><p id="0d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数将两个范围之间的数字序列生成一个列表。有了这样一个函数，所有的数字在初始化的时候都会被加载到内存中。</p><p id="8989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们用范围为100-100，000，000的序列初始化它，所有的数字都会被生成。</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="4f03" class="mg mh it lz b gy mi mj l mk ml">data = seq(100,100_000_000)</span></pre><p id="9437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为这一代人的死刑计时。</p><p id="82b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们必须导入Python时间库:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="0e6f" class="mg mh it lz b gy mi mj l mk ml">import time</span></pre><p id="21d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了计时该序列的生成，我们将使用下面的代码片段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/b1f479921b44d65ca56a5752aad8269e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-PvcrDimoJZ-RYwbQWinA.png"/></div></div></figure><p id="f133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lw lx ly lz b">time.time()</code>从开始到结束对<code class="fe lw lx ly lz b">data = seq(100,100_000_000)</code>进行计时。该函数返回以秒为单位的当前时间。</p><p id="286c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="9593" class="mg mh it lz b gy mi mj l mk ml">execution time: 8.553153991699219</span></pre><p id="3779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数的执行时间为8秒，因为所有元素都已生成。</p><p id="1a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="64fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上面的代码片段不同，生成器按需创建序列。只有在使用<code class="fe lw lx ly lz b">next</code>关键字时，才会加载元素。</p><p id="4dee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个与之前使用的函数等价的函数，但是这次使用生成器语法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/7cfb3f5531a5d4ffef1be864c617c5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8UUmbbtWm9vC0jOfnvHPOA.png"/></div></div></figure><p id="78a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们替换前面示例中的函数并运行它。</p><p id="0ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="5969" class="mg mh it lz b gy mi mj l mk ml">execution time: 0.0</span></pre><p id="f31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">0.0秒。尽管这个时间可能不是100%准确，但你会注意到发电机的能量。在使用<code class="fe lw lx ly lz b">next</code>关键字或循环之前，不会生成任何元素。</p><h2 id="c384" class="mg mh it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated"><strong class="ak">内存优势</strong></h2><ol class=""><li id="fc69" class="oh oi it lb b lc nn lf no li oj lm ok lq ol lu om on oo op bi translated">记忆不是无限的。一个常规的列表会把所有的东西都存储在内存中，并且会因为大量的数据流而使你的系统崩溃。</li><li id="2b7c" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">您可能不想一次得到所有数据，甚至不想一开始就得到所有数据。</li></ol><p id="9dba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么在Python库和函数的许多实现中使用生成器的一些原因。它们在文件读取库中很常见。</p><p id="3545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lw lx ly lz b">map</code>、<code class="fe lw lx ly lz b">filter</code>和<code class="fe lw lx ly lz b">open</code>函数在Python中很常见。在Python 2中，使用这些函数将返回一个列表。然而，从Python 3开始，它们的实现转向了生成器。</p><h2 id="47e3" class="mg mh it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated"><strong class="ak">地图</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="d0be" class="mg mh it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated"><strong class="ak">过滤器</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="daaa" class="mg mh it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated"><strong class="ak">打开</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bb56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些例子都使用<code class="fe lw lx ly lz b">next</code>关键字跳转到下一个序列。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="7572" class="mw mh it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">无限序列</h1><p id="7b30" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">生成器仅按需创建元素。这提供了创建无限序列的能力。这可以通过创建无限循环的<code class="fe lw lx ly lz b">yield</code>数据来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/567f98dac65bd0451263959a061aa3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LqePWWYDOhFf5DtphXDf9Q.png"/></div></div></figure><p id="518d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细看这个函数:<code class="fe lw lx ly lz b">while True</code>。这个循环永远不会结束，因为它给出了从<code class="fe lw lx ly lz b">1</code>到无穷大的每个数字的平方。但是，因为有发电机，这是没有问题的。</p><p id="dd46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以运行这个生成器任意次，它会产生一个值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/99ca6b4a059f873f69ef51c3c584bf00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kQJv7Y9n2iP7xu5KB7rJg.png"/></div></div></figure><p id="8d28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="04a8" class="mg mh it lz b gy mi mj l mk ml">1<br/>4<br/>9</span></pre><p id="fdd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看，它产生数字<em class="ma"> 1 </em>、<em class="ma"> 2 </em>和<em class="ma"> 3 </em>的平方。这可以做无数次。</p><p id="a4f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="0b21" class="mw mh it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">生成器表达式</h1><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="de8b" class="mg mh it lz b gy mi mj l mk ml">&gt;&gt;&gt; list_compr = [i ** 2 for i in range(5)]<br/>&gt;&gt;&gt; list_compr<br/>[0, 1, 4, 9, 16]<br/>&gt;&gt;&gt;</span></pre><p id="183a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的片段说明了<strong class="lb iu"> <em class="ma"> </em> </strong> <em class="ma">列表理解</em>。这是创建列表的一种Pythonic方式。</p><p id="c608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经知道发电机可以创造序列。然而，前面所有的例子都使用了函数。嗯，生成器表达式提供了一种类似的方式来创建序列，比如列表。</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="3b7b" class="mg mh it lz b gy mi mj l mk ml">&gt;&gt;&gt; list_generator = (i ** 2 for i in range(5))<br/>&gt;&gt;&gt; list_generator<br/>&lt;generator object &lt;genexpr&gt; at 0x000001F7F60D3CC8&gt;<br/>&gt;&gt;&gt;</span></pre><p id="21be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细看。</p><p id="c9a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解使用方括号(<code class="fe lw lx ly lz b">[i ** 2 for i in``` range(5)]</code>)，生成器使用圆括号(<code class="fe lw lx ly lz b">(i ** 2 for i in range(5))</code>)。这个微小的差别变成了一个发电机。</p><p id="12aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很方便，不是吗？</p><p id="1346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来测试一下:</p><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="ed2a" class="mg mh it lz b gy mi mj l mk ml">&gt;&gt;&gt; next(list_generator)<br/>0<br/>&gt;&gt;&gt; next(list_generator)<br/>1<br/>&gt;&gt;&gt; next(list_generator)<br/>4<br/>&gt;&gt;&gt; next(list_generator)<br/>9<br/>&gt;&gt;&gt; next(list_generator)<br/>16<br/>&gt;&gt;&gt;</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="4e19" class="mw mh it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><p id="7d6e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">生成器是列表的有用替代品。当有大量数据时，或者如果您希望方便地给出流中的后续元素，可以使用它们。许多Python库都是用它们构建的。我强烈建议您在自己的代码中尝试一下。</p><p id="2bad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一起在Python的旅程中继续成长吧！</p></div></div>    
</body>
</html>