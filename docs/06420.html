<html>
<head>
<title>Functional Programming With Java: map, filter, and reduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java函数式编程:映射、过滤和归约</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-with-java-map-filter-and-reduce-d0df1092d6ee?source=collection_archive---------6-----------------------#2020-09-30">https://betterprogramming.pub/functional-programming-with-java-map-filter-and-reduce-d0df1092d6ee?source=collection_archive---------6-----------------------#2020-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="065d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最常用的流操作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3ca22272535081e021ddfd85d6923477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FR3kuTgPP6xwdgsp_-gQtg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kate5oh3?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯蒂·史密斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/katie-smith-cooking?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3d74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三个方法，<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">filter</code>和<code class="fe lv lw lx ly b">reduce</code>，是任何<a class="ae ky" href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731" rel="noopener">函数式编程</a>的基石。</p><p id="6053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我们的数据管道由一个或多个<a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/package-summary.html#StreamOps" rel="noopener ugc nofollow" target="_blank">中间操作</a>，转换(又名<em class="lz">映射</em>)和/或过滤元素，以及一个再次收集数据的终端操作(又名<em class="lz">减少</em>)组成。</p><p id="1945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这三个，我们可以做很多事情，所以有必要深入了解它们。但是他们有一些近亲也是有用的。</p><p id="711e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:本文假设Java 9。为了可读性，方法签名和可见性修饰符被缩短了。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/35205717f70a0d30f1178327d4e89c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S72S-nYJ2oH-QugtBeIBdQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dead____artist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">捕捉人心。</a>上<a class="ae ky" href="https://unsplash.com/s/photos/map?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">下</a></p></figure><h1 id="6a3a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">地图</h1><p id="d99b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#map-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">Stream#map(Function&lt;T&gt; mapper)</a></code>是转换每个元素的中间流操作。它应用它的参数a <code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html" rel="noopener ugc nofollow" target="_blank">Function&lt;T, R&gt;</a></code>，并返回一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html" rel="noopener ugc nofollow" target="_blank">Stream&lt;R&gt;</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="7e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是要点；使用起来非常简单。但是根据类型的不同，有专门的<code class="fe lv lw lx ly b">map</code>函数。</p><h2 id="8a90" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">平面地图</h2><p id="f244" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">Stream#flatMap(Function&lt;T, Stream&lt;R&gt;)</a></code>是经常被误解的<code class="fe lv lw lx ly b">map</code>的兄弟姐妹。</p><p id="5d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时映射函数会返回任意数量的结果，包装成另一种类型，比如<code class="fe lv lw lx ly b">java.util.List</code>:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="499d" class="nh mj it ly b gy nx ny l nz oa">var identifier = List.of(1L, 5L);</span><span id="de91" class="nh mj it ly b gy ob ny l nz oa">Function&lt;Long, List&lt;String&gt;&gt; mapper = (id) -&gt; ...;</span><span id="fe1a" class="nh mj it ly b gy ob ny l nz oa">identifier.stream()     // Stream&lt;Long&gt;<br/>          <strong class="ly iu">.map(mapper)</strong>  // Stream&lt;<strong class="ly iu">List&lt;String&gt;</strong>&gt;<br/>          <strong class="ly iu">???</strong></span></pre><p id="50aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最有可能的是，我们想要处理列表的内容，而不是列表本身。通过使用<code class="fe lv lw lx ly b">flatMap</code>，我们可以将<code class="fe lv lw lx ly b">Stream&lt;List&lt;String&gt;&gt;</code>映射到一个<code class="fe lv lw lx ly b">Stream&lt;String&gt;</code>:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="0862" class="nh mj it ly b gy nx ny l nz oa">var identifier = List.of(1L, 5L);</span><span id="570f" class="nh mj it ly b gy ob ny l nz oa">Function&lt;Long, List&lt;String&gt;&gt; mapper = (id) -&gt; ...;</span><span id="ff24" class="nh mj it ly b gy ob ny l nz oa">identifier.stream()                    // Stream&lt;Long&gt;<br/>          .map(mapper)                 // Stream&lt;List&lt;String&gt;&gt;<br/>          <strong class="ly iu">.flatMap(Collection::stream) // Stream&lt;String&gt;</strong><br/>          ...</span></pre><h2 id="d0d4" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">可选<t>#平面图</t></h2><p id="cf05" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">java.util.Optional&lt;T&gt;</a></code>的情况下，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#flatMap-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">flatMap</a></code>方法用于将<code class="fe lv lw lx ly b">Optional</code>展平回其内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#flatMap-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">flatMap</a></code>的实现甚至比<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#map-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">map</a></code>做得更少，因为它省略了将映射器的返回值重新打包到新的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">Optional</a></code>中。</p><h2 id="1d08" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">值类型映射/平面映射</h2><p id="62e5" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在<a class="ae ky" href="https://openjdk.java.net/projects/valhalla/" rel="noopener ugc nofollow" target="_blank">项目Valhalla </a>和<a class="ae ky" href="https://openjdk.java.net/jeps/218" rel="noopener ugc nofollow" target="_blank">泛型专门化</a>到来之前，处理值类型和泛型总是一个特例。</p><p id="abf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以依靠自动装箱，但我们不能否认这有额外的开销。JDK包括专门的流类型来改进值类型的处理:</p><ul class=""><li id="64e7" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/IntStream.html" rel="noopener ugc nofollow" target="_blank">IntStream</a></code></li><li id="3046" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/LongStream.html" rel="noopener ugc nofollow" target="_blank">LongStream</a></code></li><li id="de9d" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/DoubleStream.html" rel="noopener ugc nofollow" target="_blank">DoubleStream</a></code></li></ul><p id="68a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的映射函数返回一个相关的值类型，我们可以使用相应的<code class="fe lv lw lx ly b">mapTo...(mapper)</code> / <code class="fe lv lw lx ly b">flatMapTo...(mapper)</code>来创建一个基于值类型的流:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="3356" class="nh mj it ly b gy nx ny l nz oa">   IntStream <a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#mapToInt-java.util.function.ToIntFunction-" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">mapToInt</strong>(ToIntFunction&lt;T&gt; mapper)</a><br/>  LongStream <a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#mapToLong-java.util.function.ToLongFunction-" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">mapToLong</strong>(ToLongFunction&lt;T&gt; mapper)</a><br/>DoubleStream <a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#mapToDouble-java.util.function.ToDoubleFunction-" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">mapToDouble</strong>(ToDoubleFunction&lt;T&gt; mapper)</a></span><span id="db31" class="nh mj it ly b gy ob ny l nz oa">   IntStream <a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#flatMapToInt-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">flatMapToInt</strong>(Function&lt;T, IntStream&gt; mapper)</a><br/>  LongStream <a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#flatMapToLong-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">flatMapToLong</strong>(Function&lt;T, LongStream&gt; mapper)</a><br/>DoubleStream <a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#flatMapToDouble-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">flatMapToDouble</strong>(Function&lt;T, DoubleStream&gt; mapper)</a></span></pre><p id="7923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以得到一个真正的<code class="fe lv lw lx ly b">long</code>数组，而不需要中间装箱:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="169e" class="nh mj it ly b gy nx ny l nz oa">long[] hashCodes =<br/>    List.of("hello", "world")<br/>        .stream()<br/>        <strong class="ly iu">.mapToInt</strong>(String::hashCode)<br/>        .toArray();</span></pre><h2 id="8cde" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">为每一个</h2><p id="b821" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如前所述，<code class="fe lv lw lx ly b">map</code>是一种中间操作。许多其他语言使用它来对所有元素执行操作，如果不使用<code class="fe lv lw lx ly b">void</code>，则丢弃任何返回类型。</p><p id="1603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以像那样使用<code class="fe lv lw lx ly b">map</code>,但是还有更好的方法。</p><p id="03ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过利用终端操作<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-" rel="noopener ugc nofollow" target="_blank">Stream#forEach(Consumer&lt;T&gt;)</a></code>，我们将消费者应用于流的每个元素:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="7848" class="nh mj it ly b gy nx ny l nz oa">listeners.stream()<br/>         ... // other operations<br/>         <strong class="ly iu">.forEach</strong>(this::trigger);</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/3b8dd5481c71f3c1b5fe9c8c040c7d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPS41sdX-a3AEq8WT23RiQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">韦德·奥斯汀·埃利斯在<a class="ae ky" href="https://unsplash.com/s/photos/filter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="f5e7" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">过滤器</h1><p id="a13a" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">Stream&lt;T&gt;#filter(Predicate&lt;T&gt; predicate)</a></code>用于，你猜对了，过滤元素。如果谓词返回<code class="fe lv lw lx ly b">true</code>，元素将在流中进一步移动:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="824a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用一个变量作为谓词，那么使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/function/Predicate.html#negate--" rel="noopener ugc nofollow" target="_blank">Predicate&lt;T&gt;#negate()</a></code>很容易被否定。Java 11甚至为我们提供了<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html#not(java.util.function.Predicate)" rel="noopener ugc nofollow" target="_blank">static &lt;T&gt; Predicate&lt;T&gt;not​(Predicate&lt;T&gt; target)</a></code>方法，所以我们可以用lambda:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="380e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并非所有人都已经使用了Java 11。但是我们可以在一个助手类中复制它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="12ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">助手类也可以是<code class="fe lv lw lx ly b">import static</code>，所以我们可以省略<code class="fe lv lw lx ly b">StreamHelpers</code>。</p><h2 id="9e35" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">takeWhile / dropWhile</h2><p id="145b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这两种方法，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#takeWhile-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">takeWhile</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#dropWhile-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">dropWhile</a></code>，是<code class="fe lv lw lx ly b">filter</code>的近亲。他们的名字很容易理解。</p><p id="aabd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是<em class="lz">短路流操作</em>，如果不必要，不处理流的所有元素。如果谓词返回<code class="fe lv lw lx ly b">false</code>，则丢弃流的剩余部分(<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#takeWhile-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">takeWhile</a></code>)或者丢弃之前的所有内容(<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#dropWhile-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">dropWhile</a></code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="ef42" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">无序流</h2><p id="33dd" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">只要流是有序的，这些方法就能按预期工作。在无序流的情况下，它们很容易变得不确定。如果不是所有元素都与谓词匹配，则返回的元素是任意的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因很简单:因为不清楚谓词遇到元素的顺序，所以结果不可能是确定的。</p><h2 id="45e3" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">平行流</h2><p id="cb24" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">由于这些方法的有序性质，在并行流中使用它们是非常昂贵的，会影响整体性能。通常，顺序流是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#takeWhile-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">takeWhile</a></code>或<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#dropWhile-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">dropWhile</a></code>的更好选择。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/0a188a3646408b6a2366ec5be8529e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6G37GugPhOGTNqH32ar_5A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aidan_t?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾丹·托德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/french-press?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="631a" class="mi mj it bd mk ml or mn mo mp os mr ms jz ot ka mu kc ou kd mw kf ov kg my mz bi translated">减少</h1><p id="3f4a" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><code class="fe lv lw lx ly b">reduce</code>方法，在函数式编程行话中也称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> fold </em> </a>，用一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/function/BinaryOperator.html" rel="noopener ugc nofollow" target="_blank">BinaryOperator&lt;T&gt;</a></code>累加流中的元素，并将它们缩减为一个值:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="dd0d" class="nh mj it ly b gy nx ny l nz oa">T <a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#reduce-java.util.function.BinaryOperator-" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">reduce</strong>(T initialValue, BinaryOperator&lt;T&gt; accumulator)</a></span></pre><p id="a5ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个常见的用例是对值求和:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="42df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外还有两种<code class="fe lv lw lx ly b">reduce</code>型号可供选择:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="e5c8" class="nh mj it ly b gy nx ny l nz oa">Optional&lt;T&gt; <a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">reduce</strong>(BinaryOperator&lt;T&gt; accumulator)</a></span><span id="9ba0" class="nh mj it ly b gy ob ny l nz oa">      &lt;U&gt; U <a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#reduce-U-java.util.function.BiFunction-java.util.function.BinaryOperator-" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">reduce</strong>(U initialValue</a>,<br/>                   BiFunction&lt;U, T, U&gt; accumulator,<br/>                   BinaryOperator&lt;U&gt; combiner);</span></pre><p id="a6ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个不需要初始值。因此，我们可能找不到匹配的元素来累积，因此将<code class="fe lv lw lx ly b">Optional&lt;T&gt;</code>作为返回类型。</p><p id="926e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个用于并行流。累加可以并行化，多个结果合并。</p><h2 id="2644" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">计数/总和/最小值/最大值</h2><p id="39cc" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">常见的<code class="fe lv lw lx ly b">reduce</code>用例已经可供我们使用，取决于流类型:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="892b" class="nh mj it ly b gy nx ny l nz oa">// All Streams</span><span id="9ffe" class="nh mj it ly b gy ob ny l nz oa"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#count--" rel="noopener ugc nofollow" target="_blank">long Stream&lt;T&gt;#<strong class="ly iu">count</strong>()</a></span><span id="affe" class="nh mj it ly b gy ob ny l nz oa">// Value-Type Streams</span><span id="f7ef" class="nh mj it ly b gy ob ny l nz oa"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/IntStream.html#sum--" rel="noopener ugc nofollow" target="_blank">int IntStream#<strong class="ly iu">sum</strong>()</a><br/><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/IntStream.html#min--" rel="noopener ugc nofollow" target="_blank">int IntStream#<strong class="ly iu">min</strong>()</a> <br/><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/IntStream.html#max--" rel="noopener ugc nofollow" target="_blank">int IntStream#<strong class="ly iu">max</strong>()</a></span><span id="435b" class="nh mj it ly b gy ob ny l nz oa"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/LongStream.html#sum--" rel="noopener ugc nofollow" target="_blank">long LongStream#<strong class="ly iu">sum</strong>()</a><br/><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/LongStream.html#min--" rel="noopener ugc nofollow" target="_blank">long LongStream#<strong class="ly iu">min</strong>()</a> <br/><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/LongStream.html#max--" rel="noopener ugc nofollow" target="_blank">long LongStream#<strong class="ly iu">max</strong>()</a></span><span id="076a" class="nh mj it ly b gy ob ny l nz oa"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/DoubleStream.html#sum--" rel="noopener ugc nofollow" target="_blank">double DoubleStream#<strong class="ly iu">sum</strong>()</a><br/><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/DoubleStream.html#min--" rel="noopener ugc nofollow" target="_blank">double DoubleStream#<strong class="ly iu">min</strong>()</a><br/><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/util/stream/DoubleStream.html#max--" rel="noopener ugc nofollow" target="_blank">double DoubleStream#<strong class="ly iu">max</strong>()</a></span></pre><p id="aaca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解<code class="fe lv lw lx ly b">reduce</code>操作，让我们自己做一个简单的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="eb9c" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">收集者</h2><p id="4f6f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">通过聚合流的元素，收集器在主题上与<code class="fe lv lw lx ly b">reduce</code>相关。我们可以用这两种方法获得相似的结果，但是它们之间的区别更加微妙。</p><p id="5e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">reduce</code>操作通过以不可变的方式组合两个值来创建一个新值。然而，收集器使用可变的累积对象。</p><p id="dbb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实现两者的<code class="fe lv lw lx ly b">String</code>串联:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">reduce</code>版本创建了许多<code class="fe lv lw lx ly b">String</code>对象，因为它只能以不可变的方式工作。但是收集器可以利用可变的累积对象来减少实例化。</p><p id="c951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该选择哪一个取决于我们的需求，考虑实际的预期目的、性能考虑等。如果我们处理不可变值类型，应该使用典型的归约。但是如果我们需要累积到一个可变的数据结构中，收集器可能更有意义。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ab62" class="mi mj it bd mk ml or mn mo mp os mr ms jz ot ka mu kc ou kd mw kf ov kg my mz bi translated">结论</h1><p id="1249" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">了解我们(功能)工具箱中最重要的工具总是一个好主意。</p><p id="399b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">map</code>作为变换应用于一个元素。</p><p id="9dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">filter</code>只累加与a <code class="fe lv lw lx ly b">Predicate&lt;T&gt;</code>匹配的元素。</p><p id="a004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">reduce</code>通过使用不可变值，将所有元素累加到一个值中。</p><p id="4153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这条推文完美地总结了这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ng l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nt ly ox bn oy oz bi"><span id="297f" class="pa mj it ly b be pb pc l nz oa"><strong class="ly iu">You like my ramblings about Java?<br/>Check out my upcoming book!<br/></strong><a class="ae ky" href="https://belief-driven-design.com/book/" rel="noopener ugc nofollow" target="_blank">https://belief-driven-design.com/book/</a></span></pre><h1 id="b09c" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">资源</h1><ul class=""><li id="c054" class="oc od it lb b lc na lf nb li pd lm pe lq pf lu oh oi oj ok bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Map_(higher-order_function)" rel="noopener ugc nofollow" target="_blank">地图(高阶函数)</a>(维基百科)</li><li id="0a72" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Filter_(higher-order_function)" rel="noopener ugc nofollow" target="_blank">过滤器(高阶函数)</a>(维基百科)</li><li id="8782" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)" rel="noopener ugc nofollow" target="_blank">折叠(高阶函数)(维基百科)</a></li><li id="c8b7" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/collections/streams/reduction.html" rel="noopener ugc nofollow" target="_blank">Java教程:还原</a>(甲骨文)</li><li id="8a1a" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated"><a class="ae ky" href="https://web.mit.edu/6.005/www/fa15/classes/25-map-filter-reduce/" rel="noopener ugc nofollow" target="_blank">麻省理工学院6.005软件构造</a>(麻省理工学院)</li></ul><h1 id="6811" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">相关文章</h1><div class="pg ph gp gr pi pj"><a href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731" rel="noopener follow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">Java函数式编程:简介</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">Java从来就不是函数式语言，但这并不意味着我们不能尝试</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">medium.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ks pj"/></div></div></a></div><div class="pg ph gp gr pi pj"><a href="https://medium.com/better-programming/functional-programming-with-java-streams-f930e0e4d184" rel="noopener follow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">Java函数式编程:流</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">最佳实践概述</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">medium.com</p></div></div><div class="ps l"><div class="py l pu pv pw ps px ks pj"/></div></div></a></div></div></div>    
</body>
</html>