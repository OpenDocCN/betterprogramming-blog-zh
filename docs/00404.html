<html>
<head>
<title>Weak Self and Unowned Self in Swift Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斯威夫特解释了软弱的自我和无主的自我</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/weak-self-and-unowned-self-explained-in-swift-65d73697a004?source=collection_archive---------2-----------------------#2019-05-14">https://betterprogramming.pub/weak-self-and-unowned-self-explained-in-swift-65d73697a004?source=collection_archive---------2-----------------------#2019-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b4dd65136886d583b6a7e4596b28c27a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ukoHTJu4Sfh0TNsiAjPZw.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@otoriii" rel="noopener ugc nofollow" target="_blank">大卫·艾姆里奇</a>在<a class="ae kf" href="https://unsplash.com/photos/TdeCF3XmDWg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d42f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">斯威夫特中的弱小自我和无主自我，对于我们很多人来说，都是难以理解的。尽管自动引用计数(ARC)已经为我们解决了很多问题，但是当我们不使用值类型时，我们仍然需要管理引用。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="af4a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">什么是弧、保留和释放？</h1><p id="c025" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们需要从基本面入手，才能充分理解弱自我和无主自我在做什么。通读Swift文档中的<a class="ae kf" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank">自动引用计数可以最好地解释这些概念。这一切都归结于内存管理。</a></p><p id="16f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在ARC之前，我们必须手动管理内存和引用。这导致了许多错误和令人头痛的问题。当一个新实例保留一个对象时，引用计数增加，而当一个引用被释放时，引用计数减少。一旦没有对对象的引用，也就是说不再需要该对象，就释放内存。</p><p id="f3f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Swift中，我们需要使用弱自我和无主自我来给ARC提供我们代码中关系之间所需的信息。它基本上告诉我们的代码是否需要某个强引用，并防止引用计数下降到零。</p><p id="13f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有正确使用这些关键字，我们可能会保留内存，这可能会导致应用程序中出现内存警告。如果没有正确使用弱引用和无主引用，也会发生所谓的强引用循环或保留循环。</p><p id="6f0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我在这篇博文中引用并解释的那样，很高兴知道:</p><blockquote class="mo mp mq"><p id="438c" class="kg kh mr ki b kj kk kl km kn ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ld im bi translated">引用计数仅适用于类的实例。结构和枚举是值类型，而不是引用类型，并且不通过引用来存储和传递。</p></blockquote></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="04fa" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">何时使用弱自我</h1><p id="0bc7" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">首先，弱引用总是被声明为可选变量，因为当它的引用被释放时，它们可以被ARC自动设置为<code class="fe mv mw mx my b">nil</code>。下面两个类将帮助解释何时使用弱引用。</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="67aa" class="nh lm it my b gy ni nj l nk nl">class Blog {<br/>    let name: String<br/>    let url: URL<br/>    var owner: Blogger?<br/><br/>    init(name: String, url: URL) { self.name = name; self.url = url }<br/><br/>    deinit {<br/>        print("Blog \(name) is being deinitialized")<br/>    }<br/>}<br/><br/>class Blogger {<br/>    let name: String<br/>    var blog: Blog?<br/><br/>    init(name: String) { self.name = name }<br/><br/>    deinit {<br/>        print("Blogger \(name) is being deinitialized")<br/>    }<br/>}</span></pre><p id="2ed1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦释放了这些类中的任何一个，就会打印出一条消息。在下面的代码示例中，我们将两个实例定义为可选的，然后将它们设置为<code class="fe mv mw mx my b">nil</code>。虽然你们中的一些人可能期望两个打印语句，但这实际上并没有发生:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="9434" class="nh lm it my b gy ni nj l nk nl">var blog: Blog? = Blog(name: "SwiftLee", url: URL(string: "www.avanderlee.com")!)<br/>var blogger: Blogger? = Blogger(name: "Antoine van der Lee")<br/><br/>blog!.owner = blogger<br/>blogger!.blog = blog<br/><br/>blog = nil<br/>blogger = nil<br/><br/>// Nothing is printed</span></pre><p id="139e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是保留周期的结果。该博客对其所有者有强烈的引用，并且不愿意发布。同时，主人也不愿意免费开放它的博客。博客不发布它的所有者，谁保留它的博客，谁保留他自己…好吧，你明白了。这是一个无限循环:保留循环。</p><p id="6083" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们需要引入一个弱引用。在本例中，只需要一个弱基准电压源，因为这已经打破了环路。例如，我们可以设置一个从博客到其所有者的弱引用:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="205b" class="nh lm it my b gy ni nj l nk nl">class Blog {<br/>    let name: String<br/>    let url: URL<br/>    weak var owner: Blogger?<br/><br/>    init(name: String, url: URL) { self.name = name; self.url = url }<br/><br/>    deinit {<br/>        print("Blog \(name) is being deinitialized")<br/>    }<br/>}<br/><br/>class Blogger {<br/>    let name: String<br/>    var blog: Blog?<br/><br/>    init(name: String) { self.name = name }<br/><br/>    deinit {<br/>        print("Blogger \(name) is being deinitialized")<br/>    }<br/>}<br/><br/>var blog: Blog? = Blog(name: "SwiftLee", url: URL(string: "www.avanderlee.com")!)<br/>var blogger: Blogger? = Blogger(name: "Antoine van der Lee")<br/><br/>blog!.owner = blogger<br/>blogger!.blog = blog<br/><br/>blog = nil<br/>blogger = nil<br/><br/>// Blogger Antoine van der Lee is being deinitialized<br/>// Blog SwiftLee is being deinitialized</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3fdc" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">但是弱小的自己呢？</h1><p id="bcf8" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我知道，这不是一个软弱的例子。不过，这的确解释了这个故事。</p><p id="b510" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我们大多数人来说，最好的做法是始终使用弱结合的self inside闭包来避免保留循环。然而，这仅在self也保持闭合时需要。如果你总是默认为弱势，你可能比你需要的更多的使用期权</p><p id="b100" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们为博客文章引入了一种发布方法。请注意，在本例中，我们通过手动添加延迟来伪造网络请求。</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="54f3" class="nh lm it my b gy ni nj l nk nl">struct Post {<br/>    let title: String<br/>    var isPublished: Bool = false<br/><br/>    init(title: String) { self.title = title }<br/>}<br/><br/>class Blog {<br/>    let name: String<br/>    let url: URL<br/>    weak var owner: Blogger?<br/><br/>    var publishedPosts: [Post] = []<br/><br/>    init(name: String, url: URL) { self.name = name; self.url = url }<br/><br/>    deinit {<br/>        print("Blog \(name) is being deinitialized")<br/>    }<br/><br/>    func publish(post: Post) {<br/>        /// Faking a network request with this delay:<br/>        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {<br/>            self.publishedPosts.append(post)<br/>            print("Published post count is now: \(self.publishedPosts.count)")<br/>        }<br/>    }<br/>}<br/><br/>var blog: Blog? = Blog(name: "SwiftLee", url: URL(string: "www.avanderlee.com")!)<br/>var blogger: Blogger? = Blogger(name: "Antoine van der Lee")<br/><br/>blog!.owner = blogger<br/>blogger!.blog = blog<br/><br/>blog!.publish(post: Post(title: "Explaining weak and unowned self"))<br/>blog = nil<br/>blogger = nil</span></pre><p id="4073" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印出以下内容:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="9db0" class="nh lm it my b gy ni nj l nk nl">// Blogger Antoine van der Lee is being deinitialized<br/>// Published post count is now: 1<br/>// Blog SwiftLee is being deinitialized</span></pre><p id="3e1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到请求在博客发布之前就已经完成了。强引用允许我们完成发布并将文章保存到我们发布的文章中。</p><p id="d663" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们要更改发布方法，改为包含弱引用:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="5a51" class="nh lm it my b gy ni nj l nk nl">func publish(post: Post) {<br/>    /// Faking a network request with this delay:<br/>    DispatchQueue.main.asyncAfter(deadline: .now() + 1) { [weak self] in<br/>        self?.publishedPosts.append(post)<br/>        print("Published post count is now: \(self?.publishedPosts.count)")<br/>    }<br/>}</span></pre><p id="006f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到以下输出:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="5f44" class="nh lm it my b gy ni nj l nk nl">// Blogger Antoine van der Lee is being deinitialized<br/>// Blog SwiftLee is being deinitialized<br/>// Published post count is now: nil</span></pre><p id="371f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于博客在发布请求完成之前就已经发布了，我们将永远无法更新已发布帖子的本地状态。</p><p id="56f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果闭包一执行，引用实例就有工作要做，请确保不要使用weak self。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="bee2" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">弱引用和保留周期</h1><p id="fa10" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">一旦封闭保持自我，自我保持封闭，保持循环就发生了。如果我们有一个包含<code class="fe mv mw mx my b">onPublish</code>闭包的变量，这可能会发生:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="4fd8" class="nh lm it my b gy ni nj l nk nl">class Blog {<br/>    let name: String<br/>    let url: URL<br/>    weak var owner: Blogger?<br/><br/>    var publishedPosts: [Post] = []<br/>    var onPublish: ((_ post: Post) -&gt; Void)?<br/><br/>    init(name: String, url: URL) {<br/>        self.name = name<br/>        self.url = url<br/><br/>        // Adding a closure instead to handle published posts<br/>        onPublish = { post in<br/>            self.publishedPosts.append(post)<br/>            print("Published post count is now: \(self.publishedPosts.count)")<br/>        }<br/>    }<br/><br/>    deinit {<br/>        print("Blog \(name) is being deinitialized")<br/>    }<br/><br/>    func publish(post: Post) {<br/>        /// Faking a network request with this delay:<br/>        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {<br/>            self.onPublish?(post)<br/>        }<br/>    }<br/>}<br/><br/>var blog: Blog? = Blog(name: "SwiftLee", url: URL(string: "www.avanderlee.com")!)<br/>var blogger: Blogger? = Blogger(name: "Antoine van der Lee")<br/><br/>blog!.owner = blogger<br/>blogger!.blog = blog<br/><br/>blog!.publish(post: Post(title: "Explaining weak and unowned self"))<br/>blog = nil<br/>blogger = nil</span></pre><p id="ad9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">闭包保留着博客，而博客保留着闭包。这将导致打印以下内容:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="d7dd" class="nh lm it my b gy ni nj l nk nl">// Blogger Antoine van der Lee is being deinitialized<br/>// Published post count is now: 1</span></pre><p id="859e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管计数为1时一切似乎都很好，但我们没有看到博客和发布者被去初始化。这是因为保留周期导致内存没有被释放。</p><p id="e325" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mv mw mx my b">onPublish</code>方法中添加对blog实例的弱引用解决了我们的保留周期:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="c46f" class="nh lm it my b gy ni nj l nk nl">onPublish = { [weak self] post in<br/>    self?.publishedPosts.append(post)<br/>    print("Published post count is now: \(self?.publishedPosts.count)")<br/>}</span></pre><p id="6857" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并产生以下输出:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="7fe1" class="nh lm it my b gy ni nj l nk nl">// Blogger Antoine van der Lee is being deinitialized<br/>// Published post count is now: Optional(1)<br/>// Blog SwiftLee is being deinitialized</span></pre><p id="510f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据保存在本地，所有实例都被释放。不再有保留周期。</p><p id="bb57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，总结一下这一部分，很高兴知道当ARC对<code class="fe mv mw mx my b">nil</code>设置了一个弱引用时，没有调用属性观察者。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a588" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">何时使用无主自我</h1><p id="673d" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">与弱引用不同，在使用unowned时，引用不会变成可选的。尽管如此，无主的和弱的都不会创建强引用。</p><p id="466b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">引自苹果文档:</p><blockquote class="mo mp mq"><p id="9e65" class="kg kh mr ki b kj kk kl km kn ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ld im bi translated">只要弱引用在其生命周期的某个时刻变为零是有效的，就使用弱引用。相反，当您知道引用一旦在初始化过程中被设置就永远不会为零时，请使用无主引用。</p></blockquote><p id="aa44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，使用unowned时要非常小心。这可能是因为您正在访问一个不再存在的实例，从而导致崩溃。使用unowned over weak的唯一好处是您不必处理期权。因此，在这些情况下，使用weak总是更安全。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="8003" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">为什么我们不需要像Structs这样的值类型呢？</h1><p id="87bf" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在Swift中，我们有<a class="ae kf" href="https://developer.apple.com/swift/blog/?id=10" rel="noopener ugc nofollow" target="_blank">值类型和</a>引用类型。</p><p id="ecea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这已经让事情变得更清楚了，因为对于引用类型，你实际上需要处理一个引用。这意味着您需要将这种关系管理为强关系、弱关系或无主关系。</p><p id="bc0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值类型保留其数据的唯一副本—唯一实例。这意味着在多线程环境中没有必要使用弱引用，因为没有引用，只有我们正在处理的唯一副本。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="5fc8" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">弱无主只和self一起用吗？</h1><p id="67b8" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">不，绝对不是。只要是引用类型，就可以将任何属性或变量声明为弱声明或无主声明。因此，这也可行:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="a8fe" class="nh lm it my b gy ni nj l nk nl">download(imageURL, completion: { [weak imageViewController] result in<br/>    // ...<br/>})</span></pre><p id="5601" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您甚至可以引用多个实例，因为它基本上是一个数组:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="b885" class="nh lm it my b gy ni nj l nk nl">download(imageURL, completion: { [weak imageViewController, weak imageFinalizer] result in<br/>    // ...<br/>})</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="c210" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="efb0" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这是一个很难理解的话题。最好从阅读<a class="ae kf" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank"> Swift文档</a>开始，它会更深入。此外，如果你不确定，使用弱无主。它可以让你远离烦人的虫子。</p><p id="016a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢！</p></div></div>    
</body>
</html>