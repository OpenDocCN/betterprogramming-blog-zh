<html>
<head>
<title>The Great Interface, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">伟大的界面，第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-great-interface-part-2-84e0ee73ceb2?source=collection_archive---------5-----------------------#2022-08-31">https://betterprogramming.pub/the-great-interface-part-2-84e0ee73ceb2?source=collection_archive---------5-----------------------#2022-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="87e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编程到接口而不是实现。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/558b49609b2fc0c32a08453c944fe2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnDIKuf1wSjZTuma5MGP-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片:伟大的界面工程</p></figure><p id="faaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我是一个干净的代码追求者。这些年来，我一直对界面的用法感到惊讶。接口是面向对象编程(OOP)的一个基本概念。</p><p id="1245" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是该系列的第二篇文章，通过它我从接口的角度来写OOP。如果你错过了《T2》第一部，我建议你先看一遍。</p><p id="7fe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将关注如何使用接口来实现一些面向对象的设计原则和模式。</p><p id="d581" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你处理复杂的软件系统时，了解这些OO设计原则和模式是非常有益的。不能保证你会得到用它们写一段代码的最好方法，但是它们通常会产生可维护和可测试的软件。好吧，我们开始吧。</p><h1 id="b52e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从属倒置原则</h1><p id="07df" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">马丁在《干净的建筑》一书中提到了5个设计原则，被称为“坚固的”。最后一个原则“D”是依赖倒置原则(DIP)的标准，我发现它对打破依赖循环非常有用。下面是一个典型的例子。</p><p id="eeaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我曾经开发过一个可以打VOIP电话的移动应用，我们会有一个如下图所示的组件图。根据Clean架构，经常变化的易失性软件将取决于更稳定的软件。该应用程序是易变的，因为它与用户界面相关，并且会经常改变，以不断改善用户体验；而CallSDK是一个稳定的组件，专注于不经常更改的低级功能。因此，应用程序依赖于CallSDK。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/8009034fb89e6b2af4fb5390880e5e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*bWZ9x0PLA4FMfQRTT2DvAA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图表</p></figure><p id="50d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，一切都很简单。但是，如果我们需要让应用程序从CallSDK中做一些事情，例如获取电池状态。直接思考可能是如下的组件设计。这会造成依赖循环，让应用和CallSDK高度耦合，这是非常不好的做法。CallSDK不应该依赖于应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/5778de5558777bd9ff062d3d261d78a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*qlfdS-pwBHXzo_YcBqKVDA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图表</p></figure><p id="1231" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了打破两个组件之间的依赖循环，我们可以使用DIP。下面的代码将让您大致了解它是如何工作的。接口<code class="fe mu mv mw mx b">BatteryService</code>在CallSDK中定义，但在应用程序中实现。换句话说，应用程序依赖于CallSDK的<code class="fe mu mv mw mx b">BatteryService</code>接口。使用DIP的结果是，依赖关系仍然从应用程序指向CallSDK。</p><h2 id="41df" class="my lw it bd lx mz na dn mb nb nc dp mf lh nd ne mh ll nf ng mj lp nh ni ml nj bi translated"><strong class="ak">应用</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="8b06" class="my lw it bd lx mz na dn mb nb nc dp mf lh nd ne mh ll nf ng mj lp nh ni ml nj bi translated"><strong class="ak">调用SDK </strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="5276" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设计模式</h1><p id="68d0" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">四人帮的《设计模式》一书中有24种面向对象的设计模式[3]。在大多数情况下，界面起着重要的作用。我将在这里阐述几种常见的模式。它们是策略、工厂方法和适配器。如果你有兴趣了解更多，我强烈建议你读这本书。</p><h2 id="d7fd" class="my lw it bd lx mz na dn mb nb nc dp mf lh nd ne mh ll nf ng mj lp nh ni ml nj bi translated"><strong class="ak">策略模式</strong></h2><p id="0f57" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当我们有一个复杂的开关情况时，策略模式是非常有用的。当您对每种情况都有不同的策略要执行时，通常会发生这种情况。使用策略模式使代码更干净。请看看下面显示的使用不同支付方式的示例购物应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/3cadfa0cf72f4faf6689c9c1ab6d3946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPZeLBC39wU30Fu18atXiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的策略模式的类图</p></figure><p id="0ef6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们定义接口<code class="fe mu mv mw mx b">PaymentStrategy</code>，它由三个不同的具体支付类实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2153" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后一个非常简单的<code class="fe mu mv mw mx b">Shopping</code>类如下，允许用户用不同的方法支付。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="65ea" class="my lw it bd lx mz na dn mb nb nc dp mf lh nd ne mh ll nf ng mj lp nh ni ml nj bi translated"><strong class="ak">工厂方法模式</strong></h2><p id="cf91" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">工厂方法是指将用于创建对象的方法。当移动应用变得越来越复杂时，工程师可能会决定在单独的框架/库中构建每个旅程。这是使用工厂方法模式的好地方，因为主机应用程序不知道为每个旅程创建什么具体的视图类。相反，宿主应用程序通过工厂方法接口将创建视图的任务委托给个人旅程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/98c9f62a5d0a09e0bc7dfadf53f7720a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*XmmRkrg3eV-PwCgO7Ggsiw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者工厂方法模式的类图</p></figure><p id="44df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的<code class="fe mu mv mw mx b">Common</code>包定义了每个旅程要实现的<code class="fe mu mv mw mx b">View</code>和<code class="fe mu mv mw mx b">ViewCreator</code>接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ed99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面显示了一个简单的“循环旅程”,因此只要符合视图界面，该旅程就可以自由地创建其花哨的视图。请注意<code class="fe mu mv mw mx b">CircleView</code>仅在包装内可见。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6d9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，另一个名为“广场之旅”的旅程如下图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="45c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的应用程序模拟用户访问不同的旅程，将调用工厂方法分别创建不同的视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="92e2" class="my lw it bd lx mz na dn mb nb nc dp mf lh nd ne mh ll nf ng mj lp nh ni ml nj bi translated"><strong class="ak">适配器模式</strong></h2><p id="af9e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">想想看，当你去另一个国家旅行，你的电源插头与插座不匹配时，你需要一个电源适配器。当两个现有的接口不匹配时，使用适配器模式，因此我们需要创建一个适配器来使整个事情一起工作。下面的类图向您展示了一个非常有趣的老式打印机问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/7b390d84f158259c883acedc14f4bf3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*2A7pRm5H-hW03j6KC1jx1g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的适配器模式的类图</p></figure><p id="1ec8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有一个非常老的打印机类，如下，我们不能修改它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="095c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数打印客户端使用最新的NewPrinter，它符合最新的打印机接口，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="beaf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了以与新打印机完全相同的方式使用旧打印机，我们将创建一个适配器。给你。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3d29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，通过调用打印机接口中定义的相同函数，客户机可以很容易地用新旧打印机进行打印。适配器只是帮助旧打印机适应打印机接口。请看看下面的示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="49ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5d74" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们已经在本文(第2部分)中讨论了很多。我们讨论了依赖倒置原则、策略模式、因素方法模式和适配器模式。所有这些都有接口作为设计的一部分。希望你发现它对更好地利用接口和使你的代码更整洁是有用的。</p><p id="5c6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一篇文章(第3部分)中，我将与您分享测试期间接口的神奇用法。</p><h1 id="f33c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ol class=""><li id="050e" class="np nq it la b lb mn le mo lh nr ll ns lp nt lt nu nv nw nx bi translated">你可以在GitHub的这里找到所有示例<a class="ae lu" href="https://github.com/CullenSUN/great_interface" rel="noopener ugc nofollow" target="_blank">的完整源代码。</a></li><li id="ffc1" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated"><a class="ae lu" href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164" rel="noopener ugc nofollow" target="_blank">干净的架构:软件结构和设计的工匠指南</a>，亚马逊的书。</li><li id="d549" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated"><a class="ae lu" href="https://www.amazon.com/gp/product/0201633612/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0201633612&amp;linkCode=as2&amp;tag=triatcraft-20&amp;linkId=XRGUDJCGWC6AJNZM" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素</a>，亚马逊的书。</li></ol></div></div>    
</body>
</html>