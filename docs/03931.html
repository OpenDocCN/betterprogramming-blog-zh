<html>
<head>
<title>How to Detect and Fix Memory Leaks With Chrome DevTools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Chrome DevTools检测并修复内存泄漏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-me-an-angular-app-with-memory-leaks-please-36302184e658?source=collection_archive---------0-----------------------#2020-03-13">https://betterprogramming.pub/build-me-an-angular-app-with-memory-leaks-please-36302184e658?source=collection_archive---------0-----------------------#2020-03-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="416b" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">网页性能</a></h2><div class=""/><div class=""><h2 id="5cb1" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">准备好提高您的web性能了吗？</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/ec3543e2dc4e7c6a3f9778568fb16299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pUXa4Ar815nA-GZSAnNR5g.gif"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">性能时间线记录:修复内存泄漏前后(动画由<a class="ae li" href="https://rakia-bensassi.medium.com/" rel="noopener">作者</a>制作)</p></figure><p id="0b26" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="mf">如果你喜欢看，可以在Udemy上查看我的</em> <strong class="ll je"> <em class="mf">视频课程</em></strong><em class="mf">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="mf">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="mf">。</em></p></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><p id="8618" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">去年，我的团队分配给我一项任务，是修复我们Angular应用程序中的一个性能问题。那一刻，我很害怕。我觉得我被那个任务惩罚了。</p><p id="017f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">目标应用的很大一部分是我写的，但我不知道我应该做什么来修复它。该应用程序在开始时运行流畅，但在添加新功能后，如对有角度的材料表进行在线编辑，它运行越来越慢，需要很长时间才能加载，最终用户对此完全不满意。</p><p id="6986" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">带着从艾迪·奥斯马尼的教程中学到的一些知识，我开始了我的任务。</p><p id="b858" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一开始，我很挣扎。表演太糟糕了，甚至连灯塔都无法开始运行。我在Lighthouse上遇到了一个错误，这是由于很长的<a class="ae li" href="https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint" rel="noopener ugc nofollow" target="_blank">第一次内容丰富的绘画(FCP) </a>和<a class="ae li" href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" rel="noopener ugc nofollow" target="_blank">交互时间(TTI) </a>造成的，但是几天后，我的热情增加了，因为我看到了Lighthouse审计和Chrome DevTools性能分析结果的改进。</p><div class="kt ku kv kw gu ab cb"><figure class="mp kx mq mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/e12b31088968d9e078192127fabc7dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*GR0S0ZLRwSmZR0jC7B9gtg.png"/></div></figure><figure class="mp kx mq mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/acebc3c7f9b315076e913c40b0040b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*6vcBfGtaHkk2DHgn1nh-Ig.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk mv di mw mx translated">性能调优之旅:改进前后</p></figure></div><p id="a4cc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">是的，我做到了。在介绍了我在性能调优过程中为实现这一结果所做的工作之后，我甚至从团队和利益相关者那里获得了非常积极、鼓舞人心的反馈。</p><p id="8d0e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">几周后，我的团队正在处理的第二个Angular应用程序开始出现类似的问题，但症状不同。</p><p id="86a0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">最终用户并没有对加载时间感到沮丧，但是在长时间使用该应用程序后，他们意识到它变得更慢、迟缓，并且似乎经常暂停。这一次，我没有害怕，但我很好奇导致问题的原因。</p><p id="78ae" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">经过一番调查，原来罪魁祸首是一个<strong class="ll je">内存泄露</strong>。</p><p id="c589" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">空谈不值钱。让我们创建一些代码，看看如何生成一个遭受内存泄漏的web应用程序，它会损害性能并让用户讨厌它。下面是我们今天的示例应用程序:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj my"><img src="../Images/a1f62980d55c1154dfee86ff5af69c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1Pj6UrlclqrCt9l1dVwyUQ.gif"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Angular todos管理app(动画由<a class="ae li" href="https://rakia-bensassi.medium.com/" rel="noopener">作者</a>创作)</p></figure><pre class="kt ku kv kw gu mz na nb nc aw nd bi"><span id="d343" class="ne nf iu na b gz ng nh l ni nj"><strong class="na je">Table of Contents</strong></span><span id="3d60" class="ne nf iu na b gz nk nh l ni nj"><a class="ae li" href="#402a" rel="noopener ugc nofollow"><strong class="na je">Project Setup</strong></a><strong class="na je"><br/></strong><a class="ae li" href="#2b58" rel="noopener ugc nofollow"><strong class="na je">Code</strong></a><strong class="na je"><br/></strong><a class="ae li" href="#7fe5" rel="noopener ugc nofollow"><strong class="na je">Time for Heap Snapshot</strong></a><strong class="na je"><br/></strong><a class="ae li" href="#3db1" rel="noopener ugc nofollow"><strong class="na je">New Feature Request</strong></a><strong class="na je"><br/></strong><a class="ae li" href="#7a4f" rel="noopener ugc nofollow"><strong class="na je">Performance Timeline Record</strong></a><strong class="na je"><br/></strong><a class="ae li" href="#4555" rel="noopener ugc nofollow"><strong class="na je">Identify JS Heap Memory Leaks</strong></a><strong class="na je"><br/></strong><a class="ae li" href="#3558" rel="noopener ugc nofollow"><strong class="na je">We’ve Got a Leak — How Do We Fix It?</strong></a><br/>  ∘ <a class="ae li" href="#7d23" rel="noopener ugc nofollow">Action 1: unsubscribing</a><br/>  ∘ <a class="ae li" href="#d0a1" rel="noopener ugc nofollow">Action 2: onlySelf &amp; emitEvent</a><br/>  ∘ <a class="ae li" href="#5853" rel="noopener ugc nofollow">Have we fixed it?</a><br/>  ∘ <a class="ae li" href="#ad09" rel="noopener ugc nofollow">Action 3: OnPush ChangeDetection</a><br/>  ∘ <a class="ae li" href="#1bf1" rel="noopener ugc nofollow">Action 4: Angular pipe &amp; minimize subscriptions</a><br/><a class="ae li" href="#97dc" rel="noopener ugc nofollow"><strong class="na je">What’s the Difference?</strong></a><strong class="na je"><br/></strong><a class="ae li" href="#a1a7" rel="noopener ugc nofollow"><strong class="na je">Conclusion</strong></a></span></pre></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><h1 id="402a" class="nl nf iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">项目设置</h1><p id="f0b3" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">你知道该怎么做。启动您的终端，运行命令<code class="fe oh oi oj na b">ng new</code>，并提供名称<code class="fe oh oi oj na b">apngular-memory-leaks</code>来创建应用程序:</p><pre class="kt ku kv kw gu mz na nb nc aw nd bi"><span id="abce" class="ne nf iu na b gz ng nh l ni nj">ng new angular-memory-leaks<br/>cd angular-memory-leaks</span></pre><p id="9fdb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oh oi oj na b">ng new</code>命令提示您初始应用程序中要包含的特性信息。您可以通过按Enter或Return键接受默认值。</p></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><h1 id="2b58" class="nl nf iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">密码</h1><p id="d0d6" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">好了，好东西来了。我们必须遵循接下来的步骤。</p><ul class=""><li id="a452" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">安装<a class="ae li" href="https://material.angular.io/components/table/overview" rel="noopener ugc nofollow" target="_blank">角材</a>和<a class="ae li" href="https://github.com/angular/flex-layout" rel="noopener ugc nofollow" target="_blank">角材伸缩布局</a>:</li></ul><pre class="kt ku kv kw gu mz na nb nc aw nd bi"><span id="26ec" class="ne nf iu na b gz ng nh l ni nj">npm install @angular/material<br/>npm install @angular/cdk<br/>npm install hammerjs<br/>npm install @angular/flex-layout</span></pre><ul class=""><li id="a3cd" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">通过将该行添加到<code class="fe oh oi oj na b">src/style.scss</code>来导入角度主题:</li></ul><pre class="kt ku kv kw gu mz na nb nc aw nd bi"><span id="fdb8" class="ne nf iu na b gz ng nh l ni nj">@import "~@angular/material/prebuilt-themes/indigo-pink.css";</span></pre><ul class=""><li id="4ae7" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">生成两个新组件，<code class="fe oh oi oj na b">todo-list</code>和<code class="fe oh oi oj na b">todo-dialog</code>:</li></ul><pre class="kt ku kv kw gu mz na nb nc aw nd bi"><span id="bbed" class="ne nf iu na b gz ng nh l ni nj">ng generate component todo-list<br/>ng generate component todo-dialog</span></pre><ul class=""><li id="6927" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">更新<code class="fe oh oi oj na b">app.module.ts</code> <em class="mf"> : </em></li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">应用程序模块</p></figure><ul class=""><li id="ecd2" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">将<code class="fe oh oi oj na b">app.component.html</code> <em class="mf"> </em>的内容替换为:</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">app.component.html</p></figure><ul class=""><li id="e69c" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">这就是<code class="fe oh oi oj na b">todo-list.component.html</code>的样子:</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><code class="fe oh oi oj na b">todo-list.component.html</code></p></figure><ul class=""><li id="1cb2" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated"><code class="fe oh oi oj na b">todo-list.component.css:</code></li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><code class="fe oh oi oj na b">todo-list.component.css</code></p></figure><ul class=""><li id="f9c2" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated"><code class="fe oh oi oj na b">todo-list.component.ts:</code></li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><code class="fe oh oi oj na b">todo-list.component.ts</code></p></figure><ul class=""><li id="65c6" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated"><code class="fe oh oi oj na b">todo.dialog.html:</code></li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><code class="fe oh oi oj na b">todo.dialog.html</code></p></figure><ul class=""><li id="201c" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated"><code class="fe oh oi oj na b">todo.dialog.ts:</code></li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">todo.dialog.ts</p></figure><ul class=""><li id="681c" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">正如你已经注意到的，<code class="fe oh oi oj na b">todo-list.component.ts</code>和<code class="fe oh oi oj na b">todo.dialog.ts </code>正在使用<code class="fe oh oi oj na b">todo.service.ts</code>，它提供了所有待办事项的类型和列表。现在，<code class="fe oh oi oj na b">getTodos()</code>和<code class="fe oh oi oj na b">getTypes()</code>方法正在读取两个常量，但是您可以在您的情况下调整它们，以便通过REST调用从后端获得真实数据:</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div></figure><p id="641f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是运行<code class="fe oh oi oj na b"><strong class="ll je">ng serve</strong></code>并用浏览器调用<code class="fe oh oi oj na b"><strong class="ll je">localhost:4200</strong></code>后的结果:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ov"><img src="../Images/4c9815e3cd5739167c37722038cb4ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qn7XXRVmaWxSauUYNbs9YA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Angular 9:待办事项管理应用</p></figure></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><h1 id="7fe5" class="nl nf iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">堆快照时间</h1><p id="5f7c" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">太好了！让我们用<a class="ae li" href="https://developers.google.com/web/tools/chrome-devtools" rel="noopener ugc nofollow" target="_blank"> Chrome DevTools </a> (F12)来看看一些统计数据。我们将拍摄两个堆快照，展示内存是如何在应用程序的JavaScript(对象、原语、字符串、函数、DOM节点等)之间分配的。)在拍摄快照的时间点。</p><ol class=""><li id="e742" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me ow oq or os bi translated">重新加载页面后，打开DevTools上的内存面板(F5)。</li><li id="2b33" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me ow oq or os bi translated">启用堆快照复选框。</li><li id="2c65" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me ow oq or os bi translated">点击“拍摄快照”按钮。“快照1”现已准备就绪。</li></ol><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pc"><img src="../Images/9fa2115d813d554a59a34326026cf979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*JRqQIkI3zOGf68newjQ6Lg.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Chrome开发工具:堆快照</p></figure><p id="de78" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">4.玩你的web应用程序:用todo对话框创建八张新的todo卡片(点击加号“+”按钮)。</p><p id="f050" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">5.然后单击“拍摄堆快照”图标拍摄第二张快照。第二个记录的快照将比第一个大:8.4 Mb而不是5.5 Mb。</p><p id="d6cd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">6.单击摘要，然后选择比较以查看差异。在“# New”列下，有第二个快照中新分配的对象(新数组、闭包、事件发射器、主题等)。在“# Deleted”列下，有已删除的对象。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pd"><img src="../Images/cf749ef9a889d74760a66a7f2e93ab5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbHMWR1hIPAN82DmJUSeKw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">比较两个堆快照</p></figure></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><h1 id="3db1" class="nl nf iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">新功能请求</h1><p id="c80f" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">我们可以开始添加一些有用的功能，例如使用todo对话框不仅创建一个todo，还可以同时创建多个todo，并在todo对话框中的“依赖于”下拉列表中添加一个条件:</p><ul class=""><li id="1752" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">“写作”类型的待办事项可能依赖于三种待办事项类型:“写作”、“阅读”或“编码”</li><li id="3221" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated">“阅读”或“编码”类型的待办事项可能仅取决于“阅读”或“编码”</li></ul><p id="1468" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于这个实现，我们将使用Angular <code class="fe oh oi oj na b">FormArray </code>和订阅类型的字段<code class="fe oh oi oj na b">valueChanges</code>。你必须更新<code class="fe oh oi oj na b">todo.dialog.ts:</code>如下:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><code class="fe oh oi oj na b">todo.dialog.ts</code></p></figure><p id="18c2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oh oi oj na b">todo.dialog.html</code>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><code class="fe oh oi oj na b">todo.dialog.html</code></p></figure><p id="6840" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们将删除<code class="fe oh oi oj na b">createTodo()</code>和<code class="fe oh oi oj na b">updateTodo()</code>方法，而在<code class="fe oh oi oj na b">todo-list.component.ts</code>和<code class="fe oh oi oj na b">todo-list.component.html</code>中使用<code class="fe oh oi oj na b">openTodoDialog()</code>方法:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><code class="fe oh oi oj na b">todo-list.component.ts</code></p></figure><p id="e8ca" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们必须调整<code class="fe oh oi oj na b">todo.service.ts</code>中的<code class="fe oh oi oj na b">updateTodoList()</code>方法:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><code class="fe oh oi oj na b">todo.service.ts</code></p></figure><p id="efdd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">新的待办事项对话框布局:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pe"><img src="../Images/59fb3a4b5fa6e0ced26e60b0a26d8757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koM5VbIGZRhta_n36VOlXw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">创建多个待办事项的对话框</p></figure><p id="52fd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是非常漂亮的。是时候说出真相了。您需要重复前面的步骤1到6来比较当前状态的两个新的堆快照(第一个是初始的，第二个是在创建许多todos的列表的场景之后)。结果将类似于以下内容:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pf"><img src="../Images/ea856787c3560ee7ec65a5ff93128974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIn-ZJaO7z02KgpY-7DHEw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">比较2个堆快照</p></figure><p id="ced6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如您所见，在第二个快照中，所需的堆大小增加了3 MB。创建了许多新的对象、侦听器、数组、DOM，但是没有或很少删除它们。</p></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><h1 id="7a4f" class="nl nf iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">绩效时间表记录</h1><p id="791d" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">我们用一个演奏记录来翻译这个。打开DevTools上的Performance面板，然后启用Memory复选框并做一个记录。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pg"><img src="../Images/8cdb0b5e632db7a22d751170bc2cf0bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*VWYtpGoJAGcwZakhEB0hMg.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Chrome DevTools:性能记录</p></figure><p id="b2f2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在你点击开始按钮之后，在停止记录之前，你需要运行应用程序:多次打开待办事项对话框，创建新的待办事项，在对话框中添加新的表单，在保存和不保存的情况下删除一些表单，更新一些待办事项。停止记录，等待您看到结果:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/49b71424bf81d4e45962c0d1f2e9d30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPypRPXytEKX8oaewOcEBA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">绩效时间表记录</p></figure><p id="4234" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是怎么回事？</p><p id="c5f0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Chrome和DevTools为我们提供了发现影响页面性能的内存问题的可能性，包括内存泄漏、内存膨胀和频繁的垃圾收集。在上面的记录中，内存使用情况细分为:</p><ul class=""><li id="6604" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">JS堆(Javascript所需的内存，蓝线)</li><li id="b573" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated">文件(红线)</li><li id="2849" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated">DOM节点(绿线)</li><li id="facd" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated">听众(黄线)</li><li id="b252" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated">GPU内存</li></ul><p id="4032" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们注意到JS堆结束时比开始时高。在现实世界中，如果您看到这种增长模式(JS堆大小、节点大小、侦听器大小)，这可能意味着内存泄漏。当应用程序无法清除未使用的资源，并且用户意识到在某个时候应用程序变得更慢、迟缓并且可能会频繁暂停时，就会发生内存泄漏，这是潜在垃圾收集问题的征兆。</p><p id="fad8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在性能时间线记录中，频繁上升和下降的JS堆或节点计数图意味着频繁的垃圾收集(蓝色竖线)，这就是我们的示例中的情况。</p></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><h1 id="4555" class="nl nf iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">识别JS堆内存泄漏</h1><ol class=""><li id="8029" class="ok ol iu ll b lm oc lp od ls ph lw pi ma pj me ow oq or os bi translated">打开开发工具</li><li id="3152" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me ow oq or os bi translated">转到内存面板。</li><li id="16c1" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me ow oq or os bi translated">选择“时间线上的分配工具”单选按钮。</li><li id="6ea7" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me ow oq or os bi translated">按下开始按钮(黑色圆圈)。</li><li id="f703" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me ow oq or os bi translated">执行您怀疑导致内存泄漏的操作。</li><li id="7614" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me ow oq or os bi translated">完成后，按下“停止录制”按钮(红圈)。</li></ol><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/1b8b8b00c27819709af07c0b729e0bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBfYT75G6dAJXbCTmMSokQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Chrome DevTools:时间轴上的分配工具</p></figure><p id="6491" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">每条蓝色竖线都是一些JS对象的内存分配。您可以用鼠标选择一条线来查看更多细节。</p></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><h1 id="3558" class="nl nf iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">我们有一个漏洞，我们如何修理它？</h1><p id="41b5" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">以下是一些可能导致Angular应用程序内存泄漏的情况:</p><ul class=""><li id="cfea" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated"><strong class="ll je">丢失退订</strong>，将组件保留在内存中</li><li id="f1da" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated"><strong class="ll je">缺少DOM事件监听器</strong>的注销:比如一个滚动事件监听器，一个表单<code class="fe oh oi oj na b">onChange</code>事件监听器，等等。</li><li id="7130" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated"><strong class="ll je">未使用时未关闭的WebSocket连接</strong></li><li id="44fd" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated"><strong class="ll je">分离的DOM树</strong>:当没有全局引用时，DOM节点可能会被垃圾收集。当一个节点从DOM树中移除时，它被称为<em class="mf">分离</em>，但是一些JavaScript仍然引用它。这种情况可以通过比较两个堆快照，然后向下滚动到构造函数列下以Detached为前缀的元素来识别。</li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pk"><img src="../Images/3d614eed86eac4f1841926e3b0ea7e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CDPSCfBeJnj5EpphYGCeCw.gif"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">标记和清除垃圾收集算法的可视化效果(<a class="ae li" href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="2669" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当一个对象不再被一个全局对象可访问的对象引用时，它将被垃圾收集器访问。相互引用但同时无法从根访问的对象将被垃圾回收。</p><h2 id="7d23" class="ne nf iu bd nm pl pm dn nq pn po dp nu ls pp pq nw lw pr ps ny ma pt pu oa ja bi translated">性能调整操作1:取消订阅</h2><p id="1533" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">我们的todo应用程序已经遭受了首先提到的内存泄漏的两个常见原因。每次出现订阅observable的需求时，它都会产生一个订阅对象，当组件被Angular runtime破坏时，应该以一种不会导致JavaScript运行时内存泄漏的方式来处理该订阅对象——这意味着调用<code class="fe oh oi oj na b">unsubscribe()</code>，通常在组件的<code class="fe oh oi oj na b">ngOnDestroy</code>方法内部。</p><p id="8f4e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在保留了对<code class="fe oh oi oj na b">formGroup.get('type').valueChanges</code>的订阅并删除了对<code class="fe oh oi oj na b">formGroup.valueChanges</code>的订阅后(因为不需要了)，我们在<code class="fe oh oi oj na b">todo.dialog.ts</code>和<code class="fe oh oi oj na b">todo-list.component.ts</code>中添加了缺少的退订，如下所示:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">取消订阅可观的</p></figure><h2 id="d0a1" class="ne nf iu bd nm pl pm dn nq pn po dp nu ls pp pq nw lw pr ps ny ma pt pu oa ja bi translated">性能调整操作2:仅自身和发射事件</h2><p id="96b9" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">为了更细粒度地控制变更传播和DOM事件发出，我们可以使用<code class="fe oh oi oj na b">onlySelf: true</code>和<code class="fe oh oi oj na b">emitEvent: false</code>来防止表单字段的变更触发其祖先的<code class="fe oh oi oj na b">onChange</code>方法(整个表单或对话框中所有表单的列表)。</p><p id="a2b2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在将监听器移至<code class="fe oh oi oj na b">FormGroup</code> <code class="fe oh oi oj na b">valueChanges</code>之前，您可能已经注意到，每次更改类型下拉列表中的值后，浏览器控制台上会显示两条日志消息:一条来自<code class="fe oh oi oj na b">console.log('form value changed')</code>，另一条来自<code class="fe oh oi oj na b">console.log('type changed')</code>，因为触发字段事件监听器会传播到父DOM事件监听器。</p><p id="d731" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">每当删除不需要的todo表单(带有删除图标)时，您必须记住取消订阅它的侦听器:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">从<code class="fe oh oi oj na b">formArray</code>中删除一个项目表单</p></figure><h2 id="5853" class="ne nf iu bd nm pl pm dn nq pn po dp nu ls pp pq nw lw pr ps ny ma pt pu oa ja bi translated">我们修好了吗？</h2><p id="f37d" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">去重复前面的场景，然后为它做一个性能时间线记录。看看会发生什么；我会在这里等。注意到什么有趣的事了吗？区别大吗？</p><p id="bc56" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我不这么认为。这种改进并不是灵丹妙药。对于这些内存泄漏，还有更多的问题。所以，让我们继续我们的优化任务。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pv"><img src="../Images/b95c9b90d348f59159a873e6f9bc162f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xI1PEMzwwGdaEeicBoRCNw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片来源:Addy Osmani的《<a class="ae li" href="https://medium.com/@addyosmani/measure-optimize-monitor-33e36108e014" rel="noopener">性能调优:测量、优化和监控</a></p></figure><h2 id="ad09" class="ne nf iu bd nm pl pm dn nq pn po dp nu ls pp pq nw lw pr ps ny ma pt pu oa ja bi translated">性能调整操作3: OnPush ChangeDetection</h2><p id="03f1" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">代替默认的角度<code class="fe oh oi oj na b">ChangeDetectionStrategy</code>，我在todo对话框中使用了<code class="fe oh oi oj na b">OnPush</code>策略:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">todo.dialog.ts中的OnPush ChangeDetectionStrategy</p></figure><h2 id="1bf1" class="ne nf iu bd nm pl pm dn nq pn po dp nu ls pp pq nw lw pr ps ny ma pt pu oa ja bi translated">性能调优操作4:角度管道和最小化订阅</h2><p id="4024" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">我实现了一个自定义的纯<strong class="ll je"> </strong> <a class="ae li" href="https://angular.io/guide/pipes" rel="noopener ugc nofollow" target="_blank">管道</a>，并在<code class="fe oh oi oj na b">selectBox</code>字段中使用它。现在不再需要订阅《T4》了。</p><p id="70c4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">请记住，不纯的管道经常被调用，就像每次按键或鼠标移动一样频繁，并且昂贵的长时间运行的管道可能会破坏用户体验。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">选择带管道盒子</p></figure><p id="0106" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">不要忘记在<code class="fe oh oi oj na b">app.module.ts</code>的声明部分添加<code class="fe oh oi oj na b">FilterPerTypePipe</code>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://gist.github.com/rakia/09ee9ff620246a7c0903893e7a117b09" rel="noopener ugc nofollow" target="_blank">按类型过滤管道</a></p></figure><p id="d942" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我在对话框中删除了对<code class="fe oh oi oj na b">todoService.getTodos()</code>的订阅，因为<code class="fe oh oi oj na b">todoList</code>已经在todo列表组件中可用，并且可以添加到<code class="fe oh oi oj na b">TodoDialogData</code>。我还将对<code class="fe oh oi oj na b">todoService.getTypes()</code>的订阅移动到了todo list组件中。在<code class="fe oh oi oj na b">TodoDialog</code>中<code class="fe oh oi oj na b">TodoService</code>不需要注射:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">todo-dialog.ts没有任何订阅</p></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ot ou l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">todo-dialog-data.model.ts</p></figure></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><h1 id="97dc" class="nl nf iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">有什么区别？</h1><p id="0fad" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">这是经过最后一步优化后的最终Chrome DevTools统计数据。在记录过程中，我执行了几乎相同的示例场景:通过使用对话框三次来创建九个新的todo，添加和删除一些表单，单击一次对话框的Cancel按钮，并通过添加依赖项来更新一个todo。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pw"><img src="../Images/92cb67e163ee71d96dc8d715225d5578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d50feckRrQfUCbWFzJARpQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">最终绩效时间表记录</p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj px"><img src="../Images/162af903d86a1af468b6b1a90fe81f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UsuwK_whJhXcFvk4ebJssA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">最后两个堆快照</p></figure><ul class=""><li id="dbf4" class="ok ol iu ll b lm ln lp lq ls om lw on ma oo me op oq or os bi translated">在场景的最后，性能时间线记录中的JS堆大小是大约9 MB，而不是大约10 MB(将鼠标悬停在图形上可以看到它)。</li><li id="c9af" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated">在我们的第一份业绩记录中，文件的数量是两份而不是七份。</li><li id="123c" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated">听众人数是609人，而不是2，008人。</li><li id="6e75" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated">在创建了九个新的todos之后，第二个快照中的JS堆增加了0,8 MB，而不是我们教程开始时的3 MB。</li><li id="2bbb" class="ok ol iu ll b lm ox lp oy ls oz lw pa ma pb me op oq or os bi translated">垃圾收集少了很多→垃圾收集频繁的问题得到缓解。</li></ul><p id="8332" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这很有道理，不是吗？</p><p id="cbb1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">完整的Angular 9 todo应用程序可以在<a class="ae li" href="https://github.com/rakia/angular-memory-leaks" rel="noopener ugc nofollow" target="_blank"> this GitHub repository </a>下找到。</p></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><h1 id="a1a7" class="nl nf iu bd nm nn no np nq nr ns nt nu kj nv kk nw km nx kn ny kp nz kq oa ob bi translated">最终想法</h1><p id="4566" class="pw-post-body-paragraph lj lk iu ll b lm oc ke lo lp od kh lr ls oe lu lv lw of ly lz ma og mc md me in bi translated">构建大型应用程序需要编写大量代码、复杂页面、长列表和许多组件和模块。Angular是一个做了大量内存管理工作的框架。尽管如此，一些场景还是会导致错误，导致内存泄漏，结果是用户体验受损。我们不会知道可能是我们造成了这个问题，直到它出现在生产中。</p><p id="dc90" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">用户重新加载页面的频率越来越低。<a class="ae li" href="https://developers.google.com/web/fundamentals/performance/rail" rel="noopener ugc nofollow" target="_blank">当性能延迟超过一秒钟时，他们就无法专注于正在执行的任务</a>。超过10秒，用户会感到沮丧，很可能会放弃任务。他们可能会回来，也可能不会回来。这就是为什么为长期会话保持最佳性能至关重要。</p><p id="95e3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">调试内存泄漏问题可能是一项艰巨的任务，避免它们需要对问题有所了解并保持警惕。</p></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><p id="2503" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的免费电子邮件简讯独家访问</strong> </a> <strong class="ll je"> </strong>或注册媒体<a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener">这里</a>。</p><p id="e0fa" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="mf">你可以在Udemy上查看我的</em> <strong class="ll je"> <em class="mf">视频课程</em></strong><em class="mf">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="mf">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="mf">。</em></p><div class="py pz gq gs qa qb"><a rel="noopener  ugc nofollow" target="_blank" href="/web-vitals-guide-b56e28798e7f"><div class="qc ab fp"><div class="qd ab qe cl cj qf"><h2 class="bd je gz z fq qg fs ft qh fv fx jd bi translated">网络生命:它们是什么，如何衡量它们</h2><div class="qi l"><h3 class="bd b gz z fq qg fs ft qh fv fx dk translated">谷歌用来影响你的网络应用排名的基本性能指标指南</h3></div><div class="qj l"><p class="bd b dl z fq qg fs ft qh fv fx dk translated">better编程. pub</p></div></div><div class="qk l"><div class="ql l qm qn qo qk qp lc qb"/></div></div></a></div><div class="py pz gq gs qa qb"><a href="https://levelup.gitconnected.com/how-to-use-tensorflow-js-without-memory-leaks-273ad16196be" rel="noopener  ugc nofollow" target="_blank"><div class="qc ab fp"><div class="qd ab qe cl cj qf"><h2 class="bd je gz z fq qg fs ft qh fv fx jd bi translated">我如何在不泄漏内存的情况下使用TensorFlow.js</h2><div class="qi l"><h3 class="bd b gz z fq qg fs ft qh fv fx dk translated">使用TFJS模型而不影响web性能的技巧</h3></div><div class="qj l"><p class="bd b dl z fq qg fs ft qh fv fx dk translated">levelup.gitconnected.com</p></div></div><div class="qk l"><div class="qq l qm qn qo qk qp lc qb"/></div></div></a></div></div></div>    
</body>
</html>