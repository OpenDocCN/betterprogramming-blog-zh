<html>
<head>
<title>How to Create Your Own Event Emitter in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中创建自己的事件发射器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-your-own-event-emitter-in-javascript-fbd5db2447c4?source=collection_archive---------2-----------------------#2020-02-03">https://betterprogramming.pub/how-to-create-your-own-event-emitter-in-javascript-fbd5db2447c4?source=collection_archive---------2-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4da7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于ES6类构建一个简单的事件发射器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a478ee9f62d96659a0ac0c8f6573bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bJfhV43dj5zRGZJA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="e068" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">这是干什么用的？</h1><p id="80a3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，对于你的理解和见识。要全面了解某个东西是如何工作的，就自己写吧。</p><p id="aae1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">其次，编写更干净的代码。我们会给你一个真实的例子。</p><p id="fb14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后但同样重要的是:你可能会在面试中被要求写下自己的小而简单的<code class="fe ms mt mu mv b">EventEmitter</code>——有所准备是件好事！</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="6019" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你好世界！</p><p id="2639" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们从文档开始。Node.js <a class="ae ky" href="https://nodejs.org/api/events.html" rel="noopener ugc nofollow" target="_blank">文档</a>回答了你可能有的所有问题，但是像许多文档一样，它有点复杂。这就是为什么你可能需要一个快速指南。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="b10f" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">创造</h1><p id="97d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如我提到的，我们将使用ES6类。</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="a9a5" class="nm la it mv b gy nn no l np nq">class MyEventEmitter {}</span></pre><p id="128f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们需要一个构造函数来为事件和回调初始化我们的<code class="fe ms mt mu mv b">store</code>。</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="e9a0" class="nm la it mv b gy nn no l np nq">constructor() {<br/>    this._events = {};<br/>  }</span></pre><p id="78c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们描述一下我们的第一个方法，<code class="fe ms mt mu mv b">on</code>。它有两个参数:事件的名称和侦听器，侦听器将被触发。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6bfc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从上面的代码中我们可以看到，如果对象<code class="fe ms mt mu mv b">_events</code>没有属性，它会创建它并分配一个空数组。之后，一个新的侦听器将被添加到数组中。如果属性存在，我们只需添加一个侦听器。</p><p id="6070" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下一个方法是<code class="fe ms mt mu mv b">removeListener</code>。和以前一样，它需要两个参数:事件的名称和侦听器，这两个参数必须被删除。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d5a3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是怎么回事？很简单。如果我们没有这样的事件，我们会抛出一个新的错误和相关的消息。否则，我们过滤一组侦听器。</p><p id="dd4c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后一种方法是<code class="fe ms mt mu mv b">emit</code>。毫无例外，这个方法也接受两个参数:事件的名称和参数，它们必须传递给侦听器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0cdc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">很简单。如果事件的名字是错误的，我们抛出一个错误。否则，我们使用<code class="fe ms mt mu mv b">forEach</code>遍历所有回调函数，并用必要的数据调用每个回调函数。</p><p id="27d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我们事件发射器的最终版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="8af9" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated"><strong class="ak">我们如何使用它？</strong></h1><p id="29cc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">创建实例:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="9624" class="nm la it mv b gy nn no l np nq">const myEventEmitter = new MyEventEmitter();</span></pre><p id="7dc2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">创建处理程序:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="cd13" class="nm la it mv b gy nn no l np nq">const handleMyEvent = (data) =&gt; {<br/> console.log('Was fired: ', data);<br/>};</span></pre><p id="3400" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将其添加到实例中:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="255d" class="nm la it mv b gy nn no l np nq">myEventEmitter.on('testEvent', handleMyEvent);</span></pre><p id="b2f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，发出一个事件:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="0cd9" class="nm la it mv b gy nn no l np nq">myEventEmitter.emit('testEvent', 'hi'); // Was fired: hi</span></pre><p id="6813" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以根据需要多次发出事件，并传递不同的值。每次都会触发相关的监听器:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="ac62" class="nm la it mv b gy nn no l np nq">myEventEmitter.emit('testEvent', 'trigger'); // Was fired: trigger</span><span id="b6e1" class="nm la it mv b gy nt no l np nq">myEventEmitter.emit('testEvent', 'again'); // Was fired: again</span></pre><p id="a1de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是，如果我们试图发出不存在的事件，我们将得到一个错误:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="9e9d" class="nm la it mv b gy nn no l np nq">myEventEmitter.emit('fakeEvent', {}); // Error: Can't emit an event. Event "fakeEvent" doesn't exits.</span></pre><p id="6ce2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，我们可以删除一个侦听器:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="3bff" class="nm la it mv b gy nn no l np nq">myEventEmitter.removeListener("testEvent", handleMyEvent);</span></pre><p id="6ff5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面的emit不会做任何事情。同时，它不会触发错误，因为属性<code class="fe ms mt mu mv b">testEvent</code> <strong class="lt iu"> </strong>存在于<code class="fe ms mt mu mv b">this._event</code> <strong class="lt iu"> </strong>对象上。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="e7c9" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">来自真实项目的示例</h1><p id="d50c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">以下代码取自Chrome扩展。不管你是否熟悉它，我将简要地解释它是如何工作的。长话短说，扩展的不同部分通过发送消息相互通信。一开始，事情是这样的:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="5184" class="nm la it mv b gy nn no l np nq">switch(action) {<br/> case 'open':<br/>  openPopup(payload);<br/>  break;<br/>...</span></pre><p id="9762" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在代码的另一部分，我们创建了这条消息:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="0d6c" class="nm la it mv b gy nn no l np nq">const msg = {<br/> action: 'open',<br/> payload,<br/>};</span><span id="793e" class="nm la it mv b gy nt no l np nq">chrome.runtime.sendMessage(msg);</span></pre><p id="7763" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">可以想象，随着扩展的增长，这个“开关盒”变得越来越大。我们决定创建一个<strong class="lt iu"> </strong> <code class="fe ms mt mu mv b">connector</code> <strong class="lt iu"> </strong>，它完全作为一个事件发射器工作:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="cfb5" class="nm la it mv b gy nn no l np nq">connector.addListener("open", openPopup);<br/>...</span></pre><p id="921c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要触发它:</p><pre class="kj kk kl km gt ni mv nj nk aw nl bi"><span id="2e12" class="nm la it mv b gy nn no l np nq">const msg = {<br/> action: 'open',<br/> payload,<br/>};</span><span id="e363" class="nm la it mv b gy nt no l np nq">connector.sendToBackground(msg)</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="4921" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">摘要</h1><p id="3c9c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是我的第一篇英文文章！希望你觉得有用。</p><p id="d600" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我相信<code class="fe ms mt mu mv b">EventEmitter</code>的知识会激励你写出更好的代码。对我来说是的！</p></div></div>    
</body>
</html>