<html>
<head>
<title>2 Things to Know to Test Streams in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中测试流需要知道的两件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2-things-you-really-need-to-know-to-test-streams-in-flutter-937b71b82abe?source=collection_archive---------2-----------------------#2022-10-15">https://betterprogramming.pub/2-things-you-really-need-to-know-to-test-streams-in-flutter-937b71b82abe?source=collection_archive---------2-----------------------#2022-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee3d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">流匹配器和Q</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cba6e6928a080d1c8c02be6e95d14bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7i6l3DAmHn9RQe8D"/></div></div></figure><p id="512e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">流是Dart的一大特色，许多Flutter应用程序都利用了它们。但是如果你真的在你的Flutter应用中使用它们，你也会想要测试它们，为此，我在这里提出了我发现在测试流中必须知道的两件事。</p><h1 id="c85f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">1.流匹配器</h1><p id="357a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">第一件事是在测试中使用流匹配器。您可能已经熟悉在测试中使用匹配器，例如:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="d89f" class="mp lo iq ml b gy mq mr l ms mt">import 'package:test/test.dart';</span><span id="898b" class="mp lo iq ml b gy mu mr l ms mt">void main() {<br/>  test('basic test', () async {<br/>    const lifeTheUniverseAndEverything = 21 + 21;<br/>    expect(lifeTheUniverseAndEverything, equals(42));<br/>  });<br/>}</span></pre><p id="536c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，<code class="fe mv mw mx ml b">equals(42)</code>的值返回一个匹配器。</p><p id="3055" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么我们如何对流使用匹配器呢？例如，如果我们有一个发出单个int值的非常基本的流，我们可能想要测试它实际上发出了我们期望的int值，为此，我们可以使用<code class="fe mv mw mx ml b"><a class="ae my" href="https://api.flutter.dev/flutter/package-test_api_expect/emitsInOrder.html" rel="noopener ugc nofollow" target="_blank">emitsInOrder()</a></code> <a class="ae my" href="https://api.flutter.dev/flutter/package-test_api_expect/emitsInOrder.html" rel="noopener ugc nofollow" target="_blank">函数</a>来得到一个<code class="fe mv mw mx ml b"><a class="ae my" href="https://api.flutter.dev/flutter/package-test_api_expect/StreamMatcher-class.html" rel="noopener ugc nofollow" target="_blank">StreamMatcher</a></code>。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="3bda" class="mp lo iq ml b gy mq mr l ms mt">test('test a stream emits expected item', () async {<br/>    final testSubject = StreamController&lt;int&gt;();</span><span id="2e4f" class="mp lo iq ml b gy mu mr l ms mt">testSubject.add(1);</span><span id="87a3" class="mp lo iq ml b gy mu mr l ms mt">expect(testSubject.stream, emitsInOrder([1]));<br/>  });<br/>}</span></pre><p id="f42d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，如果我们运行它，我们就通过了测试。</p><p id="fbd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为StreamMatcher说明文档中的示例代码，我们实际上可以进行更复杂的匹配:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="8b1b" class="mp lo iq ml b gy mq mr l ms mt">test('test a stream emits expected items in expected order', () async {<br/>    final testSubject = StreamController&lt;int&gt;();</span><span id="39a3" class="mp lo iq ml b gy mu mr l ms mt">testSubject.add(1);<br/>    testSubject.add(2);<br/>    testSubject.add(3);<br/>    testSubject.close();</span><span id="f775" class="mp lo iq ml b gy mu mr l ms mt">expect(<br/>      testSubject.stream,<br/>      emitsInOrder(<br/>        [<br/>          1,<br/>          emitsAnyOf([0, 2]),<br/>          lessThanOrEqualTo(3),<br/>          emitsDone,<br/>        ],<br/>      ),<br/>    );<br/>  });</span></pre><p id="e551" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我强烈推荐阅读Andrea的优秀文章,这篇文章对使用匹配器测试流有更详细的解释。</p><h1 id="0b61" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">2.Q</h1><p id="cc57" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当谈到测试流时，我的第二个重要技巧是如何测试监听流的代码。假设我们有一个类，它将流作为依赖项，然后对流事件进行一些处理，然后可能基于此改变其状态。更具体地说，我们可能有:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="19d0" class="mp lo iq ml b gy mq mr l ms mt">class Marvin {<br/>  final Stream&lt;int&gt; answerStream;</span><span id="b42d" class="mp lo iq ml b gy mu mr l ms mt">  bool isHappy = false;</span><span id="d5f8" class="mp lo iq ml b gy mu mr l ms mt">  Marvin(this.answerStream) {<br/>    answerStream.listen((event) {<br/>      isHappy = (event == 42);<br/>    });<br/>  }<br/>}</span></pre><p id="bee9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此我们可以设计一个测试:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="f92f" class="mp lo iq ml b gy mq mr l ms mt">test('test Marvin is happy with the correct answer', () async {<br/>    final fakeStream = StreamController&lt;int&gt;();<br/>    final testMarvin = Marvin(fakeStream.stream);</span><span id="a5a9" class="mp lo iq ml b gy mu mr l ms mt">    fakeStream.add(42);</span><span id="27b4" class="mp lo iq ml b gy mu mr l ms mt">    expect(testMarvin.isHappy, true);<br/>  });</span></pre><p id="da8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但遗憾的是，当我们运行上述测试时，我们得到了:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="f17c" class="mp lo iq ml b gy mq mr l ms mt">Expected: &lt;true&gt;<br/>  Actual: &lt;false&gt;</span><span id="7249" class="mp lo iq ml b gy mu mr l ms mt">package:test_api                          expect<br/>main.&lt;fn&gt;<br/>test/dart_streams_testing_test.dart:46<br/>2</span><span id="bf45" class="mp lo iq ml b gy mu mr l ms mt">✖ test Marvin is happy with the correct answer</span></pre><p id="a7a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哪里出了问题？</p><p id="4bfb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，我们忘记了考虑Dart流是如何处理的，以及它们的事件是如何传递给侦听器的。虽然没有明确说明，但关于Dart中异步编程的优秀文章说:</p><blockquote class="mz na nb"><p id="1237" class="kr ks nc kt b ku kv jr kw kx ky ju kz nd lb lc ld ne lf lg lh nf lj lk ll lm ij bi translated">【Dart为异步编程提供的所有高级API和语言特性——futures、streams、async和await——都建立在这个简单的循环之上。</p></blockquote><p id="a66d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的结果是流事件被实际处理，也就是通过事件循环传递给它们的监听器。因此，如果我们想要测试由我们的<code class="fe mv mw mx ml b">testMarvin</code>监听器添加到我们的测试流中的项目的交付，我们需要允许事件循环完成，从而处理在循环的每一个循环结束时发生的流事件。那么我们如何做到这一点呢？对我们来说幸运的是，Dart团队领先我们一步，并且已经用<code class="fe mv mw mx ml b"><a class="ae my" href="https://pub.dev/documentation/test_api/latest/hooks/pumpEventQueue.html" rel="noopener ugc nofollow" target="_blank">pumpEventQueue()</a></code> <a class="ae my" href="https://pub.dev/documentation/test_api/latest/hooks/pumpEventQueue.html" rel="noopener ugc nofollow" target="_blank">功能</a>为这种非常偶然的情况做好了准备。所以在我们的测试中增加了这个:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="5e8c" class="mp lo iq ml b gy mq mr l ms mt">test('test Marvin is happy with the correct answer', () async {<br/>    final fakeStream = StreamController&lt;int&gt;();<br/>    final testMarvin = Marvin(fakeStream.stream);</span><span id="a6d5" class="mp lo iq ml b gy mu mr l ms mt">    fakeStream.add(42);</span><span id="9493" class="mp lo iq ml b gy mu mr l ms mt">    await pumpEventQueue();</span><span id="ff5b" class="mp lo iq ml b gy mu mr l ms mt">    expect(testMarvin.isHappy, true);<br/>  });</span></pre><p id="c711" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的测试如期通过。</p><h1 id="468b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">继续前进。</h1><p id="4b09" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">正如你所看到的，在Dart中测试流并因此测试你的Flutter应用并不是一件困难的任务，只要你知道这两个非常有用的知识。</p><p id="3713" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编码快乐！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="f037" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">【https://manichord.com】最初发表于<a class="ae my" href="https://manichord.com/blog/posts/test-streams-in-flutter.html" rel="noopener ugc nofollow" target="_blank"><em class="nc"/></a><em class="nc">。</em></p></div></div>    
</body>
</html>