<html>
<head>
<title>Core Data — Building a Custom Store</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心数据—构建定制商店</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/core-data-building-a-custom-store-84d19f39dec4?source=collection_archive---------8-----------------------#2022-03-22">https://betterprogramming.pub/core-data-building-a-custom-store-84d19f39dec4?source=collection_archive---------8-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0df2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过增量和原子存储深入了解核心数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7de3f77a9d86f10092c713e0e76da6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kztVWgXA14wJCei8AA10w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:undraw.co</p></figure><p id="2780" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我认为这篇教程可能是我写过的最吸引人的教程之一。</p><p id="cd8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的主要目标是揭示核心数据如何在幕后工作，而不是解决您的问题。</p><p id="f2fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个很好的方法是编写自己的自定义存储。</p><h1 id="788a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">定制商店——它到底是什么意思？</h1><p id="19b9" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">好了，让我们快速回顾一下核心数据堆栈的样子。</p><p id="29ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们有三个主要组件——<strong class="kx ir">数据模型、数据存储和上下文</strong>。</p><p id="2a5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">深入到“存储”组件，我们知道我们有四种类型的存储— <strong class="kx ir">原子</strong> (XML、二进制和内存中)和一种<strong class="kx ir">增量</strong> (SQLite)。</p><p id="f70d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，是时候透露我们可以选择<strong class="kx ir">通过子类化NSIncremenetalStore或NSAtomicStore来创建自定义商店</strong>。</p><p id="0a0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两个类允许您编写自己的存储类型，并基本上控制核心数据如何保存、获取和优化本地数据。</p><p id="878a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，你可以编写一个可以用CSV 文件代替SQLite的<strong class="kx ir">商店，或者甚至是一个<strong class="kx ir">与web服务</strong>独立同步的商店。事实上，一旦你掌握了控制权，几乎一切皆有可能。</strong></p><h1 id="c37f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">我们为什么需要它？</h1><p id="e447" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">大多数情况下，你不会。核心数据附带的四种商店类型适合您的大部分需求。</p><p id="578f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是有几个原因让您需要知道如何创建自己的数据存储。</p><p id="74b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要理解的一点是，使用自己的定制数据存储并不意味着对栈的其余部分进行额外的修改。数据模型和上下文不知道它们正在使用自定义数据存储，而代码库的其余部分保持不变。</p><p id="f5c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">意味着你的店很容易更换，所以不用担心！</p><h1 id="c264" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">依靠你的技术</h1><p id="0cac" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">SQLite是一种非常有效的数据存储方式，它被选为许多移动应用程序的首选数据库绝非偶然。</p><p id="e38e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但这并不意味着这是在移动设备上管理数据的唯一方式。</p><p id="93d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，在iOS上实现NoSQL数据存储有很好的解决方案，编写自定义存储是<strong class="kx ir">将您的核心数据连接到不同类型存储的一种方式</strong>。</p><h1 id="f429" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">跨平台支持</h1><p id="90f2" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果您在同一个团队中与Android开发人员一起工作，就会出现要求两个平台使用相同数据文件格式的情况。</p><p id="4310" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在许多情况下，让所有平台都使用相同的格式和技术对于团队的成功至关重要。</p><p id="3377" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的是，通过使用自定义存储类型，我们可以在相同的格式上工作，并且仍然可以使用优秀的核心数据特性。</p><h1 id="af1b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">从旧的持久性存储迁移</h1><p id="a413" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果您正在开发一个尚未实现核心数据的现有应用程序，但该应用程序已经有一个数据存储，那么创建一个自定义存储可能是一个很好的起点。</p><p id="4734" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从旧的持久层迁移总是很麻烦，所以这种方法可以减轻迁移的痛苦。</p><h1 id="f168" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">将持久性存储直接连接到Web服务</h1><p id="0364" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">因为我们已经完全控制了商店的行为，所以一个很好的想法是<strong class="kx ir">将它直接绑定到你的后端服务</strong>。</p><p id="cec1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这似乎是一个奇怪的想法，尤其是当你想到“关注点分离”原则的时候。</p><p id="671e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是有一些方法可以将你的商店直接连接到一个web服务，而不会使它过于耦合，比如依赖注入。</p><p id="0114" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个令人兴奋的方法，我们可以稍后再探讨。</p><h1 id="fcaa" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">浏览另一个堆栈组件</h1><p id="011b" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">学习如何创建自定义存储可以揭示一些核心数据秘密，即它是如何工作的。</p><p id="b18c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这基本上意味着你要对获取、保存和出错负责。</p><p id="8e4d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个从不同角度对核心数据进行概述的过程，只会让你成为更好的iOS开发人员。</p><p id="82ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也许，这是尝试和学习它的最好理由。</p><h1 id="617b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">NSIncrementalStore vs . NSAtomicStore</h1><p id="299e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如上所述，核心数据存储分为两种类型— <strong class="kx ir">原子</strong>和<strong class="kx ir">增量</strong>。</p><p id="58f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如何选择创建哪种类型的商店？</p><p id="0636" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这取决于你的需求——每种商店类型都有其缺点和优点。</p><p id="f512" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">原子存储更青睐简单性而非性能。在原子存储中，我们将所有数据加载到内存中，每次需要执行更改(插入/更新/删除)时，我们都必须保存所有数据。</p><p id="c770" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，这是一个易于管理的存储，但也消耗了最大的内存。</p><p id="c173" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们需要将数据基于JSON、XML或CSV文件时，原子存储是相关的。</p><p id="3a74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，请注意，这些文件不能太大——在这种情况下，请考虑使用增量存储。</p><p id="92df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与原子存储相比，增量存储实现起来更复杂。它们要求我们自己处理所有的错误和优化，是为那些喜欢性能胜过简单的人准备的。</p><p id="2c75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">增量存储用于大数据文件或其他特殊的异步数据获取，如HTTP请求。</p><p id="56e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两种存储类型都允许我们创建基本上任何我们想要的持久性存储。我们只需要了解它们是如何工作的。</p><h1 id="7f51" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">它们是如何工作的？</h1><p id="7539" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在我们继续之前，我想解释一下存储在核心数据中的基本工作方式，它甚至比您想象的还要简单。</p><p id="9b3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们来谈谈核心数据的责任和你的责任。</p><p id="706e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">核心数据负责:</p><ul class=""><li id="c9c3" class="mo mp iq kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">初始化我们的商店。</li><li id="db4d" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">处理获取，包括谓词。</li><li id="64a2" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">为我们管理不同的环境。</li></ul><p id="3200" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，您需要:</p><ul class=""><li id="1c41" class="mo mp iq kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">基于您的数据创建对象。</li><li id="47a0" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">生成对象id。</li><li id="ab6a" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">定义商店元数据信息。</li><li id="eff5" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">应要求提供额外的数据信息。</li></ul><p id="3f7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，作为开发人员，我们需要做的是处理核心数据框架和我们的后台存储之间的连接，无论它是什么。</p><p id="4f1e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们开始设置原子存储之前，让我们看看它的超类— NSPersistentStore。</p><h1 id="fed4" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">NSPersistentStore</h1><p id="9acd" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated"><code class="fe nc nd ne nf b">NSPersistentStore</code>是所有核心数据持久性存储的基类。<code class="fe nc nd ne nf b">NSPersistentStore</code>也是<code class="fe nc nd ne nf b">NSIncrementalStore</code>和<code class="fe nc nd ne nf b">NSAtomicStore</code>的超类，如果我们想创建自己的商店，我们需要子类化其中一个类。</p><p id="c87a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了创建一个新的原子商店，我们将创建一个名为<code class="fe nc nd ne nf b">MyAtomicStore</code>的子类:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="ce54" class="nk ls iq nf b gy nl nm l nn no">class MyAtomicStore: NSAtomicStore</span></pre><p id="2cdb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我前面说过的，我们自己不初始化存储——那是核心数据框架的工作。</p><p id="03fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的工作是注册它们，并告诉Core Data我们希望它加载什么类型的存储。</p><p id="9f43" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个存储都有包含类型和UUID的元数据。</p><p id="d424" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">元数据信息帮助核心数据初始化新的存储，管理它的迁移，在扩展之间共享它，并且一般来说，随着时间的推移照顾我们的存储。</p><p id="7f54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们将以下内容添加到我们的<code class="fe nc nd ne nf b">MyAtomicStore</code>类中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d4b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们从基于这些值声明一个类型和一个UUID开始，我们还创建了一个storeType和一个商店描述。当我们设置核心数据容器时，这两者都将被使用。</p><p id="0f28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，被覆盖的方法和变量对于创建自定义存储来说是必需的——不要担心，我们有很多方法可以被覆盖以使存储工作，这是一个好的开始。</p><p id="749d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了元数据，我们可以将我们的存储注册到核心数据。</p><h1 id="304d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">注册新商店</h1><p id="5049" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">为了确保核心数据加载我们的存储，我们需要执行两个步骤:注册，然后加载它。</p><p id="f8ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了注册我们创建的商店，我们将在<code class="fe nc nd ne nf b">applicationDidFinishLaunchingWithOptions</code>中添加下面一行:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="d4fa" class="nk ls iq nf b gy nl nm l nn no">NSPersistentStoreCoordinator.registerStoreClass(MyAtomicStore.self, type: MyAtomicStore.storeType)</span></pre><p id="9f61" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的下一步是在加载核心数据容器<strong class="kx ir">之前，将我们之前创建的商店描述添加到其中:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ddd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一切顺利，我们的集装箱将毫无问题地装船。</p><h1 id="dcb6" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">NSAtomicStore</h1><p id="152b" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">现在我们的商店已经加载完毕，让我们深入到商店本身。</p><p id="bc6a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">原子存储不同于增量存储，因为它们将所有数据保存在内存中。</p><p id="2a52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这使得它们简单而快速，但在内存方面效率不高，尤其是在处理大型商店时。</p><p id="d505" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">毫无疑问，主要任务是将所有数据加载到内存中。</p><h1 id="234d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">映射数据</h1><p id="9444" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">因此，我们要做的第一件事是创建一个字典，将所有实例映射到一个唯一的值，例如UUID:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="8d27" class="nk ls iq nf b gy nl nm l nn no">var objectMapping = [UUID : NSManagedObjectID]()</span></pre><p id="81ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，我们没有映射对象本身，而是映射它们的对象id。你记得为什么吗？</p><p id="3a2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">原因是受管对象不是存储持有或创建的东西，而是受管对象上下文作业的一部分。</p><p id="f712" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是为什么学习如何创建自己的数据存储会如此丰富——你最终会知道事情是如何在幕后工作的，而我们才刚刚开始。</p><h1 id="c3a3" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">加载所有数据</h1><p id="d1a3" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">正如我前面说过的(甚至可能说过几次)，原子存储从一开始就保存所有的数据。</p><p id="2f20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，加载存储时调用的方法之一是<code class="fe nc nd ne nf b">load()</code>。</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="955e" class="nk ls iq nf b gy nl nm l nn no">override func load() throws {</span></pre><p id="f8cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne nf b">load()</code>方法是<code class="fe nc nd ne nf b">NSAtomicStore</code>类的一部分，当你创建自己的原子存储时<strong class="kx ir">必须覆盖</strong>。</p><p id="2761" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们的存储使用某种CSV文件，那就是我们转到该文件并加载其所有记录的时候了。</p><p id="2d27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看一下将所有东西连接起来需要采取的步骤:</p><p id="95ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">-将CSV(或任何其他持久性文件或数据)文件加载到内存中。</p><p id="ef8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">-循环它的所有行。</p><p id="e004" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">-对于每一行:</p><ul class=""><li id="2a31" class="mo mp iq kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">生成一个新的<code class="fe nc nd ne nf b">referenceID</code>。</li><li id="fa62" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">基于<code class="fe nc nd ne nf b">referenceID</code>生成新的<code class="fe nc nd ne nf b">ObjectID</code>。</li><li id="358a" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">创建一个新的缓存节点(这是我们的“对象”)。</li><li id="f497" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">用数据填充缓存节点。</li><li id="7279" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">将<code class="fe nc nd ne nf b">objectID</code>映射到它的<code class="fe nc nd ne nf b">referenceID</code>。</li><li id="cd49" class="mo mp iq kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">将缓存节点添加到存储中。</li></ul><p id="7ae9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来工作量很大，是吧？嗯，考虑到这是你创建自己的商店时要做的大部分工作，这没什么大不了的。</p><p id="c010" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个基本的功能性<code class="fe nc nd ne nf b">load()</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5233" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请一行一行地按照我之前列出的步骤去理解正在发生的事情。</p><h1 id="e07a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">更多见解</h1><p id="0c35" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">别担心，我不会把你留在黑暗中，用我刚才给你看的代码。</p><p id="c905" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有几件事你应该知道:</p><p id="0bfc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于CSV中的每一行，我们的目标是创建一个名为<strong class="kx ir">的缓存节点</strong>。一个缓存节点代表我们存储中的一个<strong class="kx ir">记录</strong>，一旦我们从本地文件加载数据，它就是我们保存数据的地方。</p><p id="ca3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们向存储中插入一条新记录时，我们基本上是在插入一个新的缓存节点。</p><p id="69c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了创建一个缓存节点，我们需要提供一个<code class="fe nc nd ne nf b">objectID</code>。到目前为止，我们只读取了<code class="fe nc nd ne nf b">objectID</code>值，但从未生成过。</p><p id="c673" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们将使用一个内置方法生成一个<code class="fe nc nd ne nf b">objectID</code>:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="032e" class="nk ls iq nf b gy nl nm l nn no">let objectID = self.objectID(for: songDesc, withReferenceObject: uuid)</span></pre><p id="e779" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建缓存节点后，我们可以使用常规的<code class="fe nc nd ne nf b">setValue() </code>函数设置它的值。</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="b14a" class="nk ls iq nf b gy nl nm l nn no">cacheNode.setValue(name, forKey: “name”)</span></pre><p id="b17a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们用来自CSV的信息填充商店的地方。一个好的技巧是从实体描述中获取关键属性的名称，而不是硬编码。</p><p id="f53e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能看起来像一个过度工程化的任务，但从长远来看是值得的。</p><h1 id="10f9" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">关系呢？</h1><p id="6515" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">核心数据不仅仅是一个持久存储，还是一个对象图。这意味着我们的新商店需要<strong class="kx ir">管理不同对象之间的关系。</strong></p><p id="a989" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，我们的“对象”实际上是我们刚刚创建的缓存节点。要实现关系，我们需要做的就是将一个缓存节点连接到另一个:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="1a17" class="nk ls iq nf b gy nl nm l nn no">let albumCacheNode = NSAtomicStoreCacheNode(objectID: albumObjectID)</span><span id="bd98" class="nk ls iq nf b gy nr nm l nn no">// filling the albume node with data</span><span id="0d72" class="nk ls iq nf b gy nr nm l nn no">songNode.setValue(albumCacheNode, forKey: “album”)</span></pre><p id="2a38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不要忘记相册节点只是一个标准的缓存节点—我们需要生成一个<code class="fe nc nd ne nf b">objectID</code>(基于实体描述)，映射它，并将其插入到存储中，就像我们对歌曲节点所做的那样。</p><h1 id="288f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">添加新对象</h1><p id="b039" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们的存储可能需要支持添加新对象。</p><p id="93e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们知道如何从CSV文件中加载所有数据并将其转换为节点后，添加新信息应该很容易，但这需要我们执行额外的工作。</p><p id="a400" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当核心数据插入和操作对象时，我们的存储不做任何事情—记住，上下文是应用程序沙箱。我们的商店只有在上下文<code class="fe nc nd ne nf b">save()</code>方法被调用时才进入画面。</p><p id="3b7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，我们需要做三件事:生成新的引用ID，创建新的缓存节点，并将数据保存到CSV文件中。</p><h1 id="de50" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">生成新的参考ID</h1><p id="c8cb" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">看来我们已经去过了，不是吗？</p><p id="bbc0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我告诉过你从现在开始事情会越来越熟悉。</p><p id="eb9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当核心数据上下文(现在是您的客户机)要求插入一个新对象时，我们需要做的第一件事是<strong class="kx ir">返回一个引用对象</strong>。</p><p id="3fe7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">引用对象必须是唯一的，并且应该从对象值派生。</p><p id="1661" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果没有，我们需要继续映射它。</p><p id="4a94" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要返回一个新的引用对象，实现<code class="fe nc nd ne nf b">newReferenceObject</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="235d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">添加新的缓存节点</h1><p id="c55f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">添加新的缓存节点类似于我们之前从文件加载数据时所做的，但是方向相反——从上下文到存储。</p><p id="fac6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们需要实现以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6ea8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，尽管实现看起来很明显，但是有一个小问题:关系。</p><p id="122d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们插入一个具有关系的新对象，我们需要确保当我们创建一个新的缓存节点时，<strong class="kx ir">我们负责所有的连接和链接</strong>。</p><p id="38a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以帮助我们的事情之一是我们在引用对象和objectIDs之间做的映射。</p><p id="2f71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们有了一个<code class="fe nc nd ne nf b">objectID</code>，我们需要做的就是检索它的缓存节点(如果存在于我们的内存中)并执行相关的连接:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="2c41" class="nk ls iq nf b gy nl nm l nn no">if let albumNode = self.cacheNode(for: albumObjectID) {</span><span id="27e6" class="nk ls iq nf b gy nr nm l nn no">cacheNode.setValue(albumNode, forKey: “album”)</span><span id="f02e" class="nk ls iq nf b gy nr nm l nn no">} else {</span><span id="4c0c" class="nk ls iq nf b gy nr nm l nn no">// create a new album cache node from data.</span><span id="3caa" class="nk ls iq nf b gy nr nm l nn no">}</span></pre><p id="87b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne nf b">NSAtomicStore</code>有一个叫<code class="fe nc nd ne nf b">cacheNode(for objectID: NSManagedObjectID)</code>的函数可以帮助我们在<code class="fe nc nd ne nf b">objectID</code>之前获得一个缓存节点，我们需要用它来连接我们需要的一切。</p><h1 id="682a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">节约</h1><p id="1531" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">最后一步是用所有新的更改更新我们的本地文件。</p><p id="f620" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">核心数据调用store save方法，我们应该在我们的子类中实现它:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="2a25" class="nk ls iq nf b gy nl nm l nn no">override func save() throws {}</span></pre><p id="0527" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是怎样做才是正确的方法呢？</p><p id="eade" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有几种方法可以实现这一点，这取决于您选择如何跟踪您的数据。</p><p id="1e4d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一种方法是采用暴力手段。我们有一个包含所有<code class="fe nc nd ne nf b">objectIDs</code>的映射，因此我们可以为它们生成缓存节点，并从缓存节点创建可以保存为CSV文件的数据。</p><p id="795d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能是将数据保存回文件的最可靠、最简单的方法，但不是最优雅的方法。</p><p id="81a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一种方法是保留我们加载CSV文件时创建的数据，并在每次更新或插入新的缓存节点时用更改来更新它。</p><p id="51b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们需要将数据保存回文件，我们已经用所有的更改更新了它。</p><p id="5b87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，您不需要担心处理多个上下文——这是核心的数据容器工作。只有当应用程序请求在本地保存数据时，才会保存到存储区并插入新的缓存节点。</p><h1 id="32f6" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">更新和删除</h1><p id="18e7" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">就像添加一个新的缓存节点一样，更新和删除需要实现额外的方法。</p><p id="d729" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更新节点，我们需要实现以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="296b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，<code class="fe nc nd ne nf b">NSAtomicStore</code>让您的生活变得更加轻松——它已经为您提供了节点和托管对象。</p><p id="4921" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是重用来自<code class="fe nc nd ne nf b">newCacheNode</code>函数的代码并将其合并到一个地方的好时机。</p><p id="ba36" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">移除缓存节点的过程类似——就在缓存节点从存储中移除之前，核心数据调用<code class="fe nc nd ne nf b">willRemoveCacheNodes</code>方法。</p><p id="c06d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们需要删除相应数据和关系的地方。</p><h1 id="bac2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">NSIncrementalStore</h1><p id="d0f7" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">与<code class="fe nc nd ne nf b">NSAtomicStore</code>不同的是，<code class="fe nc nd ne nf b">NSIncrementalStore</code>旨在解决其他无法将数据保存在内存中，只需要在需要时加载数据的情况。</p><p id="114b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种情况主要有两种情况:当数据存储太大而无法保存在内存中时，第二种情况是数据没有保存在设备上，您只能在请求时获取数据，就像web服务一样。</p><p id="93c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但首先，让我们谈谈我们如何建立一个自己的<code class="fe nc nd ne nf b">NSIncrementalStore</code>。</p><p id="e146" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我认为最重要的是要明白这样一个事实，我们有更多的控制权，因此也有更多的责任。</p><p id="c360" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实现<code class="fe nc nd ne nf b">NSAtomicStore</code>很简单。我们所要做的就是获取所有记录，将它们连接到一个引用ID，并填充缓存节点。</p><p id="5a6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe nc nd ne nf b">NSIncrementalStore</code>中，我们有两项主要工作:</p><p id="3322" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">-我们需要自己处理所有的存储操作，例如获取、保存和删除。</p><p id="8b6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">-我们需要控制断层。记住，它是增量的，我们只加载我们需要的。</p><p id="e378" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们开始工作吧。</p><h1 id="1b6f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">正在加载商店</h1><p id="9043" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">增量存储通常使用本地文件(在许多情况下，它是一个SQLite文件)，并需要确保文件位于正确的位置(如果不在，就创建它)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="508a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也是做另外两件事的地方:</p><p id="e907" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">- <strong class="kx ir">检查</strong>文件是否被<strong class="kx ir">损坏</strong>并抛出错误。</p><p id="1e87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">- <strong class="kx ir">从商店加载基础数据</strong>(可选)。</p><p id="1048" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面我们来详细阐述一下“加载基础数据”是什么意思。</p><p id="3f2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，增量存储不像原子存储——我们不会将所有数据都加载到内存中。</p><p id="7fbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但这并不意味着我们完全不能加载任何数据。</p><p id="f403" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果我们有大量的歌曲，我们可以将它们的id加载到内存中，这样在需要的时候我们就可以更容易地获取额外的数据。</p><p id="355f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">获取像“headers”这样的东西可以简化我们的实现，另外，这也是确保我们的文件没有损坏并且格式正确的好方法。</p><h1 id="ad4f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">执行存储请求</h1><p id="76c3" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">为了让我们的增量存储正常工作，我们需要处理的第一件事是来自我们上下文的存储请求——记住，既然我们是一个存储，那么上下文就是我们的“客户机”。</p><p id="acca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在增量商店中，我们需要实现以下方法:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="8f76" class="nk ls iq nf b gy nl nm l nn no">override func execute(_ request: NSPersistentStoreRequest, with context: NSManagedObjectContext?) throws -&gt; Any</span></pre><p id="5bc8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne nf b">execute()</code>函数有两个参数:存储请求本身(我们稍后会谈到)和相关的上下文。</p><p id="3e73" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数处理获取请求、保存，甚至批处理操作。</p><h1 id="60a0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">NSPersistentStoreRequest</h1><p id="cffd" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated"><code class="fe nc nd ne nf b">execute()</code>方法签名中的<code class="fe nc nd ne nf b">NSPersistentStoreRequest</code>实例封装了执行上下文要求我们做的所有必要信息。</p><p id="4674" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要了解我们有什么类型的请求。因此，我们需要检查实例的<code class="fe nc nd ne nf b">requestType</code>属性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="68c5" class="nk ls iq bd lt ns nt dn lx nu nv dp mb le nw nx md li ny nz mf lm oa ob mh oc bi translated">迷人的</h2><p id="ec46" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">当<code class="fe nc nd ne nf b">requestType</code>属性等于<code class="fe nc nd ne nf b">fetchRequestType</code>时，我们知道上下文试图执行<strong class="kx ir">一个获取请求</strong>。</p><p id="9935" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，我们可以将它转换为fetch请求，并检查请求的是什么实体:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e75c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了实体名称，我们可以基于获取请求创建我们的歌曲:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a535" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">先说上面的代码:</p><p id="35b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们有一个特殊的函数叫做<code class="fe nc nd ne nf b">getSongsIds(byRequest:)</code>。我们需要编写这个函数，它需要根据收到的获取请求从我们的后备存储中检索歌曲id。</p><p id="1c52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">获取请求包含我们需要的所有信息，包括一个谓词和排序描述符。</p><p id="4148" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是您需要做的最复杂的工作——如何使用谓词和排序描述符来执行对CSV或SQLite文件的请求？</p><p id="1374" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我的建议是，您不需要涵盖谓词和排序的所有可能的用例。</p><p id="483c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您构建应用程序并添加越来越多的获取请求时，请根据您的需求分析获取请求，并在过程中添加相关代码。不要试图完全复制基于SQLite的增量——这不是构建增量存储的目标。</p><p id="e36f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们有了所有的歌曲id，我们就可以执行一个for循环，并为每个id创建一个托管对象。</p><p id="d751" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，我们不只是在每次循环迭代中初始化一个新的托管对象——我们首先从实体描述和<code class="fe nc nd ne nf b">songID</code>中生成一个<code class="fe nc nd ne nf b">objectID</code>。只有这样，我们才能从上下文中检索一个托管对象。</p><p id="c4fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果上下文已经有一个带有这个<code class="fe nc nd ne nf b">ObjectID</code>的托管对象，它将返回现有的对象。</p><p id="ee3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne nf b">songID</code>是我们对象的参考对象和唯一标识符。将它附加到<code class="fe nc nd ne nf b">objectID</code>上是我们从后台存储中注册记录的存储方式。</p><p id="f043" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可能已经注意到的另一件事是，我们根本不用数据填充我们的歌曲——那是因为我们只初始化出错的对象。还记得核心数据特性吗？</p><p id="84a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">故障使我们能够优化我们的请求，并且只在请求时加载额外的数据。我们很快会谈到断层！</p><h2 id="c51a" class="nk ls iq bd lt ns nt dn lx nu nv dp mb le nw nx md li ny nz mf lm oa ob mh oc bi translated">节约</h2><p id="a81f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">回到<code class="fe nc nd ne nf b">execute()</code>函数的开头——正如我提到的，这个函数不仅处理获取，还处理保存。</p><p id="db42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是什么是“保存”存储请求呢？</p><p id="3c26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">“保存”意味着插入、更新和删除对象。</p><p id="e860" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了处理保存请求，我们首先需要检查请求类型，并将其与<code class="fe nc nd ne nf b">saveRequestType</code>进行比较。</p><p id="4436" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一步是将获取请求转换为<code class="fe nc nd ne nf b">NSSaveChangesRequest</code>。</p><p id="e93e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的，<code class="fe nc nd ne nf b">execute()</code>函数在这里使用了多态性——它有时可以是一个获取请求，有时是一个保存请求。</p><p id="3d6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像fetch请求一样，save请求也<strong class="kx ir">封装了所有需要的信息</strong>来将新数据保存到您的存储中。</p><p id="cf4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne nf b">NSSaveChangesRequet</code>有三个属性:</p><p id="c1fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">- <code class="fe nc nd ne nf b">insertedObjects</code></p><p id="16b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">- <code class="fe nc nd ne nf b">updatedObjects</code></p><p id="90c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">- <code class="fe nc nd ne nf b">deletedObjects</code></p><p id="b625" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它们中的每一个都是包含被请求保存的对象列表的数组。</p><p id="8c8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些是什么东西？嗯，在这种情况下，对象实际上是<code class="fe nc nd ne nf b">NSManagedObject</code>。如果您将它们转换为<code class="fe nc nd ne nf b">Song</code>(例如)，您将能够检索所有需要的信息并将其保存在您的后备存储器中。</p><p id="a7e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看实际的保存请求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9c64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne nf b"><strong class="kx ir">ObjectID</strong></code></p><p id="c21d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，花一点时间，阅读上面的代码，并思考是否缺少了什么。</p><p id="9baa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">提示—看看我们之前编写的代码，当时我们从后备存储中加载了所有数据，并将其注册到增量存储中。</p><p id="fc7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你到了吗？</p><p id="4b39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要将objectID映射到它的引用值(在本例中为<code class="fe nc nd ne nf b">songID</code>)。记得吗？</p><p id="6a23" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe nc nd ne nf b">execute()</code>函数中没有发生的原因是，正如您可能知道的，添加到核心数据的新对象有一个临时的<code class="fe nc nd ne nf b">objectID</code>。只有在保存操作完成后，它们才能获得永久的<code class="fe nc nd ne nf b">objectID</code>。</p><p id="a3cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也是核心数据要求您使用函数<code class="fe nc nd ne nf b">obtainPermanentIDs()</code>获得一个永久objectID的时候:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="706c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne nf b">obtainPermanentIDs</code>函数传递新对象的列表，并要求返回相应对象id的列表。</p><p id="37cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想您现在应该已经熟悉这个实现了。</p><p id="9ac7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne nf b">obtainPermanentIDs</code>是了解NSIncrementalStore揭示核心数据如何在幕后工作的另一个极好的例子。突然间，许多事情变得更加明显。</p><p id="ed9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是——这个谜题还缺少一块，那就是<strong class="kx ir">断层</strong>。</p><h1 id="e532" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">故障</h1><p id="2b13" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">还记得我们获取对象但没有获取它们的数据时，我告诉过你我们很快会谈到出错吗？这些物体就像“幽灵”，空无一物。</p><p id="2659" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当“用户”(用户实际上是应用程序本身)调用<code class="fe nc nd ne nf b">song.name</code>时，如果需要，我们需要去获取名称。</p><p id="37fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的是，NSIncrementalStore很好地帮助我们管理了那个区域。</p><p id="1222" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们只需要再实现一个功能，那就是<code class="fe nc nd ne nf b">newValuesForObject</code>。</p><p id="3c65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当商店需要用来自商店的信息实现一个对象时，调用这个函数。</p><p id="30fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像原子存储一样，我们不自己填充托管对象——我们在这里使用一个节点。<code class="fe nc nd ne nf b">NSIncrementalStoreNode</code>准确地说:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6e4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代码很简单，除了一点——版本(我用粗体标出)。</p><p id="4642" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们创建<code class="fe nc nd ne nf b">NSIncrementalStoreNode</code>时，我们需要提供一个版本，该版本应该在每次创建节点时递增。</p><p id="50a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">“版本”有助于合并冲突，并且应该被持久地保存——一行的特定版本。在上面的例子中，我从磁盘中读取了版本，并将其保存回来——以备将来读取。</p><p id="57e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne nf b">NSIncrementalStore</code>为我们跟踪有故障的对象——这基本上是需要完成的艰苦工作。</p><p id="8449" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关系呢？</p><p id="1843" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于关系，我们需要覆盖一个额外的方法:</p><pre class="kg kh ki kj gt ng nf nh ni aw nj bi"><span id="7de5" class="nk ls iq nf b gy nl nm l nn no">func newValue(forRelationship relationship: NSRelationshipDescription, forObjectWith objectID: NSManagedObjectID, with context: NSManagedObjectContext?) throws -&gt; Any</span></pre><p id="366e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管看起来很可怕，但关系断层是肤浅的。我们需要做的就是分析什么是目的实体，并返回它的<code class="fe nc nd ne nf b">NSManagedObjectID</code>(或者在多对多关系的情况下返回id)。</p><p id="b3a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看下面的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b4d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，我处理了两个关系——一个是Album(一对一),一个是Composer(一对多)。</p><p id="4b40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你问自己对象数据在哪里，你现在应该知道答案了。如果核心数据需要，它会通过调用<code class="fe nc nd ne nf b">newValuesForObject()</code>函数来询问数据。你的工作只是执行它。</p><h1 id="61e0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">网络服务</h1><p id="efb7" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">这是我之前提到过的一个部分，你可能仍然会觉得很奇怪。因为增量存储是增量的，所以实现这种存储的一个可能的用例是将存储直接连接到您的后端API。</p><p id="3b71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想一想——我们有一个完美的对象图框架，带有谓词、排序和缓存机制。</p><p id="7c9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论如何，你都在你的应用程序中使用这种机制。为什么您“关心”数据是从本地还是远程存储接收的？</p><p id="546c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是核心数据魅力的一部分。正如我不止一次说过的——核心数据<strong class="kx ir">不是SQLite包装器</strong>。远不止这些。</p><p id="7288" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是您管理实体的地方，将它直接绑定到您的服务器可能是一个很好的方法。</p><p id="f471" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将我们的商店连接到服务器的主要问题是，调用HTTP请求是一个<strong class="kx ir">耗时的操作</strong>，可能需要几秒钟才能返回。</p><p id="18ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您的存储中的所有步骤必须同步—核心数据存储不支持异步操作。</p><p id="1a37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑到我们已经知道的所有核心数据后台操作约束，从应用程序执行核心数据请求应该得出结论，并在后台线程中执行。</p><h1 id="3828" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">摘要</h1><p id="00d1" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在深入研究核心数据时，实现增量存储和原子存储是需要学习的有趣主题之一。</p><p id="7f64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不是因为你能用它做什么，而是你能从中学到什么。</p><p id="9375" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个转换你在iOS开发中的位置，并作为一个框架制作者思考一秒钟的绝佳机会。</p><p id="1c1a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经了解了如何创建原子和增量存储，以及它们如何通过将我们的存储直接连接到我们的后端来为我们服务。</p></div></div>    
</body>
</html>