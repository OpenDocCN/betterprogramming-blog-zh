<html>
<head>
<title>Build Your Own Filter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您自己的过滤器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-own-filter-e88ba0dcbfae?source=collection_archive---------19-----------------------#2020-04-15">https://betterprogramming.pub/build-your-own-filter-e88ba0dcbfae?source=collection_archive---------19-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6893" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为了更好地理解它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63c9a7a5703ee6d72655b3120c5b4d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nB6bYS4aM5xrtpoBa0K4SA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alexblock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alex Block </a>在<a class="ae ky" href="https://unsplash.com/s/photos/sort?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过滤是一种常见的编程模式，在这种模式下，我们迭代一组元素，只返回一组通过过滤函数提供的条件的新元素。与<a class="ae ky" href="https://medium.com/better-programming/build-your-own-map-b9a0c9d6fbab" rel="noopener">映射</a>不同，我们不能逆转应用过滤函数以获得原始数据集的过程；然而，这可以在映射中通过对变换后的集合应用映射函数的逆来得到原始集合来实现。</p><p id="a91f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数式编程的上下文中应用过滤将帮助我们在更好的意义上实现可读性。我们所要做的就是提供原始数组和过滤函数。使用这个<a class="ae ky" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">声明性方法</a>，从一组数据(在本文中是数组)中过滤项目的步骤是隐藏的，我们将注意力集中在我们想要实现的最终结果上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/bc00ecefa40ac6f4e6cc2792cf83363e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M6WI3c2Y3lxd_KW2.png"/></div></div></figure><p id="24c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在上图中，我们确实提供了[🍕,🍔,🥗,🍏]和过滤功能<code class="fe lw lx ly lz b">isHealthy</code>。过滤器遍历每一种美味的食物，并根据它的过滤功能，决定哪些是健康的，哪些是不健康的。只有健康的数据将被保存在新数组中，并最终被返回[🥗,🍏].</p><p id="2ce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与映射类似，我们有一些选择来过滤数组中的元素，既有声明性的，也有命令性的。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="13de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对过滤器使用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener ugc nofollow" target="_blank">for</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener ugc nofollow" target="_blank">循环</a>是一种必不可少的方法，它遍历元素并将元素推送到一个数组中，该数组传递嵌套在<code class="fe lw lx ly lz b">for</code>循环中的条件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="c0ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们需要跟踪条目索引，定义一个初始数组，并在<code class="fe lw lx ly lz b">for</code>循环中嵌套条件语句。尽管可以执行这种过滤方式，但可读性不是很好。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="7937" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">为每一个</h1><p id="2efa" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们的另一个选择是使用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">forEach</a></code>，它像一个<code class="fe lw lx ly lz b">for</code>循环一样，遍历一个元素数组。但是使用它的好处是我们不必担心索引跟踪。我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="d536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就可读性而言，这似乎是对前一种选择的改进，但是在迭代器的上下文之外对<a class="ae ky" href="https://lorenstewart.me/2017/01/22/javascript-array-methods-mutating-vs-non-mutating/" rel="noopener ugc nofollow" target="_blank">和</a>T2数组进行变异并不理想。如果我们有一个总是返回新数组的过滤方法，那就更好了。</p><p id="6f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们有一个更好的选择，叫做<em class="ng">原生JavaScript过滤器</em>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="595f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">本机JavaScript过滤器</h1><p id="496d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">本地JavaScript过滤器</a>在过滤数组元素时采用声明性方法。因为它是在<code class="fe lw lx ly lz b">Array.prototype</code>上定义的方法，所以它在提供的数组上迭代并在其上调用回调。这个回调函数充当我们的过滤函数，它接受三个参数:</p><ul class=""><li id="2f88" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe lw lx ly lz b">element </code> —数组中被迭代的当前项</li><li id="0231" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe lw lx ly lz b">index </code> —当前元素在数组中被迭代的索引或位置</li><li id="3099" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe lw lx ly lz b">array </code> —应用过滤方法的原始数组</li></ul><p id="f73a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以这个过滤方法为例。请注意，过滤器可以应用于任何类型的阵列。在本例中，我们将根据对象属性过滤对象数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="fd00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅用一行代码，我们就能够过滤一组项目。这太棒了。此外，正如您在第12行中看到的，链接映射和过滤方法对于处理不同类型的数据集非常有用。</p><p id="cb00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经学习了一些关于过滤的基本知识，以及在JavaScript中处理过滤的不同方式。尽管我们主要关注的是可读性，但是当我们在数据集上应用一个方法时，我们不应该忘记性能。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="55ea" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">构建一个过滤函数</h1><p id="de64" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们现在将注意力转向构建我们自己的过滤函数。正如我们在为JavaScript的原生过滤器制作的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank"> polyfill </a>中所看到的，构建一个可扩展到更大数据集并考虑不同边缘情况的生产就绪过滤方法并不简单。然而，在我们的例子中，我们将关注过滤数组的核心。</p><h2 id="be15" class="nv mk it bd ml nw nx dn mp ny nz dp mt li oa ob mv lm oc od mx lq oe of mz og bi translated">自带过滤功能(用于循环型)</h2><p id="1361" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">用<code class="fe lw lx ly lz b">for</code>循环抽象过滤过程非常简单。我们提供过滤函数和原始数组，让<code class="fe lw lx ly lz b">FilterLoop</code>为我们处理过滤过程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h2 id="90e4" class="nv mk it bd ml nw nx dn mp ny nz dp mt li oa ob mv lm oc od mx lq oe of mz og bi translated">自带过滤功能(递归版本)</h2><p id="95db" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在我们将创建一个递归版本的过滤函数。确保首先检查构建映射函数的递归版本<a class="ae ky" href="https://medium.com/better-programming/build-your-own-map-b9a0c9d6fbab" rel="noopener">。</a></p><p id="a080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lw lx ly lz b">for</code>循环版本一样，我们需要传递一个数组和一个过滤函数。然而，正如你在第2行看到的，我们正在<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构</a>数组参数，并把它分成两个新的变量，叫做<code class="fe lw lx ly lz b">head</code>和<code class="fe lw lx ly lz b">tail</code>。</p><p id="6feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法允许我们在每一步决定如果通过了<code class="fe lw lx ly lz b">validFn</code>验证，是否需要返回<code class="fe lw lx ly lz b">head</code>元素(如第9行所示)。如果没有，我们简单地忽略该迭代的元素<code class="fe lw lx ly lz b">head</code>，继续递归调用<code class="fe lw lx ly lz b">FilterRecursive</code>函数(如第13行所示)。</p><p id="ca6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次迭代后，原始数组的长度都会缩小，直到最后我们到达一个空数组。此时<code class="fe lw lx ly lz b">head</code>将被设置为<code class="fe lw lx ly lz b">undefined</code>，因为我们将试图析构一个空数组。然后我们开始返回通过验证器的数组元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h2 id="f20f" class="nv mk it bd ml nw nx dn mp ny nz dp mt li oa ob mv lm oc od mx lq oe of mz og bi translated">自带过滤功能(发电机版本)</h2><p id="3f24" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这是一个用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">生成器函数</a>构建的过滤函数的非常简单的例子。正如您在代码下面的日志中看到的，每次调用生成器函数时，它都会返回一个<code class="fe lw lx ly lz b">iterator object</code>。通过传递我们的验证器函数，我们只返回通过验证的迭代器对象中的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="1330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.freecodecamp.org/news/implement-array-map-with-recursion-35976d0325b2/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/implement-array-map-with-recursion-35976d 0325 b 2/</a></p><p id="e6f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Array/filter</a></p></div></div>    
</body>
</html>