<html>
<head>
<title>Build a CLI Tool to Parse and Query Dynamic JSON in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个CLI工具来解析和查询Golang中的动态JSON</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-cli-tool-to-parse-and-query-dynamic-json-in-golang-cc1db72b1e85?source=collection_archive---------7-----------------------#2021-09-09">https://betterprogramming.pub/build-a-cli-tool-to-parse-and-query-dynamic-json-in-golang-cc1db72b1e85?source=collection_archive---------7-----------------------#2021-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="033d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">运行时查询和解析JSON</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a1c18ec1cf5e320ae8a910a500c6f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ludb2kStb0ZBTzH4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马修·法斯纳赫特在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="842b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您一直在使用Golang开发JSON友好的应用程序，我猜您可能已经遇到了解析动态(我们不知道这个文件的结构)JSON文件的问题。</p><p id="8e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多解决这个问题的方法，比如使用一个空接口和<a class="ae ky" href="https://pkg.go.dev/encoding/json" rel="noopener ugc nofollow" target="_blank">解组</a>,但是在你必须访问JSON的值之前，这似乎是一件轻而易举的事情。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4be8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们会学到什么？</h1><p id="9b5c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不，我们不打算在这个项目中使用<code class="fe mz na nb nc b">JSON.Unmarshal</code>。<strong class="lb iu"> </strong>我们将构建自己的逻辑，使用字符串操作和映射字符串接口从JSON文件解组到Golang数据结构。</p><p id="f78d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将构建一个查询工具，它将帮助我们基于用户在运行时提供的输入来访问<a class="ae ky" href="https://bitfieldconsulting.com/golang/map-string-interface" rel="noopener ugc nofollow" target="_blank">映射字符串接口</a>中的值(接口通常不允许这样做)。这将是一种<a class="ae ky" href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/" rel="noopener ugc nofollow" target="_blank">深度优先搜索</a>类型的基于递归的算法。这听起来可能很吓人，但代码实际上非常简单。</p><p id="6e77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我为JSON验证写的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-your-first-golang-cli-tool-for-json-validation-30dd4ff0b963">上一篇文章中，我使用了参数作为输入，我在这个项目中使用了一个交互式shell。它更有趣，也更容易使用。这将有助于我们在执行期间获得用户输入，提供文本和背景颜色，使我们的程序看起来不枯燥，并有助于无缝的用户交互。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5c0a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="7d5e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你应该了解基本的Golang语法。这需要对<a class="ae ky" href="https://gobyexample.com/" rel="noopener ugc nofollow" target="_blank">栈、递归、指针、结构和控制结构</a>有所了解。如果你对这些有一个基本的概念，你可以继续！我在要点代码中提供了注释，这样你就不会迷路。</p><p id="0dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在最后提供了Github库供你参考。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="97c6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">项目结构</h1><p id="6b15" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我采用这种代码结构是因为我的项目中有一个额外的模块叫做<code class="fe mz na nb nc b">jsonvalidator</code>。这种结构使理解包变得容易，并有助于实现模块化。我可以在其中添加任意数量的包，而不会破坏现有的功能。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="343d" class="nh md it nc b gy ni nj l nk nl">- src/<br/>-- example.com/<br/>--- check.txt<br/>--- check.json<br/>--- go.mod<br/>--- main.go<br/>--- jsonvalidator/<br/>--- jsondigger/<br/>     - jsondigger.go<br/>     - jsondigger_test.go</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="810e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">项目索引</h1><p id="8123" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了更好的理解，这个项目被分成了几个部分。</p><ol class=""><li id="1a62" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">使用<code class="fe mz na nb nc b">github.com/abiosoft/ishell/v2</code>设置交互式外壳并添加命令</li><li id="fccf" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">构建将JSON解组到map string接口的逻辑</li><li id="7a97" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">向用户显示JSON文件的映射</li><li id="8f26" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">构建查询JSON的逻辑</li></ol><h1 id="c764" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">使用ishell设置交互式Shell并添加命令</h1><p id="d25d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">Ishell</code>是一个伟大的开源工具，有助于构建交互式命令行应用程序。它支持用户输入，多行输入，提供颜色，清单和多选选项。我已经使用了<code class="fe mz na nb nc b">ishell</code>来构建CLI命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="cfea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<code class="fe mz na nb nc b">name</code>是您将在shell中调用的模块的名称。<code class="fe mz na nb nc b">help</code>包含模块的描述。<code class="fe mz na nb nc b">Ishell</code>提供了惊人的shell体验，您只需在shell中键入<code class="fe mz na nb nc b">help</code>即可查看描述。</p><p id="1f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Ishell</code>定义了一个<code class="fe mz na nb nc b">context</code>，它包含命令行参数，每个函数用一个命令执行。我已经将它传递给了<code class="fe mz na nb nc b">jsondigger</code>包函数，以便从<code class="fe mz na nb nc b">CLIExecuter</code>函数中访问命令行参数。</p><h1 id="30c3" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">将JSON解组到Map String接口的逻辑</h1><p id="af87" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">地图字符串接口是Golang中最有用的概念之一。它为我们提供了一个指向空接口的映射。</p><p id="8dc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢把它看作是Python字典，但是是在面向对象编程的意义上。接口可以包含字符串、映射、整数或任何任意类型的内容。这给了我们处理不同数据类型的灵活性。</p><p id="2d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，顾名思义，映射将字符串指向一个接口，而接口并不是为了在运行时被查询而构建的。它们不是为了直接引用值而构建的，而是使用称为方法的函数。</p><p id="49f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个空的接口没有任何方法，即使我们填充了它，我们也不能查询它。</p><p id="8468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么使用<code class="fe mz na nb nc b">map[string]interface{}</code>和<code class="fe mz na nb nc b">json.Unmarshal </code>不适合嵌套JSON的原因。如果我们有一个嵌套的JSON，那么查询到更深的层次几乎是不可能的。</p><p id="30d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以编写自己的代码来解组到我们选择的接口中。我使用了堆叠逻辑来处理这个问题。因为我们有一个JSON文件，所以几乎每一行都以一个字符串后跟一个冒号开始。</p><p id="d7d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只使用了<code class="fe mz na nb nc b">map[string]interface{}</code>，但是接口中值的类型是由冒号后面的内容定义的。</p><p id="0531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我考虑过三种可能性。</p><ul class=""><li id="8122" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu oh ns nt nu bi translated">冒号后的第一个字符可以是一个<code class="fe mz na nb nc b">“</code>，如果它是一个字符串的话</li><li id="57dc" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu oh ns nt nu bi translated"><code class="fe mz na nb nc b">{</code>如果是嵌套的JSON对象(为此我们需要一个栈)</li><li id="5c89" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu oh ns nt nu bi translated"><code class="fe mz na nb nc b">[</code>表示JSON文件中的一个数组。</li></ul><p id="f0ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，基于这一点，我必须确保每个级别的地图都被正确填充。主要目的是处理JSON中的嵌套对象，所以我在这个例子中使用了<code class="fe mz na nb nc b">Stack</code>。但是<code class="fe mz na nb nc b">Stack</code>的元素属于<code class="fe mz na nb nc b">struct StackEle</code>类型。</p><p id="4c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了跟踪我们当前嵌套的键，我有一个名为<code class="fe mz na nb nc b">name</code>的字段和另一个名为<code class="fe mz na nb nc b">util</code>的字段，用于处理当前类型为<code class="fe mz na nb nc b">map[string]interface{}</code>的键的数据。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6b7f" class="nh md it nc b gy ni nj l nk nl">type StackEle struct {</span><span id="07bb" class="nh md it nc b gy oi nj l nk nl">name string</span><span id="5e32" class="nh md it nc b gy oi nj l nk nl">util map[string]interface{}</span><span id="1bf9" class="nh md it nc b gy oi nj l nk nl">}</span></pre><p id="d75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始时，我将一个元素添加到最终存储答案的堆栈中。现在，每当我读取冒号后的<code class="fe mz na nb nc b">{</code>时，我都会获取堆栈的顶部。</p><p id="71d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个stack元素，我用当前的key ie添加了堆栈中的键值对。冒号前的字符串和一个空的<code class="fe mz na nb nc b">map[string]interface{}</code>作为值。</p><p id="5cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我将当前添加的空<code class="fe mz na nb nc b">map[string]interface{}</code>推入堆栈，因为我们知道这是一个嵌套层次。</p><p id="5c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Golang自动传递指针，这意味着每当嵌套的<code class="fe mz na nb nc b">map[string]interface{} </code>更新时，堆栈的底层也会更新。每当我在第一行遇到一个<code class="fe mz na nb nc b">}</code>，我就从堆栈中弹出。</p><p id="ddd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果冒号后面有一个<code class="fe mz na nb nc b">“</code>，我知道有一个字符串。因此，我将键值对添加到当前栈顶的<code class="fe mz na nb nc b">util</code> (map)中(同样，stack有助于确保将其添加到正确的级别)。</p><p id="78a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，如果冒号后面有一个<code class="fe mz na nb nc b">[</code>，我就分割字符串并将数组保存在栈顶元素的<code class="fe mz na nb nc b">util</code>对的键值中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2ce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将有一个完全填充的<code class="fe mz na nb nc b">map[string]interface{}</code>,所有的值都被正确填充。但是我们如何对此进行查询呢？</p><h1 id="b235" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">向用户显示JSON文件的映射</h1><p id="fb99" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个DFS类型的算法。我还在命令行中使用了颜色来吸引用户。</p><p id="3536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对象的类型是map string接口，我们将调用调用键值对的当前值的函数。</p><p id="0f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后一个级别，将不再需要调用该功能。这保证了递归会结束，不会陷入无限循环。</p><p id="b6da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还使用计数器来处理缩进的级别。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/4f5c983ee8e68d3ebc15c2cc5c22ba2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzA4F7XGt_uSU5shm6qzwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示对象函数的输出</p></figure><h1 id="b57e" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">构建查询JSON的逻辑</h1><p id="6571" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是类似的逻辑。我们简单地使用DFS查询JSON，当我们找到匹配的键时，我们显示并退出循环。这里，我以点分隔字符串的形式接受查询。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="872b" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; glossary.GlossDiv.GlossList.GlossEntry.GlossTerm</span></pre><p id="dc02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我只需要把字符串分成数组。这种类型的查询适用于所有级别。这意味着即使最后一个元素是地图，它也将使用Golang的默认<code class="fe mz na nb nc b">Println</code>作为地图打印。</p><p id="2a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助递归，我传递了查询字符串数组和一个计数器，以确保我们的方向正确。为了进入下一个级别，我们只需递增计数器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ce237985f9546ac7b7e9074fe9e9792b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ecQNgWoCr8NFl0OQC55_eg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b207" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8e73" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢您阅读至此。我希望你喜欢这个项目。理解栈的工作可能需要一些时间，但是一旦你掌握了它，你将能够更有逻辑和更有效地思考。</p><p id="fbc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归也像堆栈一样工作，几乎任何递归算法都可以用堆栈来模拟。这个项目将带你了解字符串操作、映射、接口、递归、结构等等。对于初学者来说，学习任何东西的最佳方式是开始构建和应用。</p><p id="fd22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是该项目的<a class="ae ky" href="https://github.com/shadowshot-x/go-cli-jsonOps" rel="noopener ugc nofollow" target="_blank"> Github库</a>的链接。如果您愿意参与，我会非常高兴，所以请随意提出拉动请求。</p><h1 id="da6b" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">参考</h1><p id="429f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">大部分代码都是我自己写的，但是我提到了一些对我有帮助的著名参考资料。</p><ol class=""><li id="3a30" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://github.com/abiosoft/ishell" rel="noopener ugc nofollow" target="_blank">伊谢尔</a></li><li id="b40c" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://medium.com/a-journey-with-go/go-understand-the-empty-interface-2d9fc1e5ec72" rel="noopener"> Go:了解空界面</a></li></ol></div></div>    
</body>
</html>