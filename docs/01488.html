<html>
<head>
<title>How To Test Your Automated Builds on Docker Hub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Docker Hub上测试你的自动化构建</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-test-your-automated-builds-on-docker-hub-e40879f35d1e?source=collection_archive---------2-----------------------#2019-09-18">https://betterprogramming.pub/how-to-test-your-automated-builds-on-docker-hub-e40879f35d1e?source=collection_archive---------2-----------------------#2019-09-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d6dd" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">当你在GitHub上发布代码时，让你的测试启动起来</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/bcbd3e79714c8f3d0ead44661da31cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lzV3sOXMh_wYD_w3"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Tammi Baliszewski 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a48f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<a class="ae kz" href="https://medium.com/@NMichas/build-your-docker-images-automatically-when-you-push-on-github-18e80ece76af" rel="noopener">上一篇文章</a>中，我演示了如何快速设置Docker Hub工作流，以便在GitHub上推送代码时自动构建容器映像。</p><p id="3afa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将探讨如何在公开发布之前自动测试您的图像。</p><p id="3dd5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker Hub允许您定义一系列要执行的测试。一旦它为您自动构建了一个映像(并且在这个映像被标记为可供公开下载之前)，这些测试就会发生。</p><p id="6330" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据您的测试结果，您的图像将被发布或不发布，从而确保只有有效/正确的图像被推送到您的Docker存储库。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f2b4" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">指定您的测试</h1><p id="cb58" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我想首先想到的问题是:“我可以执行什么样的测试？”简而言之:任何事情。但是接下来是一个更长的答案。</p><p id="9ae6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker Hub允许您通过将一个<br/> <code class="fe na nb nc nd b">docker-compose.test.yml</code>文件放在与您的<code class="fe na nb nc nd b">Dockerfile</code>相同的级别来指定您的测试。事实上，只要它们都以<code class="fe na nb nc nd b">test.yml</code>结尾，您可以根据需要拥有任意多的这些文件。</p><p id="5d6d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Docker合成文件中，您应该遵循特定的结构，以便Docker能够使用它。模式很简单:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="ffb9" class="ni me iu nd b gz nj nk l nl nm">sut:<br/>  build: .<br/>  command: test_command</span></pre><p id="28f4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">服务名<code class="fe na nb nc nd b">sut</code>是必需的，所以不要省略或替换它。下一个指令，<code class="fe na nb nc nd b">build</code>，实际上建立了你当前的形象。然后用一个<code class="fe na nb nc nd b">command</code>来指定您想要执行的命令来开始您的测试。</p><p id="f5e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以让我们在这里修改一下最初的问题:这些应该/可能是什么样的测试？为了回答这个问题，我们应该记住三件事:</p><ol class=""><li id="966f" class="nn no iu lc b ld le lg lh lj np ln nq lr nr lv ns nt nu nv bi translated">您指定的任何测试命令都在一个容器内运行，该容器从您用Docker Hub构建的映像实例化而来。您必须确保所有资源、外部应用程序、程序和脚本在您的容器中都可用，以便您的测试命令可以找到并使用它们。</li><li id="f6f8" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">Docker Hub自动化测试可以帮助您验证您推送的映像可以在以后成功地实例化一个容器。这很可能不是执行单元、集成、性能或其他更适合CI/CD管道的前一步的测试的地方。例如，如果您的单元测试失败了，您是否不想在实际将构建升级到Docker Hub之前知道这一点？使用适当的工具和环境来执行您的测试。</li><li id="70f6" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">Docker Hub构建在它们可能消耗的时间和资源方面有特定的限制。拥有一个复杂的构建和测试工作流可能会让你超出那些相当宽松的限制，导致你的构建和测试失败。根据<a class="ae kz" href="https://success.docker.com/article/what-are-the-current-resource-limits-placed-on-automated-builds" rel="noopener ugc nofollow" target="_blank"> KB000470 </a>，这些限制目前为:<br/> -总执行时间:2小时<br/> -总使用内存:2 GB <br/> - CPU分配:1个CPU <br/> -总使用磁盘空间:30 GB</li></ol><p id="8346" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">总之，尽可能缩短您的构建和测试，最大限度地减少资源使用，并在CI/CD管道的后期测试什么是合适的。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4fbf" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">构建和运行测试</h1><p id="05cb" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">使用我们在<a class="ae kz" href="https://medium.com/@NMichas/build-your-docker-images-automatically-when-you-push-on-github-18e80ece76af" rel="noopener">上一篇文章</a>中创建的<a class="ae kz" href="https://github.com/NMichas/dockerbuild" rel="noopener ugc nofollow" target="_blank">简单项目</a>，我们讨论了如何创建自动化构建，我们现在将编写一个测试作为自动化构建的一部分来执行。</p><h2 id="c7d3" class="ni me iu bd mf ob oc dn mj od oe dp mn lj of og mp ln oh oi mr lr oj ok mt ol bi translated">成功的测试返回0</h2><p id="fc01" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这是一个非常简单的规则。</p><p id="fb0e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了让Docker Hub意识到您的测试已经成功执行，并且您的映像现在有资格被标记并分发给他人使用，您的测试脚本应该返回一个零(0)的退出/返回代码。</p><p id="a881" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">任何其他代码都被视为错误，会将您的构建呈现为失败，不会对其进行标记，也不会使其在Docker Hub上可供下载。</p><h2 id="7c22" class="ni me iu bd mf ob oc dn mj od oe dp mn lj of og mp ln oh oi mr lr oj ok mt ol bi translated">创建<code class="fe na nb nc nd b">docker-compose.test.yml</code>文件</h2><p id="2362" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">因为我们只有一个简单的Hello World项目，所以除了<code class="fe na nb nc nd b">hello-world</code>二进制文件本身之外，我们没有什么可以真正测试的。创建一个<br/> <code class="fe na nb nc nd b">docker-compose.test.yml</code>文件，并放置以下内容:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="e8ff" class="ni me iu nd b gz nj nk l nl nm">sut:<br/>  build: .<br/>  command: /hello</span></pre><p id="ea5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将该文件添加到GitHub repo中，然后推送。如果您已经遵循了本系列中<a class="ae kz" href="https://medium.com/@NMichas/build-your-docker-images-automatically-when-you-push-on-github-18e80ece76af" rel="noopener">上一篇文章</a>的构建规则，几分钟后您应该会有一个带有<em class="om">最新</em>标签的新构建。通过检查这个构建的输出，您现在可以看到我们的测试命令被执行了:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj on"><img src="../Images/53539d1cae76d89e1e6e1de39585cae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xShd0ic6wAkoJEQ1NDqu4g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">测试成功执行</p></figure><h2 id="3e2d" class="ni me iu bd mf ob oc dn mj od oe dp mn lj of og mp ln oh oi mr lr oj ok mt ol bi translated">在接收拉取请求时启用自动化测试</h2><p id="cbdd" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">您还可以让Docker Hub在您的GitHub存储库收到PRs时自动执行您的测试。登录到您的Docker Hub帐户，并切换到您正在使用的存储库。导航到Builds选项卡并单击Configure Automated Builds按钮:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/7e733769e2fccf9d5800f45726960b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nhvc5ZUkHiRRFyjVoRqTQw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">配置您的自动化构建</p></figure><p id="780b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要启用测试，您只需选择自动测试<em class="om"> </em>部分<em class="om"> : </em>下的一个可用选项</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj op"><img src="../Images/b5cfb0c46f68c1346a6e1f759f28c6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fspkM1ZnzcuEFFxUHjaiZA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">选择测试类型</p></figure><p id="8204" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了<em class="om"> </em>关闭，<em class="om"> </em>这是一种不言自明的方法，其他两个选项告诉Docker Hub在什么情况下执行您的测试。<br/>当PRs来自相同的源存储库时，内部拉请求执行测试，而内部和外部拉请求总是执行测试。</p><p id="e9a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，出于安全原因，接收外部pull请求时的测试执行只适用于公共映像(否则，任何人都可以通过发送包含一些精心制作的测试的PR来访问您的私有映像及其数据)。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="fd01" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated"><strong class="ak">本系列其他文章</strong></h1><div class="oq or gq gs os ot"><a href="https://medium.com/better-programming/build-your-docker-images-automatically-when-you-push-on-github-18e80ece76af" rel="noopener follow" target="_blank"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd iv gz z fq oy fs ft oz fv fx it bi translated">当你在GitHub上推送时，自动构建你的Docker图像</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">在GitHub上推送代码时，如何在Docker Hub上设置自动化构建。</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kt ot"/></div></div></a></div><div class="oq or gq gs os ot"><a href="https://medium.com/@NMichas/how-to-recover-from-a-failed-automated-docker-hub-build-8b6c1cc3d7d4" rel="noopener follow" target="_blank"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd iv gz z fq oy fs ft oz fv fx it bi translated">如何从失败的自动化Docker Hub构建中恢复</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">你的Docker Hub自动化构建失败了吗？这里有一个如何恢复它的快速指南。</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">medium.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph kt ot"/></div></div></a></div></div></div>    
</body>
</html>