<html>
<head>
<title>Build Pie Charts in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中构建饼图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-pie-charts-in-swiftui-822651fbf3f2?source=collection_archive---------1-----------------------#2021-04-28">https://betterprogramming.pub/build-pie-charts-in-swiftui-822651fbf3f2?source=collection_archive---------1-----------------------#2021-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0ae4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在您的iOS应用程序中创建优雅的图表</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/da07055937681a83478579d1ec29fa67.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*lpWQw-yDVY8YvY225H4KsQ.gif"/></div></figure><p id="e19f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我将解释我是如何在SwiftUI中创建了如上所示的漂亮的饼图。您可以在Github上找到这个库，并通过一个简单的步骤将其添加到您的XCode项目中。参见<a class="ae lj" href="https://github.com/ilamanov/SwiftPieChart" rel="noopener ugc nofollow" target="_blank">https://github.com/ilamanov/SwiftPieChart</a>。</p><p id="b13a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">文章由两部分组成:</p><ul class=""><li id="135a" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li lp lq lr ls bi translated">创建饼图</li><li id="02d0" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated">创建在饼图下方显示附加信息的表格</li></ul></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="6537" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">创建饼图</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/26760d1cb742c9daebffda975ffe57ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*I0XUgnuCb0fvlk2f_4e6sA.png"/></div></figure><p id="2b9a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">饼图由一些切片组成。让我们创建一个组件来显示一个切片。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/681f50e4bc28aa45d74b3a75e838d599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*AjxSKY7kCHj0o70Kegez6Q.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">饼图的一部分</p></figure><p id="189a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">创建一个新文件<code class="fe nd ne nf ng b">PieSliceView.swift</code>。向其中添加以下<code class="fe nd ne nf ng b">PieSliceData</code>数据结构——这将用于保存饼图扇区的数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ee81" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了渲染饼图，我们将使用一个<code class="fe nd ne nf ng b">Path</code>。<code class="fe nd ne nf ng b">Path</code>需要两次调用来渲染这个切片。首先，我们需要将光标移动到屏幕的中心，然后我们需要画一个弧形。我们将用<code class="fe nd ne nf ng b">path.move()</code>和<code class="fe nd ne nf ng b">path.addArc()</code>来完成这些:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2690" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们使用框架的宽度和高度来计算中心点。我们可以从<code class="fe nd ne nf ng b">GeometryReader</code>对象中获取框架的宽度和高度。我们取框架的最小尺寸，并将其作为图表的尺寸(上面的第<code class="fe nd ne nf ng b">7</code>行),这样我们的图表就是方形的，并适合它的框架。我们还添加了<code class="fe nd ne nf ng b">aspectRatio()</code>，因此我们的图表垂直居中。我们需要90度的偏移(线<code class="fe nd ne nf ng b">17</code>和<code class="fe nd ne nf ng b">18</code>)，因为在SwiftUI坐标系中，0度从3点开始，而不是从0点开始。</p><p id="5537" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们现在可以测试这个切片渲染:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1a48" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">结果是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/681f50e4bc28aa45d74b3a75e838d599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*AjxSKY7kCHj0o70Kegez6Q.png"/></div></figure><p id="c223" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们在这个切片上添加文本。为此我们将使用<code class="fe nd ne nf ng b">ZStack</code>——我们将文本堆叠在我们的弧的顶部:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ff0f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">计算文本的位置(上面的第<code class="fe nd ne nf ng b">30</code>行)很复杂。首先，我们计算中间角度(开始和结束角度之间的中点-线<code class="fe nd ne nf ng b">4</code>)。同样，我们需要一个<code class="fe nd ne nf ng b">Pi / 2</code> (90度)的偏移量来补偿坐标系的差异(SwiftUI中的0度是3点钟，但在我们的目的中，0度是12点钟)。</p><p id="81b9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后使用下面的公式计算文本的位置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/379e2d2f4bf9b08802062d19301128f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KvlMekZoJK3yPB7BTrcleg.jpeg"/></div></div></figure><p id="bd17" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">结果是顶部有文本的饼图切片:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/84311ac876bde386e627ee4133cdec5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*PCZ5XIynOxMtYc8sryjarA.png"/></div></figure><p id="f3f9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们可以渲染一片饼图，让我们渲染一堆饼图，并将它们组合成一个饼图。</p><h2 id="9c92" class="np mg iq bd mh nq nr dn ml ns nt dp mp kw nu nv mr la nw nx mt le ny nz mv oa bi translated">组合饼图切片</h2><p id="d997" class="pw-post-body-paragraph kn ko iq kp b kq ob jr ks kt oc ju kv kw od ky kz la oe lc ld le of lg lh li ij bi translated">让我们创建一个名为<code class="fe nd ne nf ng b">PieChartView.swift</code>的新文件来呈现饼图。我们将为这个视图添加两个参数:<code class="fe nd ne nf ng b">values</code>和<code class="fe nd ne nf ng b">colors</code> <em class="og"> </em>，它们将指示饼图切片的值和颜色。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5f5a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们根据提供的<code class="fe nd ne nf ng b">values</code>和<code class="fe nd ne nf ng b">colors</code>计算<code class="fe nd ne nf ng b">slices</code>(它是一个<code class="fe nd ne nf ng b">PieSliceData</code>的数组)。我们基于每个切片的值来计算该切片的跨度。以度为单位计算跨度的公式是<code class="fe nd ne nf ng b">degrees = 360 * value / sum</code>，其中<code class="fe nd ne nf ng b">sum</code>是所有值的总和(第13行)。基于跨度，我们计算所有切片的<code class="fe nd ne nf ng b">start</code>和<code class="fe nd ne nf ng b">end angles</code>。我们将使用<code class="fe nd ne nf ng b">slices</code>数组将所需的数据从上一节传入我们的<code class="fe nd ne nf ng b">PieSliceView</code>。</p><p id="b47f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，让我们修改视图的<code class="fe nd ne nf ng b">body</code>功能，以便绘制我们的切片:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="05df" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们使用一个<code class="fe nd ne nf ng b">ZStack</code>来堆叠所有切片，并将所有切片的帧设置为等于我们的<code class="fe nd ne nf ng b">PieChartView</code>的帧大小。我们还为我们的<code class="fe nd ne nf ng b">PieChartView</code>添加了一个<code class="fe nd ne nf ng b">backgroundColor</code>参数，这样我们可以很容易地改变背景。结果如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/fe9fc58264d45a63cc07f330c04ed103.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*m7UeF7VpLIT0TeixsMlIFw.png"/></div></figure><p id="8413" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，让我们在饼图的中心添加一些文本。我们首先添加一个与背景颜色匹配的圆，然后在圆的顶部添加文本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1040" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们添加了另一个参数叫做<code class="fe nd ne nf ng b">innerRadiusFraction</code>(第11行)来控制内圆的半径。现在，我们将饼图中心的文本设置为所有值的总和。</p><p id="18c9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="og">我们也可以让这个文本动态化——当你点击切片时显示切片的值。动态文本的实现参见</em><a class="ae lj" href="https://github.com/ilamanov/SwiftPieChart" rel="noopener ugc nofollow" target="_blank"><em class="og"/></a><em class="og">。</em></p><p id="a312" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">结果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/2fab47c5f5d98a0e9caf1c1c379752a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*xXPvt4G4cjAVBrQSadfcog.png"/></div></figure><p id="17a8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们已经完成了饼图中最重要的部分。我们还可以在用户单击单个切片时添加很酷的动画，如下所示。那些效果的实现见<a class="ae lj" href="https://github.com/ilamanov/SwiftPieChart" rel="noopener ugc nofollow" target="_blank">https://github.com/ilamanov/SwiftPieChart</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/248e43a980d533d38784a2c8d0739fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*BiS7UhJiMiWUZT9zz622Og.gif"/></div></figure><p id="6479" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，让我们在饼图下方添加一些附加信息。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="2f65" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">创建显示附加信息的表格</h1><p id="3961" class="pw-post-body-paragraph kn ko iq kp b kq ob jr ks kt oc ju kv kw od ky kz la oe lc ld le of lg lh li ij bi translated">让我们将下面的<code class="fe nd ne nf ng b">PieChartRows</code>视图添加到<code class="fe nd ne nf ng b">PieChartView.swift</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4b45" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">该视图将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b4411afdc1d813040d31bedde459f7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*mEqx-Vc8p34Qh4r3eGdMQw.png"/></div></figure><p id="edaf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们现在可以在我们的<code class="fe nd ne nf ng b">PieChartView</code>中渲染它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1702" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们把我们的<code class="fe nd ne nf ng b">ZStack</code>包装成了一个<code class="fe nd ne nf ng b">VStack</code>，并在<code class="fe nd ne nf ng b">ZStack</code>下面加上了<code class="fe nd ne nf ng b">PieChartRows</code>。我们还添加了另一个参数<code class="fe nd ne nf ng b">names</code>，这样我们就可以在图表中显示类别的名称。</p><p id="2bf3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">就这样！我们的饼图完成了。<code class="fe nd ne nf ng b">PieChartView</code>的完整代码如下所示。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="51fd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/0239e433ab50dc92dc2651197c8f34ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*VzyqFyy3iDZfGaZEV4lWvQ.png"/></div></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="a79d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们没有将悬停效果添加到我们的饼状图中，但是您可以在Github repo中找到这些效果的实现:<a class="ae lj" href="https://github.com/ilamanov/SwiftPieChart" rel="noopener ugc nofollow" target="_blank">https://github.com/ilamanov/SwiftPieChart</a>。</p><p id="f300" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您甚至可以直接从XCode将这个repo作为资源库添加到您的项目中——有关说明，请参阅repo。</p></div></div>    
</body>
</html>