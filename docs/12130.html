<html>
<head>
<title>4 Domains of Knowledge You Should Know About Strings in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python中的字符串，你应该知道的4个知识领域</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-domains-of-knowledge-you-should-know-about-strings-in-python-70703c0ba1d0?source=collection_archive---------11-----------------------#2022-05-13">https://betterprogramming.pub/4-domains-of-knowledge-you-should-know-about-strings-in-python-70703c0ba1d0?source=collection_archive---------11-----------------------#2022-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2da4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对您的Python字符串知识的高层次回顾</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18ec5c8d876ff6e94e3ca3df0aefd341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xsGX5ZT5EJn_gxlU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布雷特·乔丹在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文本是最基本的信息交流形式。无论您正在构建什么样的应用程序，您都不可避免地要以某种方式处理文本信息。因此，很好地理解使用和处理Python中的字符串的基本技术是至关重要的。在这篇文章中，我想提供一个关于字符串的四个知识领域的高级回顾。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a0b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.使用和搜索子字符串</h1><h2 id="c6a2" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">使用下标访问一个或多个字符</h2><p id="1acc" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">字符串是Python中的一种序列数据类型，因此可以使用下标访问单个或多个字符。下面是一些例子:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="75e6" class="mu md it nm b gy nq nr l ns nt">greeting = "Hello, World!"</span><span id="10a5" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">assert</strong> greeting[0] == "H"<br/><strong class="nm iu">assert</strong> greeting[1:3] == "el"</span></pre><p id="de24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你只使用一个索引时，你得到的是一个字符。当你使用切片(<code class="fe nv nw nx nm b">start_index:end_index</code>)时，你会得到多个字符。请注意，当您使用切片时，不包括结束索引。您还可以向切片添加一个步骤，以便可以检索不连续的字符:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2917" class="mu md it nm b gy nq nr l ns nt"><strong class="nm iu">assert</strong> greeting[1:10:2] == 'el,Wr'</span></pre><p id="7145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像Python中的其他序列数据一样，如果想要检索字符串末尾的字符，也可以使用负索引。对于负索引，-1表示最后一个，-2表示倒数第二个，依此类推。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="b7f9" class="mu md it nm b gy nq nr l ns nt"><strong class="nm iu">assert</strong> greeting[-1] == '!'<br/><strong class="nm iu">assert</strong> greeting[-3:-1] == "ld"</span></pre><h2 id="3c25" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">检查子字符串是否存在</h2><p id="58a1" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">因为字符串是序列，这意味着它支持使用<code class="fe nv nw nx nm b">in</code> : <code class="fe nv nw nx nm b">substr in text</code>来检查字符串中是否存在子串。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0e34" class="mu md it nm b gy nq nr l ns nt"><strong class="nm iu">assert</strong> "Wor" in greeting</span></pre><p id="63de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果要检查一个字符串的开头是否包含子串，最好使用<code class="fe nv nw nx nm b">startswith</code>方法。你应该知道还有另一个相关的方法<code class="fe nv nw nx nm b">endswith</code>，它检查结束。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4ced" class="mu md it nm b gy nq nr l ns nt"><strong class="nm iu">assert</strong> greeting.startswith("Hello")<br/><strong class="nm iu">assert</strong> greeting.endswith("ld!")</span></pre><h2 id="878b" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">定位子字符串</h2><p id="a12d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">有时候，仅仅知道一个子字符串是否存在于另一个字符串中是不够的。相反，我们想知道确切的位置。这种情况下，我们可以用<code class="fe nv nw nx nm b">index</code>或者<code class="fe nv nw nx nm b">find</code>。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0648" class="mu md it nm b gy nq nr l ns nt"><strong class="nm iu">assert</strong> greeting.index("ello") == 1<br/><strong class="nm iu">assert</strong> greeting.find("ello") == 1</span></pre><p id="5644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎两者都在做同样的事情。但是，我建议您使用<code class="fe nv nw nx nm b">find</code>，因为在一个不存在的子串上调用<code class="fe nv nw nx nm b">index</code>会引发一个异常，这可能会使您的程序崩溃。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2659" class="mu md it nm b gy nq nr l ns nt">&gt;&gt;&gt; greeting.find("no_substr")<br/>-1<br/>&gt;&gt;&gt; greeting.index("no_substr")<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>ValueError: substring not found</span></pre><p id="31ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面注意，当字符串中不存在子串时，<code class="fe nv nw nx nm b">find</code>返回-1，而<code class="fe nv nw nx nm b">index</code>引发<code class="fe nv nw nx nm b">ValueError</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="83a6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.f弦</h1><p id="0d8d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">说到字符串格式化和插值，你应该很了解f字符串。当我们说插值时，我们的意思是将非字符串变量转换成它们的字符串表示。</p><p id="6cc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">string(或string)是使用F或F作为前缀的字符串文字，F表示格式化。下面展示了如何创建一个简单的f字符串。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="89c8" class="mu md it nm b gy nq nr l ns nt">&gt;&gt;&gt; message = f"First Message: {greeting}"<br/>&gt;&gt;&gt; print(message)<br/>First Message: Hello, World!</span></pre><h2 id="e85e" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">字符串连接/插值</h2><p id="7e7d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">当您想要连接多个字符串/变量时，最好使用f字符串，因为它们可以自动处理插值。当您使用<code class="fe nv nw nx nm b">+</code>操作将字符串与非字符串变量连接起来时，每个参与者都必须是字符串。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="7985" class="mu md it nm b gy nq nr l ns nt">price = 1.23<br/>volume = 12<br/>product = "water"</span><span id="dcf2" class="mu md it nm b gy nu nr l ns nt">description0 = "Product Name: " + product + "; Price: $" + str(price) + "; Volume: " + str(volume) + " oz"</span><span id="ab4e" class="mu md it nm b gy nu nr l ns nt">print(description0)<br/># output: Product Name: water; Price: $1.23; Volume: 12 oz</span></pre><p id="0248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面看到的，从多个变量构造一个字符串是非常复杂的，特别是包括一些非字符串变量。相比之下，f字符串使这种连接操作简单得多:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="72e2" class="mu md it nm b gy nq nr l ns nt">description1 = f"Product Name: {product}; Price: ${price:}; Volume: {volume} oz"</span><span id="01df" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">assert</strong> description0 == description1</span></pre><p id="632f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用f字符串来创建描述1，它与描述0相匹配。正如你所看到的，f弦消除了不同部分之间的物理空间，使得连续阅读更加容易。</p><h2 id="c95f" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">格式规范</h2><p id="f9f3" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">对于f字符串，您还应该熟悉格式说明符，它允许您在变量后面使用<code class="fe nv nw nx nm b">:</code>来应用额外的格式要求。下面是一些例子:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3038" class="mu md it nm b gy nq nr l ns nt"># Big numbers separator<br/>big_number = 98765432123456789<br/><strong class="nm iu">assert</strong> f"{big_number:_d}" == '98_765_432_123_456_789'</span><span id="d068" class="mu md it nm b gy nu nr l ns nt"># Floating numbers formatting<br/>more_digits = 2.345678<br/><strong class="nm iu">assert</strong> f"{more_digits:.2f}" == '2.35'<br/><strong class="nm iu">assert</strong> f"{more_digits:.4f}" == '2.3457'</span><span id="946d" class="mu md it nm b gy nu nr l ns nt"># Scientific notation<br/>sci_number = 0.0000043203<br/><strong class="nm iu">assert</strong> f"{sci_number:e}" == '4.320300e-06'</span></pre><h2 id="5dc2" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">联盟</h2><p id="ee47" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">您还可以根据字符串的对齐方式提供格式要求，例如左对齐或居中对齐。我们也可以应用填充来填补空白。下面是一些例子:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="73ca" class="mu md it nm b gy nq nr l ns nt">s0, s1 = 'a', 'bb'</span><span id="fc36" class="mu md it nm b gy nu nr l ns nt"># Left-aligned with padding *<br/>print(f'{s0:*&lt;7}\n{s1:*&lt;7}')<br/># output the following:<br/>a******<br/>bb*****</span><span id="7a35" class="mu md it nm b gy nu nr l ns nt"># Right-aligned with padding %<br/>print(f'{s0:%&gt;8}\n{s1:%&gt;8}')<br/># output the following:<br/>%%%%%%%a<br/>%%%%%%bb</span><span id="f401" class="mu md it nm b gy nu nr l ns nt"># Center-aligned<br/>print(f'{s0:@^9}\n{s1:@^9}')<br/># output the following:<br/>@@@@a@@@@<br/>@@@bb@@@@</span></pre><p id="fd67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们使用&lt; to indicate that we want left alignment, &gt;进行右对齐，使用^进行中心对齐。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9edc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.自定义类的字符串表示形式</h1><p id="a36b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">当您定义定制类时，您想要实现两个特殊的方法:<code class="fe nv nw nx nm b">__str__</code>和<code class="fe nv nw nx nm b">__repr__</code>。</p><h2 id="520e" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">覆盖__repr__</h2><p id="e8f6" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在您的自定义类中，您可以覆盖<code class="fe nv nw nx nm b">__repr__</code>，它应该返回一个字符串。更具体地说，该字符串可用于重建具有相同属性的另一个实例对象。考虑下面的例子。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="b059" class="mu md it nm b gy nq nr l ns nt">class Student:<br/>    def __init__(self, name: str, grade: int) -&gt; None:<br/>        self.name = name<br/>        self.grade = grade</span><span id="eab0" class="mu md it nm b gy nu nr l ns nt">    def __repr__(self) -&gt; str:<br/>        print("__repr__ is invoked")<br/>        return f"Student({self.name!r}, {self.grade})"</span></pre><p id="3cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个类，我们可以创建一个实例，并检查它。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1612" class="mu md it nm b gy nq nr l ns nt">&gt;&gt;&gt; student = Student("John Robinson", 6)<br/>&gt;&gt;&gt; student<br/>__repr__ is invoked<br/>Student('John Robinson', 6)</span></pre><p id="07f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，当我们在交互式Python控制台中输入实例变量时，会调用<code class="fe nv nw nx nm b">__repr__</code>方法并显示自定义实例的字符串表示。</p><p id="d98e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到，在f弦中，当我们插值<code class="fe nv nw nx nm b">self.name</code>时，我们包含了<code class="fe nv nw nx nm b">!r</code>。这就是所谓的格式转换——我们指定这个变量应该通过调用它的<code class="fe nv nw nx nm b">__repr__</code>方法进行插值。这里，对于一个字符串，<code class="fe nv nw nx nm b">!r</code>将把它用引号括起来，允许用户通过调用<code class="fe nv nw nx nm b">Student(‘John Robinson’, 6)</code>来重建一个<code class="fe nv nw nx nm b">Student</code>实例。</p><p id="492d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，如果不使用<code class="fe nv nw nx nm b">!r</code>，表示就变成了<code class="fe nv nw nx nm b">Student(John Robinson, 6)</code>，如果调用它，这是无效的语法。请注意<code class="fe nv nw nx nm b">!r</code>只需要用于字符串，不需要用于整数，如我们的例子所示。</p><h2 id="9cf1" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">覆盖__str__</h2><p id="912b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在您的自定义类中，您还应该覆盖<code class="fe nv nw nx nm b">__str__</code>，它也返回一个字符串。与__repr__返回的字符串相比，<code class="fe nv nw nx nm b"> __str__</code>返回的字符串应该更具信息性，如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d850" class="mu md it nm b gy nq nr l ns nt">class Student:<br/>    def __init__(self, name: str, grade: int) -&gt; None:<br/>        self.name = name<br/>        self.grade = grade</span><span id="caa5" class="mu md it nm b gy nu nr l ns nt">    def __repr__(self) -&gt; str:<br/>        print("__repr__ is invoked")<br/>        return f"Student({self.name!r}, {self.grade})"</span><span id="c395" class="mu md it nm b gy nu nr l ns nt">    def __str__(self) -&gt; str:<br/>        print("__str__ is called")<br/>        return f"Student Name: {self.name}; Grade: {self.grade}"</span></pre><p id="995f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了更新后的类，我们可以运行下面的代码来看看如何调用<code class="fe nv nw nx nm b">__str__</code>。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="911d" class="mu md it nm b gy nq nr l ns nt">&gt;&gt;&gt; student = Student("John Robinson", 6)<br/>&gt;&gt;&gt; print(student)<br/>__str__ is called<br/>Student Name: John Robinson; Grade: 6</span></pre><p id="f559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在用实例调用<code class="fe nv nw nx nm b">print</code>函数，而不是直接检查实例。如您所见，我们获得了由<code class="fe nv nw nx nm b">__str__</code>创建的字符串。因此，作为一般规则，当您在实例对象上调用print时，它是由<code class="fe nv nw nx nm b">__str__</code>返回的字符串。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ecde" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.正则表达式</h1><p id="7db4" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Python字符串有许多适合基本文本数据处理的方法。但是，当您有更复杂的字符串处理作业时，您可能必须使用正则表达式。为了简单起见，我将正则表达式称为regex。</p><p id="8819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文本处理中，Regex有时被认为是一种独立的语言，尽管许多编程语言都集成了它并创建了各自的“方言”值得注意的是，大多数用法或多或少是相似的，如果你很了解Python，你可以很容易地学习另一种语言的regex相关特性。</p><h2 id="430c" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">构建模式</h2><p id="ec80" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在Python的标准库中，re模块提供了regex所需的功能。使用正则表达式的第一步是构建正确的模式。用字符串表示的模式决定了字符串应该是什么样子。</p><p id="b4c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于常规字符串，它们只是表示它们看起来是什么样子。例如，<code class="fe nv nw nx nm b">“abc”</code>表示字符串应该有<code class="fe nv nw nx nm b">“abc”</code>。然而，正如您可能意识到的，这些字符串的功能不足以检测多种匹配更一般模式的字符串。为此，有几类模式构建元素。</p><p id="fd4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">边界锚</strong> <br/>第一类属于模式的前缀和后缀。下面列出了一些常见的粗体锚点。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="401b" class="mu md it nm b gy nq nr l ns nt"><strong class="nm iu">^hello</strong>         starts with hello</span><span id="cd1e" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">world$</strong>         ends with world</span><span id="b94b" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">^hello world$</strong>  starts and ends with “hello world”, and thus exact matching</span></pre><p id="3a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数量词</strong> <br/>你也可以指定某个字符串应该有多少次重复。它们被称为量词。一些常见的如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="51eb" class="mu md it nm b gy nq nr l ns nt"><strong class="nm iu">he?</strong>       h followed by zero or one e</span><span id="84be" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">he* </strong>      h followed by zero or more e</span><span id="d6a0" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">he+ </strong>      h followed by one or more e</span><span id="a585" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">he{3}</strong>     h followed by eee</span><span id="9a41" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">he{1,3}</strong>   h followed by e, ee, or eee</span><span id="e09f" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">he{2,} </strong>   h followed by 2 or more e</span></pre><p id="23cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">字符类</strong> <br/>你可以只用几个字符来表示一大组字符，这可以大大简化模式。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0bf7" class="mu md it nm b gy nq nr l ns nt"><strong class="nm iu">\d</strong>       any decimal digit</span><span id="7b4c" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">\D </strong>      any character that is not a decimal digit</span><span id="d4dc" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">\s</strong>       any whitespace, including space, \t, \n, \r, \f, \v</span><span id="5d5b" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">\S </strong>      any character that isn't a whitespace</span><span id="cf67" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">\w</strong>       any word character, means alphanumeric plus underscores</span><span id="7f41" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">\W</strong>       any character that is not a word character</span><span id="312f" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">. </strong>       any character except a newline</span><span id="bd73" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">[abc]</strong>    a set of defined characters, in this case, a, b, or c</span></pre><p id="6973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">逻辑运算符</strong> <br/> Regex和其他语言一样，有自己的逻辑运算符。下面是一些例子:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4d29" class="mu md it nm b gy nq nr l ns nt"><strong class="nm iu">a|b</strong>       a or b</span><span id="a11c" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">(abc)</strong>     abc as a group</span><span id="1067" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">[^a]</strong>      any character other than a</span></pre><h2 id="2f62" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">使用该模式</h2><p id="7dba" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在您构建了一个模式之后，是时候测试它是否按预期工作了。请注意，这是非常常见的，你可能要调整你的模式多次，才最终工作。所以，如果你正在努力让你的模式正确，不要担心。要使用一个模式，有两种方法。</p><p id="d458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要多次使用该模式，最好编译该模式，这样当您的程序再次使用它时，可以节省时间。您可以在下面找到这种用法:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="08cd" class="mu md it nm b gy nq nr l ns nt">import re</span><span id="ed73" class="mu md it nm b gy nu nr l ns nt">pattern = re.compile("^hi")</span><span id="2ce0" class="mu md it nm b gy nu nr l ns nt">pattern.search("hi, Python")<br/># output: &lt;re.Match object; span=(0, 2), match='hi'&gt;</span><span id="ccd0" class="mu md it nm b gy nu nr l ns nt">pattern.search("hi, JavaScript")<br/># output: &lt;re.Match object; span=(0, 2), match='hi'&gt;</span><span id="0468" class="mu md it nm b gy nu nr l ns nt">pattern.search("hello, C#")<br/># output: None</span></pre><p id="7322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您只使用该模式一次时，我们可以简单地使用<code class="fe nv nw nx nm b">re</code>模块中的各种函数，如下所示。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d03e" class="mu md it nm b gy nq nr l ns nt">re.search(r"^hi", "hi Python")<br/># output: &lt;re.Match object; span=(0, 2), match='hi'&gt;</span></pre><h2 id="8611" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">匹配对象</h2><p id="e3fd" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">当使用字符串模式时，最重要的数据是<code class="fe nv nw nx nm b">Match</code>对象，如上例所示。对于<code class="fe nv nw nx nm b">Match</code>对象，它包括匹配的跨度，以及匹配了什么。可以找到它常用的方法和各自的效果。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="23e4" class="mu md it nm b gy nq nr l ns nt">match = re.search(r"(\w\d)+", "xyzdda2b1c3ee")</span><span id="a97e" class="mu md it nm b gy nu nr l ns nt">print(match)<br/># output: &lt;re.Match object; span=(5, 11), match='a2b1c3'&gt;</span><span id="d07c" class="mu md it nm b gy nu nr l ns nt">print("matched:", match.group())<br/># output: matched: a2b1c3</span><span id="ecd0" class="mu md it nm b gy nu nr l ns nt">print("span:", match.span())<br/># output: span: (5, 11)</span><span id="c402" class="mu md it nm b gy nu nr l ns nt">print(f"start: {match.start()} &amp; end: {match.end()}")<br/># output: start: 5 &amp; end: 11</span></pre><p id="2063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，<code class="fe nv nw nx nm b">Match</code>对象被评估为真，因此，您可以使用:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="69f0" class="mu md it nm b gy nq nr l ns nt">match = re.search("the_pattern", "the_string")<br/>if match:<br/>    # when a match is found, do the operation<br/>else:<br/>    # when a match isn't found, do the other operation</span></pre><h2 id="0048" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">解决现实生活中的问题</h2><p id="028b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">让我们把事情放在一起，解决一个现实生活中的问题。假设我们有以下数据:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0114" class="mu md it nm b gy nq nr l ns nt">students_data = """101, John Robinson; good at maths<br/>some random nonsense<br/>102, Ashley Young; good at sports<br/>54, random; record<br/>103, Zoe Apple; All As<br/>1234, random; record<br/>Another random record"""</span></pre><p id="332a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这是关于有学生信息的数据。每行代表一个学生的信息。但是，文本数据包含其他不正确的数据，我们希望提取正确的记录。</p><p id="870e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过观察所有这些行，我们可以看到学生证号是3位数，后面是姓名和描述。因此，我们可能会提出下面的模式，并给出详细的解释。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2949" class="mu md it nm b gy nq nr l ns nt">r"(\d{3}), (.+); (.+)"</span><span id="9f2e" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">(\d{3})</strong>:   a group of 3 digits <strong class="nm iu">-&gt; for the ID number</strong></span><span id="a1be" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">, </strong>:        string literals, a comma and a space</span><span id="507f" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">(.+)</strong>:     a group of one or more word characters <strong class="nm iu">-&gt; for the name</strong></span><span id="afbd" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">; </strong>:        string literals, a semicolon and a space</span><span id="fa61" class="mu md it nm b gy nu nr l ns nt"><strong class="nm iu">(.+)</strong>:      a group of one or more characters -&gt; <strong class="nm iu">for the description</strong></span></pre><p id="cfe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用这种模式，我们可以提取所需的记录:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8ae7" class="mu md it nm b gy nq nr l ns nt">regex = re.compile(r"(\d{3}), (.+); (.+)")<br/>desired_records = []</span><span id="674c" class="mu md it nm b gy nu nr l ns nt">for line in students_data.split("\n"):<br/>    match = regex.match(line)<br/>    if match:<br/>        print(f"{'Matched:':&lt;12}{match.group()}")<br/>        desired_records.append(line)<br/>    else:<br/>        print(f"{'No Match:':&lt;12}{line}")</span><span id="95be" class="mu md it nm b gy nu nr l ns nt">print(desired_records)</span><span id="14bb" class="mu md it nm b gy nu nr l ns nt"># output the following lines:</span><span id="02ce" class="mu md it nm b gy nu nr l ns nt">Matched:    101, John Robinson; good at maths<br/>No Match:   some random nonsense<br/>Matched:    102, Ashley Young; good at sports<br/>No Match:   54, random; record<br/>Matched:    103, Zoe Apple; All As<br/>No Match:   1234, random; record<br/>No Match:   Another random record<br/><br/>['101, John Robinson; good at maths', '102, Ashley Young; good at sports', '103, Zoe Apple; All As']</span></pre><p id="ff4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，我们正确地提取了所需的记录，这突出了regex的灵活性——我们构建了一个通用模式，它可以匹配多个记录。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e9ef" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="262f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在本文中，我回顾了关于在Python中使用字符串的四个关键知识领域。其中，前三个域应该是简单明了的。对于正则表达式，在你熟悉它们之前，确实需要大量的练习。</p></div></div>    
</body>
</html>