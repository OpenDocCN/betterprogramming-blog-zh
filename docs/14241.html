<html>
<head>
<title>Understanding Java Virtual Threads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Java虚拟线程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-java-virtual-threads-3b70d8de37a1?source=collection_archive---------7-----------------------#2022-11-21">https://betterprogramming.pub/understanding-java-virtual-threads-3b70d8de37a1?source=collection_archive---------7-----------------------#2022-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="48d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于它如何解决异步编程问题的讨论</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/26fc5eb52afc765064ef4b88590ea769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-7pWoqFgLYhXckti"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><p id="8f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JDK 19版本中，我们可以找到JDK开发者工作了很长时间的东西的第一个预览，<a class="ae ky" href="https://openjdk.org/projects/loom/" rel="noopener ugc nofollow" target="_blank">项目织机</a>。第一个预览版是JEP 425 的一部分，它允许创建“虚拟线程”因为它仍然是一个预览，当你用Java 19编译你的程序时，你必须<a class="ae ky" href="https://theboreddev.com/how-to-enable-previews-in-java/" rel="noopener ugc nofollow" target="_blank">启用预览</a>。您可以在我们的文章<a class="ae ky" href="https://theboreddev.com/how-to-enable-previews-in-java/" rel="noopener ugc nofollow" target="_blank">“如何在Java中启用预览”中查看如何在Java中启用预览功能</a></p><p id="d2ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，虚拟线程的第二个预览版作为<a class="ae ky" href="https://openjdk.org/jeps/436" rel="noopener ugc nofollow" target="_blank"> JEP 436 </a>的一部分发布。在第一个预览版中引入的一些变化已经被最终确定；我们离获得虚拟线程的完全访问权又近了一步。</p><p id="f55a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将试图为您提供一个坚实的背景，说明为什么JVM生态系统中非常需要Java虚拟线程，并为您提供理解Java虚拟线程的基础知识。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/9219ab3ee00f12558fe0eb71ea498d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*3_PMaA7Vwuanhjuw.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@panyunbo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">潘云波</a>在<a class="ae ky" href="https://unsplash.com/s/photos/platform?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="b9d9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">平台线程的问题</h1><h2 id="408f" class="mo lx it bd ly mp mq dn mc mr ms dp mg li mt mu mi lm mv mw mk lq mx my mm mz bi translated">操作系统线程和平台线程之间的奇偶校验</h2><p id="0332" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">目前，在JDK中，Java线程(也称为“平台”线程)和OS线程之间存在一对一的关系。</p><p id="7575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着当一个线程等待完成一个IO操作时，底层操作系统线程将保持阻塞和未使用状态，直到该操作完成。就Java生态系统的可伸缩性而言，这一直是个大问题，因为可用的线程限制了我们在主机中的应用程序。</p><p id="7fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的十年中，我们试图通过使用异步处理库和使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Futures_and_promises" rel="noopener ugc nofollow" target="_blank">期货</a>来解决这个问题。例如，使用<code class="fe nf ng nh ni b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank">CompletableFuture</a></code>我们可以实现非阻塞的方法，尽管这些模型的可读性在很多情况下不是我们所期望的。如果你有兴趣看一些CompletableFuture的例子，你可以阅读我们的文章<a class="ae ky" href="https://theboreddev.com/parallel-api-calls-with-completablefuture/" rel="noopener ugc nofollow" target="_blank">“使用CompletableFuture的多个API调用</a>”</p><h1 id="0052" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">异步编程的问题是</h1><p id="b86e" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">尽管异步编程是线程限制的可行解决方案，但编写异步代码比顺序代码更复杂。开发人员必须定义回调来基于给定任务的响应应用操作，这使得跟踪和推理代码变得困难。</p><p id="1c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个大问题是调试这些应用程序变得很困难。多线程可以处理给定的请求，因此，调试、记录或分析堆栈跟踪变得很困难。</p><p id="b32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就灵活性和可维护性而言，异步编程也非常有限。我们必须放弃某些顺序工作流结构，如循环。这意味着一段按顺序编写的代码不容易转换成异步代码。相反的情况也会发生同样的情况。</p><p id="2e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，但同样重要的是，由于随之而来的复杂性，编写显式异步代码更容易出错。</p><h1 id="7a3a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">创建线程的成本很高</h1><p id="cb1f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">平台线程的另一个问题是，它们很重，制造成本很高。因此，我们需要预先创建它们，并将它们存储在线程池中，以避免每次我们需要线程来运行代码时都创建新的线程。为什么它们很贵？</p><p id="4a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建Java线程的开销很大，因为它涉及到为线程分配内存、初始化线程堆栈，以及进行操作系统调用来注册操作系统线程。</p><p id="2070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们考虑这两个问题时，操作系统线程的限制和创建平台线程的成本，我们需要有限的线程池来安全地运行我们的应用程序。如果我们不使用有限的线程池，我们就有耗尽资源的风险，这会给我们的系统带来巨大的后果。</p><h1 id="934f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">昂贵的上下文切换</h1><p id="7329" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这种设计的另一个问题是上下文切换有多昂贵。当存在上下文切换时，OS线程从一个平台线程切换到另一个平台线程。操作系统必须保存当前线程的本地数据和内存指针，并为新的平台线程加载这些指针。上下文切换是非常昂贵的操作，因为它涉及许多CPU周期。操作系统暂停一个线程，保存它的堆栈，并分配新的线程。这个过程成本很高，因为它需要加载和卸载线程堆栈。</p><p id="7131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何解决这些问题呢？这就是<a class="ae ky" href="https://openjdk.org/projects/loom/" rel="noopener ugc nofollow" target="_blank"> Project Loom </a>及其虚拟线程发挥作用的地方。让我们看看如何！</p><h1 id="aa6c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">虚拟线程拯救世界</h1><p id="1650" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">Java中的虚拟线程得名于对虚拟内存的类比<a class="ae ky" href="https://www.techtarget.com/searchstorage/definition/virtual-memory#:~:text=Virtual%20memory%20is%20a%20common,(RAM)%20to%20disk%20storage." rel="noopener ugc nofollow" target="_blank">。这是因为我们有一种拥有几乎无限数量的可用线程的错觉(形象地说)，就像虚拟内存一样。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/57f25c700118b1a66648113c924a5074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*B696_klzQpXVXZgt.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@armand_khoury?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿曼德·库利</a>在<a class="ae ky" href="https://unsplash.com/s/photos/illusion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="dabb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟线程解决了JDK中可伸缩性的一个主要问题，但是它是如何解决的呢？答案主要是通过打破平台线程和操作系统线程之间的关联。</p><p id="7a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JVM生态系统中的许多应用程序在达到它们的CPU或内存极限之前就崩溃了，这主要是由于平台线程和OS线程之间的这种奇偶校验。创建平台线程是非常昂贵的。因此，需要使用线程池。我们总是受到主机中可用的处理单元(CPU)数量的限制。</p><p id="3942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，虚拟线程对系统的开销最小。因此，在我们的应用程序中可以有成千上万个。每个虚拟线程都需要一个操作系统线程来完成一些工作，但是在等待资源时，它不会占用操作系统线程。这意味着虚拟线程可以等待IO，释放它们当前正在使用的平台线程，以便另一个虚拟线程可以使用它来做一些工作，并在IO操作完成后继续它们的工作。</p><p id="ba9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的主要好处是什么？答案之一是廉价的上下文切换！我们来看看为什么！</p><h1 id="d773" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">廉价的上下文切换</h1><p id="491a" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">正如我们前面提到的，在Java中，上下文切换是非常昂贵的，因为每次发生时都必须保存和加载线程堆栈。</p><p id="0a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟线程的区别在于，由于它们在JVM的控制下，线程堆栈存储在堆内存中，而不是堆栈中。这意味着为唤醒的虚拟线程分配线程堆栈变得更加便宜。将虚拟线程的数据堆栈加载到“载体”线程堆栈的过程称为挂载。相反的过程称为卸载。</p><p id="30cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们简单地看一下线程调度。</p><h1 id="164f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">行程安排</h1><p id="641b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">操作系统调度传统的平台线程，而JDK运行时调度虚拟线程。</p><p id="0bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在平台线程的情况下，操作系统调度程序负责给每个操作系统线程分配工作。其方法是给每个进程分配<a class="ae ky" href="https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice" rel="noopener ugc nofollow" target="_blank">时间片</a>。当这个时间结束时，轮到另一个进程获得CPU时间来做一些工作。这就是操作系统试图确保在现有进程中公平分配CPU时间的方式。</p><p id="135e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，虚拟线程由JDK运行时直接调度。它的实现方式是在内部使用一个<code class="fe nf ng nh ni b"><a class="ae ky" href="https://theboreddev.com/discover-java-forkjoinpool/" rel="noopener ugc nofollow" target="_blank">ForkJoinPool</a></code>。这是一个用作虚拟线程调度程序的专用池。这意味着由<code class="fe nf ng nh ni b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html#commonPool--" rel="noopener ugc nofollow" target="_blank">ForkJoinPool.commonPool</a></code>返回的公共池是与这个新实例不同的实例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8201a0dd759ad3da3f49a0b56e206e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*lYSZfgBaBzSOj748.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="a6df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JDK调度程序不使用时间片。在这种情况下，虚拟线程在等待阻塞操作响应时会让出并放弃它的承载线程。主要的结果是，我们将有一个更好的资源利用，因此，在我们的应用程序的吞吐量增加。</p><p id="3063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得一提的是，底层平台线程，在调度方面也称为载体线程，仍然由操作系统调度程序管理。它们现在是一个抽象层，对于编写并发代码的开发人员来说完全不可见。</p><p id="7fa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里要考虑的另一个方面是，虚拟线程提供了并行执行工作的错觉。正在发生的是处理单元的时间得到更有效的分配。每个处理单元不会并行工作，只是从一个虚拟线程切换到另一个虚拟线程，频率更高，成本更低。</p><p id="8daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经看到了虚拟线程是如何工作的，现在我们可能会有一个问题。每个应用程序都会从虚拟线程的引入中受益吗？不完全是。让我们看看这是为什么。</p><h1 id="60bd" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">IO绑定的应用程序</h1><p id="9150" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在采用虚拟线程后，并不是每个应用程序都能从巨大的性能提升中受益。只有当我们的应用程序受限于IO时，我们才会看到巨大的好处。</p><p id="1ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是什么意思？IO绑定的应用程序花费大量时间等待IO操作的响应，例如网络调用、文件或数据库访问。这些是现今大多数的应用。</p><p id="730c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在IO绑定的应用程序中，使用虚拟线程的好处是巨大的，因为虚拟线程非常擅长等待，这意味着线程可以在性能方面以非常廉价的方式等待和恢复。</p><p id="b314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，虚拟线程在等待时会阻塞，但平台线程不会。平台线程将被分配给不同的虚拟线程，以继续做有用的工作，而不是等待。这意味着我们的系统将有更好的资源利用率！</p><p id="6380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们将两个平台线程映射到操作系统中的一个对应的OS线程。我们可以看到，平台线程总是忙于做一些工作，而不是等待IO的完成。</p><p id="7088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当一个虚拟线程等待IO时，它就会放弃以释放它的载体线程。一旦IO操作完成，虚拟线程将被放回<a class="ae ky" href="https://theboreddev.com/discover-java-forkjoinpool/" rel="noopener ugc nofollow" target="_blank"> ForkJoinPool </a>的FIFO队列中，并等待一个载体线程可用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/f2683cde2e016bea0fa406d706a51340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qq-OdAxjfm6UvvFB.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="e196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也意味着我们可以大大提高应用程序的吞吐量。虚拟线程通过增加我们可以并发处理的任务数量来实现这一点，而不是通过减少延迟。说清楚一点，虚拟线程并不比平台线程快。他们只是在等待和分配工作的方式上更有效率。</p><p id="fca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于CPU受限的应用程序，我们有其他工具来提高其性能，如并行任务或ForkJoinPool 中的<a class="ae ky" href="https://theboreddev.com/discover-java-forkjoinpool/" rel="noopener ugc nofollow" target="_blank">工作窃取。虚拟线程对性能的影响很小。请记住两者的区别，以免得到意想不到的结果！</a></p><p id="becf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟线程给我们的应用带来了什么好处？有一个很重要的。我们现在可以以同步方式编写非阻塞并发代码。</p><h1 id="e6d8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">非阻塞操作的同步方式</h1><p id="d039" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">随着Java中虚拟线程的引入，编写并发代码得到了极大的简化。我们的代码变得更容易阅读和理解；这是当今异步编程的一个大问题，它的复杂性有时会失控。</p><p id="8190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以编写并发代码，而不用编排可能异步发生的交互。JDK运行时将为我们处理它，在现有的虚拟线程中分配可用的操作系统线程。</p><p id="b78f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用Java中可用的传统并发机制来维护旧的应用程序，会发生什么？</p><h1 id="f623" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">向后兼容性</h1><p id="6ac1" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如果您想知道在迁移到Java 19之后，如果它使用同步块或任何传统的并发机制，您的代码会发生什么，这是一个好消息。旧的并发代码将与虚拟线程一起工作，而根本不需要修改它。在许多情况下，您甚至可能不需要重新编译和构建新的工件，因为JDK运行时会处理所有这些。在其他情况下，充分利用虚拟线程所需的更改很少。</p><p id="2ccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看JDK空气污染指数现在是什么样的！</p><h1 id="8963" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">用虚拟线程编程</h1><p id="b3f5" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">JEP 425 提出的JDK有一些变化。我们将看到，如何编写代码来利用虚拟线程是非常简单的。</p><p id="2636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以像往常一样编写代码。虚拟线程是JDK的一个内置特性。因此，你不需要做太多就可以利用它。</p><p id="59dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个好处是虚拟线程从<code class="fe nf ng nh ni b">Thread</code>类扩展而来。不需要新的线程类对象。</p><p id="dc40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的变化是我们如何定义我们创建的线程是代表虚拟线程还是平台线程。为了实现这一点，JDK引入了一个<code class="fe nf ng nh ni b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.Builder.html" rel="noopener ugc nofollow" target="_blank">Thread.Builder</a></code>来方便地实例化和配置这两者。</p><p id="f563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.Builder.html" rel="noopener ugc nofollow" target="_blank">Thread.Builder</a></code>提供了两种实例化线程的方法。其中一个使用<code class="fe nf ng nh ni b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.Builder.OfPlatform.html" rel="noopener ugc nofollow" target="_blank">Thread.Builder.ofPlatform()</a></code>方法创建了一个传统的平台线程。要实例化一个虚拟线程，我们必须使用<code class="fe nf ng nh ni b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.Builder.OfVirtual.html" rel="noopener ugc nofollow" target="_blank">Thread.Builder.ofVirtual()</a></code>来代替。</p><p id="d221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个变化是包含了一个新的<code class="fe nf ng nh ni b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/ExecutorService.html" rel="noopener ugc nofollow" target="_blank">ExecutorService</a></code>。这个新的执行器服务可以通过运行<code class="fe nf ng nh ni b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()" rel="noopener ugc nofollow" target="_blank">Executors.newVirtualThreadPerTaskExecutor()</a></code>方法来实例化。</p><p id="b4fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过几个例子来看看它是如何工作的！</p><h1 id="fe83" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">executors . newvirtualthreadpertaskmexecutor()</h1><p id="075b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这种新方法可以轻松地从现有的并发代码过渡到虚拟线程。让我们看看下面的例子:</p><pre class="kj kk kl km gt nl ni nm bn nn no bi"><span id="ae6a" class="np lx it ni b be nq nr l ns nt">final LongAdder adder = new LongAdder();<br/>Runnable task = () -&gt; {<br/>    try {<br/>        Thread.sleep(10);<br/>        System.out.println("I'm running in thread " + Thread.currentThread());<br/>        adder.increment();<br/>    } catch (InterruptedException e) {<br/>        Thread.interrupted();<br/>    }<br/>};<br/>long start = System.nanoTime();<br/>try (ExecutorService executorService = Executors.newCachedThreadPool()) {<br/>    IntStream.range(1, 10000)<br/>            .forEach(number -&gt; executorService.submit(task));<br/>}<br/>long end = System.nanoTime();<br/>System.out.println("Completed " + adder.intValue() + " tasks in " + (end - start)/1000000 + "ms");</span></pre><p id="ebf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到上面的示例如何使用缓存的线程池来提交10，000个任务，模拟一个小的IO操作，该操作需要10ms加上打印到控制台和增加计数器的时间。</p><p id="1793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行这段代码，我们会得到以下结果:</p><pre class="kj kk kl km gt nl ni nm bn nn no bi"><span id="67d2" class="np lx it ni b be nq nr l ns nt">...<br/>I'm running in thread Thread[#1271,pool-1-thread-1242,5,main]<br/>I'm running in thread Thread[#1260,pool-1-thread-1231,5,main]<br/>I'm running in thread Thread[#928,pool-1-thread-899,5,main]<br/>I'm running in thread Thread[#275,pool-1-thread-246,5,main]<br/>Completed 9999 tasks in 4740ms</span></pre><p id="7cf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简洁起见，我只包括了最新的元素和最终结果。您可以看到我们如何使用缓存线程池中的平台线程。运行这么简单的东西需要4.7秒。</p><p id="d719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看使用新的虚拟线程执行器会发生什么:</p><pre class="kj kk kl km gt nl ni nm bn nn no bi"><span id="3717" class="np lx it ni b be nq nr l ns nt">long start = System.nanoTime();<br/>try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {<br/>       IntStream.range(1, 10000)<br/>               .forEach(number -&gt; executor.submit(task));<br/>}<br/>long end = System.nanoTime();<br/>System.out.println("Completed " + adder.intValue() + " tasks in " + (end - start)/1000000 + "ms");</span></pre><p id="c235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到，切换到虚拟线程就像切换到新的executor服务一样简单。其余的代码保持不变！太棒了，对吧？</p><p id="866c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用虚拟线程的性能如何？这些是我们得到的结果:</p><pre class="kj kk kl km gt nl ni nm bn nn no bi"><span id="9d9a" class="np lx it ni b be nq nr l ns nt">I'm running in thread VirtualThread[#10029]/runnable@ForkJoinPool-1-worker-10<br/>I'm running in thread VirtualThread[#10031]/runnable@ForkJoinPool-1-worker-10<br/>I'm running in thread VirtualThread[#10027]/runnable@ForkJoinPool-1-worker-10<br/>I'm running in thread VirtualThread[#10028]/runnable@ForkJoinPool-1-worker-10<br/>Completed 9999 tasks in 760ms</span></pre><p id="961a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟线程只用了760ms！这是为什么呢？正如我们前面看到的，当虚拟线程等待IO操作时，平台线程不会被阻塞。因此，在虚拟线程等待时，可以处理其他任务。这对JVM生态系统来说是巨大的！</p><h1 id="c598" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">虚拟的线程()</h1><p id="2378" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">现在让我们看一个类似的例子。在这种情况下，我们将使用<code class="fe nf ng nh ni b">Thread.ofPlatform()</code>和<code class="fe nf ng nh ni b">Thread.ofVirtual()</code>来指定我们将在测试中使用哪种线程。</p><p id="ca60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将首先使用<code class="fe nf ng nh ni b">Thread.ofPlatform()</code>运行一个例子:</p><pre class="kj kk kl km gt nl ni nm bn nn no bi"><span id="6cd1" class="np lx it ni b be nq nr l ns nt">long start = System.nanoTime();<br/>int[] numbers = IntStream.range(1, 10000).toArray();<br/>List&lt;Thread&gt; threads = Arrays.stream(numbers).mapToObj(num -&gt;<br/>        Thread.ofPlatform()<br/>                .start(task)<br/>).toList();<br/>threads.parallelStream().forEach(thread -&gt; {<br/>    try {<br/>        thread.join();<br/>    } catch (InterruptedException e) {<br/>        throw new RuntimeException(e);<br/>    }<br/>});<br/>long end = System.nanoTime();<br/>System.out.println("Completed " + adder.intValue() + " tasks in " + (end - start)/1000000 + "ms");</span></pre><p id="dbcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们启动9，999个线程来运行我们在上一个示例中使用的相同任务。然后，我们使用<code class="fe nf ng nh ni b"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/join.html" rel="noopener ugc nofollow" target="_blank">join()</a></code>等待它们完成。</p><p id="85e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行这个测试，大约需要2-3秒钟来完成。结果如下:</p><pre class="kj kk kl km gt nl ni nm bn nn no bi"><span id="a592" class="np lx it ni b be nq nr l ns nt">I'm running in thread Thread[#10023,Thread-9993,5,main]<br/>I'm running in thread Thread[#10025,Thread-9995,5,main]<br/>I'm running in thread Thread[#10026,Thread-9996,5,main]<br/>I'm running in thread Thread[#10028,Thread-9998,5,main]<br/>Completed 9999 tasks in 2394ms</span></pre><p id="a87f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用相同的例子，但是实例化虚拟线程，会发生什么？</p><pre class="kj kk kl km gt nl ni nm bn nn no bi"><span id="01b3" class="np lx it ni b be nq nr l ns nt">List&lt;Thread&gt; threads = Arrays.stream(numbers).mapToObj(num -&gt;<br/>        Thread.ofVirtual()<br/>                .start(task)<br/>).toList();</span></pre><p id="8bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在前面的例子中观察到的，虚拟线程提供了更好的吞吐量，如下面的结果所示:</p><pre class="kj kk kl km gt nl ni nm bn nn no bi"><span id="fc0c" class="np lx it ni b be nq nr l ns nt">I'm running in thread VirtualThread[#10029]/runnable@ForkJoinPool-1-worker-4<br/>I'm running in thread VirtualThread[#10030]/runnable@ForkJoinPool-1-worker-4<br/>I'm running in thread VirtualThread[#10031]/runnable@ForkJoinPool-1-worker-4<br/>I'm running in thread VirtualThread[#9954]/runnable@ForkJoinPool-1-worker-5<br/>Completed 9999 tasks in 722ms</span></pre><p id="e0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，虚拟线程以相当大的差异击败了平台线程。</p><p id="e04d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，这些计时是不准确的，因为我们没有运行适当的基准。我们没有预热JVM，以便给JIT编译器时间来执行改进，并且我们也在运行单次执行。这向您展示了使用虚拟线程可以提高多少吞吐量！</p><p id="27e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想提一下，虚拟线程也为在Java中引入结构化并发打开了大门。这一改变将使Java代码在不同嵌套层次上运行多个并发任务时更加安全。</p><p id="0f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java将很快引入结构化并发和作用域，作为T2 JEP 429 T3的一部分。这与科特林在他们的<a class="ae ky" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协程</a>中所做的非常相似。</p><h1 id="9fb6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="024a" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在本文中，我们看到了虚拟线程将如何解决Java生态系统中的一个主要问题。由于主机中操作系统线程数量的限制，操作系统线程和平台线程之间的现有奇偶校验对于某些应用来说是一个巨大的限制因素。</p><p id="c7c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长期以来，异步编程一直是我们的救星。然而，我们看到虚拟线程是导致我们认为异步编程死亡的一个重要因素。在下一个JDK版本中提供这一更改后，将采用简单的并发范例。</p><p id="cefb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们今天的全部内容！我们希望您喜欢这篇文章，并对JVM生态系统有所了解。我们认为，在即将到来的变化之后，JVM生态系统以及这个社区的所有开发人员和语言的未来是光明的。</p><p id="6117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>