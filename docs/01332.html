<html>
<head>
<title>Webpack 4 — The Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Webpack 4 —完整指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/webpack-4-the-complete-guide-af1b1e2e3f7a?source=collection_archive---------4-----------------------#2019-09-02">https://betterprogramming.pub/webpack-4-the-complete-guide-af1b1e2e3f7a?source=collection_archive---------4-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6e3e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">该模块捆绑器的详细运行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9bc0a404da0b7b9529fa8d0def498626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDn7kSi7EZ3WlU3kQaAN1w.png"/></div></div></figure><p id="f343" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Webpack是一个模块捆绑器。换句话说，Webpack接受一堆不同的资源或文件(如CSS、JS、SASS、JPG、SVG、PNG……)，并将它们组合成包，每种类型一个单独的包。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lq"><img src="../Images/dc9487d2b5001de49cd34bca99b85f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lg87spoV4rIQR0e82zQuSQ.png"/></div></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4a8c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Webpack安装</h1><p id="edc3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们使用npm在项目目录中创建一个<em class="mv"> package.json </em>文件:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="a610" class="nb lz it mx b gy nc nd l ne nf">npm init</span></pre><p id="d639" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们通过在终端中运行以下命令来安装webpack:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="33d2" class="nb lz it mx b gy nc nd l ne nf">npm install --save-dev webpack webpack-dev-server webpack-cli</span></pre><p id="25ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:<em class="mv"> save-dev </em>将包保存为开发依赖项，- <em class="mv"> save </em>保存应用程序依赖项它将已安装的包写入package.json中的依赖项字段，而<em class="mv"> save-dev </em>则写入devDependencies。</p><p id="a335" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建package.json后，编辑脚本部分以启动webpack。package.json文件将如下所示:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="afea" class="nb lz it mx b gy nc nd l ne nf">{<br/>   "name": "projectName", <br/>   "version": "1.0.0", <br/>   "private": true, <br/>   "description": "", <br/>   "main": "index.js", <br/>   "scripts": {<br/>      "start" : "webpack"<br/>   }, <br/>   "keywords": [], <br/>   "author": "", <br/>   "license": "ISC", <br/>   "devDependencies": {<br/>      "webpack": "^4.2.6", <br/>      "webpack-cli": "^3.2.3"<br/>   }<br/>}</span></pre><p id="e0c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以使用<em class="mv"> npm start来启动我们的应用程序。</em>当应用程序启动时，webpack将在/ <em class="mv"> src </em>目录中搜索<em class="mv"> index.js </em>。确保在<em class="mv"> /src </em>目录中有<em class="mv"> index.js </em>。Webpack将<em class="mv"> index.js </em>及其依赖项捆绑到一个文件中，该捆绑文件将在<em class="mv"> /dist </em>目录下创建为<em class="mv"> main.js </em>。我们需要将我们的<em class="mv"> main.js </em>添加到<em class="mv">index.html。</em></p><p id="8341" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Webpack读取入口点并分析它的依赖项等等。它将入口点及其所有依赖项捆绑到一个文件中。</p><h1 id="0cbf" class="ly lz it bd ma mb ng md me mf nh mh mi jz ni ka mk kc nj kd mm kf nk kg mo mp bi translated">配置Webpack</h1><p id="eb1e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Webpack 4是一个零配置模块捆绑器。它有一组默认值。如果我们想创建一个配置文件，在根目录中添加<em class="mv"> webpack.config.js </em>。</p><h2 id="b21d" class="nb lz it bd ma nl nm dn me nn no dp mi ld np nq mk lh nr ns mm ll nt nu mo nv bi translated">进入</h2><p id="c9c9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Webpack需要一个入口点。我们只是在重新创造我们已经拥有的东西——<em class="mv">/src/index . js</em>对我们来说没有什么新东西。我们明确地告诉webpack在<em class="mv"> /src </em>目录中查找index.js。</p><p id="5254" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> Webpack.config.js </em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="5129" class="nb lz it mx b gy nc nd l ne nf">module.exports = {<br/>   entry: ‘./src/index.js’<br/>};</span></pre><p id="f2aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以有不止一个入口点。我们稍后将讨论这一点。</p><h2 id="495f" class="nb lz it bd ma nl nm dn me nn no dp mi ld np nq mk lh nr ns mm ll nt nu mo nv bi translated">输出</h2><p id="6bc2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在Webpack应该捆绑我们的输出的地方，<em class="mv"> /dist/main.js，</em>是默认路径。我们可以重命名输出文件名，并将“filename”放入输出中。路径决定了代码从哪里分离出来。</p><p id="12ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> Webpack.config.js </em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="af06" class="nb lz it mx b gy nc nd l ne nf"><strong class="mx iu">const</strong> path = require(‘path’);<br/>module.exports = {<br/>   entry: ‘./src/index.js’,<br/>   output: {<br/>      path: path.resolve(__dirname, ‘dist’),<br/>      filename: ‘main.js’<br/>   }<br/>};</span></pre><p id="528d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在编辑<em class="mv"> package.json </em>文件中的脚本部分，如下所示:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="71b5" class="nb lz it mx b gy nc nd l ne nf">“script” : {<br/>   "start" : "webpack --config webpack.config.js"<br/>}</span></pre><h2 id="e573" class="nb lz it bd ma nl nm dn me nn no dp mi ld np nq mk lh nr ns mm ll nt nu mo nv bi translated">方式</h2><p id="5e3e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">模式开发不会缩小输出文件。捆绑的输出文件对于开发来说是可读的。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="26f4" class="nb lz it mx b gy nc nd l ne nf"><strong class="mx iu">const</strong> path = require(‘path’);<br/>module.exports = {<br/>   mode: "development",   <br/>   entry: ‘./src/index.js’,<br/>   output: {<br/>      path: path.resolve(__dirname, ‘dist’),<br/>      filename: ‘main.js’<br/>   }<br/>};</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="35f3" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">装载机</h1><p id="662a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">正如我们已经讨论过的，Webpack不仅捆绑了JavaScript文件，它还捆绑了图像和其他静态文件。加载器是捆绑不同类型文件的关键——你可以在这里看到加载器列表<a class="ae nw" href="https://webpack.js.org/loaders/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="26ac" class="nb lz it bd ma nl nm dn me nn no dp mi ld np nq mk lh nr ns mm ll nt nu mo nv bi translated">CSS加载程序</h2><p id="fcfe" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们可以用模块对象中的一组规则定义一个加载器。现在在我们的项目中创建<em class="mv"> main.css </em>，并使用该命令安装<em class="mv">风格加载器</em>和<em class="mv"> css加载器</em>:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="dc78" class="nb lz it mx b gy nc nd l ne nf">npm install --save-dev style-loader css-loader</span></pre><p id="81bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在更新<em class="mv"> webpack.config.js </em>如下:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="66a7" class="nb lz it mx b gy nc nd l ne nf"><strong class="mx iu">const</strong> path = require(‘path’);<br/>module.exports = {<br/>   mode: "development",   <br/>   entry: ‘./src/index.js’,<br/>   output: {<br/>      path: path.resolve(__dirname, ‘dist’),<br/>      filename: ‘main.js’<br/>   },<br/>   module:{<br/>      rules:[<br/>         {<br/>            test: /\.css$/, <br/>            use: ["style-loader", "css-loader"]}]<br/>   }<br/>};</span></pre><p id="b369" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Webpack从相反方向读取加载程序。它首先执行<em class="mv"> css-loader </em>，然后执行<em class="mv"> style-loader </em>，其中<em class="mv"> css-loader </em>将css文件转换成普通的JavaScript代码，而<em class="mv"> style-loader </em>将样式注入DOM。</p><p id="5637" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于sass，我们需要使用一个<em class="mv"> sass-loader </em>，这个<em class="mv"> sass-loader </em>需要<em class="mv"> node-sass </em>。使用以下命令安装一个<em class="mv"> sass-loader </em>。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="f9cd" class="nb lz it mx b gy nc nd l ne nf">npm install sass-loader node-sass webpack --sav-dev</span></pre><p id="67dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在用<em class="mv"> sass-loader </em>更新<em class="mv"> webpack.config.js </em>文件。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="91eb" class="nb lz it mx b gy nc nd l ne nf"><strong class="mx iu">const</strong> path = require(‘path’);<br/>module.exports = {<br/>   mode: "development",   <br/>   entry: ‘./src/index.js’,<br/>   output: {<br/>      path: path.resolve(__dirname, ‘dist’),<br/>      filename: ‘main.js’<br/>   },<br/>   module:{<br/>      rules:[<br/>         {<br/>            test: /\.css$/, <br/>            use: [<br/>               "style-loader", // Injects style into DOM<br/>               "css-loader",   // Turns CSS into JS<br/>               "sass-loader"   // Turns SCSS into CSS<br/>            ]<br/>         }<br/>      ]<br/>   }<br/>};</span></pre><p id="100f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要忘记将我们的<em class="mv">main.css/main.scss</em>导入到<em class="mv">index.html</em>中，并且<em class="mv">main.css/main.scss</em>中定义的样式将注入到Html DOM中。现在我们需要在独立的CSS中创建它。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="db06" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">缓存破坏和插件</h1><p id="b0bd" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">浏览器可以缓存我们的代码，这样每次你做了更改，用户就不能重新下载文件了。在我们的例子中，当代码发生变化时，<em class="mv"> main.js </em>将会下载。我们可以使用一个特殊的散列函数将文件名改为<em class="mv">main . blabla . js</em></p><p id="ae3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一次我们在代码中不做任何更改的情况下构建时，文件名保持不变:main.balbalabla.js。但是，如果代码中有一个字符发生变化，文件名就会变成main.vnas28r9ysd.js，浏览器必须再次下载它。</p><p id="e639" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们在项目中添加供应商代码时，这非常有用。我们不需要每次都下载供应商代码，因为我们并不总是对供应商文件进行任何更改，并且该文件可以缓存在浏览器中。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="ce0b" class="nb lz it mx b gy nc nd l ne nf">output : { <br/>   filename : "main.[contentHash].js"<br/>}</span></pre><p id="a2c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在的问题是如何将这个文件链接到<em class="mv">index.html</em>中。我们不能预测动态生成的文件名，因为webpack会这样做。Webpack使用插件在Html的底部创建脚本标签。</p><h1 id="182b" class="ly lz it bd ma mb ng md me mf nh mh mi jz ni ka mk kc nj kd mm kf nk kg mo mp bi translated">插件</h1><p id="0561" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">插件选项用于以多种方式定制webpack构建过程。这里可以看到插件列表<a class="ae nw" href="https://webpack.js.org/plugins/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="2e4e" class="nb lz it bd ma nl nm dn me nn no dp mi ld np nq mk lh nr ns mm ll nt nu mo nv bi translated">Html webpack插件</h2><p id="b27a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">HtmlWebpackPlugin简化了HTML文件的创建，以服务于您的webpack包。这对于在文件名中包含散列的webpack包尤其有用，散列会改变每次编译。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="c530" class="nb lz it mx b gy nc nd l ne nf">npm install --save-dev html-webpack-plugin</span></pre><p id="bd69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> webpack.config.js </em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="9ffd" class="nb lz it mx b gy nc nd l ne nf"><strong class="mx iu">const</strong> path = require(‘path’);<br/>module.exports = {<br/>   mode: "development",   <br/>   entry: ‘./src/index.js’,<br/>   output: {<br/>      path: path.resolve(__dirname, ‘dist’),<br/>      filename: ‘main.js’<br/>   },<br/>   plugins: [ <br/>      new HtmlWebpackPlugin()<br/>   ]<br/>};</span></pre><p id="1272" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这为我们创建了一个<em class="mv">index.html</em>文件，并把它放到dist目录中，动态生成的JS文件包含在Html的底部。</p><p id="b982" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv">index.html</em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="6c0c" class="nb lz it mx b gy nc nd l ne nf"><em class="mv">&lt;!DOCTYPE html&gt;<br/></em><strong class="mx iu">&lt;html&gt;<br/>&lt;head&gt; <br/>   &lt;meta </strong>charset=”UTF-8"<strong class="mx iu">&gt;<br/>   &lt;title&gt;</strong>Webpack App<strong class="mx iu">&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>   </strong>&lt;script type=”text/javascript” src=”main.170skb99wrjcb.js”&gt;&lt;/script&gt;<br/><strong class="mx iu">&lt;/body&gt;<br/>&lt;/html&gt;</strong></span></pre><p id="9005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个新生成的Html文件没有我们的Html代码。为此，我们需要提供我们的模板。webpack配置文件如下所示:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="f9f9" class="nb lz it mx b gy nc nd l ne nf"><strong class="mx iu">const</strong> path = require(‘path’);<br/>module.exports = {<br/>   mode: "development",   <br/>   entry: ‘./src/index.js’,<br/>   output: {<br/>      path: path.resolve(__dirname, ‘dist’),<br/>      filename: ‘main.js’<br/>   },<br/>   plugins: [ <br/>      new HtmlWebpackPlugin({ <br/>         template: './src/index.html'<br/>      })<br/>   ]<br/>};</span></pre><p id="9287" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用一个css加载器将我们的css注入到DOM中，实际上，我们需要独立的css。为此，请使用mini-css-extract-plugin:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="b1db" class="nb lz it mx b gy nc nd l ne nf">npm install mini-css-extract-plugin</span></pre><p id="d212" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个插件将css提取到一个单独的文件中。</p><p id="7281" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> webpack.config.js </em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="bb98" class="nb lz it mx b gy nc nd l ne nf"><strong class="mx iu">const</strong> path = require(‘path’);<br/>module.exports = {<br/>   mode: "development",   <br/>   entry: ‘./src/index.js’,<br/>   output: {<br/>      path: path.resolve(__dirname, ‘dist’),<br/>      filename: ‘main.js’<br/>   },<br/>   module:{<br/>      rules:[<br/>         {<br/>            test: /\.css$/, <br/>            use: [ <br/>               MiniCssExtractPlugin.loader,<br/>               "style-loader", // Injects style into DOM<br/>               "css-loader",   // Turns CSS into JS<br/>               "sass-loader"   // Turns SCSS into CSS<br/>            ]<br/>         }<br/>      ]<br/>   },<br/>   plugins: [ <br/>      new HtmlWebpackPlugin({ <br/>         template: './src/index.html'<br/>      }), <br/>      new MiniCssExtractPlugin()<br/>   ]<br/>};</span></pre><p id="d939" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">新生成的css文件会自动注入到Html中— <code class="fe nx ny nz mx b">HtmlWebpackPlugin</code>会处理的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="80fc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">分离代码开发和生产模式</h1><p id="4f3b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这个模式是webpack 4引入的一个参数。我们将把webpack配置分为开发模式和生产模式。同时他们也分享了很多常用的东西。因此，我们有三个配置文件:用于共享开发和生产模式的公共文件，第二个用于开发模式，最后一个用于生产模式。</p><p id="2184" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不会为dev模式构建dist目录——web pack-dev-server将帮助我们从内存中加载文件。我们只需要缩小生产模式代码的最终版本。</p><p id="e5b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再创建两个文件:<em class="mv"> webpack.dev.js </em>和<em class="mv"> webpack.prod.js. </em>将<em class="mv"> webpack.config.js </em>重命名为<em class="mv"> webpack.common.js </em>。这些名称由您决定—使用您想要的任何名称。</p><p id="1930" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们安装所需的npm软件包:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="9b40" class="nb lz it mx b gy nc nd l ne nf">npm install --save-dev webpack-dev-server</span></pre><p id="cd43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Webpack-dev-server提供实时重载。它还提供了对webpack资产的快速内存访问。这应该用于开发模式。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="ad8b" class="nb lz it mx b gy nc nd l ne nf">npm install --save-dev webpack-merge</span></pre><p id="90fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Webpack-merge提供了一个合并函数，它连接数组并合并对象，从而创建一个新的对象。它再次返回函数中的包装值。</p><p id="73c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们将开发和生产模式的代码分开。对于常见的配置，我们不需要模式参数和输出。我们也不想为开发模式添加内容哈希。这三个文件的最终版本将如下所示:</p><p id="ba06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> webpack.common.js </em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="c040" class="nb lz it mx b gy nc nd l ne nf">const path = require(“path”);<br/>var HtmlWebpackPlugin = require(“html-webpack-plugin”); module.exports = { <br/>   entry: “./src/index.js”, <br/>   plugins: [ <br/>      new HtmlWebpackPlugin({ <br/>         template: “./src/template.html” <br/>      }) <br/>   ], <br/>   module: { <br/>      rules: [ <br/>         { <br/>            test: /<strong class="mx iu">\.</strong>scss$/, <br/>            use: [ <br/>               “style-loader”, // Inject styles into DOM <br/>               “css-loader”,   // Turns css into commonjs <br/>               “sass-loader”   // Turns sass into css <br/>            ] <br/>         } <br/>      ] <br/>   }<br/>};</span></pre><p id="aba3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> webpack.dev.js </em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="11e8" class="nb lz it mx b gy nc nd l ne nf">const path = require(“path”);<br/>const common = require(“./webpack.common”);<br/>const merge = require(“webpack-merge”);</span><span id="50d9" class="nb lz it mx b gy oa nd l ne nf">module.exports = merge(common, { <br/>   mode: “development”, <br/>   output: { <br/>      filename: “main.js”, <br/>      path: path.resolve(__dirname, “dist”) <br/>   }<br/>});</span></pre><p id="d445" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> webpack.prod.js </em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="bf03" class="nb lz it mx b gy nc nd l ne nf">const path = require(“path”);<br/>const common = require(“./webpack.common”);<br/>const merge = require(“webpack-merge”);</span><span id="60ce" class="nb lz it mx b gy oa nd l ne nf">module.exports = merge(common, { <br/>   mode: “production”, <br/>   output: { <br/>      filename: “main.[contentHash].js”, <br/>      path: path.resolve(__dirname, “dist”) <br/>   }<br/>});</span></pre><p id="f98b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们必须配置webpack-dev-server。我们还需要在我们的<em class="mv"> package.json </em>上添加开发模式和生产模式。像这样编辑<em class="mv"> package.json </em>中的脚本部分:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="0cdd" class="nb lz it mx b gy nc nd l ne nf">“script” : {<br/>   "start": "webpack-dev-server --config webpack.dev.js --open",<br/>   "build": "webpack --config webpack.prod.js"<br/>}</span></pre><p id="09bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe nx ny nz mx b">npm start</code>作为开发模式，使用<code class="fe nx ny nz mx b">npm run</code>作为生产模式。现在，您可以在构建目录中看到捆绑的生产模式的缩小文件。开发模式的内存更改。<em class="mv">-打开</em>准备好后会自动打开浏览器窗口。</p><p id="aae1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哎呀，我们需要锯多个入口点！别担心，设置起来并不困难——我们有bootstrap之类的供应商脚本。我们需要为<em class="mv"> main.js </em>和<em class="mv"> vendor.js </em>准备两个独立的包。那么webpack.common.js中的入口点将如下所示:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="10db" class="nb lz it mx b gy nc nd l ne nf">module.exports = { <br/>   entry: {<br/>      main: “./src/index.js”, <br/>      vendor: "./src/vendor.js"<br/>   }<br/>}</span></pre><p id="ff12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还必须对输出进行更改，以生成两个不同的包:用于开发和生产模式的配置文件。</p><p id="e5a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> webpack.dev.js </em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="f380" class="nb lz it mx b gy nc nd l ne nf">module.exports = merge(common, { <br/>   mode: “development”, <br/>   output: { <br/>      filename: “[name].bundle.js”, <br/>      path: path.resolve(__dirname, “dist”) <br/>   }<br/>});</span></pre><p id="c6ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv"> webpack.prod.js </em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="3a3e" class="nb lz it mx b gy nc nd l ne nf">module.exports = merge(common, { <br/>   mode: “production”, <br/>   output: { <br/>      filename: “[name].[contentHash].js”, <br/>      path: path.resolve(__dirname, “dist”) <br/>   }<br/>});</span></pre><p id="9424" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这会在开发和生产模式下生成两个不同的包。您可以在开发模式下看到包main.bundle.js和vendor.bundle.js。在生产模式下main.275hsossba83k.js和vendor.934jsdpaczl83.js</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="537f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="c948" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们还在项目中使用图像和其他类型的资产。为此，我们需要将所需的包添加到webpack中，否则您将在webpack中看到错误“您可能需要一个合适的加载程序来处理此文件类型”。</p></div></div>    
</body>
</html>