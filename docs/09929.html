<html>
<head>
<title>ES2022: A Complete Guide on Private Class Fields, Methods, and Static Initialization Blocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2022:关于私有类字段、方法和静态初始化块的完整指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/es2022-a-complete-guide-on-private-static-class-fields-methods-and-static-initialization-blocks-f12943a86b2d?source=collection_archive---------2-----------------------#2021-11-02">https://betterprogramming.pub/es2022-a-complete-guide-on-private-static-class-fields-methods-and-static-initialization-blocks-f12943a86b2d?source=collection_archive---------2-----------------------#2021-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7f9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">新ECMAScript语法介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2787463a3561f6e251b0f6f7a3600f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mR-5_aH5wQ_-NXUv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">真诚媒体</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="83f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">技术委员会39 ( <a class="ae ky" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank"> TC39 </a>)是一个致力于ECMAScript标准化的JavaScript专家小组。完成的提案是已经达到阶段4的提案，并且包括在规范的<a class="ae ky" href="https://tc39.es/ecma262/" rel="noopener ugc nofollow" target="_blank">最新草案</a>中。</p><p id="ea63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看ES2022对JavaScript类的更改，其中包括以下新语法:</p><ul class=""><li id="b731" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">私有类字段和方法</li><li id="113c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">静态公共字段(静态公共方法在ES2015中)</li><li id="0a37" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">静态私有字段和方法</li><li id="ae93" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">静态初始化块</li><li id="7672" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">针对私人领域的人体工程学品牌检查</li></ul><h1 id="ec4d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">班级</h1><p id="3a14" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">类</a>是创建对象的模板。它们封装数据以及处理这些数据的方法。ES2015中正式引入了JavaScript类。它们建立在原型的基础上，但是也有一些语法和语义与ES5类语义不同。</p><p id="900c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类可以通过类声明或类表达式来定义。</p><ul class=""><li id="6497" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">类声明使用关键字<code class="fe ng nh ni nj b">class</code>和类名定义了一个类。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ul class=""><li id="9752" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">类表达式用表达式定义类，表达式可以是命名的或未命名的类。</li></ul><p id="b751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个未命名的类示例，变量名变成了类名(第5行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个命名类的例子。类名覆盖变量名成为类名(第5行)。然而，类名不能用来实例化一个实例(第14行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类成员位于花括号<code class="fe ng nh ni nj b">{}</code>内。类成员包括字段和方法。在没有任何<code class="fe ng nh ni nj b">static</code>修饰符的情况下，它们与对象/实例相关联，被称为实例字段和实例方法。它们在一个类中被<code class="fe ng nh ni nj b">this</code>引用。“Class”构造函数是实例化对象的特殊方法。默认情况下，所有字段和方法都是公共的。</p><p id="cd7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个类定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c9d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第2行声明了一个字段<code class="fe ng nh ni nj b">_count</code>，并将其初始化为0。</p><p id="b7b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第5行将参数值分配给字段<code class="fe ng nh ni nj b">_name</code>。</p><p id="d8e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用下划线(<code class="fe ng nh ni nj b">_</code>)来区分带有get/set方法的字段名称。ES2015中引入了Getters和setters。如果我们对一个字段和get/set方法使用相同的名称，getter/setter将递归调用自己，并抛出一个<code class="fe ng nh ni nj b">RangeError: Maximum call stack size exceeded</code>。</p><p id="616b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，<code class="fe ng nh ni nj b">girl</code>是从类<code class="fe ng nh ni nj b">Person</code>创建的实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ab68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1行创建了实例<code class="fe ng nh ni nj b">girl</code>。</p><p id="22a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第2行直接访问实例字段，并打印出值<code class="fe ng nh ni nj b">Alice</code>。</p><p id="7dac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第3行调用get方法，打印出转换后的值<code class="fe ng nh ni nj b">ALICE</code>。</p><p id="bca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第4行打印出实例细节。</p><p id="f9bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用下面的代码使用<code class="fe ng nh ni nj b">in</code>操作符来检查字段或方法是否存在:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，实例<code class="fe ng nh ni nj b">girl</code>可以调用<code class="fe ng nh ni nj b">greet</code>方法来打印消息并增加计数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="375e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">私有字段和方法</h1><p id="d3f8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">默认情况下，所有字段和方法都是公共的。ES2022添加了确保封装的私有作用域。私有范围内的字段和方法不能从类外部访问——除非有一些显式的方法来公开它们。</p><p id="5141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在声明字段和访问字段时，私有字段都用一个散列(<code class="fe ng nh ni nj b">#</code>)前缀定义。私有字段只能作为字段声明提前声明。如果没有初始化器，字段被设置为<code class="fe ng nh ni nj b">undefined</code>。类似地，方法可以通过在名字前加前缀<code class="fe ng nh ni nj b">#</code>来私有化。</p><p id="c6c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于前面的例子，我们将<code class="fe ng nh ni nj b">_count</code>和<code class="fe ng nh ni nj b">_name</code>重命名为<code class="fe ng nh ni nj b">#_count</code>和<code class="fe ng nh ni nj b">#_name</code>，使它们成为私有的。同样，<code class="fe ng nh ni nj b">#increaseCount</code>成为私有方法。我们必须为私有字段添加一个声明，这对于公共字段不是必须的(第5行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，实例<code class="fe ng nh ni nj b">girl</code>只能访问公共getter(第4行)，而不能访问私有字段<code class="fe ng nh ni nj b">#_name</code>(第3行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e6ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，<code class="fe ng nh ni nj b">in</code>操作符将为私有字段和方法返回false，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="052e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，<code class="fe ng nh ni nj b">girl</code>实例可以调用公共<code class="fe ng nh ni nj b">greet</code>方法并访问公共getter，但是不能访问<code class="fe ng nh ni nj b">#_count</code>(第5行)和<code class="fe ng nh ni nj b">#increaseCount</code>(第8行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="cc18" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">私有字段和方法没有继承</h1><p id="6575" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">JavaScript没有受保护的范围。私有字段和方法只能从类声明内部访问。它们对子类不可见。</p><p id="f6d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，<code class="fe ng nh ni nj b">Girl</code>是<code class="fe ng nh ni nj b">Person</code>的子类。一个类定义不能访问它的超类的私有方法(第9行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6c9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的规则也适用于子类实例。实例<code class="fe ng nh ni nj b">girl</code>可以访问其超类的公共字段和方法，但不能访问私有字段和方法(第19和22行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="6e32" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">静态公共字段和方法</h1><p id="d87f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在ES2015中，引入了静态公共方法。ES2022增加了剩余的静态字段和方法:</p><ul class=""><li id="7557" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">静态公共字段</li><li id="3037" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">静态私有字段</li><li id="ad4e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">静态私有方法</li></ul><p id="22d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态字段和方法不用于类的实例。相反，它们是在类本身上调用的。</p><p id="50ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态字段通常用于缓存、固定配置或任何其他不需要跨实例复制的数据。静态方法通常是特殊功能的实用函数。</p><p id="c6f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的类<code class="fe ng nh ni nj b">Circle</code>混合了静态和实例字段/方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态字段和方法可以从类本身访问:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9ed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实例不能访问静态字段和方法，您将在下面看到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态字段只被静态方法调用，比如<code class="fe ng nh ni nj b">pi</code>和<code class="fe ng nh ni nj b">doublePi</code>。</p><p id="dc2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把<code class="fe ng nh ni nj b">message</code>改成<code class="fe ng nh ni nj b">static</code>字段呢？<code class="fe ng nh ni nj b">circle.getMessage()</code>的值会是多少？</p><p id="7c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">会是<code class="fe ng nh ni nj b">undefined</code>。</p><p id="b008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过用类名而不是<code class="fe ng nh ni nj b">this</code>引用它来解决。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f6eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe ng nh ni nj b">Circle</code>创建一个子类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9aa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有静态字段和方法都继承自超类，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实例行为几乎一样，除了<code class="fe ng nh ni nj b">circle</code>的原型是<code class="fe ng nh ni nj b">Circle</code>(第13行)，构造器是<code class="fe ng nh ni nj b">CircleExtended</code>(第14行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="abbb" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">静态私有字段和方法</h1><p id="f021" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">ES2022增加了实例字段和方法以及静态字段和方法的私有范围。私有静态字段和方法也用一个hash ( <code class="fe ng nh ni nj b">#</code>)前缀定义。</p><p id="01e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于前面的例子，我们通过将<code class="fe ng nh ni nj b">pi</code>和<code class="fe ng nh ni nj b">doublePi</code>重命名为<code class="fe ng nh ni nj b">#pi</code>和<code class="fe ng nh ni nj b">#doublePi</code>来使它们成为私有的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用类的静态方法和实例方法，它似乎工作得很好，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4177" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe ng nh ni nj b">Circle</code>创建一个子类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们不能调用<code class="fe ng nh ni nj b">CircleExtended.area</code>(第2行)和<code class="fe ng nh ni nj b">CircleExtended.perimeter</code>(第4行)，尽管这两个方法在超类中有公共作用域。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道只有定义私有静态字段的类才能访问该字段。在<code class="fe ng nh ni nj b">CircleExtended.area</code>和<code class="fe ng nh ni nj b">CircleExtended.perimeter</code>中，<code class="fe ng nh ni nj b">this</code>是指不能访问私有成员<code class="fe ng nh ni nj b">#pi</code>和<code class="fe ng nh ni nj b">#doublePi</code>的子类。为了让它们工作，我们需要修改超类，用类名而不是<code class="fe ng nh ni nj b">this</code>来引用静态私有字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="07b5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">静态初始化块</h1><p id="cc73" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">静态初始化块支持比静态字段初始化更灵活的<code class="fe ng nh ni nj b">static</code>属性初始化。每个类可以有多个静态初始化块。它们和任何交错的静态字段初始值设定项一起按照声明的顺序进行计算。超类的任何静态初始化都是在子类之前首先执行的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="218f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行代码后，我们看到这些消息按顺序打印出来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="52c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态块允许我们处理不同的类初始化用例。在下面的例子中，类D的静态块可以使用<code class="fe ng nh ni nj b">this</code>引用访问它自己的静态字段(第15行)，使用<code class="fe ng nh ni nj b">super</code>引用访问它的超类字段(第14行)。它还可以包括try/catch块(第16–20行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="dbad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的示例中，它演示了如何从类外部访问私有字段。<code class="fe ng nh ni nj b">peekMySecret</code>是一个随机变量，通过一个静态块被授权访问一个静态私有字段。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="37d3" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">针对私人领域的人体工程学品牌检查</h1><p id="31a6" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们已经展示了如何使用<code class="fe ng nh ni nj b">in</code>操作符来检查实例中是否有特定的公共字段或方法。在ES2022中，检查已经扩展到私有字段和方法，这被称为私有字段的人体工程学品牌检查。</p><p id="4516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个<a class="ae ky" href="https://github.com/tc39/proposal-private-fields-in-in" rel="noopener ugc nofollow" target="_blank">官方示例</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="de1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该能够调用<code class="fe ng nh ni nj b">C.isC</code>来检查<code class="fe ng nh ni nj b">c</code>是否是一个实例。但是，浏览器还不支持该功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="4b58" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="0a3f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">编程语言随着时间的推移而发展，要跟上它们是一个挑战。与此同时，看到它们变得更简洁、更强大也很有趣。</p><p id="e388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们回顾了ES2022对JavaScript类在私有/静态类字段/方法、静态初始化块和私有字段的人体工程学品牌检查方面的更改。</p><p id="6f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>