<html>
<head>
<title>How to Build a Fault Tolerant Redis Network With Spring Boot and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Spring Boot和多克构建容错Redis网络</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-fault-tolerant-redis-network-with-spring-boot-and-docker-17e16ad898ed?source=collection_archive---------4-----------------------#2020-06-10">https://betterprogramming.pub/how-to-build-a-fault-tolerant-redis-network-with-spring-boot-and-docker-17e16ad898ed?source=collection_archive---------4-----------------------#2020-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1dba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">具有复制和故障转移功能的集群</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/123c59ee6c172a5679b6d0ea7b624a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5uKbeF6UNpZOphpM.jpg"/></div></div></figure><p id="d122" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">编者按:这篇文章经过编辑，使用了一个更有思想的机器之间的主要/次要关系，而不是以前的、文化上不敏感的术语。根据您在当地使用的术语，您可能需要更新我们在这里称为主/次的术语，以匹配您的系统。谢谢！</em></p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="4ed3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在分布式系统中，实现容错是成功的关键标准之一。</p><p id="41f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一下在Redis网络中使用Redis集群和sentinels实现容错和复制。</p><p id="5ea3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我将介绍:</p><ul class=""><li id="d82b" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated"><a class="ae me" href="#83e7" rel="noopener ugc nofollow">Redis简介</a></li><li id="1f93" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated">使用Docker创建带有Redis缓存的spring boot应用程序</li><li id="85cb" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated">构建容错Redis网络的不同方法</li><li id="5501" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated"><em class="ln">用redis集群分片</em></li><li id="a5ed" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated"><em class="ln">使用redis集群进行复制</em></li><li id="9bb2" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated"><em class="ln">带sentinel(无分片)的Redis主从网络</em></li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="83e7" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">Redis简介</h1><blockquote class="nc nd ne"><p id="932a" class="kr ks ln kt b ku kv jr kw kx ky ju kz nf lb lc ld ng lf lg lh nh lj lk ll lm ij bi translated">Redis是一个开源的(BSD许可的)、内存中的数据结构存储，用作数据库、缓存和消息代理。</p><p id="1b27" class="kr ks ln kt b ku kv jr kw kx ky ju kz nf lb lc ld ng lf lg lh nh lj lk ll lm ij bi translated">Redis具有内置的复制、LRU驱逐、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster的自动分区提供高可用性。</p><p id="1607" class="kr ks ln kt b ku kv jr kw kx ky ju kz nf lb lc ld ng lf lg lh nh lj lk ll lm ij bi translated">为了实现其出色的性能，Redis工作在内存中。</p></blockquote><p id="ef83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">—<a class="ae me" href="https://redis.io/topics/introduction#:~:text=In%20order%20to%20achieve%20its,each%20command%20to%20a%20log." rel="noopener ugc nofollow" target="_blank">Redis简介</a></p><h2 id="fcfd" class="ni ml iq bd mm nj nk dn mq nl nm dp mu la nn no mw le np nq my li nr ns na nt bi translated">在我们深入研究编码之前，需要注意一些关键的Redis特性</h2><ul class=""><li id="ca65" class="lv lw iq kt b ku nu kx nv la nw le nx li ny lm ma mb mc md bi translated"><strong class="kt ir">最大内存:</strong>默认情况下，Redis在64位系统上没有内存限制，在32位系统上有3 GB内存限制。大内存可以包含更多的数据，并提高命中率，这是最重要的指标之一，但在内存的某个限制下，命中率将处于相同的水平。</li><li id="3974" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated"><strong class="kt ir">驱逐算法:</strong>当缓存大小达到内存限制时，旧数据将被删除，以便为新数据腾出空间。Redis提供<code class="fe nz oa ob oc b">Last Recently Used</code>和<code class="fe nz oa ob oc b">Least Frequently Used</code>驱逐算法。RDB时间点快照在特定的时间间隔或写入次数后，AOF会为每个写入操作创建持久性日志。</li><li id="10e5" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated"><strong class="kt ir">持久性:</strong>出于各种原因，您可能想要持久化您的缓存。启动后，缓存最初是空的，在停机后恢复的情况下，用快照数据填充它将是有用的。Redis支持不同的方式来实现持久性。</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="eb26" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">开发Spring Boot + Redis + Docker应用程序</h1><p id="251b" class="pw-post-body-paragraph kr ks iq kt b ku nu jr kw kx nv ju kz la od lc ld le oe lg lh li of lk ll lm ij bi translated">在本文的最后，我将针对这个演示对Github repo进行一些更新。如果您想在本文的不同地方查看代码，请查看发布版。</p><div class="og oh gp gr oi oj"><a href="https://github.com/avinash10584/spring-boot-redis-cluster.git" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">avinash 10584/spring-boot-redis-cluster</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">spring-boot-redis-cluster。在…上创建一个帐户，为avinash 10584/spring-boot-redis-cluster开发做出贡献</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox kp oj"/></div></div></a></div><p id="0672" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们建立我们的Redis应用程序！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="c377" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">步骤1:创建一个简单的Spring Boot待办事项应用程序</h1><p id="78c3" class="pw-post-body-paragraph kr ks iq kt b ku nu jr kw kx nv ju kz la od lc ld le oe lg lh li of lk ll lm ij bi translated">首先，让我们创建一个简单的待办事项应用程序。我们不会为多个用户创建它，只是为了保持简单。</p><p id="b4e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，我们只是在应用程序中存储一个简单的待办事项列表作为缓存。我们还没有使用数据库。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="c95e" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">步骤2:下载并启动Redis Docker映像</h1><p id="b077" class="pw-post-body-paragraph kr ks iq kt b ku nu jr kw kx nv ju kz la od lc ld le oe lg lh li of lk ll lm ij bi translated">从Docker hub下载官方Redis图像:</p><p id="40f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">docker pull redis</code></p><p id="d406" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个命令之后，新的映像应该出现在您的本地存储库中(键入Docker images进行检查)。</p><p id="ad55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GitHub中的项目被配置为使用独立模式和集群模式。</p><p id="9b23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们在独立模式下使用Redis。我们从Dockerhub中提取的Redis图像开始:</p><p id="86f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">docker run --rm -p 4025:6379 -d --name redis-1 redis redis-server</code></p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="3309" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">步骤3:将Redis集成到Spring Boot应用程序中</h1><p id="ee84" class="pw-post-body-paragraph kr ks iq kt b ku nu jr kw kx nv ju kz la od lc ld le oe lg lh li of lk ll lm ij bi translated">我们将使用spring boot cache与Redis对话。Spring附带了几个注释，您可以添加这些注释来帮助它使用Redis缓存。</p><p id="49b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe nz oa ob oc b">@EnableCaching</code>添加到您的应用程序配置中，以启用这些注释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ab58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们构建我们的Docker应用程序，以确保spring boot应用程序可以与Redis对话。该项目的docker文件位于github repo中。我将重点放在Redis上，所以我将避免spring boot应用程序的docker文件的细节。</p><p id="4aeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想了解项目中使用的Docker文件的更多信息，并了解如何避免Docker构建时间和使用缓存，那么请看这篇文章:</p><div class="og oh gp gr oi oj"><a href="https://medium.com/codingfullstack/5-essential-docker-tips-for-your-spring-boot-images-8f570270d9ba" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">Spring Boot形象的5个重要提示🐳</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">跟上最新和最佳实践，构建spring boot docker映像。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">medium.com</p></div></div><div class="os l"><div class="pa l ou ov ow os ox kp oj"/></div></div></a></div><p id="3204" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">DOCKER_BUILDKIT=1 docker build -t learnings/spring-boot-redis-cluster .</code></p><p id="803e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦构建了我们的映像，下一步就是运行该映像:</p><p id="d177" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">docker run --rm -p 4024:4024 --name spring-boot-redis learnings/spring-boot-redis-cluster</code></p><p id="87bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您运行应用程序并访问<code class="fe nz oa ob oc b">http://localhost:4024/app/</code>，您将得到错误<code class="fe nz oa ob oc b">.ConnectTimeoutException: connection timed out</code>。</p><p id="feae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是因为我们希望我们的两个Docker映像能够相互对话——默认情况下，它们位于自己的网络上，并且相互隔离。</p><p id="7610" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此时我们有两个选择:</p><ul class=""><li id="914b" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated"><strong class="kt ir">使用Docker网络</strong></li></ul><p id="39c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者，</p><ul class=""><li id="ca09" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated"><strong class="kt ir">创建一个构建默认网络的docker-compose</strong></li></ul><p id="de07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将为这个演示创建docker网络，我正在创建一个Docker网络，但如果你想在项目中添加docker-compose文件，请在评论中告诉我。</p><p id="dd95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">docker network create spring-redis-network</code></p><p id="cf25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们将Redis和spring boot映像连接到这个网络:</p><p id="adbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">docker network connect spring-redis-network redis-1</code></p><p id="a41e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以寻找Redis实例的IP地址，并在<code class="fe nz oa ob oc b">application.yml</code>中进行更新。</p><p id="6470" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">如果您使用</em> <code class="fe nz oa ob oc b"><em class="ln">docker-compose </em></code> <em class="ln">可以避免这种查找，因为它可以绑定服务，而无需给出IP地址的细节:</em></p><p id="e745" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">docker inspect spring-redis-network</code></p><p id="7ce3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的IP地址是<code class="fe nz oa ob oc b">172.18.0.2</code></p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="87ef" class="ni ml iq oc b gy pf pg l ph pi">"Name": "redis-1", <br/>"EndpointID": "88b100f3569bb4ed68ac8cbf84f4b5a20493e11c5e7336a052bbbd25bb5f4205", "MacAddress": "02:42:ac:12:00:02", <br/>"IPv4Address": "<strong class="oc ir">172.18.0.2</strong>/16", <br/>"IPv6Address": ""</span></pre><p id="cec3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以在<code class="fe nz oa ob oc b">application.yml</code>更新这个:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="caf6" class="ni ml iq oc b gy pf pg l ph pi">redis: <br/>   host: 172.18.0.2 <br/>   port: 6379</span></pre><p id="e510" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">注意:我们使用端口6379，因为我们在Docker网络中，对主机公开的端口是4025。</em></p><p id="80da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们再次构建应用程序的映像，并连接到我们创建的网络:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="c9ae" class="ni ml iq oc b gy pf pg l ph pi">DOCKER_BUILDKIT=1 docker build -t learnings/spring-boot-redis-cluster</span></pre><p id="7789" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行Docker映像时，我们可以通过传递<code class="fe nz oa ob oc b">--net</code>连接到网络:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="165c" class="ni ml iq oc b gy pf pg l ph pi">docker run --rm --net spring-redis-network -p 4024:4024 --name spring-boot-redis learnings/spring-boot-redis-cluster</span></pre><p id="506a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该在<code class="fe nz oa ob oc b"><a class="ae me" href="http://localhost:4024/app/" rel="noopener ugc nofollow" target="_blank">http://localhost:4024/app/</a></code>处看到待办事项列表项</p><p id="d151" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以验证缓存是在Docker Redis映像中创建的:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="99b9" class="ni ml iq oc b gy pf pg l ph pi">docker exec -it redis-1 redis-cli --scan</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="824c" class="ni ml iq bd mm nj nk dn mq nl nm dp mu la nn no mw le np nq my li nr ns na nt bi translated">步骤4:修改我们的应用程序以使用Spring Cache注释</h2><p id="814d" class="pw-post-body-paragraph kr ks iq kt b ku nu jr kw kx nv ju kz la od lc ld le oe lg lh li of lk ll lm ij bi translated">Spring Cache通常使用五种基本的注释:</p><ul class=""><li id="dbc7" class="lv lw iq kt b ku kv kx ky la lx le ly li lz lm ma mb mc md bi translated"><code class="fe nz oa ob oc b">@CachePut</code>:用于更新缓存。</li><li id="562c" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated"><code class="fe nz oa ob oc b">@Cacheable</code>:返回一个方法的缓存响应</li><li id="ac3c" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated"><code class="fe nz oa ob oc b">@CacheEvict</code>:要删除不再需要的缓存条目，可以考虑删除一个实体。</li><li id="2b4d" class="lv lw iq kt b ku mf kx mg la mh le mi li mj lm ma mb mc md bi translated"><code class="fe nz oa ob oc b">@Caching</code> : Java不允许在一个方法或类中两次使用相同的注释类型。所以，如果你想说<code class="fe nz oa ob oc b">@CacheEvict</code>在两个不同的缓存中用同一个方法<code class="fe nz oa ob oc b">@Cacheable</code>可以用来聚合其他缓存注释。</li></ul><p id="b021" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我已经将这些添加到我们的<code class="fe nz oa ob oc b">ToDoListController</code>中，看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="61fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们再次运行我们的应用程序并检查Redis统计数据，</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="c9dd" class="ni ml iq oc b gy pf pg l ph pi">DOCKER_BUILDKIT=1 docker build -t learnings/spring-boot-redis-cluster . </span><span id="20bd" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -p 4024:4024 --name spring-boot-redis learnings/spring-boot-redis-cluster </span><span id="651f" class="ni ml iq oc b gy pj pg l ph pi">docker exec -it redis-1 redis-cli info stats</span></pre><p id="f5c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想检查到目前为止的代码，<a class="ae me" href="https://github.com/avinash10584/spring-boot-redis-cluster/releases/tag/REDIS-CACHE" rel="noopener ugc nofollow" target="_blank">看一下标签</a>。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="98bb" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">使用Redis集群进行分片</h1><p id="6621" class="pw-post-body-paragraph kr ks iq kt b ku nu jr kw kx nv ju kz la od lc ld le oe lg lh li of lk ll lm ij bi translated">我们已经用Redis缓存构建了一个基本的spring boot应用程序。</p><p id="a184" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果我们处理的是无法包含在一个节点中的大量数据，该怎么办呢？Redis支持集群在多个节点上共享数据。</p><p id="9266" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Redis集群中的整个键空间被分成16384个槽(称为哈希槽)，这些槽被分配给多个Redis节点。给定的键被映射到这些槽中的一个，并且键的散列槽被计算:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="8c87" class="ni ml iq oc b gy pf pg l ph pi">HASH_SLOT = CRC16(key) mod 16384</span></pre><p id="e023" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在大多数情况下，您不需要知道这些内部信息，因为Redis会处理来自正确集群的数据的推送和提取。</p><p id="0285" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们停止Redis映像并构建一个集群:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="1d81" class="ni ml iq oc b gy pf pg l ph pi">docker stop redis-1 <br/>docker stop spring-boot-redis</span></pre><p id="2fc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们再旋转两个Redis节点来构建一个集群。我们还传递了一个位于项目/ <code class="fe nz oa ob oc b">redis-conf</code>中的Redis配置文件。</p><p id="80f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Redis至少需要三个节点才能让集群工作。</strong></p><p id="cae2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Redis映像默认禁用Redis集群支持，因此我们需要添加一个配置文件，并将其传递给我们的Redis Docker映像。我已经将它添加到项目根目录下的<code class="fe nz oa ob oc b">/redis-conf</code>中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ce50580023fb138d441d4e5041bd54f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kwCQQi7et3KnU1wC.png"/></div></div></figure><p id="49d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始碎片:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="b150" class="ni ml iq oc b gy pf pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf:/redis_config -p 4025:6379 -d --name redis-1 redis redis-server /redis_config/node1.conf </span><span id="973d" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf:/redis_config -p 4026:6379 -d --name redis-2 redis redis-server /redis_config/node2.conf </span><span id="e4ee" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf:/redis_config -p 4027:6379 -d --name redis-3 redis redis-server /redis_config/node3.conf</span></pre><p id="9aa6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Redis映像已经以集群模式启动，但是我们仍然需要创建一个集群来将它们绑定在一起。我们可以进行主从配置，但目前，我们只需要数据分片并创建不带故障转移的集群。</p><p id="8f33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在下一节讨论故障转移。</p><p id="2ca5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行以下命令创建集群:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="d3f7" class="ni ml iq oc b gy pf pg l ph pi">docker exec -it redis-1 redis-cli --cluster create 172.18.0.2:6379 172.18.0.3:6379 172.18.0.4:6379</span></pre><p id="c466" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该会在输出中看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/51ae154255382e0b057e575fd4e8a711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3OWOOHEJ4PEWmVwD.png"/></div></div></figure><p id="c6d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以检查我们的Docker网络，以获取Redis节点的新IP地址</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="d30c" class="ni ml iq oc b gy pf pg l ph pi">docker inspect spring-redis-network</span></pre><p id="80ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的<code class="fe nz oa ob oc b">application-cluster.yml</code>长这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c008" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们停止Docker spring boot应用程序，并使用集群配置重新启动它:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="5220" class="ni ml iq oc b gy pf pg l ph pi">docker stop spring-boot-redis </span><span id="f447" class="ni ml iq oc b gy pj pg l ph pi">DOCKER_BUILDKIT=1 docker build -t learnings/spring-boot-redis-cluster . </span><span id="c601" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -e "SPRING_PROFILES_ACTIVE=cluster" -p 4024:4024 --name spring-boot-redis learnings/spring-boot-redis-cluster</span></pre><p id="0e48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在浏览器中刷新应用程序，以验证应用程序是否正常工作。</p><p id="a1ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还可以验证任何节点中的群集配置:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="2b63" class="ni ml iq oc b gy pf pg l ph pi">docker exec -it redis-2 redis-cli cluster nodes</span></pre><p id="069b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">分片允许我们的数据分布在大型数据集的多个节点中，并通过哈希减少查找。</p><p id="86a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的集群缺少分布式系统的两个关键安全检查:故障转移处理和复制。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="9e71" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">使用Redis集群进行复制</h1><p id="0a59" class="pw-post-body-paragraph kr ks iq kt b ku nu jr kw kx nv ju kz la od lc ld le oe lg lh li of lk ll lm ij bi translated">Redis集群允许我们实现故障转移处理和复制。</p><p id="613c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在主从配置中设置节点，其中有一个父节点和两个副本节点。</p><p id="5505" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，如果我们失去一个节点，群集仍然能够选举新的主节点。在此设置中，写入必须通过主服务器，因为副本服务器是只读的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/9b38363dd267c45ac6b3bfe7cf70b5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*di41EYcxOHeysAsi.png"/></div></div></figure><p id="6fe1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样做的好处是，如果主节点消失，它的整个状态已经复制到辅助节点，这意味着当一个节点被选为主节点时，它可以立即开始接受写入。</p><h2 id="93ef" class="ni ml iq bd mm nj nk dn mq nl nm dp mu la nn no mw le np nq my li nr ns na nt bi translated">我们需要哨兵吗？</h2><p id="87fb" class="pw-post-body-paragraph kr ks iq kt b ku nu jr kw kx nv ju kz la od lc ld le oe lg lh li of lk ll lm ij bi translated">Sentinels是独立的Redis实例，它们与Redis节点一起运行，以决定它们在集群中的角色，并在发生故障转移时根据需要改变主从关系。</p><blockquote class="nc nd ne"><p id="63cc" class="kr ks ln kt b ku kv jr kw kx ky ju kz nf lb lc ld ng lf lg lh nh lj lk ll lm ij bi translated"><strong class="kt ir">使用Redis集群时不需要Sentinel。</strong></p></blockquote><p id="bd3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln">如果任何主实例中出现任何问题，Redis集群将执行自动故障转移。</em> </strong></p><p id="a2ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们应该将我们的集群转换为主从集群。让我们再添加三个节点，作为三个主节点的副本。</p><p id="0139" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们停止节点，然后再次启动它们:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="52e4" class="ni ml iq oc b gy pf pg l ph pi">docker stop redis-1 <br/>docker stop redis-2 <br/>docker stop redis-3 </span><span id="8111" class="ni ml iq oc b gy pj pg l ph pi"># Start redis nodes </span><span id="d3b2" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf:/redis_config -p 4025:6379 -d --name redis-1 redis redis-server /redis_config/node1.conf </span><span id="2526" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf:/redis_config -p 4026:6379 -d --name redis-2 redis redis-server /redis_config/node2.conf </span><span id="a9fe" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf:/redis_config -p 4027:6379 -d --name redis-3 redis redis-server /redis_config/node3.conf </span><span id="5709" class="ni ml iq oc b gy pj pg l ph pi"># Start replicas </span><span id="5836" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf:/redis_config -p 5025:6379 -d --name redis-1-replica redis redis-server /redis_config/node1-replica.conf</span><span id="a1ab" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf:/redis_config -p 5026:6379 -d --name redis-2-replica redis redis-server /redis_config/node2-replica.conf</span><span id="7eb1" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf:/redis_config -p 5027:6379 -d --name redis-3-replica redis redis-server /redis_config/node3-replica.conf</span></pre><p id="cc00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们检查一下Docker网络，因为我们需要IP地址来创建集群:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="cb4e" class="ni ml iq oc b gy pf pg l ph pi">docker inspect spring-redis-network </span><span id="ad67" class="ni ml iq oc b gy pj pg l ph pi">docker exec -it redis-1 redis-cli --cluster create 172.18.0.2:6379 172.18.0.3:6379 172.18.0.4:6379 172.18.0.6:6379 172.18.0.7:6379 172.18.0.8:6379 --cluster-replicas 1</span></pre><p id="41d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您看到以下错误，请停止正在运行的节点，因为它们具有内存中的数据，并且在创建集群时需要为空:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="033b" class="ni ml iq oc b gy pf pg l ph pi">[ERR] Node 172.18.0.3:6379 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.</span></pre><p id="d1f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一切顺利，您应该会看到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/214fe3b261b9948bde9129e1b381f848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6ChcDMq0OVdDYErb.png"/></div></div></figure><p id="8538" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过以下方式验证我们的群集:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="cd5e" class="ni ml iq oc b gy pf pg l ph pi">docker exec -it redis-2 redis-cli cluster nodes</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/4573631f3aedf60a6ae24895491c911f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4v1eHBSktir-_MHg.png"/></div></div></figure><p id="3a0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们最终的<code class="fe nz oa ob oc b">application-cluster.yml</code>看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="bed6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们再次运行我们的应用程序，并检查Redis统计数据:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="461c" class="ni ml iq oc b gy pf pg l ph pi">DOCKER_BUILDKIT=1 docker build -t learnings/spring-boot-redis-cluster . </span><span id="7d7b" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -p 4024:4024 --name spring-boot-redis learnings/spring-boot-redis-cluster </span><span id="ce86" class="ni ml iq oc b gy pj pg l ph pi">docker exec -it redis-1 redis-cli info stats</span></pre><p id="c5f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在应该测试我们的故障转移。让我们用<code class="fe nz oa ob oc b">docker stop redis-2</code>停止我们的一个服务器。</p><p id="deb5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您运行<code class="fe nz oa ob oc b">docker exec -it redis-1 redis-cli cluster nodes</code>，您会看到之前的次映像现在被提升为主映像。</p><p id="f0db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果父副本出现故障，Redis会自动将辅助副本提升为主副本。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="4ee4" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">Redis初级-次级(副本)网络，带Sentinel，无分片</h1><p id="e5a8" class="pw-post-body-paragraph kr ks iq kt b ku nu jr kw kx nv ju kz la od lc ld le oe lg lh li of lk ll lm ij bi translated">在不需要分片并且一个节点足以满足内存需求的场景中，您可以通过在Redis节点的<code class="fe nz oa ob oc b">replica</code>配置中指定<code class="fe nz oa ob oc b">replicaof</code>来避免创建集群并构建主从副本。</p><p id="80b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们不使用Redis集群，那么我们需要哨兵来实现故障转移。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1e90f1426812f3c6d62a6b75813be399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bR1nXCVbrioOojfX.png"/></div></div></figure><p id="0913" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哨兵和Redis集群是不同的概念。如果主要的死亡，然后哨兵互相交谈，以决定新的主要。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/84c72f6e21eca8b3cae4aa70c4decd83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IGgbxV23uxX2BjlF.png"/></div></div></figure><p id="620a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于sentinel配置与集群有很大不同，我把这个配置放在了<code class="fe nz oa ob oc b">/redis-conf-sentinel</code></p><p id="b9d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们添加sentinel服务器，这样我们就可以实现自动故障转移，</p><p id="bedb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哨兵只需要查看主节点就可以决定故障转移。</p><p id="bbc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">sentinel monitor redis-cluster 172.18.0.2 6379 2</code></p><p id="a813" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用下面的配置来决定一个集群节点在多长时间后被视为关闭。</p><p id="6609" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">sentinel down-after-milliseconds redis-cluster 5000</code></p><p id="c27f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以添加以下内容，以便在故障切换开始前允许当前复制写入超时完成:</p><p id="cc7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">sentinel failover-timeout redis-cluster 10000</code></p><p id="9b47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们停止所有的码头集装箱:</p><p id="6803" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nz oa ob oc b">docker stop $(docker ps -a -q)</code></p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="18e2" class="ni ml iq oc b gy pf pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf-sentinel:/redis_config -p 4025:6379 -d --name redis-1 redis redis-server /redis_config/node1.conf d</span><span id="4269" class="ni ml iq oc b gy pj pg l ph pi">ocker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf-sentinel:/redis_config -p 5025:6379 -d --name redis-1-replica redis redis-server /redis_config/node1-replica-1.conf</span><span id="b106" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf-sentinel:/redis_config -p 5026:6379 -d --name redis-2-replica redis redis-server /redis_config/node1-replica-2.conf</span><span id="af8a" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf-sentinel:/redis_config -p 6025:6379 -d --name sentinel-1 redis redis-server /redis_config/sentinel1.conf --sentinel </span><span id="b82f" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf-sentinel:/redis_config -p 6026:6379 -d --name sentinel-2 redis redis-server /redis_config/sentinel2.conf --sentinel </span><span id="d247" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -v /mnt/c/Development/github/spring-boot-redis-cluster/redis-conf-sentinel:/redis_config -p 6027:6379 -d --name sentinel-3 redis redis-server /redis_config/sentinel3.conf --sentinel </span><span id="49bb" class="ni ml iq oc b gy pj pg l ph pi">docker logs sentinel-2</span></pre><p id="14db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要更新我们的spring boot应用程序来使用sentinel配置。</p><p id="0bfb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们添加一个单独的<code class="fe nz oa ob oc b">application-sentinel.yml</code>并启动应用程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy oz l"/></div></figure><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="a671" class="ni ml iq oc b gy pf pg l ph pi">docker stop spring-boot-redis DOCKER_BUILDKIT=1 </span><span id="d135" class="ni ml iq oc b gy pj pg l ph pi">docker build -t learnings/spring-boot-redis-cluster . </span><span id="2f68" class="ni ml iq oc b gy pj pg l ph pi">docker run --rm --net spring-redis-network -e "SPRING_PROFILES_ACTIVE=sentinel" -p 4024:4024 --name spring-boot-redis learnings/spring-boot-redis-cluster</span></pre><p id="acf3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以停止我们的主实例来验证sentinels正在工作:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="0ff6" class="ni ml iq oc b gy pf pg l ph pi">docker stop redis-1</span></pre><p id="33c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该在您的sentinel <code class="fe nz oa ob oc b">docker logs sentinel-1</code>中看到这样的日志:</p><pre class="kg kh ki kj gt pb oc pc pd aw pe bi"><span id="42c1" class="ni ml iq oc b gy pf pg l ph pi">1:X 18 Jun 2020 21:25:06.046 # +sdown primary redis-cluster 172.18.0.2 6379 1:X 18 Jun 2020 21:25:07.679 # +new-epoch 1 1:X 18 Jun 2020 21:25:07.891 # <strong class="oc ir">+vote-for-leader </strong>bfebc5c7d07121c78633024dcbc89a14bf1e4563 1 1:X 18 Jun 2020 21:25:07.948 # +odown primary redis-cluster 172.18.0.2 6379 #quorum 3/2 1:X 18 Jun 2020 21:25:07.948 # Next failover delay: I will not start a failover before Thu Jun 18 21:25:28 2020 1:X 18 Jun 2020 21:25:08.580 # <strong class="oc ir">+config-update-from sentinel </strong>bfebc5c7d07121c78633024dcbc89a14bf1e4563 172.18.0.7 6379 @ redis-cluster 172.18.0.2 6379 1:X 18 Jun 2020 21:25:08.580 # <strong class="oc ir">+switch-primary redis-cluster </strong>172.18.0.2 6379 172.18.0.4 6379 1:X 18 Jun 2020 21:25:08.581 * </span></pre><p id="75b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样！我们实现了一个spring boot Redis应用程序，并学习了如何创建不同的Redis网络。</p><p id="a210" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您有任何问题或反馈，请不要犹豫，在评论区留下您的想法。</p><p id="94cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于与代码相关的问题，请随意直接在<a class="ae me" href="https://github.com/avinash10584/spring-boot-redis-cluster" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中创建问题。</p></div></div>    
</body>
</html>