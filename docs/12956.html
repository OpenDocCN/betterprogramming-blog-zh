<html>
<head>
<title>From React to Solid.js: A Smooth Transition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从React到Solid.js:平稳过渡</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-to-solidjs-a-smooth-transition-c30a618ba261?source=collection_archive---------4-----------------------#2022-07-14">https://betterprogramming.pub/react-to-solidjs-a-smooth-transition-c30a618ba261?source=collection_archive---------4-----------------------#2022-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="77b8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">SolidJS非常有效地做到了这一点，尤其是对于React开发人员</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d344561ca130916fec96ae324d2e7095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50DOJlxczkXiT-WRRYcsTA.png"/></div></div></figure><p id="3860" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Web框架来来去去是事实。虽然，大约10年来Angular和React一直主导着市场。但是你在面试中听到过多少次以下的问题:</p><p id="03ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你能比较Angular和React吗？两者各有什么利弊？何时使用一个而不是另一个？</p><p id="f362" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是等等…那么我们真的只有两个选择吗？一些过分务实的人可能会说这是真的。押注于大公司支持、数百万人使用的框架/库似乎是合理的。它们更可靠，我们也更有保证它们会得到长期支持。</p><p id="9995" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，你认为高风险的赌注是什么？</p><p id="570b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我建议查看Solid.js，这是一个开源的JavaScript库。这个库的提议是带来我们在React上发现的好东西，并改进一些其他部分，带来一个不同的算法来管理组件渲染(这是惊人的快)。观察下面SolidJS在性能方面与普通Javascript的接近程度。那绝对是惊人的！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/067520c321d0885a05012db4bbb79408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DAP_wrFZoi0hCwfpTrHmg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/8e97c91e6368d6e1391a76bd78afbc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sNFEIZ5GYA32MBmqvHAP8w.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated"><a class="ae lt" href="https://krausest.github.io/js-framework-benchmark/current.html" rel="noopener ugc nofollow" target="_blank">https://krausest . github . io/js-framework-benchmark/current . html</a></p></figure><p id="fb1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是从React切换到SolidJS有多难呢？小菜一碟！在这篇文章中，我将试着展示如何快速地转移到SolidJS！</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="247a" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">基本结构和语法</h1><p id="937a" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">实体仅支持功能组件。观察下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4200" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有比这更相似的反应吗？结构是一样的，并且支持Typescript。不过我们可以注意到一个不同之处:<code class="fe na nb nc nd b">class</code>代替了<code class="fe na nb nc nd b">className</code>(它还支持<a class="ae lt" href="https://www.solidjs.com/tutorial/bindings_classlist" rel="noopener ugc nofollow" target="_blank">条件类</a>)。</p><p id="3ec3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">说到事件监听，SolidJS非常接近DOM事件。我们可以通过在上添加<em class="ne">作为前缀来监听原始事件。看看如何在上面的代码片段中捕获<code class="fe na nb nc nd b">mousemove</code>事件。</em></p><p id="c937" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当更深入地探索这个库时，您会注意到一些其他的小差异，但是总的来说，我们能同意它看起来几乎和React一样吗？</p><h1 id="9140" class="mb mc iq bd md me nf mg mh mi ng mk ml jw nh jx mn jz ni ka mp kc nj kd mr ms bi translated">状态管理</h1><p id="7b99" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">有几种方法可以管理React应用程序中的状态。您可以使用<code class="fe na nb nc nd b">useState</code>或<code class="fe na nb nc nd b">useReducer</code>在本地完成这项工作，或者您可以在组件树的分支中实现一个上下文。作为一种外包解决方案，您可以利用像Redux或Mobx这样的状态管理库。</p><p id="ad73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的目标不是为这些解决方案辩护，而是向您展示SolidJS如何实现它们。</p><h2 id="e7ff" class="nk mc iq bd md nl nm dn mh nn no dp ml la np nq mn le nr ns mp li nt nu mr nv bi translated">在组件级别</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="86a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们从React中知道的<code class="fe na nb nc nd b">useState</code>变成了SolidJS中的<code class="fe na nb nc nd b">createSignal</code>。要访问状态的值，我们需要调用它。</p><p id="1f27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">也可以创建衍生信号，就像我们用<code class="fe na nb nc nd b">doubleCount</code>T13做的那样。通过访问组件状态，通过触发依赖于它们的任何效应，导出值将携带与它们的反应性。</p><p id="7d51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与React和我们期望的<code class="fe na nb nc nd b">useState</code>行为不同，<code class="fe na nb nc nd b">count</code>状态不仅仅是一个数字。这是一个返回一个数字的函数，通过调用这个函数，我们最终得到了这个值。</p><h2 id="5bc3" class="nk mc iq bd md nl nm dn mh nn no dp ml la np nq mn le nr ns mp li nt nu mr nv bi translated">使用备忘录与创建备忘录</h2><p id="a909" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated"><em class="ne"> </em> React中的<code class="fe na nb nc nd b">useMemo</code> <em class="ne"> </em>就像缓存最后的结果一样简单，直到被监视的值发生变化。</p><p id="ae3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了Solid的<code class="fe na nb nc nd b">createMemo</code>，事情变得简单了一些。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="03e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不需要观察<code class="fe na nb nc nd b">count</code>值的变化。因为<code class="fe na nb nc nd b">count</code>实际上是一个提供订阅的函数，所以<code class="fe na nb nc nd b">createMemo</code>函数创建了一个与它的绑定。<code class="fe na nb nc nd b">createMemo</code>返回的值也是一个函数，所以当我们想要使用它的值时，我们需要调用它。</p><h2 id="d25e" class="nk mc iq bd md nl nm dn mh nn no dp ml la np nq mn le nr ns mp li nt nu mr nv bi translated">全球状态</h2><p id="a4de" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">有时只做地方州管理会导致混乱，对吗？为了避免过多的财产钻探，SolidJD有一个超级简单的解决方案。由于我们正在处理信号的概念，我们可以简单地提取所有本地信号，并在一个<code class="fe na nb nc nd b">store.ts</code>文件中声明它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1830" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那有多好？！这有多简单？！真的，这太神奇了。你只需要声明你所在的州，导出它们，无论你在哪里使用它们，都会有人订阅！</p><p id="3ba5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法提供了多种不同的策略。你可以创建一个全球商店，你可以创建一些部分商店，你可以组成商店。这就是自由！</p><h1 id="cfe7" class="mb mc iq bd md me nf mg mh mi ng mk ml jw nh jx mn jz ni ka mp kc nj kd mr ms bi translated">控制流程</h1><p id="5719" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">在我们的应用程序开发过程中，有一种结构是我们永远无法摆脱的:列表。当使用React时，我们通常通过简单地创建一个<code class="fe na nb nc nd b">map</code>并返回JSX来实现。在React中，我们需要担心向key属性传递一个惟一的值，所以React不必在单个元素改变时重新呈现整个列表。</p><p id="251e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SolidJs做的有点不同，使用<a class="ae lt" href="https://www.solidjs.com/tutorial/flow_for" rel="noopener ugc nofollow" target="_blank"> <em class="ne">作为</em> </a> <em class="ne">标签</em>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f081" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Solid的方法的好处是我们不需要担心键和性能。列表中的索引(<em class="ne"> i) </em>也是一个<em class="ne">信号。</em>因此，列表订阅了索引，当发生变化时，Solid确切地知道在哪里更新。</p><p id="e236" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除此之外，SolidJS还提供了另一个呈现列表的选项:<a class="ae lt" href="https://www.solidjs.com/tutorial/flow_index" rel="noopener ugc nofollow" target="_blank"> <em class="ne"> Index </em> </a>标签。如果您迭代的值是原语，那么它会提高性能。</p><h1 id="3f7d" class="mb mc iq bd md me nf mg mh mi ng mk ml jw nh jx mn jz ni ka mp kc nj kd mr ms bi translated">路线</h1><p id="b9b8" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">如果你用<code class="fe na nb nc nd b">react-router-dom</code>在你的React应用上实现routes，我必须说你在这里几乎没有工作要做。换成<code class="fe na nb nc nd b">solid-app-router</code>就好！(有一个小的区别:一个<code class="fe na nb nc nd b">Link</code>组件将有一个属性<code class="fe na nb nc nd b">href</code>而不是<code class="fe na nb nc nd b">to</code>)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="abdb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">学习新的框架/库或技术可能具有挑战性。如果我们可以选择重复使用我们的知识，并在我们的清单上增加一项技能，那就更好了。Solid.js非常有效地做到了这一点，尤其是对于React开发人员。</p><p id="518b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你很好奇为什么SolidJS这么快吗？它没有使用虚拟dom，而是使用细粒度的反应式解决方案，将模板直接编译到DOM中。<a class="ae lt" href="https://indepth.dev/posts/1269/finding-fine-grained-reactive-programming" rel="noopener ugc nofollow" target="_blank">谁能比SolidJS的创造者更好地解释它是如何工作的</a>。</p><p id="2513" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">干杯！</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt nw nd nx ny aw nz bi"><span id="333c" class="nk mc iq nd b gy oa ob l oc od"><strong class="nd ir">Additional video</strong>: <a class="ae lt" href="https://www.youtube.com/watch?v=OqcHoLWyyIw" rel="noopener ugc nofollow" target="_blank">Replacing React with SolidJS</a>.</span></pre></div></div>    
</body>
</html>