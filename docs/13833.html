<html>
<head>
<title>Cool Swift Features That Are Rarely Used</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">很少使用的酷炫Swift功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cool-swift-features-that-rarely-used-ea8eee870f16?source=collection_archive---------1-----------------------#2022-10-01">https://betterprogramming.pub/cool-swift-features-that-rarely-used-ea8eee870f16?source=collection_archive---------1-----------------------#2022-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd32" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">回顾10种Swift语言结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f6583f8af529242b7ce885ebf9da15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S7t8JMpC4MRwbO3F"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rev3n?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">micha Kubalczyk</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ef26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift是最强大的编程语言之一。同时也相对容易学。了解Objective-C之后，我可以在不到一周的时间内切换到它。混合了经典的C风格指令如<code class="fe lv lw lx ly b">if</code>和<code class="fe lv lw lx ly b">for</code>，现代概念如ARC和扩展以及强大的框架，使它成为初学者和专业人士的最佳编程语言之一。</p><p id="36eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种简单性产生了一个问题:许多开发人员在开始编写应用程序时，不再深入研究语言特性。我在2014年用Swift编写了我的第一个应用程序，但我一直在学习Swift的新<em class="lz">隐藏</em>功能。在本文中，我想回顾一下开发人员很少在他们的第一个应用中使用的10种Swift语言结构。</p><h1 id="9b27" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">推迟</h1><p id="0b49" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">如果你的函数很混乱，有很多返回或者抛出，使用了非托管资源或者其他最终需要清理的代码，那么<code class="fe lv lw lx ly b">defer</code>是你的一个很好的选择。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="f57e" class="nb mb it ly b gy nc nd l ne nf">openResource()<br/><br/>defer { freeResource() }<br/><br/>// Do whatever you like. Don't free the resource</span></pre><p id="f0ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看上面的代码。一开始我们打开一个资源。它可以是文件、数据库或网络套接字。我们知道，在这个函数结束时，需要释放资源，否则会导致内存泄漏或其他问题。</p><p id="662e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开资源后立即调用<code class="fe lv lw lx ly b">defer</code>。反初始化代码应该在<code class="fe lv lw lx ly b">defer</code>闭包里面。然后使用您的文件、数据库或套接字，而不必担心释放它。无论您有多少条return语句，您都可以确保您的非托管资源将被正确地...管理。</p><h1 id="c940" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">惰性变量</h1><p id="034f" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">惰性变量在被请求时被初始化。这是一个很棒的句法糖，它把这个:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="fdfb" class="nb mb it ly b gy nc nd l ne nf">private var _innerVariable: SomeComplexType?<br/><br/>var visibleVariable: SomeComplexType {<br/>  get() {<br/>    if _innerVariable == nil {<br/>      _innerVariable = SomeComplexType()<br/>    }<br/>    return _innerVariable!<br/>  }<br/>}</span></pre><p id="b2ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变成这样:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="9854" class="nb mb it ly b gy nc nd l ne nf">lazy var visibleVariable = SomeComplexType()</span></pre><p id="19e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你需要一个变量在某一点单独初始化时，这很有用。同时，您希望它只初始化一次，而不是每次都重新创建。</p><p id="e5c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，以下代码可用于创建一个UI元素:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="4260" class="nb mb it ly b gy nc nd l ne nf">lazy var titleLabel: UILabel = {<br/>  let label = UILabel()<br/>  label.text = "Screen title"<br/>  return label<br/>}()<br/><br/>func createLayout() {<br/>  addSubview(titleLabel)<br/>}</span></pre><h1 id="c7c5" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">警戒控制语句</h1><p id="b5ab" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">guard</code>语句实际上在Swift中很常用，但我想在这里提到它，因为它对于所说的编程语言是独一无二的。从另一种语言如C++、Python甚至Objective-C切换过来后，你可能会觉得很奇怪。</p><p id="5a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，<code class="fe lv lw lx ly b">guard</code>类似于<code class="fe lv lw lx ly b">if</code>结构，但是逻辑相反。主要区别在于，<code class="fe lv lw lx ly b">guard</code>应该总是以流终止语句(<code class="fe lv lw lx ly b">return</code>、<code class="fe lv lw lx ly b">throw</code>、<code class="fe lv lw lx ly b">break</code>)结束...).</p><p id="f0ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的用例是获取非可选变量。假设我们正在编写一个使用可选类属性的方法。但是这个方法只有在属性不是<code class="fe lv lw lx ly b">nil</code>的时候才有意义。</p><p id="9578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">诀窍是:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="95b7" class="nb mb it ly b gy nc nd l ne nf">guard let nonOptional = optionalVariable else {<br/>  // Show a message<br/>  return<br/>}<br/><br/>// Use nonOptional</span></pre><p id="e412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe lv lw lx ly b">if</code>语句，<code class="fe lv lw lx ly b">guard</code>可能有几个用逗号分隔的条件，删除可选性并不是它唯一能做的事情。例如，这是另一个有效的用例:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="cb1d" class="nb mb it ly b gy nc nd l ne nf">guard let field1 = field1,<br/>  !field1.isEmpty,<br/>  let field2 = field2,<br/>  !field2.isEmpty<br/>else {<br/>  return<br/>}</span></pre><p id="03ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面的例子中看到的，<code class="fe lv lw lx ly b">guard</code>语句可以重定义常量和变量，使它们成为非可选的。</p><h1 id="1e95" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">协议扩展</h1><p id="6e76" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">一些像C++这样的老语言有一个有趣的特性叫做<em class="lz">多重继承</em>。这意味着一个类可以有两个或更多的基类。例如，如果类<code class="fe lv lw lx ly b">A</code>具有函数<code class="fe lv lw lx ly b">a()</code>，类<code class="fe lv lw lx ly b">B</code>具有函数<code class="fe lv lw lx ly b">b()</code>，则扩展<code class="fe lv lw lx ly b">A</code>和<code class="fe lv lw lx ly b">B</code>的类<code class="fe lv lw lx ly b">C</code>将同时具有函数<code class="fe lv lw lx ly b">a()</code>和<code class="fe lv lw lx ly b">b()</code>。这同样适用于类变量、常量和其他所有东西。</p><p id="2998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特性确实非常强大，但是它产生了如此多的问题和不确定性，以至于it专家将它列入了不良实践的列表。比如后藤。</p><p id="e040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有现代语言都只允许从一个基类(或超类)继承，并在Swift术语中添加了接口或协议。协议的缺点是它们不能拥有自己的功能。或者……他们能吗？</p><p id="7268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个协议真的不能包含任何数据。这是不可避免的。但是您可以添加一个函数，该函数对继承该协议的所有类都可用。</p><p id="1642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您正在编写一个<code class="fe lv lw lx ly b">File</code>类，它提供了对文件系统的访问。而且我们有一个函数<code class="fe lv lw lx ly b">open(access: Access)</code>。<code class="fe lv lw lx ly b">Access</code>定义请求的文件访问权限。</p><p id="393b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要<code class="fe lv lw lx ly b">ReadableFile</code>和<code class="fe lv lw lx ly b">WritableFile</code>。<code class="fe lv lw lx ly b">ReadableFile</code>会有一个功能<code class="fe lv lw lx ly b">open()</code>，调用<code class="fe lv lw lx ly b">open(access: .read)</code>。这将是一个类似的功能<code class="fe lv lw lx ly b">WritableFile</code>。</p><p id="946e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要一个既可读又可写的文件。这就是多重继承发挥作用的地方。但是斯威夫特没有。我们必须使用协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">MyFile</code>从上面的例子现在可以访问所有的功能:<code class="fe lv lw lx ly b">get() -&gt; String</code>、<code class="fe lv lw lx ly b">readText() -&gt; String</code>、<code class="fe lv lw lx ly b">set(text: String)</code>、<code class="fe lv lw lx ly b">write(text: String)</code>等。只要被调用的函数在同一个协议或基础协议中声明，这些函数就可以相互调用。</p><p id="5382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有定义任何函数(没有代码)，则必须在采用该协议的类中定义它。</p><h1 id="40fa" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">异步函数</h1><p id="bc09" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">异步函数存在于许多语言中，但直到5.5版才出现在Swift中。你只能从iOS 13，iPadOS 13，macOS 10.15，tvOS 13，watchOS 6开始使用它们。如果你的应用需要在iOS 12或macOS 10.14中运行，你将无法使用并发。</p><p id="7165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外观:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="cf18" class="nb mb it ly b gy nc nd l ne nf">func asyncTask() async throws -&gt; Result {<br/>  ...<br/>}<br/><br/>Task {<br/>  do {<br/>    let result = await asyncTask()<br/>    print(result)<br/>  } catch {<br/>    print(error.localizedDescription)<br/>  }<br/>}</span></pre><p id="b8e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作原理:</p><p id="5985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Task</code>是创建异步上下文的结构。只能从上下文中调用异步函数(<code class="fe lv lw lx ly b">Task</code>闭包或另一个异步函数)。</p><p id="9294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步函数应该用关键字<code class="fe lv lw lx ly b">async</code>标记。关键字<code class="fe lv lw lx ly b">throws</code>表示该功能可能会失败。一个标准的Swift函数应该是这样的:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="8236" class="nb mb it ly b gy nc nd l ne nf">func task(completion: @escaping (result: Result?, error: Error?) -&gt; Void) {<br/>  ...<br/>}</span></pre><p id="377c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要调用一个异步函数，你需要使用<code class="fe lv lw lx ly b">await</code>关键字。</p><p id="28c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你为什么要用它？这使得代码更容易阅读和测试。我们有一个包装在<code class="fe lv lw lx ly b">do-catch</code>块和<code class="fe lv lw lx ly b">Task</code>结构中的易读代码，而不是带有选项、可能的保留周期和其他混乱的完成块。</p><p id="f6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift中的并发很容易实现，但是有一个重要的时刻。异步函数在单独的线程中工作。这意味着你不能更新用户界面，导航，显示弹出窗口等。</p><p id="229f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，你需要切换到<code class="fe lv lw lx ly b">MainActor</code>。有三种方法:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="f859" class="nb mb it ly b gy nc nd l ne nf">await MainActor.run {<br/>  // Update UI<br/>}</span><span id="68d2" class="nb mb it ly b gy ni nd l ne nf">@MainActor func iWillRunInMainThread() {<br/>  // This function will run in UI thread<br/>}</span><span id="dbe3" class="nb mb it ly b gy ni nd l ne nf">Task { @MainActor in<br/>  // Functions here will run on UI thread<br/>}</span></pre><p id="684d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以根据自己的情况选择最合适的方式。</p><h1 id="edcf" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">区间匹配</h1><p id="b85f" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">区间或范围可以是封闭的或开放的。开放区间不包括边缘值，而封闭区间包括整个范围。</p><p id="792f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><p id="39fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">let range1 = 1...5 // 1, 2, 3, 4, 5</code></p><p id="912e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">let range2 = 1..&lt;5 // 1, 2, 3, 4</code></p><p id="ce86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">注意:旧版本的Swift有单独的间隔数据类型。后来它们就成了一个共同的类型——</em><code class="fe lv lw lx ly b"><em class="lz">Range</em></code><em class="lz">。</em></p><p id="da24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift允许在<code class="fe lv lw lx ly b">switch</code> - <code class="fe lv lw lx ly b">case</code>结构中使用音程。例如:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="cbf8" class="nb mb it ly b gy nc nd l ne nf">switch age {<br/>  case 0..&lt;18:<br/>    print("You're minor")<br/>    <br/>  case 18...:<br/>    print("You're adult")<br/>      <br/>  default:<br/>    print("You weren't born yet")<br/>}</span></pre><p id="7502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">间隔可以相互重叠。它们也可以在同一个<code class="fe lv lw lx ly b">switch</code>中与简单值一起使用。它是这样工作的:</p><ul class=""><li id="b0d3" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">一条<code class="fe lv lw lx ly b">switch</code>语句计算提供的值，或者从内存中读取变量值；</li><li id="70c6" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">从上到下检查<code class="fe lv lw lx ly b">switch</code>的值是否与<code class="fe lv lw lx ly b">case</code>的值匹配；</li><li id="6bd9" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">如果它与所述值不匹配，它进行到下一个<code class="fe lv lw lx ly b">case</code>直到它结束。如果没有匹配，它执行一个<code class="fe lv lw lx ly b">default</code>块；</li><li id="8285" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">如果匹配，它执行代码块并终止<code class="fe lv lw lx ly b">switch</code>的执行，除非使用了<code class="fe lv lw lx ly b">fallthrough</code>关键字；</li><li id="5ae2" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">如果使用<code class="fe lv lw lx ly b">fallthrough</code>,则执行匹配块后的下一个<code class="fe lv lw lx ly b">case</code>块。然后它不再做任何匹配。</li></ul><p id="ff41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要几个值，而不是一个区间，可以用逗号来表示:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="aca8" class="nb mb it ly b gy nc nd l ne nf">case 1, 5, 10:<br/>    // ...</span></pre><h1 id="1c4f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">关联值</h1><p id="d0df" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">Swift的一个独特或至少不常见的特性是<em class="lz"> enum关联值</em>。每个枚举事例都可以包含数据。</p><p id="d136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。我们希望允许用户选择性别。如果用户没有表明自己是女性还是男性，我们希望允许他们输入另一个性别。同时，我们希望保持枚举的魅力:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="34ce" class="nb mb it ly b gy nc nd l ne nf">enum Gender {<br/>  case female<br/>  case male<br/>  case other(gender: String, pronounce: String)<br/>}</span></pre><p id="c580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样定义性别:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="59a0" class="nb mb it ly b gy nc nd l ne nf">let gender = Gender.other(gender: "Non-binary", pronounce: "them")</span></pre><p id="a5dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以在<code class="fe lv lw lx ly b">case</code>块中提取这些值:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="649d" class="nb mb it ly b gy nc nd l ne nf">switch gender {<br/>case .female:<br/>  print("Say 'hi' to her")<br/><br/>case .male:<br/>  print("Say 'hi' to him")<br/><br/>case let .other(_, pronounce):<br/>  print("Say 'hi' to \(pronounce)")<br/>}</span></pre><p id="250a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不需要处理所有的情况，你可以使用一个<code class="fe lv lw lx ly b">if</code>语句:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="e4c3" class="nb mb it ly b gy nc nd l ne nf">if case let .other(genderName, _) = gender {<br/>  print(genderName)<br/>}</span></pre><h1 id="f4a4" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">链接</h1><p id="e227" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">链接是我最喜欢的现代编程语言的特性之一。当您处理选项时，链接尤其有用，这在Swift中非常常见。</p><p id="43f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子——我们在一个名为<code class="fe lv lw lx ly b">items</code>的可选变量中有一个项目列表。每个项目都有一个可选的id。我们需要向服务器发送一个id列表。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="1e6b" class="nb mb it ly b gy nc nd l ne nf">var items: [Item]? = ...<br/>var ids = [Int]()<br/>if let items = items {<br/>    for item in items {<br/>      if let itemId = item.id {<br/>        ids.append(itemId)<br/>      }<br/>    }<br/>}</span></pre><p id="8d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过链接，上述示例可以变成一行代码:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="88a1" class="nb mb it ly b gy nc nd l ne nf">var items: [Item]? = ...<br/>let ids = items?.compactMap { $0.id } ?? []</span></pre><p id="0336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这已经是很大的简化了。现在假设我们只有一个id，第一个非空id。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="b9af" class="nb mb it ly b gy nc nd l ne nf">var items: [Item]? = ...<br/>var id: Int?<br/>if let items = items {<br/>    for item in items {<br/>      if let itemId = item.id {<br/>          id = itemId<br/>          break<br/>      }<br/>    }<br/>}</span></pre><p id="e60e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以简化这一点:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="3915" class="nb mb it ly b gy nc nd l ne nf">var items: [Item]? = ...<br/>let id = items?.compactMap { $0.id }.first</span></pre><p id="7afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您处理更复杂的结构时，链接的真正威力是显而易见的。假设<code class="fe lv lw lx ly b">Item</code>结构有另一个结构字段——<code class="fe lv lw lx ly b">description</code>，它有一个字段<code class="fe lv lw lx ly b">color</code>。</p><p id="4355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要获得颜色列表，例如，为了收集统计数据，您可以这样做:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="01e3" class="nb mb it ly b gy nc nd l ne nf">var items: [Item]? = ...<br/>let colors = items?.compactMap { $0.description }.compactMap { $0.color } ?? []</span></pre><p id="ea35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="5128" class="nb mb it ly b gy nc nd l ne nf">var items: [Item]? = ...<br/>let colors = items?.compactMap { $0.description?.color } ?? []</span></pre><p id="ddb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe lv lw lx ly b">compactMap</code>，还可以使用<code class="fe lv lw lx ly b">forEach</code>、<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">filter</code>等功能。如果左侧可选，需要在<code class="fe lv lw lx ly b">.</code>前加<code class="fe lv lw lx ly b">?</code>。</p><h1 id="e906" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">弱变量</h1><p id="10ae" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">弱变量允许避免保留周期。<em class="lz">保留周期</em>是两个对象相互强引用时的状态。这迫使一个对象总是留在内存中，即使它不再被使用。</p><p id="574c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个典型的例子是视图控制器和演示者。或者视图控制器和视图模型。他们需要互相传递信息。最简单的实现是保持彼此之间的链接。当你关闭应用程序屏幕时，它不需要将它们保存在内存中，但ARC(自动引用计数器)只有在没有其他对象对其进行强引用时才会释放一个对象。</p><p id="e045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="6128" class="nb mb it ly b gy nc nd l ne nf">class MyController: UIViewController {<br/>  var viewModel: MyViewModel?<br/><br/>    // ...<br/>}<br/><br/>class MyViewModel: NSObject {<br/>  var controller: MyController?<br/>  <br/>  // ...<br/>}</span></pre><p id="c36d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用协议会更好，但是它不能解决保留周期问题，所以为了节省时间，我们在这里不使用它们。</p><p id="90db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初始化期间，<code class="fe lv lw lx ly b">viewModel</code>和<code class="fe lv lw lx ly b">controller</code>将开始相互参照。当iOS看到<code class="fe lv lw lx ly b">MyController</code>不在dissolve中时，它会尝试释放它，但是<code class="fe lv lw lx ly b">MyViewModel</code>仍然引用它。同样适用于<code class="fe lv lw lx ly b">MyViewModel</code> - <code class="fe lv lw lx ly b">MyController</code>正在引用它。怎么修？</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="bfb5" class="nb mb it ly b gy nc nd l ne nf">class MyController: UIViewController {<br/>  var viewModel: MyViewModel?<br/><br/>    // ...<br/>}<br/><br/>class MyViewModel: NSObject {<br/>  weak var controller: MyController?<br/>  <br/>  // ...<br/>}</span></pre><p id="b8a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与默认的强引用不同，弱引用不包含对象。相反，当对象被释放时，它们变为<code class="fe lv lw lx ly b">nil</code>。在上面的示例中，这将在解散后发生:</p><ul class=""><li id="04e7" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">iOS将检查是否有对<code class="fe lv lw lx ly b">MyController</code>的强引用</li><li id="4d20" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">没有强有力的引用，唯一的引用是弱的</li><li id="d65e" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">iOS发布了一个<code class="fe lv lw lx ly b">MyController</code>的实例。<code class="fe lv lw lx ly b">MyViewModel</code>实例的<code class="fe lv lw lx ly b">controller</code>变量会自动设置为<code class="fe lv lw lx ly b">nil</code></li><li id="1ee4" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">自从<code class="fe lv lw lx ly b">MyController</code>发布后，就不会再有强引用<code class="fe lv lw lx ly b">MyViewModel</code></li><li id="8635" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lv lw lx ly b">MyViewModel</code>的实例也被释放</li></ul><p id="e3ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用故事板或xib时，<code class="fe lv lw lx ly b">weak</code>变量的另一个例子是<code class="fe lv lw lx ly b">@IBOutlet</code>引用。</p><p id="6af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们切换到下一个主题之前，还有一点需要注意——有时我们使用完成处理程序执行异步操作。例如:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="20e2" class="nb mb it ly b gy nc nd l ne nf">func loadData() {<br/>  network.load { data, error in<br/>    if let error = error {<br/>      self.show(error)<br/>    } else {<br/>      self.show(data)<br/>    }<br/>  }<br/>}</span></pre><p id="cad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，闭包有一个对调用类的强引用。如果它是<code class="fe lv lw lx ly b">UIViewController</code>的实例，即使用户返回，它也会把它留在内存中，直到接收到数据。但是如果用户关闭屏幕，我们不需要显示任何内容。那么，为什么我们要把它保存在内存中并处理结果呢？</p><p id="991f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">weak</code>关键字将解决这个问题:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="c4d4" class="nb mb it ly b gy nc nd l ne nf">func loadData() {<br/>  network.load { [weak self] data, error in<br/>    if let error = error {<br/>      self?.show(error)<br/>    } else {<br/>      self?.show(data)<br/>    }<br/>  }<br/>}</span></pre><p id="7240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你多次提到<code class="fe lv lw lx ly b">self</code>，你可以使用<code class="fe lv lw lx ly b">guard</code>语句:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="de3b" class="nb mb it ly b gy nc nd l ne nf">func loadData() {<br/>  network.load { [weak self] data, error in<br/>    guard let self = self else { return }<br/>    if let error = error {<br/>      self.show(error)<br/>    } else {<br/>      self.show(data)<br/>    }<br/>  }<br/>}</span></pre><p id="7218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种避免保留周期的方法是使用<code class="fe lv lw lx ly b">unowned</code>关键字。它类似于<code class="fe lv lw lx ly b">weak</code>，但是它假设无主对象将在内存中。如果引用的实例被释放，可能会导致崩溃。</p><h1 id="9797" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">财产观察员</h1><p id="3ef2" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">另一个现代特征是房产观察者。在更老的编程语言中它是不存在的，所以很多从其他语言转到Swift的开发者不知道如何使用它。</p><p id="dc4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个具有属性的类:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="f256" class="nb mb it ly b gy nc nd l ne nf">class MyClass {<br/>  var prop: Int = 0<br/>  <br/>  func propChanged() {<br/>  }<br/>}</span></pre><p id="5747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想知道<code class="fe lv lw lx ly b">prop</code>是什么时候被更改的，并采取一些措施。例如，如果我们有一个包含红色、绿色和蓝色组件的颜色结构，当其中一个组件改变时，我们需要重新绘制它。</p><p id="b5eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显而易见的方法是，每当我们设置一个<code class="fe lv lw lx ly b">prop</code>时就调用<code class="fe lv lw lx ly b">propChanged()</code>。但这是一种快速获取bug的方法。您可能会忘记打电话，或者其他开发人员可能甚至不知道这是必要。</p><p id="5478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是将<code class="fe lv lw lx ly b">prop</code>和<code class="fe lv lw lx ly b">propChanged</code>设为私有，并添加一个函数:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="8c61" class="nb mb it ly b gy nc nd l ne nf">func changeProp(_ newValue: Int) {<br/>  prop = newValue<br/>  propChanged()<br/>}</span></pre><p id="0b3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可行的，但是代码太多了。你可能有几十处房产。你不允许得到这个值，因为它是私有的。</p><p id="2e24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确的方法是:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="6c6f" class="nb mb it ly b gy nc nd l ne nf">class MyClass {<br/>  var prop: Int = 0 {<br/>    didSet {<br/>      propChanged()<br/>    }<br/>  }<br/>}</span></pre><p id="3019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">didSet</code>是一名物业观察员。这是一个常规的Swift函数，可以使用<code class="fe lv lw lx ly b">prop</code>的新值。每次值改变时都会调用它，所以你不用再担心它了。</p><p id="bdef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有两个观察者:</p><ul class=""><li id="40c9" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">在设置新值之前调用<code class="fe lv lw lx ly b">willSet</code>。<code class="fe lv lw lx ly b">prop</code>仍有旧值。你可以用它来释放旧的资源，为新的价值做准备。</li><li id="f133" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">设置新值后调用<code class="fe lv lw lx ly b">didSet</code>。</li></ul><h2 id="adcb" class="nb mb it bd mc nx ny dn mg nz oa dp mk li ob oc mm lm od oe mo lq of og mq oh bi translated">属性包装</h2><p id="9985" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">属性包装器允许在设置或获取数据时对数据进行所有可能的操作。一个典型的例子是设置数据范围，比如我们需要限制一个从<code class="fe lv lw lx ly b">1</code>到<code class="fe lv lw lx ly b">5</code>的值。这是一个典型的评级案例。如果允许的选项是给出1到5颗星，6将是错误的。如果你从后端得到它，你可以假设这是一个计算错误或四舍五入。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="8c52" class="nb mb it ly b gy nc nd l ne nf">@propertyWrapper<br/>struct Rating {<br/>  private var number = 1<br/>    <br/>  var wrappedValue: Int {<br/>    get { return number }<br/>    set { number = max(min(newValue, 5), 1) }<br/>  }<br/>}<br/><br/>struct User {<br/>  @Rating var rating: Int<br/>}<br/><br/>var user = User()<br/>user.rating = 10<br/><br/>print(user.rating)<br/>// 5 is printed</span></pre><p id="464c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，显示错误可能是更好的解决方案，但是在很多情况下，当您获取或设置变量的值时，数据处理可能是一个好主意。</p><h1 id="dde6" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">摘要</h1><p id="1193" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我确信，如果您是一名经验丰富的Swift开发人员，您会了解其中的大部分功能，如果不是全部的话。但是如果你是Swift新手，或者你没有深入研究文档或阅读其他人的代码，你可能不知道其中的一些，因为它们没有在其他编程语言中使用。</p><p id="930e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望它对你有用。编码快乐，下次见！</p><h1 id="641e" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">第二部分</h1><p id="fa40" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在我发表这篇文章后，我得到了一些关于缺失功能的评论。下面是第2部分，描述更高级、甚至更少使用的Swift功能:</p><p id="b4c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://foxicorn.medium.com/cool-swift-features-that-rarely-used-part-2-92bb52e8a715" rel="noopener">https://foxi corn . medium . com/cool-swift-features-that-less-used-part-2-92 bb 52 e8a 715</a></p></div></div>    
</body>
</html>