<html>
<head>
<title>Detect and Handle Collision Events in a RealityKit Scene Across Different Entities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跨不同实体检测和处理RealityKit场景中的碰撞事件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/realitykit-on-ios-part-2-applying-collision-events-d64b6e10421f?source=collection_archive---------5-----------------------#2020-01-30">https://betterprogramming.pub/realitykit-on-ios-part-2-applying-collision-events-d64b6e10421f?source=collection_archive---------5-----------------------#2020-01-30</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="cd48" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">iOS上的现实工具包，第2部分—应用碰撞事件</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/58c545471f184b1fc305e6dc4b92c809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjgAKumpQ-wyoivPVCYM1A.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">由DALL-E绘制</p></figure><p id="c0a4" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这是我涵盖RealityKit来龙去脉的系列文章的第二部分，从这里的<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-realitykit-on-ios-entities-gestures-and-ray-casting-8f6633c11877">开始</a>。</p><h1 id="a8bb" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">快速回顾</h1><p id="bad8" class="pw-post-body-paragraph kw kx ir ky b kz ml js lb lc mm jv le lf mn lh li lj mo ll lm ln mp lp lq lr ik bi translated">如果你没有机会看一下第1部分，我们探索了RealityKit框架的基础——reality kit的<code class="fe mq mr ms mt b">ARView</code>解剖，实体，组件，材料，设置教练覆盖，光线投射，以及向我们基于增强现实的iOS应用程序添加一些3D手势。</p><p id="0e0d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们最终得到的应用程序能够向AR场景添加多个实体，但是它缺乏任何事件处理。像重叠的实体和相互移动实体这样的事情没有任何事件处理程序来显示冲突的发生。</p></div><div class="ab cl mu mv hv mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ik il im in io"><h1 id="01d3" class="lt lu ir bd lv lw nb ly lz ma nc mc md jx nd jy mf ka ne kb mh kd nf ke mj mk bi translated">我们的目标</h1><p id="2cc8" class="pw-post-body-paragraph kw kx ir ky b kz ml js lb lc mm jv le lf mn lh li lj mo ll lm ln mp lp lq lr ik bi translated">本文的目的是深入挖掘碰撞事件。我们将在我们的实体上设置各自的组件，并通过我们将在本文过程中构建的iOS应用程序来查看一些不同的冲突检测用例。</p><p id="13e5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这里，三个主要组件用于为RealityKit中的实体提供真实的类似对象的行为和感觉:</p><ul class=""><li id="2d71" class="ng nh ir ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated"><code class="fe mq mr ms mt b"><a class="ae ls" href="https://developer.apple.com/documentation/realitykit/collisioncomponent" rel="noopener ugc nofollow" target="_blank">CollisionComponent</a></code></li><li id="22f4" class="ng nh ir ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe mq mr ms mt b"><a class="ae ls" href="https://developer.apple.com/documentation/realitykit/physicsbodycomponent" rel="noopener ugc nofollow" target="_blank">PhysicsBodyComponent</a></code></li><li id="cc83" class="ng nh ir ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe mq mr ms mt b"><a class="ae ls" href="https://developer.apple.com/documentation/realitykit/physicsmotioncomponent" rel="noopener ugc nofollow" target="_blank">PhysicsMotionComponent</a></code></li></ul><p id="5ce0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们将在另一部分更深入地探讨物理学方面。现在，让我们在RealityKit中碰撞碰撞！</p><h1 id="f98d" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">现实套件碰撞</h1><p id="77ad" class="pw-post-body-paragraph kw kx ir ky b kz ml js lb lc mm jv le lf mn lh li lj mo ll lm ln mp lp lq lr ik bi translated">为了允许实体检测碰撞事件，我们需要先给实体添加一个<code class="fe mq mr ms mt b">CollisionComponent</code>。随后，我们将在AR场景中监听<a class="ae ls" href="https://developer.apple.com/documentation/realitykit/collisionevents" rel="noopener ugc nofollow" target="_blank">碰撞事件</a>，并处理碰撞的不同状态— <em class="nu">开始</em>、<em class="nu">接触</em>和<em class="nu">结束</em>。</p><p id="9cf5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了开始我们的旅程，启动Xcode并创建一个新的基于增强现实的iOS应用程序，然后选择RealityKit作为渲染引擎，SwiftUI作为用户界面类型。</p><p id="303c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">接下来，让我们用一个<code class="fe mq mr ms mt b">ModelComponent</code>(为了美观)和一个<code class="fe mq mr ms mt b">CollisionComponent</code>来设置我们的自定义实体框，这使我们的实体能够与其他有<code class="fe mq mr ms mt b">CollisionComponent</code>的实体碰撞。</p><pre class="kh ki kj kk gu nv mt nw nx aw ny bi"><span id="0718" class="nz lu ir mt b gz oa ob l oc od">import SwiftUI<br/>import RealityKit<br/>import Combine</span><span id="b7bf" class="nz lu ir mt b gz oe ob l oc od">class CustomEntity: Entity, HasModel, HasAnchoring, <strong class="mt is">HasCollision</strong> {<br/>    <br/>    <strong class="mt is">var collisionSubs: [Cancellable] = []</strong><br/>    <br/>    required init(color: UIColor) {<br/>        super.init()<br/>        <br/>        self.components[<strong class="mt is">CollisionComponent</strong>] = CollisionComponent(<br/>            shapes: [.generateBox(size: [0.5,0.5,0.5])],<br/>            <strong class="mt is">mode: .trigger</strong>,<br/>          <strong class="mt is">filter: .sensor</strong><br/>        )<br/>        <br/>        self.components[ModelComponent] = ModelComponent(<br/>            mesh: .generateBox(size: [0.5,0.5,0.5]),<br/>            materials: [SimpleMaterial(<br/>                color: color,<br/>                isMetallic: false)<br/>            ]<br/>        )<br/>    }<br/>    <br/>    convenience init(color: UIColor, position: SIMD3&lt;Float&gt;) {<br/>        self.init(color: color)<br/>        self.position = position<br/>    }<br/>    <br/>    required init() {<br/>        fatalError("init() has not been implemented")<br/>    }<br/>}</span></pre><p id="60a3" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在上面的代码中，我们做了相当多的事情。让我们仔细看看:</p><ul class=""><li id="41fa" class="ng nh ir ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated">符合<code class="fe mq mr ms mt b">HasCollision</code>协议对于启用实体内的冲突检测至关重要。</li><li id="532a" class="ng nh ir ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe mq mr ms mt b">collisionSubs</code>是一个保存实体冲突订阅的数组，我们很快就会看到。</li><li id="2112" class="ng nh ir ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">就像<code class="fe mq mr ms mt b">ModelComponent</code> s一样，<code class="fe mq mr ms mt b">CollisionComponent</code>也需要一个形状，它可以不同于可见实体的形状。通常，当您想要对进入我们当前实体附近的实体进行碰撞检测时，会为<code class="fe mq mr ms mt b">CollisionComponent</code>设置一个较大的尺寸。</li><li id="f85d" class="ng nh ir ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe mq mr ms mt b">CollisionMode</code>用于指示如何为实体收集碰撞数据— <code class="fe mq mr ms mt b">trigger</code>和<code class="fe mq mr ms mt b">default</code>是当前可用的两种内置模式。</li><li id="56bc" class="ng nh ir ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe mq mr ms mt b">CollisionFilter</code>作为一个筛选程序，用于确定需要检测碰撞的实体。它由三种类型组成— <code class="fe mq mr ms mt b">default</code>、<code class="fe mq mr ms mt b">sensor</code>(这与所有类型的实体相冲突)，以及一个自定义类型。我们可以通过设置一个<code class="fe mq mr ms mt b">CollisionGroup</code>来创建定制的<code class="fe mq mr ms mt b">CollisionFilter</code>——一个包含在实体中的位掩码。</li></ul><p id="c051" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">既然我们已经设置了带有<code class="fe mq mr ms mt b">CollisionComponent</code>的<code class="fe mq mr ms mt b">CustomEntity</code>类，让我们监听<code class="fe mq mr ms mt b">CollisionEvents</code>并相应地处理实体的状态。</p><h2 id="5ae8" class="nz lu ir bd lv of og dn lz oh oi dp md lf oj ok mf lj ol om mh ln on oo mj op bi translated">简单碰撞事件</h2><p id="1b04" class="pw-post-body-paragraph kw kx ir ky b kz ml js lb lc mm jv le lf mn lh li lj mo ll lm ln mp lp lq lr ik bi translated">在下面的代码中，我们明确地在我们已经订阅的<code class="fe mq mr ms mt b">Began</code>和<code class="fe mq mr ms mt b">Ended</code>事件中寻找<code class="fe mq mr ms mt b">CustomEntity</code>类型的实体。一旦碰撞开始，我们使用<code class="fe mq mr ms mt b">SimpleMaterial</code>改变其中一个实体的颜色——在碰撞结束后重置它。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oq or l"/></div></figure><p id="2e64" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">现在我们已经在实体上设置了碰撞事件，让我们在RealityKit场景中添加几个实体框，并见证碰撞:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oq or l"/></div></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj os"><img src="../Images/278034e76e68b1f287df577e2d39830f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jzUHS4JgVbyegrOoSFJSVA.gif"/></div></div></figure><blockquote class="ot ou ov"><p id="3168" class="kw kx nu ky b kz la js lb lc ld jv le ow lg lh li ox lk ll lm oy lo lp lq lr ik bi translated">注意:为了防止碰撞时两个实体重叠，我们需要使用<code class="fe mq mr ms mt b">PhysicsBodyComponent</code>。</p></blockquote><h2 id="1885" class="nz lu ir bd lv of og dn lz oh oi dp md lf oj ok mf lj ol om mh ln on oo mj op bi translated">与触发器体积碰撞(隐藏空间)</h2><p id="101f" class="pw-post-body-paragraph kw kx ir ky b kz ml js lb lc mm jv le lf mn lh li lj mo ll lm ln mp lp lq lr ik bi translated"><code class="fe mq mr ms mt b">TriggerVolumes</code>是不可见的3D形状，当实体进入或退出该体积时被触发。<code class="fe mq mr ms mt b">TriggerVolumes</code>是看不见的实体，这一事实可以在AR游戏的“寻宝”类游戏中加以利用(即解开谜团)。</p><p id="9ac5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe mq mr ms mt b">TriggerVolumes</code>扩展一个实体，默认符合<code class="fe mq mr ms mt b">HasCollision</code>协议。为了给你的现实装备场景添加一个<code class="fe mq mr ms mt b">TriggerVolume</code>，你需要遵守<code class="fe mq mr ms mt b">HasAnchoring</code>协议。你还需要以下面的方式把它放到场景中，以确保我们之前看到的<code class="fe mq mr ms mt b">addCollision</code>函数在检测<code class="fe mq mr ms mt b">CollisionEvents</code>时允许类型<code class="fe mq mr ms mt b">TriggerVolume</code>:</p><pre class="kh ki kj kk gu nv mt nw nx aw ny bi"><span id="2b2c" class="nz lu ir mt b gz oa ob l oc od">extension TriggerVolume : HasAnchoring{}</span><span id="66bc" class="nz lu ir mt b gz oe ob l oc od">let hiddenArea = TriggerVolume(shape: .generateBox(size: [0.3,0.3,0.3]), filter: .sensor)</span><span id="8bba" class="nz lu ir mt b gz oe ob l oc od">hiddenArea.position = [-0.5,-1.5, -3]</span><span id="c283" class="nz lu ir mt b gz oe ob l oc od">arView.scene.anchors.append(hiddenArea)</span></pre><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj os"><img src="../Images/f4305f956cdbba1c9a7c023519eb930e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PJtTCOkCAjDCBUHTWIz6Uw.gif"/></div></div></figure><h2 id="95ee" class="nz lu ir bd lv of og dn lz oh oi dp md lf oj ok mf lj ol om mh ln on oo mj op bi translated">碰撞过滤器和组</h2><p id="c35c" class="pw-post-body-paragraph kw kx ir ky b kz ml js lb lc mm jv le lf mn lh li lj mo ll lm ln mp lp lq lr ik bi translated">通常，只需要在某一组实体之间设置碰撞事件。不同<code class="fe mq mr ms mt b">CollisionFilter</code>的实体不会触发碰撞事件(一个<code class="fe mq mr ms mt b">CollisionFilter</code>由一个<code class="fe mq mr ms mt b">CollisionGroup</code>和<code class="fe mq mr ms mt b">Mask</code>组成)。一个<code class="fe mq mr ms mt b">CollisionFilter</code>很方便的场景是一个AR台球游戏(即知道条纹或固体是否有碰撞)。</p><p id="b054" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在下面的代码中，我们创建了一个新的球形实体，带有一个自定义的<code class="fe mq mr ms mt b">CollisionFilter</code>！</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oq or l"/></div></figure><p id="7a60" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">另一方面，我们已经将先前创建的box实体的<code class="fe mq mr ms mt b">CollisionComponent</code>的<code class="fe mq mr ms mt b">filter</code>属性更改为:</p><pre class="kh ki kj kk gu nv mt nw nx aw ny bi"><span id="c819" class="nz lu ir mt b gz oa ob l oc od">filter: CollisionFilter(group: CollisionGroup(rawValue: 1), mask: CollisionGroup(rawValue: 1)</span></pre><p id="8cfa" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">现在让我们将光线投射和<code class="fe mq mr ms mt b">ARCoachingOverlay</code>一起添加到我们的RealityKit场景中来检测一个水平面。我们将使用2D点交替添加盒子和球体实体到3D空间的场景中。我们将基于用户的手势和在<code class="fe mq mr ms mt b">GlobalVariables</code>结构中定义的全局属性:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oq or l"/></div></figure><blockquote class="ot ou ov"><p id="d14a" class="kw kx nu ky b kz la js lb lc ld jv le ow lg lh li ox lk ll lm oy lo lp lq lr ik bi translated">注意变化:现在在<code class="fe mq mr ms mt b">addCollision</code>函数中传递了<code class="fe mq mr ms mt b">scene</code>属性。</p></blockquote><p id="5468" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这种变化的原因是实体不再直接添加到场景的根锚点。实体被添加到光线投射锚，最终在场景中设置。所以为了允许实体使用<code class="fe mq mr ms mt b">self.scene</code>访问场景，我们在前面定义的<code class="fe mq mr ms mt b">CustomEntity</code>的<code class="fe mq mr ms mt b">addCollision</code>扩展函数中传递属性。</p><p id="a70c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">保存RealityKit的<code class="fe mq mr ms mt b">ARView</code>的SwiftUI <code class="fe mq mr ms mt b">ContentView</code>的代码如下所示:</p><pre class="kh ki kj kk gu nv mt nw nx aw ny bi"><span id="275b" class="nz lu ir mt b gz oa ob l oc od">struct ContentView : View {<br/>    var body: some View {<br/>        return ARViewContainer().edgesIgnoringSafeArea(.all)<br/>    }<br/>}</span><span id="f8df" class="nz lu ir mt b gz oe ob l oc od">struct ARViewContainer: UIViewRepresentable {<br/>    <br/>    func makeUIView(context: Context) -&gt; ARView {<br/>        <br/>        let arView = ARView(frame: .zero)<br/>        <br/>        let config = ARWorldTrackingConfiguration()<br/>        config.planeDetection = .horizontal<br/>        arView.session.run(config, options: [])<br/>        <br/>        arView.addCoaching()<br/>        arView.setupGestures()<br/>        return arView<br/>        <br/>    }<br/>    <br/>    func updateUIView(_ uiView: ARView, context: Context) {}<br/>}</span></pre><p id="8978" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe mq mr ms mt b">addCoaching</code>函数用于在onboarding期间设置教练覆盖以检测飞机(这在上一部分中讨论过，源代码中提供了实现)。</p><p id="0a98" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">让我们看看我们的RealityKit iOS应用程序在上面集成的<code class="fe mq mr ms mt b">CollisionFilters</code>和组中的运行情况。您会注意到，在下面的视频中，长方体和球体形状之间的碰撞事件没有订阅:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oz or l"/></div></figure></div><div class="ab cl mu mv hv mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ik il im in io"><h1 id="be8c" class="lt lu ir bd lv lw nb ly lz ma nc mc md jx nd jy mf ka ne kb mh kd nf ke mj mk bi translated">结论</h1><p id="b5f8" class="pw-post-body-paragraph kw kx ir ky b kz ml js lb lc mm jv le lf mn lh li lj mo ll lm ln mp lp lq lr ik bi translated">处理碰撞是任何增强现实应用程序中最常见的功能之一。我们看到了<code class="fe mq mr ms mt b">CollisionComponents</code>如何与<code class="fe mq mr ms mt b">ModelComponents</code>一起在让我们的实体表现得像真实物体方面发挥重要作用。一个<code class="fe mq mr ms mt b">CollisionComponent</code>让我们控制实体的碰撞形状。</p><p id="b001" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">此外，我们探索了<code class="fe mq mr ms mt b">TriggerVolume</code>——entity的一个子类，通常用于确定一个实体是否已经进入那个空间。最后，我们看到了如何通过使用碰撞组和过滤器来管理与场景中某些实体的选择性碰撞。</p><p id="69cb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">正如我们在第1部分中所做的扩展，以及在本文中所讨论的内容(特别是光线投射和教练叠加)，我们将在本系列的后续部分中做同样的事情。具体来说，我们将使用冲突的各种用例来为我们的AR应用程序添加更多的功能。</p><p id="1819" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">你可以在下面的<a class="ae ls" href="https://github.com/anupamchugh/iowncode/tree/master/RealityKitCollisions" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到我们在上面构建的RealityKit iOS应用程序的完整源代码。</p><p id="4782" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">这一次到此为止。感谢阅读，请继续关注下一部分。</p></div></div>    
</body>
</html>