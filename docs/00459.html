<html>
<head>
<title>Using Hooks to Replace Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用钩子代替Redux</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-hooks-to-replace-redux-392f98ca61b7?source=collection_archive---------1-----------------------#2019-05-25">https://betterprogramming.pub/using-hooks-to-replace-redux-392f98ca61b7?source=collection_archive---------1-----------------------#2019-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2bde" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过功能组件中的生命周期挂钩和状态管理，让您的生活更加轻松</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c586ab93a4a064d0074c047b000ecd6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EaJWU73IxftXFSADGnmmSg.png"/></div></div></figure><p id="df8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一名来自Vue的React开发初学者，我发现自己在与Redux和以正确的方式进行简单状态管理所需的所有样板文件作斗争:动作类型、动作生成器、正确的动作和reducers。如果你想简单地连接React，你必须安装另一个包react-redux，并学习如何使用它。之后，如果你想使用异步操作，你必须编写自己的redux中间件或者学习如何使用另一个包——redux-thunk…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lq"><img src="../Images/9ffed375fd5b687fc73e7f85dc06183a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEggcUNJxyQQNdvBQlXRUg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/photos/aZ9X3L1Va2Y?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae lv" href="https://unsplash.com/search/photos/frustration?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9052" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是随后反应伴随着钩子！钩子是神奇的小东西，它让你可以更容易地使用基于类的组件特性，比如生命周期钩子和功能组件中的状态管理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/373be479e21e5cdd48c33779316c04e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7gOX1JHNw5fUIKaK9ObSg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/photos/V3DokM1NQcs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Nghia Le </a>在<a class="ae lv" href="https://unsplash.com/search/photos/success?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1eb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中一个钩子是<code class="fe lx ly lz ma b">useReducer</code>。正如官方文档所述，<code class="fe lx ly lz ma b">useReducer</code>，</p><blockquote class="mb"><p id="5294" class="mc md it bd me mf mg mh mi mj mk lp dk translated"><em class="ml">接受一个</em> <code class="fe lx ly lz ma b"><em class="ml">(state, action) =&gt; newState</em></code> <em class="ml">类型的缩减器，并返回与</em> <code class="fe lx ly lz ma b"><em class="ml">dispatch</em></code> <em class="ml">方法配对的当前状态。(如果你熟悉Redux，你已经知道这是如何工作的。)</em></p></blockquote><p id="1262" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">我想知道——也许Redux被提及是有原因的，我可以用它来让<em class="mr">像Redux一样进行集中的</em>状态管理。为什么不用<code class="fe lx ly lz ma b">useState</code>？它做几乎同样的事情，但方式不同。React文档指出，当被调用时<code class="fe lx ly lz ma b">useState</code>返回一个有状态值和一个更新它的函数。</p><p id="fb76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为有一个基本的区别使得<code class="fe lx ly lz ma b">useReducer</code>和<code class="fe lx ly lz ma b">useState</code>更适合谈论<em class="mr">集中式</em>状态管理。使用<code class="fe lx ly lz ma b">useState</code>钩子，负责计算新状态的业务逻辑必须在所有更新状态的组件中。有了<code class="fe lx ly lz ma b">useReducer</code>,我们可以将所有的业务逻辑放在一个地方(reducer本身),这使得维护变得容易，并使组件专注于它们最初被设计来做的事情。另一个好处是，<code class="fe lx ly lz ma b">useReducer</code>钩子保持了Flux、Redux、Vuex和其他状态管理解决方案所使用的“分派动作来更新状态”模式。</p><p id="a0d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，我们有一个赢家。但是交易中的中央集权部分呢？<em class="mr"> </em>因为React有一个长期的解决方案，与所有组件共享一个状态:上下文。根据官方文件:</p><blockquote class="mb"><p id="9f6a" class="mc md it bd me mf mg mh mi mj mk lp dk translated"><em class="ml">上下文提供了一种通过组件树传递数据的方法，而不必在每一层手动向下传递属性。</em></p></blockquote><p id="b817" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">这是一种单向的、共享的、集中的状态，组件在发生变化时会对其做出反应。现在有了<code class="fe lx ly lz ma b">useContext</code>挂钩。看来我们已经为这项工作选择了最好的工具——让我们让它们一起工作吧。</p><p id="0904" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们将使用<em class="mr">“又老又无聊”</em>递增递减计数器应用程序。我们有3个组件由一个高阶组件(<code class="fe lx ly lz ma b">App</code>本身)连接。其中一个用于显示计数器的值，另外两个用于更新计数器。下面是工作应用程序的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3dbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简单起见，我在一个文件中写了这个例子——在一个真正的应用程序中，这些组件应该在不同的文件中。</p><p id="cade" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的工作是替换从<code class="fe lx ly lz ma b">App</code>组件传递到另一个组件的道具，并保持应用程序的功能。</p><p id="7605" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们可以利用<code class="fe lx ly lz ma b">useContext</code>替换<code class="fe lx ly lz ma b">Display</code>组件上的道具:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="aa47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，正如您可以通过执行代码来检查的那样，我们失去了递增/递减功能，因为上下文不能被其使用者更新。</p><p id="8937" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是我们使用<code class="fe lx ly lz ma b">useReducer</code>的地方。正如我之前所说的，<code class="fe lx ly lz ma b">useReducer</code>函数返回状态和dispatch函数，可以用来调度将更新状态的动作。</p><p id="4bb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">受返回具有两个值的数组的钩子的启发，我们将使用<code class="fe lx ly lz ma b">Context</code>来共享实际状态和分派函数，这两个值可以被析构并归属于两个单独的变量。</p><p id="4d2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们必须编写一个reducer来替换<code class="fe lx ly lz ma b">App</code>组件中的<code class="fe lx ly lz ma b">addToCounter</code>函数。</p><p id="0e08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">必须添加的最后一个部分是一个高阶组件，以利用<code class="fe lx ly lz ma b">useReducer</code>钩子并将状态和调度设置为上下文值，因为<code class="fe lx ly lz ma b">React</code>钩子只能在组件内部调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ec5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，我们的应用程序又开始工作了。</p><p id="9e00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是异步函数呢？Reducers应该是纯函数，所以我们不能使用async await并等待承诺来解析，然后根据解析结果更新状态。</p><p id="d005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们可以使用类似redux-thunk这样更简单的工具。我们为<code class="fe lx ly lz ma b">useReducer</code>分派方法构建了一个包装函数，它检查有效负载是否是一个承诺，解析它，然后分派期望的动作。为此，我们必须致力于<code class="fe lx ly lz ma b">CounterContextProvider</code>并实现我们的“中间件”。我们将实现一个异步，它将在按钮被点击一秒后递增计数器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="863c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">终于来了！一种集中式状态管理代码，可用于共享状态，并调度更新状态的操作，无论是同步还是异步。</p><p id="99b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能认为这个项目代码太多，props的解决方案更精简——但这只是一个例子，向你展示它是如何完成的。当然，在这样的应用中，使用它没有多大意义。然而，在有些情况下，您的应用程序可能更复杂，您不想安装和学习如何使用其他3个包(redux、react-redux和redux-thunk)来管理应用程序的状态。</p><p id="806d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一点:这个例子并不意味着Redux就是发电站，也不是Redux在所有项目上的替代品。存在非常真实和故意的限制。对于需要强大功能的大型项目，应该使用Redux。如果您有一个较小的项目或一个初级开发人员团队，这个例子可能适合。</p></div></div>    
</body>
</html>