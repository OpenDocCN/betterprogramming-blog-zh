<html>
<head>
<title>How to Use Express to Build a REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Express构建REST API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-express-to-build-a-rest-api-69bd4abb8e4a?source=collection_archive---------12-----------------------#2020-01-16">https://betterprogramming.pub/use-express-to-build-a-rest-api-69bd4abb8e4a?source=collection_archive---------12-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="539a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Node中构建可伸缩API的介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/648044cf47725a67440038aadb709ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0O-eqJRpmALF6PHd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément H </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://www.webtips.dev/how-to-use-express-to-build-a-rest-api"><div class="gh gi kz"><img src="../Images/c19cb3069af1beba3c93258d9fcfe139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*-PVzecNs3s4ZbJsdsgIsGA.png"/></div></a></figure><p id="613e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你知道吗，根据JS 的<a class="ae ky" href="https://2019.stateofjs.com/back-end/" rel="noopener ugc nofollow" target="_blank">状态，2019年Express在知名度、兴趣和满意度方面排名第一，这项年度调查有超过20，000名受访者。它主要用于为web创建健壮的API，通过其灵活的API快速而容易地实现。</a></p><p id="f0da" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">API是不同软件组件之间通信的常用手段。它们提供了一种在两个应用程序之间交换数据的简单方法。在我们的例子中，这是在浏览器和数据库之间。在本教程中，我们将使用Express在Node中构建一个可伸缩的REST API。</p><p id="034d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了简单起见，我们将使用经典的todo示例。我们将构建一个API来存储、检索、修改和删除待办事项。每个操作将由不同的HTTP请求方法处理。我们的第一项工作将是建立快递。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="27fe" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">设置Express</h1><p id="feab" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">为了使本教程简明易懂，我将使用<code class="fe na nb nc nd b">LocalStorage</code>替换数据库功能。当然，我们在node中没有这个，所以我们必须填充它。这意味着我们将有两个依赖项:<code class="fe na nb nc nd b"><a class="ae ky" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank">express</a></code>和<code class="fe na nb nc nd b"><a class="ae ky" href="https://www.npmjs.com/package/node-localstorage" rel="noopener ugc nofollow" target="_blank">node-localstorage</a></code>。<code class="fe na nb nc nd b">npm init -y</code>您的项目，并将它们添加到您的依赖项中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1fc4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我还把默认脚本换成了<code class="fe na nb nc nd b">node server.js</code>；这是我们将在其中设置Express服务器的文件。在根目录下创建<code class="fe na nb nc nd b">server.js</code>文件，并在其中添加以下几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="23c3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以用传入端口的<code class="fe na nb nc nd b">app.listen</code>来启动web服务器；从命令行或默认为8080。现在没什么发生。如果你打开<code class="fe na nb nc nd b">localhost:8080</code>，你会看到服务器没有返回任何东西。所以让我们改变这一点，增加一些路线！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/64d0262fbab9820c518525ef6b2e328a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*UF2BENGcVyRNPDbf7E-jyA.png"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e179" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">创建路线</h1><p id="9560" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">对于路由，我创建了一个名为<code class="fe na nb nc nd b">routes</code>的单独目录，并添加了一个<code class="fe na nb nc nd b">index.js</code>。我们将有四个不同的端点:</p><ul class=""><li id="a8fb" class="nh ni it lc b ld le lg lh lj nj ln nk lr nl lv nm nn no np bi translated"><code class="fe na nb nc nd b">GET</code>用于获取所有或单个待办事项</li><li id="c164" class="nh ni it lc b ld nq lg nr lj ns ln nt lr nu lv nm nn no np bi translated"><code class="fe na nb nc nd b">POST</code>用于创建新的待办事项</li><li id="47fe" class="nh ni it lc b ld nq lg nr lj ns ln nt lr nu lv nm nn no np bi translated"><code class="fe na nb nc nd b">PUT</code>用于更新现有待办事项</li><li id="0837" class="nh ni it lc b ld nq lg nr lj ns ln nt lr nu lv nm nn no np bi translated"><code class="fe na nb nc nd b">DELETE</code>用于删除特定的待办事项</li></ul><p id="4bcd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这就是我们的<code class="fe na nb nc nd b">routes/index.js</code>的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f7d7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe na nb nc nd b">routes</code>将是一个获取express应用程序作为参数的函数。<code class="fe na nb nc nd b">app</code>变量公开了一个<code class="fe na nb nc nd b">route</code>方法，该方法接受一个端点作为参数。我们可以使用冒号来指定路由参数。通过在末尾添加一个问号，我们可以告诉express这只是一个可选的参数。</p><p id="ae72" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在<code class="fe na nb nc nd b">route</code>上，我们可以链接不同的HTTP请求方法。对于每个方法，我们将执行不同的函数。这些方法来自于<code class="fe na nb nc nd b">Todo.js</code>下控制器文件夹中定义的一个对象，所以这将是我们的下一步。</p><p id="5a14" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是首先，要实际告诉Express使用这些路线，请返回到您的<code class="fe na nb nc nd b">server.js</code>文件，并使用以下内容扩展它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a156" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我已经导入了<code class="fe na nb nc nd b">routes</code>并传递了Express <code class="fe na nb nc nd b">app</code>给它。现在，如果你导航到<code class="fe na nb nc nd b">localhost:8080/todo</code>，它将调用<code class="fe na nb nc nd b">todo.get</code>方法，我们还没有指定，所以让我们现在就这样做。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e8f8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">请求和回应</h1><p id="0ec6" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">如果还没有，创建一个<code class="fe na nb nc nd b">controllers</code>文件夹并添加一个<code class="fe na nb nc nd b">Todo.js</code>文件。我们将为这四个请求导出一个包含四个方法的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c7dd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">每个方法将访问一个<code class="fe na nb nc nd b">request</code>和<code class="fe na nb nc nd b">response</code>对象。我们还需要导入<code class="fe na nb nc nd b">LocalStorage</code>包，因为我们将使用它来代替真正的数据库。它会自动在根目录下为你创建一个<code class="fe na nb nc nd b">db</code>文件夹。</p><p id="babc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们按顺序进行，看看如何使用<code class="fe na nb nc nd b">get</code>方法返回到dos。</p><h2 id="fee4" class="nv me it bd mf nw nx dn mj ny nz dp mn lj oa ob mp ln oc od mr lr oe of mt og bi translated">获取路线</h2><p id="58e7" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">我们希望根据URL中是否提供了id来获取全部或特定的todo。我们还想检查我们是否有一个<code class="fe na nb nc nd b">localStorage</code>项目集，这样我们就不会以一个错误结束。这留给我们以下检查:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9590" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要获得URL参数，我们只需访问<code class="fe na nb nc nd b">request.params</code>对象。属性的名称将是在<code class="fe na nb nc nd b">app.route</code>中指定的名称。<em class="oh"> ( </em> <code class="fe na nb nc nd b"><em class="oh">:id</em></code> <em class="oh"> ) </em>要返回一个JSON响应，我们可以用一个我们想要返回的对象调用<code class="fe na nb nc nd b">response.json</code>作为响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="77f5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果<code class="fe na nb nc nd b">localStorage</code>里连<code class="fe na nb nc nd b">todos</code>都没有，我们可以返回一个空数组。否则，我们可以返回存储在localStorage中的项目。由于我们只能存储字符串，我们需要在对象上调用<code class="fe na nb nc nd b">JSON.parse</code>。当我们想要访问单个todo时，情况也是如此。但是这一次，我们还想筛选单个项目。</p><p id="5537" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你刷新页面，你会得到一个空的<code class="fe na nb nc nd b">todo</code>列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/241cce4fa9adac12e29b37ff438c2959.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*p9S2-hu5uli8SfnkR-sznQ.png"/></div></figure><h2 id="dd34" class="nv me it bd mf nw nx dn mj ny nz dp mn lj oa ob mp ln oc od mr lr oe of mt og bi translated">邮寄路线</h2><p id="d3c4" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">让我们用一些项目填充数组。这一次，我们希望使用<code class="fe na nb nc nd b">x-www-form-urlencoded</code>内容类型发送请求数据。由于我们不能在没有任何前端的情况下直接在浏览器中发送<code class="fe na nb nc nd b">POST</code>请求，我们需要找到另一种方法。对于这个任务，我正在使用流行的<a class="ae ky" href="https://www.getpostman.com/downloads/" rel="noopener ugc nofollow" target="_blank">邮递员</a>应用程序。你可以免费下载安装。</p><p id="c732" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">打开应用程序并创建新请求。将方法类型设置为<code class="fe na nb nc nd b">POST</code>，将主体设置为<code class="fe na nb nc nd b">x-www-form-urlencoded</code>。如果已经提供了一个<code class="fe na nb nc nd b">name</code>和一个<code class="fe na nb nc nd b">completed</code>标志，我们只想添加一个新的todo。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/3f66af15baedcc4035e49e6645e31b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/1*SlDUMDSbRHu0Lr5G4NVW4g.gif"/></div></figure><p id="8b00" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了从Express内部的请求中获取值，我们可以访问<code class="fe na nb nc nd b">request.body</code>。然而，如果您发送一个post请求并尝试注销<code class="fe na nb nc nd b">request.body</code>，您会注意到它是<code class="fe na nb nc nd b">undefined</code>。这是因为默认情况下express不能处理URL编码的值。为了通过JavaScript访问它们，我们必须使用中间件。在定义路线之前，将以下行添加到您的<code class="fe na nb nc nd b">server.js</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bdc4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，如果您发送<code class="fe na nb nc nd b">POST</code>请求并尝试再次注销<code class="fe na nb nc nd b">request.body</code>，您将获得注销到控制台的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/9ab616c432012055ed42f9dc95f3693e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/1*tx_GMMffHZeBDr1RDnStlg.gif"/></div></figure><p id="e5c1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，我们可以从检查请求中是否有这两个值开始，如果没有，我们可以发送一个错误来指出问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a851" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们想要添加一个新条目的方法是，我们只是想从localStorage获取<code class="fe na nb nc nd b">todos</code>(如果有的话),解析JSON并将一个新对象推送到数组中。然后将其转换回JSON，当然，发送一个响应让我们知道我们是否成功了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fefa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意，由于我们可能在localStorage中没有<code class="fe na nb nc nd b">todos</code>,我们需要返回到一个空数组。还要注意，因为我们得到的请求是字符串，所以我们需要将<code class="fe na nb nc nd b">completed</code>标志转换为布尔值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/b1820d55f758706b9931ca0d4000ce70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XkHaWmnncArA2MR_YLs3Rg.gif"/></div></div></figure><h2 id="1860" class="nv me it bd mf nw nx dn mj ny nz dp mn lj oa ob mp ln oc od mr lr oe of mt og bi translated">放置路线</h2><p id="c877" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">一旦我们的待办事项列表中有了足够多的项目，我们就可以尝试更新它们。同样，我们需要检查id和<code class="fe na nb nc nd b">name</code>或<code class="fe na nb nc nd b">completed</code>标志的存在。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0280" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们希望遵循与对<code class="fe na nb nc nd b">create</code>方法类似的逻辑:解析localStorage数据，更新数组中id与作为请求参数传递的id相匹配的条目，将数据转换回JSON并发送成功响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="840c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请记住，我们希望将<code class="fe na nb nc nd b">completed</code>标志转换为布尔值。我们不能像对<code class="fe na nb nc nd b">todo.name</code>那样做逻辑OR的原因是，如果我们想让<code class="fe na nb nc nd b">completed</code>设置为假，它总是会回到默认的<code class="fe na nb nc nd b">todo.completed</code>值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/90305f587a9f507509629d03ce9c1138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UWelx-77jQZHLJgoQXj7LQ.gif"/></div></div></figure><h2 id="a4c8" class="nv me it bd mf nw nx dn mj ny nz dp mn lj oa ob mp ln oc od mr lr oe of mt og bi translated">删除路线</h2><p id="0e8d" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">可能所有方法中最短最简单的是<code class="fe na nb nc nd b">delete</code>。我们所要做的就是过滤掉id与传入端点的id相匹配的项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="798e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">并将它的字符串版本重新分配给localStorage中的<code class="fe na nb nc nd b">todos</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/8fe7d1696b42d89389211c98e063bd20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6rE4UJqXCgfMiCxRUf_hWQ.gif"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6771" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="a5a2" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">现在，您已经有了一个处理todo项的工作API。我会把UI部分留给你。这种方法的优点是每个操作都被分成不同的方法。这样，您的API更容易扩展。这也有助于减少寻找bug的时间。如果您遇到某个请求的问题，您可以快速查明哪里出了问题。你就会知道问题出在一个单一的函数上。</p><p id="919a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你想知道我在整个教程中得到的JSON响应的外观和感觉，我正在使用<a class="ae ky" href="https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh" rel="noopener ugc nofollow" target="_blank"> JSON Viewer </a> Chrome扩展，你可以从提供的链接中获得。如果你想弄乱最终项目，你可以在<a class="ae ky" href="https://github.com/flowforfrank/express-api" rel="noopener ugc nofollow" target="_blank"> express-api </a> Github repo找到它。</p><p id="26e4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">感谢您通读。无论你是否有构建API和使用Express的经验，请在下面的评论中分享你的想法，让我们知道你的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://medium.com/@ferencalmasi/membership"><div class="gh gi on"><img src="../Images/e66c4cd6d9849ac0bd245f3fc39b65c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZ9xuLqLkbqUG65sgVB3gg.png"/></div></a></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://www.webtips.dev/how-to-secure-your-api-with-json-web-tokens"><div class="gh gi oo"><img src="../Images/c3b1f59f2d770fee024bbcd141f3995a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*lCiKyc-wOVLjDx6swaFlgA.png"/></div></a></figure></div></div>    
</body>
</html>