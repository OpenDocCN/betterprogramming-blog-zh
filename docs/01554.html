<html>
<head>
<title>Design Patterns: Using the Strategy Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:在JavaScript中使用策略模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-patterns-using-the-strategy-pattern-in-javascript-3c12af58fd8a?source=collection_archive---------1-----------------------#2019-09-24">https://betterprogramming.pub/design-patterns-using-the-strategy-pattern-in-javascript-3c12af58fd8a?source=collection_archive---------1-----------------------#2019-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf10" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设计模式系列—第1部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ed1b60679228ff0ef3dee86c7caca06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2lPadnzPghjzZztk"/></div></div></figure><p id="1979" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">书中描述了23种经典设计模式<code class="fe lq lr ls lt b">Design Patterns: Elements of Reusable Object-Oriented Software</code>。这些模式为软件开发中重复出现的特定问题提供了解决方案。</p><p id="3cf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将探讨<em class="lu">战略模式</em>——它是如何运作的，如何以及何时应用。这种模式在其他上下文中称为<em class="lu">策略</em> <strong class="kw iu"> </strong>。</p><h1 id="c67c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">战略模式:基本理念</h1><blockquote class="mn mo mp"><p id="cce9" class="ku kv lu kw b kx ky ju kz la lb jx lc mq le lf lg mr li lj lk ms lm ln lo lp im bi translated"><em class="it">策略模式是一种行为设计模式，能够在运行时选择算法</em></p></blockquote><p id="f837" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lu"> —维基百科</em></p><blockquote class="mn mo mp"><p id="c93e" class="ku kv lu kw b kx ky ju kz la lb jx lc mq le lf lg mr li lj lk ms lm ln lo lp im bi translated"><em class="it">定义一族算法，封装每一个，使它们可以互换。策略让算法独立于使用它的客户端而变化。</em></p></blockquote><p id="851c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lu"> —设计模式:可复用面向对象软件的要素</em></p><p id="2239" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种模式的主要特征是客户端有一组算法，在运行时将选择一个特定的算法来使用。这些算法可以在它们之间互换。</p><p id="dcd5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的代码展示了一个经典的问题，你需要在你的应用中选择一个具体的算法。在这段代码中，您可以使用任何编程语言的<code class="fe lq lr ls lt b">switch</code>控制结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/9fe5be1ae239b5b4831a4c851c7f8ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ekcNrnNBBwdJrbU8.png"/></div></div></figure><p id="f2df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，使用<em class="lu">策略模式</em> <strong class="kw iu"> </strong>可以更加灵活，该模式采用以下结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/4a4d53dd0249e378e4cb295c4d1729db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tqdf-Z_aIGQkXc0R.png"/></div></div></figure><p id="0561" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种模式的UML图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/10bacfb2c064cb23702b40b8e270e47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:76/0*HhL8EVCmMlxI43GH"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/c4ce559b1e220c5e8de6060570dcb510.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/0*dkcF7NijpcczHo82.png"/></div></figure><p id="8e4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个策略都用一个具体的对象来表示。因此，客户端/上下文包含一个实现接口<code class="fe lq lr ls lt b">Strategy</code>的<code class="fe lq lr ls lt b">Strategy</code>对象(<code class="fe lq lr ls lt b">concreteStrategyA</code>、<code class="fe lq lr ls lt b">concreteStrategyB</code>、…)。关键的交换在于在上下文中实现一个方法，该方法改变策略的实例。比如:<code class="fe lq lr ls lt b">setStrategy</code>。</p><h1 id="a0e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">何时使用策略模式</h1><ol class=""><li id="8ba6" class="mx my it kw b kx mz la na ld nb lh nc ll nd lp ne nf ng nh bi translated">当你需要使用几种不同的算法时。您需要创建一个具体的类来实现您的算法(它可以由<code class="fe lq lr ls lt b">a</code>或<code class="fe lq lr ls lt b">some</code>函数组成)。</li><li id="51a2" class="mx my it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">当围绕几个相关算法有条件语句时。</li><li id="cc85" class="mx my it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">当你的大部分课程都有相关行为时。</li></ol><h1 id="b5ce" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">战略模式的优势</h1><p id="d968" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">策略模式有几个优点:</p><ul class=""><li id="168a" class="mx my it kw b kx ky la lb ld nq lh nr ll ns lp nt nf ng nh bi translated">运行时在不同算法<strong class="kw iu"> </strong>(策略)之间切换很容易，因为你在接口中使用了多态性。</li><li id="968c" class="mx my it kw b kx ni la nj ld nk lh nl ll nm lp nt nf ng nh bi translated">清理代码<strong class="kw iu"> </strong>因为你避免了有条件感染的代码(不复杂)。</li><li id="cb25" class="mx my it kw b kx ni la nj ld nk lh nl ll nm lp nt nf ng nh bi translated">更干净的代码，因为您将关注点分成了类(每个策略一个类)。</li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="a2b3" class="lv lw it bd lx ly ob ma mb mc oc me mf jz od ka mh kc oe kd mj kf of kg ml mm bi translated">策略模式:使用JavaScript的基本实现</h1><p id="df6f" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">我将向您展示如何用JavaScript实现这种模式。记住:Javascript缺少接口——您需要编写一个名为<code class="fe lq lr ls lt b">StrategyManager</code>的类，它被用作接口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/2ef0697404f4f641140c7e590df82c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tGC30XtpdyYkVym3.png"/></div></div></figure><p id="ddb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个类包含一个名为<code class="fe lq lr ls lt b">_strategy</code>的私有属性，它代表所使用的策略。方法<code class="fe lq lr ls lt b">doAction</code>会落实到每一个具体的策略中。策略模式不同于JavaScript中的UML，它缺少面向对象的特性。</p><p id="e1f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个具体策略的实施如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/2db243167f2ac35a1a4f1266e9969640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*21zj2347tZtVXUOp.png"/></div></div></figure><p id="3c5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，具体方法<code class="fe lq lr ls lt b">doAction</code>是在每个具体策略中实现的。</p><p id="0cc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，上下文/客户端必须包含<code class="fe lq lr ls lt b">StrategyManager</code>(或者策略接口是面向对象语言)才能使用具体的策略:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/1bea9a007d5207658347f48b3f277412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oo2C989f73PpWxRQ.png"/></div></div></figure><h1 id="a10d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">策略模式:使用JavaScript的一组策略</h1><p id="66ea" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nn lf lg lh no lj lk ll np ln lo lp im bi translated">在下面的实现中，我们的<code class="fe lq lr ls lt b">StrategyManager</code>变得更加复杂，包含一系列算法。在这种情况下，您可以更改属性<code class="fe lq lr ls lt b">_strategy</code>，而不是名为<code class="fe lq lr ls lt b">_strategies</code>的数组。</p><p id="432f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，使用方法<code class="fe lq lr ls lt b">addStrategy</code>在策略列表中添加新的策略。<code class="fe lq lr ls lt b">Strategy</code>类有两个属性:1。策略的名称和2。算法(名为<code class="fe lq lr ls lt b">handler</code>)。方法<code class="fe lq lr ls lt b">doAction</code>用于调用具体的算法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/c6a2054c08429a5cbf30f82ad9f93bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7Q4QV6fXp_it4IDm.png"/></div></div></figure><p id="6455" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们使用具体策略的客户端/上下文代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/c1507268a55e656c1dc458e1f28337a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LdqQZciDhrvcVS48.png"/></div></div></figure><p id="d918" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一部分是创建具体的策略(可以使用<code class="fe lq lr ls lt b">Singleton</code>模式和<code class="fe lq lr ls lt b">Factory</code> <strong class="kw iu"> </strong>模式构建)并添加到<code class="fe lq lr ls lt b">strategyManager</code> <strong class="kw iu"> </strong>(可以是我们的接口)。客户端的下一部分是选择要使用的策略——可以从我们的应用程序中使用GUI或CLI选择该策略。</p><p id="1c81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，请注意，如果选择了不支持的策略，系统将返回一个错误。当您想要为您的系统提供高级算法时，可以使用这种方法。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="cf74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢这篇文章，并想阅读类似的文章，别忘了鼓掌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/826581e5d9d84c9ac865ff50de96d060.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/1*vMyFTOWtr9c252J4X1FW6g.gif"/></div></div><p class="ol om gj gh gi on oo bd b be z dk translated">点按并拖移以不止一次鼓掌。50是极限。</p></figure><p id="4db9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您需要选择具体的算法时，策略模式可以帮助您避免代码中的复杂性。在这篇文章中，我用JavaScript语言展示了一个简单的实现，它没有接口。如果你使用一种带有接口的编程语言，你可以遵循这个模式的UML。</p><p id="b22c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最重要的是，不要只是实现我在这里展示的模式。您需要知道模式解决的问题是什么，以及为什么您应该使用它。实现会因编程语言而异。</p></div></div>    
</body>
</html>