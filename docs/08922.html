<html>
<head>
<title>How To Implement @propertyWrapper, WrappedValue, and ProjectedValue in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中实现@propertyWrapper、WrappedValue和ProjectedValue</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-propertywrapper-wrappedvalue-and-projectedvalue-in-swift-c7aa89b0979e?source=collection_archive---------8-----------------------#2021-06-25">https://betterprogramming.pub/how-to-implement-propertywrapper-wrappedvalue-and-projectedvalue-in-swift-c7aa89b0979e?source=collection_archive---------8-----------------------#2021-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8896" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Swift中使用@propertywrapper编写干净的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97a2556034799b2ed227f945416e6eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0pKoTZJ9eonRmKwe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@christinhumephoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·休姆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kz la lb"><p id="14e2" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">"属性包装在管理属性存储方式的代码和定义属性的代码之间添加了一层隔离层。"— <a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html" rel="noopener ugc nofollow" target="_blank"> Swift文档</a></p></blockquote><p id="8709" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">它将额外的逻辑封装到属性中，并限制对可用属性值的访问。</p><p id="732e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe mc md me mf b">@propertyWrapper</code>在Swift 5.1中引入Swift。现在，您可以实现一个包装器，并以更自然的方式使用包装的属性，而不会注意到包装层，就像它是一个普通的属性一样。让我们看看如何使用这个新语法。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="e983" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">假设您正在创建一个代表每个客户数据的<code class="fe mc md me mf b">Customer</code> <strong class="lf iu"> </strong>类型<strong class="lf iu"> </strong>。</p><pre class="kj kk kl km gt mn mf mo mp aw mq bi"><span id="2b14" class="mr ms it mf b gy mt mu l mv mw">struct Customer { <br/>    var name: String<br/>    var address: String <br/>    var postcode: String<br/>}</span></pre><p id="cb59" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是您希望对邮政编码的格式添加一些约束，因为有效的邮政编码必须符合特定的格式。</p><p id="0632" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">例如，它应该是数字和大写字母的组合，在外向代码和内向代码之间有一个空格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/9e4ff7730a5ffe663bcba944466d44cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*trkpImaGZ9KkBUdrZcDOZg.png"/></div></figure><p id="ec2e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果输入的邮政编码有效，该值将分配给<code class="fe mc md me mf b">postcode</code>；否则，<code class="fe mc md me mf b">postcode</code>的值将是一串“无效的邮政编码”</p><p id="d877" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为了封装这个逻辑，您决定创建一个属性包装器。</p><h1 id="f889" class="my ms it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">老办法</h1><p id="7cb9" class="pw-post-body-paragraph lc ld it lf b lg np ju li lj nq jx ll lz nr lo lp ma ns ls lt mb nt lw lx ly im bi translated">在引入<code class="fe mc md me mf b">@propertyWrapper</code>之前，你必须创建一个类型<code class="fe mc md me mf b">Postcode</code>来包装这个逻辑。<code class="fe mc md me mf b">Customer</code>的属性<code class="fe mc md me mf b">postcode</code>将是一个<code class="fe mc md me mf b">Postcode</code>对象而不是一个<code class="fe mc md me mf b">String</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="347e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">输入邮政编码的验证将在<code class="fe mc md me mf b">Postcode</code>内处理。computed属性<code class="fe mc md me mf b">value</code>将是唯一的接口，通过它可以在这个结构之外访问邮政编码值。</p><p id="5411" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当用一个<code class="fe mc md me mf b">String</code>值初始化一个<code class="fe mc md me mf b">Postcode</code>实例时，输入值将被存储在私有属性<code class="fe mc md me mf b">inputValue</code>中。</p><p id="bf85" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">每当调用<code class="fe mc md me mf b">value</code>时，它都会验证并返回邮政编码值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0c59" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">使用这个包装器，您必须通过<code class="fe mc md me mf b">customer.postcode.value</code>访问邮政编码值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="1062" class="my ms it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">新方法:@propertyWrapper</h1><p id="dae1" class="pw-post-body-paragraph lc ld it lf b lg np ju li lj nq jx ll lz nr lo lp ma ns ls lt mb nt lw lx ly im bi translated">现在，我们能够以更优雅的方式包装价值。</p><p id="78da" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">首先是在定义类型<code class="fe mc md me mf b">Postcode</code>时，在<code class="fe mc md me mf b">struct</code>之前添加语法<code class="fe mc md me mf b">@propertyWrapper</code>。</p><p id="04a8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在这种类型中，您必须定义一个名为<code class="fe mc md me mf b">wrappedValue</code>的计算属性来包装值<strong class="lf iu">。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="715f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果您创建了一个接受参数来初始化<code class="fe mc md me mf b">wrapperValue</code>的初始化器，请记住使用<code class="fe mc md me mf b">wrappedValue</code>作为您的初始化参数的名称。否则，当您初始化<code class="fe mc md me mf b">Customer</code>实例时，您可能会遇到此错误<em class="le">“</em>无法将类型为“String”的值转换为预期的参数类型“Postcode”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/54863059aa5899c4eeadd72d1b73b163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8HOlcw0voFaMoLOZnAj7g.png"/></div></div></figure><p id="117b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在结构<code class="fe mc md me mf b">Customer</code>中，您可以通过在属性之前添加包装器的名称(本例中为<code class="fe mc md me mf b">@Postcode</code>)作为属性，将包装器应用于属性<code class="fe mc md me mf b">postcode</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d50b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当您初始化<code class="fe mc md me mf b">Customer</code>实例并访问其<code class="fe mc md me mf b">postcode</code>属性时，您可以像它是一个普通的<code class="fe mc md me mf b">String</code>对象一样进行操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="c542" class="my ms it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">预计价值</h1><p id="cb06" class="pw-post-body-paragraph lc ld it lf b lg np ju li lj nq jx ll lz nr lo lp ma ns ls lt mb nt lw lx ly im bi translated">除了包装的值之外，属性包装器还可以通过定义名为<code class="fe mc md me mf b">projectedValue</code>的属性来公开附加信息。有一个预测值是可选的。</p><p id="5f4c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在这个例子中，有时您想知道无效邮政编码的原始值。在这种情况下，您可以利用预测值。</p><p id="0b51" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">滚动回到<code class="fe mc md me mf b">@propertyWrapper struct Postcode</code>的定义。您可以找到这行代码:</p><pre class="kj kk kl km gt mn mf mo mp aw mq bi"><span id="69fc" class="mr ms it mf b gy mt mu l mv mw">var projectedValue: String? = nil</span></pre><p id="ef6e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果邮政编码的值无效，其原始输入值将分配给<code class="fe mc md me mf b">projectedValue</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4794" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">投影值的名称是以$符号开头的包装值的名称。在本例中，您可以通过<code class="fe mc md me mf b">customer.$postcode</code>访问预测值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="24b1" class="my ms it bd mz na nx nc nd ne ny ng nh jz nz ka nj kc oa kd nl kf ob kg nn no bi translated">参考</h1><div class="oc od gp gr oe of"><a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">属性-Swift编程语言(Swift 5.5)</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">属性将值与特定的类、结构或枚举相关联。存储的属性存储常量和…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">docs.swift.org</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">Swift | Sundell Swift中的财产包装</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">当处理代表某种状态的属性时，通常会有某种关联的逻辑…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.swiftbysundell.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://www.toptal.com/swift/wrappers-swift-properties" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">Swift中的财产包装</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">简单地说，属性包装器是一种通用结构，它封装了对属性的读写访问，并且…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.toptal.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://nshipster.com/nspredicate/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">n重定向</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">NSPredicate是一个基础类，它指定应该如何提取或过滤数据。它的查询语言是…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">nshipster.com</p></div></div><div class="oo l"><div class="ow l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>