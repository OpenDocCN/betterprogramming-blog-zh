<html>
<head>
<title>Lesser-Known JavaScript Hazards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">鲜为人知的JavaScript危害</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lesser-known-javascript-hazards-8d688a463b1f?source=collection_archive---------4-----------------------#2019-10-30">https://betterprogramming.pub/lesser-known-javascript-hazards-8d688a463b1f?source=collection_archive---------4-----------------------#2019-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae03" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">箭头函数和对象文字、绑定、浅集等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a4e8a65f4aa575674259dd2647820505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejm8QMy1gcPbF0_bdull3w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@gohrhyyan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">吴礼仁</a>在<a class="ae ky" href="https://unsplash.com/s/photos/warning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从我们克服了<a class="ae ky" href="https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_(abandoned)" rel="noopener ugc nofollow" target="_blank"> Harmony </a>之后，JavaScript就有了很多新的、令人愉悦的特性。虽然更多的特性可以让我们编写出可读的、高质量的代码，但是我们也很容易过分追求新奇的东西，并陷入一些潜在的陷阱。</p><p id="4d68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一些我经常看到的困惑来源，不管是新的还是旧的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0fcf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">箭头函数和对象文字</h1><p id="7e08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank"> Arrow functions </a>提供了一个更简洁的语法，其中一个可用的特性是你可以把你的函数写成一个带有隐式返回值的lambda表达式。这对于函数式代码来说很方便，比如当你必须使用函数来映射数组时。这将是相当多的具有常规功能的空行。</p><p id="6076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ff51" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">const</strong> numbers = [1, 2, 3, 4];<br/>numbers.map(function(n) {<br/>  return n * n;<br/>});</span></pre><p id="4813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这变成了一个圆滑、易读的带有lambda风格箭头函数的一行程序:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a94e" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">const</strong> numbers = [1, 2, 3, 4];<br/>numbers.map(n =&gt; n * n);</span></pre><p id="5be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">arrow函数的这个用例将会像预期的那样工作:它将值乘以自身，然后返回一个包含<code class="fe nj nk nl na b">[1, 4, 9, 16]</code>的新数组。</p><p id="d55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果您尝试映射到对象中，语法可能不是人们直觉上期望的那样。例如，假设我们试图将数字映射到包含如下值的对象数组中:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="727d" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">const</strong> numbers = [1, 2, 3, 4];<br/>numbers.map(n =&gt; { value: n });</span></pre><p id="6e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的结果实际上将是一个包含未定义值的数组。虽然看起来我们在这里返回了一个对象，但是解释器看到了完全不同的东西。花括号被解释为arrow函数的块范围，而value语句实际上是一个标签。如果我们将上面的箭头函数外推至解释器实际执行的结果，它看起来会像这样:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d5ce" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">const</strong> numbers = [1, 2, 3, 4];</span><span id="36ad" class="ne md it na b gy nm ng l nh ni">numbers.map(function(n) {<br/>  value:<br/>  n<br/>  return;<br/>});</span></pre><p id="5aa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方法相当微妙。我们只需要将对象括在括号中，这样就把它变成了一个表达式，而不是一个块语句，就像这样:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4bcb" class="ne md it na b gy nf ng l nh ni">const numbers = [1, 2, 3, 4];<br/>numbers.map(n =&gt; ({ value: n }));</span></pre><p id="0deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将计算出一个数组，该数组包含一个对象数组，这些对象的值符合预期。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a9d2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">箭头函数和绑定</h1><p id="477e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">关于箭头函数的另一个警告是，它们没有自己的<code class="fe nj nk nl na b">this</code>绑定，这意味着它们的<code class="fe nj nk nl na b">this</code>值将与封闭词法范围的<code class="fe nj nk nl na b">this</code>值相同。</p><p id="fe0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，尽管语法可以说更加流畅，但arrow函数并不能取代好的旧函数。您很快就会遇到这样的情况，您的<code class="fe nj nk nl na b">this</code>绑定与您想象的不一样。</p><p id="9a34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8dbc" class="ne md it na b gy nf ng l nh ni">let calculator = {<br/>  value: 0,<br/>  add: (values) =&gt; {<br/>    this.value = values.reduce((a, v) =&gt; a + v, this.value);<br/>  },<br/>};</span><span id="9f0e" class="ne md it na b gy nm ng l nh ni">calculator.add([1, 2, 3]);<br/>console.log(calculator.value);</span></pre><p id="ac92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然人们可能认为这里的<code class="fe nj nk nl na b">this</code>绑定是那里的计算器对象，但实际上会导致<code class="fe nj nk nl na b">this</code>要么是未定义的，要么是全局对象，这取决于代码是否运行在严格模式下。这是因为这里最接近的词法范围是全局范围。在严格模式下，这是未定义的；否则，它就是浏览器中的窗口对象(或者Node.js兼容环境中的流程对象)。</p><p id="478f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常规函数确实有一个<code class="fe nj nk nl na b">this</code>绑定。当在一个对象上调用时，这将指向该对象，因此使用常规函数仍然是成员函数的方法。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8927" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">let</strong> calculator = {<br/>  value: 0,<br/>  add(values) {<br/>    <strong class="na iu">this</strong>.value = values.reduce((a, v) =&gt; a + v, <strong class="na iu">this</strong>.value);<br/>  },<br/>};</span><span id="f238" class="ne md it na b gy nm ng l nh ni">calculator.add([10, 10]);<br/>console.log(calculator.value);</span></pre><p id="2805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，由于箭头函数没有<code class="fe nj nk nl na b">this</code>绑定，<code class="fe nj nk nl na b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noopener ugc nofollow" target="_blank">Function.prototype.call</a></code>、<code class="fe nj nk nl na b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="noopener ugc nofollow" target="_blank">Function.prototype.bind</a></code>和<code class="fe nj nk nl na b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener ugc nofollow" target="_blank">Function.prototype.apply</a></code>也不能使用它们。<code class="fe nj nk nl na b">this</code>绑定是在声明箭头功能时固定的，不能更改。</p><p id="4d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在下面的例子中，我们将遇到与前面相同的问题:当调用加法器的add函数时，<code class="fe nj nk nl na b">this</code>绑定是全局对象，尽管我们试图用<code class="fe nj nk nl na b">Function.prototype.call</code>覆盖它:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bee7" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">const</strong> adder = {<br/>  add: (values) =&gt; {<br/>    <strong class="na iu">this</strong>.value = values.reduce((a, v) =&gt; a + v, <strong class="na iu">this</strong>.value);<br/>  },<br/>};</span><span id="b068" class="ne md it na b gy nm ng l nh ni"><strong class="na iu">let</strong> calculator = {<br/>  value: 0<br/>};</span><span id="72ac" class="ne md it na b gy nm ng l nh ni">adder.add.call(calculator, [1, 2, 3]);</span></pre><p id="12fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">箭头函数很简洁，但是在需要<code class="fe nj nk nl na b">this</code>绑定的地方，它们不能代替常规的成员函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="89b9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">自动分号插入</h1><p id="36bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然这不是新特性，但自动分号插入(ASI)是JavaScript中比较奇怪的特性之一，所以值得一提。理论上，大多数情况下可以省略分号(许多项目就是这样做的)。如果这个项目有先例，你应该遵循它，但是，你需要意识到ASI是一个特性，否则你最终会得到具有欺骗性的代码。</p><p id="0525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举以下例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2f90" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">return</strong><br/>{<br/>  value: 42<br/>}</span></pre><p id="cf02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们可能会认为它会返回对象文字，但实际上它会返回undefined，因为分号的插入使它成为一个空的返回语句，后跟一个block语句和一个label语句。</p><p id="8108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，实际被解释的最终代码看起来更像下面这样:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6b8e" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">return</strong>;<br/>{<br/>  value: 42<br/>};</span></pre><p id="44f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据经验，永远不要用左括号、方括号或模板字符串开始一行，即使使用分号也不行，因为ASI总是出现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="44da" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">浅集</h1><p id="72cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">集合是浅层的，意味着具有相同值的重复数组和对象，这将导致集合中有多个条目。</p><p id="6d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e72a" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">let</strong> set = <strong class="na iu">new</strong> Set();<br/>set.add([1, 2, 3]);<br/>set.add([1, 2, 3]);</span><span id="7add" class="ne md it na b gy nm ng l nh ni">console.log(set.length);</span></pre><p id="66b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个集合的大小是2，如果你从引用的角度来考虑，这是有意义的，因为它们是不同的对象。</p><p id="bdee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，字符串是不可变的。以集合中的多个字符串为例，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b97d" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">let</strong> set = <strong class="na iu">new</strong> Set();<br/>set.add([1, 2, 3].join(','));<br/>set.add([1, 2, 3].join(','));</span><span id="2d4e" class="ne md it na b gy nm ng l nh ni">console.log(set.size);</span></pre><p id="7e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将导致集合的大小为1，因为字符串是不可变的，并且在JavaScript中是固定的，如果您发现自己需要存储一组对象，这可以作为一种变通方法。我们可以对它们进行序列化和反序列化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b6e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">类和时间死区</h1><p id="de01" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在JavaScript中，常规函数被提升到词法范围的顶部，这意味着下面的例子将会如人们所预期的那样工作:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="174b" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">let</strong> segment = <strong class="na iu">new</strong> Segment();</span><span id="a237" class="ne md it na b gy nm ng l nh ni"><strong class="na iu">function</strong> Segment() {<br/>  <strong class="na iu">this</strong>.x = 0;<br/>  <strong class="na iu">this</strong>.y = 0;<br/>}</span></pre><p id="0fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于类来说就不一样了。类实际上并没有被提升，在你试图使用它们之前，需要在词法范围内被完全定义。</p><p id="3994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c34b" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">let</strong> segment = <strong class="na iu">new</strong> Segment();</span><span id="82a5" class="ne md it na b gy nm ng l nh ni"><strong class="na iu">class</strong> Segment {<br/>  constructor() {<br/>    <strong class="na iu">this</strong>.x = 0;<br/>    <strong class="na iu">this</strong>.y = 0;<br/>  }<br/>}</span></pre><p id="9c2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当试图构造一个类的新实例时，这会导致一个<code class="fe nj nk nl na b">ReferenceError</code>,因为它们不像函数那样被提升。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a2a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后</h1><p id="3125" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后是有点特殊的情况。看看下面的片段:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="431e" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">try</strong> {<br/>  <strong class="na iu">return</strong> true;<br/>} <strong class="na iu">finally</strong> {<br/>  <strong class="na iu">return</strong> false;<br/>}</span></pre><p id="a056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你认为它会返回什么值？答案既直观，同时也可能变得不直观。人们可能会认为第一个return语句使函数实际返回并弹出调用堆栈。但这是该规则的一个例外，因为Finally语句总是运行的，所以Finally块中的return语句会返回。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b328" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后</h1><p id="f29b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript简单易学，但很难掌握。换句话说，除非开发人员注意他们在做什么以及为什么要做什么，否则很容易出错。</p><p id="3ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于ECMAScript 6及其甜蜜的特性来说尤其如此。尤其是箭头函数，一直都在出现。如果要我猜的话，我会说这是因为开发人员认为它们比常规函数更漂亮。但它们不是常规函数，也不能替代它们。</p><p id="65fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时不时的略读一下<a class="ae ky" href="https://www.ecma-international.org/ecma-262/9.0/index.html" rel="noopener ugc nofollow" target="_blank">说明书</a>也无妨。它不是世界上最令人兴奋的文档，但就规范而言，它也没那么糟糕。</p><p id="6c84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<a class="ae ky" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>这样的工具也有助于揭示一些角落案例中正在发生的事情。人类和计算机倾向于以不同的方式解析事物。</p><p id="343f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我将把最后一个例子留给你们作为练习。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/b1b22a1588073de3f17ace839863fe27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_MxHFgeGPlf2iZ95.gif"/></div></div></figure></div></div>    
</body>
</html>