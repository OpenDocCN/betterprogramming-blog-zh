<html>
<head>
<title>Everything You Need To Know About Regular Expressions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python中正则表达式你需要知道的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-you-need-to-know-about-regular-expressions-in-python-bbf96939b15?source=collection_archive---------2-----------------------#2021-08-13">https://betterprogramming.pub/everything-you-need-to-know-about-regular-expressions-in-python-bbf96939b15?source=collection_archive---------2-----------------------#2021-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="05dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何成为Regex的巫师</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/59524b9df3eacf4206d25cdc9194b42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rc0yP_EKYJpWsmRZ7Rq4sA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创造的形象。来自<a class="ae ky" href="https://pixabay.com/pt/users/pexels-2286921/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1841550" rel="noopener ugc nofollow" target="_blank">像素</a>在<a class="ae ky" href="https://pixabay.com/pt/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1841550" rel="noopener ugc nofollow" target="_blank">像素</a>的背景图片</p></figure><p id="49b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">亲爱的程序员和软件开发爱好者们。让我们面对一个事实:正则表达式是可怕的。太可怕了。为什么？我听到你问了。</p><p id="c32a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它是一系列的字符和符号(对于未经训练的人来说)看起来就像试图在外语街上阅读招牌一样令人生畏。简而言之，这使得术语“正则表达式”或<em class="lv"> Regex </em>变得有点讽刺。</p><p id="846c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不惜一切代价避免使用regex，而且用了比我愿意承认的时间长得多的时间。但是有一天，我决定是时候学会使用它了。</p><p id="ff10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式是程序员旅程中极其重要的一部分。它是一个你需要放在你的实用腰带上的工具，它可以把你从痛苦的长时间编写不必要的代码中解救出来。</p><p id="5f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我一头扎进了神秘的regex世界。我已经预料到这很难，但是一旦我理解了基本概念，前进的道路就相当简单了。</p><p id="ae3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我意识到这就像学习任何其他语言一样:一旦你理解了单词和语法，把句子串起来就成了第二天性。</p><p id="b86b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从最基本的意义上来说，正则表达式是一系列搜索模式的字符。这些字符序列是<a class="ae ky" href="https://en.wikipedia.org/wiki/Regular_language" rel="noopener ugc nofollow" target="_blank"> <em class="lv">正则语言</em> </a>的实例，最常用于文本解析或任何类型的字符串输入验证。</p><p id="e1df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一张由特定形状切割而成的纸板。只有与切口完全匹配的形状才能通过。纸板薄板相当于一个正则表达式字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/c1128edc0b28a4aef407b9063d2289ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LL2sTC-LcnAMtmzYBd4yA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的正则表达式搜索模式会是什么样子呢？</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="1108" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu">Regex:</strong> circle|triangle|hexagon</span></pre><p id="d5e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">输入语句:</strong>三个进来的形状是圆形、三角形和矩形。</p><p id="af90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式引擎将只匹配单词<code class="fe mi mj mk ly b">circle</code>和<code class="fe mi mj mk ly b">triangle</code>。你也可以试试<a class="ae ky" href="https://regex101.com/r/20qASm/1" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="3dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单不是吗！</p><p id="401f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要知道正则表达式模式本身是正则语言的一部分。然而，我们今天使用的大多数编程语言都支持正则表达式，并有内置的(或可下载的)模块。</p><p id="f421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们在我们选择的语言中使用它们。除了这篇文章中到处散布的<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> regex101 </a>链接，我将在这篇文章的所有代码中使用Python regex模块<code class="fe mi mj mk ly b"><a class="ae ky" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">re</a></code>。</p><p id="c8ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，在代码的世界里，你如何创造这种隐喻性的纸板呢？让我们来看一个例子。</p><p id="41a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有一串“西尔维20岁了。”而你想从这句话里只提取年龄。这里你需要的只是数字。这里的正则表达式模式是<code class="fe mi mj mk ly b">\d</code>，这是一个特殊的字符，它匹配只有数字的模式(我们将在后面讨论模式的细节)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/8ba734cc340c8ab8ff48159d66b8db75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvsRhjgAHyrZpMvr8aIwIw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/edb162af8661b5784d6649c335c8203a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*SsmC4j_ief3QVmiY4SGcuw.png"/></div></div></figure><p id="4c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不完全是我们想要的，但我们更近了一步。至少我们识别出了数字！我们的红色纸板切割块作为一个数字标识符。</p><p id="6d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据需求，它可以从实际的字母字符(例如，regex <code class="fe mi mj mk ly b">a</code>是一个有效的表达式，它将在字符串输入中搜索<code class="fe mi mj mk ly b">a</code>)到一组特殊字符。我们稍后会看到很多这样的例子。</p><p id="c4af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们需要的不是单个的数字，而是整个数字。让我们用另一个块以某种方式修改标识符。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/dd6628d3dc90f0d1833b8a899b3c0d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwuS6HOAjw_FA16UOIZGOQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="789d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给出了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/8f9ba1701baa6a17ae8991afc4626d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ziY9nfeb6mYL4SnO0TszXg.png"/></div></div></figure><p id="cfb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">耶！我们从绳子上知道了西尔维的年龄！但是等等，如果出生年份也在字符串中呢？如果我们使用上面的表达式，它将给出句子中所有的2位数集合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/7a6ffa1f80475c761191a2cfe61a1394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qp_wWYkHLt5Y13GP-odK3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不希望这样，因此让我们修改它多一点。我们能做什么？</p><p id="359c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加一个边界表达式，因为我们想要的两位数两边都有空格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/53640a00e184199f1f9301202705a6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jfkHNx3pQDDy1F0KUKiBQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tada！：</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/8f9ba1701baa6a17ae8991afc4626d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ziY9nfeb6mYL4SnO0TszXg.png"/></div></div></figure><p id="d53e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在得到了我们所需要的，即使字符串中还有另外一个4位数。只是为了好玩，您可以在这里查看上面的正则表达式字符串:</p><p id="5997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有边界→ <a class="ae ky" href="https://regex101.com/r/6NQrVh/1" rel="noopener ugc nofollow" target="_blank">试试</a></p><p id="7b0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有边界→ <a class="ae ky" href="https://regex101.com/r/f2JlO3/1" rel="noopener ugc nofollow" target="_blank">此处</a></p><p id="0b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很漂亮吧？通过一行代码，我们可以从字符串中提取数字。</p><p id="a4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经讨论过，在我们的<em class="lv">代码纸板</em>中，我们需要使用一堆字符来创建这些<em class="lv">虚拟剪裁</em>。让我们看看它们是什么。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="0f23" class="mw md it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">特性</h1><ul class=""><li id="1da0" class="nn no it lb b lc np lf nq li nr lm ns lq nt lu nu nv nw nx bi translated"><strong class="lb iu">\ d</strong>:0到9之间的任意数字</li><li id="f210" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> \D </strong>:数字以外的任何东西</li><li id="929d" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> \s </strong>:空格</li><li id="0887" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">除了空格以外的任何东西</li><li id="5e95" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> \w </strong>:任意字符</li><li id="ab4d" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">除了字符以外的任何东西</li><li id="aa86" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> \b </strong>:墙壁周围的边界空白</li><li id="a0a8" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu">。</strong>:匹配任意字符(<a class="ae ky" href="https://regex101.com/r/8MHf23/1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">试试</strong> </a>)</li><li id="717f" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> \。:</strong>匹配一个句点</li></ul><h1 id="1135" class="mw md it bd mx my od na nb nc oe ne nf jz of ka nh kc og kd nj kf oh kg nl nm bi translated">修饰语</h1><ul class=""><li id="7762" class="nn no it lb b lc np lf nq li nr lm ns lq nt lu nu nv nw nx bi translated"><strong class="lb iu"> {}: </strong>分组数量，像<code class="fe mi mj mk ly b">\d{3}</code>给出3位数对，<code class="fe mi mj mk ly b"> \d{3,5}</code>给出3到5位数对。总的来说，就是<code class="fe mi mj mk ly b">{min, max}</code></li><li id="52a0" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> []: </strong>字符分组。它将匹配括号内容中的单个字符。Like <code class="fe mi mj mk ly b">[a-z]</code>将匹配小写字母中的每个字符。</li><li id="6acb" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> +: </strong>匹配它之前的元素一次或多次，像<code class="fe mi mj mk ly b">[a-z]+a</code> <strong class="lb iu"> </strong>会给出分组后的匹配结果，如下图<strong class="lb iu"> </strong> <a class="ae ky" href="https://regex101.com/r/mWajBz/1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">此处</strong> </a></li><li id="1750" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu">？:</strong>匹配它之前的元素零次或一次，看<code class="fe mi mj mk ly b">[a-z]?a</code> <strong class="lb iu"> </strong> <a class="ae ky" href="https://regex101.com/r/crYTcV/1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">如何工作</strong> </a></li><li id="32ce" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> *: </strong>匹配它之前的元素零次或多次。参见<code class="fe mi mj mk ly b">[a-z]*a</code> <a class="ae ky" href="https://regex101.com/r/FuBwxr/1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">这里的</strong> </a></li><li id="727b" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> $: </strong>表示行尾</li><li id="f905" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> ^: </strong>表示生产线的开始</li><li id="6e18" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu"> |: </strong> Or运算符。例如<strong class="lb iu"> col(o|u)r </strong>将匹配单词color的美式和英式拼写。</li></ul><p id="0f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是最常见的，在本文和大多数用例中会派上用场。然而，可以在<a class="ae ky" href="https://www.rexegg.com/regex-quickstart.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到一个包含更多角色类别的备忘单。</p><p id="956a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了了解这些字符之外，理解正则表达式引擎如何工作的一些基础知识也是有意义的。如果复杂的正则表达式出现意外结果，这将节省您大量的猜测时间。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="0f53" class="mw md it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">正则表达式是如何工作的</h1><p id="592e" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">有两种类型的正则表达式引擎:文本导向引擎和正则表达式导向引擎，后者是最流行的一种。很有可能你用的是同一个。我们可以用python做一个简单的测试来检查我们使用的是哪种类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/f272c56c5cc0c6e3750c32b27fedfc47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1N7LZ73Gj5TwVH5ZI6E6sQ.png"/></div></div></figure><p id="85b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是<code class="fe mi mj mk ly b">regex</code>，这意味着我们正在使用regex导向的引擎。为什么这很重要？因为在这个引擎中实现了某些重要的特性，比如懒惰量词和反向引用。</p><p id="6190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，重要的是要知道，这个引擎从左到右<em class="lv"/>(这也是上述例子的工作方式)。这个例子将会更加清楚。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/25d8a01c90846f9a5e663f2a80029fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w_ZXCYt3HftDVjXc6rWPuQ.png"/></div></div></figure><p id="2cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显匹配是从左到右的。从长远来看，了解这些基本知识肯定会对你有所帮助。</p><p id="51e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些知识，我们现在可以尝试使用一些新技能。那么regex有哪些用途呢？一些用途包括:</p><ul class=""><li id="1d9d" class="nn no it lb b lc ld lf lg li on lm oo lq op lu nu nv nw nx bi translated">解析文本、日志、web数据等输入。</li><li id="fa39" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">输入验证</li><li id="b59d" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">测试输出结果</li><li id="c3bc" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">搜索文本</li><li id="d283" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">数据重组</li></ul><p id="7236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，一如既往，用例子学起来更容易。既然我们已经知道了如何使用regex，并且其中的所有字符都已经不再神秘，那么让我们看三个具体的例子，看看如何用几行代码自己使用它。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="c1ba" class="mw md it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">例1。验证电子邮件条目</h1><p id="ce1f" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">在任何regex教程中，您都会发现这个例子是默认的。它就像正则表达式的“Hello World ”,因此我将把它包含在这里。它帮助我们验证输入的电子邮件地址格式。你可以自己试试这个简单的例子。</p><p id="b2c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一步一步地解决这个问题。首先，我们知道有效的电子邮件地址应该是什么样的(大多数情况下):</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="4a90" class="mc md it ly b gy me mf l mg mh">someone@mailservice.domain</span></pre><p id="da3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户或<code class="fe mi mj mk ly b">someone</code> <em class="lv"> </em>通常由字母或数字的组合组成。有时也可能有特殊字符，但是对于regex的初学者，我们可以考虑一个简单的例子。</p><p id="f7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们有从A到Z的字符，允许大写，这意味着A到Z，还有数字0到9。该组的正则表达式将如下所示:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="7983" class="mc md it ly b gy me mf l mg mh">[a-zA-Z0–9]</span></pre><p id="b3c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似的，邮件服务一般都是字母的像Gmail，gmx，Hotmail等。，后跟一个@符号。因此:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="773c" class="mc md it ly b gy me mf l mg mh">@[a-zA-Z]</span></pre><p id="9012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们考虑一下最受欢迎的域名——com、net、edu和org，它们跟在邮件服务提供商后面的句点字符后面。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="624d" class="mc md it ly b gy me mf l mg mh">\.(com|net|edu|org)</span></pre><p id="7585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把这些放在一起，我们就有了正则表达式:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="455c" class="mc md it ly b gy me mf l mg mh">[a-zA-Z0–9]+@[a-zA-Z]+\.(com|net|org|edu)</span></pre><p id="bb7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们在一个python脚本中使用它，该脚本接受一个输入电子邮件id并验证它是否符合格式要求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b1c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/61e23a7505ee8b9e5cd94cff9dca3bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2ODvN8DsZ9JeyTlQMb4YXQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截屏</p></figure><p id="3129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你自己的电子邮件id验证器！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="f99d" class="mw md it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">例2。从文本中获取姓名和年龄</h1><p id="6aa7" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">我们已经在本文开头的简化示例中看到了如何从字符串中获取年龄。让我们看一个例子，在这个例子中，我们可以提取姓名和文本，并将它们放入字典中。</p><p id="d4ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经明白，如何使用正则表达式<code class="fe mi mj mk ly b">\b\d{2}\b</code>从字符串中提取一个2位数。在这个例子中的文本的情况下，我们考虑2或3个数字(因为也有一个百岁老人)。</p><p id="88fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于在这篇文章中得到的名字，我们看到每个人都有一个超过3个字母的名字。因此，长度为3或更长的大写字符串组应该可以工作:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="a0c9" class="mc md it ly b gy me mf l mg mh">\b[A-z][a-z]{3,}\b</span></pre><p id="4f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于在字典中找到与年龄相匹配的名字的最后一部分，简单的英语语法规则应该可以做到——在句子结构中，我们总是在名字后面说年龄。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="235c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/cd3cf7fa456c164bde36cfd7c0030c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWUwAO5Vt3UEjfQaB_OmSA.png"/></div></div></figure><p id="8d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，随着输入文本变得更加复杂，我们需要智能地提取更多的信息，我们将不得不使用更多的正则表达式。然而，我可以肯定地说，即使在复杂的情况下，你肯定会在某种程度上使用正则表达式来简化。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="69b2" class="mw md it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated"><strong class="ak">例3。密码模式匹配</strong></h1><p id="36ba" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">当您准备创建新密码时，大多数人一定对这句话很熟悉:</p><p id="6db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">“您的密码必须包含至少8个字符，至少一个大写字母、一个小写字母、一个数字和一个符号，以确保高度安全”</em></p><p id="dc44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想过如何做到这一点吗？又是Regex。这个例子比我们到目前为止看到的要复杂一点，涉及到regex中的一些概念，我会在后面解释。有了这些，你也可以构建一个简单的版本！</p><p id="69b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们目前所了解的情况，至少有一部分是简单明了的。我们需要字符(大写和小写)— <code class="fe mi mj mk ly b"><strong class="lb iu">A-Z</strong></code>和<code class="fe mi mj mk ly b"><strong class="lb iu">a-z</strong></code>，数字— <code class="fe mi mj mk ly b"><strong class="lb iu">\d</strong></code>和特殊符号— <code class="fe mi mj mk ly b"><strong class="lb iu">_@$!%*?&amp;</strong></code> <strong class="lb iu"> </strong>，所有这些加起来超过8:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="800e" class="mc md it ly b gy me mf l mg mh">[A-Za-z\d_@$!%*?&amp;]{8,}</span></pre><p id="7924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将为您提供包含上述<em class="lv">任何</em>字符的所有内容的匹配。</p><p id="5082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe mi mj mk ly b">asdf@1234</code>即使没有大写字母也是有效的密码— <a class="ae ky" href="https://regex101.com/r/TiW8wh/1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">试试</strong> </a> <strong class="lb iu">。</strong></p><p id="05b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一些方法来预测未来，并从每个组中匹配至少一个结果。进入<em class="lv">正则表达式环视。环视匹配字符，但不给出实际的匹配。相反，它们返回一个二元结果:要么匹配，要么不匹配。因此，它们实际上是<em class="lv">的断言</em>。</em></p><p id="0b11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式环视有两种类型:</p><h2 id="8c9e" class="mc md it bd mx os ot dn nb ou ov dp nf li ow ox nh lm oy oz nj lq pa pb nl pc bi translated"><strong class="ak">向前看</strong></h2><ul class=""><li id="6f42" class="nn no it lb b lc np lf nq li nr lm ns lq nt lu nu nv nw nx bi translated">积极前瞻:这是通过使用字符<strong class="lb iu">实现的？= </strong>在字符串中。例如，<code class="fe mi mj mk ly b">xyz(?=abc)</code>会在每一个<code class="fe mi mj mk ly b">xyz</code>的<em class="lv">前面</em>查找是否有<code class="fe mi mj mk ly b">abc</code>，遇到一个才匹配(<a class="ae ky" href="https://regex101.com/r/e0PFEM/1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">试试这里</strong> </a>)。</li><li id="49a7" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">消极前瞻:与上面类似，这个断言<strong class="lb iu">？！</strong>在上面的否定中。在这种情况下，<code class="fe mi mj mk ly b">xyz(?!abc)</code>将<em class="lv">提前查看每个<code class="fe mi mj mk ly b">xyz</code>的</em>以检查是否没有<code class="fe mi mj mk ly b">abc</code>并相应地给出匹配(<a class="ae ky" href="https://regex101.com/r/dqPnnk/1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">尝试此处</strong> </a>)。</li></ul><h2 id="9e06" class="mc md it bd mx os ot dn nb ou ov dp nf li ow ox nh lm oy oz nj lq pa pb nl pc bi translated"><strong class="ak">看后面</strong></h2><ul class=""><li id="6ac9" class="nn no it lb b lc np lf nq li nr lm ns lq nt lu nu nv nw nx bi translated">正面向后看:在这种情况下，正则表达式引擎将暂时向后工作。正则表达式<code class="fe mi mj mk ly b">(?&lt;=abc)xyz</code>将搜索以<code class="fe mi mj mk ly b">abc</code>开头的每个<code class="fe mi mj mk ly b">xyz</code>，即从右到左(<a class="ae ky" href="https://regex101.com/r/M1MUcs/1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">尝试此处</strong> </a>)</li><li id="50bd" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">后面的否定看起来与上面类似，在这种情况下，<code class="fe mi mj mk ly b">(?&lt;!abc)xyz</code>将搜索每一个<code class="fe mi mj mk ly b">xyz</code><em class="lv"/><code class="fe mi mj mk ly b">abc</code><strong class="lb iu"/>前面没有的，即从右到左(<a class="ae ky" href="https://regex101.com/r/5KV5F2/1" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a>)</li></ul><p id="2f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些概念，我们可以为密码问题的下一部分构建正则表达式。在这种情况下，积极的前瞻对我们最有用。</p><p id="46b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分解一下。我们需要大写字母来匹配未来。</p><p id="d82b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mi mj mk ly b">(?=[A-Z])</code>将匹配大写字母并给出多个匹配，只要它遇到它们。由于我们需要在字符串的任何位置都有一个匹配，我们将其修改为:<code class="fe mi mj mk ly b">(?=.*[A-Z])</code></p><p id="34fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，对于</p><ul class=""><li id="8a2e" class="nn no it lb b lc ld lf lg li on lm oo lq op lu nu nv nw nx bi translated">小写字母:<code class="fe mi mj mk ly b">(?=.*[a-z])</code></li><li id="ccde" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">数字:<code class="fe mi mj mk ly b">(?=.*\d)</code></li><li id="c94a" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">特殊字符:<code class="fe mi mj mk ly b">(?=.*_@$!%*?&amp;)</code></li></ul><p id="b932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将所有这些放在开始和结束行标识符之间(分别为^和美元):</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="2079" class="mc md it ly b gy me mf l mg mh">^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&amp;])[A-Za-z\d@$!%*?&amp;]{8,}$</span></pre><p id="8d70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比看起来更容易理解，对吗？现在让我们使用这个正则表达式实现一个简单的密码强度检查工具。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="795a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示(密码为<em class="lv"> abcABC@1234 </em>和<em class="lv"> abcABC1234 </em>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/bf11e68d220ce742e15bc52f804335da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Bv-r5twjs-cV7Eadtzo5HA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截屏</p></figure><p id="bc19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你自己的密码强度检查器！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="a33c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您喜欢从这篇文章中学习。和往常一样，正则表达式的世界比本文解释的要复杂得多。不过，这应该会让你有一个很好的开始，很快你就会成为一名巫师！学习正则表达式的更多参考是<a class="ae ky" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">这里</a>:</p><p id="c0a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你可能也会喜欢我的其他编程帖子，如下所示:</p><ul class=""><li id="e5ba" class="nn no it lb b lc ld lf lg li on lm oo lq op lu nu nv nw nx bi translated"><a class="ae ky" href="https://towardsdatascience.com/perfectly-pythonic-python-stuff-that-you-should-definitely-know-daa559528d58" rel="noopener" target="_blank">你绝对应该知道的完美Pythonic Python素材</a></li><li id="b8c0" class="nn no it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://towardsdatascience.com/awesome-aws-quicksight-visuals-every-data-analyst-should-know-e4e9302b2711" rel="noopener" target="_blank">每个数据分析师都应该知道的出色AWS-Quicksight视觉效果</a></li></ul></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="c60c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>