<html>
<head>
<title>Advanced Features of Kubernetes’ Horizontal Pod Autoscaler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes卧式Pod自动秤的先进特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-features-of-kubernetes-horizontal-pod-autoscaler-536ebd7893ad?source=collection_archive---------3-----------------------#2022-07-04">https://betterprogramming.pub/advanced-features-of-kubernetes-horizontal-pod-autoscaler-536ebd7893ad?source=collection_archive---------3-----------------------#2022-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2909" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kubernetes的水平吊舱自动缩放器有一些你可能不知道的功能。以下是如何利用它们的优势。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29afe934d9f57dc9ec43af74ccf35615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKLeoAvWn-tMI3suXcc_gg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@raimondklavins?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雷蒙·克拉文斯</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="1b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数使用Kubernetes的人都知道，您可以使用<em class="lv">Horizontal Pod auto scaler(HPA)</em>根据应用程序的CPU或内存使用情况来扩展应用程序。然而，您可以使用HPA的更多功能来定制应用的扩展行为，例如使用定制应用指标或外部指标进行扩展，以及alpha/beta功能，如<em class="lv">“扩展到零”</em>或容器指标扩展。</p><p id="2c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在本文中，我们将探索所有这些选项，以便我们可以充分利用HPA的所有可用特性，并在未来的Kubernetes版本中率先使用这些特性。</p><h1 id="9307" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">设置</h1><p id="a63b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在开始扩展之前，我们首先需要一个测试环境。为此我们将使用<em class="lv">KinD(Kubernetes in Docker)</em>由以下YAML定义的集群:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该清单配置了具有1个控制平面节点和3个工作器的KinD集群，此外，它还启用了一些与自动缩放相关的功能门。这些特征门稍后将允许我们使用HPA的一些alpha/beta特征。要使用上述配置创建集群，您可以运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了集群，我们还需要一个可以扩展的应用程序。为此，我们将使用在Kubernetes端到端测试中使用的<a class="ae ky" href="https://pkg.go.dev/k8s.io/kubernetes/test/images/resource-consumer#section-readme" rel="noopener ugc nofollow" target="_blank">资源消费者工具</a>及其映像。要部署它，您可以运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，这个应用程序非常方便，因为它允许我们模拟Pod的CPU和内存消耗。它还可以公开基于自定义/外部指标进行扩展所需的自定义指标。为了测试这一点，我们可以运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们还需要部署收集指标的服务，我们将基于这些指标来扩展我们的测试应用程序。首先是Kubernetes <code class="fe mv mw mx my b"><a class="ae ky" href="https://github.com/kubernetes-sigs/metrics-server" rel="noopener ugc nofollow" target="_blank">metrics-server</a></code>,默认情况下它通常在集群中可用，但实际情况并非如此，因此要部署它，我们需要运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c3b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">metrics-server</code>允许我们监控CPU和内存使用等基本指标，但我们也希望根据自定义指标实现扩展，如应用程序在其<code class="fe mv mw mx my b">/metrics</code>端点上公开的指标，甚至是外部指标，如在群集外运行的队列的队列深度。为此，我们需要:</p><ul class=""><li id="939c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/prometheus-operator/prometheus-operator" rel="noopener ugc nofollow" target="_blank"> Prometheus操作员</a>收集自定义/外部指标。</li><li id="dbbf" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/MartinHeinz/metrics-on-kind/blob/master/service-monitor.yaml" rel="noopener ugc nofollow" target="_blank"> ServiceMonitor </a>对象告诉Prometheus如何获取我们应用程序的指标。</li><li id="6deb" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/kubernetes-sigs/prometheus-adapter" rel="noopener ugc nofollow" target="_blank"> Prometheus适配器</a>将自定义/外部指标从Prometheus实例获取到Kubernetes API中。</li></ul><p id="76d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以参考<a class="ae ky" href="https://github.com/kubernetes-sigs/prometheus-adapter/blob/master/docs/walkthrough.md" rel="noopener ugc nofollow" target="_blank">端到端演练</a>了解更多设置细节。</p><p id="36ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面需要大量的设置，所以为了本文的目的和方便起见，我制作了一个脚本和一组清单，您可以使用它们来启动KinD cluster以及所有需要的组件。你需要做的就是从这个库运行<code class="fe mv mw mx my b">setup.sh</code>脚本<a class="ae ky" href="https://github.com/MartinHeinz/metrics-on-kind" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="797f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行脚本后，我们可以使用以下命令验证一切准备就绪:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b4f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多有用的命令可以在上述脚本的输出或<a class="ae ky" href="https://github.com/MartinHeinz/metrics-on-kind/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">存储库自述文件</a>中找到。</p><h1 id="490d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">基本自动缩放</h1><p id="e8db" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">既然我们的基础设施已经启动并运行，我们就可以开始扩展测试应用程序了。最简单的方法是使用像<code class="fe mv mw mx my b">kubectl autoscale deploy resource-consumer --min=1 --max=5 --cpu-percent=75</code>这样的命令创建HPA，但是这样会创建带有<code class="fe mv mw mx my b">autoscaling/v1</code>的<code class="fe mv mw mx my b">apiVersion</code>的HPA，缺少大部分特性。</p><p id="c3e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将使用YAML创建HPA，将<code class="fe mv mw mx my b">autoscaling/v2</code>指定为<code class="fe mv mw mx my b">apiVersion</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述HPA将使用由<code class="fe mv mw mx my b">metrics-server</code>从应用Pod收集的基本指标。为了测试伸缩性，我们可以模拟大量的内存使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="d976" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">自定义指标</h1><p id="627c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">基于CPU和内存使用的扩展通常就足够了，但是我们需要高级扩展选项。首先是使用应用程序公开的自定义指标进行扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="98dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此HPA配置为根据Prometheus从应用程序的<code class="fe mv mw mx my b">/metrics</code>端点收集的<code class="fe mv mw mx my b">custom_metric</code>值来扩展应用程序。如果所有pod(<code class="fe mv mw mx my b">.target.type: AverageValue</code>)中指定指标的平均值超过100，这将扩大应用程序的规模。</p><p id="89e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面使用了Pod metric来进行缩放，但是也可以指定任何其他对象，该对象具有附加到自身的度量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码片段与上一个代码片段实现了相同的功能，但是这一次使用了<em class="lv">服务</em>而不是Pod作为度量的来源。它还表明，通过将<code class="fe mv mw mx my b">.target.type</code>设置为<code class="fe mv mw mx my b">Value</code>而不是<code class="fe mv mw mx my b">AverageValue</code>，您可以使用直接比较来测量缩放阈值。</p><p id="462b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了找出哪些对象公开了可以在缩放中使用的度量，可以使用<code class="fe mv mw mx my b">kubectl get --raw</code>遍历API。例如，要查找Pod或服务的<code class="fe mv mw mx my b">custom_metric</code>，您可以使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="caab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，为了帮助您排除故障，HPA对象提供了一个status节，显示所应用的指标是否被识别:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0fda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了测试上述HPA的行为，我们可以提升应用程序公开的指标，并查看应用程序如何纵向扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="027e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">外部指标</h1><p id="74ac" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了展示HPA的全部潜力，我们还将尝试根据外部指标扩展应用程序。这将要求我们从运行在集群之外的外部系统(如Kafka或PostgreSQL)中获取指标。我们没有可用的资源，所以我们配置了Prometheus Adapter来将某些指标视为外部指标。实现这一点的配置可以在<a class="ae ky" href="https://github.com/MartinHeinz/metrics-on-kind/blob/master/custom-metrics-config-map.yaml" rel="noopener ugc nofollow" target="_blank">这里</a>找到。不过，您需要知道的是，对于这个测试集群，任何带有<code class="fe mv mw mx my b">external</code>前缀的应用程序指标都将进入外部指标API。为了测试这一点，我们增加了这样一个指标，并检查API是否被填充:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2c5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，要基于此指标扩展我们的部署，我们可以使用以下HPA:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="fa23" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">HPAScaleToZero</h1><p id="a7f1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们已经了解了HPA的所有众所周知的特性，让我们看看我们使用特性门实现的alpha/beta特性。第一个是<em class="lv"> HPAScaleToZero </em>。</p><p id="6488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，这将允许您将HPA中的<code class="fe mv mw mx my b">minReplicas</code>设置为零，如果没有流量，有效地关闭服务。这在<em class="lv">“突发”</em>工作流中很有用，例如当您的应用程序从外部队列接收数据时。在这个用例中，当有消息等待处理时，应用程序可以安全地扩展到零。</p><p id="6a37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用特征门后，我们只需运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将先前示出的HPA的最小副本设置为零。</p><p id="8581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这只适用于<code class="fe mv mw mx my b">type</code> <code class="fe mv mw mx my b">External</code>或<code class="fe mv mw mx my b">Object</code>的指标。</p><h1 id="b527" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">HPAContainerMetrics</h1><p id="ba07" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们可以利用的另一个特征门是<em class="lv"> HPAContainerMetrics </em>，它允许我们使用<code class="fe mv mw mx my b">type: ContainerResource</code>的指标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ae6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得基于单个容器而不是整个Pod的资源利用率进行扩展成为可能。如果您有包含应用程序容器和边车的多容器Pod，并且您希望忽略边车并仅基于应用程序容器扩展部署，那么这将非常有用。</p><p id="8b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以通过运行以下命令来查看Pod/container指标的细分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="cf55" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">对数标度下降</h1><p id="99f7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最后但同样重要的是<em class="lv">对数标度下降</em>特征标志。</p><p id="e459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有此功能，运行时间最少的Pod将在缩减过程中首先被删除。虽然这并不总是理想的，因为它可能会造成副本分布的不平衡，因为新的Pods往往比旧的服务更少的流量。</p><p id="b3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用此功能标志后，在选择要删除的Pod时，将改为使用半随机选择的Pod。</p><p id="15ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关完整的原理和算法细节，请参见<a class="ae ky" href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-apps/2185-random-pod-select-on-replicaset-downscale" rel="noopener ugc nofollow" target="_blank"> KEP-2189 </a>。</p><h1 id="3bf7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结束语</h1><p id="fa1e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，我试图涵盖您可以使用Kubernetes HPA来扩展您的应用程序的大多数事情。然而，在Kubernetes中运行的扩展应用程序有更多的工具和选项，例如<a class="ae ky" href="https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler" rel="noopener ugc nofollow" target="_blank">垂直pod autoscaler </a>可以帮助保持pod资源请求和限制最新。</p><p id="1122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个选项是<em class="lv"> Digital Ocean </em>的<a class="ae ky" href="https://github.com/jthomperoo/predictive-horizontal-pod-autoscaler" rel="noopener ugc nofollow" target="_blank">预测HPA </a>，它将尝试预测一个资源和应用程序应该有多少副本。</p><p id="61f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，自动扩展并不以Pod结束——设置Pod自动扩展后的下一步是设置<a class="ae ky" href="https://github.com/kubernetes/autoscaler" rel="noopener ugc nofollow" target="_blank">集群自动扩展</a>,以避免耗尽整个集群中的可用资源。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><div class="kj kk kl km gt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/automate-all-the-boring-kubernetes-operations-with-python-7a31bbf7a387"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">用Python自动化所有枯燥的Kubernetes操作</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">了解如何使用Python的Kubernetes客户端库来自动化所有枯燥的Kubernetes任务和操作</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">better编程. pub</p></div></div><div class="od l"><div class="oe l of og oh od oi ks nu"/></div></div></a></div><div class="oj ok gp gr ol nu"><a rel="noopener  ugc nofollow" target="_blank" href="/stop-messing-with-kubernetes-finalizers-b849511b2329"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">不要再和Kubernetes终结器捣乱了</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">这就是为什么你不应该强制删除Kubernetes资源或者移除它们的终结器</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">better编程. pub</p></div></div><div class="od l"><div class="om l of og oh od oi ks nu"/></div></div></a></div><pre class="kj kk kl km gt on my oo op aw oq bi"><span id="9fb0" class="or lx it my b gy os ot l ou ov"><strong class="my iu">Want to Connect?</strong></span><span id="1cad" class="or lx it my b gy ow ot l ou ov">This article was originally posted at <a class="ae ky" href="https://martinheinz.dev/blog/76" rel="noopener ugc nofollow" target="_blank">martinheinz.dev</a></span></pre></div></div>    
</body>
</html>