# 什么是独生子女？

> 原文：<https://betterprogramming.pub/what-is-a-singleton-2dc38ca08e92>

## 单体设计模式和常见实现的介绍

![](img/ac4d0a0bb82efa599c9303eb320b5b4e.png)

由[萨法尔·萨法罗夫](https://unsplash.com/@codestorm?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 介绍

单例设计模式将类的实例化限制为单个实例。这样做是为了在整个软件系统中提供对特定资源的协调访问。通过这种设计模式，singleton 类确保它只被实例化一次，并且可以提供对单个实例的简单访问。

# 用例

单体设计模式的常见用例包括工厂、构建器和保存程序状态的对象。

单例有时被认为是全局变量或静态类的替代品。

*与全局变量相比，单例变量有以下好处:*

*   单例实例字段不占用全局名称空间
*   单例可以被延迟初始化(将进一步讨论)

主要是因为单例拥有实例化的对象，而静态类没有，*单例相对于静态类*有以下优势:

*   单件可以实现接口
*   单例可以作为参数传递
*   单例可以换出它们的实例(比如为了测试的目的)
*   单例可以被多态地处理，所以可能存在多种实现

# 履行

让我们看看 Java 中一个基本单例类的实现细节。单例通常用一个私有构造函数方法和一个公共静态方法来实现，以返回单例的实例——存储在私有静态最终变量中。

有两种类型的单例实现:急切初始化和懒惰初始化。它们的不同之处在于初始化 singleton 实例的方式。我们还必须考虑它们中的线程安全。

## 急切初始化

在这个版本中，singleton 实例是在初始化 singleton 变量时创建的，而不是在第一次使用它时。由于在程序执行的这一点上 singleton 没有用，它可能会不必要地消耗系统资源。如果单例实例的计算成本很高或者占用大量资源，这可能会降低系统性能。然而，这个版本是线程安全的。

## 惰性初始化

在这个版本中，singleton 实例是在静态的`getInstance`方法第一次被调用时创建的。这确保了单例实例仅在绝对必要时才消耗系统资源。

## 线程安全的惰性初始化

上面显示的懒惰初始化版本是*而不是*线程安全的。单例实例可以在一个多线程程序中创建多次，所有都同时使用`Singleton`类。如果创建单例对象的成本非常高，这可能会消耗大量可用的系统资源。此外，这可能导致线程接收到部分创建的 singleton 对象。

通过使用同步，下面的实现是线程安全的。`instance`变量现在也被声明为`volatile`，这确保了所有线程都有一个 singleton 实例的更新视图。