<html>
<head>
<title>A First Look at SwiftUI NavigationStack, NavigationPath, and “navigationDestination”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI导航堆栈、导航路径和“导航目的地”初探</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-first-look-at-swiftui-navigationstack-navigationpath-and-navigationdestination-3a9bbb300e08?source=collection_archive---------0-----------------------#2022-06-23">https://betterprogramming.pub/a-first-look-at-swiftui-navigationstack-navigationpath-and-navigationdestination-3a9bbb300e08?source=collection_archive---------0-----------------------#2022-06-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="e525" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用iOS 16告别SwiftUI NavigationView</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/4df6cc990da8edb4ee611b5419bf1b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*321T3sPeNdkJ68L3"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@dannayyyboi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹钟</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="83ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI NavigationView从一开始就是这个框架的致命弱点。从最初不允许在NavigationLink中缓慢加载目的地视图(尽管后来解决了这个问题)，到不能以编程方式导航深层链接的<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/programmatic-navigation-in-swiftui-project-81200f35150">功能</a>，SwiftUI的导航框架经常迫使我们退回到使用<code class="fe lw lx ly lz b">UINavigationController</code>。</p><p id="dfab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们喘息的是，在iOS 16中，苹果提出了一种新的导航架构，这种架构是数据驱动的，而不是以前的视图驱动结构。</p><p id="7bf3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">主要的新导航API变化包括一个新的<code class="fe lw lx ly lz b">NavigationStack</code>,允许您从堆栈中推送和弹出视图，一个用于管理路由堆栈的<code class="fe lw lx ly lz b">NavigationPath</code>,以及一个用于以编程方式高效导航视图的<code class="fe lw lx ly lz b">navigationDestination</code>修饰符。随着同样的更新，他们已经弃用了<code class="fe lw lx ly lz b">NavigationView</code>。</p><h1 id="22f9" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">你好，导航栈</h1><p id="5d37" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">在我们的视图层次堆栈中集成NavigationStack非常简单:</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="73cb" class="nb mb iu lz b gz nc nd l ne nf">NavigationStack {<br/>       NavigationLink {<br/>            Text("Destination Screen")<br/>       } label: {<br/>            Text("Goto Next Screen")<br/>       }<br/>}</span></pre><p id="6584" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在一些琐碎的情况下，我们可以用新的<code class="fe lw lx ly lz b">NavigationStack</code>容器直接重构旧的<code class="fe lw lx ly lz b">NavigationView</code>。请注意新的<code class="fe lw lx ly lz b">NavigationLink</code> init语法。</p><p id="77b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该API现在包含一个<code class="fe lw lx ly lz b">value</code> - <code class="fe lw lx ly lz b">label</code>语法，标签包含链接的内容视图，值包含目标视图构建器。</p><p id="cb31" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样值得注意的是，NavigationLink的旧init方法如<code class="fe lw lx ly lz b">NavigationLink(isActive:destination:label:)</code>已经被弃用。</p><p id="23d3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">类似地,<code class="fe lw lx ly lz b">NavigationLink(destination:tag:selection:)</code>在iOS 16中也被弃用，这意味着基于NavigationLink重构编程导航将需要完全不同的代码。</p></div><div class="ab cl ng nh hy ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="in io ip iq ir"><h1 id="fe36" class="ma mb iu bd mc md nn mf mg mh no mj mk ka np kb mm kd nq ke mo kg nr kh mq mr bi translated">使用"<code class="fe lw lx ly lz b">navigationDestination"</code>修饰符的程序导航</h1><p id="1099" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">在上一节中，我们看到了如何在init代码中设置<code class="fe lw lx ly lz b">NavigationLink</code>的目标视图。然而，你可能还记得在iOS 16之前构建复杂的导航结构时，布尔标志给我们带来的痛苦。</p><p id="fef7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很高兴，从iOS 16开始，我们可以在<code class="fe lw lx ly lz b">.navigationDestination</code>修改器中设置目的地视图。<code class="fe lw lx ly lz b">navigationDestination</code>让我们能够基于类型以编程方式路由到不同的屏幕。你也可以为不同的视图类型添加多个<code class="fe lw lx ly lz b">navigationDestination</code>修改器。</p><p id="a4a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在以下示例中，我们创建了一个SwiftUI导航应用程序，该应用程序在目的地屏幕上构建相同的列表视图:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure></div><div class="ab cl ng nh hy ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="in io ip iq ir"><h1 id="f766" class="ma mb iu bd mc md nn mf mg mh no mj mk ka np kb mm kd nq ke mo kg nr kh mq mr bi translated">路由导航使用导航路径链接</h1><p id="88ce" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">以前，为了路由导航链接，我们有<code class="fe lw lx ly lz b">tags</code>。</p><p id="0e0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在iOS 16中，我们有了一个强大的新<code class="fe lw lx ly lz b">NavigationPath</code>，可以保存与<code class="fe lw lx ly lz b">NavigationStack</code>中显示的视图相关的类型擦除数据。</p><p id="b3b6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">NavigationPath</code>的强大之处在于它能够从堆栈中轻松推送、弹出属于不同数据类型的视图。</p><p id="874f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">考虑下面的应用，我们在<code class="fe lw lx ly lz b">NavigationStack</code>中插入了<code class="fe lw lx ly lz b">NavigationPath</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="9f8e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们已经在一个<code class="fe lw lx ly lz b">ObservableObject</code>类中设置了我们的<code class="fe lw lx ly lz b">NavigationPath</code>，并在一个<code class="fe lw lx ly lz b">EnvironmentObject</code>中设置了它，以便将它传递给子视图。不过，您也可以使用<code class="fe lw lx ly lz b">@Binding</code>来完成同样的操作。</p><p id="86a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意修改后的<code class="fe lw lx ly lz b">NavigationStack(path:)</code>初始化。</p><p id="1d97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是<code class="fe lw lx ly lz b">RowListsView</code>的代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="e66d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们稍微修改了上面的SwiftUI视图——加入了自定义的back按钮，这些按钮将以编程方式更改<code class="fe lw lx ly lz b">NavigationPath</code>——从而更改视图<code class="fe lw lx ly lz b">NavigationStack</code>:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/0299b852dbbc017f22b19e9a78a52d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*56p5lByOpvex_Cb9o6Cq-w.gif"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">SwiftUI导航路径</p></figure><p id="cab0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们看到了通过调用下面这段代码返回到根目录是多么容易:</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="fc45" class="nb mb iu lz b gz nc nd l ne nf">router.path = .init()</span></pre><p id="65e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以通过长按返回按钮返回到任何一个屏幕——它会显示一个带有前一个屏幕标题的下拉列表。现在，默认情况下标题会显示<code class="fe lw lx ly lz b">back</code>，但是你可以通过设置<code class="fe lw lx ly lz b">.navigationTitle(string:)</code>修改器来定制它们。</p></div><div class="ab cl ng nh hy ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="in io ip iq ir"><p id="5a51" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然这篇关于新SwiftUI NavigationStack的介绍性文章到此结束，但是您可以使用新模式做更多的事情，比如处理深度链接等等。</p><p id="1bf8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，为了将新的导航API移植到之前的iOS版本，这里有一个<a class="ae kz" href="https://github.com/johnpatrickmorgan/NavigationBackport" rel="noopener ugc nofollow" target="_blank">惊人的开源库</a>。</p><p id="c8a0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目前就这些。以下是整个<a class="ae kz" href="https://gist.github.com/anupamchugh/eba92fc51dbc5e155adfdc3770d31d99" rel="noopener ugc nofollow" target="_blank"> SwiftUI代码片段</a>的要点。</p></div></div>    
</body>
</html>