<html>
<head>
<title>Fixing a Performance Anti-pattern With Amazon DynamoDB and Lessons Learned</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Amazon DynamoDB修复性能反模式及经验教训</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fixing-a-performance-anti-pattern-with-amazon-dynamodb-and-lessons-learned-858b4e570b0d?source=collection_archive---------9-----------------------#2022-07-25">https://betterprogramming.pub/fixing-a-performance-anti-pattern-with-amazon-dynamodb-and-lessons-learned-858b4e570b0d?source=collection_archive---------9-----------------------#2022-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="975a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我使用Amazon DynamoDB的第一步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cfd2ffb125ebe22b09b3bd4f3c386b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Vk6yJtVZ1nXRTmR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@wawa01?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Waren Brasse </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近一直在做一个个人项目，在这个项目中，我决定使用并学习更多关于DynamoDB的知识。虽然我过去在一些小事情上使用过Dynamo，但我过去的大部分经验都是在关系数据库上，我花了一些时间才理解和NoSQL一起工作的意义。</p><h1 id="bc60" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是DynamoDB？</h1><p id="0e9f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">DynamoDB 是亚马逊网络服务完全管理的NoSQL数据库。</p><p id="f775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与将数据存储在结构化行和列中的关系数据库不同，Dynamo数据存储在键值对中。这意味着，与您通常在关系数据库中看到的数据相比，您存储在Dynamo中的数据是非结构化的。您必须定义的惟一模式是您的表键:分区键和排序键。除此之外，您的数据可以是无模式的(尽管您的应用程序仍然需要知道如何处理它)。</p><h1 id="f636" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我的错误</h1><p id="0f99" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我的项目中，我使用Python并通过<code class="fe ms mt mu mv b">boto3</code>库访问Dynamo。这是在AWS Lambda上运行的。在我的代码中，我有一个数据模型<code class="fe ms mt mu mv b">collection</code>，我需要对它进行基本的CRUD(创建、读取、更新、删除)操作。</p><p id="2a5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的代码看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你明白我的错误了吗？</p><blockquote class="my mz na"><p id="5f95" class="kz la nb lb b lc ld ju le lf lg jx lh nc lj lk ll nd ln lo lp ne lr ls lt lu im bi translated">我做的每一个数据库操作，都是在重新初始化<code class="fe ms mt mu mv b">boto3</code>资源和Dynamo表。</p></blockquote><p id="2ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很容易做到(尤其是有了<a class="ae ky" href="https://levelup.gitconnected.com/is-github-copilot-worth-it-3af9d3ee1f81" rel="noopener ugc nofollow" target="_blank"> GitHub Copilot </a>基本上就是给我写的这些功能)，我当时也没怎么想过。然而，在审查一些代码时，我的未婚夫<a class="nf ng ep" href="https://medium.com/u/328f007d818d?source=post_page-----858b4e570b0d--------------------------------" rel="noopener" target="_blank"> Myles Loffler </a>向我指出，这<a class="ae ky" href="https://docs.aws.amazon.com/codeguru/detector-library/python/lambda-client-reuse/" rel="noopener ugc nofollow" target="_blank">实际上是与</a> <code class="fe ms mt mu mv b"><a class="ae ky" href="https://docs.aws.amazon.com/codeguru/detector-library/python/lambda-client-reuse/" rel="noopener ugc nofollow" target="_blank">boto3</a></code> <a class="ae ky" href="https://docs.aws.amazon.com/codeguru/detector-library/python/lambda-client-reuse/" rel="noopener ugc nofollow" target="_blank">客户端一起工作时的反模式，尤其是在Lambda </a>上。</p><p id="3833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:虽然我在使用Dynamo时遇到了这种反模式，但是由于CRUD操作的性质，您可以在任何时候一遍又一遍地重新初始化同一个<code class="fe ms mt mu mv b">boto3</code>资源时遇到它！</p><h1 id="9ce2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我是怎么修好的</h1><p id="d57b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">幸运的是，这很容易修复，而且修复它使我的代码总体上更好！</p><p id="36db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了一个新的<code class="fe ms mt mu mv b">utilities</code>文件来处理我的数据库连接，并添加了以下函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在本例中，Dynamo表名现在通过存储在settings中的一个独立函数进行检索。</p></figure><p id="c974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我重构了我的CRUD函数，只使用了<code class="fe ms mt mu mv b">get_dynamo_table</code>，而不是直接使用<code class="fe ms mt mu mv b">boto3</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现在我可以调用新的get_dynamo_table函数了。</p></figure><p id="281c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到了我的数据库实用程序中全局变量的使用。虽然这通常被认为是一种不好的实践，但是我使用它们是基于Lambda最佳实践，该实践建议<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html" rel="noopener ugc nofollow" target="_blank">利用执行环境重用</a>。</p><h1 id="b28a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">这有什么不同呢？</h1><p id="fca9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这给我的代码带来了四个主要的不同:</p><h2 id="6735" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">表演</h2><p id="6a84" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这明明是大的！</p><p id="07d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进行测试，我部署了应用程序的两个版本，一个使用旧代码，另一个使用新代码，并运行了一些导致CRUD操作的工作流。</p><p id="1b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我的应用程序<strong class="lb iu">在没有</strong>应用此更改的情况下的一些跟踪示例。此操作包括删除一个项目和一个查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/c7d51e590e7e359af264e5281b48d0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQblZkXuTZ01IrKhKVCVhA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">进行此更改之前的删除和查询操作，分别需要84毫秒和76毫秒。</p></figure><p id="682a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是应用了这一更改的应用程序中相同的两个操作(删除和查询)的痕迹:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/b0c88b6061fdd1b143620bde97233fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ehC24qTScEWEMBoiZZVzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">进行此更改后，相同的删除和查询操作分别需要7毫秒和12毫秒。</p></figure><p id="0ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们只是在谈论几分之一秒的时间，但这些延迟会随着时间的推移而增加！应用此更改后，应用程序感觉明显更快，响应更快。</p><h2 id="af71" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">清洁</h2><p id="6fb9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这种方法不仅更容易阅读，而且从长远来看，肯定会减少我的项目中的代码。每当我需要访问数据库时，我不必导入<code class="fe ms mt mu mv b">boto3</code>和访问环境变量。现在只有一个函数可以访问Dynamo，所以如果我需要改变什么，我只需要在一个地方改变它。</p><h2 id="4049" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">易测性</h2><p id="f735" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">测试也更干净。之前，我必须在每个位置模拟<code class="fe ms mt mu mv b">boto3</code>，这也相当复杂，因为我模拟的是一个返回值的返回值。现在我可以模仿<code class="fe ms mt mu mv b">get_dynamo_table</code>，它更加简单易懂。</p><h2 id="472d" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">复用性</h2><p id="6bc4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">utils.db</code>中的新函数根本不关心表名——它是由设置中的<code class="fe ms mt mu mv b">get_dynamo_table_name</code>函数检索的。随着项目的发展，这些代码可以在其他可能使用不同发电机表的Lambdas上重用。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="1076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我上面提到的，我对使用Amazon的DynamoDB相当陌生——我还在学习中！</p></div></div>    
</body>
</html>