<html>
<head>
<title>Debounce Your Complex Selectors With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React钩子去抖你复杂的选择器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/debounce-your-complex-selectors-with-react-hooks-97c315f0db90?source=collection_archive---------8-----------------------#2021-01-08">https://betterprogramming.pub/debounce-your-complex-selectors-with-react-hooks-97c315f0db90?source=collection_archive---------8-----------------------#2021-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">反跳依赖饥饿反应冗余选择器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0d23d93248c8e4d8936c62b5ad94d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qPXLXq0FjuzaWblU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@timmarshall?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·马歇尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="3d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redux在2015年变得超级流行，直到今天，它仍在许多大型代码库中使用。它是由丹·阿布拉莫夫创立的，它解决了当时的一个特殊挑战:国家管理。到目前为止，在最好的状态管理工具上还没有明显的赢家，但是幸运的是，我们有相当多的选择。这完全取决于您的场景和个人偏好。</p><p id="2471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从npm趋势来看，Redux仍然被广泛使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/baacecc6ebc4e994c11a094d301c0dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVyoECJ2A5TPhdjRlDe5LA.png"/></div></div></figure><p id="41f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Redux非常成熟，我们有大量的配套工具和Redux实用程序。最近，<code class="fe lw lx ly lz b">react-redux</code>被移植到了Hooks，这太棒了，它帮助我们摆脱了旧的容器/组件方法。</p><p id="a725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redux有它的缺点——这是毫无疑问的。我们将关注当选择器依赖于许多缩减器时，它的效率会有多低。随着应用程序的增长，缩减器/选择器及其复杂性也在增长。您可能会发现自己处于一个选择器依赖于多个缩减器的场景中。如果那个选择器的消费者只是一个轻的组件，你就没事，但是如果你的组件很贵，你就麻烦了。您有阻塞UI线程的风险。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e7ae" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">依赖关系过多的选择器</h1><p id="4b6a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">想象你有这个Redux商店:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="55ce" class="ni mi it lz b gy nj nk l nl nm">- classes: [...],<br/>- exercises: [...],<br/>- teachers: [...],<br/>...</span></pre><p id="c6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有这些选择器:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="9081" class="ni mi it lz b gy nj nk l nl nm">// this will be aschematic example</span><span id="8d19" class="ni mi it lz b gy nn nk l nl nm">import { createSelector } from 'reselect';</span><span id="f255" class="ni mi it lz b gy nn nk l nl nm">export const teachersSelectors = (state: GlobalState) =&gt;  state.teachers;</span><span id="dab0" class="ni mi it lz b gy nn nk l nl nm">export const classesSelector = (state: GlobalState) =&gt;  state.classes;</span><span id="98ed" class="ni mi it lz b gy nn nk l nl nm">...</span><span id="8755" class="ni mi it lz b gy nn nk l nl nm">export const listClassesWithTeachersAndExercises = createSelector(<br/> classesSelector,<br/> exercisesSelectors,<br/> teachersSelectors) =&gt; // some logic to put together all the data</span></pre><p id="6c1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择器<code class="fe lw lx ly lz b">listClassesWithTeachersAndExercises</code> <br/>依赖于一些不同的存储属性。这意味着一旦这些改变，它将被重新计算。</p><p id="7a2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们有一个REST端点，它返回用户类及其数据依赖项。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="e81f" class="ni mi it lz b gy nj nk l nl nm">[GET] <a class="ae ky" href="https://www.example.com/getStudentAppointments" rel="noopener ugc nofollow" target="_blank">https://www.example.com/s</a>tudent/classes</span><span id="b6bd" class="ni mi it lz b gy nn nk l nl nm">// Sample returned data:</span><span id="661e" class="ni mi it lz b gy nn nk l nl nm">{ classes: [...],<br/>  included: {<br/>    teachers: [...],<br/>    exercises: [...],<br/>  }<br/>}</span></pre><p id="19d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>当将所有这些信息转储到reducer中时，我们的<code class="fe lw lx ly lz b">listAppoinmentsWithTeachersAndExercises</code>选择器将在每次reducer-dependency更新时被重新计算。在这种情况下，它将被重新计算:</p><ul class=""><li id="f1da" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">一次当类被添加到<code class="fe lw lx ly lz b">store.classes</code></li><li id="7ada" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">有一次教师被加到了<code class="fe lw lx ly lz b">store.teachers</code></li><li id="fcdb" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">一次当练习被添加到<code class="fe lw lx ly lz b">store.exercises</code></li></ul><p id="b142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是Redux的标准行为，对此我们无能为力/想做点什么。通常这没什么，我们可以忍受。但是如果我们必须渲染一个超级昂贵的组件呢？</p><p id="e8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那个昂贵的组件可能会阻塞UI线程，这是我们想要避免的。让用户界面冻结几毫秒对用户的UX感知有负面影响。您的web应用程序必须随时响应。</p><p id="1765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使它没有阻塞UI线程，考虑性能也是一个好习惯。可能会有使用过时硬件的用户在查看你的应用。</p><p id="9583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在不久的将来，当并发模式正式发布时，我们将有更多的工具来解决这个问题。现在，我们只是停留在默认的React渲染阻塞行为。</p><p id="0a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此我们能做些什么？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9a99" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">去抖拯救世界</strong></h1><p id="9c96" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">去抖是现在流行的技术。它主要用于搜索自动完成功能。为了避免在每次击键时发出请求，所做的是对端点<code class="fe lw lx ly lz b">http</code>的调用去抖。一旦用户停止输入，端点就被调用。</p><p id="0ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的场景中，可以把每次Redux store更新看作是用户的一次击键。我们将继续去抖我们的选择器，直到所有的存储更新都被执行。我们如何做到这一点？我们将创建一个使用<code class="fe lw lx ly lz b">useSelector</code>钩子的定制钩子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="ce33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>钩子是用TypeScript写的。如果对打字稿不感兴趣，可以去掉。不过，我强烈建议使用它们，因为在键入选择器时，更容易知道它们各自应该返回什么。这在大型代码库中特别有用。</p><p id="2fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这里发生的一些关键事情。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="84b7" class="ni mi it lz b gy nj nk l nl nm">// this is were our debounced data will be stored<br/>const [data, setState] = useState&lt;unknown&gt;();</span></pre><p id="6a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次这个定制钩子被调用时，无论是由<code class="fe lw lx ly lz b">useSelector</code>还是因为钩子调用者被刷新，我们将:</p><p id="5db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.清除先前的超时(如果有)。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="6edf" class="ni mi it lz b gy nj nk l nl nm">if (refTimeout.current) {<br/>  clearTimeout(refTimeout.current);<br/>}</span></pre><p id="801e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.设置一个新的超时时间来更新<code class="fe lw lx ly lz b">data</code>信息，以防在<code class="fe lw lx ly lz b">time</code>毫秒内钩子不再刷新。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="27a2" class="ni mi it lz b gy nj nk l nl nm">refTimeout.current = setTimeout(() =&gt; {<br/>  if (result.current !== selectorData) {<br/>    setState(selectorData);<br/>  }<br/>}, time);</span></pre><p id="f803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果钩子被卸载了，我们会自己清理以确保我们没有更新一个卸载钩子的<code class="fe lw lx ly lz b">state</code>。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="6a81" class="ni mi it lz b gy nj nk l nl nm">useEffect(() =&gt; () =&gt; refTimeout.current &amp;&amp;  clearTimeout(refTimeout.current), []);</span></pre><p id="831b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个钩子的另一个特性是你可以有条件的去抖。如果<code class="fe lw lx ly lz b">time</code>参数设置为<code class="fe lw lx ly lz b">0</code>，则不会发生去抖，选择器的结果将立即返回。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="560f" class="ni mi it lz b gy nj nk l nl nm">if (time === 0) {<br/>  return selectorData;<br/>}</span></pre><p id="5007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何使用它？非常简单:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="d932" class="ni mi it lz b gy nj nk l nl nm">const list = useDebounceSelector(<!-- -->listAppoinmentsWithTeachersAndExercises<!-- -->);</span></pre><p id="a389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想有条件地设置超时:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="92e2" class="ni mi it lz b gy nj nk l nl nm">const debouncedList = useDebounceSelector(<!-- -->listAppoinmentsWithTeachersAndExercises, 250<!-- -->);</span><span id="2fd2" class="ni mi it lz b gy nn nk l nl nm">// if init variable is true it will not debounce otherwise it will do a 250ms debounce</span><span id="d556" class="ni mi it lz b gy nn nk l nl nm">const conditionallyDebounceList = useDebounceSelector(<!-- -->listAppoinmentsWithTeachersAndExercises, init ? 0 : 250<!-- -->);</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="3dd2" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">包装</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/fc9cab45cd97a3be3de2b4b22255b769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CibtRnivUltp6WXE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="26cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，不是吗？在几行代码中，我们创建了一个可以在任何组件中使用的实用程序挂钩。这将使我们避免在昂贵的组件上做不必要的渲染。当然，这个钩子只在特定的场景下使用，所以要明智地使用它。</p><p id="8435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想继续钻研TypeScript，可以阅读我下面的另一篇文章。</p><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/mastering-typescripts-mapped-types-5fa5700385eb" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">掌握TypeScript的映射类型</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">学习如何像专家一样处理映射类型</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><p id="a353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p></div></div>    
</body>
</html>