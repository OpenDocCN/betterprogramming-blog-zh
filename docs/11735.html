<html>
<head>
<title>How to Use SpriteKit in Your iOS Arcade Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在你的iOS街机游戏中使用SpriteKit</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-your-arcade-ios-game-using-spritekit-and-gameplaykit-make-it-spritey-547a871b690f?source=collection_archive---------16-----------------------#2022-04-12">https://betterprogramming.pub/how-to-make-your-arcade-ios-game-using-spritekit-and-gameplaykit-make-it-spritey-547a871b690f?source=collection_archive---------16-----------------------#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a532" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让它精神点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c400954f14dd15c85fc536e4c84adeb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_5Cni1LA0I7ID_kqVNdgw.png"/></div></div></figure><p id="9dd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你有没有想过在苹果手机平台上开发你的街机游戏？那就加入我的旅程吧，在这里你将加深对<em class="ln">苹果游戏开发</em>环境中最常用框架的理解。没错，我说的就是<code class="fe lo lp lq lr b">SpriteKit</code>和<code class="fe lo lp lq lr b">GameplayKit</code>！<br/>这篇文章特别将<em class="ln">聚焦于SpriteKit。</em></p><p id="13ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我是Luigi，今天我将向你们展示我是如何制作河豚的，这是一个简单的游戏，你将扮演一只河豚，它必须避免碰到一些坏海马，并躲避它们向你扔来的泡泡。命令非常简单，只需在屏幕上移动手指，就可以相应地移动河豚。每当你被泡泡伤害时，河豚的尺寸就会增加，同时给出你仍然可以击中的视觉提示(三次击中，你就完成了)，而与敌人接触会让你直接进入屏幕上的游戏。你的分数会随着时间的推移而增加，所以你越能抵抗敌人的攻击，你的分数就越高。这个游戏是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/74b10012eec87f809bc00778deee2564.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*zyIg8JJBMts9Eti7qOrQ4A.gif"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated"><em class="lx">河豚的快速玩法</em></p></figure><p id="4be9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重要的是要知道这不是一个从头开始的教程，所以你需要一些SpriteKit的基础知识来更好地理解接下来的段落中将要涉及的内容。不过不要担心，这比看起来容易！</p><p id="87fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一定要检查它的<strong class="kt ir"> </strong> GitHub库，这样你就可以在我解释的时候看看整个项目。</p><div class="ly lz gp gr ma mb"><a href="https://github.com/Decoyman24/Fugu-Pufferblast" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd ir gy z fp mg fr fs mh fu fw ip bi translated">GitHub-decoy man 24/Fugu-puffer blast:一款我在游戏卡壳期间用SpriteKit做的iOS街机游戏。</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">github.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp kp mb"/></div></div></a></div><p id="55d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一个外部测试飞行链接，用于在游戏发布到应用商店之前试用游戏(这将很快发生)。确保从iOS设备打开此链接！</p><div class="ly lz gp gr ma mb"><a href="https://testflight.apple.com/join/R7NjDRs0" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd ir gy z fp mg fr fs mh fu fw ip bi translated">加入河豚:河豚贝塔</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">使用TestFlight应用程序帮助开发人员测试他们的应用程序和应用程序剪辑的测试版。在应用程序上下载TestFlight</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">testflight.apple.com</p></div></div><div class="mk l"><div class="mq l mm mn mo mk mp kp mb"/></div></div></a></div><p id="dd7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为有很多关于SpriteKit和它如何工作的内容要讨论，而且我不想让你整天阅读无聊的东西，所以我们将保持它的简单，只覆盖那些难以理解的代码部分！</p><p id="3337" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要了解GameScene的整个流程(游戏性发生的实际部分)，以及SpriteKit如何处理一些事件，如用户的输入或我们给出的约束。</p><p id="ec42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，有一些游戏场景特有的功能，我们可以用它们来创造奇迹。</p><p id="d419" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们说的是<code class="fe lo lp lq lr b">update</code>、<code class="fe lo lp lq lr b">touchesBegan</code> / <code class="fe lo lp lq lr b">touchesMoved</code> / <code class="fe lo lp lq lr b">touchesEnded</code>、<code class="fe lo lp lq lr b">didMove(to)</code>、<code class="fe lo lp lq lr b">didBegin</code>和<code class="fe lo lp lq lr b">didEnd</code>函数。</p><p id="bb52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中一些函数依赖于SpriteKit的物理部分，我们将在后面介绍它们。</p><p id="0081" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们从最重要的开始。</p><h1 id="a7cf" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">didMove(to)函数</h1><p id="3037" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated"><code class="fe lo lp lq lr b">GameScene</code>的<code class="fe lo lp lq lr b">didMove(to)</code>功能基本上就是当你<strong class="kt ir">移动到</strong>游戏场景时发生的事情。</p><p id="18c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你想在这里放入任何需要渲染的元素，以及它们的属性，或者开始播放背景音乐。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b984" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里你也可以定义游戏场景本身的一些属性，比如显示调试数据(FPS，当前渲染的节点)，设置是否显示物理实体等等。</p><p id="6965" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个项目中，我们将使用<code class="fe lo lp lq lr b">didMove(to)</code>来创建我们的主角河豚，这个超级胡萝卜将不时地产卵，乐谱文本，以及一些我们稍后需要的隐藏的东西。</p><p id="5b53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从添加Fugu开始，它将在GameScene的作用域中声明为一个<code class="fe lo lp lq lr b">Puffer</code>类实例。</p><p id="1085" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想要更多的细节，你可以检查项目中的代码，但是Puffer类基本上包含了根据Fugu的状态创建不同动画的方法和一个名为<em class="ln"> damageable </em>的布尔属性，我们用它来了解Fugu何时容易受到敌人的攻击。</p><p id="b53a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只需在<code class="fe lo lp lq lr b">GameScene</code>下添加以下内容:</p><pre class="kg kh ki kj gt nq lr nr ns aw nt bi"><span id="feca" class="nu ms iq lr b gy nv nw l nx ny">var puffer = Puffer()</span></pre><p id="5af4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以返回到<code class="fe lo lp lq lr b">didMove(to)</code>函数，创建我们美丽的河豚。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c18e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，有很多线只是为了一条小河豚。</p><p id="5fd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们刚刚做的是为<code class="fe lo lp lq lr b">puffer</code>实例设置一些属性，例如它在屏幕上的位置(在正中间)，我们稍后将讨论的一些物理属性，它在Z轴上的位置，所以它在屏幕的前面(因为我们的背景将在较低的Z位置)和它的比例(维度)，因为真实资产分辨率高于我们在屏幕上想要的维度，所以我们将它设置为其原始维度的1/4。</p><p id="33e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，最重要的一步是我们将河豚加入游戏场景。这是通过<code class="fe lo lp lq lr b">addChild(puffer) </code>命令完成的。</p><p id="d59b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这基本上是添加了一个sprite作为GameScene的子元素(它是包含我们所有元素的父元素)，所以我们基本上每次想在屏幕上添加东西的时候都会使用这个命令。</p><p id="72f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们也可以用它来添加背景图片和横幅，但是我们将在稍后通过编辑器来处理场景的大小。</p><p id="d73c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要<em class="ln">最后一件事</em>来应用于我们的河豚。因为我们要在一个巨大的空间里自由移动，我们要对Fugu的移动范围施加一些限制，以避免他离开屏幕。</p><p id="bdbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只需在前面的代码块之前写这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="abf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们刚刚做的是为Fugu的X和Y位置创建两个<code class="fe lo lp lq lr b">SKRange</code>值，这样他就不能超出这些界限。我们使用<code class="fe lo lp lq lr b">self.frame.width</code>和<code class="fe lo lp lq lr b">self.frame.height</code>值来使用场景的框架(简单来说就是屏幕的边缘)作为限制。</p><p id="c1cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们将这个约束应用于带有<em class="ln">的<code class="fe lo lp lq lr b">puffer</code>实例。约束</em>修改器。</p><p id="57cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要对场景本身应用一些属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2daf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了我们稍后将要讨论的所有物理属性，我们可以注意到GameScene本身的一些有趣的修饰符，如<code class="fe lo lp lq lr b">.showsFPS</code> <em class="ln">、</em> <code class="fe lo lp lq lr b">.showsNodeCount</code> <em class="ln">和</em> <code class="fe lo lp lq lr b">.showsPhysics</code> <em class="ln">、</em>，它们可以分别用于显示FPS计数器、屏幕上渲染的节点数量以及运行时节点的物理点击框。</p><p id="3899" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，我们还在游戏场景中添加了一个<code class="fe lo lp lq lr b">worldNode</code>孩子。这是一个SKNode值，它充当其他<code class="fe lo lp lq lr b">SKSpriteNodes</code>的容器，当游戏暂停时，我们将使用它来暂停屏幕上所有其他移动的元素。</p><p id="6f7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将分数标签添加到场景中的时间。这使用了一个<code class="fe lo lp lq lr b">gameScore</code>值，该值将用于跟踪用户的分数久而久之。</p><p id="ccdf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将此代码添加到之前编写的代码块中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d605" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们在屏幕的上角添加了标签。</p><h1 id="3ca2" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">更新功能</h1><p id="9bdf" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">现在来说说<code class="fe lo lp lq lr b">update</code>功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0ac0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是你想知道它工作的主要函数之一，因为它是你的<code class="fe lo lp lq lr b">GameScene</code>在每一帧调用的函数(当你的场景没有暂停时)。我可以向你保证，那是一大堆电话！</p><p id="d39a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果你的游戏要以60 FPS(每秒帧数)运行，通常是这样，那么<code class="fe lo lp lq lr b">update</code>函数将在一秒钟内被调用60次</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/496a07b7cbb8020ec02460fa8b1de21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zWmckbyqIO8pilzT.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">来源:<a class="ae oa" href="https://developer.apple.com/documentation/spritekit/skscene/responding_to_frame-cycle_events" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/sprite kit/sk scene/responding _ to _ frame-cycle _ events</a></p></figure><p id="34a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这张图片解释了<code class="fe lo lp lq lr b">SpriteKit</code>应用程序中每一帧的精确情况。</p><p id="e267" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，首先要做的是运行更新函数中的所有内容。</p><p id="ca8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在更新功能之后，<code class="fe lo lp lq lr b">GameScene</code> ( <code class="fe lo lp lq lr b">SKScene</code>)评估任何动作(精灵的移动、过渡等)。)或您可能已经定义的控制语句，然后它继续模拟其物理特性(如精灵之间的碰撞)，应用约束(例如，无论对角色施加什么力，您都可以将角色放在固定的位置上)，并最终在屏幕上渲染每个元素。</p><p id="e4d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">知道了这一点，我们无法想象在某些情况下使用<code class="fe lo lp lq lr b">update</code>让事情发生，例如，当你的角色死亡时播放声音，因为这将导致每秒播放60次你的声音，直到你的游戏暂停或直到你关闭应用程序。我们不希望这样。</p><p id="35b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，在我们的例子中，我们可以使用这个函数使我们的分数随着时间的推移而增加。</p><p id="1802" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们首先在GameScene的范围内声明一个<code class="fe lo lp lq lr b">gameScore</code>变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f0e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们已经在游戏开始时将分数设置为0，只需要增加分数即可。</p><p id="a3f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们是这样做的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3cdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的游戏过程中，只要游戏没有暂停，基本上会在每一帧开始时给我们的分数增加1/3/6分。每一帧给出的点数取决于<code class="fe lo lp lq lr b">pufferState</code>变量，这意味着我们受到的伤害越大，我们得到的点数就越多，因为河豚越大，我们就越难避免气泡。</p><h1 id="1db8" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">触摸开始/触摸移动/触摸结束功能</h1><p id="7828" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">这三个函数处理用户与屏幕交互(点击)的每个阶段发生的事情，从它们的名字就可以很容易理解。在这一部分，我们将处理屏幕上的河豚运动。</p><h1 id="9c07" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">touchesBegan():</h1><p id="c767" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">在这里，我们将处理交互的初始部分，即当我们开始点击屏幕时。</p><p id="43be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这属于<code class="fe lo lp lq lr b">GameScene</code>的范围:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9e1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里做的是当我们控制Fugu(我们将在下一部分使用它)以及使用<code class="fe lo lp lq lr b">startTouch</code>(一个<code class="fe lo lp lq lr b">CGPoint</code>值)来锁定我们刚刚点击的屏幕部分时，将bool值设置为true。然后，我们将Fugu的实际位置存储在<code class="fe lo lp lq lr b">nodePosition</code>中，以便以后移动它。</p><h1 id="d22e" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">touchesMoved():</h1><p id="4dfc" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">在这个函数中，我们现在将处理当我们在屏幕上点击之后，在放开之前继续移动手指时会发生什么。在<code class="fe lo lp lq lr b">touchesBegan()</code>函数之后写这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3fc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里发生的事情非常简单。这一切都是从我们<code class="fe lo lp lq lr b">controlling</code> Fugu这个前提开始的，也就是说我们已经开始敲击屏幕了。</p><p id="b98c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们只是简单地用一个<code class="fe lo lp lq lr b">SKAction.move</code>将Fugu的位置改变为X和Y的计算值，这些值简单地从<code class="fe lo lp lq lr b">nodePosition</code>中取其原始位置(其值在<code class="fe lo lp lq lr b">touchesBegan</code>函数中设置)并加上<code class="fe lo lp lq lr b">location</code>的X和Y，这个函数中使用的临时值用于跟踪手指在屏幕上移动的位置。这就是全部了！</p><h1 id="bea7" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">touchesEnded():</h1><p id="25e9" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们之前说过，<code class="fe lo lp lq lr b">touchesEnded()</code>处理我们将手指从屏幕上抬起的瞬间发生的事情。</p><p id="32b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了将<code class="fe lo lp lq lr b">controlling</code> bool设置为false以便我们知道我们不再控制Fugu之外，我们没有出于任何特殊原因使用这个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="ad2c" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">让我们开始身体接触吧</h1><p id="3347" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们现在要讨论的是让游戏变得生动的部分，也就是物理。</p><p id="99cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们用它来创造游戏中的特定事件，比如被炮弹击中，碰到敌人，或者获得能量。物理也可以模拟碰撞，施加力，等等，但是我们在这个游戏中不需要这些。</p><p id="5b05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SpriteKit处理物理的方式相当简单。我们可以给每个实体(在我们的例子中是<code class="fe lo lp lq lr b">SKSpriteNodes</code>)分配特定的<code class="fe lo lp lq lr b">.physicsBody</code>值。先从分析河豚的属性开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bf52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以看到我们有很多关于<code class="fe lo lp lq lr b">.physicsBody</code>的修饰语，但是不要感到气馁，理解这项工作并不像看起来那么难。</p><p id="46a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在谈论分配给它的实际修改器之前，我们必须了解我们的精灵有哪种物理实体。有3种可能的物理实体，正方形、圆形和alpha mask。</p><p id="15c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，它是一个圆形物体，半径等于分配给<code class="fe lo lp lq lr b">puffer</code>的精灵的原始高度(因此它不包括我们在<em class="ln"> didMoveTo </em>函数中设置的0.25的缩放)，这意味着如果您将<code class="fe lo lp lq lr b">view.showsPhysics</code>的值从<code class="fe lo lp lq lr b">didMove(to)</code>设置为<code class="fe lo lp lq lr b">true</code>，您将在Fugu的身体周围看到类似这样的东西:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2b3d8046fafbf41c22b6d4094b66709c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*uuRSqDL0s4lR_veAalUNsw.png"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">河豚被一个神秘的圆圈包围着。</p></figure><p id="6a7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们分配给它的物理实体，它的形状是圆形的。很简单。</p><p id="2fac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外两个不言自明的属性是<code class="fe lo lp lq lr b">.affectedByGravity</code>和<code class="fe lo lp lq lr b">isDynamic</code>。</p><p id="984f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，通过将这两个设置为<code class="fe lo lp lq lr b">false</code>，我们不会施加任何由整个场景的重力引起的力(无论如何，重力被设置为0 ),我们还可以确定，无论发生什么，当与其他身体接触时，河豚的身体都不会发生冲突。</p><p id="e48f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在是有趣的部分。</p><p id="02aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在SpriteKit的物理学中，我们使用类别位掩码来理解身体的哪个类别与另一个类别接触。我们将无法理解，例如，当Fugu触摸敌人的投射物，敌人本身，或者仅仅是屏幕的边缘。</p><p id="bc95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在<code class="fe lo lp lq lr b">GameScene</code>的范围之外声明我们的类别位掩码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9066" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类别位掩码就是二进制整数，您可以在注释中看到它们的实际值。</p><p id="a06f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要用它们来做计算，一旦声明我们可以用它们的名字来做任何我们需要的操作。</p><p id="dbb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到<code class="fe lo lp lq lr b">puffer</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="eec6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以看到河豚(通过他的<code class="fe lo lp lq lr b">.categoryBitMask</code>)被识别为<code class="fe lo lp lq lr b">PhysicsCategory.Ally</code>，它会碰撞的唯一一类物体(导致停止自己或以足够的冲力移动另一个物体)是<code class="fe lo lp lq lr b">PhysicsCategory.Wall</code>物体，我们想知道接触时(是的，是<code class="fe lo lp lq lr b">.contactTestBitMask</code>)的物体是<code class="fe lo lp lq lr b">Bullet</code>、<code class="fe lo lp lq lr b">Enemy</code>、<code class="fe lo lp lq lr b">Carrot</code>、<code class="fe lo lp lq lr b">Letter</code>和<code class="fe lo lp lq lr b">Wall</code>。这意味着，如果我们不将这些类别放在<code class="fe lo lp lq lr b">.contactTestBitMask</code>下，我们将无法控制这些类别何时会发生冲突。</p><p id="c374" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">花点时间来更好地理解这些概念，因为SpriteKit物理背后的所有逻辑都围绕着这三个修改器！</p><p id="4a98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们来谈谈最后两个<code class="fe lo lp lq lr b">GameScene</code>特定于SpriteKit物理的功能:<code class="fe lo lp lq lr b">didBegin()</code>和<code class="fe lo lp lq lr b">didEnd()</code>。当两个物体之间的碰撞开始和结束时，这是两个参与的功能(正如他们的名字所暗示的)，但是为了让这两个功能发挥作用，我们需要有一个<code class="fe lo lp lq lr b">SKPhysicsContactDelegate</code>简而言之就是一个有权监视物理接触的场景。我们在声明它的时候已经把它分配到我们的游戏场景中了！</p><pre class="kg kh ki kj gt nq lr nr ns aw nt bi"><span id="0e10" class="nu ms iq lr b gy nv nw l nx ny">class GameScene: SKScene, SKPhysicsContactDelegate {</span></pre><p id="9ef4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们只需要将这行代码添加到<code class="fe lo lp lq lr b">didMove(to)</code>函数中:</p><pre class="kg kh ki kj gt nq lr nr ns aw nt bi"><span id="77cb" class="nu ms iq lr b gy nv nw l nx ny">physicsWorld.contactDelegate = self</span></pre><p id="1873" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这个，游戏场景被正式指定为联络代表！</p><p id="6c6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们转到它的两个功能。</p><h1 id="f6cd" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">didBegin():</h1><p id="f7dc" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">每当两个<code class="fe lo lp lq lr b">SKPhysics</code>物体接触时，我们的游戏都会调用这个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7be0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们有一个<code class="fe lo lp lq lr b">collision</code>常数，它等于一个<code class="fe lo lp lq lr b">bodyA</code>和<code class="fe lo lp lq lr b">bodyB</code>之间的接触。</p><p id="4373" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于类别位掩码是二进制值，SpriteKit用一个<strong class="kt ir"> | </strong>(逻辑或)运算符来计算两者之间的联系。</p><p id="9021" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在河豚可以受到伤害的前提下(因为他可以有无敌的阶段)，我们将根据哪些身体相互冲突来调用不同的函数。</p><p id="d875" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要注意的是尸体的顺序很重要，这就是为什么我们有两个调用<code class="fe lo lp lq lr b">enemyHit()</code>函数的例子，当河豚接触到敌人或被敌人接触时会发生这个函数。</p><p id="9a7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为子弹总是以固定的速度前进，所以它们总是第一个接触到河豚的身体，所以我们只需要一个条件来承受子弹的伤害。</p><p id="bac6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">超级胡萝卜也是一样，因为它的位置永远是固定的，无论如何，第一个与它相撞的将是河豚。</p><h1 id="097e" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">didEnd():</h1><p id="bd30" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">关于这个功能没有太多要说的，因为它发生在两个物体接触结束的时候。它在某些情况下是有用的(例如当一个角色从开关上下来时)，但是我们根本不会使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="fa8c" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">暂时就这样吧！</h1><p id="43c0" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">如果你想了解更多关于使用苹果的框架为iOS制作游戏的知识<a class="ae oa" href="https://medium.com/@orleone.dev/make-it-structured-gameplaykit-6d7e79d5a44a" rel="noopener">由<a class="oc od ep" href="https://medium.com/u/fe472f263de1?source=post_page-----547a871b690f--------------------------------" rel="noopener" target="_blank"><em class="ln">or este Leone</em></a><em class="ln"/>撰写的这篇文章</a>可以派上用场。在这里，俄瑞斯忒斯将介绍<code class="fe lo lp lq lr b">GameplayKit</code>是如何工作的！我强烈建议你这么做，因为GameplayKit是一个很棒的框架，它将帮助你使你的游戏更加结构化。</p></div></div>    
</body>
</html>