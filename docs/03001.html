<html>
<head>
<title>Get a Full-Stack Development Environment Ready With Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker Compose准备好全栈开发环境</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/get-a-full-stack-development-environment-ready-with-docker-compose-b88d4a56a7f2?source=collection_archive---------10-----------------------#2020-01-14">https://betterprogramming.pub/get-a-full-stack-development-environment-ready-with-docker-compose-b88d4a56a7f2?source=collection_archive---------10-----------------------#2020-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="34c4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">开始在一个集装箱化的环境中开发您的新的全栈应用程序，以前很少或没有Docker经验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/302d8403fac7567c91a96d36f1fa45fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMI20DDdWnKf5PzFK7BDxQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@chuttersnap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae kv" href="https://unsplash.com/s/photos/stack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="580e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将介绍如何设置开始开发全栈web应用程序所需的所有容器。</p><p id="6642" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然在这里，我将使用特定的技术，但是在每个容器中运行的技术可以通过一些小的改变被您喜欢的技术所替代。</p><p id="dbfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，请注意，本文将只涵盖开发的设置。本文中包含的所有docker文件都不是生产就绪的。</p><p id="102c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看我们的基础架构将会是什么样子。为此，我将首先展示我们项目的文件结构:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="c5ce" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">app</strong><br/>├── docker-compose.yaml<br/>├── api<br/>│   ├── Dockerfile.dev<br/>│   ├── go.mod<br/>│   └── main.go<br/>├── client<br/>│   ├── Dockerfile.dev<br/>│   └── <em class="md">create-react-app files and directories</em><br/>└── nginx<br/>    ├── default.conf<br/>    └── Dockerfile.dev</span></pre><p id="ee61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个结构中，我们可以看到我们将使用<a class="ae kv" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go lang </a>(和web框架<a class="ae kv" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> Gin </a>)作为后端，使用<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>作为前端。</p><p id="ae34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我将添加另外两个服务，一个数据库和一个缓存。我们的docker-compose文件将包含一个<a class="ae kv" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgres </a>容器，以及一个<a class="ae kv" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> redis </a>容器，以展示这些服务将如何集成到我们的应用程序中。</p><p id="1805" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，我也决定使用一个<a class="ae kv" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>服务器。虽然这对于我们的开发环境来说不是必需的，因为我们可以使用本地机器作为开发服务器，但是这个服务器将在生产中消失，所以在我们的docker-compose构建中使用NGINX将使从这个开发构建过渡到生产就绪构建变得更加容易。</p><p id="7eab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将为我们的React客户机创建docker文件。为此，首先导航到项目的根目录(在本教程中，<code class="fe me mf mg lt b">app/</code>目录将扮演这个角色)并运行以下命令:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="6cd3" class="lx ly iq lt b gy lz ma l mb mc">npx create-react-app client</span></pre><p id="8f1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦命令执行完毕，我们就可以让基本的React客户端就绪了。使用前面的命令启动它的唯一问题是，默认情况下，它会在<code class="fe me mf mg lt b">client/</code> <em class="md"> </em>目录中创建一个g it存储库，所以请确保删除它<em class="md">。</em></p><p id="6f10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，我们已经准备好创建我们的第一个docker文件，所以我们将把下面几行添加到一个名为<code class="fe me mf mg lt b">Dockerfile.dev</code>的文件中，该文件将位于客户端/目录<em class="md">中。</em></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f90b" class="lx ly iq lt b gy lz ma l mb mc">FROM node:alpine</span><span id="d4b2" class="lx ly iq lt b gy mh ma l mb mc">WORKDIR /app</span><span id="b3d4" class="lx ly iq lt b gy mh ma l mb mc">COPY ./package.json ./</span><span id="a351" class="lx ly iq lt b gy mh ma l mb mc">RUN npm install</span><span id="cdfd" class="lx ly iq lt b gy mh ma l mb mc">COPY . .</span><span id="4e51" class="lx ly iq lt b gy mh ma l mb mc">CMD [“npm”,”run”, “start”]</span></pre><p id="8f72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这是一个基本的other文件，但我将强调一个值得注意的最佳实践:为了避免每次更新文件时重新缓存<code class="fe me mf mg lt b">package.json</code>文件，我们将它的副本与其他文件分开。</p><p id="0ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们可以避免在每次构建时运行<code class="fe me mf mg lt b">npm install</code> <em class="md"> </em>命令，这是构建Docker映像最耗时的步骤之一。</p><p id="29b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，在我们的构建中指定我们想要的图像版本通常是有趣的，因为它增强了我们的容器的一致性。</p><p id="9066" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，我选择了<code class="fe me mf mg lt b">node:alpine</code>映像，这是一个最小映像，也就是说，它包含运行npm的最小映像。</p><p id="7863" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到后端方面，我们先用Go的<a class="ae kv" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> Gin </a> web框架创建一个基础服务器。导航到<code class="fe me mf mg lt b">app/api</code>目录并创建一个文件<code class="fe me mf mg lt b">main.go</code> <em class="md"> : </em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基本Gin服务器</p></figure><p id="6e7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要一个<code class="fe me mf mg lt b">go.mod</code>文件，它相当于npm中的<code class="fe me mf mg lt b">package.json</code>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="46fc" class="lx ly iq lt b gy lz ma l mb mc">module github.com/&lt;yourUsername&gt;/&lt;nameOfYourProject&gt;</span><span id="22b7" class="lx ly iq lt b gy mh ma l mb mc">go 1.13</span><span id="20da" class="lx ly iq lt b gy mh ma l mb mc">require github.com/gin-gonic/gin v1.5.0</span></pre><p id="1f5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们准备好了两个文件，我们就可以开始在API目录中编写我们的<code class="fe me mf mg lt b">Dockerfile.dev</code>文件:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="fda7" class="lx ly iq lt b gy lz ma l mb mc">FROM golang:latest</span><span id="cbf7" class="lx ly iq lt b gy mh ma l mb mc">ENV GO111MODULE=on</span><span id="33d8" class="lx ly iq lt b gy mh ma l mb mc">WORKDIR /app</span><span id="a559" class="lx ly iq lt b gy mh ma l mb mc">COPY ./go.mod .</span><span id="9db2" class="lx ly iq lt b gy mh ma l mb mc">RUN go mod download</span><span id="7340" class="lx ly iq lt b gy mh ma l mb mc">RUN go get github.com/pilu/fresh</span><span id="081e" class="lx ly iq lt b gy mh ma l mb mc">COPY . .</span><span id="4a44" class="lx ly iq lt b gy mh ma l mb mc">CMD ["fresh"]</span></pre><p id="71f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经注意到，在这个other文件中，我们遵循与另一个文件相同的最佳实践。</p><p id="84ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经将<code class="fe me mf mg lt b">go.mod</code>副本从其他文件中分离出来，因为这将防止在没有添加新的依赖关系时执行<code class="fe me mf mg lt b">go mod download command</code> <em class="md"> </em>。</p><p id="3aee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，您可能已经注意到这个容器将要运行的默认命令是<code class="fe me mf mg lt b">fresh</code> <em class="md"> </em>而不是<code class="fe me mf mg lt b">go run main.go</code> <em class="md">。</em></p><p id="ee87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您曾经使用过Gin，您就会知道热重载不是这个框架中的默认特性。由于这是开发环境中的一个期望特性，我们将使用<a class="ae kv" href="https://github.com/gravityblast/fresh" rel="noopener ugc nofollow" target="_blank"> fresh </a>，这是一个命令行工具，每次文件更新时它都会构建并重启一个web应用程序。</p><p id="e1b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，进入docker-compose文件之前的唯一一步是设置NGINX服务器。首先创建一个<code class="fe me mf mg lt b">nginx/</code>目录，里面有一个名为<code class="fe me mf mg lt b">default.conf</code>的文件；</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们NGINX服务器的默认配置</p></figure><p id="bc8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，这个文件将告诉NGINX创建一个监听端口80的服务器，然后将请求重定向到它的一个上游服务器。</p><p id="53a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果请求的端点以<code class="fe me mf mg lt b">/api/</code>，<em class="md"> </em>开始，NGINX <em class="md"> </em>将代理把请求传递给我们的API服务器。</p><p id="d3a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果端点是任何其他端点，客户端-服务器将是获得请求的那个。另一条规则与<a class="ae kv" href="https://github.com/sockjs/sockjs-node" rel="noopener ugc nofollow" target="_blank"> WebSockets (SockJS) </a>相关，但是最初，如果您决定跳过这条规则，也没什么大不了的。</p><p id="9571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NGINX服务器的<code class="fe me mf mg lt b">Dockerfile.dev</code>将是最简单的:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="0bf1" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">FROM</strong> nginx</span><span id="713c" class="lx ly iq lt b gy mh ma l mb mc"><strong class="lt ir">COPY</strong> ./default.conf /etc/nginx/conf.d/default.conf</span></pre><p id="74f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经完成了所有的Docker文件，我们可以进入最后一步:Docker组合配置。</p><p id="37aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。</p><p id="4336" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个文件中，我们定义了用来构建容器的docker文件、它们必须公开的端口、它们必须定义的卷等等。</p><p id="dfd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这个文件乍一看似乎有点吓人，但它实际上是您可能已经熟悉的所有工具的汇编:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker撰写</p></figure><p id="0675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想解决的第一件事是我们可以分配给Docker容器的不同重启策略。</p><p id="1919" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有4种策略:<em class="md">否，始终，故障时，除非停止</em>。请注意，我已经将<em class="md"> always </em>分配给NGINX服务器，将<em class="md"> on-failure </em>分配给API服务器，但是实际上，除非您有理由重新启动另一个服务，否则我们的应用程序中唯一感兴趣的服务是NGINX服务器的服务。</p><p id="728d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们的NGINX服务器是将流量重定向到其他容器的服务器，所以当它关闭时，任何其他服务都无法工作。</p><p id="b656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我已经为所有容器添加了端口映射。虽然我选择的端口大多是标准端口，但是它们也可以被更改为您喜欢的任何其他端口。</p><p id="1b99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，这里添加的卷满足以下两种需求之一:它们要么支持热重装(API和客户机容器)，要么允许数据持久性(redis和Postgres容器)。</p><p id="e317" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，使用Docker Compose向容器传递环境变量相当容易。</p><p id="8c6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所观察到的，可以只在docker-compose文件中添加变量本身，或者更好的是，创建一个. env <em class="md"> </em>文件来存储变量，尤其是那些不应该共享的变量(密码、密钥……)。</p><p id="f288" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您完成了所有需要的文件，就该运行您的项目并测试一切都正常工作了。为此，只需在根目录下运行以下命令:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5e75" class="lx ly iq lt b gy lz ma l mb mc">docker-compose up --build</span></pre><p id="2a76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过运行以下命令来查看容器是否已成功创建:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9904" class="lx ly iq lt b gy lz ma l mb mc">docker-compose ps</span></pre><p id="d6ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成开发后，您可以通过运行以下命令立即停止所有容器:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="8586" class="lx ly iq lt b gy lz ma l mb mc">docker-compose down</span></pre></div></div>    
</body>
</html>