<html>
<head>
<title>Understand RxJava in a New Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以新的方式理解RxJava</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-rxjava-in-a-new-way-3f43f2696c8c?source=collection_archive---------7-----------------------#2020-10-06">https://betterprogramming.pub/understand-rxjava-in-a-new-way-3f43f2696c8c?source=collection_archive---------7-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba77" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用动画图学习RxJava</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b9ef943c8726b1f9670ddcc4ddd4d99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhBuvc24QPJpiyrrP99liQ.jpeg"/></div></div></figure><p id="da55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">反应式编程是编写清晰代码的一种非常重要的方式，而<a class="ae ln" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>是以反应方式异步处理数据序列的最著名的库之一。</p><p id="b55f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于Android开发者，我们使用的是<a class="ae ln" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>。</p><p id="6a69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将使用RxLab应用程序，通过可视化图表、动画和交互来学习RxJava。</p><p id="59fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:本文不会涉及RxJava。它只会帮助你理解和记住如何工作。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="805c" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">RxLab是什么？</h1><p id="01cc" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">RxLab是一款Android应用。这是学习ReactiveX动画编程、调度程序和时间管理的开源和神奇的工具。</p><p id="4bd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://play.google.com/store/apps/details?id=com.github.anastr.rxlab" rel="noopener ugc nofollow" target="_blank">从Google Play下载应用</a>开始学习，或者从Github获取最新更新和源代码:</p><div class="ms mt gp gr mu mv"><a href="https://github.com/anastr/RxLab" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">anastr/RxLab</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">在GitHub上使用动画、调度程序和时间项目学习ReactiveX编程的神奇工具。这是一个开放的…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj kp mv"/></div></div></a></div><p id="d48a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们开始之前，我想解释一下这个应用程序是如何产生emit的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2e5ee97a44cfd4c953fd0f1aff0a1bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*J3cnQliIxFVoD-ZvQf5qqg.png"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">这是一个发射器</p></figure><ol class=""><li id="74ed" class="np nq iq kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated">向发出它的可观察物体发射色点</li><li id="aec6" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">价值</li><li id="6af9" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">颜色指向当前线程</li><li id="a67e" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">正在使用的线程索引</li></ol><p id="f000" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当小圆圈的颜色(3号)是:</p><ul class=""><li id="05a5" class="np nq iq kt b ku kv kx ky la nr le ns li nt lm od nv nw nx bi translated">红色:主线程</li><li id="8508" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm od nv nw nx bi translated">青色:计算线程</li><li id="4047" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm od nv nw nx bi translated">黄色:IO线程</li><li id="eaa1" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm od nv nw nx bi translated">绿色:单线程</li></ul><p id="e96a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从一个简单的操作开始:</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="c8d5" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">就()</h1><p id="12b1" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">这段代码将打印日志中从A到D的字母，但是我想让您看一下交互图:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="17b9" class="oj lw iq of b gy ok ol l om on">Observable.just('A', 'B', 'C', 'D')<br/>     <!-- -->.subscribe <strong class="of ir">{<br/>           </strong>Log.i(TAG, "$<strong class="of ir">it</strong>")<br/>     <strong class="of ir">}</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a491ed6d231bca0c1d75b1516e2fbb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*1KQdJECFpnw83pOwIaGK9g.gif"/></div></figure><p id="ecf7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe op oq or of b">Observable.just</code>是<code class="fe op oq or of b">observable</code>对象，在<code class="fe op oq or of b">subscribe</code>方法中我们放入了<code class="fe op oq or of b">observer</code>。</p><p id="7286" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的图中，<code class="fe op oq or of b">just()</code>是<code class="fe op oq or of b">observable</code>，箭头是<code class="fe op oq or of b">observer</code>。正如你所注意到的，(A，B，C，D)是发射的。</p><p id="f6e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe op oq or of b">just()</code>操作将获取许多项，然后以相同的顺序和相同的线程(在我们的例子中是主线程)将它们传递给<code class="fe op oq or of b">observer</code>。当<code class="fe op oq or of b">observable</code>完成发送它的发射时，它将调用我们的<code class="fe op oq or of b">observer</code>中的<code class="fe op oq or of b">onComplete</code>(通过在我们的图中画一条小竖线)，这意味着<code class="fe op oq or of b">observable</code>已经发送了它所有的发射，<code class="fe op oq or of b">observer</code>在那之后将不会接收任何发射。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="0d73" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">地图()</h1><p id="65b8" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">假设我们有<code class="fe op oq or of b">strings</code>的发射，我们需要将它们映射到这些字符串的长度列表。</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="5f3c" class="oj lw iq of b gy ok ol l om on"><em class="os">Observable</em>.just("Dr.", "Anas", "Altair")<br/>    .map <strong class="of ir">{ it</strong>.length <strong class="of ir">}<br/>    </strong>.subscribe(...)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2c49750ea825aa3c49224ac8a698673c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*AzZ9kfyC41usaJoWoeWdlQ.gif"/></div></figure><p id="28c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">发射将从<code class="fe op oq or of b">observable</code>一个接一个地发送到<code class="fe op oq or of b">map</code>操作，后者将字符串转换成整数(字符串的长度)，然后将它们发送到<code class="fe op oq or of b">observer</code>。</p><p id="0a90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，发出将在相同的顺序和相同的线程中进行。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="31db" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">间隔()</h1><p id="12fb" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">如果我们想要每两秒发送一次信号，RxJava很容易做到:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="28cc" class="oj lw iq of b gy ok ol l om on">Observable.interval(2000, TimeUnit.MILLISECONDS)<br/><strong class="of ir">    </strong>.subscribe(...)</span></pre><p id="204c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们的观察者将会收到的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f4b191efd4cee9d7992ada270268f06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8F26H46ukMf0ALsc9LjbTg.gif"/></div></figure><p id="f160" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">带条纹的黄色方块是时间。<code class="fe op oq or of b">observable</code>会每两秒钟自动发送一次信号。第一次发射将是0，然后是1，2，3…它会一直发出信号。</p><p id="f658" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你注意到了吗？默认情况下，<code class="fe op oq or of b">interval</code>操作将在计算线程上工作，并将向同一计算线程上的<code class="fe op oq or of b">observer</code>发送一个发射，因此您需要小心处理<code class="fe op oq or of b">observer</code>内部的发射。或者可以使用<code class="fe op oq or of b">observeOn()</code>操作来改变螺纹。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="9319" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">flatMap()和concatMap()</h1><p id="1759" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">看到这两个<code class="fe op oq or of b">observable</code>了吗:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="9731" class="oj lw iq of b gy ok ol l om on"><em class="os">Observable</em>.just("A,B,C", "D,E,F")<br/>    .flatMap <strong class="of ir">{ </strong>stringEmit <strong class="of ir">-&gt;<br/>        </strong><em class="os">Observable</em>.fromIterable(stringEmit.<em class="os">split</em>(','))<br/>            .subscribeOn(Schedulers.computation())<br/>            .doOnNext <strong class="of ir">{ </strong><em class="os">longProcess</em>(..) <strong class="of ir">}<br/>    }<br/></strong>    .subscribe(...)</span><span id="afe0" class="oj lw iq of b gy ot ol l om on"><em class="os">Observable</em>.just("A,B,C", "D,E,F")<br/>    .concatMap <strong class="of ir">{ </strong>stringEmit <strong class="of ir">-&gt;<br/>        </strong><em class="os">Observable</em>.fromIterable(stringEmit.<em class="os">split</em>(','))<br/>            .subscribeOn(Schedulers.computation())<br/>            .doOnNext <strong class="of ir">{ </strong><em class="os">longProcess</em>(..) <strong class="of ir">}<br/>    }<br/></strong>    .subscribe(...)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/9d69e3bf2dc9ba096ee59cb261c8044d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*5Qdw9IGT1e_sCr5B_gHp-w.gif"/></div></figure><p id="5b77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，我们有两个<code class="fe op oq or of b">observable</code>和两个<code class="fe op oq or of b">observer</code>，它们互不影响。</p><h2 id="04ac" class="oj lw iq bd lx ou ov dn mb ow ox dp mf la oy oz mh le pa pb mj li pc pd ml pe bi translated">平面地图()</h2><p id="1ce1" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">第一个只是有两个字符串发出(“A，B，C”和“D，E，F”)。<code class="fe op oq or of b">flatMap</code>操作将把每个发射转换成一个<code class="fe op oq or of b">observable</code>。在我们的例子中，它将把“A，B，C”转换成一个<code class="fe op oq or of b">observable</code>，这个<code class="fe op oq or of b">observable</code>将发送三个emit(“A”、“B”和“C”)，我们调用<code class="fe op oq or of b">subscribeOn</code>来改变新的<code class="fe op oq or of b">observable</code>将要处理的线程，然后对每个字母emit进行长时间的处理。</p><p id="6e75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到我们的图表，仔细观察<code class="fe op oq or of b">flatMap</code>操作。它将从上游获取所有发射，并在不同的计算线程上一起处理它们。然后，信件会以随机顺序发送到最后的<code class="fe op oq or of b">observer</code>(第一个完成长流程的)<em class="os">。</em></p><h2 id="a793" class="oj lw iq bd lx ou ov dn mb ow ox dp mf la oy oz mh le pa pb mj li pc pd ml pe bi translated">concatMap()</h2><p id="3ff0" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">它将做与<code class="fe op oq or of b">flatMap</code>相同的工作，但是它将从上游获取第一个字符串发射，转换它，并将所有新的<code class="fe op oq or of b">observable</code>发射发送到<code class="fe op oq or of b">observer</code>。只有到那时，它才会处理从上游发出的下一个字符串。</p><p id="c5d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe op oq or of b">flatMap</code>和<code class="fe op oq or of b">concatMap</code>会做同样的工作，但是<code class="fe op oq or of b">concatMap</code>尊重顺序。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="0ec1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">RxLab <strong class="kt ir"> </strong>中有很多操作我会让你自己去发现(<code class="fe op oq or of b">filter</code>、<code class="fe op oq or of b">reduce</code>、<code class="fe op oq or of b">scan</code>、<code class="fe op oq or of b">zip</code>、<code class="fe op oq or of b">combineLatest</code>、<code class="fe op oq or of b">distinct</code>、<code class="fe op oq or of b">throttle</code>等等)。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="6146" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="839f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">RxLab是一个非常好的应用程序，当你想要一个操作，但忘记了它是如何工作的，或者想看看线程、时间或结果时，可以打开它。</p><p id="ff15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个项目最终不会帮助你从零开始学习RxJava，但是会帮助你理解它，记忆它的操作。</p></div></div>    
</body>
</html>