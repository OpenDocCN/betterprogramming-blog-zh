<html>
<head>
<title>3 Chaotic Python Features To Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要避免的3个混乱的Python特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-chaotic-python-features-to-avoid-9c609908bc13?source=collection_archive---------0-----------------------#2021-07-19">https://betterprogramming.pub/3-chaotic-python-features-to-avoid-9c609908bc13?source=collection_archive---------0-----------------------#2021-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b0c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避开这些令人困惑的片段</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4d139d12a7ca5de0578aa2832a1b8af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sToUxIvBGUXWZfQ9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@imranbangash?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Imran Bangash </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="01fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几十年里，Python已经成为最流行的通用编程语言之一。因此，它已经被不同领域的人所采用，例如金融、科学和工程。Python受欢迎的原因之一是它的多功能性——通常有不同的方法来实现相同的功能。然而，有些方法可能会让其他人感到困惑。在这种情况下，您应该考虑替代方案。</p><p id="55b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论几个可能令人困惑的Python特性——尤其是对初学者而言。作为比较，我将提供实现相同功能的替代方案。正如您将看到的，替代方案可能需要更多的代码，但是由于它们的清晰性，它们应该是首选的。毕竟，可读性是您应该为您的编码项目努力实现的最大目标。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0cb0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">for/while循环中的else子句</h1><p id="6cd8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">大多数编程语言在<code class="fe mz na nb nc b">for</code>和<code class="fe mz na nb nc b">while</code>循环方面都有相似的特性。它们具有以下一般形式:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="61cf" class="nh md it nc b gy ni nj l nk nl">for item in list_or_array:<br/>    do something with the item</span><span id="d502" class="nh md it nc b gy nm nj l nk nl">while some_condition_evaluated:<br/>    do something</span></pre><p id="0caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管我们的编程水平如何，它们对我们所有人来说都是直观的。然而，Python允许将<code class="fe mz na nb nc b">else</code>子句用于<code class="fe mz na nb nc b">for</code>和<code class="fe mz na nb nc b">while</code>循环。观察以下这些特征:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">for和while循环中的else子句</p></figure><p id="8197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe mz na nb nc b">if…else…</code>语句中最常看到<code class="fe mz na nb nc b">else</code>子句，其中<code class="fe mz na nb nc b">else</code>子句仅在前一个<code class="fe mz na nb nc b">if</code>子句不运行时运行。这种行为可能会让一些人认为同样的事情也会发生在<code class="fe mz na nb nc b">for</code>和<code class="fe mz na nb nc b">while</code>循环中的<code class="fe mz na nb nc b">else</code>子句上。然而，如果您运行上面的代码，您会发现两个<code class="fe mz na nb nc b">else</code>子句在每种情况下都运行。</p><p id="7e76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这些情况下，<code class="fe mz na nb nc b">else</code>子句的规则是，只有在<code class="fe mz na nb nc b">for</code>或<code class="fe mz na nb nc b">while</code>子句中执行了<code class="fe mz na nb nc b">break</code>语句时，才会跳过该子句。观察下面的对比:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用break跳过else子句</p></figure><p id="9a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，除非在<code class="fe mz na nb nc b">for</code>或<code class="fe mz na nb nc b">while</code>循环中有一个<code class="fe mz na nb nc b">break</code>语句，否则对<code class="fe mz na nb nc b">else</code>子句没有任何影响，该子句在完成前一个子句后仍然会运行。换句话说，这是大多数情况下的建议:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b886" class="nh md it nc b gy ni nj l nk nl"># Instead of this<br/>for item in iterable:<br/>    do_a<br/>else:<br/>    do_b</span><span id="4b4a" class="nh md it nc b gy nm nj l nk nl"># Do this<br/>for item in iterable:<br/>    do_a</span><span id="50ae" class="nh md it nc b gy nm nj l nk nl">do_b</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6214" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对setdefault使用默认值</h1><p id="fd68" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们从字典中检索一个值时，如果字典中不存在一个键，Python会抛出一个<code class="fe mz na nb nc b">KeyError</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8488" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; grades = {"John": 90, "Jennifer": 95}<br/>&gt;&gt;&gt; grades["Josh"]<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/><strong class="nc iu">KeyError</strong>: 'Josh'</span></pre><p id="87b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，有些人可能会使用<code class="fe mz na nb nc b">setdefault</code>来检索键值。当在字典中找不到关键字时，它将使用指定的默认值。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0044" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; grades.setdefault("Josh", "N/A")<br/>'N/A'</span></pre><p id="33f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这个方法的名字可能是违反直觉的——特别是如果您有任何其他编程背景，您可能永远不会想到“setter”方法可以返回值。</p><p id="760b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您真的想在检索字典值时有一个回退，更好的替代方法是使用<code class="fe mz na nb nc b">get</code>方法:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9e34" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; grades.get("Jack", "N/A")<br/>'N/A'</span></pre><p id="a5be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想知道为什么Python有两个似乎做同样事情的方法。因为他们不完全一样。<code class="fe mz na nb nc b">setdefault</code>方法将返回回退值，同时，它将通过设置缺少的键和默认值来更新字典。<code class="fe mz na nb nc b">get</code>方法将简单地返回回退值，而不改变字典。如下所示，字典有<code class="fe mz na nb nc b">Josh</code>键，但没有<code class="fe mz na nb nc b">Jack</code>键:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="473c" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; grades<br/>{'John': 90, 'Jennifer': 95, 'Josh': 'N/A'}</span></pre><p id="72a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望设置与使用<code class="fe mz na nb nc b">setdefault</code>方法相关的行为，您可以考虑<code class="fe mz na nb nc b">defaultdict</code>数据类型，它是<code class="fe mz na nb nc b">dict</code>的子类，具有在缺少键时生成默认值的特性。以下代码向您展示了返回<code class="fe mz na nb nc b">‘N/A’</code>并为丢失的键设置值的实现:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b752" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; from collections import defaultdict<br/>&gt;&gt;&gt; grades = defaultdict(lambda: "N/A", {"John": 90, "Jennifer": 95})<br/>&gt;&gt;&gt; grades["Jack"]<br/>'N/A'<br/>&gt;&gt;&gt; grades<br/>defaultdict(&lt;function &lt;lambda&gt; at 0x1058071f0&gt;, {'John': 90, 'Jennifer': 95, 'Jack': 'N/A'})</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa9c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">切片中的负步骤</h1><p id="6c80" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">切片是从序列数据类型(如列表或字符串)中检索多项的强大方法。当我们对序列进行切片时，我们通常指定起始和结束索引。此外，我们可以在切片中指定一个步骤，在指定的步骤之后获取项目。下面是一个简单的例子:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6f65" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; integers = [0, 1, 2, 3, 4, 5, 6]<br/>&gt;&gt;&gt; integers[0:7:2]<br/>[0, 2, 4, 6]<br/>&gt;&gt;&gt; integers[::3]<br/>[0, 3, 6]</span></pre><p id="3e79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">切片有几个显著的特征:</p><ol class=""><li id="074b" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">可以省略开始和结束索引。Python将为您应用正确的索引。</li><li id="c3f0" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果您使用看似索引外的索引，Python将为您使用适用的绑定索引。</li></ol><p id="4ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个额外的特性是你可以在切片中应用一个负的步骤。该功能的一个广为人知的应用是反转序列，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9860" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; integers[::-1]<br/>[6, 5, 4, 3, 2, 1, 0]</span></pre><p id="05fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是猜猜下面的操作会发生什么？</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ea8b" class="nh md it nc b gy ni nj l nk nl">integers[0:6:-1]</span><span id="95c9" class="nh md it nc b gy nm nj l nk nl">integers[-1:-7:-1]</span></pre><p id="25e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行这两行代码，您将得到下面的结果:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="98bc" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; integers[0:6:-1]<br/>[]<br/>&gt;&gt;&gt; integers[-1:-7:-1]<br/>[6, 5, 4, 3, 2, 1]</span></pre><p id="c665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道发生了什么。当你有一个消极的步骤，切片将从右向左计数。本质上，开始索引指的是右边的项，结束索引指的是左边的项。从右边移到左边，切片将采取指定的步骤来检索相应的项目。</p><p id="df65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，切片<code class="fe mz na nb nc b">[0:6:-1]</code>意味着从索引<code class="fe mz na nb nc b">0</code>处的项目开始，向左移动直到索引<code class="fe mz na nb nc b">6</code>处的项目，并向前左移一步。因为起始索引在结束索引的左侧，所以会产生一个空列表。同样的操作发生在<code class="fe mz na nb nc b">[-1:-7:-1]</code>上，由于起始索引在结束索引的右侧，所以从右向左移动时可以产生一个项目列表。</p><p id="d274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解释可能会让你感到困惑。因此，通常不建议使用这个特性。当您需要反转一个序列时，您可以简单地使用Python中可用于排序数据类型的<code class="fe mz na nb nc b">reverse</code>方法。颠倒顺序后，你可以应用积极的一步，产生更直观的结果，而不会混淆他人。下面是一个简单的例子:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="66ed" class="nh md it nc b gy ni nj l nk nl"># instead of<br/>integers[-1:-7:-1]</span><span id="2722" class="nh md it nc b gy nm nj l nk nl"># do this (or something similar)<br/>integers.reverse()<br/>integers[0:6:1]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5d15" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="dba7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了三个可能会让其他Python开发人员感到困惑的特性——尤其是那些不熟悉这种语言的人。如前所述，代码最重要的目标是尽可能获得最好的可读性。因此，建议不要使用这些功能。</p><p id="dcd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您仍然想知道它们是什么，因为您可能会在其他人的代码中遇到它们。</p></div></div>    
</body>
</html>