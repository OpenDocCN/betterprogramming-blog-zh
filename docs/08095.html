<html>
<head>
<title>Create a Custom Alert Object in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中创建自定义警报对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-custom-alert-object-in-swiftui-bddf98923a1?source=collection_archive---------5-----------------------#2021-03-24">https://betterprogramming.pub/create-a-custom-alert-object-in-swiftui-bddf98923a1?source=collection_archive---------5-----------------------#2021-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="555a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在iOS应用程序中开发您自己定制的提醒</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e2b11f28296fa1e4724a07ba9070d3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7sJGpzbwVhhSUETjT98fQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="65ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SwiftUI还不支持定制的<code class="fe lu lv lw lx b">Alert</code>对象，但是多亏了<code class="fe lu lv lw lx b">UIViewControllerRepresentable</code>，我们可以开发自己的<code class="fe lu lv lw lx b">Alert</code>对象，它支持我们想要的特性。在本文中，我们将创建一个能够适应多种情况的<code class="fe lu lv lw lx b">Alert</code>对象。</p><p id="2b0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:您可以<a class="ae ly" href="https://github.com/SwiftDeeply/Crate-Custom-Alert-Object-in-SwiftUI" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上下载本文的示例项目和源代码。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6317" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">项目概述</h1><p id="975d" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在解释一个主题时，你能做的确保主题被理解的最好的事情之一就是用真实的例子来解释这个主题。这就是为什么我还将创建一个自定义的<code class="fe lu lv lw lx b">Alert</code>对象，用于待办事项应用程序。(当然，我将用来创建<code class="fe lu lv lw lx b">Alert</code>对象的几乎所有特性都可以在不同的场景中使用。)</p><p id="f926" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在待办事项应用中，我们将使用上下文菜单来删除和编辑待办事项列表项，并使用导航项来创建新的待办事项。事实上，这些UI元素不会直接删除、编辑或创建我们的待办事项列表项。它们只会作为一个<code class="fe lu lv lw lx b">Alert</code>对象出现，允许我们进行这些操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/32f8e82309b26582d0a0ea6b15ea4024.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hZcjGAcuC8BINF8NPQnshw.png"/></div></figure><p id="ef7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不同属性的内容删除、编辑和创建操作所调用的<code class="fe lu lv lw lx b">Alert</code>对象中的元素也需要不同。当然，为了做到这一点，我们首先需要创建一个项目并概述实现。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5dbe" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建新项目</h1><p id="4d08" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">首先，创建一个新的SwiftUI项目，然后为我们将要创建的文件创建新文件夹。我通常在基本项目中使用这种团队方法。当然，你可以使用不同的分组方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/f0f8ba63ce885d14d93fd4c64468f745.png" data-original-src="https://miro.medium.com/v2/format:webp/1*OYeyxbMy4mx_rItHAXwH3w.png"/></div></figure><p id="1761" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您将<code class="fe lu lv lw lx b">Info.plist</code>文件移动到一个文件夹中时，您会遇到一个错误。您可以使用下面文章中的信息来解决这个问题。</p><div class="ne nf gp gr ng nh"><a href="https://canbalkaya.medium.com/how-to-set-info-plist-path-62cce55059b" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">如何设置Info.plist路径？</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">了解如何解决Info.plist路径错误问题</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">canbalkaya.medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ks nh"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2f60" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">构建数据模型</h1><p id="a8ed" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在这个项目中，我们将需要两个数据模型。第一个用于待办事项，第二个用于提醒操作。让我们建造第一个。</p><p id="736c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选择<code class="fe lu lv lw lx b">Models</code>文件夹，按CMD+N创建新的Swift文件。创建Swift文件后，创建一个名为<code class="fe lu lv lw lx b">TodoItem</code>的新结构。(在这个Swift文件中，我们将使用UIKit属性。这就是为什么你不应该忘记导入UIKit框架。)</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="61b5" class="oa mh it lx b gy ob oc l od oe"><strong class="lx iu">import</strong> UIKit<br/><br/><strong class="lx iu">struct</strong> TodoItem: Identifiable {<br/><br/>}</span></pre><p id="85f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注:</strong>当我们要使用<code class="fe lu lv lw lx b">ForEach</code>中的<code class="fe lu lv lw lx b">TodoItem</code>对象时，我们会需要<code class="fe lu lv lw lx b">Identifiable</code>协议，所以我们已经在<code class="fe lu lv lw lx b">TodoItem</code>中写好了<code class="fe lu lv lw lx b">Identifiable</code>协议。</p><p id="2214" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">TodoItem</code>对象将有五个属性:标题、描述、优先级、日期、完成。<code class="fe lu lv lw lx b">Priority</code>是一个自定义枚举对象，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3f23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:我们使用<code class="fe lu lv lw lx b">CaseIterable</code>协议在一个属性中定义所有情况。</p><p id="4061" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以定义所有的属性。(我们为下面的<code class="fe lu lv lw lx b">Identifiable</code>协议定义了一个额外的属性<code class="fe lu lv lw lx b">id</code>。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2f93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义一个静态的<code class="fe lu lv lw lx b">TodoItem</code>数组，当应用程序第一次启动时，在应用程序界面中有样本数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0c87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您键入这些代码时，会遇到一些错误。这些错误的原因是我使用了一个扩展来更改<code class="fe lu lv lw lx b">Date</code>对象的值。我们将在这个项目中使用的<code class="fe lu lv lw lx b">Date</code>扩展如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c474" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将来，我们将根据“优先级”值来更改我们将在界面元素中使用的颜色和文本。要做到这一点，我们需要创建一个如下所示的扩展。多亏了这个扩展，我们可以创建自定义的<code class="fe lu lv lw lx b">RawValue</code>。(如你所见，我们的<code class="fe lu lv lw lx b">RawValue</code>的数据类型是<code class="fe lu lv lw lx b">(name: String, color: UIColor)</code>。这是一个元组。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9f93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">TodoItem</code>型号完成！让我们开始创建和<code class="fe lu lv lw lx b">Action</code>模型。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="6d87" class="oa mh it lx b gy ob oc l od oe"><strong class="lx iu">struct</strong> Action: Identifiable {<br/><br/>}</span></pre><p id="092d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个模型中我们还需要一个enum，因为我们将在项目中使用的<code class="fe lu lv lw lx b">Alert</code>对象将有多种类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9411" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，我们不需要定义自定义的<code class="fe lu lv lw lx b">RawValue</code>，因为enum的输出只是<code class="fe lu lv lw lx b">String</code>。</p><p id="647b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是<code class="fe lu lv lw lx b">Action</code>模型的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="89f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们不会用<code class="fe lu lv lw lx b">Action</code>模型创建动态对象。它只是用于创建静态对象。因此，让我们在<code class="fe lu lv lw lx b">Action</code>模型内部创建一个元组。这个元组拥有我们将在项目中使用的所有<code class="fe lu lv lw lx b">Action</code>对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c967" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据模型完成了！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f01d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">准备数据存储类</h1><p id="38fc" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">现在我们需要一个数据管理器类。当然，我们需要在一个单独的Swift文件中定义这个类。如果你和我使用相同的组方法，这个Swift文件也应该在<code class="fe lu lv lw lx b">Helpers</code>类中。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="e156" class="oa mh it lx b gy ob oc l od oe"><strong class="lx iu">import</strong> SwiftUI<br/><br/><strong class="lx iu">class</strong> DataStore: ObservableObject {<br/><br/>}</span></pre><p id="450d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>我们使用<code class="fe lu lv lw lx b">ObservableObject</code>协议通过<code class="fe lu lv lw lx b">@Published</code>属性包装器来定义属性。</p><p id="da20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了在项目的不同部分将<code class="fe lu lv lw lx b">DataStore</code>类作为单例使用，我们定义了一个名为<code class="fe lu lv lw lx b">shared</code>的属性。这样，通过键入<code class="fe lu lv lw lx b">DataStore.shared</code>，就可以直接访问<code class="fe lu lv lw lx b">DataStore</code>类。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="94d0" class="oa mh it lx b gy ob oc l od oe">// MARK: - Properties<br/><strong class="lx iu">static</strong> <strong class="lx iu">let</strong> shared = DataStore()</span></pre><p id="6b3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们将所有的<code class="fe lu lv lw lx b">TodoItem</code>对象放在一个名为<code class="fe lu lv lw lx b">allTodoItems</code>的数组中。用<code class="fe lu lv lw lx b">@Published</code>定义这个属性的原因是为了让它在<code class="fe lu lv lw lx b">DataStore</code>类之外发生变化时立即改变。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="90fd" class="oa mh it lx b gy ob oc l od oe">@Published <strong class="lx iu">var</strong> allTodoItems = TodoItem.example</span></pre><p id="8c3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建两个单独的数组来对接受<code class="fe lu lv lw lx b">true</code>和<code class="fe lu lv lw lx b">false</code>对象的<code class="fe lu lv lw lx b">TodoItem</code>值进行分组，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b70f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义以下属性，以定义将立即采取的动作、相应的菜单动作以及是否出现<code class="fe lu lv lw lx b">Alert</code>对象。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="679d" class="oa mh it lx b gy ob oc l od oe">@Published <strong class="lx iu">var</strong> currentAction: Action? = <strong class="lx iu">nil</strong><br/>@State <strong class="lx iu">var</strong> menuActions: [Action] = []<br/>@Published <strong class="lx iu">var</strong> alertShowing = <strong class="lx iu">false</strong></span></pre><p id="b319" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在<code class="fe lu lv lw lx b">DataStore</code>类之外使用的大多数函数中编写一个<code class="fe lu lv lw lx b">TodoItem</code>参数。我们需要一个方法来找出所选的<code class="fe lu lv lw lx b">TodoItem</code>对象在<code class="fe lu lv lw lx b">allTodoItems</code>数组中的索引。下面的函数就是为了这个。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="8d79" class="oa mh it lx b gy ob oc l od oe">// MARK: - Methods<br/><strong class="lx iu">private</strong> <strong class="lx iu">func</strong> getSelectedTodoItemIndex(selected todoItem: TodoItem) -&gt; Int {<br/>    allTodoItems.firstIndex(where: { $0.id == todoItem.id })!<br/>}</span></pre><p id="1c5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在项目中使用<code class="fe lu lv lw lx b">contextMenu</code>修改器。我们将给出下面的函数作为这个修改器的输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b2a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，将我们对<code class="fe lu lv lw lx b">TodoItem</code>对象的所有更改定义为函数，如下所示。正如你所看到的，所有的函数都改变了<code class="fe lu lv lw lx b">allTodoItems</code>数组。所以一切都根据<code class="fe lu lv lw lx b">allTodoItems</code>变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="95e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">DataStore</code>下课了！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d9f4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建自定义警报对象</h1><p id="8f5a" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">是时候创建我们的自定义<code class="fe lu lv lw lx b">Alert</code>对象了，然后我们将创建应用程序的主UI。这样我们的申请就完成了。</p><p id="64ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，在名为<code class="fe lu lv lw lx b">TextFieldWrapper</code>的<code class="fe lu lv lw lx b">Views</code>文件夹中创建一个新的Swift文件。然后编写如下代码。(该元件调整<code class="fe lu lv lw lx b">Alert</code>对象是否出现在屏幕上。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b1b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你写这段代码时，你会得到一个错误，因为<code class="fe lu lv lw lx b">TextFieldAlert</code>对象丢失了。让我们创建这个对象。</p><p id="726b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以把<code class="fe lu lv lw lx b">TextFieldAlert</code>想象成一个定制的<code class="fe lu lv lw lx b">Alert</code>对象，因为在这个对象中，我们将把一个<code class="fe lu lv lw lx b">UIAlertViewController</code>对象转换成一个带有<code class="fe lu lv lw lx b">UIViewControllerRepresentable</code>协议的SwiftUI元素。</p><p id="53f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们将从我们定义的<code class="fe lu lv lw lx b">Action</code>对象接收与<code class="fe lu lv lw lx b">Alert</code>相关的所有信息，所以我们在里面定义了一个<code class="fe lu lv lw lx b">Action</code>属性。</p><p id="9799" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们定义了一个<code class="fe lu lv lw lx b">UIViewControllerRepresentable</code>扩展来将<code class="fe lu lv lw lx b">UIAlertViewController</code>对象转换成SwiftUI元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="db5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，这次我们得到一个错误，因为我们没有一个<code class="fe lu lv lw lx b">TextFieldAlertViewController</code>。</p><p id="fa35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建<code class="fe lu lv lw lx b">TextFieldAlertViewController</code>对象，创建一个新的Swift文件并编写以下代码。(我们导入Combine框架的原因是为了使用<code class="fe lu lv lw lx b">AnyCancellable</code>对象。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7229" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们的<code class="fe lu lv lw lx b">Action</code>类型是“创建”或“编辑”时，我们将在我们的<code class="fe lu lv lw lx b">Alert</code>对象中使用两个<code class="fe lu lv lw lx b">UIPickerView</code>对象。我们将把<code class="fe lu lv lw lx b">UIToolbar</code>添加到这些<code class="fe lu lv lw lx b">UIPickerView</code>对象中的一个。让我们用以下方法定义这个<code class="fe lu lv lw lx b">UIToolbar</code>中要使用的按钮的动作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6e30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们将为我们的<code class="fe lu lv lw lx b">UIAlertViewController</code>对象定义主方法。</p><p id="b3b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们根据当前<code class="fe lu lv lw lx b">Action</code>对象的类型来确定将出现在<code class="fe lu lv lw lx b">UIAlertController</code>中的UI元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7bed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在第三个<code class="fe lu lv lw lx b">UITextField</code>中遇到了一个错误，因为我们还没有定义<code class="fe lu lv lw lx b">datePicker</code>方法。让我们将下面的内容写入<code class="fe lu lv lw lx b">UITextField</code>扩展来定义方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9762" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让<code class="fe lu lv lw lx b">TextFieldAlert</code>对象像<code class="fe lu lv lw lx b">alert</code>修改器一样工作，我们需要创建自己的修改器。我们可以在一个<code class="fe lu lv lw lx b">View</code>扩展中做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e64d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自定义<code class="fe lu lv lw lx b">Alert</code>对象完成！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="708b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">准备用户界面</h1><p id="56b5" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">我们将创建两个屏幕。第一个是针对未完成的任务，另一个是针对已完成的任务。</p><h2 id="dc95" class="oa mh it bd mi oh oi dn mm oj ok dp mq lh ol om ms ll on oo mu lp op oq mw or bi translated">第一屏</h2><p id="008e" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">实际上，第一个屏幕的Swift文件现在在我们的Xcode项目上:<code class="fe lu lv lw lx b">ContentView.swift</code>。让我们把名字从<code class="fe lu lv lw lx b">ContentView</code>改成<code class="fe lu lv lw lx b">UncompletedTasksView</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a849" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在这个页面上使用<code class="fe lu lv lw lx b">DataController</code>类，定义一个名为<code class="fe lu lv lw lx b">dataController</code>的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b0f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你在文章的开头所看到的，在这一页的顶部有一个部分显示了已经完成的任务的数量。让我们编写下面的代码来创建这个部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7fcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们把这个部分改成UI组件会更好。为此，创建一个名为<code class="fe lu lv lw lx b">CompletedTasksSectionView</code>的新SwiftUI文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3f4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义一个名为<code class="fe lu lv lw lx b">count</code>的<code class="fe lu lv lw lx b">Int</code>属性来显示有多少任务。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="5e85" class="oa mh it lx b gy ob oc l od oe">// MARK: - Properties<br/><strong class="lx iu">let</strong> count: Int</span></pre><p id="84eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后在这里写我们几行前写的<code class="fe lu lv lw lx b">Section</code>元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2623" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在页面内部使用<code class="fe lu lv lw lx b">CompletedTasksSectionView</code>组件来代替旧的组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="820e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编写以下修饰符对<code class="fe lu lv lw lx b">NavigationView</code>和<code class="fe lu lv lw lx b">List</code>元素进行修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d1b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是时候使用我们的<code class="fe lu lv lw lx b">textAlert</code>修改器了。就像写<code class="fe lu lv lw lx b">alert</code>修饰符一样，我们在<code class="fe lu lv lw lx b">NavigationView</code>之外写<code class="fe lu lv lw lx b">textAlert</code>修饰符。我们用于<code class="fe lu lv lw lx b">isPresented</code>和<code class="fe lu lv lw lx b">action</code>参数的属性来自<code class="fe lu lv lw lx b">dataController</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c842" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们创建<code class="fe lu lv lw lx b">List</code>元素的第二个<code class="fe lu lv lw lx b">Section</code>。(这个元素将是我们列表的动态部分。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d2eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先如下定义我们需要的属性。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="7474" class="oa mh it lx b gy ob oc l od oe">// MARK: - Properties<br/><strong class="lx iu">let</strong> dataStore = DataStore.shared<br/><strong class="lx iu">let</strong> todoItem: TodoItem</span></pre><p id="a76f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后通过编写以下代码创建接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0181" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的<code class="fe lu lv lw lx b">ListCellView</code>元素如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/448ceb5de808ca67acf1f51fb21a8154.png" data-original-src="https://miro.medium.com/v2/format:webp/1*AAc5F9-CkjLgsJpEw-jNdQ.png"/></div></figure><p id="e2be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">ListCellView</code>元素已准备就绪。返回<code class="fe lu lv lw lx b">UncompletedTasksView</code>结构。如果我们将它与<code class="fe lu lv lw lx b">ForEach</code>元素一起使用，我们可以在界面中即时动态显示<code class="fe lu lv lw lx b">incompleteTodoItems</code>数组中的所有对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e3b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在第一个屏幕中使用<code class="fe lu lv lw lx b">sheet</code>修改器，因为我们的第二个屏幕将是一个工作表屏幕。因此，我们现在需要创建第二个屏幕。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="f8e8" class="oa mh it lx b gy ob oc l od oe"><strong class="lx iu">struct</strong> CompletedTasksView: View {<br/>    <br/>    // MARK: - View<br/>    <strong class="lx iu">var</strong> body: <strong class="lx iu">some</strong> View {<br/>        Text("Hello, World!")<br/>    }<br/>}</span></pre><p id="95f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">@State</code>属性包装器为<code class="fe lu lv lw lx b">sheet</code>修改器的<code class="fe lu lv lw lx b">isPresented</code>参数创建一个<code class="fe lu lv lw lx b">Bool</code>属性。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="bc24" class="oa mh it lx b gy ob oc l od oe">@State <strong class="lx iu">private</strong> <strong class="lx iu">var</strong> completedTasksViewIsAppear = <strong class="lx iu">false</strong></span></pre><p id="35ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，在<code class="fe lu lv lw lx b">NavigationView</code>外面写<code class="fe lu lv lw lx b">sheet</code>修饰符。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="866b" class="oa mh it lx b gy ob oc l od oe">NavigationView {<br/>    // ...<br/>}<br/>.sheet(isPresented: $completedTasksViewIsAppear, content: {<br/>    CompletedTasksView()<br/>})</span></pre><p id="4ab1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一屏完成了！来体验一下吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/3a1273ca60054e96f0f3101a390d744a.png" data-original-src="https://miro.medium.com/v2/1*Xnx342HNsjF355z4owa9bA.gif"/></div></figure><h2 id="8bcc" class="oa mh it bd mi oh oi dn mm oj ok dp mq lh ol om ms ll on oo mu lp op oq mw or bi translated">第二屏</h2><p id="a2ef" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">现在我们要做的就是创建<code class="fe lu lv lw lx b">CompletedTasksView</code>元素。为了实现这一点，让我们在<code class="fe lu lv lw lx b">CompletedTasksView</code>结构中定义以下两个属性。</p><pre class="kj kk kl km gt nw lx nx ny aw nz bi"><span id="5e54" class="oa mh it lx b gy ob oc l od oe">// MARK: - Properties<br/>@ObservedObject <strong class="lx iu">var</strong> dataStore = DataStore.shared<br/>@Environment(\.presentationMode) <strong class="lx iu">var</strong> presentationMode</span></pre><p id="1da7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后创建接口。(如您所见，下面的代码与第一个屏幕的代码非常相似。)</p><p id="bc31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们运行<code class="fe lu lv lw lx b">presentationMode</code>属性中的<code class="fe lu lv lw lx b">dismiss()</code>方法时，我们将返回到第一个屏幕。所以当这个人按下完成按钮时，它将返回到第一个屏幕。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f03e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对，app做好了！让我们一起来看看它是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/e141e5970b93e094ded77daf67ca80c0.png" data-original-src="https://miro.medium.com/v2/1*COL7bp1HcF1_ENx3_Vedkw.gif"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="94d1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="5ac4" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">我们现在创建的<code class="fe lu lv lw lx b">Alert</code>对象拥有尽可能多的我们可以在UIKit中添加的特性。所以现在您有了一个可以在SwiftUI项目中实际使用的<code class="fe lu lv lw lx b">Alert</code>对象。</p><p id="92a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢阅读这篇文章。如果你有任何问题，请在评论区留言。</p><p id="a316" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">我的其他文章:</strong></p><ul class=""><li id="6652" class="os ot it la b lb lc le lf lh ou ll ov lp ow lt ox oy oz pa bi translated"><a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/using-filemanager-in-swiftui-44bc0f33995e">在SwiftUI中使用文件管理器</a></li><li id="7168" class="os ot it la b lb pb le pc lh pd ll pe lp pf lt ox oy oz pa bi translated"><a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/building-cross-platform-apps-with-swiftui-3fea88cdb0ae">使用SwiftUI构建跨平台应用</a></li><li id="684a" class="os ot it la b lb pb le pc lh pd ll pe lp pf lt ox oy oz pa bi translated"><a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-firebase-in-swiftuis-new-application-lifecycle-c77a8a306d63">如何在SwiftUI的新应用生命周期中使用Firebase</a></li></ul></div></div>    
</body>
</html>