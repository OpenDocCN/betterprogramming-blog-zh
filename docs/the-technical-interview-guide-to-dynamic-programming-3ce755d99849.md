# 动态编程技术面试指南

> 原文：<https://betterprogramming.pub/the-technical-interview-guide-to-dynamic-programming-3ce755d99849>

## 面试准备和日常编码的动态编程 JavaScript 指南

![](img/2a133bc8ae90c0d09afc6ad5142cfd16.png)

图片来源:作者

讨论完如何准备字符串操作面试问题，我们接下来要关注另一个热门话题:动态编程。

[动态规划](https://en.wikipedia.org/wiki/Dynamic_programming)是一种通过构建解决较小子问题的解决方案来解决较大问题的方法。

一个迭代实现，渴望和预缓存，通常是首选，因为它需要更少的时间和内存。然而，带迭代的动态编程更难思考。

迭代实现也称为制表。这个过程类似于填表格。这是一种自下而上的方法，首先解决较小的子问题，然后构建整个解决方案。这使得跟踪调试过程更加容易。

递归是一种解决问题的方法，其解决方案依赖于同一问题的较小实例的解决方案。但是递归在性能和空间使用上可能是低效的。动态编程通过内存化提高了性能和空间利用率。

记忆化动态规划是一种自顶向下的方法，假设较小的子问题已经解决，并且整个解决方案是从这些子解决方案中导出的。所有的递归算法都可以迭代实现，虽然有时候不太直观。

我们在本文中提供了 JavaScript 示例。然而，该原理和算法也可以应用于其他语言。

这个面试系列会让你为一个成功的技术面试做好准备，对日常编码也很有用。

# 排列

对于动态编程来说，[数组](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)与[映射和集合](https://medium.com/better-programming/the-technical-interview-guide-to-string-manipulation-92f4c4649cd)一样，是记忆化的基本数据结构。

Array 是一个类似列表的对象，它有执行遍历和变异操作的方法。在 JavaScript 中，数组长度和元素类型可以重置。它可以作为一个对象互换使用。以下是供回顾的代码样本，包括 ES2016 中的`includes`、ES2019 中的`flat` / `flatMap`和 ES2022 中的`at`。

# 动态规划

还有很多动态编程相关的测试。不可能全部都练习。我们通过一系列测试来强调解决问题的技巧。

对于每个测试，我们给出两个动态规划解，一个迭代实现，一个递归实现。

我们尝试通过以下步骤实现解决方案的标准化:

*   将记忆数组命名为`dp`。
*   将递归名命名为`findResult`。
*   将递归放在函数内部，以利用[闭包](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)。

闭包是一个函数与对其周围状态的引用捆绑在一起(封闭)的组合。换句话说，闭包让我们可以从内部函数访问外部函数的范围。在 JavaScript 中，闭包是在每次创建函数时创建的。

## 斐波那契数

[斐波那契数](https://en.wikipedia.org/wiki/Fibonacci_number)是一个经典的动态规划问题。斐波纳契数列是一系列数字，其中一个数字是最后两个数字的相加，从 0 和 1 开始。斐波纳契数列中的每个数字称为斐波纳契数。

对于得出第 n 个斐波那契数的算法，等式是:

*   `fibonacci(n) = fibonacci(n - 1) + fibonacci(n — 2)`

这是计算第 n 个斐波那契数的迭代算法:

这是计算第 n 个斐波那契数的递归算法:

这些是验证测试:

## **最小路径**

最小路径是通过向右或向下寻找矩阵中从左上角到右下角的路径，其中假设矩阵中的每个点都被赋予一个值，则该路径应该具有最小和。例如，`[[1,2], [3,4]]`有一条从 1 → 2 → 4 的最小路径，其和为 7。

我们初始化一个二维数组用于记忆，其中`dp[i][j]`代表从`point[0][0]`到`point[i][j]`的最小路径和。最小路径从左侧点(`dp[i][j — 1]`)或从上方点(`dp[i — 1][j]`)开始累积:

*   `dp[i][j] = Math.min(dp[i][j — 1], dp[i — 1][j]) + matrix[i][j]`。

这是计算最小路径和的迭代算法:

这是计算最小路径和的递归算法:

这些是验证测试:

## L **最大增长子序列**

一个[最长递增子序列](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) (LIS)是寻找一个给定序列中最长的子序列，其中子序列的元素按从低到高的顺序排列，并且子序列尽可能长。这个子序列不一定是连续的或唯一的。例如，`[1, 3, 2, 2, 4]`具有最长的递增子序列，`[1, 2, 2, 4]`，其长度为 4。

给定一个数字数组`nums`，我们初始化一个数组用于记忆，其中`dp[i]`代表`nums.slice(0, i + 1)`中最长的递增子序列。`nums`中每个元素都是一个单长度的列表。如果后续元素等于或大于，则当前元素可以将长度扩展 1。如果这个值更大，选择这个新值。分解算法是这样的:

`dp[i] = Math.max(dp[j] + 1)`，对于每个`0 ≤ j < i`和`nums[j] < nums[i]`

将选择所有选项中最长的`dp[i]`，因为结果不一定是最后一个元素的`dp[nums.length — 1]`。

这不是最快的算法，但很容易理解。如果你在寻找一个 O(n log n)的解决方案，请查看这个维基页面。

这是计算 LIS 长度的迭代算法:

这是计算 LIS 长度的递归算法:

这些是验证测试:

## 变革

一个[找零](https://en.wikipedia.org/wiki/Change-making_problem)问题解决的是找到给定金额的最小硬币数的问题。给定`[1, 5]`的硬币选择，制造 100 的最小硬币数是 20，即`5 x 20 = 100`。如果无解，硬币数为-1。

给定一个数字数组`coins`，我们初始化一个数组用于记忆，其中`dp[i]`代表产生数量`i`的最小硬币数。等式是:

`dp[i] = Math.min(dp[i — coins[j]] + 1)`，对于每一个`0 ≤ j < coins.length` 和`i — coins[j] >= 0`和`dp[i — coins[j]] !== -1`

这是计算目标金额硬币数的迭代算法:

这是计算目标金额硬币数的递归算法:

这些是验证测试:

## L **最长公共子序列&** 最短公共超序列

一个[最长公共子序列](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem) (LCS)被用来寻找两个序列的最长公共子序列。子序列在原始序列中不需要连续。为了简化，我们假设字符串只包含小写字母。给定两个字符串`“apple”`和`“peach”`，最长的公共子序列是`“pe”`，长度为 2。

[最短公共超序列](https://en.wikipedia.org/wiki/Shortest_common_supersequence_problem) (SCS)是两个给定序列的最小长度的公共超序列。同样的例子，`“apple”`和`“peach”`，短接的公共超序列是`“appleach”`，长度为 8。

你注意到什么了吗？`“apple”`和`“peach”`的总长度为 10，减去复制的最长公共子序列`“pe”`的长度，剩余值为 8。因此，LCS 和 SCS 的长度可以一起计算。

给定两个字符串`str1`和`str2`，我们初始化一个二维数组用于记忆，`dp[i][j]`代表`str1.slice(0, i)`和`str2.slice(0, j)`的最长公共子序列。该算法可以描述如下:

*   如果`(str1[i — 1] === str2[j — 1])`，那么`dp[i][j] = dp[i — 1][j — 1] + 1`。
*   否则，`dp[i][j] = Math.max(dp[i][j — 1], dp[i — 1][j])`。

这是计算 LCS 和 SCS 长度的迭代算法:

这是计算 LCS 和 SCS 长度的递归算法:

这些是验证测试:

## 正则表达式匹配

正则表达式是定义搜索模式的字符序列。该模式用于对字符串执行“查找”或“查找和替换”操作。这里我们将模式简化为以下情况之一:

*   `.`匹配任何单个字符。
*   `*`匹配前面的字符 0 次或更多次。
*   否则，字符匹配自身。

例如，`“a”`匹配模式`“a”`、`“.”`、`“a*”`、`“a*b*”`和`“a*b*c*”`。但是`“a”`与模式`“b”`、`“b*”`、`“*a*b*”`和`“a*b*c*d”`不匹配。

这是检查正则表达式匹配的迭代算法:

这是检查正则表达式匹配的递归算法:

这些是验证测试:

# 结论

动态规划问题有很多种。熟能生巧。享受编码。

感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物。