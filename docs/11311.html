<html>
<head>
<title>The Best Approach for a Pipeline Architecture in .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中管道体系结构的最佳方法。网</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-best-approach-for-a-pipeline-architecture-in-net-d0ad0332ea24?source=collection_archive---------6-----------------------#2022-03-08">https://betterprogramming.pub/the-best-approach-for-a-pipeline-architecture-in-net-d0ad0332ea24?source=collection_archive---------6-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0942" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用最少的代码创建一个干净的管道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dc5394744b9b1c4fefd932fa50a95473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ogf14B-QzOHiaTnO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="01c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我最近的项目中，我面临了一个相当简单的挑战，就是将Azure Blob存储中的数据与本地文件存储同步。然而，在同步时，应该对blob或文件的元数据应用若干过滤和转换，例如，通过特定位置过滤，将文件的路径转换为blob路径等</p><p id="87b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的白板上画出数据流后，我很快意识到，过滤和转换只是简单的链式操作，就像流水线一样。我决定使用管道和过滤器模式作为架构的应用程序逻辑部分，但是在。网？</p><h1 id="e7d9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">要求</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/7ebf0ef11d7a8559aedcf25758803422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*sX4tNoRF5NW3l2Owt6JNqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有源和订户的管道草图</p></figure><p id="d9e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要完成的是将几项任务分解成一系列逻辑步骤。此外，我们的目标是在每个单独的步骤中遵循单一责任原则。一个步骤应该只关注一件事。如果我们需要另一件东西，我们只需在中间增加一个步骤。同样非常需要的是，通过依赖注入使管道可注入，同时还保持可配置性。</p><p id="0d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上所述，我们要完成以下要求:</p><ul class=""><li id="ced7" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">一种按照逻辑顺序快速设置管道的方法。</li><li id="430f" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">可以用依赖注入来构造管道。</li><li id="7d95" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">管道应该是可配置的。</li><li id="dab4" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">管道应该将一个事件流作为输入，输出另一个事件流。事件类型可能因此而改变。</li></ul><h2 id="1b38" class="nc lw it bd lx nd ne dn mb nf ng dp mf li nh ni mh lm nj nk mj lq nl nm ml nn bi translated">方法</h2><p id="bf4a" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在我的研究中，我发现了许多在。然而，在我看来，它们都太复杂，不够灵活。这就是为什么我决定重新创造这种建筑风格。NET，使用<a class="ae ky" href="https://github.com/dotnet/reactive" rel="noopener ugc nofollow" target="_blank">反应式扩展</a>使它更加干净和直观。</p><p id="bc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我的经验，处理事件流的最佳方法是<a class="ae ky" href="https://github.com/dotnet/reactive" rel="noopener ugc nofollow" target="_blank">反应式扩展</a>。Reactive Extensions是一个库，它使您能够用类似LINQ的操作符处理异步数据流。这是使用观察者模式实现的。</p><p id="71ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，你有一个<code class="fe nt nu nv nw b">IObservable&lt;T&gt;</code>，它发出数据/事件。然后，您可以像使用LINQ的<code class="fe nt nu nv nw b">IEnumerable&lt;T&gt;</code>一样处理这些数据，对其进行过滤、转换等等，之后数据到达名为<code class="fe nt nu nv nw b">IObserver&lt;T&gt;</code>的订户，他订阅流并处理结果。</p><p id="04cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单单反应式扩展库就足以满足我们一半的需求。我们可以设置一个事件源，一个管道，它过滤和转换数据，最后设置一个订户来处理事件。</p><p id="e4dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们仍然缺少使用依赖注入的能力，我个人认为，在一个大的<code class="fe nt nu nv nw b">Reactive.Linq</code>链中，很难在一个类中实现单一的职责。</p><p id="2809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有和Rx.Net合作过，我强烈推荐你去看看李·坎贝尔的以下教程:</p><div class="nx ny gp gr nz oa"><a href="http://introtorx.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">欢迎</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">编辑描述</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">introtorx.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><h1 id="272f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">具有IObservable的流水线结构</h1><p id="c4cf" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">首先，我们需要一个接口，我们可以用它来声明一个管道。界面应该明确什么进什么出。我决定把它叫做<code class="fe nt nu nv nw b">IPipe&lt;TIn, TOut&gt;</code>。这个管道必须包含一个方法，该方法将一个<code class="fe nt nu nv nw b">IObservable&lt;TIn&gt;</code>作为输入并返回一个<code class="fe nt nu nv nw b">IObservable&lt;TOut&gt;</code>。我们称之为<code class="fe nt nu nv nw b">Handle()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="842b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个管道的实例现在可以一个接一个地链接起来，同时是类型安全的。为了能够将多个管道链接在一起，最好有一个简单的扩展方法，而不是将那些<code class="fe nt nu nv nw b">Handle()</code>调用一个嵌套在另一个中。这就是我们创建以下扩展方法的原因:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="3bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以一个管道接一个管道地进行链接，而不用在代码中深度嵌套我们的调用链。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/d213ed39c21e6866d6f3568dc56218d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-vjzVwDRyeKXDZXskgp5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有单个源的示例管道</p></figure><p id="5189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们现在可以创建并链接单个负责的管道，从而创建一个相当干净的管道。然而，我们仍然缺少依赖注入部分。</p><p id="6f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够从依赖注入创建管道，必须将管道和依赖项添加到阿迪容器中。问题就在这里:当一个管道是从一个全局DI-Container创建的时候，我们如何具体地配置和重用它呢？</p><p id="35ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这个过滤管的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过滤管道的示例实现</p></figure><p id="d8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要注入一个<code class="fe nt nu nv nw b">ILogger</code>，它通常被添加到全局DI-Container中，以及一个特定的Options-Instance，我们当然不希望它是全局可用的。为了实现这一点，我们需要每个管道有一个单独的DI容器，在这里我们为每个管道添加特定的配置。</p><p id="9a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定为这件事创建一个<code class="fe nt nu nv nw b">IPipelineBuilder</code>。构建器应该有自己的DI容器，它是从全局容器派生出来的。在这个容器中，我们可以安全地为我们的管道添加选项。此外，我们将使用这个生成器以类型安全的方式设置管道本身。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">IPipelineBuilder的实现</p></figure><p id="718d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nw b">PipelineBuilder</code>有两种方法:<code class="fe nt nu nv nw b">ConfigureOptions()</code>和<code class="fe nt nu nv nw b">ConfigurePipeline()</code>。您可以使用第一种方法将您的特定管道选项添加到构建器的DI容器中，第二种方法用于将可观察管道链接在一起。</p><p id="056c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的目标是，使管道的创建尽可能简单，需要尽可能少的参数。出于这个原因，我决定强制将Source-Observable添加到<code class="fe nt nu nv nw b">IPipelineStepBuilder</code>中，因为这为我们节省了多个额外的泛型类型参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="bbac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，在添加一个源之后，您可以添加一个管道，处理<code class="fe nt nu nv nw b">ChatMessage</code>。该步骤由<code class="fe nt nu nv nw b">LoggerPipe</code>处理，并将<code class="fe nt nu nv nw b">ChatMessage</code>返回到下一个管道。<code class="fe nt nu nv nw b">MessageFilterPipe</code>也处理<code class="fe nt nu nv nw b">ChatMessage</code>，只让符合特定标准的消息通过。<code class="fe nt nu nv nw b">MessageTransformPipe</code>显示了一个转换是如何在一个管道中发生的，并返回另一个类型<code class="fe nt nu nv nw b">IdentifiedChatMessage</code>。</p><p id="ac8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个好处是，您可以决定要么向管道添加一个<code class="fe nt nu nv nw b">IPipe&lt;TIn,TOut&gt;</code>实例，这不需要您添加通用参数，要么让它由构建器中的DI容器构建，遗憾的是，您必须指定管道的传出类型，因为这是无法推断的。</p><p id="d49a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nt nu nv nw b">Build()</code>后，会收到一个<code class="fe nt nu nv nw b">IObservable&lt;TOut&gt;</code>，可以订阅。</p><p id="0e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下要做的唯一一件事，就是向一个类提供一个<code class="fe nt nu nv nw b">IPipelineBuilder</code>的实例，这个类正在建立一个管道。为此，我们为<code class="fe nt nu nv nw b">IServiceCollection</code>实现了一个扩展方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="7107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得DI-Container可用于PipelineBuilder进行克隆，并且还将构建器添加为临时服务，这总是会产生一个新的、干净的<code class="fe nt nu nv nw b">IPipelineBuilder</code>实例。</p><h1 id="2bd9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="e106" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">有了这些模块，我们能够最大限度地减少所需的代码，创建一个干净的管道。管道可以承载无限的管道，并且可以使用依赖注入以类型安全的方式构造。此外，我们能够添加特定的配置选项，以便我们可以托管多个管道，这些管道具有相同的管道，但具有不同的配置。</p><p id="089a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pipline架构本身实施了一个更干净的代码，因为它非常清楚一步一步发生了什么。当您遵循单一责任原则并提供良好的命名时，在构建管道时，您将不会有任何问题，可以识别错误发生的位置，或者添加额外功能的位置。此外，通过在管道之间或管道末端添加额外的管道，扩展功能是非常容易的。</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="1752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信这个功能对你的项目非常有用——以管道架构为特色——我决定把它作为一个包发布在NuGet上:</p><div class="nx ny gp gr nz oa"><a href="https://www.nuget.org/packages/ObservablePipelines/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">可观察管道0.0.2</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">一个简单的。NET包来实现一个具有可观察性和可注入管道的干净的管道架构。这个包裹是…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">www.nuget.org</p></div></div><div class="oj l"><div class="oz l ol om on oj oo ks oa"/></div></div></a></div><p id="191e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以在我的GitHub上找到源代码和展示:</p><div class="nx ny gp gr nz oa"><a href="https://github.com/TobiStr/ObservablePipelines" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">GitHub-TobiStr/observable pipelines。NET包来实现一个干净的管道架构。</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">一个简单的。NET包来实现一个具有可观察性和可注入管道的干净的管道架构。这个包裹是…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="pa l ol om on oj oo ks oa"/></div></div></a></div></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="bf35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。非常感谢您的支持和参与。</p><p id="2403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。</p><p id="5f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你有美好的一天！</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/429378e6a7aee01df92851fb0e90e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK4zVN8TtnIM37dhEhE54g.png"/></div></div></figure><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@tobias.streng/membership" rel="noopener"> <em class="pc">现在加入中等</em> </a></p><p id="cb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。</p></div></div>    
</body>
</html>