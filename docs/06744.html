<html>
<head>
<title>Finding Bad Commits Using Git Bisect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Git二等分查找错误提交</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/finding-bad-commits-using-git-bisect-c6f09a964149?source=collection_archive---------6-----------------------#2020-10-30">https://betterprogramming.pub/finding-bad-commits-using-git-bisect-c6f09a964149?source=collection_archive---------6-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ef11" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">找出是哪个提交引入了新错误</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ff4250bcc6bd2c1125001e58cf28ce2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DO_s98I9GjDeqtVCtMVdHQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@shanehauser" rel="noopener ugc nofollow" target="_blank"> Shane Hauser </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><blockquote class="kw"><p id="c6c0" class="kx ky iq bd kz la lb lc ld le lf lg dk translated">“Git-二分——使用二分搜索法找到引入bug的提交”— <a class="ae kv" href="https://git-scm.com/docs/git-bisect" rel="noopener ugc nofollow" target="_blank"> Git的官方文档</a></p></blockquote><p id="3dcb" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb lg ij bi translated">最好通过一个真实的例子来理解这个命令并演示它是如何工作的。</p><p id="1309" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">让我们创建一个空的Git项目，并添加以下提交:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="aa81" class="mm mn iq mi b gy mo mp l mq mr">git commit --allow-empty -m 'good commit 1'<br/>git commit --allow-empty -m 'good commit 2'<br/>git commit --allow-empty -m 'good commit 3'<br/>git commit --allow-empty -m 'good commit 4'<br/>git commit --allow-empty -m 'good commit 5'<br/>git commit --allow-empty -m 'good commit 6'<br/>git commit --allow-empty -m 'BAD COMMIT'<br/>git commit --allow-empty -m 'good commit 7'<br/>git commit --allow-empty -m 'good commit 8'<br/>git commit --allow-empty -m 'good commit 9'<br/>git commit --allow-empty -m 'good commit 10'</span></pre><p id="d93b" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">我们刚刚发现了一个bug，但是我们不确定是哪个提交引入了它。<code class="fe ms mt mu mi b">git bisect</code>来救援了！</p><p id="690a" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">我们首先需要运行<code class="fe ms mt mu mi b">git bisect start</code>来启动向导:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="a7d5" class="mm mn iq mi b gy mo mp l mq mr">git bisect start</span></pre><p id="7415" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">现在我们需要告诉Git我们所知的最后一个引入bug的提交是什么。假设我们已经在最后一次提交时发现了错误:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="477d" class="mm mn iq mi b gy mo mp l mq mr">git bisect bad HEAD</span></pre><p id="afc1" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">当然，最早的提交是好的:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="ec81" class="mm mn iq mi b gy mo mp l mq mr">git bisect good HEAD~9<br/>Bisecting: 4 revisions left to test after this (roughly 2 steps)<br/>[375c587c8da1c90d07fd58a2402fd8bcf842ffd2] good commit 6</span></pre><p id="0552" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">现在Git将对我们的历史执行二分搜索法，并检查我们需要决定是好是坏的提交。</p><p id="c5dd" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">我们现在在<code class="fe ms mt mu mi b">good commit 6</code>上，一个在bug被引入之前的提交:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="bef7" class="mm mn iq mi b gy mo mp l mq mr">git bisect good<br/>Bisecting: 2 revisions left to test after this (roughly 1 step)<br/>[f14653c6730ef0537dbf8ec541997d7e9deb5e2a] good commit 7</span></pre><p id="d763" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">这个提交<em class="mv">不是</em>好的，因为代码已经包含了<code class="fe ms mt mu mi b">BAD COMMIT</code>。所以我们需要告诉Git这是不好的:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="92c2" class="mm mn iq mi b gy mo mp l mq mr">git bisect bad<br/>Bisecting: 0 revisions left to test after this (roughly 0 steps)<br/>[421dab9fc7f885dfadb3c7a37d70fa7dfbb6f3d1] BAD COMMIT</span></pre><p id="b34f" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">最后，错误的承诺:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="0099" class="mm mn iq mi b gy mo mp l mq mr">git bisect bad<br/>421dab9fc7f885dfadb3c7a37d70fa7dfbb6f3d1 is the first bad commit</span></pre><p id="3b9f" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><code class="fe ms mt mu mi b">git log</code>现在将揭示实际上是<code class="fe ms mt mu mi b">BAD COMMIT</code>引入了这个bug:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="eaa5" class="mm mn iq mi b gy mo mp l mq mr">git log | grep "BAD COMMIT" -B 5<br/>commit 421dab9fc7f885dfadb3c7a37d70fa7dfbb6f3d1<br/>Author: MarounMaroun &lt;maroun email&gt;<br/>Date:   Sun Jan 19 11:28:03 2020 +0200</span><span id="de32" class="mm mn iq mi b gy mw mp l mq mr">    BAD COMMIT</span></pre></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="3b78" class="ne mn iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated">自动化git二等分</h1><blockquote class="nv nw nx"><p id="2082" class="lh li mv lj b lk mc jr lm ln md ju lp ny me ls lt nz mf lw lx oa mg ma mb lg ij bi translated">"如果您有一个可以判断当前源代码是好是坏的脚本，您可以通过发出以下命令来一分为二:</p><p id="4a11" class="lh li mv lj b lk mc jr lm ln md ju lp ny me ls lt nz mf lw lx oa mg ma mb lg ij bi translated"><code class="fe ms mt mu mi b">$ git bisect run my_script arguments</code></p><p id="7f9a" class="lh li mv lj b lk mc jr lm ln md ju lp ny me ls lt nz mf lw lx oa mg ma mb lg ij bi translated">请注意，如果当前源代码是好的/旧的，脚本(上面示例中的<code class="fe ms mt mu mi b">my_script</code>)应该以代码0退出，如果当前源代码是坏的/新的，则以代码1到127(包括1和127)退出，但125除外。”— <a class="ae kv" href="https://git-scm.com/docs/git-bisect#_bisect_run" rel="noopener ugc nofollow" target="_blank"> Git的官方文档</a></p></blockquote><p id="5aff" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><code class="fe ms mt mu mi b">bisect</code>可以在<em class="mv">上运行一个命令，每次迭代</em>。如果命令成功(以零代码退出)，它会自动将提交标记为好。如果失败，它会将其标记为坏的(以非零代码退出)。例如，我们可以尝试使用<code class="fe ms mt mu mi b">make</code>实用程序(<code class="fe ms mt mu mi b">my_test.sh</code>)来构建我们的应用程序:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="23d2" class="mm mn iq mi b gy mo mp l mq mr">#!/usr/bin/env bash</span><span id="6aa5" class="mm mn iq mi b gy mw mp l mq mr">make test || exit 1</span></pre><p id="35a2" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">现在我们可以运行<code class="fe ms mt mu mi b">git bisect run ./my_test.sh</code>来开始自动化调试。如果脚本成功，它将返回一个零代码，并且<code class="fe ms mt mu mi b">git bisect</code>将把它标记为好的。否则，它会被标记为坏的。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="5686" class="ne mn iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated"><strong class="ak">总结</strong></h1><p id="b792" class="pw-post-body-paragraph lh li iq lj b lk ob jr lm ln oc ju lp lq od ls lt lu oe lw lx ly of ma mb lg ij bi translated"><code class="fe ms mt mu mi b">git bisect</code>是一个追踪bug的简单工具。它大大减少了调试时间。当你有一个很难调试的bug，并且很难找到是哪个提交引入了它的时候，最好使用它。如果您创建小而一致的提交，这将非常有用。</p><p id="96d3" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">如果您有可以通过编写测试场景由工具本身应用的自动化测试，这个命令将会更加有用。</p></div></div>    
</body>
</html>