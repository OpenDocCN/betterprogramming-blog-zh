# 服务员，我的单元测试里有数据库！

> 原文：<https://betterprogramming.pub/waiter-theres-a-database-in-my-unit-test-9698d866102e>

## 单元测试、集成测试和系统测试之间的区别驱动着愚蠢的面试问题和严肃的设计决策

![](img/f3739b2861e9219f98ae8a1b26e05c46.png)

《在餐厅》作者 J.M .六岁的天才儿子[https://www.flickr.com/people/dailypic/](https://www.flickr.com/people/dailypic/)

有多少种测试？假货和冒牌货有什么区别？缩进代码时，应该使用空格还是制表符？区分集成测试和系统测试的三个特征是什么？

向资深软件开发人员询问这些面试问题，你可能会得到白眼、咆哮，甚至是[冥想](http://www.satisfice.com/blog/archives/67)。如果你是一名新的开发人员，在面试你的第一份工作时，你听到了类似这样的问题，我有一些经验丰富的建议给你:抵制在记忆中寻找匹配教科书页面的诱惑。相反，确定最近的出口，然后疯狂冲刺。假装突然沙门氏菌中毒是可选的，但为了适合这种场合的表演，值得一些风格点。任何一个认为这个问题有合理答案的老板也会让你的生活变得痛苦，因为他会根据武断的规则不停地提出要求，而这些规则可能适合也可能不适合任何特定的情况。

你可以随意搜索查尔斯·巴贝奇的档案。你不会发现任何编码法则宣称任何地方的所有程序员都应该用空格缩进。另一方面，如果认为制表符和空格是等价的，它们之间的选择没有什么区别，那就错了。面试问题之所以愚蠢，只是因为它们缺乏上下文。加上上下文，单词就有了更清晰的含义，产生了重要的影响。

# 现实生活不是智力竞赛节目，但专业术语仍然很重要

在“[狗吃了我的单元测试](https://medium.com/@mike_74565/the-dog-ate-my-unit-tests-b56f1c01218b)”中，我承认，当我的老板发现我对基本术语感到尴尬和困惑时，我开始从一个随意的黑客转变为一个守纪律的开发人员。作为自我惩罚的一部分，我加入了一个学习小组，每周在文明边缘的一家路面公司的办公室聚会，钻研 ASQ 的“认证软件质量工程师知识体系”(CSQE BOK)。十年后，那个巨大的三环活页夹，堆满了印第安纳州质量委员会的纸张，仍然在我的书架上积着灰尘。它充满了每个人都使用的技术术语，但是有着混杂的定义。即使在活页夹里，你也会发现各种各样的东西。BOK 三世。包含来自“V 模型”的单元、集成和系统测试的定义 BOK 六世。B.4 包含一个混合测试分类法，它以不同的方式定义相同的术语。通篇都有重叠和不一致。在大多数娱乐形式中，我不会推荐这种材料，但如果你深夜被困在一家路面公司的偏远办公室里，它值得你笑一两声。

几乎没有变化。马丁·福勒[去年](https://martinfowler.com/bliki/IntegrationTest.html)指出，我们仍然无法就*集成测试*的精确定义达成一致，但无论如何尝试解释一下这个概念，因为它**重要** *。*一边是*单元测试*另一边是*系统测试*的边界可能是模糊的，但是它们对我们如何设计和构建我们的软件产生了重要的影响。这些决策反过来会对我们项目的成功以及我们同事和其他利益相关者的福祉产生重大影响。

最近，我在午餐时与一位开发人员聊天，他诅咒自己的命运，因为他继承了一个将业务逻辑和数据持久性紧密融合的组件，以至于将它们分开需要脑外科医生的技巧。对他来说不幸的是，手术室在等待，因为他的下一个任务是更换数据源。更可悲的是，这项手术还需要两次彩票中奖者的运气，因为当他的变化违反了一些既定的(但可能没有记录在案的)预期时，他没有任何警告。

当然，该组件包含在一个测试程序中——但是只有在该组件被集成到整个系统中并作为一个整体进行测试之后，该测试程序才会产生影响。这种程度的测试对我的朋友没有好处。他需要即时反馈，这样他才能自信地做出改变。他只进行了耗时太长的测试，而且测试级别很高，很容易漏掉他感兴趣的低级错误。

使用更多的技术术语，他需要*单元测试*，但是只有*系统测试*。我们无法就中间的边界达成一致，但我们可以就极端达成一致。即使我们坚持走极端，我们也可以推动关于我们应该在什么水平上测试的有益讨论。我们还可以追踪错误级别测试的悲惨故事。

出于本文的目的，我将稍微收紧定义，以便我们可以讨论频谱。你不需要像我一样在同样的地方画线，但是我鼓励你把它们画在某处**并且为你的选择提供充分的理由。这些线条将形成一个心智模型，帮助你清楚地思考你在哪里测试，什么时候测试，以及如何测试。**

当我们谈到单元测试的主题时，你会看到，以一种特殊的方式画线会对设计决策产生巨大的影响。一个训练有素的单元测试方法可以完全避免我朋友的困境，方法是在设计过程的早期就将业务逻辑与数据持久性分开。

# 无论级别如何，我们都通过测试来发现和评估

我最喜欢的古代文学场景之一出现在柏拉图的对话中。像往常一样，苏格拉底假装完全不知道，要求给美德这个词下一个一致的定义，以此来折磨可怜的梅诺。Meno 列出了一系列美德，有些适用于女人，有些适用于男人，有些适用于统治者，有些适用于奴隶。苏格拉底用笑话回答

> 我是多么幸运啊，梅诺！当我向你要一种美德时，你给了我一大堆。

如果我们谈论单元测试、集成测试和系统测试，但是不能解释使所有这些测试成为*测试*的核心概念，我们就像梅诺一样，揭示了我们没有完全考虑定义，并且可能不能解释我们正在做什么。

许多人认为测试软件就像对汽车进行十二点安全检查。当我触摸制动踏板时，制动灯是否点亮？检查。电池是否提供至少 12 伏电压？检查。发动机机油是否在油尺上的标记范围内？检查。

当然，我们执行定义良好的检查作为我们测试的一部分，但是像 Meno 的列表一样，它们没有定义核心。有人必须设计清单，并且(我们希望)有一个包含每一项和指定每一种测量技术的理由。为什么检查电池而不检查喷油器？为什么要相信量油尺而不是把油放掉称重？顺着检查回溯到它们的设计，你会发现人类的大脑肩负着在现实世界的约束中学习重要系统特性的任务。

詹姆斯·巴赫和迈克·伯顿已经花了很多年时间来提炼关于测试这个主题的一些最清晰的想法。他们这样抓住了它的核心概念:

> 测试是通过探索和实验来了解产品，从而对产品进行评估的过程，在一定程度上包括:提问、学习、建模、观察、推理等。

测试在人类经历中根深蒂固，以至于我们大多数人甚至没有意识到我们在大多数时间都在做着测试。如果你考虑走一条不同的上班路线，注册一个新闻订阅，或者更换面巾纸品牌，你会问什么问题？你如何着手回答这些问题？在你做决定之前，你愿意花多少时间和金钱来收集信息？

随着你的学习，你可能会制定一些规则来帮助你决定一个特定的选项是否值得考虑。如果您愿意，您甚至可以编写一个程序，使用这些规则来执行评估或为您完成一个清单，但是作为一个有思维的人，发现、设计适当的规则以及基于新信息进行重新评估的过程完全属于您。

[巴赫和波尔顿把可以简化为算法的评估称为“检查”](https://www.satisfice.com/blog/archives/856)检查是测试的一部分。它通常是最明显的部分，因此容易与整体混淆。这增加了测试过程被忽视然后被遗忘的危险。这导致了[错误的想法，即测试可以自动化](https://medium.com/swlh/an-instant-test-report-and-a-cherry-pie-a384e11e0a76)，这个想法已经嵌入到我们的语言和工具中。

对此我将直言不讳。我正在履行我上周对迈克·伯顿做出的关于坚持这一区别的承诺。我没有举起我的右手，他也没有给我一个徽章，但我确实感到被委托了。因此，你会读到我为了更精确而偏离了更常用的术语:例如，*自动化检查*而不是*自动化测试*。如果你觉得这分散了注意力，我道歉，但只是一半。也许这种分心会让你停下来考虑一下不同之处。也许你也会成为副警长。

# 单元测试保持代码的适应性和灵活性

几个月前，在丹佛软件质量协会的一个关于 API 测试的特别小组中，有人问了托德·布拉德利和我一个不切实际但发人深省的问题。如果我们被迫放弃三个测试层(单元、集成、系统)中的两个，我们会保留哪一个？尽管有专业软件测试人员的听众，我们两个都毫不犹豫地给出了会让他们所有人(包括我)失业的答案:所有的层都很重要，但是只有一层是我们会瘫痪的。没有单元测试，我们就没有单元检查。如果没有单元检查来保护我们，我们会害怕修复专业测试人员[几乎可以保证](https://daedtech.com/are-unit-tests-worth-it/)在系统级发现的无数错误。

自动单元检查不是一个可选的安全功能，您可以在产品烘烤后将其附加到产品上。相反，它们是[蛋白质，在你揉面的时候防止面团破碎。它们能让你大胆地做出改变，而不用担心会一团糟。单元检查记录您的学习，并保护单元测试过程中出现的设计。](https://www.scientificamerican.com/article/the-scientific-secret-of-stretchy-dough/)

## 什么是单位？

这里有一个来自 BOK 考试委员会的定义。B.4):

> 单元是最小的可测试软件，可以被编译、汇编、链接或置于测试工具或驱动程序的控制之下。一个单元通常是一个程序员的工作，可能由几百行或更少的源代码组成。

我看到“几百…行代码”时眼睛都凸出来了，但是定义上说的是“或者更少”。这是一个上限，而且(我希望)不是精确的。关键概念不是行数。这是一个小黑匣子的想法，它服务于一个狭窄且定义明确的目的。一个 [cookie jar](https://curl.haxx.se/docs/http-cookies.html) 是一个合理的范围单元。网络浏览器不是。

## 单元测试和设计之间的密切关系

所有有目的的代码都有一个设计。这个设计可能是草率的，随意的，或者更糟糕的，但它仍然是一个设计。设计来源于提问、学习、建模、观察、推理等。这个活动列表应该看起来很熟悉。我直接从巴赫和博尔顿提供的测试定义中提取出来的。我并不是第一个注意到单元测试和代码设计之间关系的人。像 [Allen Holub](http://www.drdobbs.com/architecture-and-design/test-driven-design/240168102) 和 [Mohamed Taman](https://www.infoq.com/articles/test-driven-design-java/) 这样的专家程序员对这个主题充满了诗意，并提倡使用测试来驱动显式检查和设计。其他编码人员可能使用隐式测试来驱动隐式设计，但是所有的设计都是基于某种测试的。

现在这种情况似乎不那么频繁了，但是我仍然发现人们在争论单元检查应该是专业测试人员的责任还是编写单元的开发人员的责任。如果你问这个问题，你没有看到(或者选择忽略)测试、设计和检查之间的相互作用。

我不打算在单元周围画一个亮黄色的警戒线，并说专业测试人员不被允许跨越并测试它们。如果他们遵循一条询问路线或者仅仅是好奇，我看不出有什么理由阻止他们，但是正式的单元检查来自产生设计的相同过程。在许多情况下，检查*是*设计。

## 测试设计影响产品设计

还记得那个开发人员吗？他得知自己的下一个任务是梳理数据持久性之外的业务逻辑，并以诅咒自己的命运、他出生的那一天以及整个天堂的主人作为回应。他应该诅咒他的商店定义*单元*的方式。

如果我们认真对待“可测试软件的最小部分”,并实际上使我们的小部分软件可测试，我们就不会梦想编写一个“单元”检查来为验证业务逻辑的目的提供一个数据库。业务逻辑将在一个单独的可测试单元中，被对数据持久性一无所知的单元检查所覆盖。数据持久性逻辑将位于一个独立的单元中，由对业务逻辑一无所知的单元检查所覆盖。如果我们关心这两个单元是如何交互的，我们可以编写一组单独的集成检查。

一个二年级的计算机科学学生会立即意识到这种设计只不过是坚持关注点分离。在我们称之为现实生活的混乱中，基本原则每天都被忽视或忽略。有时候没有什么坏事发生。有时我们会在现场看到奇怪的间歇性故障。有时候，一个开发人员对着天空挥舞着拳头，然后向他们的项目经理报告说他们将会损失一周的时间。

从一开始就严格遵守构建可执行单元检查的规则，你将迫使你的设计遵循良好的原则。不存在混合了业务和数据逻辑的单元检查，也不存在对无法测试的单元的单元检查。

## 单元测试的价值

因为单元测试与设计联系如此紧密，所以无论你是否把它作为一项活动提出来，它都会发生。那么，问题不是你是否执行单元测试，而是你是否明确地这样做，把它当作一个有意的规程，并产生可执行的单元检查。这让我们回到托德和我在班里给出的答案。如果你在为一个疯狂的官僚工作，他强迫你只在一层测试，那么你应该接受纪律，建立你的可执行单元检查，并且坚持到底。即使你不是在为一个疯狂的官僚工作，接受纪律只会帮助你。

当单元不能满足期望时，好的单元检查可靠地发出失败信号。这是一项卑微的工作，对代码库的可维护性有着巨大的影响。如果您确信当您意外破坏了其他单元所依赖的接口时，单元检查会保护您，那么您可以随意重构、优化或扩展。相反，如果你缺乏这种信心，那么任何改变都会产生一种风险，即一些未确定的依赖单元会失败。您唯一的缓解方法是测试集成系统，并祈祷您的覆盖率足够。

## 良好的单元检查的特征

*   它是 100%自动化的，不需要人工干预或解释。
*   它运行速度非常快，几毫秒就能完成。
*   它将单元与外界隔离，用[测试替身](http://xunitpatterns.com/Test%20Double.html)取代依赖。
*   它不对状态(配置、有无数据等)做出假设。
*   正好证明了一点。

这只是单元测试的一个粗略总结，作为与系统和集成测试的对比。单元测试的主题，尽管大部分被简化为写检查，也很容易填满整个[的书](https://www.manning.com/books/the-art-of-unit-testing-second-edition)。这可能是程序员可以学习的最重要的学科。

# 系统测试检测紧急不当行为

## 什么是系统？

如果一个单元是软件产品中可以测试的最小部分，那么系统就是最大的。CSQE BOK (VII。B.4)这样定义系统测试:

> 系统是一个大组件。系统测试的目的是揭示不能归因于组件本身的错误，而是归因于组件之间的不一致，或者组件的计划交互，以及其他对象。

系统是一个很大的组成部分。多大？我熟悉一家医疗器械公司，该公司在设计产品时，特别将操作员纳入各种具有关键安全影响的不良事件的缓解策略中。在这种情况下，系统由硬件、软件和至少两个人组成:操作员和病人。排除这些因素中任何一个的测试都有遗漏紧急故障模式的风险:在一个漫长的过程中，患者的妻子带着一大包饼干来了，他吃完了，导致他的血浆脂质飙升，软件“检测”到传感器故障(真实故事——注意你吃的东西)。

## 复杂性和涌现

区分系统和单元的关键概念是“涌现”单元足够小并且定义良好，我们可以全面地映射它们的行为。给定前提条件 *x* 当条件 *y* 时，我们期望行为 *z* 。相比之下，系统受制于复杂性。他们的行为方式是不可能预测的，即使完全了解他们的单位。我们不能控制所有相关的前提条件，也不能完全描述条件。随着与系统的互动呈线性增长，两者都呈指数增长，我们对自己有办法发现它们缺乏信心，即使有无限的时间。

举个简单的例子，构建一个程序，从一个静态列表中随机选取两个单词(即使是像牛津英语词典一样大的单词)。可能的输出数量巨大但简单。你总会看到一对字。扩展程序，通过 web 搜索引擎运行第二个单词，访问结果中的第一页，并输出页面上的第一个单词。现在你有了复杂性，而不仅仅是规模。你的程序的行为将取决于你不理解的因素，更不用说控制了。这些因素将相互作用，产生一系列令人难以置信的可能行为。预计会遇到来自上游状态、格式和延迟的组合效应。

## 系统测试的挑战

正如单元测试的情况一样，一个[完整的](https://www.amazon.com/Lessons-Learned-Software-Testing-Context-Driven/dp/0471081124) [规程](https://www.amazon.com/Agile-Testing-Practical-Guide-Testers/dp/0321534468)围绕着系统测试，其中很大一部分致力于[管理](https://en.wikipedia.org/wiki/Equivalence_partitioning) [范围](https://en.wikipedia.org/wiki/All-pairs_testing)以在合理的预算内提供合理的信心。与单元测试不同，系统测试永远不会“完成”单元测试可以产生一组检查，覆盖所有相关的先决条件和可能的条件。系统测试甚至不能精确地定义相关或可能的全部范围。系统从无限多的原因中产生惊喜。测试它们是一个概率和风险管理的游戏。

单元测试为自动化单元检查提供了一条直接的途径。像其他与系统相关的事情一样，检查需要一种更加细致入微的方法。随着稳定性的提高，检查变得更加有效。系统的某些方面会比其他方面更稳定。当其中一个数字有时变成错误信息或大猩猩图片时，对两个数字之和的检查就失败了。当实际行为突破了意料之外的界限，进入奇异状态时，人类的检查往往比机械的检查更有效。让测试人员在身边询问重要的问题，并使用令人惊讶的行为来更多地了解系统，这是一个好主意。

在某些情况下，最有效的系统检查方法是半自动的，机器提供输出给测试人员检查。全自动系统检查作为快速反馈机制可以提供巨大的价值，但是它们也带来了自身的复杂性。设计产生更多信号而不是噪音的检查需要技术技能和努力，这往往会让以前感到惊讶的项目经理感到惊讶。

## 良好系统检查的特征

*   它是针对完全构建的实际系统或接近的代理执行的。
*   它将所有其他考虑因素与总执行时间(可能会非常昂贵)进行权衡，并找到节约的方法。
*   它为开发人员理解故障提供了足够的日志记录和其他证据，而无需重复检查。

最后一点特别重要。由于完整系统的复杂性，检查是不可重复的。我们可能执行完全相同的一组操作，但我们不能保证基本条件是相同的。系统对于间歇性故障已经成熟，而我们人类在描述低频事件方面是出了名的差。如果我们在行动中抓住他们，或者随着时间的推移监控他们的表现，我们就有更好的机会去理解他们。

# 集成测试提供了关系破裂的早期警告

## 什么是整合？

回到我们的朋友，BOK(七。B.4):

> 集成是一个将硬件和软件组件聚合在一起以创建更大组件的过程。集成测试是为了表明，即使组件通过了成功的组件测试，单独的组件是令人满意的，但是组件的组合是不正确或不一致的。

集成测试和系统测试有什么不同？我们在谈论哪些组件？也许这是我脑海中关于连续马戏团的太多信息，但我读到了 BOK 的聚合组件，想到了鸡发出的声音，并立即重播了温迪店的旧“[零件是零件](https://www.youtube.com/watch?v=OTzLVIc-O5E)”表演。

## 一个潜在的最佳检查点

不要责怪 BOK。事实是，没有人能够在集成测试和系统测试之间划出精确的界限。那很好。我们不需要。一方面，一个好的单元检查通过伪造所有的依赖关系将它的单元与外界隔离开来。另一方面，一个好的系统检查覆盖了整个完整构建的系统。集成检查介于两者之间。它涵盖了一些精心定义的组件，其他的都不存在或伪造。

这个界限变得很难定义，因为最终，“系统”包括整个宇宙，并提出了深刻的哲学含义([蝴蝶翅膀](https://en.wikipedia.org/wiki/Butterfly_effect)和所有这些)，我们不需要为我们的测试程序考虑这些。就我们的目的而言，当我们想要评估两个或更多组件如何一起工作，并与系统的其余部分隔离时，我们应该设计集成检查，这样说就足够了。以这种方式缩小焦点可以提供比系统测试更多的控制或更快的反馈。

例如，假设您的产品包含一个分析引擎，它根据地铁乘客人数和小麦期货市场的结算价格实时执行一些难以理解的计算，这两项数据都是从监控适当数据馈送的内部组件接收的。单元检查将只覆盖带有伪造数据组件的分析引擎。系统检查将覆盖整个系统，包括实时数据输入。集成检查可能包括分析引擎和两个内部监控组件，但伪造数据馈送。这使您能够关注内部组件之间的关系，同时消除实时提要的不确定性。它还允许您引入[故障注入](https://en.wikipedia.org/wiki/Fault_injection)，并了解当 feeds 做了意想不到的事情时，集成组件将如何表现。

## 良好的集成检查的特征

*   它验证两个或多个组件是否按预期进行交互。
*   它比系统级检查更快、更便宜或更有效。
*   它为开发人员理解故障提供了足够的日志记录和其他证据，而无需重复检查。

您可能已经注意到，最后一点逐字重复了良好系统检查的特征。随着我们扩展到单元级别之外，并对越来越多的集成组件执行检查，不确定性行为的可能性呈指数增长，随之而来的是检查间歇性失败的可能性。如果您不能可靠地复制一个失败，那么下一个最好的事情就是精确记录发生了什么，在哪里，什么时候。

# 各就各位，各就各位

*测试*是一个通过了解产品来评估产品的人类过程。它可能包括*检查*，这是一个定义明确的评估，可以简化为算法并由机器执行。

一个好的软件测试计划将包括在技术栈的不同层次上战略性地放置的检查。它们可能涉及机械和人工检查的混合。

**单元检查**确保最小的组件继续按照指定的方式运行，尽管它们的实现发生了变化。它们运行起来非常简单，速度惊人，以至于每次对代码进行哪怕是最小的更改时，您都不会考虑在开发工作站上执行它们。它们需要很少的配置或依赖性管理(理想情况下不需要),以至于您在从您的持续集成管道中运行它们时不会犹豫。

**集成检查**针对组件的特定子集之间的交互，在这种情况下，您有理由担心一个组件可能会以不违反显式契约(应该由单元测试涵盖)的方式进行更改，但仍然会导致另一个组件失败或行为异常。在理想的情况下，集成检查应该是完全自动化的，运行起来就像单元测试一样简单快捷。在现实世界中，您可能需要折衷并引入实际的依赖项，如数据库或消息队列。这些依赖会带来复杂性和延迟，这是你在单元检查中永远无法忍受的。因此，您可能会选择将它们与您的主要 CI 管道并行运行，而不是接受更长的执行时间。

**系统检查**通知你复杂系统中可能出现的不可预测的行为。它们昂贵、缓慢，而且必然是不完整的，但是你仍然执行它们，因为你是谦卑的。尽管有良好的单元和集成检查，您认识到您有多少不知道的，并且希望在客户介入之前提前解决您的高级产品风险。系统级别的自动化带来了较低级别不存在的重大挑战，可能值得也可能不值得付出努力。

你可以用这些区别来发明一些愚蠢的面试问题，或者你可以用它们来引导你思考什么，在哪里，多少。如果你经常被怪异的行为吓到，看看你的系统和集成检查。如果你害怕做出改变，因为你可能会打破一些东西，看看你的单元检查。如果您检查您的单元检查并在设置中发现一个数据库，您有理由怀疑该单元。也许它融合了两种逻辑。最好在午餐时从继承你设计的可怜的开发者那里听到一大堆抱怨之前，重温一下那个设计。