<html>
<head>
<title>Mistakes I’ve Made Treating File Paths As Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我把文件路径当作字符串时犯的错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mistakes-ive-made-treating-file-paths-as-strings-ef831eecb33a?source=collection_archive---------14-----------------------#2020-03-04">https://betterprogramming.pub/mistakes-ive-made-treating-file-paths-as-strings-ef831eecb33a?source=collection_archive---------14-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2dc9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">作为开发人员，您做的一些事情可能会工作数年，但却在您最意想不到的时候反过来伤害您</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb1dd5a5eb318c58b9d5cf93189869b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GY9xXMXso1-V8zpG.png"/></div></div></figure><p id="28d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些是你希望另一个开发人员在你的职业生涯早期告诉你的事情，这样你就不会犯同样的错误。这篇文章就是关于这些事情中的一件，如果你正在读这篇文章，就当是我对你的警告。</p><p id="78a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">文件路径看起来像字符串。您有许多目录，可能还有一个以扩展名结尾的文件名。您用一个<code class="fe lq lr ls lt b">/</code>字符分隔目录和文件，结果看起来像<code class="fe lq lr ls lt b">/path/to/file</code>。因此，您可以像对待字符串一样对待它们，将它们连接或串联起来，直到您将它们传递给另一个用于读取或写入文件的file方法。这些是我几个月前的想法。这就是我错的地方。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c42e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">不要忘记Windows</h1><p id="878f" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">如果你在Mac(就像我有幸做的那样)或Linux上开发，那么你可能已经阅读了上面的段落并且没有注意到任何错误。如果你在Windows上开发，当你阅读<code class="fe lq lr ls lt b">/</code>角色时，你可能会对着你的咖啡叹气。</p><p id="bf63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你在Mac上工作并部署到Linux环境时，很容易忘记——就像我多年来所做的那样——Windows使用反斜杠。当您使用需要在这两种平台上运行的命令行工具时，发现自己犯了这样的错误是非常痛苦的。<a class="ae my" href="https://github.com/twilio-labs/create-twilio-function" rel="noopener ugc nofollow" target="_blank"> create-twilio-function </a>就是这样一个命令行工具，它必须经历<a class="ae my" href="https://github.com/twilio-labs/create-twilio-function/commit/af3031dcd5947a2abb735f7769bcd8fdb7e1aa73" rel="noopener ugc nofollow" target="_blank">个</a> <a class="ae my" href="https://github.com/twilio-labs/create-twilio-function/commit/fa281c1fce15db0915a8b403c4d19b9b2422da99" rel="noopener ugc nofollow" target="_blank">的变化</a>，比如:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="d480" class="nd mc it lt b gy ne nf l ng nh">mkdir(path + '/' + dirName);</span></pre><p id="2011" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">收件人:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="b7c0" class="nd mc it lt b gy ne nf l ng nh">const path = require('path');<br/>mkdir(path.join(pathName, dirName));</span></pre><p id="a3ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以便它能在Windows上正常工作。</p><p id="c358" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于Windows用户，我很抱歉。对于其他人来说，当使用Node.js时，<code class="fe lq lr ls lt b"><a class="ae my" href="https://nodejs.org/api/path.html" rel="noopener ugc nofollow" target="_blank">path</a></code>模块是你的朋友。每当你必须连接两条路径时，使用<code class="fe lq lr ls lt b"><a class="ae my" href="https://nodejs.org/api/path.html#path_path_join_paths" rel="noopener ugc nofollow" target="_blank">path.join</a></code>。并查看其他实用程序，如<code class="fe lq lr ls lt b"><a class="ae my" href="https://nodejs.org/api/path.html#path_path_relative_from_to" rel="noopener ugc nofollow" target="_blank">path.relative</a></code>(返回从一条路径到另一条路径的相对路径)和<code class="fe lq lr ls lt b"><a class="ae my" href="https://nodejs.org/api/path.html#path_path_normalize_path" rel="noopener ugc nofollow" target="_blank">path.normalize</a></code>(返回路径解析段，如<code class="fe lq lr ls lt b">.</code>或<code class="fe lq lr ls lt b">..</code>)。</p><p id="d106" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要理会<code class="fe lq lr ls lt b"><a class="ae my" href="https://nodejs.org/api/path.html#path_path_sep" rel="noopener ugc nofollow" target="_blank">path.sep</a></code>，它会根据您正在使用的系统返回一个<code class="fe lq lr ls lt b">/</code>或一个<code class="fe lq lr ls lt b">\</code>。用<code class="fe lq lr ls lt b">path.join</code>就行了。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="173e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">路径的行为与字符串不同</h1><p id="566f" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">现在是我的第二个错误，这次是在Ruby中工作。这个稍微微妙一些，躲过了我的测试。您看，您可以使用<code class="fe lq lr ls lt b">Pathname</code>类来创建路径片段，然后将它们连接起来。例如:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="2729" class="nd mc it lt b gy ne nf l ng nh">require "pathname"<br/>path1 = Pathname.new("path")<br/>path2 = Pathname.new("to")<br/>path1 + path2<br/># =&gt; #&lt;Pathname:path/to&gt;</span></pre><p id="b6fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，<code class="fe lq lr ls lt b">Pathname</code>对象有一个<code class="fe lq lr ls lt b">+</code>操作符来连接路径，就像<code class="fe lq lr ls lt b">+</code>连接字符串一样。事实上，它还可以混合使用字符串和路径:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="eae8" class="nd mc it lt b gy ne nf l ng nh">require "pathname"<br/>path1 = Pathname.new("path")<br/>path2 = "to"<br/>path1 + path2<br/># =&gt; #&lt;Pathname:path/to&gt;</span></pre><p id="4563" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一切似乎都很好，除了它不能反过来工作。</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="9ae0" class="nd mc it lt b gy ne nf l ng nh">require "pathname"<br/>path1 = "to"<br/>path2 = Pathname.new("path")<br/>path1 + path2<br/># =&gt; TypeError (no implicit conversion of Pathname into String)</span></pre><p id="0f89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像这样的小错误意味着我们做错了什么。不过，这不是我的问题。不，我的问题源于期望连接一个路径名和一个字符串，而不是连接两个字符串。这在<a class="ae my" href="https://github.com/philnash/jekyll-gzip/" rel="noopener ugc nofollow" target="_blank">我的RubyGem</a>T14】中有所体现。你看，我试着用下面这条线创建一个路径球:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="9444" class="nd mc it lt b gy ne nf l ng nh">files = Dir.glob(dir + "**/*{#{extensions}}")</span></pre><p id="d963" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原来在某些情况下，<code class="fe lq lr ls lt b">dir</code>实际上是一个字符串而不是路径名，并且它不包含分隔符。因此，当我真正想让它寻找<code class="fe lq lr ls lt b">"dirname/**/*{#{extensions}}"</code>时，它却在寻找<code class="fe lq lr ls lt b">"dirname**/*{#{extensions}}"</code>。连接两个路径名或者一个路径名和一个字符串会增加分隔符(<a class="ae my" href="https://github.com/philnash/jekyll-gzip/commit/6651b7f51b62cd14a3e256d77fa604a49eacb9d8#diff-392aaa6a279f62e98df890fff8d82d1eL54-R54" rel="noopener ugc nofollow" target="_blank">正如有人在我的commit评论中指出的</a>)，但是连接两个字符串不会。这意味着gem愉快地去寻找错误的路径名，没有找到文件，然后继续成功地什么也不做。将整行替换为:</p><pre class="kj kk kl km gt mz lt na nb aw nc bi"><span id="7324" class="nd mc it lt b gy ne nf l ng nh">files = Dir.glob(File.join(dir, "**", "*{#{extensions}}"))</span></pre><p id="2a38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">已修复问题。在这种情况下，<code class="fe lq lr ls lt b"><a class="ae my" href="https://ruby-doc.org/core-2.6.2/File.html#method-c-join" rel="noopener ugc nofollow" target="_blank">File.join</a></code>是用来避免字符串意外的方法。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4481" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">始终使用内置路径池</h1><p id="3e9a" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">无论您是使用Node.js、Ruby还是任何其他语言，都不要试图将文件路径视为字符串。它们在不同的平台上表现不同，将路径和字符串混合在一起会导致难以调试的错误。</p><p id="51a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用您的标准库，为自己省去麻烦。</p></div></div>    
</body>
</html>