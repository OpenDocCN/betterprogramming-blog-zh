<html>
<head>
<title>Android Navigation With a Pre-Existing Back Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有预先存在的后台堆栈的Android导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-navigation-with-a-pre-existing-back-stack-70d3d7327f31?source=collection_archive---------8-----------------------#2020-11-05">https://betterprogramming.pub/android-navigation-with-a-pre-existing-back-stack-70d3d7327f31?source=collection_archive---------8-----------------------#2020-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2756" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TaskStackBuilder简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f76236d7938502a71674ab00909eb57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vjhrf3pxDE04RmkP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="0eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航仍然是移动应用程序中最具挑战性的主题之一。在使用导航组件或您自己的导航器时，您会发现许多方法来路由到一组屏幕。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/a0b587fcdd515feccdb6ec647f4717c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wugu7ZUIPTLau2P1ROnzbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从A到B到c的导航。</p></figure><p id="5085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航也意味着如何回到上一个屏幕。您必须确保您的用户能够回到对您的流程有意义的地方。</p><p id="6e20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照上面的线性路径，从C点往回导航会到达b点，但是如果我让你导航到另一个屏幕呢？由于Android系统处理后台堆栈，这看起来有些牵强，对吗？</p><p id="554a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们想从A导航到C <em class="lw">而不从B导航</em>，然而，我们想让用户在从C导航回来时停留在屏幕B上——不管你是来自A还是B</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/7c19d49cb7018a762fadd74cf37a641f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhkvggXcMnPrCYsxdE2uIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从A导航到C，B养育C</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="6698" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">深度链接用例</h1><p id="8e4c" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">对于几个项目来说，我的任务是实现<a class="ae ky" href="https://developer.android.com/training/app-links/deep-linking" rel="noopener ugc nofollow" target="_blank">深层链接</a>。在移动应用中，系统可以拦截预定义的网址，打开你的应用而不是浏览器。应用程序打开后，您可以解析链接内容以导航至特定屏幕。</p><p id="2c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推荐的模式包括为每个活动声明一个深层链接。这样做将把路由委托给系统，以便在给定某个深层链接的情况下打开适当的屏幕。</p><p id="0f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您将直接导航到您的屏幕，而无需任何先前的屏幕堆栈。当按下back按钮时，用户将离开你的应用程序，因为它是你的back stack中唯一的屏幕。</p><p id="010e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们将深层链接附加到活动c。一旦深层链接被触发，我们将获得下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/48c0cfc7db723b80c9c0308322f817da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdLY53IxFjrP1IYaRxt08w.png"/></div></div></figure><p id="f28e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多情况下，这将是预期的行为。例如，当你从应用程序请求邮件意向时，你将打开你选择的邮件应用程序。您将进入编辑邮件屏幕。按下后退按钮会离开邮件应用程序，并返回到您的应用程序。</p><p id="cf03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，产品经理并不总是这么看。他们更喜欢你的用户留在你的应用上，不管他们来自哪里。另一个论点是，无论用户如何登陆屏幕，路由都应该是相同的。</p><p id="50b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为从A到B and B可以到达C，所以他们希望有相同的导航。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/6c6e9e38acf9267aa9c87b738706c6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoPQPCXlSciFdBnrPeJH7g.png"/></div></div></figure><p id="85e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引入这种模式会导致几个架构问题。深层链接不是这样工作的，由你来提供路径。</p><p id="a83d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lw">免责声明:我不是提倡这种模式！相反，我认为深层链接应该是你的应用程序的唯一入口。离开这个入口点应该会将您重定向到开始的应用程序。</em></p><p id="1d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，我看得太多了。我觉得你最好知道如何处理这件事。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="8d22" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">重建您的后台堆栈</h1><p id="9d83" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">提供这样的导航模式意味着路由到一个屏幕，同时通知系统它应该创建的后台堆栈。</p><p id="33b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng nh b"><a class="ae ky" href="https://developer.android.com/reference/androidx/core/app/TaskStackBuilder" rel="noopener ugc nofollow" target="_blank">TaskStackBuilder</a></code>提供了这样一种机制。顾名思义，您可以构建一个屏幕堆栈。</p><p id="8c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，你需要一个作为中枢的屏幕(比如Splash)。它的责任将是拦截所有的深层链接，然后分派到适当的屏幕。</p><p id="cd0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你解析了深层链接，你就可以创建你的目的地活动意图。用一个<code class="fe ne nf ng nh b">Context</code>把它传给<code class="fe ne nf ng nh b">TaskStackBuilder</code>，然后开始你的一堆活动:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="fabd" class="nm mg it nh b gy nn no l np nq">TaskStackBuilder.create(context) // can be this@SplashScreenActivity<br/>    .addNextIntentWithParentStack(intent) // The intent where to go<br/>    .startActivities()</span></pre><p id="9b28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们还没有提供您的屏幕是如何连接的。到目前为止，我们只成功地启动了一个没有任何父堆栈的intent。预期的结果将和以前一样，尽管我们使用了一种奇特但无用的导航方式。</p><p id="6ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要编辑您的<code class="fe ne nf ng nh b">AndroidManifest.xml</code>文件来指出栈是如何构建的。建造者依靠一面叫做<code class="fe ne nf ng nh b">parentActivityName</code>的旗帜。</p><p id="4e20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的示例，您可能有以下清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做，你让系统知道从C返回应该去b。</p><p id="ebb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以从A导航到C，但按下back按钮时会返回B。</p></div></div>    
</body>
</html>