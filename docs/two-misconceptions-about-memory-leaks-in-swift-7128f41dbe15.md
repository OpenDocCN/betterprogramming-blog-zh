# 关于 Swift 中内存泄漏的两个误解

> 原文：<https://betterprogramming.pub/two-misconceptions-about-memory-leaks-in-swift-7128f41dbe15>

## 他们告诉你的内存泄漏并不完全正确

![](img/abeebd934aabc58ab888a811d6b9978f.png)

照片由[达尼洛·阿尔维斯](https://unsplash.com/@daniloalvesd?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

Swift 严重依赖两种类型的实体:结构和类。两者的主要区别在于，结构是值类型，而类是引用类型。

两者的不同之处在于 Swift 如何在内存中处理它们。[引用类型在堆中分配，而值类型在栈中分配](https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation)。对于堆栈上的变量，一旦变量超出范围，内存就会自动释放。从堆中释放内存并不容易，不同的语言为此实现了不同的系统。

Swift 使用一种叫做[自动引用计数](https://en.wikipedia.org/wiki/Automatic_Reference_Counting)的静态方法，简称 ARC。编译器为每个引用类型的变量保留一个计数器:每当实体创建对变量的引用时，计数器就增加。每当参考中断时，计数器就会减少。当计数器到达`0`时，内存立即被释放。

该系统最常见的问题是参考周期。当两个变量相互引用时，就会发生这种情况。当这种情况发生时，计数器永远不会到达`0`，因为这两个对象保持一个指向彼此的指针，并且计数器对于它们自己的引用总是至少为`1`。当我们用来访问这些对象的变量变得不可访问时(例如，因为它超出了它的作用域),我们的应用程序就出现了内存泄漏:这两个变量保存在内存中，但我们无法再访问它们。

避免这种情况的常见建议是尽可能使用值类型。作为值类型，假设它们不会产生内存泄漏。

不幸的是，这并不完全正确。我们不能在我们的应用程序中只使用值类型(例如，`UIKit`和`Combine`都严重依赖于类),当结构的属性是引用类型时，我们仍然可以对它们进行引用循环。更糟糕的是，符合协议的类可能会在看似无辜的代码后面隐藏引用循环！

让我们看几个例子。

# 协议和参考周期

让我们看看下面的代码:

在这个例子中，我们有一个协议`Person`允许一个人拥有一个伴侣。伙伴必须符合相同的`Person`协议。

然后我们有一个实现协议的类`Married`。出于调试目的，我添加了一个`name`属性，当类为`deinit`时，我们将打印一条消息。

现在，让我们使用这些实体来创建一个参考循环。

在这里，我们创造了一对夫妇的人，我们将他们结合在一起。然后我们释放这些对象……没有来自`deinit`的消息被打印在控制台上。这是意料之中的。我们有两个相互引用的类。

然而，在`Married`类中，伙伴的类型是`Person`，这是一个协议！这意味着一个`Married`人可以接受任何其他对象作为伙伴，只要它符合`Person`协议。

`Married`类不会立即显示存在引用循环的风险，因为`Person`类型不是一个类。

为了解决这个问题并打破引用循环，我们需要在`partner`属性上使用`weak`关键字。通过使用该关键字，编译器不会增加引用计数器，因此它可以释放引用。然而，如果我们试图添加`weak`属性，我们会得到下面的编译器错误。

![](img/74cdbcc1f8f4d8cc762f741956f6fc55.png)

这是在抱怨不能使用`weak`关键字，因为`Person`也可以是值类型。为了解决这个问题，我们需要更新协议，将一致性添加到`[AnyObject](https://developer.apple.com/documentation/swift/anyobject)`协议中。

如果我们再次运行创建人的代码，我们最终设法正确地释放我们的`Married`对象。

第一点:总是将只由类实现的协议标记为`AnyObject`协议。这样，如果我们有一个参考循环，就可以做参考`weak`并求解。

# 结构和引用循环

第二个谎言是，结构不能生成引用循环。不幸的是，当他们的一个属性是一个类时，他们可以。让我们考虑一个可以包含一个`Person`的`House`结构。

这段代码看起来很安全，但事实并非如此。我们的`Person`可以由一个类实现，通过使用不带`weak`关键字的`Married`版本，我们将结束一个引用循环。

找到这个引用循环更加微妙:我们有一个保存协议属性的结构，我们通常不能为它添加`weak`关键字。但是当协议由一个类实现时，我们可能仍然有一个引用循环。

为了解决引用循环，我们需要使用类边界协议和`weak`关键字。

# 如何确保我们的应用程序没有内存泄漏

在为这篇文章做研究的时候，我在 [Essential Developer](https://www.essentialdeveloper.com/) 的[这个视频](https://www.youtube.com/watch?v=Gg-2nZYRd2g&list=PLyjgjmI1UzlTtsImzQ4cT8bQ3_RXtkqLg&index=4)上找到了答案。它的简单和有效打动了我。

基本上，每当我们为我们的类编写测试时，我们应该稍微改变我们的方法。我们需要使用工厂函数，而不是在`setUpWithError()`方法中创建测试变量。然后，我们可以向我们的引用类型添加一个弱引用，并断言它们在`tearDownWithError()`方法中成为`nil`。

在这个测试中，我们通过添加一个参考循环来创建被测系统(SUT)。在第 15 行，我们创建了`weakSUT`变量，在`tearDownWithError()`中，我们断言弱引用在测试结束时变成了`nil`。

如果我们使用带有强引用的`Married`类版本，这个测试将会失败。如果我们使用正确的版本，带有`weak var partner`属性，测试将会通过。

# 结论

在今天的文章中，我们指出了一些关于 Swift 语言的误解。诚然，值类型本身不会创建引用循环，但是，它们可以保存可以创建引用循环的变量。

这使得发现这样的问题变得非常困难，并且当我们将协议加入其中时，事情会变得更糟。

当编写我们的应用程序时，我们应该意识到我们的协议是如何使用的。如果我们希望它们只被类使用，我们应该使用`: AnyObject`一致性将它们标记为类绑定协议，这样我们就可以打破可能的引用循环。

最后，每次我们在应用程序中创建一个类时，我们都应该用`weakSUT`属性编写一个测试，并断言它在`tearDownWithError()`方法中变成了`nil`。

这些小预防措施将使我们的代码更具表现力，我们的应用程序更健壮，缺陷更少。