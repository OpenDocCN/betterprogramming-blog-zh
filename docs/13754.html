<html>
<head>
<title>How to Structure Navigation in React Native With Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React Native With Typescript中构造导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-navigation-with-typescript-fa7805f52ab0?source=collection_archive---------1-----------------------#2022-09-24">https://betterprogramming.pub/react-navigation-with-typescript-fa7805f52ab0?source=collection_archive---------1-----------------------#2022-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f41c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用打字—反应导航</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3c0426fcd33b5d9b3bb88985bca7ab75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iMhaqe1HBwocGhBK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亨德里克·莫克尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，构建导航已经成为任何移动应用的基本特征。说到React Native world，我们口袋里有<a class="ae kv" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank"> React导航</a>。</p><p id="b56e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将介绍如何使用TypeScript实现典型的React导航，同时比较使用TypeScript的不同策略。</p><p id="ba07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更重要的是，它还将涵盖我们如何最大限度地利用TypeScript功能，以便能够在导航上构建一个更具可伸缩性的架构。</p><p id="0036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意:本文中的例子是使用@react-navigation@6.x版本导出的。</em></p><p id="32c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">警告:本文将涉及的方法/策略并不是你必须严格遵循的必不可少的方法/策略，但它们只是我的偏好，我发现与本文的读者分享它们很有用。</em> <a class="ae kv" href="https://reactnavigation.org/docs/typescript" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> React Navigation已经有了一个惊人的关于类型脚本用法的有据可查的部分。</em> </a> <em class="ls">也就是说，你已经可以按照这个文档</em><a class="ae kv" href="https://reactnavigation.org/docs/typescript/" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">构建一个很棒的react-navigation类型脚本结构了。</em></p><h2 id="8469" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">创建堆栈导航器</h2><p id="235a" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">让我们来看看如何使用<a class="ae kv" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank"> React导航</a>包创建一个<a class="ae kv" href="https://reactnavigation.org/docs/stack-navigator/" rel="noopener ugc nofollow" target="_blank">堆栈导航</a>。</p><p id="4443" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参见下面取自<a class="ae kv" href="https://reactnavigation.org/docs/stack-navigator/#api-definition" rel="noopener ugc nofollow" target="_blank">反应导航</a>的例子；</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a845" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看出，这里没有任何关于TypeScript的具体内容，让我们在这段代码中添加一点TypeScript。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b2b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面，我们为<code class="fe mt mu mv mw b">createStackNavigator</code>添加了<code class="fe mt mu mv mw b">ParamList</code>类型。但是，我们怎么知道<code class="fe mt mu mv mw b">createStackNavigator</code>采用了泛型类型呢？有几种方法可以解决这个问题。首先查看<a class="ae kv" href="https://reactnavigation.org/docs/typescript/#type-checking-the-navigator" rel="noopener ugc nofollow" target="_blank">文档</a>一直是个好习惯。在这个给定的例子中，您会注意到在文档中已经有一个关于它的部分。</p><p id="21a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，假设网站上没有记录<code class="fe mt mu mv mw b">createStackNavigator</code>的这种特定类型，那么确定该函数是否具有该类型的一种可能的方法就是跳转到该函数的类型定义。一开始可能会令人生畏，因为会有很多类型、接口、泛型飞来飞去，但是你越习惯于跳到类型定义，它就越不会让人不知所措。</p><h2 id="5ef4" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated"><strong class="ak">更新！</strong></h2><p id="24dc" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">如果你想用typescript处理额外的复杂性，并且还想忽略React团队(<code class="fe mt mu mv mw b">React.ComponentProps)</code>)的优秀TS工具，你可以继续阅读到本文末尾。</p><p id="6eb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但我恐怕，这一段可能就要结束了！</p><p id="0190" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将能够使用<code class="fe mt mu mv mw b">React.ComponentProps&lt;typeof YourStack.Screen&gt;</code>检索每个堆栈屏幕的类型和它们的配置，结果将非常惊人。</p><p id="c479" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整示例见下文:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，它仍然有智能感知，如果你把一个不相关的<em class="ls">(或者:一个不在你的堆栈类型声明中的屏幕)</em>屏幕放到你的堆栈中，它仍然会警告你，这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/a21a711c3074a6045d1ce2dd5ec9d141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LkS3Ay_QPrWIDMZZCsOpZQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无效屏幕</p></figure><p id="f3fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">智能感知也将在那里:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/241f3da57b4e40434e4dbe43b887dd33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWJw4fN3Fs0IpOd-rSAIQA.png"/></div></div></figure><p id="86bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它也更加简洁、可配置和动态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="daa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，这种方法允许我们轻松地管理复杂的导航结构<em class="ls">(至少当我们将这种特定的方法与本文中的其他方法进行比较时)</em>。这是因为在你拥有更干净的JSX的同时，你也能够以一种更动态、更模块化的方式来配置你的<code class="fe mt mu mv mw b">routes</code>。</p><h2 id="a6fb" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">领先一步使用TypeScript</h2><p id="2a9b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">它确实不局限于只声明<code class="fe mt mu mv mw b">createStackNavigator</code>的泛型类型。<code class="fe mt mu mv mw b">Stack.Navigator</code>会有的<code class="fe mt mu mv mw b">children</code>元素类型怎么样？虽然他的概念在官方文档中已经有了很好的定义，但是让我们看看下面我们可以如何使用它来创建一个更松散的结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ebac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哎呀，这里发生了这么多…让我们把每个代码块分成单独的部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="bbd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在代码片段的顶部，我们正在导入必要的模块。这些导入包括类型、函数和其他必要的东西。它们不是有趣的，而是必要的:)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b653" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面，我们从react-native导入了<code class="fe mt mu mv mw b"><a class="ae kv" href="https://reactnative.dev/docs/view" rel="noopener ugc nofollow" target="_blank">View</a></code>组件，这样这个例子可以用一种更简单的方式来演示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4b41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有趣的部分来了。从<code class="fe mt mu mv mw b">@react-navigation/core</code>进口的<code class="fe mt mu mv mw b">RouteConfig</code>正好取五种类型作为<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">通用类型</a>。这个特殊的类型定义在官方的react-navigation网站上没有记录，尽管如此，你已经可以通过使用我们上面提到的跳转到类型定义的方法来理解这个类型定义。</p><p id="4a03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管在典型的react-native typescript项目中使用它可能显得多余/没有必要，但它有几个好处，将在下一节中介绍。</p><h2 id="4cc2" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated"><a class="ae kv" href="https://code.visualstudio.com/docs/editor/intellisense" rel="noopener ugc nofollow" target="_blank">智能感知</a></h2><p id="9c61" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">因为我们有一个严格类型化的堆栈路由(又名app routes)数组，所以数组的每个元素现在都必须坚持数组的类型定义。这意味着在向数组中添加新元素时，IntelliSense将开箱即用。</p><p id="61a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，应用这种类型会迫使我们在有新元素添加到应用程序routes时更新<code class="fe mt mu mv mw b">AppStackRoutesType</code> <em class="ls"> </em>。否则，我们将无法添加一个在<code class="fe mt mu mv mw b">AppStackRoutesType(AppStackParamList)</code>T13中不存在的新元素。</p><h2 id="de52" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">绘制路线</h2><p id="ae5c" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">接下来是最后一部分，我们使用<code class="fe mt mu mv mw b">createStackNavigator</code>创建堆栈导航器。那么简单地说，这只是映射我们上面创建的数组和它的严格类型的问题。</p><p id="d164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最终可以信任数组中的每个元素，它将拥有正确类型的元素，因此使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> spread语法</a>是安全的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="1078" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">这真的是最后一部分吗？</h2><p id="42bf" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">嗯……不！</p><p id="f2e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们仍然可以在我们已经讨论过的例子上改进我们的打字。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ac53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能已经注意到的不同之处是我们有了<code class="fe mt mu mv mw b">StackRoutesType</code>,它采用了一个泛型类型，等于我们之前已经见过的类型。但是你可能会问这有什么好处。最好用形象化的方式来回答这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f3a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不选择使用通用的<code class="fe mt mu mv mw b">StackRoutesType</code> <em class="ls">，</em>，我们将不得不为应用程序中的每个堆栈重复打字。</p><p id="4b5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，随着应用程序越来越大，这将是一个噩梦。<em class="ls">(这里的概念是，应用程序中堆栈的数量与应用程序的复杂性成正比，事实上，这并不总是100%有效的假设，但它适用于这个特定的示例)</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="41c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，看上面当使用泛型类型时，它是如何变得更简单和干净的。</p><h1 id="e6a2" class="ng lu iq bd lv nh ni nj ly nk nl nm mb jw nn jx me jz no ka mh kc np kd mk nq bi translated">最新图片</h1><p id="4694" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">让我们比较一下典型的<code class="fe mt mu mv mw b">Stack</code>函数在两种不同场景下的表现:</p><p id="b39f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">图一:在JSX逐个渲染整个堆栈屏幕。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="cfaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">图2:使用严格类型化的typescript创建的堆栈路由数组呈现屏幕。🎉</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="f896" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">还有一件事…导航器道具呢</h2><p id="395b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们可能还有一件事要考虑，那就是堆栈导航器的道具。查看下面的<code class="fe mt mu mv mw b">StackNavigator</code> <em class="ls">，</em>存在单个导航器的一大块配置。为什么不让这些配置与JSX脱钩？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从第13行开始，我们应该已经熟悉了为什么使用泛型。与这里的栈路由类型的唯一区别可能是<code class="fe mt mu mv mw b">DefaultNavigatorOptions</code>类型，它是从<code class="fe mt mu mv mw b">@react-navigation/core</code>引入的。类型本身的名称甚至是不言自明的，它是导航器的<code class="fe mt mu mv mw b">options</code>。</p><p id="3288" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似于<code class="fe mt mu mv mw b"><em class="ls">RouteConfig</em></code> <em class="ls"> </em>类型<em class="ls"> </em>我们上面提到过的<em class="ls">，</em>也需要多个泛型类型。除此之外，请记住，我们是显式地o<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls"/>子键，因为我们已经渲染了对应于<code class="fe mt mu mv mw b">Stack.Screen</code> <em class="ls">的<code class="fe mt mu mv mw b">Stack.Navigator</code> <em class="ls"> </em>子键。</em></p><p id="db2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第22行，我们正在创建一个全新的对象(或者它可以是一个函数，只要它返回一个满足导航选项类型的对象)，它将代表我们的导航器的<code class="fe mt mu mv mw b">options</code>。</p><p id="d7a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在第50行，只要满足给定的类型，这个对象就可以安全地与spread语法一起使用。</p><p id="7250" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更干净的JSX…我认为…</p><h2 id="fd8d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">最新图片-航海家道具</h2><p id="37d9" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">让我们再次比较典型的<code class="fe mt mu mv mw b">Stack</code>函数在两种不同场景下的表现:</p><p id="a899" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">图1:在JSX拥有stack navigator配置。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">图2:将堆栈导航器配置从JSX解耦。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="ea6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们已经介绍了如何真正利用TypeScript并实现一种更简洁的方式来构造我们的反应式本机导航器。</p><p id="22ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">祝大家有一个无虫的一天。</p></div></div>    
</body>
</html>