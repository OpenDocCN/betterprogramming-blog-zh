<html>
<head>
<title>How To Build a Pastebin Clone Web Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建Pastebin克隆Web服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-pastebin-clone-web-service-3503917ec4bd?source=collection_archive---------25-----------------------#2022-02-01">https://betterprogramming.pub/how-to-build-a-pastebin-clone-web-service-3503917ec4bd?source=collection_archive---------25-----------------------#2022-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a2c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">免费设计、构建和部署无服务器粘贴工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5fb954761dac29af990ad4416f3006d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PK5-JwCOiTsUB05l"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯利·西克玛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将构建一个<a class="ae ky" href="https://pastebin.mozilla.org/" rel="noopener ugc nofollow" target="_blank"> Pastebin </a>克隆——一个允许用户上传和分享文本或代码的网络服务，通过被称为“粘贴”的链接。接下来是我如何通过<a class="ae ky" href="https://workers.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare Worker </a>使用无服务器函数创建Pastebin克隆的旅程。如果您不熟悉Pastebin，我强烈建议您在继续阅读之前尝试一下。</p><p id="238b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“为什么是帕斯捷宾？”你可能会问。嗯，通过聊天应用程序发送超过50行长的文本(<em class="lv">看着你，</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Internet_Relay_Chat" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> IRC </em> </a>)并不是最好的沟通方式。</p><h2 id="598b" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">TL；速度三角形定位法(dead reckoning)</h2><ul class=""><li id="7280" class="mp mq it lb b lc mr lf ms li mt lm mu lq mv lu mw mx my mz bi translated">使用Cloudflare Worker和KV构建Pastebin克隆</li><li id="1def" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">项目要求和限制计划</li><li id="bbdd" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">使用密钥生成服务(KGS)粘贴URL UUID生成逻辑</li><li id="ed9e" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">GraphQL API的设计与实现</li><li id="7baa" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">paste.jerrynsh.com<a class="ae ky" href="https://paste.jerrynsh.com/" rel="noopener ugc nofollow" target="_blank">的现场演示</a></li><li id="3764" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated"><a class="ae ky" href="https://github.com/ngshiheng/paste-story" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></li></ul><p id="1532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个Pastebin克隆的设计与<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-i-built-my-own-tinyurl-like-service-using-serverless-computing-f41899f3fdcb">构建TinyURL克隆</a>非常相似，除了我们需要存储粘贴内容，而不是原始的非精简URL。</p><p id="e70e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，这不是关于以下内容的教程或指南:</p><ul class=""><li id="4e64" class="mp mq it lb b lc ld lf lg li nf lm ng lq nh lu mw mx my mz bi translated">如何应对实际的系统设计面试</li><li id="1b15" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">构建一个商业级的粘贴工具，如<a class="ae ky" href="https://en.wikipedia.org/wiki/Pastebin" rel="noopener ugc nofollow" target="_blank"> Pastebin </a>或<a class="ae ky" href="https://gist.github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub Gist </a></li></ul><p id="0eb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，这是一个概念证明(POC ),说明如何通过Cloudflare Worker使用无服务器计算来构建一个简单的粘贴工具。要继续阅读本文，请查看本<a class="ae ky" href="https://developers.cloudflare.com/workers/get-started/guide" rel="noopener ugc nofollow" target="_blank">入门指南</a>的步骤1至3。</p><p id="b054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们走吧！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="8d27" class="np lx it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">要求</h1><p id="06ac" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">让我们从阐明我们项目的用例及约束开始。</p><h2 id="a271" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">功能的</h2><ul class=""><li id="be22" class="mp mq it lb b lc mr lf ms li mt lm mu lq mv lu mw mx my mz bi translated">每当用户输入一段文本(或代码)时，我们的web服务应该生成一个带有随机关键字(UUID)的URL，例如<code class="fe od oe of og b">paste.jerrynsh.com/aj7kLmN9</code></li><li id="356f" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">每当用户访问生成的URL时，用户应该被重定向以查看原始的粘贴内容，即原始的文本块</li><li id="132b" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">粘贴的链接应该在24小时后过期</li><li id="1b9a" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">UUID应该只包含字母数字字符(<a class="ae ky" href="https://en.wikipedia.org/wiki/Base62" rel="noopener ugc nofollow" target="_blank"> Base62 </a>)</li><li id="8788" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">我们的UUID长度应该是8个字符</li></ul><h2 id="1e11" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">非功能性</h2><ul class=""><li id="d93f" class="mp mq it lb b lc mr lf ms li mt lm mu lq mv lu mw mx my mz bi translated">低延迟</li><li id="a3f5" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">高度可用</li></ul><h2 id="4482" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">预算、容量和限制规划</h2><p id="aa0f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">和我们之前的尝试一样，我们的目标是免费提供这项服务。考虑到<a class="ae ky" href="https://developers.cloudflare.com/workers/platform/pricing" rel="noopener ugc nofollow" target="_blank"> Cloudflare工作人员的定价</a>和<a class="ae ky" href="https://developers.cloudflare.com/workers/platform/limits" rel="noopener ugc nofollow" target="_blank">平台限制</a>，我们的约束条件是:</p><ul class=""><li id="63fb" class="mp mq it lb b lc ld lf lg li nf lm ng lq nh lu mw mx my mz bi translated">每天10万个请求，每分钟1千个请求</li><li id="3a07" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">CPU运行时间不超过10ms</li></ul><p id="1b55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于URL缩短器，我们的应用程序预计会经历高读写比率。也就是说，我们将使用<a class="ae ky" href="https://developers.cloudflare.com/workers/learning/how-kv-works" rel="noopener ugc nofollow" target="_blank"> Cloudflare KV </a>(下面是KV)，这是一个用于这个项目的低延迟键值存储。</p><p id="ef0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在撰写本文时，KV 的<a class="ae ky" href="https://developers.cloudflare.com/workers/platform/pricing#workers-kv" rel="noopener ugc nofollow" target="_blank">自由层具有以下</a><a class="ae ky" href="https://developers.cloudflare.com/workers/platform/limits#kv-limits" rel="noopener ugc nofollow" target="_blank">限值</a>:</p><ul class=""><li id="c794" class="mp mq it lb b lc ld lf lg li nf lm ng lq nh lu mw mx my mz bi translated">10万次阅读/天</li><li id="92ed" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">1k写入/天</li><li id="03a5" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">1 GB的存储数据(密钥大小为512字节；25 MiB的值大小)</li></ul><h2 id="c840" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">我们能储存多少浆糊</h2><p id="f55f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">在这一节中，我们将估计我们的Pastebin克隆可以存储多少粘贴，考虑到上面的限制。与存储URL不同，存储文本块会消耗更多的空间(相对而言)。以下是我们将要做出的假设:</p><ul class=""><li id="1db9" class="mp mq it lb b lc ld lf lg li nf lm ng lq nh lu mw mx my mz bi translated">1个字符为1个字节(使用此<a class="ae ky" href="https://mothereff.in/byte-counter" rel="noopener ugc nofollow" target="_blank">字节计数器</a></li><li id="c351" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">假设平均而言，一个粘贴(文件)可以包含大约200行代码(文本)，这意味着每个粘贴的大小大约为10 KB</li><li id="9547" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">最大存储容量为1 GB，这意味着我们的Pastebin克隆最多只能存储100，000个粘贴</li></ul><p id="8c32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，限额是基于每个账户的。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="c066" class="np lx it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">存储和数据库</h1><h2 id="b3e4" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">Cloudflare工人KV</h2><p id="0815" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">对于这个概念验证，我们将选择KV作为我们的数据库。让我们更深入地了解一下它的功能。</p><p id="6272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，<a class="ae ky" href="https://www.ibm.com/cloud/learn/cap-theorem" rel="noopener ugc nofollow" target="_blank"> CAP定理</a>常用于对分布式数据存储进行建模。CAP定理指出，分布式系统只能提供以下三种保证中的两种(<a class="ae ky" href="https://blog.cloudflare.com/workers-kv-is-ga/" rel="noopener ugc nofollow" target="_blank">来源</a>):</p><ol class=""><li id="b86c" class="mp mq it lb b lc ld lf lg li nf lm ng lq nh lu oh mx my mz bi translated">一致性—我的数据在哪里都一样吗？</li><li id="fb3f" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu oh mx my mz bi translated"><strong class="lb iu">可用性—我的数据是否总是可访问的？</strong></li><li id="db9c" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu oh mx my mz bi translated"><strong class="lb iu"> P </strong>分区容忍度—我的数据对区域性中断有弹性吗？</li></ol><p id="cad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在KV的情况下，Cloudflare选择保证<strong class="lb iu"> A </strong>可用性和<strong class="lb iu"> P </strong>分区容差，这符合我们的非功能性要求。尽管这种组合叫嚣着最终的一致性，但这是一种我们可以接受的折衷。</p><p id="133b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别忘了，KV支持极高的读取量和超低延迟，非常适合我们的高读写比应用。</p><p id="1047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经了解了权衡，让我们继续！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="f1e3" class="np lx it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">履行</h1><h2 id="05b0" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">URL生成逻辑</h2><p id="2e69" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">粘贴网址UUID生成逻辑将非常类似于网址缩写。以下是可能的方法的快速总结:</p><ol class=""><li id="e0e7" class="mp mq it lb b lc ld lf lg li nf lm ng lq nh lu oh mx my mz bi translated">使用UUID生成器为每个新请求按需生成一个UUID</li><li id="c05f" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu oh mx my mz bi translated">使用粘贴内容的散列(<a class="ae ky" href="https://www.md5hashgenerator.com/" rel="noopener ugc nofollow" target="_blank"> MD5 </a>)作为我们的UUID，然后使用散列的前N个字符作为我们的URL的一部分</li><li id="0d52" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu oh mx my mz bi translated">使用哈希+ Base62编码的组合</li><li id="2b6b" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu oh mx my mz bi translated">使用自动递增的整数作为我们的UUID</li></ol><p id="aaa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们将采用上面没有提到的另一种解决方案。</p><h2 id="db7e" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">预生成UUID键</h2><p id="cb2f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">对于此POC，我们将使用单独的工作线程预先生成KV中的UUID列表。我们将把这个工作者称为关键生成服务(KGS)。每当我们想要创建一个新的粘贴，我们将分配一个预先生成的UUID给新的粘贴。</p><p id="66d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这样做有什么好处呢？</p><p id="479a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，我们将不必担心密钥重复或哈希冲突(例如方法2或3)，因为我们的密钥生成器将确保插入KV的密钥是唯一的。</p><p id="9c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们将使用2kv:</p><ul class=""><li id="ef71" class="mp mq it lb b lc ld lf lg li nf lm ng lq nh lu mw mx my mz bi translated"><code class="fe od oe of og b">KEY_KV</code> —由我们的kg用来存储预先生成的UUID列表</li><li id="ffaa" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated"><code class="fe od oe of og b">PASTE_KV</code> —由我们的主应用服务器用来存储一个键值对；其中键是UUID，值是粘贴的内容。</li></ul><p id="5891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建KV，只需使用Wrangler CLI运行以下命令(<a class="ae ky" href="https://developers.cloudflare.com/workers/cli-wrangler/commands#kv" rel="noopener ugc nofollow" target="_blank">源</a>)。</p><pre class="kj kk kl km gt oi og oj ok aw ol bi"><span id="0f11" class="lw lx it og b gy om on l oo op"># Production namespace:<br/>wrangler kv:namespace create "PASTE_DB"<br/>wrangler kv:namespace create "KEY_DB"</span><span id="13c5" class="lw lx it og b gy oq on l oo op"># This namespace is used for `wrangler dev` local testing:<br/>wrangler kv:namespace create "PASTE_DB" --preview<br/>wrangler kv:namespace create "KEY_DB" --preview</span></pre><p id="5c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建这些KV名称空间，我们需要更新我们的<code class="fe od oe of og b">wrangler.toml</code>文件，以相应地包含名称空间绑定。要查看您的KV仪表板，请访问<code class="fe od oe of og b">https://dash.cloudflare.com/&lt;your_cloudflare_account_id&gt;/workers/kv/namespaces</code>。</p><h2 id="351e" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">如何生成UUID</h2><p id="7ece" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">为了让kg生成新的UUIDs，我们将使用<code class="fe od oe of og b"><a class="ae ky" href="https://github.com/ai/nanoid" rel="noopener ugc nofollow" target="_blank">nanoid</a></code>包。如果你迷路了，你可以参考GitHub库的<code class="fe od oe of og b"><a class="ae ky" href="https://github.com/ngshiheng/paste-story/tree/main/kgs" rel="noopener ugc nofollow" target="_blank">/kgs</a></code>文件夹。</p><p id="13dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KGS怎么知道有没有复制的钥匙？每当KGS生成一个密钥时，它应该总是检查UUID是否已经存在于<code class="fe od oe of og b">KEY_DB</code>和<code class="fe od oe of og b">PASTE_DB</code>中。</p><p id="8fb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，UUID应该从<code class="fe od oe of og b">KEY_DB</code>移除，并在生成新膏时在<code class="fe od oe of og b">PASTE_DB</code>创建。我们将在API部分介绍代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><h2 id="f19d" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">要生成的唯一密钥不足</h2><p id="47a2" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">我们可能遇到的另一个潜在问题是——当我们的<code class="fe od oe of og b">KEY_KV</code>中的所有UUIDs完全用完时，我们该怎么办？</p><p id="5274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将设置一个<a class="ae ky" href="https://developers.cloudflare.com/workers/platform/cron-triggers" rel="noopener ugc nofollow" target="_blank"> Cron触发器</a>，每天定期补充我们的UUID列表。为了响应Cron触发器，我们必须向Workers脚本添加一个<code class="fe od oe of og b"><a class="ae ky" href="https://developers.cloudflare.com/workers/runtime-apis/scheduled-event" rel="noopener ugc nofollow" target="_blank">"scheduled"</a></code> <a class="ae ky" href="https://developers.cloudflare.com/workers/runtime-apis/scheduled-event" rel="noopener ugc nofollow" target="_blank">事件</a>监听器，如下面的代码所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="e311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的POC每天最多只能支持1k次写入，我们将把<code class="fe od oe of og b">MAX_KEYS</code>设置为生成1000次。请根据您的帐户限制随意调整。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="5a62" class="np lx it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">应用程序接口</h1><p id="ddfb" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">在高层次上，我们可能需要2个API:</p><ul class=""><li id="7316" class="mp mq it lb b lc ld lf lg li nf lm ng lq nh lu mw mx my mz bi translated">创建粘贴内容的URL</li><li id="5004" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">重定向到原始粘贴内容</li></ul><p id="d479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个POC，我们将使用<a class="ae ky" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo GraphQL </a>服务器在<a class="ae ky" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>中开发我们的API。具体来说，我们将在使用<code class="fe od oe of og b"><a class="ae ky" href="https://github.com/cloudflare/workers-graphql-server" rel="noopener ugc nofollow" target="_blank">workers-graphql-server</a></code>的同时使用<code class="fe od oe of og b"><a class="ae ky" href="https://github.com/kwhitley/itty-router" rel="noopener ugc nofollow" target="_blank">itty-router</a></code>工人模板。</p><p id="3f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，如果您不熟悉GraphQL，您可以通过<a class="ae ky" href="https://paste.jerrynsh.com/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL playground </a>端点直接与这个POC的GraphQL API进行交互。</p><p id="ce37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">丢失时，你可以随时查阅<code class="fe od oe of og b"><a class="ae ky" href="https://github.com/ngshiheng/paste-story/tree/main/server" rel="noopener ugc nofollow" target="_blank">/server</a></code>文件夹。</p><h2 id="876d" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">按指定路线发送</h2><p id="f701" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">首先，我们的API服务器的入口点位于<code class="fe od oe of og b">src/index.js</code>，这里所有的路由逻辑都由<code class="fe od oe of og b">itty-router</code>处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><h2 id="015b" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">创建粘贴</h2><p id="a79d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">通常，要在GraphQL中创建任何资源，我们需要一个<a class="ae ky" href="https://graphql.org/learn/queries/#mutations" rel="noopener ugc nofollow" target="_blank">突变</a>。在REST API世界中，要创建的GraphQL变体非常类似于向POST端点发送请求，例如<code class="fe od oe of og b">/v1/api/paste</code>。下面是我们的GraphQL变体的样子:</p><pre class="kj kk kl km gt oi og oj ok aw ol bi"><span id="68ee" class="lw lx it og b gy om on l oo op">mutation {<br/>  createPaste(content: "Hello world!") {<br/>    uuid<br/>    content<br/>    createdOn<br/>    expireAt<br/>  }<br/>}</span></pre><p id="3a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，处理程序(解析器)应该调用从HTTP JSON主体接收<code class="fe od oe of og b">content</code>的<code class="fe od oe of og b">createPaste</code>。此端点应返回以下内容:</p><pre class="kj kk kl km gt oi og oj ok aw ol bi"><span id="90ad" class="lw lx it og b gy om on l oo op">{<br/>  "data": {<br/>    "createPaste": {<br/>      "uuid": "0pZUDXzd",<br/>      "content": "Hello world!",<br/>      "createdOn": "2022-01-29T04:07:06+00:00",<br/>      "expireAt": "2022-01-30T04:07:06+00:00"<br/>    }<br/>  }<br/>}</span></pre><p id="7937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里查看GraphQL模式。</p><p id="a922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们的解析器的代码实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="6394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了减少垃圾邮件，我们还添加了一个小检查来防止空粘贴的创建。</p><h1 id="b552" class="np lx it bd ly nq ot ns mb nt ou nv me jz ov ka mh kc ow kd mk kf ox kg mn nz bi translated">粘贴创建数据源</h1><p id="fe92" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">我们将与数据库(KV)交互的API逻辑保留在<code class="fe od oe of og b"><a class="ae ky" href="https://github.com/ngshiheng/paste-story/blob/main/server/src/datasources/" rel="noopener ugc nofollow" target="_blank">datasources/</a></code>中。</p><p id="82ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，我们需要从我们的KGS <code class="fe od oe of og b">KEY_DB</code> KV中删除所使用的密钥，以避免为新粘贴分配重复密钥的风险。</p><p id="44a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们还可以设置我们的键，在创建粘贴时有一天的<code class="fe od oe of og b"><a class="ae ky" href="https://developers.cloudflare.com/workers/runtime-apis/kv#creating-expiring-keys" rel="noopener ugc nofollow" target="_blank">expirationTtl</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="bee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我还创建了一个<code class="fe od oe of og b">getPaste</code> <a class="ae ky" href="https://graphql.org/learn/queries/" rel="noopener ugc nofollow" target="_blank"> GraphQL查询</a>来通过UUID检索粘贴内容。我们不会在本文中涉及它，但是可以在<a class="ae ky" href="https://github.com/ngshiheng/paste-story/tree/main/server/src" rel="noopener ugc nofollow" target="_blank">源代码</a>中查看它。在<a class="ae ky" href="https://paste.jerrynsh.com/graphql" rel="noopener ugc nofollow" target="_blank">操场上试一试</a>:</p><pre class="kj kk kl km gt oi og oj ok aw ol bi"><span id="956f" class="lw lx it og b gy om on l oo op">query {<br/>  getPaste(uuid: "0pZUDXzd") {<br/>    uuid<br/>    content<br/>    createdOn<br/>    expireAt<br/>  }<br/>}</span></pre><p id="490c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本次概念验证中，我们不支持删除任何贴膏，因为贴膏会在24小时后过期。</p><h1 id="8c38" class="np lx it bd ly nq ot ns mb nt ou nv me jz ov ka mh kc ow kd mk kf ox kg mn nz bi translated">获取浆糊</h1><p id="33e7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">每当用户访问一个粘贴URL (GET <code class="fe od oe of og b">/:uuid</code>)粘贴的原始内容应该被返回。如果输入了无效的URL，用户应该会得到一个丢失的错误代码。点击查看完整的HTML <a class="ae ky" href="https://github.com/ngshiheng/paste-story/blob/main/server/src/handlers/paste.js#L4" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="65f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，要在本地启动开发API服务器，只需运行<code class="fe od oe of og b">wrangler dev</code></p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="3ff3" class="np lx it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">部署</h1><p id="cbaa" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">在发布您的代码之前，您需要编辑<code class="fe od oe of og b">wrangler.toml</code>文件(在<code class="fe od oe of og b">server/</code> &amp; <code class="fe od oe of og b">kgs/</code>内)并在其中添加您的Cloudflare <code class="fe od oe of og b">account_id</code>。你可以在<a class="ae ky" href="https://developers.cloudflare.com/workers/get-started/guide#7-configure-your-project-for-deployment" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到更多关于配置和发布你的代码的信息。</p><p id="6b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一定要确保KV名称空间绑定也被添加到您的<code class="fe od oe of og b">wrangler.toml</code>文件中。</p><p id="07de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要向您的Cloudflare Worker发布任何新的更改，只需在相应的服务中运行<code class="fe od oe of og b">wrangler publish</code>。</p><p id="9cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将您的应用程序部署到自定义域，请查看这个短片。</p><h2 id="2cb8" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">CI/CD</h2><p id="b822" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">在<a class="ae ky" href="https://github.com/ngshiheng/atomic-url" rel="noopener ugc nofollow" target="_blank"> GitHub存储库</a>中，我还使用GitHub动作建立了一个CI/CD工作流。要使用<code class="fe od oe of og b">Wrangler actions</code>，请将<code class="fe od oe of og b">CF_API_TOKEN</code>添加到您的GitHub库机密中。</p><p id="594a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe od oe of og b">Edit Cloudflare Workers</code>模板<a class="ae ky" href="https://dash.cloudflare.com/profile/api-tokens" rel="noopener ugc nofollow" target="_blank">创建您的API令牌</a>。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="ca57" class="np lx it bd ly nq nr ns mb nt nu nv me jz nw ka mh kc nx kd mk kf ny kg mn nz bi translated">结束语</h1><p id="855a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">我没想到这个概念验证花了我这么长时间来编写和完成。像我之前的帖子一样，我很想以一些未来可以做出的<em class="lv">潜在的</em>改进(或者永远吸进积压的黑洞)来结束这篇文章:</p><ul class=""><li id="31da" class="mp mq it lb b lc ld lf lg li nf lm ng lq nh lu mw mx my mz bi translated">允许用户设置自定义到期时间</li><li id="a0ed" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">粘贴编辑和删除</li><li id="0bad" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">语法突出显示</li><li id="7852" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">分析学</li><li id="7f98" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">带密码保护的私人粘贴</li></ul><p id="3d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像网址缩写一样，粘贴工具也有一定的缺陷——这两种工具都使网址变得不透明，这是垃圾邮件制造者喜欢滥用的。好吧，至少下次你问“为什么这个代码不能工作？”，你就有自己的粘贴工具可以用了！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt oi og oj ok aw ol bi"><span id="3275" class="lw lx it og b gy om on l oo op"><strong class="og iu">Want to Connect With the Author?</strong></span><span id="ade4" class="lw lx it og b gy oq on l oo op">This article was originally published at <a class="ae ky" href="https://jerrynsh.com/how-to-build-a-pastebin-clone-for-free/" rel="noopener ugc nofollow" target="_blank">jerrynsh.com</a></span></pre></div></div>    
</body>
</html>