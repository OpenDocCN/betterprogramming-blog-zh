<html>
<head>
<title>JavaScript Internals: Under The Hood of a Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript内部:在浏览器的引擎盖下</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-internals-under-the-hood-of-a-browser-f357378cc922?source=collection_archive---------2-----------------------#2019-06-30">https://betterprogramming.pub/javascript-internals-under-the-hood-of-a-browser-f357378cc922?source=collection_archive---------2-----------------------#2019-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="090e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在浏览器中执行代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4018faa454aeb4c8841fdc402367eeac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RWFw8lcn9VJ8LWNG"/></div></div></figure><h1 id="db13" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="037e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Javascript很奇怪。有人喜欢，有人讨厌。它有很多独特的机制，这些机制在其他流行语言中没有出现，也没有对应的机制。例如，代码执行顺序，有时可能不直观，但肯定很突出。</p><p id="924c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">了解浏览器环境，它是由什么组成的，它是如何工作的，会让你在编写JavaScript时更有信心，并为可能发生的潜在问题做好充分准备。</p><p id="60d0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这篇文章中，我将试着解释一下Chrome浏览器背后发生的事情。我们来看看:</p><ul class=""><li id="cfb5" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">V8 Javascript引擎——编译步骤、堆和内存管理以及调用堆栈。</li><li id="feb8" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">浏览器运行时—并发模型、事件循环以及阻塞和非阻塞代码。</li></ul></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="d5f5" class="ku kv it bd kw kx ni kz la lb nj ld le jz nk ka lg kc nl kd li kf nm kg lk ll bi translated">JavaScript引擎</h1><p id="3c3b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">最流行的JavaScript引擎是V8，它是用C++编写的，被Chrome、Opera甚至Edge等基于Chromium的浏览器使用。</p><p id="7e1e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">基本上，引擎是一个将JavaScript翻译成机器代码并在计算机的中央处理器(CPU)上执行结果的程序。</p><h2 id="b6fb" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">汇编</h2><p id="ee3b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当浏览器加载JavaScript文件时，V8的解析器会将其转换成抽象语法树(AST)。这个树由Ignition使用，Ignition是一个产生字节码的解释器。字节码是机器代码的抽象，能够通过编译成非优化的机器代码来执行。V8在主线程中执行它，而优化编译器涡扇在另一个线程中进行一些优化，并产生优化的机器代码。</p><p id="e72f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这个管道叫做<a class="ae nz" href="https://en.wikipedia.org/wiki/Just-in-time_compilation" rel="noopener ugc nofollow" target="_blank">实时(JIT)编译。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/3b21b603d3af05aad59730aea58c34bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xsmQVGdJcMuhOsFmSj5ooA.gif"/></div></div></figure><h2 id="bb54" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">调用栈</h2><p id="6120" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">JavaScript是一种具有单一调用堆栈的单线程编程语言。这意味着您的代码是同步执行的。每当一个函数运行时，它将在任何其他代码运行之前完全运行。</p><p id="05c6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当V8调用您的JavaScript函数时，它必须将运行时数据存储在某个地方。<em class="ob">调用堆栈</em>是内存中由堆栈帧组成的位置。每个堆栈帧对应于一个尚未因返回而终止的函数调用。堆叠框架由以下部分组成:</p><ul class=""><li id="7c72" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">局部变量</li><li id="436f" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">自变量参数</li><li id="7539" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">回信地址</li></ul><p id="f4f8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果我们执行一个函数，V8会将frame推到栈顶。当我们从一个函数返回时，V8从框架中弹出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/babdb4d8f472af49576a3c3a0efbb98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HfdVxGiEwxRGoernzxtaTg.gif"/></div></div><p class="od oe gj gh gi of og bd b be z dk translated">Chrome开发工具中的调用堆栈</p></figure><p id="3ac2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">正如你在上面的例子中看到的，在每次函数调用时创建一个框架，并在每次返回语句时移除<em class="ob">(更多关于调用堆栈中存储的内容，你可以在这里阅读</em><a class="ae nz" href="https://medium.com/better-programming/javascript-internals-execution-context-bdeee6986b3b" rel="noopener"><em class="ob"/></a><em class="ob">)</em>。</p><p id="051f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">其他所有东西都被动态分配到一个叫做<em class="ob">堆</em>的大型非结构化内存中。</p><h2 id="8866" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">许多</h2><p id="4221" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有时V8在编译时不知道一个对象变量需要多少内存。此类数据的所有内存分配都发生在堆中——内存的非结构化区域。在我们退出分配内存的函数后，堆上的对象仍然存在。</p><p id="5a49" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">V8有一个内置的垃圾收集器(GC)。垃圾收集是内存管理的一种形式。它就像一个收集器，试图释放不再使用的对象所占用的内存。换句话说，当一个变量丢失了它所有的引用时，GC会将这个内存标记为“不可访问”并释放它。</p><p id="d46d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您可以通过在Chrome Dev Tools中制作快照来研究heap。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/0b93e9e90a21658a3816c065b910c36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IWs6bLjr_4XYlMig4IuNg.png"/></div></div><p class="od oe gj gh gi of og bd b be z dk translated"><em class="oi">Chrome开发工具中的堆快照(空白页2.2 MB！)</em></p></figure><p id="debc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">每个被实例化的JavaScript对象都被分组到其构造函数类下。带括号的分组表示不能直接调用的本机构造函数。如你所见，有许多<code class="fe oj ok ol om b">(compiled code)</code>和<code class="fe oj ok ol om b">(system)</code>实例，但也有一些传统的JavaScript对象，如<code class="fe oj ok ol om b">Math</code>、<code class="fe oj ok ol om b">String</code>、<code class="fe oj ok ol om b">Array</code>等等。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="aeed" class="ku kv it bd kw kx ni kz la lb nj ld le jz nk ka lg kc nl kd li kf nm kg lk ll bi translated">浏览器运行时</h1><p id="e689" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">因此，V8可以根据标准同步执行JavaScript，使用单个调用堆栈。但是我们对此无能为力。我们需要呈现用户界面。我们需要处理用户与UI的交互。此外，我们需要在发出网络请求的同时处理用户交互。但是当我们所有的代码都是同步的时候，我们如何实现并发呢？<em class="ob"> </em>多亏了浏览器引擎才有可能。</p><p id="8aa8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">浏览器引擎负责用HTML和CSS渲染页面。在Chrome中它被称为Blink。它是<a class="ae nz" href="https://en.wikipedia.org/wiki/WebKit#WebCore" rel="noopener ugc nofollow" target="_blank"> WebCore </a>的分支，WebCore是一个布局、渲染和文档对象模型(DOM)库。Blink是用C++实现的，它公开了Web APIs，比如DOM元素和事件、<code class="fe oj ok ol om b">XMLHttpRequest</code>、<code class="fe oj ok ol om b">fetch</code>、<code class="fe oj ok ol om b">setTimeout</code>、<code class="fe oj ok ol om b">setInterval</code>等等，可以通过JavaScript <strong class="lo iu">访问。</strong></p><p id="bfb9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们考虑下面这个<code class="fe oj ok ol om b">setTimeout(onTimeout, 0)</code>的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/6a728c95d9c81e99ff9b56ba6e519dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LaD5qH7bXyfNwwn5yJU3gQ.gif"/></div></div><p class="od oe gj gh gi of og bd b be z dk translated">Chrome开发工具中超时的调用堆栈</p></figure><p id="6737" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">正如我们所见，<code class="fe oj ok ol om b">f1()</code>和<code class="fe oj ok ol om b">f2()</code>函数首先被推入堆栈，然后<code class="fe oj ok ol om b">onTimeout</code>被执行。</p><p id="bf90" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">关键的一点是，我们注册了一个稍后运行的函数。无论是用户点击还是超时。我们的异步回调只有在相应的事件被触发后才由V8执行。</p><p id="e589" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">那么上面的例子是如何工作的呢？</p><h2 id="fa4b" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">并发</h2><p id="52c6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在执行完<code class="fe oj ok ol om b">setTimeout</code>函数后，浏览器引擎将<code class="fe oj ok ol om b">setTimeout</code>的回调函数放入<em class="ob">事件表</em> <strong class="lo iu">。</strong>这是一个将注册的回调映射到事件的数据结构，在我们的例子中<code class="fe oj ok ol om b">onTimeout</code>函数映射到超时事件。</p><p id="385d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一旦定时器到期，在我们的例子中，当我们将0 ms作为延迟时，事件被触发，并且<code class="fe oj ok ol om b">onTimeout</code>函数被放入<em class="ob">事件队列</em> <strong class="lo iu"> </strong>(也称为回调队列或消息队列或任务队列)。事件队列是一种数据结构，由将来要处理的回调函数(任务)组成。</p><p id="2c26" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后但同样重要的是，<em class="ob">事件循环</em>，一个持续运行的循环，检查调用栈是否为空。如果是这样，则执行事件队列中第一个添加的回调，并将其移动到调用堆栈中。</p><p id="28f3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">函数的处理继续进行，直到调用堆栈再次为空。然后事件循环将处理事件队列中的下一个回调(如果有的话)。</p><pre class="kj kk kl km gt oo om op oq aw or bi"><span id="26bf" class="nn kv it om b gy os ot l ou ov">const fn1 = () =&gt; console.log('fn1')<br/>const fn2 = () =&gt; console.log('fn2')<br/>const callback = () =&gt; console.log('timeout')</span><span id="2cf8" class="nn kv it om b gy ow ot l ou ov">fn1()<br/>setTimeout(callback, 1000)<br/>fn2()</span><span id="7b9b" class="nn kv it om b gy ow ot l ou ov">// output:<br/>// fn1<br/>// fn2<br/>// timeout</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/f2a28264cd2ad014642a8cfd3bce3f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UZB_cZdAhvuyezuPjdvJgQ.gif"/></div></div></figure><p id="e97f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">ECMAScript 2015引入了<em class="ob">作业队列</em> <strong class="lo iu"> </strong>(又名微任务队列)的概念。这个队列充满了承诺<code class="fe oj ok ol om b">resolve</code>和<code class="fe oj ok ol om b">reject</code>功能。作业队列中的回调比事件队列中的回调具有更高的执行优先级。这意味着事件循环将在事件队列中的任何其他回调之前逐个执行它们。</p><pre class="kj kk kl km gt oo om op oq aw or bi"><span id="7ad5" class="nn kv it om b gy os ot l ou ov">const fn1 = () =&gt; console.log('fn1')<br/>const fn2 = () =&gt; console.log('fn2')<br/>const onTimeout = () =&gt; console.log('timeout')<br/>const onResolve1 = () =&gt; console.log('resolved1')<br/>const onResolve2 = () =&gt; console.log('resolved2')</span><span id="fecc" class="nn kv it om b gy ow ot l ou ov">fn1()<br/>setTimeout(onTimeout, 0)<br/>Promise.resolve()<br/>  .then(onResolve1)<br/>  .then(onResolve2)</span><span id="1f98" class="nn kv it om b gy ow ot l ou ov">fn2()</span><span id="8fac" class="nn kv it om b gy ow ot l ou ov">// output:<br/>// fn1<br/>// fn2<br/>// resolved1<br/>// resolved2<br/>// timeout</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/19b60521ebdbf0518615d4cd82555e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EQmWU-B2Kc9fEkPaiMKIzg.gif"/></div></div></figure><p id="3d83" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意<code class="fe oj ok ol om b">onResolve1</code>、<code class="fe oj ok ol om b">onResolve2</code>、<code class="fe oj ok ol om b">onTimeout</code>回调的执行顺序。</p><h2 id="c73a" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">阻塞与非阻塞</h2><p id="b0fe" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">简单来说，所有的JavaScript代码都被认为是<em class="ob">阻塞了</em>。<strong class="lo iu"> </strong>当V8忙于处理堆栈帧时——浏览器卡住了。你的应用的用户界面被阻止。用户将无法点击、导航或滚动。在V8完成工作之前，不会处理来自网络请求的响应。</p><p id="e6d6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">想象一下，您必须在浏览器中运行的程序中解析一幅图像。</p><pre class="kj kk kl km gt oo om op oq aw or bi"><span id="5460" class="nn kv it om b gy os ot l ou ov">const fn1 = () =&gt; console.log('fn1')<br/>const onResolve = () =&gt; console.log('resolved')<br/>const parseImage = () =&gt; { /* long running parsing algorithm */ }</span><span id="6c43" class="nn kv it om b gy ow ot l ou ov">fn1()<br/>Promise.resolve().then(onResolve) // or any other Web API async fn<br/>parseImage()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/3734b5a64daeaffdf210c7ec28f946f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*njj1FAVRkpPvE7Kav-9dtQ.gif"/></div></div></figure><p id="2d6a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的例子中，事件循环被阻塞。它不能处理来自<em class="ob">事件/作业队列</em>的回调，因为<em class="ob">调用栈</em>包含帧。</p><p id="94ba" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">Web API让我们有可能通过异步回调编写<em class="ob">非阻塞</em>代码。当调用像<code class="fe oj ok ol om b">setTimeout</code>或<code class="fe oj ok ol om b">fetch</code>这样的函数时，我们将所有的工作委托给运行在单独线程中的C++本地代码。操作一完成，回调就被放入<em class="ob">事件队列</em>。同时，V8可以继续进一步执行JavaScript代码。</p><p id="acc6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有了这样的并发模型，我们可以处理网络请求、用户与UI的交互等等，而不会阻塞JavaScript执行线程。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="8fb0" class="ku kv it bd kw kx ni kz la lb nj ld le jz nk ka lg kc nl kd li kf nm kg lk ll bi translated">结尾部分</h1><p id="3fbf" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">理解JavaScript环境是由什么组成的对于每个想要解决复杂任务的开发人员来说是至关重要的。现在我们知道了异步JavaScript如何工作，调用栈、事件循环、事件队列和作业队列在其并发模型中的作用。</p><p id="1859" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">正如你可能已经猜到的，V8引擎和浏览器引擎背后有更多的东西。然而，我们大多数人只需要对所有这些概念有一个基本的了解。请点击拍手👏，如果上面的文章对你有帮助。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="f784" class="ku kv it bd kw kx ni kz la lb nj ld le jz nk ka lg kc nl kd li kf nm kg lk ll bi translated">参考</h1><div class="oz pa gp gr pb pc"><a href="https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">理解V8的字节码</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">V8是谷歌的开源JavaScript引擎。Chrome、Node.js和其他许多应用程序都使用V8。这篇文章…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">medium.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://medium.com/fhinkel/confused-about-stack-and-heap-2cf3e6adb771" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">对栈和堆感到困惑？</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">坦白说，我总是很难把堆栈和堆分开。是的，我读过内存管理，然后…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">medium.com</p></div></div><div class="pl l"><div class="pr l pn po pp pl pq ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">JavaScript如何工作:内存管理+如何处理4种常见的内存泄漏</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">几周前，我们开始了一个系列，旨在更深入地挖掘JavaScript及其实际工作方式:我们认为…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">blog.sessionstack.com</p></div></div><div class="pl l"><div class="ps l pn po pp pl pq ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">JavaScript如何工作:V8引擎内部+如何编写优化代码的5个技巧</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">几周前，我们开始了一个系列，旨在更深入地挖掘JavaScript及其实际工作方式:我们认为…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">blog.sessionstack.com</p></div></div><div class="pl l"><div class="pt l pn po pp pl pq ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://v8.dev/blog/ignition-interpreter" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">启动点火解释器V8</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">编辑描述</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">v8.dev</p></div></div><div class="pl l"><div class="pu l pn po pp pl pq ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art038" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">使用Chrome调试器工具，第6部分:堆分析器</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">上一次，我谈到了Chrome内置的CPU profiler，它可以让您检测Javascript代码并…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">commandlinefanatic.com</p></div></div></div></a></div></div></div>    
</body>
</html>