<html>
<head>
<title>Websockets in iOS 13 Using Swift and Xcode 11</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 13中使用Swift和Xcode 11的Websockets</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/websockets-in-ios-13-using-swift-and-xcode-11-18fa3000d802?source=collection_archive---------1-----------------------#2019-07-30">https://betterprogramming.pub/websockets-in-ios-13-using-swift-and-xcode-11-18fa3000d802?source=collection_archive---------1-----------------------#2019-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7e89" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">苹果终于将Websockets作为一等公民加入了它的平台</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de3c92103e13f72f2b10f78d68559709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7m32RkSJee3GBUD5HYA2w.jpeg"/></div></div></figure><p id="b98b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">iOS 13、macOS 10.15、tvOS 13、watchOS 6、Mac Catalyst中的Websockets在网络栈中获得了一等公民地位。苹果终于为他们的平台在<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask" rel="noopener ugc nofollow" target="_blank"> URLSession </a>和<a class="ae lq" href="https://developer.apple.com/documentation/network/nwprotocolwebsocket" rel="noopener ugc nofollow" target="_blank"> Network.framework </a>中增加了对低层的支持。</p><p id="370c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一次我们将关注使用URLSession功能实现Websockets。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b8db" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">iOS 13之前</h1><p id="ffae" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">以前，如果你想在苹果平台上使用Websockets，你必须依赖于iOS 2.0中添加的<a class="ae lq" href="https://developer.apple.com/documentation/cfnetwork" rel="noopener ugc nofollow" target="_blank"> CFNetwork </a>。这是使用基于C的基础流。然后你必须处理指针和内存分配问题，这在C语言中很常见。</p><p id="e2b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一种方法是使用第三方解决方案，如<a class="ae lq" href="https://github.com/daltoniam/Starscream" rel="noopener ugc nofollow" target="_blank">红蜘蛛</a>，我在之前已经<a class="ae lq" href="https://kristaps.me/websockets-swift/" rel="noopener ugc nofollow" target="_blank">描述过了。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1cb5" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用URLSession的Websockets</h1><p id="e881" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">以下是使用由<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank"> URLSession </a>提供的<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask" rel="noopener ugc nofollow" target="_blank">URLSessionWebSocketTask</a>类构建Websocket的三种方法:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="be66" class="na lz it mw b gy nb nc l nd ne">func webSocketTask(with: URL) -&gt; URLSessionWebSocketTask<br/>func webSocketTask(with: URLRequest) -&gt; URLSessionWebSocketTask<br/>func webSocketTask(with: URL, protocols: [String]) -&gt; URLSessionWebSocketTask</span></pre><h1 id="c7d9" class="ly lz it bd ma mb nf md me mf ng mh mi jz nh ka mk kc ni kd mm kf nj kg mo mp bi translated">打开连接</h1><p id="0a08" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要创建和打开Websocket连接:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c822" class="na lz it mw b gy nb nc l nd ne">let urlSession = URLSession(configuration: .default)<br/>let webSocketTask = urlSession.webSocketTask(with: "wss://echo.websocket.org")<br/>webSocketTask.resume()</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="20d9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">发送消息</h1><p id="be79" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">建立连接后，您可以使用<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/3281790-send" rel="noopener ugc nofollow" target="_blank">urlsessionwebsockettask . send</a>功能发送<code class="fe nk nl nm mw b">Data</code>或<code class="fe nk nl nm mw b">String</code>消息。您需要用<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/message" rel="noopener ugc nofollow" target="_blank"> URLSessionWebSocketTask构造一个消息。消息</a>枚举类型。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c4ef" class="na lz it mw b gy nb nc l nd ne">let message = URLSessionWebSocketTask.Message.string("Hello World")   <br/>webSocketTask.send(message) { error in<br/>  if let error = error {<br/>    print("WebSocket couldn’t send message because: \(error)")<br/>  }<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1d21" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">接收消息</h1><p id="9180" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要从服务器接收消息，您需要使用<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/3281789-receive" rel="noopener ugc nofollow" target="_blank">urlsessionwebsockettask . receive</a>方法。它接受完成处理程序，该处理程序是<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/message" rel="noopener ugc nofollow" target="_blank">消息</a>类型的<a class="ae lq" href="https://developer.apple.com/documentation/swift/result" rel="noopener ugc nofollow" target="_blank">结果</a>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d9d9" class="na lz it mw b gy nb nc l nd ne">webSocketTask.receive { result in<br/>  switch result {<br/>  case .failure(let error):<br/>    print("Error in receiving message: \(error)")<br/>  case .success(let message):<br/>    switch message {<br/>    case .string(let text):<br/>      print("Received string: \(text)")<br/>    case .data(let data):<br/>      print("Received data: \(data)")<br/>    }<br/>  }<br/>}</span></pre><p id="a835" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，如果您想连续接收消息，您需要在接收完消息后再次调用此函数。一种方法是将它包装在一个函数中，递归地调用同一个函数。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="27d6" class="na lz it mw b gy nb nc l nd ne">func receiveMessage() {<br/>  webSocketTask.receive { result in<br/>    switch result {<br/>    case .failure(let error):<br/>      print("Error in receiving message: \(error)")<br/>    case .success(let message):<br/>      switch message {<br/>      case .string(let text):<br/>        print("Received string: \(text)")<br/>      case .data(let data):<br/>        print("Received data: \(data)")<br/>      }<br/>      <br/>      self.receiveMessage()<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8471" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Pings和Pongs</h1><p id="e611" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要保持与服务器的连接，最好间隔一段时间发送PING消息。你可以用<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/3181206-sendping" rel="noopener ugc nofollow" target="_blank">urlsessionwebsockettask . send ping</a>函数来实现。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e8a4" class="na lz it mw b gy nb nc l nd ne">func sendPing() {<br/>  webSocketTask.sendPing { (error) in<br/>    if let error = error {<br/>      print("Sending PING failed: \(error)")<br/>    }<br/> <br/>    DispatchQueue.main.asyncAfter(deadline: .now() + 10) {<br/>      self.sendPing()<br/>    }<br/>  }<br/>}</span></pre><p id="f8fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，您需要负责发送给您自己的下一个PING。最简单的方法是只使用<code class="fe nk nl nm mw b">DispatchQueue</code>或<code class="fe nk nl nm mw b">Timer</code>功能。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4628" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">紧密联系</h1><p id="9578" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一旦你完成并想要关闭Websocket连接，你需要发送一个关闭代码，这是一个<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/closecode" rel="noopener ugc nofollow" target="_blank"> URLSessionWebSocketTask。CloseCode </a>枚举类型。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="15a4" class="na lz it mw b gy nb nc l nd ne">webSocketTask.cancel(closeCode: .goingAway, reason: nil)</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f33b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">正在检查连接状态</h1><p id="7752" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要监控连接状态，您可以使用<a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsocketdelegate" rel="noopener ugc nofollow" target="_blank">URLSessionWebSocketDelegate</a>协议。您可以在连接打开或关闭后进行检查。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="05cd" class="na lz it mw b gy nb nc l nd ne">/// connection disconnected<br/>func urlSession(_ session: URLSession,<br/>  webSocketTask: URLSessionWebSocketTask,<br/>  didCloseWith<br/>  closeCode: URLSessionWebSocketTask.CloseCode,<br/>  reason: Data?)</span><span id="2eee" class="na lz it mw b gy nn nc l nd ne">// connection established<br/>func urlSession(_ session: URLSession,<br/>  webSocketTask: URLSessionWebSocketTask,<br/>  didOpenWithProtocol protocol: String?)</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="61db" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a6c7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">苹果终于将Websockets作为一等公民加入了它的平台。当然，还有一些小问题和不完善的地方——例如，您不能连续接收消息——但是您不需要再去构建Websocket框架了，这是一个巨大的胜利。</p><p id="0c70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前，它只适用于最新的测试版，如果你支持旧版本的iOS、tvOS、watchOS或macOS，你需要考虑向后兼容性。</p><h1 id="a76a" class="ly lz it bd ma mb nf md me mf ng mh mi jz nh ka mk kc ni kd mm kf nj kg mo mp bi translated">链接</h1><ul class=""><li id="c36c" class="no np it kw b kx mq la mr ld nq lh nr ll ns lp nt nu nv nw bi translated"><a class="ae lq" href="https://developer.apple.com/documentation/foundation" rel="noopener ugc nofollow" target="_blank"> URLsession文档</a></li><li id="9336" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask" rel="noopener ugc nofollow" target="_blank"> URLSessionWebSocketTask文档</a></li><li id="9e51" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><a class="ae lq" href="https://developer.apple.com/documentation/foundation/urlsessionwebsocketdelegate" rel="noopener ugc nofollow" target="_blank">URLSessionWebSocketDelegate文档</a></li><li id="fb67" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><a class="ae lq" href="https://appspector.com/blog/websockets-in-ios-using-urlsessionwebsockettask" rel="noopener ugc nofollow" target="_blank">由应用程序发布的博客</a></li><li id="85a6" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><a class="ae lq" href="https://kristaps.me/websockets-swift/" rel="noopener ugc nofollow" target="_blank">我之前关于使用Websockets的博文</a></li></ul></div></div>    
</body>
</html>