<html>
<head>
<title>Should You Use Python pathlib or os?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应该用Python pathlib还是os？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-be-using-pathlib-6f3a0fddec7e?source=collection_archive---------1-----------------------#2021-01-30">https://betterprogramming.pub/should-you-be-using-pathlib-6f3a0fddec7e?source=collection_archive---------1-----------------------#2021-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8a96" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">两个Python路径库之间的决斗</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3f754183020bcfaf0386ac9c606db978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6f_v1mekoLOIPRhQ_ALRg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尼泊尔Gokyo(作者拍摄)</p></figure><p id="407c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文比较了两个使用文件路径的Python库:<a class="ae lr" href="https://docs.python.org/3/library/os.html" rel="noopener ugc nofollow" target="_blank"> os </a>和更新的<a class="ae lr" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank"> pathlib </a>。</p><p id="64d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一场黎明对决——一场比较两种常见编程任务方法的四轮对决。</p><p id="fba5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谁将是我们的冠军？</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b40d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><code class="fe mr ms mt mu b">os</code>还是<code class="fe mr ms mt mu b">pathlib</code>？</h1><p id="91f8" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">如果你已经用Python编程一段时间了，很可能你正在使用操作系统中的函数，比如<code class="fe mr ms mt mu b">os.path.join</code>。</p><p id="ee0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">pathlib是在Python 3.4中引入的，它为处理路径提供了一组不同的抽象。然而，仅仅因为它更新，并不意味着它更好。</p><p id="bc38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么如何决定哪个是最好的呢？一场传统的决斗怎么样？黎明时的手枪！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1f07" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">第一轮-单一路径</h1><p id="0991" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我们的第一轮由通常使用单个文件路径完成的任务组成:</p><ul class=""><li id="17b0" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">从字符串形成文件路径</li><li id="f4df" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">获取主目录和当前工作目录</li><li id="d240" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">使用文件名和后缀</li></ul><h2 id="27ff" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">创建单个文件路径</h2><p id="a98d" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">操作系统对文件路径采取不同的方法——例如，LINUX使用<code class="fe mr ms mt mu b">/</code>,而Windows使用<code class="fe mr ms mt mu b">\</code>作为路径的分隔符。</p><p id="5bf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于这种复杂性，可移植性是一个关键问题——<code class="fe mr ms mt mu b">os.path</code>和pathlib都提供了可移植的方法来构造路径。</p><p id="c430" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">os提供<code class="fe mr ms mt mu b">os.path.join</code>来创建文件路径:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="4d79" class="no ma iq mu b gy oe of l og oh">import os<br/>path = os.path.join(os.path.expanduser('~'), 'data', 'file.txt')<br/># /Users/adam/data/file.txt</span></pre><p id="e259" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在pathlib中，使用除法运算符<code class="fe mr ms mt mu b">/</code>和初始化的<code class="fe mr ms mt mu b">Path</code>对象形成路径:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="a643" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path.home() / ‘data’ / ‘file.txt’<br/># /Users/adam/data/file.txt</span></pre><p id="a4d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mr ms mt mu b">Path</code>对象是pathlib的焦点。我们需要的几乎所有功能都可以作为这个对象的属性或方法来访问。</p><h2 id="696e" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">获取主目录</h2><p id="d4df" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">主目录位于不同操作系统的不同位置。我们的两个竞争者都提供了一种获取用户主目录的方法，这种方法在UNIX和Windows系统上都适用:</p><ul class=""><li id="ce7b" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">Ubuntu <code class="fe mr ms mt mu b">/home/$USER</code></li><li id="b9f6" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">苹果电脑<code class="fe mr ms mt mu b">/Users/$USER</code></li><li id="874b" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">窗户<code class="fe mr ms mt mu b">C:\Users\$USER</code></li></ul><p id="b6f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">带操作系统:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="d1ed" class="no ma iq mu b gy oe of l og oh">import os<br/>os.path.expanduser(‘~’)<br/># /Users/adam</span></pre><p id="1acc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用pathlib:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="7451" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>Path.home()<br/># /Users/adam</span></pre><h2 id="0d7d" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">获取当前工作目录</h2><p id="4fa5" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">带操作系统:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="ccca" class="no ma iq mu b gy oe of l og oh">import os<br/>os.getcwd()</span></pre><p id="92ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用pathlib:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="0237" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>Path.cwd()</span></pre><h2 id="0a09" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">使用文件名和后缀</h2><p id="8689" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">文件名包含后缀。</p><p id="f981" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过操作系统获得此功能需要使用<code class="fe mr ms mt mu b">basename</code>:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="ae4f" class="no ma iq mu b gy oe of l og oh">import os<br/>os.path.basename('/path/file.suffix')<br/># file.suffix</span></pre><p id="76a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过pathlib，我们可以在一个<code class="fe mr ms mt mu b">Path</code>对象上使用<code class="fe mr ms mt mu b">name</code>属性:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="13cd" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>Path('/path/file.suffix').name<br/># file.suffix</span></pre><p id="c8f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">词干不包括后缀。用操作系统获得这个需要使用<code class="fe mr ms mt mu b">basename</code>和<code class="fe mr ms mt mu b">splitext</code>:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="75c8" class="no ma iq mu b gy oe of l og oh">from os.path import basename, splitext<br/>splitext(basename('/path/file.suffix'))[0]<br/># file</span></pre><p id="6caa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过pathlib，我们可以在一个<code class="fe mr ms mt mu b">Path</code>对象上使用<code class="fe mr ms mt mu b">stem</code>属性:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="2e9c" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>Path('/path/file.suffix').stem<br/># file</span></pre><p id="3481" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">后缀是文件路径的最后一部分，通常表示文件类型。以<code class="fe mr ms mt mu b">os.path</code>为后缀:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="fcaa" class="no ma iq mu b gy oe of l og oh">import os<br/>os.path.splitext('/path/file.suffix')[-1]<br/># .suffix</span></pre><p id="669f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">pathlib将<code class="fe mr ms mt mu b">suffix</code>作为<code class="fe mr ms mt mu b">Path</code>对象的属性:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="f0ab" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>Path('/path/file.suffix').suffix<br/># .suffix</span></pre><h2 id="ff6b" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">摘要—单一路径</h2><p id="ac75" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我们的第一轮比赛结束了——胜者是pathlib！我们的评委喜欢的一些东西:</p><ul class=""><li id="d8cc" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">将数据和功能移动到单个<code class="fe mr ms mt mu b">Path</code>对象上</li><li id="9203" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">记住一些操作系统方法(比如<code class="fe mr ms mt mu b">os.path.expanduser</code>)是很困难的</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3738" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">第二轮——制造东西</h1><p id="1606" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我们的第二轮由制作产品时通常完成的任务组成，包括:</p><ul class=""><li id="ae2d" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">制作目录</li><li id="3abc" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">将数据保存到文本文件</li><li id="11aa" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">将数据追加到文本文件</li></ul><h2 id="d2c6" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">制作目录</h2><p id="8444" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">先用<code class="fe mr ms mt mu b">os</code>:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="fe56" class="no ma iq mu b gy oe of l og oh">import os<br/>path = os.path.join(os.path.expanduser('~'), 'python-file-paths')<br/>os.mkdir(path)</span></pre><p id="1c70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用pathlib:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="de06" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path.home() / 'python-file-paths'<br/>path.mkdir()</span></pre><p id="9e3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有时，我们希望创建一个比上一个文件夹更深的新文件夹。尝试这样做会引发一个错误(因为<code class="fe mr ms mt mu b">foo</code>还不存在):</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="60e0" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path.home() / 'python-file-paths' / 'foo' / 'bar'<br/>path.mkdir()<br/># FileNotFoundError</span></pre><p id="37ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过使用<code class="fe mr ms mt mu b">parents=True</code>来避免这种情况:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="156a" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path.home() / 'python-file-paths' / 'foo' / 'bar'<br/>path.mkdir(parents=True)</span></pre><p id="c8cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">错误的另一个原因是试图创建一个已经存在的目录:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="6725" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path.home() / 'python-file-paths' <br/>path.mkdir()<br/># FileExistsError</span></pre><p id="4512" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每当我们创建一个文件夹时，我们通常使用<code class="fe mr ms mt mu b">parents=True</code>和<code class="fe mr ms mt mu b">exist_ok=True</code>:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="f852" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path.home() / 'python-file-paths' / 'foo' / 'bar'<br/>path.mkdir(parents=True, exist_ok=True)</span></pre><p id="e1c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的例子都是关于从一个路径创建一个目录。有时我们也有一个带文件名的路径。</p><p id="5e64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有时我们实际上有一个完整的文件路径(包括文件夹和文件名)。如果我们在一个完整的文件路径上使用<code class="fe mr ms mt mu b">mkdir</code>,我们将最终创建一个与我们即将创建的文件同名的目录！</p><p id="acbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用<code class="fe mr ms mt mu b">Path.parent</code>来访问我们的文件所在的文件夹，并在该文件夹上调用<code class="fe mr ms mt mu b">.mkdir</code>:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="1aac" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path.home() / 'python-file-paths' / 'foo' / 'bar' / 'baz.file'<br/>path.parent.mkdir(parents=True, exist_ok=True)</span></pre><h2 id="3951" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">将数据写入文件</h2><p id="634a" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">假设我们有一个32个样本的数据集，我们想将每个样本保存在<code class="fe mr ms mt mu b">$HOME/python-file-paths/</code>中的一个文件中。</p><p id="c207" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用os，我们在<code class="fe mr ms mt mu b">os.mkdir</code>中缺少<code class="fe mr ms mt mu b">exist_ok</code>参数，这意味着我们需要在创建<code class="fe mr ms mt mu b">base</code>文件夹之前检查它是否存在:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a795" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用<code class="fe mr ms mt mu b">cat</code>打印出我们的第一个样本:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="76fc" class="no ma iq mu b gy oe of l og oh">$ cat ~/python-file-paths/sample_0.data<br/>[37.45401188 95.07143064 73.19939418 59.86584842]</span></pre><p id="c8fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后使用pathlib，我们可以在<code class="fe mr ms mt mu b">Path</code>对象上使用<code class="fe mr ms mt mu b">exist_ok=True</code>和<code class="fe mr ms mt mu b">write_text</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="d74f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">再次使用<code class="fe mr ms mt mu b">cat</code>打印出我们的第一个样本，由于我们的随机种子，是相同的:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="0343" class="no ma iq mu b gy oe of l og oh">$ cat ~/python-file-paths/sample_0.data<br/>[37.45401188 95.07143064 73.19939418 59.86584842]</span></pre><h2 id="02cb" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">将数据追加到文件中</h2><p id="12f2" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">上面的任务是写入许多文件:每个样本一个文件。其他时候，我们想追加到一个文件中，这样做的好处是我们所有的数据都存储在一个文件中。</p><p id="258d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些示例将文本追加到一个文件<code class="fe mr ms mt mu b">all_samples.data</code>中。首先是操作系统:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="43db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用path lib——注意，我们被迫使用上下文管理来传递一个<code class="fe mr ms mt mu b">a</code>的附加标志:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="3a37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们的数据存储在一个文件中(每行一行):</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="fdee" class="no ma iq mu b gy oe of l og oh">$ head -n 2 ~/python-file-paths/samples.data<br/>[37.45401188 95.07143064 73.19939418 59.86584842]<br/>[15.60186404 15.59945203  5.80836122 86.61761458]</span></pre><h2 id="f2c7" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">总结——制作物品</h2><p id="9bb2" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">丁！胜利者又是pathlib！这一轮评委喜欢的一些东西:</p><ul class=""><li id="468b" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated"><code class="fe mr ms mt mu b">Path.mkdir()</code>中的<code class="fe mr ms mt mu b">exist_ok</code>的参数避免了创建一个已经存在的目录的错误。</li><li id="b9a6" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><code class="fe mr ms mt mu b">Path.parents</code>属性允许轻松访问文件所在的文件夹。</li><li id="96f0" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">用<code class="fe mr ms mt mu b">Path.write_text</code>将数据写入文本文件</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="12ce" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">第三轮——阅读和发现</h1><p id="09ed" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我们的第三轮是关于使用已经存在的东西，例如:</p><ul class=""><li id="b759" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">读取文本文件</li><li id="5c8f" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">查找文件</li><li id="c4f1" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">查找目录</li></ul><h2 id="cf2c" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">从文本文件中读取</h2><p id="398a" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">让我们打开之前创建的一个文本文件。</p><p id="ee70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将使用操作系统打开它，这需要上下文管理来在打开后正确关闭文件:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="d2ad" class="no ma iq mu b gy oe of l og oh">from os.path import join, expanduser<br/>path = join(expanduser('~'), 'python-file-paths', 'samples.data')<br/>with open(path, 'r') as fi:<br/>    data = fi.read()</span></pre><p id="8296" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们将使用pathlib，在这里可以使用我们的<code class="fe mr ms mt mu b">Path</code>对象上的<code class="fe mr ms mt mu b">read_text()</code>方法打开、读取和关闭文件:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="8252" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path.home() / 'python-file-paths', 'samples.data')<br/>data = path.read_text()</span></pre><h2 id="06a0" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">递归查找许多文件</h2><p id="b2ab" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">有时我们想找到许多文件的路径。我们想要找到文件系统深处的路径，也就是递归地。</p><p id="e43a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了操作系统，我们可以使用<code class="fe mr ms mt mu b">os.walk</code>来做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="3756" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用pathlib，<code class="fe mr ms mt mu b">glob</code>最好:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="5d75" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path().home()<br/>paths = [p for p in path.glob('**/*.py') if p.is_file()]</span></pre><p id="d325" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mr ms mt mu b">glob</code>不会确定地返回路径顺序。如果您依赖订单，请务必在<code class="fe mr ms mt mu b">paths</code>上调用<code class="fe mr ms mt mu b">sorted</code>。</p><h2 id="60f5" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">查找所有目录</h2><p id="06f2" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我们经常需要某个路径下的目录列表。这里我们使用用户的主目录。我们不希望这是递归的。</p><p id="6991" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于<code class="fe mr ms mt mu b">os.path</code>,我们使用<code class="fe mr ms mt mu b">os.path.listdir()</code>迭代一个路径，用<code class="fe mr ms mt mu b">os.path.isdir()</code>检查路径是否是一个目录:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="475f" class="no ma iq mu b gy oe of l og oh">from os import listdir<br/>from os.path import expanduser, join, isdir<br/>path = expanduser('~')<br/>dirs = [join(path, p) for p in listdir(path) if isdir(join(path, p))]</span></pre><p id="3ff4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于pathlib，我们使用<code class="fe mr ms mt mu b">path.iterdir</code>和<code class="fe mr ms mt mu b">path.is_dir</code>。两种方法都在<code class="fe mr ms mt mu b">Path</code>对象上调用:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="d32c" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path().home()<br/>dirs = [p.name for p in path.iterdir() if p.is_dir()]</span></pre><h2 id="1097" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">递归查找所有目录</h2><p id="386e" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">有时，我们希望超越单一路径，递归地搜索文件夹。</p><p id="ab46" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用<code class="fe mr ms mt mu b">os.walk</code>来做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="25d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于pathlib，最好使用<code class="fe mr ms mt mu b">path.glob</code>来完成:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="be62" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path().home()<br/>paths = [p for p in path.glob('**/*') if p.is_dir()]</span></pre><h2 id="40be" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">摘要—阅读和查找</h2><p id="2bfa" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我们的第三回合结束了——胜者是pathlib！我们的评委喜欢的一些东西:</p><ul class=""><li id="8a16" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">用<code class="fe mr ms mt mu b">Path.read_text</code>读取文本文件</li><li id="227e" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">能够使用<code class="fe mr ms mt mu b">Path.is_dir()</code>检查路径是目录还是使用<code class="fe mr ms mt mu b">Path.is_file()</code>检查文件夹</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="372a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">最后一轮——移除物品</h1><p id="d150" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我们的最后一轮是移除物品:</p><ul class=""><li id="fe8a" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">删除目录</li><li id="bfa8" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">删除文件</li></ul><h2 id="8cd6" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">删除目录</h2><p id="c4e6" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">最好的方法是使用<code class="fe mr ms mt mu b">shutil.rmtree</code>，它将删除目录，即使它不是空的。</p><p id="700d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了创建文件路径之外，os和pathlib之间没有真正的区别。以下示例使用pathlib:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="032b" class="no ma iq mu b gy oe of l og oh">from shutil import rmtree<br/>from pathlib import Path<br/>path = Path.home() / 'python-file-paths'<br/>rmtree(path)</span></pre><p id="599d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这通常是您在删除目录时想要的行为:即使不是空的也要删除。</p><h2 id="0c47" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">删除文件</h2><p id="6db0" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">有时，当我们知道路径时，我们希望删除特定的文件。</p><p id="59bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过操作系统做到这一点:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="02a6" class="no ma iq mu b gy oe of l og oh">import os<br/>from os.path import expanduser, isdir, join<br/>path = join(expanduser('~'), 'python-file-paths', 'data.txt')<br/>if os.path.exists(path):<br/>    os.remove(path)</span></pre><p id="5a14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用pathlib:</p><pre class="kg kh ki kj gt oa mu ob oc aw od bi"><span id="3e85" class="no ma iq mu b gy oe of l og oh">from pathlib import Path<br/>path = Path.home() / 'python-file-paths' / 'data.txt'<br/>path.unlink(missing_ok=True)</span></pre><p id="4697" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于这项任务非常复杂，下面给出了一个摘要:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/d31c8749bcc00d01e81e1f5b96b418c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVyP3M0glla_Khyg7qlnmw.png"/></div></div></figure><h2 id="7a63" class="no ma iq bd mb np nq dn mf nr ns dp mj le nt nu ml li nv nw mn lm nx ny mp nz bi translated">摘要—移除物品</h2><p id="0cd4" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我们的最后一轮比赛结束了——平局！这是最后一项任务，由于两种方法的复杂性，需要使用额外的库<code class="fe mr ms mt mu b">shutil</code>。</p><p id="20e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我们的评委来说，这是一个公平的结果——也许是对os的一点同情，OS是一个勇敢的竞争对手，但被它的继任者远远超过。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c2dc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><p id="f9aa" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">决斗已经结束，最终结果如下:</p><ul class=""><li id="1ce1" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">第一轮—单一路径—路径库</li><li id="77d1" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">第二轮——制造东西——path lib</li><li id="a876" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">第三轮—阅读和寻找—路径库</li><li id="e59b" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">第四轮—移除物品—抽签</li></ul><p id="01aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">pathlib名列前茅是因为:</p><ul class=""><li id="f385" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">将大多数功能转移到一个<code class="fe mr ms mt mu b">Path</code>类上</li><li id="0717" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><code class="fe mr ms mt mu b">Path.mkdir()</code>上的<code class="fe mr ms mt mu b">exist_ok</code>自变量</li><li id="8e8c" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">在读写文本文件时避免使用上下文管理</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="88a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p><p id="a575" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ol">最初发表于</em><a class="ae lr" href="https://www.datasciencesouth.com/blog/python-file-system" rel="noopener ugc nofollow" target="_blank"><em class="ol">https://www.datasciencesouth.com</em></a><em class="ol">。</em></p></div></div>    
</body>
</html>