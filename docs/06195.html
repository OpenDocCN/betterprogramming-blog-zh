<html>
<head>
<title>Firebase Cloud Functions: Git and a GitHub GraphQL API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase云函数:Git和GitHub GraphQL API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/firebase-cloud-functions-git-github-graphql-api-5c8577591cb1?source=collection_archive---------17-----------------------#2020-09-08">https://betterprogramming.pub/firebase-cloud-functions-git-github-graphql-api-5c8577591cb1?source=collection_archive---------17-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8c1c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Git命令和GitHub GraphQL API在Firebase Cloud函数中创建一个pull请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01e18ac86454729719daa2ac1a6f21f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLLQh8vkxSkbYBCoXjU95A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">背景照片由<a class="ae ky" href="https://unsplash.com/@goumbik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢卡斯·布拉塞克</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最近在<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>发布了一个令人兴奋的新特性。</p><p id="a181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了能够将您的演示作为渐进式网络应用部署到网上，我们的网络开源编辑器现在还可以将您的源代码推送到<a class="ae ky" href="https://github.com" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="dccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新函数运行在Firebase 的<a class="ae ky" href="https://firebase.google.com/docs/functions/" rel="noopener ugc nofollow" target="_blank">云函数上。因为我们喜欢分享我们的发现，这里是我们在开发这种集成时学到的关键东西。</a></p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="18bd" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">访问令牌</h1><p id="8c2b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">要与GitHub交互，我们需要一个令牌。</p><h2 id="e6ed" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">个人代币</h2><p id="d796" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">如果你想用你的账户与GitHub互动，你可以使用一个<a class="ae ky" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank">个人访问令牌</a>。创建后，您可以在我们的Firebase函数配置中设置它。这样做，它将从你的代码混淆。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2cac" class="nb mf it no b gy ns nt l nu nv">#!/bin/sh<strong class="no iu"><br/></strong>firebase functions:config:set github.token="4a686......."</span></pre><h2 id="b180" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">Firebase身份验证和GitHub令牌</h2><p id="b015" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">如果你对与GitHub交互感兴趣，看看你的用户的行为，你可以使用<a class="ae ky" href="https://github.com/firebase/FirebaseUI-Web" rel="noopener ugc nofollow" target="_blank"> Firebase UI </a>和<a class="ae ky" href="https://firebase.google.com/docs/auth/" rel="noopener ugc nofollow" target="_blank"> Firebase认证</a>。</p><p id="2cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据我所知，采用这样的组合，不幸的是无法在Firebase云函数中获得用户的GitHub令牌。我试图钩住认证<a class="ae ky" href="https://firebase.google.com/docs/functions/auth-events" rel="noopener ugc nofollow" target="_blank">事件</a>，但是在被触发的对象中没有找到任何相关信息。</p><p id="a90b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可能遗漏了一些东西——在这种情况下，请尽快让我知道——但如果没有，要获得这样的信息，您必须通过Firebase UI配置的<code class="fe nw nx ny no b">signInSuccessWithAuthResult</code>回调来找到它。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="070d" class="nb mf it no b gy ns nt l nu nv">callbacks: {<br/>  signInSuccessWithAuthResult: <br/>    (authResult: firebase.auth.UserCredential, _redirectUrl) =&gt; {</span><span id="8996" class="nb mf it no b gy nz nt l nu nv">    const token: string =<br/>      (userCred.credential as <br/>               firebase.auth.OAuthCredential).accessToken;<br/><br/>    return true;<br/>  },<br/>},</span></pre><p id="6f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>我提出了一个问题，询问如何使用TypeScript访问令牌，而到<code class="fe nw nx ny no b">OAuthCredential</code>的转换是作为<a class="ae ky" href="https://github.com/firebase/firebaseui-web/issues/743" rel="noopener ugc nofollow" target="_blank">答案</a>提供的。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="4d46" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">文件系统</h1><p id="1f0f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在继续之前，你可能会问自己，我们将如何能够在云中执行Git命令？我实际上也在问自己同样的问题，结果是云函数可以访问他们的<a class="ae ky" href="https://cloud.google.com/functions/docs/concepts/exec#file_system" rel="noopener ugc nofollow" target="_blank">文件系统</a>的一个临时文件夹。</p><blockquote class="oa ob oc"><p id="ba96" class="kz la od lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated">“文件系统唯一可写的部分是<code class="fe nw nx ny no b">/tmp</code>目录，您可以用它来存储函数实例中的临时文件。这是一个称为“tmpfs”卷的本地磁盘装载点，写入卷的数据存储在内存中。请注意，它将消耗为该函数提供的内存资源。— <a class="ae ky" href="https://code.luasoftware.com/tutorials/google-cloud-functions/cloud-functions-read-write-temp-files/" rel="noopener ugc nofollow" target="_blank">德斯蒙德·卢阿</a></p></blockquote><p id="6cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，临时目录不能跨函数共享。例如，这意味着您不能使用这样的文件夹来共享数据。</p><p id="0246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nw nx ny no b">tmp</code>订单还没有硬编码。相反，可以使用<a class="ae ky" href="https://nodejs.org/api/os.html" rel="noopener ugc nofollow" target="_blank"> Node.js OS模块</a>来检索临时文件夹。不管怎么说，万一将来发生变化，使用它可能会更方便——你永远不知道。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="a824" class="nb mf it no b gy ns nt l nu nv">import * as os from 'os';</span><span id="3463" class="nb mf it no b gy nz nt l nu nv">console.log(os.tmpdir()); // -&gt; /tmp</span></pre><p id="9301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过与<code class="fe nw nx ny no b"><a class="ae ky" href="https://nodejs.org/api/path.html" rel="noopener ugc nofollow" target="_blank">path</a></code> <a class="ae ky" href="https://nodejs.org/api/path.html" rel="noopener ugc nofollow" target="_blank">模块</a>一起使用，我们甚至可以创建一个简短的实用函数来本地解析文件的路径。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2758" class="nb mf it no b gy ns nt l nu nv">import * as path from 'path';<br/>import * as os from 'os';</span><span id="b6ba" class="nb mf it no b gy nz nt l nu nv">export function getFilePath(...files: string[]): string {<br/>  return path.join(os.tmpdir(), ...files);<br/>}</span><span id="97b3" class="nb mf it no b gy nz nt l nu nv">console.log(getFilePath('yo', 'david.txt'); // -&gt; /tmp/yo/david.txt</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3ad3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">Git命令</h1><p id="f508" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">为了克隆一个repo或者一般来说执行任何Git命令(比如<code class="fe nw nx ny no b">commit</code>、<code class="fe nw nx ny no b">pull</code>或者<code class="fe nw nx ny no b">push</code>)，我建议使用<a class="ae ky" href="https://github.com/steveukx" rel="noopener ugc nofollow" target="_blank">史蒂夫·金</a>开发的Node.js的<a class="ae ky" href="https://www.npmjs.com/package/simple-git" rel="noopener ugc nofollow" target="_blank">简单Git </a>接口(在<a class="ae ky" href="https://www.npmjs.com/package/simple-git" rel="noopener ugc nofollow" target="_blank"> npm </a>上每周150万次下载)。它确实减轻了所有的工作。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7895" class="nb mf it no b gy ns nt l nu nv">npm i simple-git --save</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="53e1" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">克隆</h2><p id="fe36" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">具体地，克隆功能可以如下实现:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7443" class="nb mf it no b gy ns nt l nu nv">import * as path from 'path';<br/>import * as os from 'os';</span><span id="df44" class="nb mf it no b gy nz nt l nu nv">import simpleGit, {SimpleGit} from 'simple-git';</span><span id="9fd7" class="nb mf it no b gy nz nt l nu nv">export async function clone(repoUrl: string, repoName: string) {<br/>  const localPath: string = path.join(os.tmpdir(), repoName);</span><span id="8ff3" class="nb mf it no b gy nz nt l nu nv">  await deleteDir(localPath);<br/>  <br/>  const git: SimpleGit = simpleGit();<br/><br/>  await git.clone(repoUrl, localPath);<br/>}</span><span id="b33d" class="nb mf it no b gy nz nt l nu nv">// Demo:</span><span id="135b" class="nb mf it no b gy nz nt l nu nv">(async () =&gt; {<br/> await clone('<a class="ae ky" href="https://github.com/deckgo/deckdeckgo/" rel="noopener ugc nofollow" target="_blank">https://github.com/deckgo/deckdeckgo/</a>', 'deckdeckgo'); <br/>})();</span></pre><p id="887f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使临时文件夹很可能是空的，也可以先删除工作子目录。这就是为什么我在上面的函数中调用<code class="fe nw nx ny no b">deleteDir</code>。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="4d30" class="nb mf it no b gy ns nt l nu nv">import * as rimraf from 'rimraf';</span><span id="4a18" class="nb mf it no b gy nz nt l nu nv">export function deleteDir(localPath: string): Promise&lt;void&gt; {<br/>  return new Promise&lt;void&gt;((resolve) =&gt; {<br/>    rimraf(localPath, () =&gt; {<br/>      resolve();<br/>    });<br/>  });<br/>}</span></pre><p id="25db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我使用的是来自<a class="ae ky" href="https://twitter.com/izs" rel="noopener ugc nofollow" target="_blank"> Isaac Z. Schlueter </a>的<code class="fe nw nx ny no b"><a class="ae ky" href="https://github.com/isaacs/rimraf" rel="noopener ugc nofollow" target="_blank">rimraf</a></code>(在<a class="ae ky" href="https://www.npmjs.com/package/rimraf" rel="noopener ugc nofollow" target="_blank"> npm </a>上的3700万周下载量)。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f4ed" class="nb mf it no b gy ns nt l nu nv">npm i rimraf --save &amp;&amp; npm i @types/rimraf --save-dev</span></pre><h2 id="215e" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">推</h2><p id="987f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">Git命令的另一个有趣的例子是<code class="fe nw nx ny no b">push</code>请求，因为我们必须使用令牌来认证请求。</p><p id="780a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在搜索了使用令牌的解决方案之后，我特别花了一些时间阅读这个<a class="ae ky" href="https://stackoverflow.com/questions/18935539/authenticate-with-github-using-a-token" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>问答。我得出的结论是，即使我们在函数中执行交互，避免暴露令牌的最佳解决方案是在Git URI中使用它。</p><p id="dd72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>令牌暴露在潜在的错误消息中——这就是为什么我认为适当地捕捉这些消息也是好的。</p><p id="3ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了令牌，我们可能需要提供GitHub账户的<code class="fe nw nx ny no b">username</code>(例如<a class="ae ky" href="https://github.com/peterpeterparker" rel="noopener ugc nofollow" target="_blank"> peterpeterparker </a>)和<code class="fe nw nx ny no b">email</code>。这些信息也可以通过我们的功能配置来管理。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="ce18" class="nb mf it no b gy ns nt l nu nv">import * as functions from 'firebase-functions';</span><span id="3be4" class="nb mf it no b gy nz nt l nu nv">import * as path from 'path';<br/>import * as os from 'os';</span><span id="f557" class="nb mf it no b gy nz nt l nu nv">import simpleGit, {SimpleGit} from 'simple-git';</span><span id="926d" class="nb mf it no b gy nz nt l nu nv">export async function push(project: string,<br/>                           branch: string) {<br/>  try {<br/>    const localPath: string = path.join(os.tmpdir(), repoName);</span><span id="2b69" class="nb mf it no b gy nz nt l nu nv">    // Git needs to know where is has to run, that's why we pass<br/>    // the pass to the constructor of simple-git</span><span id="5cd8" class="nb mf it no b gy nz nt l nu nv">    const git: SimpleGit = getSimpleGit(localPath);</span><span id="6631" class="nb mf it no b gy nz nt l nu nv">    // Configure Git with the username and email</span><span id="8d7c" class="nb mf it no b gy nz nt l nu nv">    const username: string = functions.config().github.username;<br/>    const email: string = functions.config().github.email;</span><span id="6ff6" class="nb mf it no b gy nz nt l nu nv">    await git.addConfig('user.name', username);<br/>    await git.addConfig('user.email', email);</span><span id="fa7a" class="nb mf it no b gy nz nt l nu nv">    // Finally Git push</span><span id="1fef" class="nb mf it no b gy nz nt l nu nv">    const token: string = functions.config().github.token;</span><span id="8c4c" class="nb mf it no b gy nz nt l nu nv">    await git.push(`https://${username}:${token}@github.com/${username}/${project}.git`, branch);<br/>  } catch (err) {<br/>    throw new Error(`Error pushing.`);<br/>  }<br/>}</span><span id="3127" class="nb mf it no b gy nz nt l nu nv">// Demo:</span><span id="dbec" class="nb mf it no b gy nz nt l nu nv">(async () =&gt; {<br/> await push('deckdeckgo', 'my-branch'); <br/>})();</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="de81" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">GitHub GraphQL API</h1><p id="aa41" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">GitHub API的最新版本(v4)可以用于GraphQL查询，这取决于您的观点。它的<a class="ae ky" href="https://docs.github.com/en/graphql" rel="noopener ugc nofollow" target="_blank">文档</a>使得搜索信息变得相对容易，但是<a class="ae ky" href="https://developer.github.com/v4/explorer/" rel="noopener ugc nofollow" target="_blank">浏览器</a>和它的自动完成功能可能更便于快速灵活地编写查询。</p><h2 id="ef08" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">询问</h2><p id="e6f0" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我没有使用任何GraphQL客户端(例如，<a class="ae ky" href="https://github.com/apollographql/apollo-client" rel="noopener ugc nofollow" target="_blank"> Apollo </a>)来执行查询。相反，我开发了一个实用程序来执行HTTPS请求。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="369c" class="nb mf it no b gy ns nt l nu nv">import fetch, {Response} from 'node-fetch';</span><span id="f02b" class="nb mf it no b gy nz nt l nu nv">async function queryGitHub(githubToken: string, <br/>                           query: string): Promise&lt;Response&gt; {<br/>  const githubApiV4: string = 'https://api.github.com/graphql';<br/><br/>  const rawResponse: Response = await fetch(`${githubApiV4}`, {<br/>    method: 'POST',<br/>    headers: {<br/>      Accept: 'application/json',<br/>      'Content-Type': 'application/json',<br/>      Authorization: `token ${githubToken}`,<br/>    },<br/>    body: JSON.stringify({query}),<br/>  });<br/><br/>  if (!rawResponse || !rawResponse.ok) {<br/>    throw new Error('Cannot perform GitHub query.');<br/>  }<br/><br/>  return rawResponse;<br/>}</span></pre><p id="f81c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe nw nx ny no b">fetch</code>在Node.js中不是本地可用的，所以我使用了<a class="ae ky" href="https://github.com/node-fetch/node-fetch" rel="noopener ugc nofollow" target="_blank">节点获取</a>(在<a class="ae ky" href="https://www.npmjs.com/package/node-fetch" rel="noopener ugc nofollow" target="_blank"> npm </a>上每周1600万次下载)。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="c01e" class="nb mf it no b gy ns nt l nu nv">npm i node-fetch --save &amp;&amp; npm i @types/node-fetch --save-dev</span></pre><h2 id="fb6a" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">查询:用户信息</h2><p id="b294" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">下面是一个相对基本的查询示例。在这个函数中，我们尝试检索与我们用来认证请求的令牌相对应的GitHub <code class="fe nw nx ny no b">login</code>(用户名)和<code class="fe nw nx ny no b">id</code>，分别是当前认证用户的信息。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1f55" class="nb mf it no b gy ns nt l nu nv">export interface GitHubUser {<br/>  id: string;<br/>  login: string;<br/>}</span><span id="534b" class="nb mf it no b gy nz nt l nu nv">export function getUser(githubToken: string): Promise&lt;GitHubUser&gt; {<br/>  return new Promise&lt;GitHubUser&gt;(async (resolve, reject) =&gt; {<br/>    try {<br/>      const query = `<br/>        query {<br/>          viewer {<br/>            id,<br/>            login<br/>          }<br/>        }<br/>      `;<br/><br/>      const response: Response = <br/>            await queryGitHub(githubToken, query);<br/><br/>      const result = await response.json();<br/><br/>      resolve(result.data.viewer);<br/>    } catch (err) {<br/>      reject(err);<br/>    }<br/>  });<br/>}</span><span id="f01c" class="nb mf it no b gy nz nt l nu nv">// Demo:</span><span id="6790" class="nb mf it no b gy nz nt l nu nv">(async () =&gt; {<br/> const token: string = functions.config().github.token;<br/> <br/> const user = await getUser(token); </span><span id="55d4" class="nb mf it no b gy nz nt l nu nv"> console.log(user); // -&gt; {login: 'peterpeterparker', id: '123'}<br/>})();</span></pre><h2 id="fb47" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">变异:拉请求</h2><p id="d1a6" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">创建一个拉请求不是GraphQL查询，而是一个<a class="ae ky" href="https://docs.github.com/en/graphql/reference/mutations#createpullrequest" rel="noopener ugc nofollow" target="_blank">变异</a>。与前面的查询相比，它需要更多的信息，但是它背后的逻辑是相同的:编写一个GraphQL查询/变异，通过HTTPS请求发送它，然后获得结果。</p><p id="5932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，为了创建一个PR，突变将需要一个<code class="fe nw nx ny no b">repositoryId</code>。这个信息可以在另一个GraphQL查询的帮助下找到——例如，在请求<a class="ae ky" href="https://docs.github.com/en/graphql/reference/queries#repository" rel="noopener ugc nofollow" target="_blank">存储库</a>信息时提供。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="537f" class="nb mf it no b gy ns nt l nu nv">export function createPR(githubToken: string,<br/>                         repositoryId: string,<br/>                         branch: string): Promise&lt;void&gt; {<br/>  return new Promise&lt;void&gt;(async (resolve, reject) =&gt; {<br/>    try {<br/>      const title: string = 'feat: my title';<br/>      const body: string = `# The Pull Request body.<br/><br/>It supports *Markdown*.`;</span><span id="7c91" class="nb mf it no b gy nz nt l nu nv">     // We want to provide a PR from a branch to master</span><span id="ea22" class="nb mf it no b gy nz nt l nu nv">     const query = `<br/>        mutation CreatePullRequest {<br/>          createPullRequest(input:{baseRefName:"master",body:"${body}",headRefName:"${branch}",repositoryId:"${repositoryId}",title:"${title}"}) {<br/>            pullRequest {<br/>              id<br/>            }<br/>          }<br/>        }<br/>      `;<br/><br/>      const response: Response = <br/>            await queryGitHub(githubToken, query);<br/><br/>      const result = await response.json();<br/><br/>      if (!result || !result.data || <br/>          !result.data.createPullRequest || result.errors) {<br/>        resolve(undefined);<br/>        return;<br/>      }<br/><br/>      resolve();<br/>    } catch (err) {<br/>      reject(err);<br/>    }<br/>  });<br/>}</span><span id="cbce" class="nb mf it no b gy nz nt l nu nv">// Demo:</span><span id="a212" class="nb mf it no b gy nz nt l nu nv">(async () =&gt; {<br/> const token: string = functions.config().github.token;<br/> <br/> await createPR(token, '6789', 'my-branch');<br/>})();</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="f128" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">摘要</h1><p id="05c2" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在开发这个特性的过程中，我学到了很多新东西，我希望在这篇文章的帮助下，我能够分享我的主要发现。</p><p id="aaa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们是开源的——你可以随时查看我们的<a class="ae ky" href="https://github.com/deckgo/deckdeckgo/" rel="noopener ugc nofollow" target="_blank"> repo </a>的源代码，或者为我们的项目做出贡献。</p><p id="9ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也非常欢迎你在下一次演讲中尝试一下。</p><p id="c702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也期待着检查和尝试包含您的幻灯片源代码的GitHub repos。</p><p id="fb63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到无限和更远的地方！</p></div></div>    
</body>
</html>