<html>
<head>
<title>How to Write a Redux Like State Management Store Using RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用RxJS编写一个类似Redux的状态管理存储</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-a-redux-like-state-management-store-using-rxjs-33b6095c5a7e?source=collection_archive---------4-----------------------#2021-09-22">https://betterprogramming.pub/how-to-write-a-redux-like-state-management-store-using-rxjs-33b6095c5a7e?source=collection_archive---------4-----------------------#2021-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="427c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">也许你不需要另一个包？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/033ca5157c21bb50c505ab37a2979dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kg60FuZwoWxvAlt8_C05wA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@karlahrnndz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡拉·埃尔南德斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="87f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用Vue多年后，最近我开始使用Angular 11，并被介绍给RxJS和NgRx。</p><p id="c1a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我了解了RxJS的基础知识并意识到它的强大时，我开始想，也许我们不需要安装另一个库来管理状态。</p><p id="3c60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我决定冒险写一个小的状态管理模块来代替我的项目中的NgRx。我提出的约束是基于使它类似于Redux，并在下面列出:</p><ul class=""><li id="d674" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用打字稿写的</li><li id="b083" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">基于缩减器函数更新状态</li><li id="805c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">有一个调度方法来更新状态</li><li id="3573" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">分派方法将接收动作作为输入</li><li id="2c96" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">动作将由两个键组成:类型和有效载荷</li><li id="fcc6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Action payload将是可选的，这样我们就可以调度除了实际状态之外不需要外部信息的操作</li><li id="e04d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">subscribe</code>让我对状态变化做出反应的方法</li><li id="a8b1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">select</code>让我对特定的状态键变化做出反应的方法</li><li id="57f0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">dispatchAsync</code>异步更新状态的方法</li></ul><p id="c859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个约束显然不是受Redux本身的启发，但是众所周知，我们需要异步操作。在Redux中，我们通过使用像<code class="fe mj mk ml mm b">redux-thunk</code>或<code class="fe mj mk ml mm b">redux-saga</code>这样的插件来做到这一点，所以我决定尝试实现类似的东西。</p><p id="0c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义好一切之后，我们就可以开始编写代码了。</p><p id="ebc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将开始用名称<code class="fe mj mk ml mm b">RxJsStore</code>定义我们的类。因为我们仍然不知道我们将要管理的状态的类型，我们将使用<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics" rel="noopener ugc nofollow" target="_blank">泛型</a>，这样用户可以在类实例创建的时候通知状态的类型。我们在TypeScript中通过在类名后添加一个<code class="fe mj mk ml mm b">&lt;T&gt;</code>来实现这一点。</p><p id="009e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们已经可以创建私有变量来存储我们的缩减器和状态。我选择将状态设为私有，这样就不能从类外部直接更改它，只有类方法能够做到这一点。</p><p id="ac5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在RxJS中，我发现可以用来管理状态的三种主要类型:<code class="fe mj mk ml mm b"><a class="ae ky" href="https://rxjs.dev/guide/observable" rel="noopener ugc nofollow" target="_blank">Observable</a></code>、<code class="fe mj mk ml mm b"><a class="ae ky" href="https://rxjs.dev/api/index/class/Subject" rel="noopener ugc nofollow" target="_blank">Subject</a></code>和<code class="fe mj mk ml mm b"><a class="ae ky" href="https://rxjs.dev/api/index/class/BehaviorSubject" rel="noopener ugc nofollow" target="_blank">BehaviorSubject</a></code>。在这种情况下，我更喜欢使用<code class="fe mj mk ml mm b">BehaviorSubject</code>,因为我们可以随时获得最后发出的值。<br/> <br/>带<code class="fe mj mk ml mm b">Observable</code>和<code class="fe mj mk ml mm b">Subject</code>发射值仅在发射时刻通过subscribe方法可用，这可能是个问题。</p><p id="ecac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">reducer类型会稍微复杂一点，尤其是你不太懂TypeScript(像我一样)。但是本质上reducer是一个函数，它接收两个参数，当前状态和动作(类型和有效负载)，并返回更新后的状态。</p><p id="c482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在类型描述中使用括号来告诉TypeScript哪个是函数参数(以及它们的类型)以及一个指向函数响应类型的箭头。这就像一个带有类型的箭头函数。</p><p id="9ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在类构造函数中，我们将收到两个类似Redux的参数:</p><ul class=""><li id="742a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将更新状态的减速器函数</li><li id="bf18" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">初始状态</li></ul><p id="5795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还必须定义<code class="fe mj mk ml mm b">Action</code>接口，以便减速器类型定义是正确的。</p><p id="cf19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们从这个开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="def6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以构建我们的订阅、调度和选择。subscribe方法是最简单的方法，因为RxJS的<code class="fe mj mk ml mm b">BehaviorSubject</code>已经实现了它。我们所要做的就是接收回调函数并订阅私有状态。回调函数将接收当前状态值，并且不返回任何内容(void)。该符号与我们用来定义减速器类型的符号非常相似。返回类型<code class="fe mj mk ml mm b">Subscription</code>由RxJS提供。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="50e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dispatch方法将接收动作，将当前状态和动作应用到reducer，并用结果更新状态。为了更新一个<code class="fe mj mk ml mm b">BehaviorSubject</code>的值，我们需要使用它的<code class="fe mj mk ml mm b">next</code>方法。</p><p id="85ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道我可以用一行代码来完成，但是，我选择创建常量来使它更具可读性。另一点是，我必须将它声明为一个箭头函数，这样对<code class="fe mj mk ml mm b">this</code>的引用就不会丢失。这是必要的，因为该方法将由<code class="fe mj mk ml mm b">asyncDispatch</code>调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="f616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是<code class="fe mj mk ml mm b">select</code>方法——我理解中最难的一种。</p><p id="8b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法使得监听特定的状态键变化成为可能。这样做，回调函数就不会被不必要的调用。但是RxJS足够强大，可以为我们提供工作所需的工具。</p><p id="8d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，该方法将返回一个用户可以订阅并对变化做出反应的可观察对象。为了使这个<code class="fe mj mk ml mm b">Observable</code>仅在所选键的值改变时发出新值，我们必须使用多个RxJS操作符。</p><p id="af86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们使用了一个特殊的操作符<code class="fe mj mk ml mm b"><a class="ae ky" href="https://rxjs.dev/api/index/function/pipe" rel="noopener ugc nofollow" target="_blank">pipe</a></code>。它可以接收任意数量的参数，每个参数都是另一个操作符，它将按顺序应用它们。</p><p id="ba79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道内的第一个操作员将是<code class="fe mj mk ml mm b"><a class="ae ky" href="https://rxjs.dev/api/operators/distinctUntilKeyChanged" rel="noopener ugc nofollow" target="_blank">distinctUntilKeyChanged</a></code>。它接收代表我们将观察其变化的键的字符串，并且将阻止<code class="fe mj mk ml mm b">Observable</code>发出新的值，除非键值发生变化。第二个是<code class="fe mj mk ml mm b"><a class="ae ky" href="https://rxjs.dev/api/operators/pluck" rel="noopener ugc nofollow" target="_blank">pluck</a></code>。它接收一个密钥，并返回它在状态中的当前值。</p><p id="2615" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，最棘手的部分是定义参数类型和返回值。我希望参数是一个字符串，并根据状态键自动进行验证。并且返回值与状态键的类型相同。为了实现这一点，我们将利用TypeScript <code class="fe mj mk ml mm b"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html" rel="noopener ugc nofollow" target="_blank">keyof</a></code>和<code class="fe mj mk ml mm b">extends</code>。</p><p id="5b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们创建一个新的<code class="fe mj mk ml mm b">type(K)</code>来扩展包含状态<code class="fe mj mk ml mm b">(T)</code>键的枚举。因此，在参数中，我们将接收类型为<code class="fe mj mk ml mm b">K</code>的键，并返回状态(<code class="fe mj mk ml mm b">T</code>)键(<code class="fe mj mk ml mm b">K</code>)的<code class="fe mj mk ml mm b">Observable</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="be0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是最后一部分，即<code class="fe mj mk ml mm b">asyncDispatch</code>。为了实现这个功能，我们将接收动作类型、一个字符串和async runner方法。然后，我们将使用await来等待运行程序执行。之后，我们将发送动作，将收到的类型和runner返回值作为有效负载。够简单吗？我想。</p><p id="4717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于类型，参数将是一个字符串——动作名——和一个异步函数runner。运行器将接收当前状态值作为参数(因此，如果需要，可以根据状态值执行不同的操作)，并将返回一个<code class="fe mj mk ml mm b">Promise</code>。</p><p id="d74d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使方法类型更安全，我使用了泛型来接收runner返回类型<code class="fe mj mk ml mm b">R</code>。返回类型将是Promise，因为我们使用的是void (nothing)类型的async-await。我无法描述返回类型，但是因为我们使用的是TypeScript，所以我更愿意这样做，即使它毫无用处。</p><p id="8989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了不丢失对类的引用，我必须将它声明为一个箭头函数。我试图在构造函数中手动进行绑定，但是没有成功。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a9de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解释完所有部分，编写好所有需要从RxJS导入的内容，我们的类将看起来像下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="bba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试它，我写了一个简单的代码。<code class="fe mj mk ml mm b">state</code>有两把钥匙:<code class="fe mj mk ml mm b">counter</code>和<code class="fe mj mk ml mm b">name</code>。减速器由三种型号组成，<code class="fe mj mk ml mm b">INCREMENT</code>、<code class="fe mj mk ml mm b">DECREMENT</code>(计数器)和<code class="fe mj mk ml mm b">CHANGE_NAME</code>。这三者都依赖于有效载荷来运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用了一个延迟5秒的<code class="fe mj mk ml mm b">asyncDispatch</code>,因此我们可以注意到，虽然这是我们调用的第一个分派，但它只在所有其他分派完成后运行。由于承诺解析为5，计数器最终将被更新回零。</p><p id="0630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以注意到，select方法按预期工作。我注意到的一个缺点是<code class="fe mj mk ml mm b">BehaviorSubject</code>在创建时发出一个值，所以我们得到的不是4而是6，但我认为这很好。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="513d" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="0bf0" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">源代码可以在我的<a class="ae ky" href="https://github.com/n0n3br/RxJsStore" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得，并作为<a class="ae ky" href="https://www.npmjs.com/package/@n0n3br/rxjs-store" rel="noopener ugc nofollow" target="_blank"> npm包</a>提供。希望你能从这篇文章中学到一些有用的东西。感谢阅读。</p></div></div>    
</body>
</html>