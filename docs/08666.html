<html>
<head>
<title>Exploring Structural Pattern Matching in Python 3.10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Python 3.10中的结构模式匹配</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-structural-pattern-matching-in-python-3-10-507e33a28a85?source=collection_archive---------6-----------------------#2021-05-27">https://betterprogramming.pub/exploring-structural-pattern-matching-in-python-3-10-507e33a28a85?source=collection_archive---------6-----------------------#2021-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cd00" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">期待已久的switch-case语句终于来了！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b8f4ab0af397de18e00df794ef47323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aUM5eI66D1WxBie_.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@scottwebb?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">斯科特·韦伯</a>从<a class="ae ky" href="https://www.pexels.com/photo/purple-and-blue-abstract-wallpaper-430207/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄。</p></figure><p id="949d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python是一种多用途语言，深受数据科学家和全栈工程师的喜爱。由于其语法上的甜蜜和哲理，它促进了代码的清晰和简洁。在本文中，我将解释结构化模式匹配——最受期待的Python特性——是如何工作的。</p><p id="b480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注:Python 3.10中首次引入了结构化模式匹配(PEP 634)。目前处于测试阶段，截止到2021年5月27日可以从</em> <a class="ae ky" href="https://www.python.org/download/pre-releases/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Python的网站</em> </a> <em class="lv">获得。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1d89" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是结构模式匹配？</h1><p id="c5c4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最明显的类比是来自其他语言的<code class="fe na nb nc nd b">switch-case</code>操作符，比如Java或C#。它允许您基于输入数据上的断言执行不同的操作。换句话说，它是多个<code class="fe na nb nc nd b">if-else</code>语句之上的语法糖。下面是在Java中如何使用<code class="fe na nb nc nd b">switch</code>语句:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e67a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python 3.10之前，用Python重写上述代码的唯一方法是一堆<code class="fe na nb nc nd b">if</code>语句:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3fa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来没那么糟糕，但是随着案件的增长和变得更加复杂，这种结构将是无法忍受的。Python开发人员发现了这一点，并为Python 3.10实现了一个新特性。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="30f5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">如何使用结构模式匹配</h1><p id="d7ed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">要应用结构模式匹配，您需要使用两个新的关键字:<code class="fe na nb nc nd b">match</code>和<code class="fe na nb nc nd b">case</code>。如果用Python 3.10重写，我们之前的例子看起来会是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，使用关键字<code class="fe na nb nc nd b">match</code>打开<code class="fe na nb nc nd b">match</code>块，关键字后面是要匹配的变量。然后，在<code class="fe na nb nc nd b">match</code>块中，编写带有<code class="fe na nb nc nd b">case</code>关键字的事例，后跟您希望变量等于的值。最后，<code class="fe na nb nc nd b">case _:</code>块将匹配任何东西。它是<em class="lv">默认的</em>处理程序。</p><p id="a487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探索一些更有挑战性的例子。例如，您可以为单个<code class="fe na nb nc nd b">case</code>块指定多个条件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码片段将打印出由<code class="fe na nb nc nd b">month</code>变量给出的一个月中的天数。为了使用多个值，我们用<code class="fe na nb nc nd b">|</code>操作符将它们分开。我们可以更进一步，通过使用<em class="lv"> guard </em>表达式来检查闰年:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<code class="fe na nb nc nd b">is_leap_year</code>是一个函数，如果当前年份是闰年，则返回<code class="fe na nb nc nd b">true</code>。在这种情况下，Python将首先评估条件，如果满足，它将打印<code class="fe na nb nc nd b">29</code>。如果不是，将进入下一个条件并打印<code class="fe na nb nc nd b">28</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1ba6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">包装和拆包</h1><p id="4e77" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">结构模式匹配提供了比基本的<code class="fe na nb nc nd b">switch-case</code>语句更多的特性。您可以用它来评估复杂的数据结构并从中提取数据。例如，假设您将数据存储在一个格式为<code class="fe na nb nc nd b">(day, month, year)</code>的元组中——全部是整数。该代码将打印出季节以及日期和年份:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1f37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到，我们使用元组语法来捕获值。通过用<code class="fe na nb nc nd b">day</code>和<code class="fe na nb nc nd b">year</code>的名字来代替值，我们告诉Python我们希望这些值被提取出来并作为变量提供。通过用一个实际的数字值代替月份，我们只检查那个值。当我们检查<code class="fe na nb nc nd b">fall</code>时，您可以注意到我们再次使用了<code class="fe na nb nc nd b">_</code>符号。它是一个通配符，将匹配先前检查中遗漏的所有其他月份值。最后，我们还有一个通配符案例来说明格式错误的数据。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b51d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">类别匹配器</h1><p id="8e7e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Python 3.10中的结构化模式匹配还有一个很酷的功能。假设你有一个这样的类:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="3f50" class="nk me it nd b gy nl nm l nn no">class Vector:<br/>    speed: int<br/>    acceleration: int</span></pre><p id="f4c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用其属性来匹配<code class="fe na nb nc nd b">Vector</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到，通过将参数作为构造函数参数传入，我们可以匹配任何类型的对象并捕获其参数。请注意，这样不会创建实际的对象，并且在类声明中不需要相应的构造函数。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a113" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">何时使用结构模式匹配</h1><p id="239e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当对数据进行分类或过滤时，这个特性对那些使用大数据结构的人很有帮助。清理大型的<code class="fe na nb nc nd b">if-elif-else</code>语句链也很有帮助。现在，这个特性还在Python 3.10的测试流中，所以暂时不要在生产项目中使用它。等待2021年秋季稳定发布。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b7b7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结束语</h1><p id="53b6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">感谢您的阅读。我希望你喜欢我的文章。在评论中让我知道你想在哪里使用新的结构模式匹配特性！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="715a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">附加阅读</h1><ul class=""><li id="86c2" class="np nq it lb b lc mv lf mw li nr lm ns lq nt lu nu nv nw nx bi translated"><a class="ae ky" href="https://docs.python.org/3.10/whatsnew/changelog.html#changelog" rel="noopener ugc nofollow" target="_blank">全Python 3.10变更日志</a></li><li id="f1c7" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/new-in-python-3-10-4-features-you-should-try-out-d48db504500d">Python 3 . 10:4中的新特性，你必须尝试一下</a></li><li id="2ce9" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://levelup.gitconnected.com/python-context-managers-in-depth-52dd2dd2624b" rel="noopener ugc nofollow" target="_blank">深度Python上下文管理器</a></li></ul></div></div>    
</body>
</html>