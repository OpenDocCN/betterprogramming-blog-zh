<html>
<head>
<title>Serializing Data Within Large Integers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">序列化大整数中的数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/serializing-data-within-large-integers-433684c8e7cd?source=collection_archive---------9-----------------------#2020-11-23">https://betterprogramming.pub/serializing-data-within-large-integers-433684c8e7cd?source=collection_archive---------9-----------------------#2020-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e6c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以太坊和Dapps使用逐位运算来序列化和反序列化单个256位令牌ID中的多个整数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/326ba8d5f8b54c7520c02473b89fc8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBDJReDVj3AqjfUHWsWztQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">移动一个大的二进制整数中的位以显示更小的整数(图片来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=507790" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kv" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=507790" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a></p></figure><p id="1a53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据大小的优化经常被忽略，或者可读性比数据大小更重要。然而，在为区块链上的数据存储付费时，大小确实很重要。以太坊智能合约整数占用256位空间，通常比需要的要大。256位整数可以表示八(8)个不同的32位整数值或32个不同的8位值。由于天然气价格取决于数据大小，因此利用您支付的存储在区块链上的整数的所有位非常重要。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/63e39ab843bdebde0b177240ebb0a9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIXDWy8-uhqDoa5H_AsE_w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在单个256位整数中可视化多个较小的整数</p></figure><p id="4a8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">明确地说，在一个较大的整数中序列化较小的整数的额外复杂性应该小心对待。只有逻辑上相关的数据才能以这种方式分组。在世界上第一个去中心化软件应用商店的开发过程中，非营利组织<a class="ae kv" href="https://www.immutablesoft.org/" rel="noopener ugc nofollow" target="_blank"> ImmutableSoft </a>发现这条道路充满了意想不到的障碍。这是他们关于为什么、在哪里以及如何应用这种技术的故事。</p><p id="e4d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ERC-721令牌id是256位整数，必须是唯一的(在区块链称为<em class="lt">不可替换的</em>)。ImmutableSoft创建的<a class="ae kv" href="https://ecosystem.immutablesoft.org/" rel="noopener ugc nofollow" target="_blank">不可变生态系统</a>去中心化应用程序(Dapp)将其软件许可激活定义为ERC-721令牌。为了表示软件许可证，它必须存储实体(组织、个人等。)和产品标识符。此外，激活限制，如有效期、版本和语言，必须永久记录在每次激活的区块链上。</p><p id="75ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">起初，仅用256位来表示所有这些信息似乎是不可能的。这很好，因为很容易扩展我们的ERC-721令牌来为每个单独的令牌存储额外的数据。然而，额外的存储会增加天然气成本，并将不可变的数据移出ERC-721标准。我们认为，我们的令牌在标准令牌ID中准确地表示整个软件激活非常重要，这样令牌即使在其他ERC-721交换中也能被理解。随着为激活起草以太坊改进提案(EIP)的计划最终确定，谨慎的设计是明智的。</p><p id="d0c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们首先检查了所有的激活变量，并为每个变量定义了一个最小整数大小。例如，假设32位足以识别不可变生态系统的所有注册实体是合理的。产品标识符也是如此。即使是最多产的经销商也会发现一个32位的整数足以标识他们所有的产品。使用通用的从纪元开始的秒表示法(C标准库<code class="fe lu lv lw lx b">time()</code>函数)，可以类似地用32位整数来表示到期时间。</p><p id="b284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代表一个版本需要一些自我反省。我们的折衷方案是使用四(4)个不同的16位整数来表示版本。在字符串点表示法中，这看起来像1.2.3.4，每个数字表示为16位无符号整数(最大值为65，535)。整个版本字段总共64位。到目前为止，已经使用了160位令牌ID，还有96位可供使用。</p><p id="0d61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了灵活性和将来的可升级性，很明显我们需要一个flags字段来标识激活令牌所代表的类型和特性。基于设置了哪些标志位(位值1)，256位令牌ID的数据布局可以改变。我们最初这样做是为了让我们的ERC-721令牌能够代表应用程序中的特性，而不是激活可执行文件。例如，独特的游戏项目可以很容易地表示为生态系统中的激活。无论游戏物品是可购买的还是只能在游戏中找到的，在线游戏都可以使用不变的生态系统将它们的物品移动到区块链，而无需区块链体验。特征标志被定义为识别应用特征。但是在接下来的讨论中，我们将重点关注限制和到期标志。</p><p id="3a12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了表示语言限制，重要的是每个语言都要用自己的位来表示，以便在一次软件许可证激活中支持多种语言。在决定使用64位(每一位代表一种不同的语言)后，我们发现自己利用了令牌ID的所有256位。下面是我们的智能合约中的bit布局。所有软件许可证激活令牌都支持最高有效的128位，最低有效的128位特定于定义的标志。在这种情况下，限制标志定义了保存语言和版本限制的最后几位(或LSB)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/23fa8b2e01d4053787b66bc927e123eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXoT_c7GPCt4D7Ld7Lt7tg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">首先尝试定义激活令牌的256位令牌ID的结构</p></figure><p id="0af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们普遍为我们的成功喝彩，并陶醉于我们的独创性——事实证明，为时过早。</p><p id="8da0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在审计和测试时，我们发现该解决方案没有强制执行ERC-721令牌的唯一性(不可替代性)要求。我们设计中的令牌对于常见的测试和用例来说是唯一的，但是存在许多(未知的)极端情况，其中生成的令牌ID可能与另一个相同。例如，如果两个人同时购买激活优惠，则到期时间将是相同的，从而导致铸造新令牌的交易失败，这是一种区块链失败，可能会损失软件创建者的收入。软件创作者也有可能指定一个没有到期的报价。正是在这个用例中，问题变得非常明显并被发现。在使用此优惠进行第一次购买后，后续购买将在制造阶段失败，因为令牌ID不是唯一的。只有到期时间为令牌提供了唯一性。</p><p id="e754" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到绘图板。我们查看了所有的数据字段，以确定如何为每个激活引入独特性。到了紧要关头，标志的大小被减少到16位，以便为唯一ID腾出空间。对特定产品递增计数器(nonce)使用16位确保了唯一性。随着每个新令牌增加这个值，它还可以用来帮助记录和报告生成。</p><p id="4263" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的难题的最后一块是激活的平台类型标志。软件许可证激活是否支持Windows操作系统、Mac操作系统、Linux或上述操作系统的某种组合？我们如此接近于适应一切，我们给了这一努力一个更多的尝试，审查语言和版本领域。有了全球抱负，我们明白我们可以，但不想限制可能的语言数量。这个版本看起来坚不可摧，但真的如此吗？</p><p id="c64b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">版本字段已经过优化并用于标识产品版本，不能更改。然而，有人认为，版本的最后一个数字永远不应被定义为激活的限制，原因是所有软件都应允许新版本解决缺陷修复。作为一个软件分销商，你永远不会想把自己困在一个角落里，在那里你必须重新许可你的客户，以提供一个错误修复。因此，一个版本需要四位数字的版本，但版本的最后一位数字现在在激活中可供争夺！</p><p id="5727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是16位足以容纳所有的平台位吗？结果是，按照目前的定义，有15个平台——还有一点留给未来。好险，太险了。随着旗帜领域仍然可以升级，我们变得更加舒适，这种紧密配合和任何支点前进。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/f4366dd557f0b35cf75d5b7b93149e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOWe2T6JQF9efX7PxTUvtg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">激活令牌的256位令牌ID结构的第二次修订</p></figure><p id="9a1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦令牌ID的结构最终确定，我们就在智能契约(Solidity)中定义常数，以便我们可以从整体中提取或反序列化单个整数。通过执行按位And运算，然后将偏移量右移，我们提取或反序列化单个整数。为了可视化，将手指放在上面想要的字段的行上(And操作)，然后将数字向右移动，直到它与末端齐平(右移偏移量)。下面是与上图中的结构相对应的已定义的偏移和遮罩。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="7af4" class="mc md iq lx b gy me mf l mg mh">  // Offset and mask of entity and product identifiers<br/>  uint256 constant EntityIdOffset = 224;<br/>  uint256 constant EntityIdMask =  (0xFFFFFFFF &lt;&lt;<br/>                                    EntityIdOffset);<br/>  uint256 constant ProductIdOffset = 192;<br/>  uint256 constant ProductIdMask =  (0xFFFFFFFF &lt;&lt;<br/>                                     ProductIdOffset);</span><span id="9e1c" class="mc md iq lx b gy mi mf l mg mh">  // Bits to help enforce non fungible (unique) token<br/>  uint256 constant UniqueIdOffset = 176;<br/>  uint256 constant UniqueIdMask =  (0xFFFF &lt;&lt;<br/>                                    UniqueIdOffset);</span><span id="445e" class="mc md iq lx b gy mi mf l mg mh">  // Flags allow different activation types and Value layout<br/>  uint256 constant FlagsOffset = 160;<br/>  uint256 constant FlagsMask =  (0xFFFF &lt;&lt; FlagsOffset);</span><span id="fe24" class="mc md iq lx b gy mi mf l mg mh">  // Expiration is last field before final 128 bit Value<br/>  uint256 constant ExpirationOffset = 128;<br/>  uint256 constant ExpirationMask = (0xFFFFFFFF &lt;&lt;<br/>                                     ExpirationOffset);</span><span id="979c" class="mc md iq lx b gy mi mf l mg mh">  // If limitation flag set, the Value is entirely utilized</span><span id="0f37" class="mc md iq lx b gy mi mf l mg mh">  // Bits 64 - 127 are for language (as defined above)<br/>  uint256 constant LanguageOffset = 64;<br/>  uint256 constant LanguageMask =  (0xFFFFFFFFFFFFFFFF &lt;&lt;<br/>                                    LanguageOffset);</span><span id="2d40" class="mc md iq lx b gy mi mf l mg mh">  // Final 64 bits is version (4 different 16 bit)<br/>  uint256 constant LimitVersionOffset = 0;<br/>  uint256 constant LimitVersionMask =(0xFFFFFFFFFFFFFFFF &lt;&lt;<br/>                                      LimitVersionOffset);</span></pre><p id="c9e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用上面的掩码和偏移量，首先执行按位and运算以应用掩码，然后将结果向右移动偏移量位。下面是一个从激活令牌ID中提取有效期的示例。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="5c11" class="mc md iq lx b gy me mf l mg mh">// token_id is the value of the activation token id</span><span id="1765" class="mc md iq lx b gy mi mf l mg mh">uint256 theExpiration;<br/>theExpiration = ((token_id &amp; ExpirationMask) &gt;&gt;<br/>                 ExpirationOffset);</span></pre><p id="ed12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦智能契约表示了令牌ID中的所有数据字段，我们的分散式应用程序(Dapp)就有必要在单个256位令牌ID中读取(反序列化)和写入(序列化)各个值。与大多数编程语言一样，JavaScript不支持大整数或整数常量，所以为了简单起见，我们将按照与上面的Solidity示例相反的顺序来执行位运算。</p><p id="7fbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用按位运算，在And运算之前右移允许使用由要反序列化的整数的大小定义的小局部掩码。JavaScript 32位整数常量(“0xFFFFFFFF”)或16位整数常量(0xFFFF)用于在移位后屏蔽大小整数。通过右移与偏移量相等的位数，然后使用and运算应用局部掩码，可以将较大整数中的每个较小整数隔离出来，并赋给一个单独的变量供程序使用。</p><p id="a75c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的Dapp，我们使用了<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点。JS </a>和<a class="ae kv" href="https://www.npmjs.com/package/big-integer" rel="noopener ugc nofollow" target="_blank">大整数</a>包。要安装npm，请执行以下操作:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="ef1b" class="mc md iq lx b gy me mf l mg mh">npm install big-integer</span></pre><p id="3459" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并在代码中包含:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="cfd0" class="mc md iq lx b gy me mf l mg mh">var bigInt = require("big-integer");</span></pre><p id="d823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建一个供JavaScript代码使用的大整数，必须使用<code class="fe lu lv lw lx b">bigInt()</code>构造函数。智能协定调用以十六进制字符串的形式返回一个256位的大整数。要开始反序列化这个大整数，将十六进制字符串直接传递给<code class="fe lu lv lw lx b">bigInt()</code>构造函数，用JavaScript创建一个256位整数的令牌ID。然后结合使用<code class="fe lu lv lw lx b">shiftRight()</code>操作和<code class="fe lu lv lw lx b">and()</code>操作，从较大的256位整数中反序列化较小的整数。以较大的256位整数编码的每个单独的整数现在可以被解析(解串行化)并呈现给用户或由Dapp使用。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="d537" class="mc md iq lx b gy me mf l mg mh">  //First create the bigInt() of the token id<br/>  //  tokenId is the response from the blockchain<br/>  var value = bigInt(tokenId);</span><span id="a886" class="mc md iq lx b gy mi mf l mg mh">  // De-serialize the activation bit flags and nonce<br/>  var flags = value.shiftRight(160).and('0xFFFF');<br/>  var nonce = value.shiftRight(176).and('0xFFFF');</span><span id="b650" class="mc md iq lx b gy mi mf l mg mh">  // De-serialize the expiration<br/>  var expiration = value.shiftRight(128).and('0xFFFFFFFF');</span></pre><p id="c1e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于JavaScript不支持64位整数常量，语言和版本字段的掩码要求我们首先创建一个<code class="fe lu lv lw lx b">bigInt()</code>来用作位掩码。有了这个掩码，我们就完成了256位激活令牌ID的反序列化。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="b885" class="mc md iq lx b gy me mf l mg mh">  // JavaScript has no 64 bit constant support, so create<br/>  // a bigInt to hold our 64 bit mask of all ones<br/>  var all32bits = bigInt('0xFFFFFFFF');<br/>  var all64bits = all32bits.or(all32bits.shiftLeft(32));</span><span id="9265" class="mc md iq lx b gy mi mf l mg mh">  // Shift 64 bits and get 64 bits for language limitations<br/>  var langLimitation = value.shiftRight(64).and(all64bits);</span><span id="0350" class="mc md iq lx b gy mi mf l mg mh">  // Final 64 bits is the version limitation and platform<br/>  var verLimitation = value.and(all64bits);</span><span id="fcca" class="mc md iq lx b gy mi mf l mg mh">  // OS/HW platform is taken from last 16 bits of version<br/>  var platformLimitations = verLimitation.and('0xFFFF');</span><span id="0bd0" class="mc md iq lx b gy mi mf l mg mh">  // Shift right to remove platform from the version<br/>  verLimitation = verLimitation.shiftRight(16);</span></pre><p id="56b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将较小的整数序列化回较大的256位整数，我们进行了相反的位运算。使用按位左移操作，我们创建每个较小整数的新的<code class="fe lu lv lw lx b">bigInt()</code>变量，但是将位移动到它们在256位整数值内的最终位置。一旦所有的单个整数值都被转换成大整数，并且处于正确的位位置，我们就执行按位“或”运算将它们放在一起。我们是这样做的。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="ee5c" class="mc md iq lx b gy me mf l mg mh">        // entityID, productID, preventResale, duration and<br/>        // limitation from user input (not shown)</span><span id="07e3" class="mc md iq lx b gy mi mf l mg mh">        // Product and entity are encoded in offer<br/>        var productIdFlag = bigInt(productID).shiftLeft(192);<br/>        var entityIdFlag =<br/>              bigInt(entityID).shiftLeft(224);</span><span id="a3f4" class="mc md iq lx b gy mi mf l mg mh">        // Expiration and limitation flags<br/>        var expirationFlag = bigInt(1).shiftLeft(160);<br/>        var limitationFlag = bigInt(1).shiftLeft(161);</span><span id="0663" class="mc md iq lx b gy mi mf l mg mh">        // Check if prevent resale flag is set and valid<br/>        var preventResaleFlag = bigInt(0);<br/>        if ((preventResale == null) || (preventResale.length == 0))<br/>          preventResale = '0';<br/>        if (preventResale == '1')<br/>          preventResaleFlag = bigInt(1).shiftLeft(162);</span><span id="5cf7" class="mc md iq lx b gy mi mf l mg mh">        // Convert the duration into an expiration<br/>        var currentDate = new Date();<br/>        var expirationInSeconds = currentDate.getTime() / 1000;<br/>        expirationInSeconds += duration;<br/>        <br/>        // Initialize the token id value<br/>        var value = bigInt(Math.ceil(expirationInSeconds));</span><span id="08bf" class="mc md iq lx b gy mi mf l mg mh">        value =<br/>          value.shiftLeft(128).or(limitation).or(expirationFlag).<br/>                  or(limitationFlag).or(preventResaleFlag).<br/>                  or(productIdFlag).or(entityIdFlag);</span></pre><p id="9cbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，这就是如何将多个较小的整数序列化和反序列化为一个256位的大整数的蓝图。我希望这个演练有助于为其他有类似问题的人指明道路。通过一些准备工作，使用序列化在单个256位整数中编码和解码多个整数并不困难。干杯！</p></div></div>    
</body>
</html>