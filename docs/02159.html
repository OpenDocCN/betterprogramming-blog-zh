<html>
<head>
<title>How To Make Your PHP Code Beautiful With Chainable Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用可链接的方法让你的PHP代码变得漂亮</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-your-php-code-beautiful-with-chainable-methods-83d8832b1b16?source=collection_archive---------3-----------------------#2019-11-11">https://betterprogramming.pub/how-to-make-your-php-code-beautiful-with-chainable-methods-83d8832b1b16?source=collection_archive---------3-----------------------#2019-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7547" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">函数式编程，认识PHP</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cb6eab9db28ac0fad6aacdc272d1844e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsziWYOI5mhU261Zh-KQBA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@zhangyuwei_cyclens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">威廉张</a>在<a class="ae ky" href="https://unsplash.com/s/photos/dock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="9938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PHP有一个丑陋的坏名声。这种语言随着时间的推移逐渐演变，这是显而易见的。</p><p id="4eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但它也有许多可取之处。PHP开发团队在每一个版本中都不断改进这种语言。尤其是PHP 7，在特性和性能上都取得了长足的进步。</p><p id="7b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种语言的其他好处包括友好的文档，无处不在的主机，以及大量的在线资源(栈溢出等)。</p><p id="a779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，所有最大的CMS平台(Wordpress，Drupal，Joomla)都是基于PHP的，在这个领域还有很多工作要做。</p><p id="66a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，对于我们这些使用PHP并想写出漂亮代码的人来说，如何实现呢？</p><p id="6a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反对者可能会声称这是不可能的，但我不同意。像<a class="ae ky" href="https://laravel.com/" rel="noopener ugc nofollow" target="_blank">Laravel</a>(“web工匠的PHP框架”)<em class="lv"> </em>这样的框架已经证明他们错了。</p><p id="9113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Laravel和其他受尊敬的PHP框架经常实现的一种模式是<em class="lv">方法链接。</em></p><p id="1fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个例子，Laravel的查询构建器API:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f12b" class="mb mc it lx b gy md me l mf mg">$users = DB::table('users')<br/>    -&gt;where('votes', '&gt;', 100)<br/>    -&gt;orWhere('name', 'John')<br/>    -&gt;get();</span></pre><p id="6dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考:<a class="ae ky" href="https://laravel.com/docs/5.6/queries" rel="noopener ugc nofollow" target="_blank">https://laravel.com/docs/5.6/queries</a>。</p><p id="e99d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种“链接”语法很好，因为它允许开发人员编写代码，以表达性和可读性强的方式一次做一件事。在上面的例子中，很容易看出发生了什么:</p><ol class=""><li id="3f0e" class="mh mi it lb b lc ld lf lg li mj lm mk lq ml lu mm mn mo mp bi translated">查看<code class="fe mq mr ms lx b">users</code>表中的行。</li><li id="f205" class="mh mi it lb b lc mt lf mu li mv lm mw lq mx lu mm mn mo mp bi translated">票数超过100的地方。</li><li id="f8f9" class="mh mi it lb b lc mt lf mu li mv lm mw lq mx lu mm mn mo mp bi translated">或者用户的名字是约翰。</li><li id="b20b" class="mh mi it lb b lc mt lf mu li mv lm mw lq mx lu mm mn mo mp bi translated">得到结果。</li></ol><p id="b442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很圆滑，对吧？让我们深入探讨如何将这种模式应用到生活中。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="8652" class="nf mc it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">具体的例子</h1><p id="7fbd" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">为了说明方法链是如何工作的，让我们以数组操作为例。PHP有很多有用的数组函数，如<code class="fe mq mr ms lx b">array_map</code>、<code class="fe mq mr ms lx b">array_filter</code>、<code class="fe mq mr ms lx b">usort</code>等。但是在一个数组上执行多个操作会很难看。</p><p id="f379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个Simpson角色名数组，我们希望应用以下转换:</p><ol class=""><li id="d3f2" class="mh mi it lb b lc ld lf lg li mj lm mk lq ml lu mm mn mo mp bi translated">过滤掉所有不以“Simpson”结尾的名字。</li><li id="85ae" class="mh mi it lb b lc mt lf mu li mv lm mw lq mx lu mm mn mo mp bi translated">将每个全名映射到一个名字。例如，我们将“丽莎·辛普森”替换为简单的“丽莎”。</li><li id="315f" class="mh mi it lb b lc mt lf mu li mv lm mw lq mx lu mm mn mo mp bi translated">按字母顺序排列我们的结果。</li></ol><p id="a1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一种方法可以解决我们的问题:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="e204" class="mb mc it lx b gy md me l mf mg">$characters = [<br/>    'Maggie Simpson',<br/>    'Edna Krabappel',<br/>    'Marge Simpson',<br/>    'Lisa Simpson',<br/>    'Moe Szyslak',<br/>    'Waylon Smithers',<br/>    'Homer Simpson',<br/>    'Bart Simpson'<br/>];</span><span id="9798" class="mb mc it lx b gy ob me l mf mg">// Look for full names that end in Simpson<br/>// Filter out items that don't match<br/>$simpsons = array_filter($characters, function ($character) {<br/>    return preg_match('/^.+\sSimpson$/', $character);<br/>});</span><span id="030f" class="mb mc it lx b gy ob me l mf mg">// Replace " Simpson" with an empty string for each item<br/>$simpsons = array_map(function ($character) {<br/>    return str_replace(' Simpson', '', $character);<br/>}, $simpsons);</span><span id="bd3c" class="mb mc it lx b gy ob me l mf mg">// Sort the items using PHP's "strcasecmp"<br/>usort($simpsons, function ($a, $b) {<br/>    return strcasecmp($a, $b);<br/>});</span><span id="1317" class="mb mc it lx b gy ob me l mf mg">var_dump($simpsons); // ['Bart', 'Homer', 'Lisa', 'Maggie', 'Marge']</span></pre><p id="f88f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为我们提供了正确的结果，但眼尖的人可能会发现一些细节:</p><ol class=""><li id="7b50" class="mh mi it lb b lc ld lf lg li mj lm mk lq ml lu mm mn mo mp bi translated"><code class="fe mq mr ms lx b">array_filter</code>接受数组和回调，但<code class="fe mq mr ms lx b">array_map</code>接受回调和数组。为什么这些函数会以不同的顺序接受参数？</li><li id="fa62" class="mh mi it lb b lc mt lf mu li mv lm mw lq mx lu mm mn mo mp bi translated">过滤和映射操作被保存到<code class="fe mq mr ms lx b">$simpsons</code>变量中，但是<code class="fe mq mr ms lx b">usort</code>通过引用访问我们的数组。为什么不一致？</li><li id="95ee" class="mh mi it lb b lc mt lf mu li mv lm mw lq mx lu mm mn mo mp bi translated">这看起来有点难看。</li></ol><p id="6128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为比较，让我们看看如何用JavaScript解决这个问题:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="b740" class="mb mc it lx b gy md me l mf mg">const simpsons = characters<br/>  .filter(character =&gt; character.match(/^.+\sSimpson$/))<br/>  .map(character =&gt; character.replace(' Simpson', ''))<br/>  .sort((a, b) =&gt; b &lt; a)</span><span id="4f88" class="mb mc it lx b gy ob me l mf mg">console.log(simpsons)</span></pre><p id="4de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript解决方案要优雅得多。数组是JavaScript中的一种对象，这允许数组操作被链接起来。</p><p id="f5c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旁白:为了简洁起见，上面的JavaScript使用了<a class="ae ky" href="https://laravel-news.com/short-arrow-functions" rel="noopener ugc nofollow" target="_blank">箭头函数</a>。PHP还没有箭头功能，但是我们可能很快就会有了！</p><p id="748b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中的数组方法链接是免费的，但是我们可以通过编写自己的自定义类在PHP中模拟这一点。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="c75c" class="nf mc it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">用可链接的方法创建类</h1><p id="4a46" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">姑且称之为<code class="fe mq mr ms lx b">Collection</code>。可以通过将数组传递到构造函数中来创建该类的实例。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="17e6" class="mb mc it lx b gy md me l mf mg">class Collection<br/>{<br/>    private $array;</span><span id="e42f" class="mb mc it lx b gy ob me l mf mg">    public function __construct($array)<br/>    {<br/>        $this-&gt;array = $array;<br/>    }<br/>}</span><span id="0d3e" class="mb mc it lx b gy ob me l mf mg">$characters = new Collection([<br/>    'Maggie Simpson',<br/>    'Edna Krabappel',<br/>    'Marge Simpson',<br/>    'Lisa Simpson',<br/>    'Moe Szyslak',<br/>    'Waylon Smithers',<br/>    'Homer Simpson',<br/>    'Bart Simpson'<br/>]);</span></pre><p id="4443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，这个类并没有做很多事情——它只是保存了作为私有属性传递的数组。让我们着眼于添加一个公共的<code class="fe mq mr ms lx b">filter</code>方法。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c008" class="mb mc it lx b gy md me l mf mg">public function filter($callback)<br/>{<br/>    $this-&gt;array = array_filter($this-&gt;array, $callback);<br/>    return $this;<br/>}</span></pre><p id="75e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在只需要回调函数，而不是像以前一样必须同时传递数组和回调函数作为参数。一旦实例的array属性被转换，就返回实例本身。这使得方法链接成为可能。</p><p id="0c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们为<code class="fe mq mr ms lx b">map</code>和<code class="fe mq mr ms lx b">sort</code>添加方法:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2515" class="mb mc it lx b gy md me l mf mg">public function map($callback)<br/>{<br/>    $this-&gt;array = array_map($callback, $this-&gt;array);<br/>    return $this;<br/>}</span><span id="f080" class="mb mc it lx b gy ob me l mf mg">public function sort($callback)<br/>{<br/>    usort($this-&gt;array, $callback);<br/>    return $this;<br/>}</span></pre><p id="051e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的方法已经准备好被链接了，但是我们需要一种方法以数组的形式获取最终结果。这类似于Laravel查询构建器如何使用<code class="fe mq mr ms lx b">get()</code>来执行已经用条件构建好的查询。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="b78a" class="mb mc it lx b gy md me l mf mg">public function execute()<br/>{<br/>    return $this-&gt;array;<br/>}</span></pre><p id="5b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上所述，我们的类如下所示:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="6a3d" class="mb mc it lx b gy md me l mf mg">class Collection<br/>{<br/>    private $array;</span><span id="a539" class="mb mc it lx b gy ob me l mf mg">    public function __construct($array)<br/>    {<br/>        $this-&gt;array = $array;<br/>    }</span><span id="9e94" class="mb mc it lx b gy ob me l mf mg">    public function filter($callback)<br/>    {<br/>        $this-&gt;array = array_filter($this-&gt;array, $callback);<br/>        return $this;<br/>    }</span><span id="e4ca" class="mb mc it lx b gy ob me l mf mg">    public function map($callback)<br/>    {<br/>        $this-&gt;array = array_map($callback, $this-&gt;array);<br/>        return $this;<br/>    }</span><span id="a21d" class="mb mc it lx b gy ob me l mf mg">    public function sort($callback)<br/>    {<br/>        usort($this-&gt;array, $callback);<br/>        return $this;<br/>    }</span><span id="2857" class="mb mc it lx b gy ob me l mf mg">    public function execute()<br/>    {<br/>        return $this-&gt;array;<br/>    }<br/>}</span></pre><p id="4ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而我们最后可以如下链数组方法！</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="935f" class="mb mc it lx b gy md me l mf mg">$characters = new Collection([<br/>    'Maggie Simpson',<br/>    'Edna Krabappel',<br/>    'Marge Simpson',<br/>    'Lisa Simpson',<br/>    'Moe Szyslak',<br/>    'Waylon Smithers',<br/>    'Homer Simpson',<br/>    'Bart Simpson'<br/>]);</span><span id="503e" class="mb mc it lx b gy ob me l mf mg">$simpsons = $characters<br/>    -&gt;filter(function ($character) {<br/>        return preg_match('/^.+\sSimpson$/', $character);<br/>    })<br/>    -&gt;map(function ($character) {<br/>        return str_replace(' Simpson', '', $character);<br/>    })<br/>    -&gt;sort(function ($a, $b) {<br/>        return strcasecmp($a, $b);<br/>    })<br/>    -&gt;execute();</span><span id="4108" class="mb mc it lx b gy ob me l mf mg">var_dump($simpsons); // ['Bart', 'Homer', 'Lisa', 'Maggie', 'Marge']</span></pre><p id="19b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常JavaScript风格！参数顺序和引用访问的问题仍然存在，但是我们的<code class="fe mq mr ms lx b">Collection</code>类在幕后处理这个问题。结果是代码更加干净，可读性更好！</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="91f1" class="nf mc it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">摘要</h1><p id="f7ff" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">PHP因混乱而臭名昭著，但Laravel和其他框架正在使用可链接的方法(以及其他方法)来鼓励漂亮的代码并挑战这种观念。</p><p id="b41b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PHP中的数组操作不像在JavaScript中那样是可链接的，而是一个基本的实用类(就像我们的<code class="fe mq mr ms lx b">Collection</code>类！)可以用来模拟这一点，并将PHP的一些小怪癖隐藏起来。</p></div></div>    
</body>
</html>