<html>
<head>
<title>A Look at the New PHP 8.1 Fibers Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看看PHP 8.1新的纤程特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-look-at-the-new-php-8-1-fibers-feature-979489399918?source=collection_archive---------1-----------------------#2021-03-23">https://betterprogramming.pub/a-look-at-the-new-php-8-1-fibers-feature-979489399918?source=collection_archive---------1-----------------------#2021-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="60a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解它是如何工作的，以及它对PHP中并发性的未来意味着什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b556258599fb1dd92a3469f95756e4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HUPrSDen6WuIXhKl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yogendras31?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约根德拉·辛格</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PHP正试图从它的代码库中去除缺乏的特性，而纤程是对这种语言有意义的补充之一。PHP Fibers 将于今年年底在PHP 8.1中发布，它将引入一种异步编程(协程)。</p><p id="4e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Fiber_(computer_science)" rel="noopener ugc nofollow" target="_blank">纤程</a>的概念基本上是指一个轻量级的执行线程(也称为<em class="lv">协程</em>)。这些看似并行运行，但最终由运行时本身处理，而不是直接推给CPU。很多主流语言都有自己的实现方式，但原理是一样的:让计算机同时做两件或更多的事情，并等待所有事情完成。</p><p id="7ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如人们可能认为的那样，纤程的PHP实现并不是真正的异步计算。事实上，引入纤程后，PHP的核心仍然是同步的。</p><p id="0efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以把PHP纤维想象成从一辆汽车换到另一辆汽车。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3803" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">纤维将如何工作？</h1><p id="5801" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">纤程是单个<a class="ae ky" href="https://www.php.net/manual/language.oop5.final.php" rel="noopener ugc nofollow" target="_blank">最终类</a>看起来像一辆汽车:它可以立即启动和运行，踩下刹车并等待，然后继续它的行程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用<code class="fe nc nd ne nf b">callable</code>创建一个新的纤程实例时，什么都不会发生。直到启动纤程，回调才会像其他普通PHP代码一样执行。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="3162" class="nk me it nf b gy nl nm l nn no">$fiber = new Fiber(function() : void {<br/>   echo "I'm running a Fiber, yay!";<br/>});</span><span id="9fa3" class="nk me it nf b gy np nm l nn no">$fiber-&gt;start(); // I'm running a Fiber, yay!</span></pre><p id="6af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不是说过纤维是异步的吗？它们是，但只是在你通过在回调中调用<code class="fe nc nd ne nf b">Fiber::suspend()</code>踩下刹车之前。然后，它将控制权传递给“外部”，但是请记住，这个Fiber car仍然活着，并等待恢复。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="bcd3" class="nk me it nf b gy nl nm l nn no">$fiber = new Fiber(function() : void {<br/>   Fiber::suspend();<br/>   echo "I'm running a Fiber, yay!";<br/>});</span><span id="9d43" class="nk me it nf b gy np nm l nn no">$fiber-&gt;start(); // [Nothing happens]</span></pre><p id="d7bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然汽车已经暂停，接下来要做的就是把你的脚从刹车上拿开，为此，我们可以从外面调用<code class="fe nc nd ne nf b">resume()</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ef13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上是不真实的异步，但这并不意味着你的应用程序不能同时做两件事。这里真正的事实是纤程函数状态保存在它离开的地方。你象征性地在两辆车之间切换，将每辆车开到一个点。</p><p id="d1d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe nc nd ne nf b">start()</code>、<code class="fe nc nd ne nf b">suspend(</code>和<code class="fe nc nd ne nf b">resume()</code>的一个巧妙之处是它们接受参数:</p><ul class=""><li id="1fb0" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe nc nd ne nf b">start()</code>方法将把参数传递给<code class="fe nc nd ne nf b">callable</code>，并将返回<code class="fe nc nd ne nf b">suspend()</code>方法接收到的任何内容。</li><li id="6c59" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe nc nd ne nf b">suspend()</code>方法返回<code class="fe nc nd ne nf b">resume()</code>方法收到的任何值。</li><li id="8f2d" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe nc nd ne nf b">resume()</code>方法返回下一次调用<code class="fe nc nd ne nf b">suspend()</code>所收到的任何内容。</li></ul><p id="c1ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得主线程和纤程之间的通信相对容易:</p><ul class=""><li id="55e9" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe nc nd ne nf b">resume()</code>用于将数值输入到通过<code class="fe nc nd ne nf b">suspend()</code>接收的光纤中，以及</li><li id="4919" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe nc nd ne nf b">suspend()</code>用于推出<code class="fe nc nd ne nf b">resume()</code>接收的值。</li></ul><p id="9cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得官方举例方式更容易理解:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e2db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您执行上面的代码，您将会收到类似这样的内容:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="ce47" class="nk me it nf b gy nl nm l nn no">Value from fiber suspending: fiber<br/>Value used to resume fiber: test</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5707" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我们即将拥有自己完整的网络服务器</h1><p id="ede4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">面对现实吧，PHP 99%的时间都是和<a class="ae ky" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> nginx </a> / <a class="ae ky" href="https://httpd.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache </a>配对的，主要是因为它不是多线程的。PHP中的服务器是阻塞的，只为某些测试或向客户端显示某些内容而服务<em class="lv"> </em>。</p><p id="e996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纤程可能会为PHP更有效地使用套接字打开大门，并支持WebSockets、服务器端事件、池化数据库连接甚至HTTP/3之类的东西，而不必求助于编译扩展、用意想不到的特性进行编程、将PHP封装到另一个外部运行时或任何其他灾难性的方法。</p><p id="5206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些事情可能需要时间来解决，但如果有承诺为其他功能保留一个单一的代码库，而不必花费数天时间来尝试编译和部署，我就同意。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8df6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">你不会直接使用纤维</h1><p id="7bba" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">根据文档，Fibers只提供了“允许用户代码在PHP中实现全栈协同程序或绿色线程所需的最低要求”</p><p id="12dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，除非你有非常奇怪的理由直接使用它们，否则你永远不会像在Javascript或Go上使用协程那样与纤程交互。</p><p id="bec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些高级框架(如<a class="ae ky" href="https://symfony.com/" rel="noopener ugc nofollow" target="_blank"> Symfony </a>、<a class="ae ky" href="https://laravel.com/" rel="noopener ugc nofollow" target="_blank"> Laravel </a>、<a class="ae ky" href="https://codeigniter.com/" rel="noopener ugc nofollow" target="_blank"> CodeIgniter </a>和<a class="ae ky" href="https://cakephp.org/" rel="noopener ugc nofollow" target="_blank"> CakePHP </a>等等)需要一些时间来理解如何处理纤程，并从开发人员的角度为它们创建一套工具。一些底层框架，像<a class="ae ky" href="https://amphp.org/" rel="noopener ugc nofollow" target="_blank"> amphp </a>和<a class="ae ky" href="https://reactphp.org/" rel="noopener ugc nofollow" target="_blank"> ReactPHP </a>，已经在其最新开发版本中登上了纤程之船。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/6cc4e59c8ce78d0ed2792b7907876831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*ZevfrlK3Qbyit6mW.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://xkcd.com/927/" rel="noopener ugc nofollow" target="_blank">标准</a> — xkcd</p></figure><p id="4e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这将使您从更多地考虑纤程而不是您的想法中解放出来，但这意味着每个人都将创造他们自己的并发风格，以及他们所有的优点和警告。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f71f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一次只能有一根纤维</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/b7d7e082eec806a37aad942bea0f5438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1UkVbl5Ed30-o-VR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@victoire_jonch?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Victoire Joncheray </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将引用来自<a class="ae ky" href="https://phpinternals.news/74" rel="noopener ugc nofollow" target="_blank"> PHP内部播客#74 </a>的Aaron Piotrowski的话:</p><blockquote class="og oh oi"><p id="acda" class="kz la lv lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">由于同一时间只能执行一条纤程，因此不会出现两个线程同时访问或写入内存时出现的某些竞争情况</p></blockquote><p id="c2f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Aaron还补充说，框架将能够在同一块内存上解决并发和同步问题。</p><p id="4abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，因为你不需要考虑数据竞争、信号量和互斥体，这些东西地鼠<em class="lv"> </em>完全理解。但是不管你做什么，你仍然必须同时做两件事情。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6f7e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">同时没有频道</h1><p id="301f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">由于只有一个纤程同时运行，所以即使你声明了多个，也不存在数据同步的问题。但亚伦说，有可能另一根纤维醒来，重写第一根纤维共享的内容。解决方案之一是使用Go的通道样式。</p><p id="4fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">吴镇男·雷森斯问了关于信道的问题，艾伦的回答很简单:除了光纤之外，还必须实现其他东西，但在那之前，如果框架认为信道对于它们所提供的东西是必要的，它们将拥有如何使用信道的最终决定权，就像amphp的家伙们一样。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="514e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">与街区里新来的孩子相比</h1><p id="84f3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最近几个月，Go语言越来越受欢迎，尤其是因为它是围绕并发性而构建的。任何事情都可以与<code class="fe nc nd ne nf b">go</code>关键字同时执行，同步由互斥或<a class="ae ky" href="https://tour.golang.org/concurrency/2" rel="noopener ugc nofollow" target="_blank">通道</a>完成，这使得它非常容易使用。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4fff" class="nk me it nf b gy nl nm l nn no">names := make(chan string)</span><span id="5012" class="nk me it nf b gy np nm l nn no">go doFoo(names)<br/>go doBar(names)</span></pre><p id="dff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个角度来看，Go远远领先于PHP最初的并发解决方案。如果你需要一个完全多线程的东西，你可能想让你的软件在Go中运行，或者如果你想直接使用CPU线程，甚至Rust。</p><p id="df43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不是说PHP与任何并发模型都不兼容，但可以肯定的是，它的基础在核心上仍然是同步的，只是牺牲了方便性和更好的可理解性。与Go相比，<a class="ae ky" href="https://www.arp242.net/go-easy.html" rel="noopener ugc nofollow" target="_blank">后者苦于管道过多</a>。</p><p id="de82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想要一个像Go一样的真正的并发模型，那么PHP将不得不从头开始重写，但是这将在已经接受多线程的计算世界中打开许多可能性。</p><p id="e390" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这将带来更多对特性和独立性的关注，这是我一直非常强调的。</p></div></div>    
</body>
</html>