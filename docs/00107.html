<html>
<head>
<title>Please Stop Using console.log() for Debugging — It’s Broken</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">请停止使用console.log()进行调试，它已经坏了</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/please-stop-using-console-log-its-broken-b5d7d396cf15?source=collection_archive---------0-----------------------#2018-02-27">https://betterprogramming.pub/please-stop-using-console-log-its-broken-b5d7d396cf15?source=collection_archive---------0-----------------------#2018-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f22" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么坏了，怎么做更好</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0dd2e4b1848302e0e11da200b3594bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrF30OHMbyFYRbXr0S0Sng.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae ky" href="https://unsplash.com/s/photos/broken?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的代码中添加<code class="fe lv lw lx ly b">console.log()</code>可能是开发人员最常见的做法之一。然而，我在生活中花了很多时间来说服初学者(有时也是熟练的编码员)停止使用它来调试JavaScript。原因如下。</p><p id="2aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我必须承认我仍然在代码中使用<code class="fe lv lw lx ly b">console.log()</code>语句——旧习难改。我不是一个人:<a class="ae ky" href="https://www.clarkio.com/2017/04/25/debugging-in-nodejs/" rel="noopener ugc nofollow" target="_blank">大约75%的Node.js开发人员报告使用它</a>(2016年)来发现他们应用程序中的错误。</p><p id="0668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些情况下，这要么是最简单的做法，因为您确切地知道记录信息的内容和位置，要么是唯一要做的事情，因为您处于受限制的生产/嵌入式环境中，没有其他工具。然而，这不是一个借口，使例外导致你的日常实践。事实上，一般来说，<code class="fe lv lw lx ly b">console.log()</code>是痛苦的，容易出错——你将在下文中看到。还有更复杂的解决方案。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="66bf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">缺少上下文信息</h1><p id="5513" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">console.log()</code>强迫您在调试之前有意识地选择要记录的信息。你首先展示的东西是不充分的，甚至是完全不相关的，因为你通常还不知道发生了什么。</p><p id="2605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次你启动你的应用程序，你都会更进一步——无论是意识到你仍然没有在正确的时间记录正确的信息，还是浪费时间一次又一次地改变你的陈述，以显示新的信息和隐藏无关的信息。</p><h2 id="6c4a" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated"><strong class="ak">用调试工具反击</strong>:</h2><ul class=""><li id="6f99" class="np nq it lb b lc my lf mz li nr lm ns lq nt lu nu nv nw nx bi translated">调试时显示/观察任何JS变量<a class="ae ky" href="https://developers.google.com/web/updates/2015/07/preview-javascript-values-inline-while-debugging" rel="noopener ugc nofollow" target="_blank">(函数参数、局部变量、全局变量等)。)</a></li><li id="2bdd" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">探索<a class="ae ky" href="https://developers.google.com/web/tools/chrome-devtools/javascript/reference#call-stack" rel="noopener ugc nofollow" target="_blank">调用堆栈</a>以获得出现问题的完整上下文</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="62bb" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">信息太多</h2><p id="63bc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">算法通常被设计成自动化大量的小任务——循环和递归是基本的构建模块。与<code class="fe lv lw lx ly b">console.log()</code>一起，它导致大量的行显示在你面前，所以你可能很难找到正确的信息。</p><h2 id="a4b9" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated"><strong class="ak">用调试工具反击</strong>:</h2><ul class=""><li id="a689" class="np nq it lb b lc my lf mz li nr lm ns lq nt lu nu nv nw nx bi translated">创建<a class="ae ky" href="https://developers.google.com/web/tools/chrome-devtools/javascript/breakpoints#conditional-loc" rel="noopener ugc nofollow" target="_blank">条件断点</a>以在满足特定条件时暂停执行，这样您就可以花时间分析发生了什么</li><li id="4c06" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">观看<a class="ae ky" href="https://developers.google.com/web/tools/chrome-devtools/javascript/reference#watch" rel="noopener ugc nofollow" target="_blank">自定义JS表达式</a>(变量、条件等。)这样你就不会浪费时间在循环的每一步推导相同的表达式</li><li id="9986" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">除了您的标准应用程序日志之外，创建一个<a class="ae ky" href="https://blog.risingstack.com/node-js-logging-tutorial/" rel="noopener ugc nofollow" target="_blank">调试日志分类</a>，以便根据需要为感兴趣的域(如文件、服务、类等)激活调试消息。).</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="a39f" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">不可信的信息</h2><p id="20e7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">你不能总是相信<code class="fe lv lw lx ly b">console.log()</code>报告的信息，因为根本没有关于它的标准化行为<em class="od"> </em>。你真的不知道引擎盖下会发生什么。</p><p id="810a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候，在控制台还没有激活的时候调用<code class="fe lv lw lx ly b">console.log()</code>只会导致对象<a class="ae ky" href="https://stackoverflow.com/questions/23392111/console-log-async-or-sync" rel="noopener ugc nofollow" target="_blank">的引用<em class="od"> </em>被排队</a>，而不是控制台将包含的输出。</p><p id="4cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一种变通方法，您需要克隆信息或序列化它的快照。<a class="ae ky" href="https://stackoverflow.com/questions/23392111/console-log-async-or-sync" rel="noopener ugc nofollow" target="_blank">渲染与将来与记录的对象的交互(例如，在浏览器控制台中扩展对象属性)异步发生</a>(被限制为限速更新)。</p><h2 id="a538" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated"><strong class="ak">用调试工具反击</strong>:</h2><ul class=""><li id="e1fe" class="np nq it lb b lc my lf mz li nr lm ns lq nt lu nu nv nw nx bi translated"><a class="ae ky" href="http://mrbool.com/how-to-debug-asynchronous-javascript-with-chrome-devtools/33573" rel="noopener ugc nofollow" target="_blank">异步堆栈跟踪</a>(现在是Chrome的默认设置)允许你检查当前事件循环之外的函数调用，就像一次对异步回调发起者的上下文感知旅行</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="152e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">改变代码行为</h1><p id="e23f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">调试异步代码的标准方法是控制台日志<code class="fe lv lw lx ly b">1</code>、<code class="fe lv lw lx ly b">2</code>、<code class="fe lv lw lx ly b">3</code>、<code class="fe lv lw lx ly b">4</code>等。(即，在您得到正确的顺序之前，在您期望的输出之前执行的所有步骤)。</p><p id="2ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果，您修改了代码，从而修改了它的运行方式，这可能导致真正难以跟踪的、不稳定的行为。完成调试后，您还必须记得删除代码中所有零散的控制台日志。</p><h2 id="8429" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated"><strong class="ak">用调试工具反击</strong>:</h2><ul class=""><li id="cb78" class="np nq it lb b lc my lf mz li nr lm ns lq nt lu nu nv nw nx bi translated">当真正理解一个应用程序的流程时，一步一步地进行<a class="ae ky" href="https://developers.google.com/web/tools/chrome-devtools/javascript/reference#stepping" rel="noopener ugc nofollow" target="_blank">是必须的</a></li><li id="8f50" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">当真正理解异步回调的计时时，<a class="ae ky" href="https://developers.google.com/web/tools/chrome-devtools/javascript/breakpoints" rel="noopener ugc nofollow" target="_blank">断点</a>是你最好的朋友(选择最适合你的问题的类型)</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="489b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">JavaScript调试工具包</h1><p id="5d04" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了帮助您调试完整的JS应用程序，您实际上需要一些工具:</p><ul class=""><li id="ba36" class="np nq it lb b lc ld lf lg li oe lm of lq og lu nu nv nw nx bi translated"><a class="ae ky" href="https://developers.google.com/web/tools/chrome-devtools/" rel="noopener ugc nofollow" target="_blank"> Chrome DevTools </a>现在支持<a class="ae ky" href="https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4" rel="noopener"> Node.js调试</a>以及在本地或<a class="ae ky" href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/" rel="noopener ugc nofollow" target="_blank">远程浏览器</a>中运行的js代码(例如，在移动设备上)</li><li id="7f54" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">Node.js <a class="ae ky" href="https://github.com/visionmedia/debug" rel="noopener ugc nofollow" target="_blank">调试</a>模块</li></ul><p id="e551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你认为在运行你的测试时不能使用调试器，考虑阅读<a class="ae ky" href="https://peterlyons.com/js-debug" rel="noopener ugc nofollow" target="_blank">这篇文章</a>和你在互联网上很容易找到的其他类似资源。</p><p id="0899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，可能没有一个放之四海而皆准的解决方案，因此，如果我没有说服您，并且您不想将调试器作为您的主要调试工具，我会建议您阅读<a class="ae ky" href="https://medium.com/@shanebdavis/debuggers-are-broken-become-a-console-log-samurai-f352accd9ef6" rel="noopener">这篇文章</a>以使您的日志记录更加智能。人们也可以提到第三方模块，如用于JavaScript的<a class="ae ky" href="https://github.com/winstonjs/winston" rel="noopener ugc nofollow" target="_blank"> winston </a>或<a class="ae ky" href="https://github.com/pimterry/loglevel" rel="noopener ugc nofollow" target="_blank"> loglevel </a>是相当好的可定制日志程序，但在我看来，我更喜欢将它们用于生产级日志(例如，信息、警告、错误等)。).其他模块如<a class="ae ky" href="https://github.com/visionmedia/debug" rel="noopener ugc nofollow" target="_blank"> debug </a>更适合调试/跟踪日志。</p></div></div>    
</body>
</html>