# 向我解释 Protobuf 就像我五岁一样

> 原文：<https://betterprogramming.pub/explain-protobuf-to-me-like-im-five-e418c99a372a>

## *什么是协议缓冲区，它们是如何工作的？*

![](img/b56cbd7c70a0cc17b8ec446f05ff5f63.png)

丹·弗里曼在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片。

协议缓冲区，也称为 protobufs，无处不在。

如果你有一个包含几十个或者几百个*微服务*的大型系统，很有可能你用的是 protobufs。

虽然 protobufs 无处不在，但我们大多数人只关心如何使用它们来使系统工作。但是你知道，乐趣总是在于细节。

在本文中，让我们试着深入一点。希望读完这篇文章后，我们至少会对 protobufs 有更好的了解。

# 那么……什么是原蟾蜍？

*   一个*序列化*(当然还有*反序列化*)数据的协议。
*   想想 JSON 或 XML——proto bufs 是一种类似的协议。
*   在微服务之间通信的情况下，protobufs 比 JSON 或 XML 更可取。当您公开公共 API 或与浏览器通信时，JSON 更合适。
*   这个协议远没有 JSON 或 XML 冗长，这对性能有好处。
*   Protobufs 专注于*效率*，放弃了人类的可读性。但是当然，它是机器可读的。不然也没什么用！
*   protobufs 的效率如何？它们只是用比其他协议更少的字节来编码数据！
*   Protobufs 依赖于生成的代码。所以基本上，有一个带 protobufs 的编译器，在你在一个`.proto`文件中写完数据定义后，它会为你生成代码。形式上，我们称之为`message`。
*   本质上，在`.proto`文件中，您键入您的`message`定义(以及您的 API 端点)。然后你编译它。它以你选择的语言给你生成代码。之后，您可以只使用生成的代码来初始化您的数据对象并传递它们。

等等，我们在实现和使用细节上花了太多时间。我们继续吧。我们今天的目的是了解这个著名的协议是如何工作的。

# Protobufs 如何对我的数据进行编码？

假设你有两个微服务，Ex 和 Wye。你想在他们之间交流。使用 protobufs，当您从 Ex 向 Wye 发送一些数据时，必须将数据转换成可传输的形式，以便它可以在网络上传输，这实质上意味着转换成字节。这就是 protobufs 获胜的地方。由于其简单的方法，protobufs 快速、简单、小巧。

让我们从一个简单的`.proto`文件开始，它有一个很酷的`message`定义，您用它来在 Ex 和 Wye 之间进行通信:

```
message very_cool_message {
    int32 coolness = 1;
}
```

那么 protobufs 会如何编码这个消息呢？

为了理解这一点，让我们介绍一下`varint`——一种序列化整数的方法。

我们将通过一个例子来尝试直接理解`varint`:

*   选择一个数字(比如，`2009`)。
*   将其转换为二进制:`11111011001`
*   将其分成一组七位:`0001111 1011001`
*   颠倒分组顺序:`1011001 0001111`
*   在每组开头加一位，组成字节:
    `01011001 00001111`
*   如果当前字节后有一个字节，则设置该字节的 MSB:
    `11011001 00001111`
*   注意，我们已经设置了第一个字节的 MSB，因为它后面是另一个字节。但是我们没有像预期的那样设置第二个字节的 MSB。这个 MSB 基本上告诉我们是否已经到了数的末尾。
*   最后，这是我们的十六进制编码表示:`D9 0F`

这就是`varint`表示数字`2009`的方式。现在让我们看看添加了一个字段的`.proto`定义:

```
message very_cool_message {
    int32 coolness = 1;
    int32 uncoolness = 2;
}
```

我们有两个字段，protobufs 必须将它们编码成一个字节流。正如我们已经讨论过的，数据将在`varints`中。但问题是，在一个字节流中，我们如何区分不同的值？

这就是序列号发挥作用的地方。虽然看起来我们只是给了字段一些序列号，但是在二进制流中，序列号是作为键来工作的。它也被编码为`varints`，另一条信息被称为`wire_type`。

线类型本质上是数据类型(例如`varint`或`64`位或`32` 位)。

因此 protobufs 将序列号和`wire_type`编码在`varint`中，如下所示:

```
(field_number << 3) | wire_type
```

我们可以看到，上面的最后三位表示`wire_type`。简单。

还记得我们是如何将 2009 编码成`D9 0F`的吗？这只是数字的`varint`编码。我们将不得不在它前面添加另一个字节来表示密钥和线路类型。对于`varint`来说，`wire_type`就是`0`。关键是我们第一条消息中的`1`。所以我们得到:

```
(1 << 3) | 0 = 1000
As byte: 0000 1000
```

所以 protobuf 会这样编码:

```
08 D9 0F
```

让我们假设上面的消息有另一个数字(比如说，`344`)作为`uncoolness`值。按照同样的编码方法，我们将得到:

```
10 D8 02
```

最终形式将是:

```
08 D9 0F 10 D8 02
```

# 如何解码

假设我们被给予`10 D8 02`，我们现在将解码它。

第一个字节表示随后的值是一个带有字段号(又名 key) `2`的`varint`。现在读取下一个字节。我们看到它有 MSB 设置。所以也要读下一个字节。它没有 MSB 设置。我们现在删除这些 msb，得到两组 7 位，如下所示:

```
1011000 0000010
```

颠倒这些组的顺序:

```
0000010 1011000
```

现在将其转换为十进制:

```
2^3 + 2^4 + 2^6 + 2^8
= 8 + 16 + 64 + 256
= 344
```

我们得到我们期望的。

所以为了解码一组数据，我们读取字段号和`wire_type`，读取字节，并相应地进行转换。

![](img/b845df0add8955241b673fb279bb73b7.png)

[Julianna Arjes](https://unsplash.com/@jmarjes?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

# 弦乐呢？

一个显而易见的问题出现了:字符串呢？

对一个字符串进行编码，`wire_type`就是`2`。这意味着首先会有一个`varint`来表示字符串的长度，然后是指定的字节长度。

想一个这样的信息:

```
message cool_name {
    string name = 1;
}
```

我们为这个名字取了一个值(比如说，`syma`)。让我们对此进行编码:

*   场号是`1`，是`2`的一个`wire_type`。所以第一个字节会是
    `0000 1010`，也就是`0A`。
*   既然是`2`的`wire_type`，那么下面的`varint`将是字符串长度的表示:`04`。请注意，MSB 未设置，因为长度信息以一个字节结束。
*   所以我们对长度进行了编码。现在将有四个字节编码字符串的四个字母:`73 79 6d 61`。
*   最后，我们还有`0A 04 73 79 6d 61`。
*   解码很简单。只是按照相反的顺序。

# 结论

就是这样。protobufs 编码和解码其他数据类型(如有符号/无符号整数、嵌套消息类型等)的方式有一些不同。但是如果您理解了 protobufs 如何处理整数和字符串类型的数据，那么其余的就很容易理解了。

感谢阅读！再见！

如果你喜欢这篇文章，考虑订阅我推荐的媒体！https://medium.com/subscribe/@mottakin