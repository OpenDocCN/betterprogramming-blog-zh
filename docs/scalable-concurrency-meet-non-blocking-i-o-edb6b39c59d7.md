# 可扩展的并发性—满足非阻塞 I/O

> 原文：<https://betterprogramming.pub/scalable-concurrency-meet-non-blocking-i-o-edb6b39c59d7>

## 我们如何实施非阻塞 I/O 来提高应用程序的性能

![](img/1d700ce162e369ddbee2cb33fd7e2849.png)

由[本杰明·沃罗斯](https://unsplash.com/@vorosbenisop?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/flow?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

# 为什么非阻塞 IO 更具可扩展性？

在几乎所有的现代 web 应用程序中，我们都有大量的 I/O。我们与数据库对话，请求记录或插入/更新它们。更多的时候，我们从硬盘上访问一些文件，这也是一种 I/O 操作。

我们正在与不同的第三方网络服务，如 OAuth 集成或其他东西。如今，许多 web 应用程序也作为微服务运行，它们必须通过 HTTP 请求与同一应用程序的其他部分进行对话。

如果你用 [Ruby](https://www.ruby-lang.org/en/) 、 [Python](https://www.python.org/) 或许多其他语言编写你的 web 应用程序，所有这些与 I/O 相关的任务在默认情况下都是阻塞的，这意味着进程会一直等到收到响应，然后继续执行程序。

另一方面，Node.js [1]默认使用非阻塞 I/O。因此，流程可以继续在其他地方工作，并在请求完成时执行回调或承诺。

这使得操作系统可以充分利用一个 CPU 内核。但是，非阻塞编程模型在其他编程语言中也是可能的吗？

是的，它是！在这篇博文中，我们将讨论如何利用(几乎)非阻塞 I/O 在 Ruby 中编写一个本地事件循环，然后看看如何改进这种设计。

# **原生实现**

首先，让我们来看看一个正在工作的本机实现:

在讨论如何改进这个设计之前，让我们先简单讨论一下`IO.select`方法，因为这是我们事件循环的核心。

# **IO.select**

正如注释中提到的，这种方法是跨平台的，可以在运行程序的任何地方使用。

它采用的第一个参数是程序想要读取的 I/O 描述符数组——文件描述符、Unix 套接字或类似的东西。

第二个数组也是一个 I/O 描述符数组，但这次是用于可写连接的。

第三个数组是一个错误数组。

最后，最后一个参数是超时。这是方法阻塞的最长时间。因此，在上面的例子中，我们可以说一个节拍至少是 10 ms，这取决于数据处理所花费的时间。

# **朴素事件循环的设计探讨**

当我们看一看这段代码时，缺点是很明显的。并发性带来的复杂性与业务逻辑纠缠在一起，很难分离。

事件循环知道我们的业务逻辑，因为它马上调用方法。我们可以在处理所有读/写事件的寄存器的帮助下改进这一点。

寄存器可以利用一个简单的散列和两个键`read`和`write`，并在那里保存回调。在 Ruby 中，回调可以是任何块、进程或 lambdas。同样，一个简单的实现可能如下所示:

现在，我们已经将业务逻辑从并发逻辑中分离出来。但是，这仍然会导致一种回调地狱。

JavaScript 曾经有过很多这样的问题，但它通过承诺和最近的[异步等待](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)特性解决了这个问题。这样，您可以编写并发运行的顺序代码。

尽管如此，我们在这个设计中还有其他缺点。它仍然使用一组固定的描述符，我们没有地方在运行时配置它。此外，每一个回调都会得到每一个读取事件的通知，尽管我们可能不希望这样。

我们如何改进呢？符合反应器模式。

# **反应堆模式**

[反应器模式](https://en.wikipedia.org/wiki/Reactor_pattern)是大多数事件循环的基础。它将应用程序逻辑与交换实现完全分离，因此使代码更易于维护和重用。

它由两个主要部分组成:一个事件多路复用器和一个调度器，并与另外两个部分——资源和请求处理程序——一起工作。

反应器使用单线程事件循环，在事件多路复用器中注册资源，并在事件触发后分派给回调。

正如我们在示例中看到的，这样就不需要阻塞 I/O，因此进程可以最大限度地利用 CPU 内核。

# **实现**

Ruby 中著名的实现有 [EventMachine](https://github.com/eventmachine/eventmachine) 、[赛璐珞](https://celluloid.io/)和 [async](https://github.com/socketry/async) 。Python 也有——至少有一个——非常好的实现，即 [Twisted](https://twistedmatrix.com/) 。PHP 有 [ReactPHP](https://reactphp.org/) ，我很确定几乎所有其他语言也有一些很好的实现。

# **缺点**

和其他任何东西一样，反应器也有一些缺点，你必须意识到这些缺点，以做出一个好的决定，使用这种模式对你的用例是否有意义。

主要的缺点是，如果其中一个回调函数很贪婪，并且占用了大量的时间，那么它将阻塞所有的回调函数，直到它结束。

本质上，一个反应器是*类型的*协作并发。如上所述，反应器是单线程的，如果 CPU 在一次回调中被充分利用，那么其他的事情都必须等待。

另一个限制是反应器模式很难调试，因为逻辑流程不是程序运行的方式。这也给开发人员带来了额外的麻烦。

# **从这里开始**

对于并发 I/O 来说，反应器模式是最好的吗？

实际上，不，仍然有改进的方法。如上所述，传统的反应器与解复用器同步调度事件，并且必须等待回调完成。我们也可以用[前摄器模式来实现这种异步。](https://en.wikipedia.org/wiki/Proactor_pattern)

如果您仍然需要更高的性能，请使用硬件！在某些时候，这是你最好的选择。如果你需要这样做，那么微服务架构就会派上用场，因为你可以独立地扩展应用程序的小部分。

[1] Node.js 只是一个例子，因为这是使用非阻塞 I/O 作为默认的最常用的平台。