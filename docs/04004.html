<html>
<head>
<title>Next.js for React: Why You Should Give It a Try Right Now</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js for React:为什么你现在应该尝试一下</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/next-js-for-react-why-you-should-give-it-a-try-right-now-e3b1886e4f20?source=collection_archive---------4-----------------------#2020-03-18">https://betterprogramming.pub/next-js-for-react-why-you-should-give-it-a-try-right-now-e3b1886e4f20?source=collection_archive---------4-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="511b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们生活在服务器端渲染的时代。Next.js在这方面很棒。这里有几个你应该去看看的理由。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/045b64bbdbbfb18bfaf3cb3fc3067ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LA8JwxES907JHxy_w52oA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@rockthechaos" rel="noopener ugc nofollow" target="_blank"> Kolleen Gladden </a>在<a class="ae ky" href="https://unsplash.com/photos/ij5_qCBpIVY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React.js和其他前端库和框架早已成为现代web开发的规范——事实上，随着React Native等技术的出现，React甚至扩展到了移动应用的开发。</p><p id="59a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，开发仍在继续，甚至有更新的技术可用，包括新的框架和库，旨在使我们的工作与原来的更好。例如，对于<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React.js </a>，有框架Gatsby和Next.js，我们现在将讨论后者。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4bd5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Next.js是什么——它的目的是什么？</h1><p id="af4c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Next.js是一个React.js框架，用于各种目的。Next.js最初设计用于在服务器端呈现React应用程序，现在允许您生成静态页面并在应用程序中使用AMP。它可以很容易地连接到Node.js以了解其生产状态。</p><p id="e978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Next.js和我们知道的React.js非常相似。当然，您以不同的方式建立了下一个项目，但是最终您编写了React代码。Next会为我们完成剩下的工作。</p><p id="1d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这种简单性和可以让任何React项目稍微好一点的强大功能，我认为没有理由忽视Next.js。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="73e7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">开始使用Next</h1><ul class=""><li id="f30b" class="mz na it lb b lc mu lf mv li nb lm nc lq nd lu ne nf ng nh bi translated">为您的下一个项目创建一个空文件夹。在其内部，键入:<br/> <code class="fe ni nj nk nl b">yarn init -y<br/> yarn add react react-dom next<br/> mkdir pages</code></li><li id="ff38" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">在<code class="fe ni nj nk nl b">pages</code>文件夹中，我们将创建下一个应用程序的所有页面。到目前为止，你的项目文件夹应该是这样的:<br/>├──<code class="fe ni nj nk nl b">package.json</code><br/>├──<code class="fe ni nj nk nl b">pages</code><br/>│└──<code class="fe ni nj nk nl b">index.js</code><br/>└──<code class="fe ni nj nk nl b">yarn.lock</code></li><li id="8045" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">现在，我们需要调整我们的<code class="fe ni nj nk nl b">packages.json</code>文件，就像这样:</li></ul><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="db8d" class="nv md it nl b gy nw nx l ny nz">“scripts”: {<br/>  “dev”: “next”,<br/>  “build”: “next build”,<br/>  “start”: “next start”,<br/>  “export”: “next build &amp;&amp; next export”<br/>}</span></pre><p id="3d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您应该能够看到的，现在我们可以运行<code class="fe ni nj nk nl b">yarn run dev</code>来启动我们的开发服务器。</p><p id="11df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了构建生产版本，我们可以运行<code class="fe ni nj nk nl b">yarn run build</code>和<code class="fe ni nj nk nl b">yarn start</code>来运行我们的生产服务器。</p><p id="2bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们也可以用Next用<code class="fe ni nj nk nl b">yarn run export</code>创建一个静态网站。在本文的后面，我们将会看到这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2556" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更好的性能</h1><p id="b135" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当比较服务器端呈现(SSR)和客户端呈现(CSR)时，通常首先给出支持SSR的论点，客户端呈现是React.js的标准。而且说白了:是的，很多情况下，SSR页面都比客户端快。</p><p id="9472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是相对符合逻辑的，但要理解它，我们需要看看是什么使这两种方法不同。</p><h2 id="1e77" class="nv md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">企业社会责任模式</h2><ol class=""><li id="06ef" class="mz na it lb b lc mu lf mv li nb lm nc lq nd lu ol nf ng nh bi translated">服务器用HTML样板文件响应来自浏览器的请求。</li><li id="e10b" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ol nf ng nh bi translated">这个HTML中的少数几样东西之一是包含的JavaScript文件。</li><li id="84e7" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ol nf ng nh bi translated">这个JavaScript文件包含React.js和我们编写的React代码。</li><li id="9a81" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ol nf ng nh bi translated">在浏览器识别出HTML中的链接后，它还必须加载并处理JavaScript文件。</li><li id="4402" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ol nf ng nh bi translated">浏览器现在运行React和我们的React代码。我们网站的渲染就是这样开始的。</li><li id="4444" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ol nf ng nh bi translated">渲染生成实际的HTML代码，用内容填充我们最终的网站。浏览器必须在渲染后显示这一点。</li></ol><h2 id="55c9" class="nv md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">SSR的模式</h2><ol class=""><li id="833b" class="mz na it lb b lc mu lf mv li nb lm nc lq nd lu ol nf ng nh bi translated">服务器用我们需要在网站上显示的完整HTML代码来响应浏览器的请求。</li><li id="63cb" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ol nf ng nh bi translated">呈现并显示HTML代码。页面已经可见。</li><li id="16ce" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ol nf ng nh bi translated">之后(或同时)，浏览器加载JavaScript文件(与CSR变体相比，该文件较小)。</li><li id="3afa" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ol nf ng nh bi translated">浏览器执行React和我们的React代码，这些代码只包含组件背后的逻辑。</li><li id="cbe0" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ol nf ng nh bi translated">现在，页面不仅是可见的，而且是可交互的。</li></ol><p id="29b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得应该明确，CSR对于同样的结果，需要付出更多的努力。</p><h2 id="17dc" class="nv md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">但是现在让我们来看一个实际的比较</h2><p id="53ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了进行比较，我使用了两个实际上完全相同的现有web应用程序。<br/>一个完全用Next.js实现(即用SSR)，一个用React.js实现(即用CSR)。</p><p id="0fbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这两个web应用程序是专门为比较SSR和CSR而开发的，因此是性能差异的极端例子——然而它们是演示的理想选择。</p><h2 id="92b2" class="nv md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">首先，React.js版本:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/df369e9f3a47f43ed30997ccae87a237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zThVf19hnhU8NUM2En5Y7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对<a class="ae ky" href="https://nextjs-cra.goldenshun.now.sh/" rel="noopener ugc nofollow" target="_blank">https://nextjs-cra.goldenshun.now.sh/</a>的Chrome审计</p></figure><h2 id="5898" class="nv md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">其次，对Next.js进行同样的审计:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/ceee493efe92711e5e46ef8d6b436bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HiFr8F32x3DYzm78CvDRXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Chrome审计:<a class="ae ky" href="https://nextjs-cra.goldenshun.now.sh/nextjs" rel="noopener ugc nofollow" target="_blank">https://nextjs-cra.goldenshun.now.sh/nextjs</a></p></figure><h2 id="24ce" class="nv md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">有什么值得注意的</h2><p id="57a9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在带有React的客户端版本中，可见网站的更长时间是明显可见的。这本身并不令人惊讶，但特别是在这个例子中，不同的油漆之间的差异，正如他们在审计中所称的那样，是显著的。</p><p id="5b5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，不同的是网站互动的持续时间。在这里，Next.js并没有领先太多。然而，如果你考虑到网站之前已经呈现给用户，Next.js显然提供了更好的用户体验。所以这个例子中最明显的赢家是Next.js。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3ef5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">AMP构建页面</h1><p id="9c51" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="on"> AMP </em>代表<em class="on">加速移动网页</em>，是为加速移动设备上的网站而制造的。</p><p id="cbab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它提供了自己的HTML标签。此外，只支持文档头部区域的CSS。</p><p id="16c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这项技术，移动设备上网站的加载和渲染时间应该会减少。虽然一开始将你的web应用程序切换到AMP可能看起来很复杂，但Next.js提供了我们需要的一切——并从我们手中拿走了很多工作。</p><h2 id="a678" class="nv md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">让我们来看一个代码示例:</h2><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="5b03" class="nv md it nl b gy nw nx l ny nz">export const config = { amp: true }</span><span id="820f" class="nv md it nl b gy oo nx l ny nz">export default function Index(props) {<br/>  return &lt;p&gt;Welcome to the AMP only Index page!!&lt;/p&gt;<br/>}</span></pre><p id="3c9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你检查网站的来源时，你应该会看到一些差异，如果我们没有激活AMP，这些差异就不会存在。</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="2bed" class="nv md it nl b gy nw nx l ny nz">&lt;body class="amp-mode-mouse" style="opacity: 1; visibility: visible; animation: none;"&gt;<br/>  &lt;!-- __NEXT_DATA__ --&gt;<br/>  &lt;p&gt;Welcome to the AMP only Index page!!&lt;/p&gt;<br/>&lt;/body&gt;</span></pre><p id="bb97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在当前设置<code class="fe ni nj nk nl b">{ amp: true }</code>的情况下，AMP页面始终会发送给用户。</p><p id="a8ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们也可以建立AMP的混合使用:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="5a5a" class="nv md it nl b gy nw nx l ny nz">import { useAmp } from ‘next/amp’</span><span id="273e" class="nv md it nl b gy oo nx l ny nz">export const config = { amp: ‘hybrid’ }</span><span id="463e" class="nv md it nl b gy oo nx l ny nz">export default function Index(props) {<br/>  const isAmp = useAmp()<br/>  return &lt;p&gt;{isAmp ? ‘AMP’ : ‘normal’}&lt;/p&gt;<br/>}</span></pre><p id="a25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在URL中的<code class="fe ni nj nk nl b">/?amp=1</code>下访问该页面的AMP版本。</p><p id="b52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在AMP路线下，<code class="fe ni nj nk nl b">AMP</code>应该显示给用户。如果只是查普通版，应该会看到<code class="fe ni nj nk nl b">normal</code>。那是因为当我们看到AMP版本时，<code class="fe ni nj nk nl b">isAmp</code>将会是<code class="fe ni nj nk nl b">true</code>。</p><blockquote class="op oq or"><p id="20ff" class="kz la on lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">"<code class="fe ni nj nk nl b">useAmp()</code>是一个钩子，用于知道是否有任何组件(不仅仅是页面)被用于AMP。"</p><p id="0b8c" class="kz la on lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">— Next.js <a class="ae ky" href="https://nextjs.org/learn/excel/amp/hybrid-amp" rel="noopener ugc nofollow" target="_blank">文档</a></p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2da0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Easy Node.js实现</h1><p id="cf2e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们需要为Node.js应用程序创建一个可运行的文件。姑且称之为<code class="fe ni nj nk nl b">server.js</code>。所以我们的设置现在看起来像这样:</p><p id="722d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">├──<code class="fe ni nj nk nl b">package.json</code><br/>├──<code class="fe ni nj nk nl b">pages</code><br/>│└──<code class="fe ni nj nk nl b">home.js</code><br/>├──<code class="fe ni nj nk nl b">server.js</code><br/>└──<code class="fe ni nj nk nl b">yarn.lock</code></p><p id="60b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于整个应用程序的Node.js端，我们将使用Express.js。如您所见，我们在<code class="fe ni nj nk nl b">pages</code>文件夹中只有一个文件，<code class="fe ni nj nk nl b">home.js</code>。像在Next.js中一样，这当然应该可以在<em class="on"> </em> <code class="fe ni nj nk nl b">/home</code>下访问。在这个文件中，我们只显示这是一个Next.js页面的消息:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="9da0" class="nv md it nl b gy nw nx l ny nz">export default () =&gt; (<br/>  &lt;p&gt;Next.js site&lt;/p&gt;<br/>)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="7cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们已经设置了<code class="fe ni nj nk nl b">unequal production</code> <strong class="lb iu"> </strong>，那么我们仍然处于Next.js开发模式，在这里我们可以进行实时修改:<br/> <code class="fe ni nj nk nl b">const dev = process.env.NODE_ENV !== "production"</code></p><p id="1b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们已经将其设置为<code class="fe ni nj nk nl b">production</code>，在我们可以从我们的节点应用程序(<code class="fe ni nj nk nl b">server.js</code>)使用我们的Next.js应用程序之前，我们需要运行纱线构建:<br/> <code class="fe ni nj nk nl b">const dev = process.env.NODE_ENV === "production"</code></p><p id="5e2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当然，您应该总是设置生产模式，并因此再次执行构建过程。一旦你完成了这些，你就可以像往常一样用Node.js运行<code class="fe ni nj nk nl b">server.js</code>和<code class="fe ni nj nk nl b">node server.js</code>。</p><p id="163f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你现在给<code class="fe ni nj nk nl b">localhost:8080</code>打电话，你应该会看到我们Express.js app的回应。如果调用<code class="fe ni nj nk nl b">localhost:8080/home</code>，Next.js会照常处理请求，并且会渲染输出<code class="fe ni nj nk nl b">pages</code>文件夹中的<code class="fe ni nj nk nl b">home.js</code>文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f64c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建静态页面</h1><p id="b07e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们通常谈论SSR时，我们指的是我们有一个活动的后端，它理论上可以根据每个请求在服务器上完整地呈现页面，然后将其作为服务器端呈现发送给用户。</p><p id="fcab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，在Next.js中，每次我们使用Next.js提供的<code class="fe ni nj nk nl b">getServerSideProps</code>函数时，页面都会呈现在服务器上。</p><p id="82df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了它，在呈现页面并将其发送给用户之前，我们可以在后端获取一个API，并将从中获取的数据嵌入到我们的前端，而最终用户不会注意到API调用。<br/>点击阅读更多关于<code class="fe ni nj nk nl b">getServerSideProps</code> <a class="ae ky" href="https://nextjs.org/docs/basic-features/pages#server-side-rendering" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="ccac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有在这种情况下，随着每个请求在服务器上重新呈现页面才是合理的——否则，我们会浪费处理能力。</p><p id="9404" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，即使我们想部署下一个应用程序，我们也需要一个合适的后端来集成我们的应用程序。</p><p id="1793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们的网站是静态的，我们想把它上传到一个简单的网络空间呢？</p><p id="d28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以将Next.js应用程序完全呈现为静态文件。这意味着我们获得了所有页面所需的HTML文件——功能中包含的JavaScript文件，当然还有所有的CSS文件。它是这样工作的:</p><ul class=""><li id="32ee" class="mz na it lb b lc ld lf lg li ox lm oy lq oz lu ne nf ng nh bi translated">如上面的设置所示，我们需要在我们的<code class="fe ni nj nk nl b">package.json</code>中为此创建一个脚本:<code class="fe ni nj nk nl b">"export": "next build &amp;&amp; next export"</code>。</li><li id="be4b" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">现在，我们可以运行<code class="fe ni nj nk nl b">yarn run export</code>，我们的Next.js应用程序的生产版本就创建好了。然后直接转换成静态页面。</li><li id="93fe" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">因此，我们将看到一个<code class="fe ni nj nk nl b">out</code>目录，包含我们的整个静态应用程序。在目录中，我们应用程序的每个页面都将有一个HTML站点。<br/>├──<code class="fe ni nj nk nl b">out</code>T10】│├──<code class="fe ni nj nk nl b">404.html</code>t11】│└──<code class="fe ni nj nk nl b">home.html</code>T12】├──<code class="fe ni nj nk nl b">package.json</code>t13】├──<code class="fe ni nj nk nl b">pages</code><br/>│└──<code class="fe ni nj nk nl b">home.js</code><br/>├──<code class="fe ni nj nk nl b">server.js</code><br/>└──<code class="fe ni nj nk nl b">yarn.lock</code></li></ul><p id="b254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们只需将文件夹的内容上传到我们的网络空间，就大功告成了。</p></div></div>    
</body>
</html>