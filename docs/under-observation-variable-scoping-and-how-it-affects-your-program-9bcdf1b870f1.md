# 观察中——变量作用域及其对程序的影响

> 原文：<https://betterprogramming.pub/under-observation-variable-scoping-and-how-it-affects-your-program-9bcdf1b870f1>

## 让我们来看一看

![](img/16273a9fefbd893b9c5f5f2dfeb2bc69.png)

保罗·斯科鲁普斯卡斯在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

当有人开始编程时，向他们介绍的一个基本概念是名称解析，也就是*作用域*。范围非常重要，因为它们决定了变量/方法是否可见。此外，作用域有助于创建一个整洁的全局名称空间，因为您可以在子作用域中“隐藏”变量。

在学习了编程的基础知识之后，作用域仍然非常重要，因为它们对于了解更高级的概念*元编程*中发生的事情是必不可少的。尤其是在 Ruby 中，许多元编程工具通过改变代码执行的范围来工作。例如，方法`class_eval`或`instance_eval`将把范围弯曲到另一个对象/类。

为了更好地理解这个概念，让我们仔细看看作用域。存在什么类型的作用域，通常使用什么级别的作用域？

# 什么是范围？

定义是:作用域是程序的一部分。

这听起来很模糊。所以还是说清楚一点吧。作用域是程序中变量可见和可访问的部分。变量可见的部分可以嵌套在不同的层次中——稍后会详细介绍。

在计算机科学中，有两种类型的作用域:词法的和动态的。类型取决于您使用的编程语言。

## 词法范围

这是所有现代语言实现的类型，据我所知。词法范围意味着源代码的上下文就是范围。例如:

所有变量都是在当前方法的上下文中定义的。在块内部，我们从上一级方法中访问变量。但是当你阅读代码时，根据上下文,`method_variable`的值是什么就很清楚了。

## 动态范围界定

这种实现在许多语言中已经不再使用了。一些仍在使用并以这种方式实现作用域的是 [Perl](https://www.perl.org/) (仅当用户选择加入时) [Bash](https://www.gnu.org/software/bash/) 、 [Emacs Lisp](https://www.emacswiki.org/emacs/EmacsLisp) 和 [LaTeX](https://www.latex-project.org/) 。

那么，动态范围是如何工作的呢？名称解析取决于运行时。我们来调整一下上面的例子，这样就能看出区别了。(记住，Ruby 不使用动态范围，所以这是一个伪 Ruby 代码，不会在您的控制台上工作)。

[https://gist . github . com/choall in/800 ed 8 a7d 966 b 260 b 020 E0 e 3c 54 eaab 2](https://gist.github.com/choallin/800ed8a7d966b260b020e0e3c54eaab2)

在动态范围语言中，运行库在当前块中查找变量，然后在上面的调用堆栈中查找变量。在我们的例子中，方法`multiply_by_two`的变量`multiplicand`和`2`被初始化，方法`multiply_by_three`和`3`被初始化。`test_method`的结果实际上取决于它所调用的方法。

有了这个例子，缺点就很明显了。动态作用域消除了引用透明性的好处，因为它依赖于调用堆栈/运行时，并且很难推断出变量的值。

我们通常有哪些层次的范围界定？

# 范围的级别

## 全球的

顾名思义，*全局作用域*是指一个变量或方法在整个应用程序中可见。这对于小脚本来说不一定是坏事，但是随着应用程序的增长，大量使用全局变量会使代码难以维护。

此外，当涉及到[多线程](https://medium.com/better-programming/multithreaded-ruby-synchronization-race-conditions-and-deadlocks-f1f1a7cddcea)时，全局变量变得特别复杂。

## 组件

在*模块范围*中，变量在模块内部可见，但模块可以跨多个文件构建。

## 文件

在*文件范围*中，变量仅在文件内部可见。这个级别主要在 C 中使用(有时在 C++中也是如此)。在 C 中，可以在文件中定义一个变量，但不能导出它，所以其他函数不能使用它。如果开发者想使用一个文件范围的变量，他们必须在文件的开始定义它，并且不能在函数中。

在文件是模块的特殊情况下，文件作用域与模块作用域非常相似。

## 功能

在*函数作用域*中，函数定义在一个变量中，并且可以在该函数的任何子块中访问。

这就是我们在词法范围示例中使用变量`method_variable`的方式。

在 JavaScript 函数中，函数作用域是用`var`关键字初始化的每个变量的默认作用域级别(如果变量在没有任何关键字的情况下被初始化，它默认成为全局变量)。为什么会这样呢？因为 JavaScript 将这些变量隐式地放在函数的顶部。

[https://gist . github . com/choall in/6e 17 f 8254 F8 c 79 f1 F5 a 2245 c 13 AC 207 e](https://gist.github.com/choallin/6e17f8254f8c79f1f5a2245c13ac207e)

这里变量`x`仍然可用，尽管它是在函数的子块中定义的。

用`var`隐式改变变量的顺序是为了让一些有趣的代码工作:

最新的 Chrome 或 Firefox 不再这样工作，但仍然可以在整个函数中看到用`var`定义的变量，而不仅仅是在一个块中。

## 街区

一个功能可以分成多个子块。在许多类 C 语言中，一个*块*被`{}`包围着——在 Ruby 中，我们更经常使用`do end`。

## 表示

在许多函数式语言中，我们有一个额外的层次，即*表达式*层次。这意味着变量只在一个短表达式中定义。

这可能看起来像这样:

```
let val x = some_function() in x * x end
```

这里我们使用变量`x`作为缓存，所以我们不必调用函数`some_function()`两次。

注意:`let`关键字也存在于非函数式语言中——例如在 JavaScript 或 [Rust](https://www.rust-lang.org/) 中——但是在这些语言中，它与变量的作用域无关。

# 相关概念

*动态分派*与作用域密切相关。这描述了如何为对象解析实例变量/方法(大多数时候)。

## 关闭

有时候，当涉及到作用域时，*闭包*令人困惑。为什么会这样呢？因为一般来说，它们是在不同于编码的地方执行的。

然而，它们在词汇上是有作用域的，因为代码的上下文与名称解析有关，而与运行时无关。

# 结论

如果我们仔细考虑代码的作用域，并保持对代码执行环境的了解，我们将能够写出更好的代码，并且在使用特定于领域的语言(可以改变作用域)时不会感到困惑——这在 Ruby 社区中很常见，尤其是在 [Rails](https://rubyonrails.org/) 中，但在 JavaScript 中也并不少见。