<html>
<head>
<title>Sending Static Calls to a Smart Contract With Ethers.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Ethers.js向智能合约发送静态调用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sending-static-calls-to-a-smart-contract-with-ethers-js-e2b4ceccc9ab?source=collection_archive---------1-----------------------#2022-03-17">https://betterprogramming.pub/sending-static-calls-to-a-smart-contract-with-ethers-js-e2b4ceccc9ab?source=collection_archive---------1-----------------------#2022-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8bff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过在发送交易前检查交易是否会失败，节省数百万美元的油费</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6f52c6b5d024b22dfbc69dc81f8e3363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HL6bWIWx1QW3tGa85FA2Fg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Metamask交易确认截图</p></figure><p id="a701" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">几个月前，我在试图确认一项以太坊交易时，从Metamask获得了上述错误信息。当时Metamask刚刚添加了这个功能，我<a class="ae lr" href="https://twitter.com/tjelailah/status/1481862406678716417" rel="noopener ugc nofollow" target="_blank">在推特上给</a>写了关于它是UX的一大改进。</p><p id="9f93" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">显然，我在测试与Uniswap智能合约的交互时，在dApp上输入了无效的输入变量。出于好奇，我还是发送了事务，看看它是否真的会失败——是的，它失败了。</p><p id="b6fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，Metamask是如何知道事务将要失败的呢？这个问题在我脑海里徘徊了一段时间，直到我找到了答案。</p><p id="e5f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你也像我一样好奇，请继续阅读这篇文章，我会告诉你如何在发送之前使用<code class="fe ls lt lu lv b">ethers.js</code>来检查交易的有效性。</p><h1 id="8ddc" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">区块链交易</h1><p id="4772" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">默认情况下，区块链交易是不可变的，这意味着没有办法逆转已经确认的交易。例如，如果你把ETH发送到错误的以太坊地址，你就没有办法恢复它。除非地址所有者好心给你退款。</p><p id="171d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">防止这种情况的一种方法是在确认交易之前仔细检查地址，或者使用易于阅读的ENS名称。但是其他种类的交易呢(例如铸造非关税壁垒)？</p><p id="20fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据<a class="ae lr" href="https://twitter.com/BuycoinsR" rel="noopener ugc nofollow" target="_blank"> Buycoins Research </a>的<a class="ae lr" href="https://dune.xyz/BuycoinsR/Tubbycat-NFT-minting-analysis" rel="noopener ugc nofollow" target="_blank"> Tubbycat NFT销售分析</a>，约776 ETH(当时约200万美元)用于失败的交易费用。就失败交易给整个生态系统造成的损失而言，这只是很小的一部分。这些交易费一部分被烧掉，一部分到了矿商手里。</p><p id="895e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然还有其他因素(如抢先运行攻击)可能导致挂起的事务最终失败，但一些事务失败可以通过事先检查其有效性来防止。</p><h1 id="b783" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">静态呼叫</h1><blockquote class="mt mu mv"><p id="bf96" class="kv kw mw kx b ky kz jr la lb lc ju ld mx lf lg lh my lj lk ll mz ln lo lp lq ij bi translated">不是执行事务的状态改变，而是可以要求一个节点<em class="iq">假装</em>一个调用没有改变状态并返回结果。</p><p id="ba5e" class="kv kw mw kx b ky kz jr la lb lc ju ld mx lf lg lh my lj lk ll mz ln lo lp lq ij bi translated">这实际上不会改变任何状态，而是免费的。在某些情况下，这可以用来确定事务是失败还是成功。</p></blockquote><p id="222d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们考虑这个例子:</p><p id="34c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">艾丽丝想在鲍勃的快餐店里点一个汉堡，但是她必须开车去那里取。鲍勃做的汉堡是全县最好的，而且卖得很快。</p><p id="eaef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果爱丽丝在汉堡卖完之后开车去餐馆，她会浪费时间、精力和汽油。因此，她需要在去餐馆之前知道汉堡是否还有。</p><p id="0262" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">鲍勃的餐馆有一个网站，他在那里更新销售额，这样人们就可以看到还剩多少汉堡。如果爱丽丝查看网站，发现汉堡已经卖完了，她就呆在家里，不会浪费资源开车去。</p><p id="f88b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">否则，她会开车去餐馆买她最喜欢的汉堡。这种情况类似于如何进行静态调用来检查事务是否可能失败。</p><h1 id="1fce" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">使用NodeJS进行静态调用</h1><p id="4e6a" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">在本节中，我们将对<a class="ae lr" href="https://rinkeby.etherscan.io/address/0xc36442b4a4522e871399cd717abdd847ab11fe88" rel="noopener ugc nofollow" target="_blank"> Uniswap V3合约</a>进行静态调用，并尝试转移我们不拥有的流动性头寸。</p><p id="a760" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在进入代码之前，确保你已经安装了<code class="fe ls lt lu lv b">ethers</code>。如果没有，请使用以下命令安装它:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="8b8f" class="ne lx iq lv b gy nf ng l nh ni">npm install --save ethers</span></pre><p id="af47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">安装成功后，在Etherscan上打开Uniswap合同<a class="ae lr" href="https://rinkeby.etherscan.io/address/0xc36442b4a4522e871399cd717abdd847ab11fe88#code" rel="noopener ugc nofollow" target="_blank">代码</a>。向下滚动至合同ABI，并将其复制到剪贴板。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/b23ba0623ef813974e22985cd30f1155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiKv70uN2fSEUZ0C_P3OZQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Uniswap V3 ABI</p></figure><ul class=""><li id="6bd6" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">创建一个<code class="fe ls lt lu lv b">abi.json</code>文件并将ABI粘贴到其中。</li><li id="1cff" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">接下来，创建一个用于进行静态调用的新文件。</li><li id="6ef1" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">将<code class="fe ls lt lu lv b">ethers</code>库和<code class="fe ls lt lu lv b">abi</code>导入到代码中。</li></ul><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="6835" class="ne lx iq lv b gy nf ng l nh ni">const { ethers, providers } = require('ethers');</span><span id="5368" class="ne lx iq lv b gy ny ng l nh ni">require('dotenv').config()</span><span id="1fe3" class="ne lx iq lv b gy ny ng l nh ni">const abi = require('./abi.json')</span></pre><ul class=""><li id="fd09" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">定义合同地址、签署人并初始化合同。</li></ul><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="21f8" class="ne lx iq lv b gy nf ng l nh ni">const contractAddress = "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"</span><span id="e9ed" class="ne lx iq lv b gy ny ng l nh ni">const signer = new ethers.Wallet(</span><span id="f19e" class="ne lx iq lv b gy ny ng l nh ni">   process.env.PRIVATE_KEY,<br/>   providers.getDefaultProvider('mainnet')</span><span id="0471" class="ne lx iq lv b gy ny ng l nh ni">);</span><span id="7671" class="ne lx iq lv b gy ny ng l nh ni">const contract = new ethers.Contract(contractAddress, abi, signer);</span></pre><p id="d0d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个例子使用来自<code class="fe ls lt lu lv b">ethers</code>的默认提供者。然而，在创建您的应用程序时，请确保在<a class="ae lr" href="http://infura.io" rel="noopener ugc nofollow" target="_blank"> Infura </a>上注册您自己的提供商，以提高您的请求率/限额，并获得通话指标。</p><ul class=""><li id="92d6" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">定义交易变量。</li></ul><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="12a5" class="ne lx iq lv b gy nf ng l nh ni">const from = "0x66fe4806cD41BcD308c9d2f6815AEf6b2e38f9a3"</span><span id="b533" class="ne lx iq lv b gy ny ng l nh ni">const to = "0xC41672E349C3F6dAdf8e4031b6D2d3d09De276f9"</span><span id="fd83" class="ne lx iq lv b gy ny ng l nh ni">const tokenId = 100</span></pre><p id="c357" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">from</code>地址既不是令牌<code class="fe ls lt lu lv b">100</code>的所有者，也不是令牌<code class="fe ls lt lu lv b">100</code>的授权使用者，因此不能将其转移到其他地址。不过我们还是试试用<code class="fe ls lt lu lv b">callStatic</code>的方法转移一下，看看结果如何。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="8f6e" class="ne lx iq lv b gy nf ng l nh ni">const transaction = async () =&gt; {</span><span id="d3ac" class="ne lx iq lv b gy ny ng l nh ni">   const a = await contract.callStatic.transferFrom(from, to, tokenId)</span><span id="db50" class="ne lx iq lv b gy ny ng l nh ni">   console.log(a)</span><span id="3dd2" class="ne lx iq lv b gy ny ng l nh ni">}</span><span id="d237" class="ne lx iq lv b gy ny ng l nh ni">transaction()</span></pre><p id="c8fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您尝试这样做时，应该会得到类似下面的错误。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="48ad" class="ne lx iq lv b gy nf ng l nh ni">reason: 'ERC721: transfer caller is not owner nor approved',<br/>  code: 'CALL_EXCEPTION',<br/>  method: 'transferFrom(address,address,uint256)',<br/>  errorArgs: [ 'ERC721: transfer caller is not owner nor approved' ],<br/>  errorName: 'Error',<br/>  errorSignature: 'Error(string)',<br/>  address: '0xC36442b4a4522E871399CD717aBDD847Ab11FE88',<br/>  args: [<br/>    '0x66fe4806cD41BcD308c9d2f6815AEf6b2e38f9a3',<br/>    '0xC41672E349C3F6dAdf8e4031b6D2d3d09De276f9',<br/>    100<br/>  ],<br/>  transaction: {<br/>    data: '0x23b872dd00000000000000000000000066fe4806cd41bcd308c9d2f6815aef6b2e38f9a3000000000000000000000000c41672e349c3f6dadf8e4031b6d2d3d09de276f90000000000000000000000000000000000000000000000000000000000000064',<br/>    to: '0xC36442b4a4522E871399CD717aBDD847Ab11FE88',<br/>    from: '0xC41672E349C3F6dAdf8e4031b6D2d3d09De276f9'<br/>  }<br/>}</span></pre><p id="5027" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以把<code class="fe ls lt lu lv b">reason: ‘ERC721: transfer caller is not owner nor approved’</code>看成这个事务会失败的原因。最重要的是，静态调用是一个<code class="fe ls lt lu lv b">read-only</code>函数，是无气的。</p><p id="15e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过在你的dApp、机器人等中集成一个静态调用。，你会省下一大笔本可以用来支付失败交易的油费的钱。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="3043" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您设法跟进到这一点，那么您一定成功地向区块链发送了一个静态调用。干得好！</p><p id="ad6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以查看下面的完整代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure></div></div>    
</body>
</html>