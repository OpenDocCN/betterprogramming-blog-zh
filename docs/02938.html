<html>
<head>
<title>What Are Holes in Arrays?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是数组中的孔？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-holes-in-arrays-3ac5fcbcd1c?source=collection_archive---------14-----------------------#2020-01-09">https://betterprogramming.pub/what-are-holes-in-arrays-3ac5fcbcd1c?source=collection_archive---------14-----------------------#2020-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="18fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你知道数组可以跳过值吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/71f11dc44548ba1d98562e89335f1bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N4mg03Wt8DHbnK8M"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Artem Maltsev 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="598a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript数组的一个特殊特性是，不是数组中的每个槽都必须填充值。这意味着我们可以跳过如下值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d75e" class="ma mb it lw b gy mc md l me mf">let arr = [];<br/>arr[1] = 1;<br/>arr[10] = 10;</span></pre><p id="b5d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不必担心为数组的其他槽设置值。</p><p id="b0f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一种替代语法来完成上述操作，编写如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f4a5" class="ma mb it lw b gy mc md l me mf">[, 1, , 2];</span></pre><p id="965a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们上面的叫做数组的<em class="mg">孔，这里逗号之间没有任何东西。有孔的阵列称为<em class="mg">稀疏阵列</em>。</em></p><p id="9c35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看JavaScript如何处理数组中的漏洞。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="7ae7" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">检查数组中的值</h1><p id="dccf" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们可以用<code class="fe nk nl nm lw b">in</code>操作符检查数组中的漏洞。为此，我们可以编写类似下面的代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8df8" class="ma mb it lw b gy mc md l me mf">const arr = [, 1, , 2];<br/>1 in arr;</span></pre><p id="2f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该从最后一行返回<code class="fe nk nl nm lw b">true</code>,因为1在数组中。</p><p id="d61f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES6将数组中的洞视为<code class="fe nk nl nm lw b">undefined</code>条目。因此，如果我们想检查数组中的漏洞，请检查<code class="fe nk nl nm lw b">undefined</code>。</p><p id="74d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代器和生成器也将漏洞视为<code class="fe nk nl nm lw b">undefined</code>。例如，如果我们有</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bb34" class="ma mb it lw b gy mc md l me mf">const arr = [, 1, , 2];<br/>const iter = arr[Symbol.iterator]()</span><span id="6ac3" class="ma mb it lw b gy nn md l me mf">for (let a of iter) {<br/>  console.log(a);<br/>}</span></pre><p id="6f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="154a" class="ma mb it lw b gy mc md l me mf">undefined<br/>1<br/>undefined<br/>2</span></pre><p id="b8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们调用<code class="fe nk nl nm lw b">next</code>来获取下一项，如下所示，</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5037" class="ma mb it lw b gy mc md l me mf">iter.next();</span></pre><p id="4bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="74ce" class="ma mb it lw b gy mc md l me mf">{value: undefined, done: false}</span></pre><p id="905b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第一个条目。</p><p id="3a5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果我们有给定的生成器，</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f7b9" class="ma mb it lw b gy mc md l me mf">function* generator () {<br/>  const arr = [, 1, , 2];<br/>  for (let a of arr) {<br/>    yield a;<br/>  }<br/>}</span><span id="21a9" class="ma mb it lw b gy nn md l me mf">for (let a of generator()) {<br/>  console.log(a);<br/>}</span></pre><p id="9bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到同样的东西。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="fd87" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">数组. from()</h1><p id="56f2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe nk nl nm lw b">Array.from()</code>像对待迭代器和生成器一样对待孔。</p><p id="e60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="14d4" class="ma mb it lw b gy mc md l me mf">const arr = [, 1, , 2];<br/>const arrFrom = Array.from(arr);</span></pre><p id="a2d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们得到<code class="fe nk nl nm lw b">arrFrom</code>的值是</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f484" class="ma mb it lw b gy mc md l me mf">[undefined, 1, undefined, 2]</span></pre><p id="1c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果我们从类似数组的对象中创建一个数组，其中我们将非负整数作为键，将一个非负数作为值的length属性，那么缺失的条目也会被视为<code class="fe nk nl nm lw b">undefined</code>。</p><p id="d8e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们跑</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0d04" class="ma mb it lw b gy mc md l me mf">const arrFrom = Array.from({<br/>  1: 'foo',<br/>  length: 2<br/>});</span></pre><p id="6c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe nk nl nm lw b">arrFrom</code>的值为</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c07b" class="ma mb it lw b gy mc md l me mf">[undefined, "foo"]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/f6c09f9ad463915e8ebcb48db3c8a120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MpKXXhLCgI9q0ing"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">科迪·韦斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="8a29" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Array.prototype方法如何处理漏洞</h1><p id="cd5e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这些方法的行为随着JavaScript版本的不同而不同。在ES5中，它们是:</p><ul class=""><li id="5224" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">forEach</code>、<code class="fe nk nl nm lw b">filter</code>、<code class="fe nk nl nm lw b">every</code>和<code class="fe nk nl nm lw b">some</code>忽略孔。</li><li id="9017" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">map</code>跳过但保留漏洞。</li><li id="d166" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">join</code>和<code class="fe nk nl nm lw b">toString</code>将孔视为<code class="fe nk nl nm lw b">undefined</code>元素，但将<code class="fe nk nl nm lw b">null</code>和<code class="fe nk nl nm lw b">undefined</code>视为空字符串。</li></ul><p id="a78c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个完整的方法列表以及它们是如何处理漏洞的。每种方法都有不同的作用。</p><ul class=""><li id="45a1" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">concat</code> —保留孔</li><li id="6365" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">copyWithin</code>-孔被复制</li><li id="5b49" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">entries</code>、<code class="fe nk nl nm lw b">keys</code>、<code class="fe nk nl nm lw b">values</code> —将孔视为<code class="fe nk nl nm lw b">undefined</code></li><li id="914c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">every</code>-忽略孔</li><li id="03eb" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">fill</code> —填充孔</li><li id="d4d0" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">filter</code>-移除孔</li><li id="1492" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">find</code>-将孔视为元素</li><li id="ed3e" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">findIndex</code>-将孔视为元素</li><li id="2a6f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">forEach</code>-忽略孔</li><li id="a183" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">indexOf</code>-忽略孔</li><li id="8fdc" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">join</code>-将孔转换为空字符串</li><li id="f1be" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">lastIndexOf</code>-忽略孔</li><li id="49e6" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">map</code> —保留孔洞</li><li id="896e" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">pop</code> —将孔视为元素</li><li id="ecbe" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">push</code>-保留孔</li><li id="b7a6" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">reduce</code>，<code class="fe nk nl nm lw b">reduceRight</code>-忽略孔</li><li id="f25f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">reverse</code>-保留孔</li><li id="e73c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">shift</code> —将孔视为<code class="fe nk nl nm lw b">undefined</code></li><li id="7fc1" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">slice</code>-保留孔</li><li id="becb" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">sort</code>-保留孔</li><li id="1d39" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">toString</code>-保留孔</li><li id="bd8c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">unshift</code>-保留孔</li><li id="7abe" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nk nl nm lw b">values</code>-将孔转换为<code class="fe nk nl nm lw b">undefined</code></li></ul><p id="4ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当数组稀疏时，它们会有漏洞。它们作为<code class="fe nk nl nm lw b">undefined</code>被迭代，但是每个数组原型方法对待漏洞的方式不同，所以我们在定义有漏洞的数组和处理它们时必须小心。</p><p id="0e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nk nl nm lw b">in</code>操作符来检查一个给定的条目是否在一个数组中。</p><p id="2b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm lw b">Array.from()</code>在将数组或带孔的类数组对象转化为数组时，也将孔视为<code class="fe nk nl nm lw b">undefined</code>并将孔转化为<code class="fe nk nl nm lw b">undefined</code>。</p></div></div>    
</body>
</html>