<html>
<head>
<title>How to Fix a Sequence When It Goes Out of Sync in Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何修复Postgres中不同步的序列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-fix-a-sequence-when-it-goes-out-of-sync-in-postgres-8393c1c65299?source=collection_archive---------11-----------------------#2022-02-15">https://betterprogramming.pub/how-to-fix-a-sequence-when-it-goes-out-of-sync-in-postgres-8393c1c65299?source=collection_archive---------11-----------------------#2022-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="783f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决Postgres中的不同步序列问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e849c31bf0102510ed3c51bf716314a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f2z1QKPY9FpKROZm.png"/></div></div></figure><p id="714d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Postgres 是世界上最先进、最广泛使用的开源RDBMS(关系数据库管理系统)之一。它尤其受到开发人员社区的青睐，因为它支持SQL和JSON查询，这使得它同时兼容关系和非关系。</p><p id="04fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，Postgres有一些众所周知的问题，其中最恼人的一个涉及序列。具体来说，Postgres序列很容易失去同步，从而阻止您插入新行。当这种情况发生时，Postgres甚至会返回一个令人困惑的错误消息。</p><p id="2528" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将向您介绍不同步问题，并向您展示如何解决这个问题。我们将学习序列，了解导致不同步问题的环境，学习如何诊断问题，并最终解决问题。我们开始吧。</p><h1 id="f4e1" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Postgres中不同步序列问题的探讨</h1><h2 id="3e84" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">什么是Postgres序列？</h2><p id="b579" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">官方文档<a class="ae lq" href="https://www.postgresql.org/docs/8.1/sql-createsequence.html" rel="noopener ugc nofollow" target="_blank">解释说序列只不过是一个数字生成器。特别是，Postgres使用一个序列来生成一个渐进的数字，它通常代表一个自动递增的数字主键。</a></p><p id="7a25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你熟悉<a class="ae lq" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>，在Postgres中拥有一个序列的结果堪比<code class="fe na nb nc nd b"><a class="ae lq" href="https://dev.mysql.com/doc/refman/8.0/en/example-auto-increment.html" rel="noopener ugc nofollow" target="_blank">AUTO_INCREMENT</a></code>行为。主要区别在于Postgres序列也可以从一个定义的值开始，然后在每个<code class="fe na nb nc nd b">INSERT</code>递减。</p><p id="c4ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以用<code class="fe na nb nc nd b"><a class="ae lq" href="https://www.postgresql.org/docs/9.5/sql-createsequence.html" rel="noopener ugc nofollow" target="_blank">CREATE SEQUENCE</a></code>语句在Postgres中定义一个序列。类似地，特殊类型<code class="fe na nb nc nd b"><a class="ae lq" href="https://www.postgresql.org/docs/9.1/datatype-numeric.html#DATATYPE-SERIAL" rel="noopener ugc nofollow" target="_blank">SERIAL</a></code>在后台使用一个序列初始化一个自动递增的数字主键。一般来说，用<code class="fe na nb nc nd b">CREATE TABLE</code>创建新表的时候应该用<code class="fe na nb nc nd b">SERIAL</code>。</p><h2 id="eeeb" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">什么时候序列会不同步？</h2><p id="b3f3" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">根据我作为一名高级软件开发人员的经验，Postgres序列不同步有三个原因。具体来说，这发生在以下情况:</p><ul class=""><li id="3ce6" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">用一个<code class="fe na nb nc nd b">INSERT</code>脚本导入许多行或者恢复一个庞大的数据库；</li><li id="aab7" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">用<code class="fe na nb nc nd b"><a class="ae lq" href="https://www.postgresql.org/docs/8.2/functions-sequence.html" rel="noopener ugc nofollow" target="_blank">setval()</a></code>功能手动设置序列的错误值；</li><li id="ab9c" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">通过在<code class="fe na nb nc nd b">INSERT</code>查询中手动指定<code class="fe na nb nc nd b">id</code>字段，向表中插入新记录。</li></ul><p id="7fb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一个是最常见的原因，通常是因为Postgres使用一个序列，只有当您省略id字段或在<code class="fe na nb nc nd b">INSERT</code>查询中使用<code class="fe na nb nc nd b">DEFAULT</code>关键字时，它才会自动更新它的值。</p><h2 id="b259" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">我如何识别这个问题？</h2><p id="be4c" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">发现这个问题很简单。当您没有为<code class="fe na nb nc nd b">id</code>列指定值并手动启动一个<code class="fe na nb nc nd b">INSERT</code>查询或者让您的ORM ( <a class="ae lq" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">对象关系映射</a>)为您执行时，Postgres将总是返回一个“重复键值违反唯一约束”错误。此外，在执行<code class="fe na nb nc nd b">UPDATE</code>查询时，这种情况永远不会发生。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ns"><img src="../Images/23f46698de5207b2511fc892fe1922ac.png" data-original-src="https://miro.medium.com/v2/0*3kk849CgAK0RE6K4"/></div></figure><p id="9163" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以想象，问题出在与id列不同步相关的序列上。具体来说，当序列为已经使用的id列返回一个值时，就会发生错误。这导致了前面提到的错误，因为根据定义，ID必须是唯一的。</p><h1 id="f6a0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">如何解决问题</strong></h1><p id="009c" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">现在是时候看看如何处理不同步问题并一劳永逸地解决它了。这个问题可以用几种方法来解决。这里有两种方法。</p><h2 id="d2e8" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">方法1:单表解决方案</h2><p id="9e8d" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">假设您想要修复与您的<code class="fe na nb nc nd b">Users</code>表的<code class="fe na nb nc nd b">id</code>列相关联的序列。您可以通过运行以下查询来实现这一点:</p><pre class="kj kk kl km gt nt nd nu nv aw nw bi"><span id="0f7a" class="mj ls it nd b gy nx ny l nz oa">SELECT SETVAL('public."Users_id_seq"', COALESCE(MAX(id), 1)) FROM public."Users";</span></pre><p id="1c72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该查询将通过将当前值设置为<code class="fe na nb nc nd b">COALESCE(MAX(id), 1)</code>的结果来更新<code class="fe na nb nc nd b">Users_id_seq</code>序列。请注意Postgres中的序列名称是如何遵循以下符号的:</p><pre class="kj kk kl km gt nt nd nu nv aw nw bi"><span id="06d6" class="mj ls it nd b gy nx ny l nz oa">"&lt;table-name&gt;_&lt;column-name&gt;_seq"</span></pre><p id="9c81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe na nb nc nd b"><a class="ae lq" href="https://www.postgresql.org/docs/8.1/functions-conditional.html#AEN12663" rel="noopener ugc nofollow" target="_blank">COALESCE</a></code>函数返回第一个非空值，它是必需的，因为如果<code class="fe na nb nc nd b">Users</code>为空，<code class="fe na nb nc nd b">MAX(id)</code>将返回<code class="fe na nb nc nd b">NULL</code>。因此，通过使用<code class="fe na nb nc nd b">COALESCE</code>，您可以确定当<code class="fe na nb nc nd b">Users</code>不为空时，分配给<code class="fe na nb nc nd b">Users_id_seq</code>的值将为<code class="fe na nb nc nd b">MAX(id)</code>，当<code class="fe na nb nc nd b">Users</code>为空时，该值为1。在这两种情况下，该查询都会设置所需的值。</p><h2 id="f45b" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">方法2:用一个脚本修复所有的序列</h2><p id="f6c9" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">如果你想用一个查询修复所有的序列，你可以使用来自官方Postgres Wiki 的以下脚本:</p><pre class="kj kk kl km gt nt nd nu nv aw nw bi"><span id="d7b6" class="mj ls it nd b gy nx ny l nz oa">SELECT 'SELECT SETVAL(' ||<br/>       quote_literal(quote_ident(PGT.schemaname) || '.' || quote_ident(S.relname)) ||<br/>       ', COALESCE(MAX(' ||quote_ident(C.attname)|| '), 1) ) FROM ' ||<br/>       quote_ident(PGT.schemaname)|| '.'||quote_ident(T.relname)|| ';'<br/>FROM pg_class AS S,<br/>     pg_depend AS D,<br/>     pg_class AS T,<br/>     pg_attribute AS C,<br/>     pg_tables AS PGT<br/>WHERE S.relkind = 'S'<br/>    AND S.oid = D.objid<br/>    AND D.refobjid = T.oid<br/>    AND D.refobjid = C.attrelid<br/>    AND D.refobjsubid = C.attnum<br/>    AND T.relname = PGT.tablename<br/>ORDER BY S.relname;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ns"><img src="../Images/6053596fcfd5f2f36dc28486fab5af2b.png" data-original-src="https://miro.medium.com/v2/0*-wP39DJ1prRow7uW"/></div></figure><p id="020a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该查询返回执行时修复每个序列所需的查询集。如Wiki中所述，您应该按如下方式使用此查询:</p><ol class=""><li id="919f" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp ob nk nl nm bi translated">将查询保存在一个<code class="fe na nb nc nd b">fix_sequences.sql</code>文件中。</li><li id="951b" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp ob nk nl nm bi translated">运行包含在<code class="fe na nb nc nd b">fix_sequences.sql</code>文件中的查询，并将结果存储在<code class="fe na nb nc nd b">temp</code>文件中。然后，运行包含在<code class="fe na nb nc nd b">temp</code>文件中的查询。最后，删除<code class="fe na nb nc nd b">temp</code>文件。您可以使用以下三个命令来实现这一点:</li></ol><pre class="kj kk kl km gt nt nd nu nv aw nw bi"><span id="eb5d" class="mj ls it nd b gy nx ny l nz oa">bash<br/>psql -Atq -f fix_sequences.sql -o temp<br/>psql -f temp<br/>rm temp</span></pre><h1 id="8281" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">如何确认问题已经解决</strong></h1><p id="ae5e" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">现在，要验证序列不再不同步，只需在最初遇到问题的表中插入一条新记录。</p><p id="a240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住在<code class="fe na nb nc nd b">INSERT</code>查询中给<code class="fe na nb nc nd b">id</code>列赋予<code class="fe na nb nc nd b">DEFAULT</code>值或者完全省略它。通过这种方式，Postgres将在后台使用<code class="fe na nb nc nd b">Users_id_seq</code>序列来检索正确的值，并将其提供给<code class="fe na nb nc nd b">id</code>。</p><p id="ec04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，运行以下查询，您应该不会再收到“重复键值违反唯一约束”错误消息:</p><pre class="kj kk kl km gt nt nd nu nv aw nw bi"><span id="71b1" class="mj ls it nd b gy nx ny l nz oa">INSERT INTO "Users"("id", "name", "surname", "email", "password")<br/>VALUES (DEFAULT, 'Jennifer', 'Jones', 'jennifer.jones@email-domain.com', 'pBHxe*cWnC2ZJKHw');</span></pre><p id="aee3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，该查询将按预期在<code class="fe na nb nc nd b">Users</code>表中插入一条新记录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ns"><img src="../Images/31b34e97bd1c054af8b64084b04d6918.png" data-original-src="https://miro.medium.com/v2/0*fznz1HPvcwAJyAl4"/></div></figure><h1 id="85d6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">结论</strong></h1><p id="dd07" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">Postgres无疑是一个伟大的RDBMS。同时，它也有一些问题会浪费你的时间。</p><p id="9942" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你没有意识到它们，不知道如何识别它们，也没有相应地解决它们，那就更是如此。在本文中，我们研究了棘手的不同步问题。</p><p id="8766" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不同步序列错误很棘手，因为它会导致“重复键值违反唯一约束”消息错误，这也与其他问题相关。但这不会再欺骗你了，因为现在你知道它为什么会发生，如何检测它，以及如何修复它！</p></div></div>    
</body>
</html>