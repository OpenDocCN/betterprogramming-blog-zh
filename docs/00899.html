<html>
<head>
<title>An Introduction to Nominal TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">名义打字稿介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/nominal-typescript-eee36e9432d2?source=collection_archive---------2-----------------------#2019-07-26">https://betterprogramming.pub/nominal-typescript-eee36e9432d2?source=collection_archive---------2-----------------------#2019-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ff75" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是名词性类型，为什么我应该使用它们？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f98a51718ef6873ab0e960629cf5fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCROqLNySDaFYUphdW915g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@arifriyanto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Arif Riyanto </a>在<a class="ae ky" href="https://unsplash.com/search/photos/programmer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="23a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要理解名词性类型，让我们从名字开始。单词<em class="lv"> nominal </em>源于拉丁语词根<em class="lv"> nom，</em>意为“名字”。很简单，“名义上”这个词可以换成“命名”这个词。<em class="lv">命名类型</em>。</p><p id="03fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">名义类型系统使用类型的名称来检查等价性。出于直觉，这里有一个反例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/bcba6454d7aed77b95fe6aa4228a0fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*QhvbCxKlfVdsmPkOY5hEEA.png"/></div></figure><p id="9e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lx ly lz ma b">Person</code>和<code class="fe lx ly lz ma b">Pet</code>接口都包含相同的信息:名称和id。</p><p id="d3a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为对象<code class="fe lx ly lz ma b">a</code>匹配<code class="fe lx ly lz ma b">Person</code>类型的结构，所以它可以被认为是<code class="fe lx ly lz ma b">Person</code>。</p><p id="8d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个相同的对象与<code class="fe lx ly lz ma b">Pet</code>类型的结构相匹配，所以它也可以被认为是<code class="fe lx ly lz ma b">Pet</code>。</p><p id="100f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种类型系统被称为<em class="lv">结构</em>类型，是构建TypeScript的类型系统。</p><p id="83df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结构类型系统使用类型的<em class="lv">结构</em>，即属性的名称和类型，来断言类型之间的等价性。对于TypeScript来说，<code class="fe lx ly lz ma b">Person</code>和<code class="fe lx ly lz ma b">Pet</code>没有区别。</p><p id="f0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于名义类型系统来说，<code class="fe lx ly lz ma b">Person</code>和<code class="fe lx ly lz ma b">Pet</code>是不同的；即使它们共享所有相同的属性。名义类型系统使用类型的名称来确定类型是否相同。</p><div class="kj kk kl km gt ab cb"><figure class="mb kn mc md me mf mg paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/9e6d47540ad4ff1c2526382522c878dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*XPttDkjCmmKJQxFt2aHZTg.png"/></div></figure><figure class="mb kn mh md me mf mg paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/123b9a537a475d709c6c84a8ea43dc90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1564/format:webp/1*TS63WlAdqaHvIcfwqCDK0g.png"/></div></figure></div><p id="46b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">暂时忽略一些细节，错误消息的最后一行说明了一切:</p><blockquote class="mi mj mk"><p id="7bc3" class="kz la lv lb b lc ld ju le lf lg jx lh ml lj lk ll mm ln lo lp mn lr ls lt lu im bi translated">类型“Person”不可分配给类型“Pet”。</p></blockquote><p id="d862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这些类型看起来一样，听起来一样，闻起来一样，但它们没有相同的名称。在名义类型系统下，这些是不同的类型。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="aff6" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">TypeScript中的名义类型</h1><p id="52d3" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">TypeScript没有对名义类型的本机支持。这一事实有很长的、有争议的历史，未来打字稿版本的路线图已经暂时搁置了名义类型。</p><p id="6daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管怎样，许多技术已经浮出水面，让<em class="lv">在TypeScript中模拟</em>标称类型。因为这些技术都不是完美的名义类型，所以它们都有各自的优缺点。让我们介绍一些更常见的技术。</p><h2 id="c2fe" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">品牌宣传</h2><p id="22e7" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">也许最常见的技术叫做<em class="lv">品牌</em>。事实上，TypeScript编译器在其自己的源代码中非常频繁地使用标记。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d30aa647a1dad25f0dfb0e3a08344f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*y-CxMFUMtnaYvFKNZDKGKg.png"/></div></figure><p id="810d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">品牌或标签通常是添加到对象上不存在的属性中的字符串文字类型。</p><p id="ecbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，TypeScript会引发一个错误，因为字符串文字<code class="fe lx ly lz ma b">'person'</code>不等于字符串文字<code class="fe lx ly lz ma b">'pet'</code>。</p><p id="a6cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用物业名称作为品牌也可以达到同样的效果。例如，<code class="fe lx ly lz ma b">'pet': void</code>。</p><p id="be75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">品牌化技术的主要缺点是，它给品牌化对象引入了一个运行时不存在的假属性。</p><h2 id="a7f3" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">枚举</h2><p id="f510" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">另一个常见的技巧是使用<code class="fe lx ly lz ma b">enum</code>来创建名义类型。在TypeScript中，枚举是唯一的，因此与枚举相交的任何类型都是唯一的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d91ee4192935a45df4ccef4ec49e0d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*b0XzuD-22s3q7pYa196Uuw.png"/></div></figure><p id="7c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过将唯一的枚举与每个类型相交来创建伪名义类型。这样做的优点是不会给每个接口添加虚假的属性，缺点是每个类型需要两个类型声明。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/cb268dcdc54a9b416a02ef5852605c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*f4SfIgWHfVLgXHvXGjSSJg.png"/></div></figure><p id="64c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，因为枚举向下编译为数字，所以与数字相交的枚举等价于与数字相交的任何其他枚举。这是一个非常微妙的点，但是在试图创建名义数字类型时可能会有问题(名义类型的常见情况，我们将在下面看到)。</p><h2 id="4917" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">私有类成员</h2><p id="0c61" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">构造名义类型的最后一种方法是使用私有类成员来表示类型。这与品牌化是同一个概念，但是因为品牌是私有的，所以它不会显示为对象上的属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/caeb6879af09263c6556c444bb7d2cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*hdit1fD4ecLwzQPW_iwWuQ.png"/></div></figure><p id="922e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法最方便的方面是封装它的能力。因为品牌属性不出现在对象上，品牌可以隐藏在一个实用程序文件或<a class="ae ky" href="https://github.com/andnp/SimplyTyped" rel="noopener ugc nofollow" target="_blank">实用程序库</a>中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f218b9d4685ded8a2af788cc7f98eda0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*jBH7MFa2Wnkr_l-BefOkSw.png"/></div></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="a2da" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">何时使用标称类型</h1><p id="8317" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">何时(以及是否)使用名义类型是一个颇有争议的话题。我发现在两种情况下，名义类型对我很重要。首先是封装。第二是强制执行某些图书馆合同。</p><h2 id="348c" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">包装</h2><p id="22ec" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">有时候，我编写的代码完全封装在它自己的模块中。除了通过明确的预定义通道，外部世界的任何代码都不应以任何方式与此代码进行交互。例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/49c207098e1d0645dcd1cc9667555f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLhDoonBC7LfqwOCDJxQEA.png"/></div></div></figure><p id="450a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不可否认，这个例子有点做作，但是请继续关注我。在我的<code class="fe lx ly lz ma b">Autosave.ts</code>模块中，我想传递一个<code class="fe lx ly lz ma b">Autosave</code>对象。该对象包含所有必要的信息，以进行任何自动保存相关的操作。</p><p id="062a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着这个模块的增长，可能会扩展到多个文件，我想确保我的<code class="fe lx ly lz ma b">handler</code>函数是特定于到<code class="fe lx ly lz ma b">Autosave</code>的。不应该简单地用任何碰巧有一个<code class="fe lx ly lz ma b">startTime</code>、一个<code class="fe lx ly lz ma b">file</code>和一些<code class="fe lx ly lz ma b">data</code>的对象来调用<code class="fe lx ly lz ma b">handler</code>函数。</p><p id="06e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免混淆和防止误用，我可能想将<code class="fe lx ly lz ma b">Autosave</code>接口标称化。这要么会迫使消费者确保他们使用的是一个<code class="fe lx ly lz ma b">Autosave</code>对象，要么甚至会阻止消费者完全使用<code class="fe lx ly lz ma b">handler</code>函数。</p><p id="c7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何情况下，通过使<code class="fe lx ly lz ma b">Autosave</code>成为名义上的，我在传达我写<code class="fe lx ly lz ma b">handler</code>函数时只考虑了<code class="fe lx ly lz ma b">Autosave</code>。我写它不是为了一般地处理任意的相似结构的对象。</p><h2 id="3baf" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">图书馆</h2><p id="fe44" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">标称类型的另一个常见用途是对测量单位进行编码。事实上，度量单位与名义类型略有不同，但很重要。但那是一个更长的对话。</p><p id="ffe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，也许我有一个导出这个的库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/17c3301336efaf709bc12cded0fd1e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*YTNlcyG5y4nyo2Lab_Lc8g.png"/></div></figure><p id="19cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数的消费者知道<code class="fe lx ly lz ma b">time</code>是以毫秒为单位，而不是以秒为单位，这一点非常重要。我可以在文档中喊出我想要的，但是另一种处理方式是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/f333cba90777911c2978532881e2d828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhpfTOCWm6jacSGFuDHSLA.png"/></div></div></figure><p id="e98b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每次消费者想要呼叫<code class="fe lx ly lz ma b">delay</code>时，他们必须明确地将他们的号码转换为<code class="fe lx ly lz ma b">Millisecond</code>。这允许一个额外的安全步骤，强迫用户签字同意他们理解和认可他们正在使用的单元。</p><p id="c4c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文到此为止！下面是对包含<code class="fe lx ly lz ma b">Nominal</code>类型的实用程序库的简单介绍。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="dbd0" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">简单类型化</h1><p id="2fac" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">SimplyTyped是一个泛型类型实用程序库。这包括我在整个故事的几个地方使用的封装的<code class="fe lx ly lz ma b">Nominal</code>类型。将这些实用工具保存在这个共享空间中的好处是，它提供了防止在TypeScript中破坏更改的安全性。</p><p id="3484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着TypeScript语言的发展和成熟，一些模式已经失宠。SimplyTyped总是针对每晚的TypeScript版本进行测试，以便在发布下一版本的TypeScript之前捕获并修复这些重大更改。</p><div class="om on gp gr oo op"><a href="https://github.com/andnp/SimplyTyped" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">和np/SimplyTyped</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">又一个类型库。这一点与众不同，它的目标是在行业用例的驱动下，减少实验性…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>