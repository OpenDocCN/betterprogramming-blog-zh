<html>
<head>
<title>Javascript Event Listeners: Closure vs. Delegation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript事件监听器:闭包与委托</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-event-listeners-closure-vs-delegation-e17552f1f59f?source=collection_archive---------13-----------------------#2019-10-21">https://betterprogramming.pub/javascript-event-listeners-closure-vs-delegation-e17552f1f59f?source=collection_archive---------13-----------------------#2019-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="74c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熟练的JavaScript开发人员将两者结合起来以最大化效率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/239fa9190a8e843542598988a955af74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YOinzTd8UtAz9l1Q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由Artem Sapegin (Unsplash)拍摄</p></figure><p id="1fce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的JavaScript开发人员在为文档对象模型(DOM)上的元素附加事件侦听器时经常面临的一个常见问题是决定采用哪种方法。</p><p id="f17d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，在页面加载时，进行提取以获得数据数组。从那里，为每个对象生成元素，并添加到DOM上的现有元素中。在生成元素的同时，还附加了事件侦听器。但最大的问题是哪种元素？对于JavaScript开发人员来说，这就是这个过程开始出现分歧的地方。</p><p id="267f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，添加事件侦听器有两种主要方法:闭包和委托。更熟练的JavaScript开发人员能够将两者结合起来以最大化效率。出于本指南的目的，将单独讨论闭包和委托方法。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a7fe" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">代码应用</h1><p id="3ad5" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这两种方法将用于实现相同的目标。我将引用我创建的存储库作为应用这些方法的例子。请参考:</p><div class="my mz gp gr na nb"><a href="https://github.com/reireynoso/photo_uploader_lab_js" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">reireynoso/photo _ uploader _ lab _ js</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">我们有一个上传照片的应用。就是这样。所有照片都存储在db.json文件中。你会想…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div></div></a></div><p id="796f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于本指南，将不遵循自述文件的要求。具体任务是:</p><ol class=""><li id="81cc" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">从<code class="fe nt nu nv nw b">db.json</code>中取出，为每个照片对象生成元素并附加到DOM上；</li><li id="25f0" class="nk nl it la b lb nx le ny lh nz ll oa lp ob lt np nq nr ns bi translated">从DOM和数据库中删除照片对象。</li></ol><p id="d500" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nt nu nv nw b">index.html</code> <em class="oc"> </em>文件中，主要焦点是ID为<code class="fe nt nu nv nw b">photoContainer</code>的<code class="fe nt nu nv nw b">&lt;div&gt;</code>容器。包含照片信息的现有<code class="fe nt nu nv nw b">&lt;div&gt;</code>已经存在。您可以随意删除该元素，因为它的某些功能以后可能不再适用。目标是在<code class="fe nt nu nv nw b">&lt;div&gt;</code> <code class="fe nt nu nv nw b">photoContainer</code>中添加任何新照片。我们开始吧！</p><p id="67c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nt nu nv nw b">src/index.js</code> <em class="oc">，</em>中已经写好了一些JavaScript代码。在注释<code class="fe nt nu nv nw b"> //****Start coding below****//</code>下面，生成处理页面加载的代码，该代码负责从数据库中获取数据。返回的数据将代表一组照片。遍历照片，并在代码块中调用另一个传入照片对象的函数。对于第一种方法，将涵盖闭包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于处理页面加载时提取的函数</p></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a2c2" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">关闭</h1><p id="930b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">首先，什么是<em class="oc">闭包</em>？简而言之，闭包控制着某个函数中哪些变量是可访问的。根据事件侦听器的定义位置，回调函数可以访问不同的变量。我们来定义一下<code class="fe nt nu nv nw b">createElement</code>函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/51ba70743a91de2f6cb0ed9db2ba838b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jnm92xIsC9sjhFgo5DMZw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用闭包添加事件侦听器</p></figure><p id="aa9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于closure，一般的方法是创建每个元素并为这些元素赋值。使用这种方法，在内存中为每个<button>生成事件监听器。事件监听器的回调函数可以访问photo对象，同时还可以访问<code class="fe nt nu nv nw b">&lt;div&gt;</code> card元素，如果服务器中的删除请求成功，该元素将最终被删除。</button></p><h2 id="767e" class="og mc it bd md oh oi dn mh oj ok dp ml lh ol om mn ll on oo mp lp op oq mr or bi translated">赞成/反对</h2><p id="898d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">通过为每个元素生成一个事件侦听器，可以占用更多的内存空间。如果应用程序是小规模的，这可能无关紧要，但是如果它是大规模的，这可能会影响性能。然而，整个过程很容易操作，因为事件监听器可以访问函数范围内的许多变量。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="6e1c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">委托</h1><p id="ba59" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">什么是<em class="oc">委托</em>？通过委托，事件监听器被附加到主<code class="fe nt nu nv nw b">&lt;div&gt;</code>容器，在本例中是<code class="fe nt nu nv nw b">photoContainer</code>。每当涉及所述元素的事件发生时，回调函数被调用。然而，该事件可以被指定给<code class="fe nt nu nv nw b">photoContainer</code>中的一个特定元素。让我们重组一下<code class="fe nt nu nv nw b">createElement</code>函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/530cd226e3e536f55dc69493e2196de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7ZsS5rd4I9FzoKzSnXR3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用委托来处理事件侦听器</p></figure><p id="d43f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于授权，有必要做一些改变。首先，创建元素并将其附加到DOM的方式利用了。innerHTML方法。第二，<code class="fe nt nu nv nw b">photoContainer</code>是在全局背景下定义的。事件侦听器已附加，但带有一个条件。</p><p id="3c07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">必须利用事件<code class="fe nt nu nv nw b">(e)</code>来获取基于所单击元素的信息。因为事件监听器在<code class="fe nt nu nv nw b">createElement</code>函数之外，所以它不能访问与之关联的照片对象。因此，必须采用利用<code class="fe nt nu nv nw b">e.target</code>的替代方案。一个数据集现在也包含在&lt;按钮&gt;中，作为传递照片ID的一种方式。</p><p id="de64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事件监听器仅在点击类名为<em class="oc"> removeButton </em>的元素时才注册某个动作，在本例中是&lt;按钮&gt;。进行提取以删除与数据集相关联的照片，并且&lt;按钮&gt;的父元素，即&lt; div &gt;卡本身也被从DOM中移除。</p><h2 id="0dff" class="og mc it bd md oh oi dn mh oj ok dp ml lh ol om mn ll on oo mp lp op oq mr or bi translated">赞成/反对</h2><p id="74a9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">从语法上讲，生成元素的代码现在减少了，这可能是提高速度的首选方式。因为只有一个事件侦听器，所以内存空间也减少了。代价是从一种方法到另一种方法查找/传输信息可能很棘手。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7278" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结束语</h1><p id="f513" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当开始操作DOM时，最好选择一种方法并实践它。最终，人们可以理解它是如何工作的，同时也意识到它可能的局限性。这可能导致探索另一种方法，并最终将两者结合起来，以最大限度地发挥潜力。感谢您的阅读。</p><p id="d421" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">**还应归功于db.json中使用的照片URL的取消标记* *</p></div></div>    
</body>
</html>