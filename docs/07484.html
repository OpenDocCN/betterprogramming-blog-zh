<html>
<head>
<title>Build a Paginated API Using Node.js, Express, and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js、Express和MongoDB构建分页API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-paginated-api-using-node-js-express-and-mongodb-227ed5dc2b4b?source=collection_archive---------1-----------------------#2021-01-20">https://betterprogramming.pub/build-a-paginated-api-using-node-js-express-and-mongodb-227ed5dc2b4b?source=collection_archive---------1-----------------------#2021-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b32f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的应用快速创建REST APIs</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be3593d85275f358ae9e5f8d283ce0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2ST2yLUhBaAoIYfepIsmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@benwhitephotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">本·怀特</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片(作者用Adobe Photoshop修改)。</p></figure><p id="2059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您试图显示成百上千的数据(比如一堆用户记录列表、帖子、教程等等)。)在前端应用程序中。在提高应用程序性能的同时，你有什么策略来呈现它们？</p><p id="cadd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想到的最明显的答案是分页！对于那些不熟悉分页概念的人，我将简单介绍一下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2bc1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分页概念</h1><blockquote class="mu"><p id="2b7e" class="mv mw it bd mx my mz na nb nc nd lu dk translated">"分页，也称为分页，是将文档分成独立页面的过程."— <a class="ae ky" href="https://en.wikipedia.org/wiki/Pagination" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="c334" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当您调用REST API时，有时会返回很多结果。出于这个原因，我们对结果进行分页，以确保响应更容易处理。</p><p id="8205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当有大量数据无法合理地显示在一个页面上时，它可以提供更好的用户体验和更容易的导航。</p><p id="8ee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Google这样的搜索引擎是在搜索引擎结果中使用分页的一个很好的例子。这使得用户在第1页找不到的情况下，可以更容易地在其他页面找到他们想要的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/742ff77cc2d1db6b27abbbe36094a9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4NBRmXOM9m_JoYcgRCzvA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Google搜索结果中的分页示例</p></figure><p id="f60a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多技术可以实现分页，但是我将向您展示实现分页的最简单的方法。让我们看看有哪些方法，然后选择一个合适的方法:</p><ol class=""><li id="66d1" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">客户端—服务器在一个请求中将所有可用的记录作为一个大块传输到客户端，这些结果被划分(例如，使用JavaScript的<code class="fe nt nu nv nw b">list slice</code>方法)到页面中并在客户端呈现。</li><li id="0bee" class="nk nl it lb b lc nx lf ny li nz lm oa lq ob lu np nq nr ns bi translated">服务器端—服务器接受来自客户端的许多参数(当前页面、排序等。)，执行获取相关记录所需的搜索，并发送一个分页的结果对象，该对象包含标识页面的详细信息(如总元素数和窗口大小)。</li></ol><p id="3adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端分页更适合数据集较小的应用程序。如果您的数据简单且易于管理，那么我建议您走客户端分页的快捷方式。</p><blockquote class="oc od oe"><p id="eff5" class="kz la of lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">“客户端处理的最大缺点是，当用户第一次访问包含表的页面时，所有数据都会被加载。提取大型数据集可能意味着等待页面加载的时间更长。随着数据结果的增长和数据变得更加复杂，加载时间会显著增加。</p><p id="a8f0" class="kz la of lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi">…</p><p id="5456" class="kz la of lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">服务器端处理更适合处理更复杂的数据集，因为服务器只给客户端提供它需要的那部分数据，这意味着初始加载会非常快。“— <a class="ae ky" href="https://buildthis.com/client-side-vs-server-side-pagination/" rel="noopener ugc nofollow" target="_blank">建立这个</a></p></blockquote><p id="0b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您有一个更大的数据集，我建议使用服务器端分页。</p><p id="30b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨服务器端分页，因为它在快速增长的应用程序中伸缩性更好，并且也是行业标准。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0913" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实施</h1><p id="9741" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">我将在我最喜欢的服务器环境之一上实现它:Node.js with Express。我还使用MongoDB作为我的数据库和Mongoose对象数据建模库。但是，如果您理解了这个概念，您可以将它应用于任何数据库。</p><p id="6dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="of">先决条件:关于如何用Express和Mongoose设置Node.js应用程序的一些知识。</em></p><p id="1b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我创建了一个用户模式来为我的MongoDB添加一些虚拟值。这是一个带有ID和名称的简单模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户模式</p></figure><p id="fcbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我创建了一个函数，在数据库连接建立后插入虚拟数据。我为这个演示添加了12个用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向数据库添加虚拟数据</p></figure><p id="0a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是最重要的部分:处理分页。为此，我用<code class="fe nt nu nv nw b">/users</code> Get API创建了一个名为<code class="fe nt nu nv nw b">paginatedResults</code>的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分页功能</p></figure><p id="2d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我取两个查询参数:<code class="fe nt nu nv nw b">page</code>和<code class="fe nt nu nv nw b">limit</code>。<code class="fe nt nu nv nw b">page</code>是指您正在请求的当前页面，<code class="fe nt nu nv nw b">limit</code>是您希望检索的文档数量。</p><p id="5fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦客户端通过查询参数发送了页面和限制，我就将它们作为常量来使用和存储。然后我定义一个<code class="fe nt nu nv nw b">skipIndex</code>来从结果列表中跳过相关的数字。</p><p id="462b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，MongoDB查询将如下所示:</p><ul class=""><li id="1ded" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu oq nq nr ns bi translated">首先，它按照ID以升序对列表进行排序。</li><li id="c0fa" class="nk nl it lb b lc nx lf ny li nz lm oa lq ob lu oq nq nr ns bi translated">然后，它根据用户需求限制列表，并根据页面请求跳过数据。</li></ul><p id="5e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这真的是简单的逻辑。</p><p id="db4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nw b">exec()</code>函数将执行这个查询作为承诺。我用一个<code class="fe nt nu nv nw b">try-catch</code>把它包起来，因为数据库异常应该在那里处理。</p><p id="c158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都设置好了，现在您可以通过调用<code class="fe nt nu nv nw b">/users</code> REST端点来测试这个分页应用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="93d9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试解决方案</h1><p id="5e0e" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">您可以从Postman客户端或浏览器对此进行测试。这里，我将REST客户端用于Visual Studio代码插件。</p><p id="d0c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是REST API端点:<a class="ae ky" href="http://localhost:3000/users?page=1&amp;limit=3" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/users？page=1 &amp; limit=3 </a>。</p><p id="2a11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的演示视频展示了分页API测试是如何完成的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演示视频</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="980b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><p id="a275" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">完整的项目可以在下面的GitHub资源库中看到:</p><div class="os ot gp gr ou ov"><a href="https://github.com/Yasas4D/PaginationNodejs" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">Yasas4D/PaginationNodejs</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">用Node.js、Express和MongoDB-yasas 4d/pagination nodejs创建一个分页API</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">github.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="00bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="75e6" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">在本文中，您了解了如何使用Node.js和MongoDB创建分页的REST API。但是，您可以用任何其他数据库替换该数据库，因为该概念对于所有数据库都是相同的。我强烈推荐执行服务器端分页，因为它易于扩展和修复。</p><p id="b8bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有所帮助，并且你能够在你正在做的任何项目中实现它。如果你有什么建议，请告诉我。</p><p id="7e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>