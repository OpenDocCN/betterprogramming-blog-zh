<html>
<head>
<title>iOS: Clean Architecture using SwiftUI, Combine, and Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS:使用SwiftUI、Combine和依赖注入清理架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-clean-architecture-using-swiftui-combine-and-dependency-injection-for-dummies-2e44600f952b?source=collection_archive---------1-----------------------#2022-12-09">https://betterprogramming.pub/ios-clean-architecture-using-swiftui-combine-and-dependency-injection-for-dummies-2e44600f952b?source=collection_archive---------1-----------------------#2022-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9962" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用简单示例实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c0e0c641e759d909c710ac66921151e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVW0heUYX2GjC9Txefaa4A.png"/></div></div></figure><p id="19a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Clean architecture是一种软件设计理念，它将应用程序的关注点分成不同的层，每层都有特定的职责。它被称为“干净的”,因为它促进了易于阅读、测试和维护的代码，并且不依赖于特定的框架或技术。</p><p id="28fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在使用SwiftUI和Combine框架用Swift编写的iOS应用程序环境中，clean architecture可能看起来像这样:</p><ul class=""><li id="d152" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><strong class="kt ir">表示层</strong>，最外层，负责处理用户输入和显示输出。这一层将包含定义应用程序用户界面的<code class="fe lw lx ly lz b">SwiftUI</code>视图。</li><li id="f2f4" class="ln lo iq kt b ku ma kx mb la mc le md li me lm ls lt lu lv bi translated"><strong class="kt ir">领域层</strong>，位于架构的中心，负责实现app的核心业务逻辑。这一层将包含定义数据模型、业务规则和应用用例的类。</li><li id="ac3c" class="ln lo iq kt b ku ma kx mb la mc le md li me lm ls lt lu lv bi translated"><strong class="kt ir">数据访问层</strong>是最内层，负责访问和存储数据。这一层将包含从网络或本地数据库获取数据并将其提供给域层的类。</li></ul><p id="e5fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每一层都有明确的、定义良好的职责，并通过一组定义良好的接口与其周围的层进行通信。这允许不同的层彼此独立地被开发、测试和维护，并且使得在不影响其他层的情况下添加新特性或对应用进行改变变得容易。</p><p id="15cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果应用程序需要添加一个涉及从新的数据源获取数据的新特性，开发人员只需在数据访问层中添加一个实现必要接口和方法的新类。这不会影响域层或表示层，它们会像以前一样继续工作。</p><p id="a71c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总的来说，在用Swift编写的iOS应用程序中使用clean architecture，结合SwiftUI和Combine框架，有助于创建结构良好、可维护和可扩展的应用程序。</p><h2 id="69e0" class="mf mg iq bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw mx bi translated">代码适应</h2><p id="e967" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">我们将从这个简单的例子开始，说明使用SwiftUI和Combine框架的iOS应用程序如何实现clean架构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1c8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，表示层中的<code class="fe lw lx ly lz b">MyView</code>结构定义了应用程序的用户界面，并使用域层中的<code class="fe lw lx ly lz b">MyViewModel</code>类来显示数据。</p><p id="e54f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lw lx ly lz b">MyViewModel</code>类使用数据访问层获取数据，数据访问层由<code class="fe lw lx ly lz b">DataFetcher</code>协议和实现它的<code class="fe lw lx ly lz b">NetworkDataFetcher</code>和<code class="fe lw lx ly lz b">DatabaseDataFetcher</code>类组成。</p><p id="3ed5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该体系结构的不同层被清楚地分开，它们之间有明确定义的接口。这使得添加新功能或对应用程序进行更改变得容易，而不会影响其他层。</p><p id="ef82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果应用程序需要从新的数据源获取数据，开发人员只需添加一个实现<code class="fe lw lx ly lz b">DataFetcher</code>协议的新类，并在<code class="fe lw lx ly lz b">MyViewModel</code>类中使用它。这不会影响数据访问层中的<code class="fe lw lx ly lz b">MyView</code>结构或其他类，它们会像以前一样继续工作。</p><h1 id="4672" class="nf mg iq bd mh ng nh ni mk nj nk nl mn jw nm jx mq jz nn ka mt kc no kd mw np bi translated">依赖注入</h1><p id="2224" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">理论上，<strong class="kt ir">依赖注入</strong>是一种实现依赖倒置原则的技术。这个原则声明高级模块不应该依赖于低级模块，而是两者都应该依赖于抽象。</p><p id="b541" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在iOS应用程序的上下文中，依赖注入意味着依赖于另一个对象的对象，例如依赖于模型对象的视图控制器，被给予对它所依赖的对象的引用，而不是创建对象本身。这使得依赖于另一个对象的对象更加灵活，也更容易测试，因为在测试期间可以给它一个模拟对象来使用。</p><h2 id="9c63" class="mf mg iq bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw mx bi translated">代码适应</h2><p id="ae93" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">下面是一个在iOS应用中使用SwiftUI和Combine框架的简单例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="243a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，<code class="fe lw lx ly lz b">UserListView</code>取决于<code class="fe lw lx ly lz b">UserViewModel</code>，而<code class="fe lw lx ly lz b">UserViewModel</code>取决于<code class="fe lw lx ly lz b">NetworkManager</code>。</p><p id="9b93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不是直接在<code class="fe lw lx ly lz b">UserViewModel</code>中创建<code class="fe lw lx ly lz b">NetworkManager</code>，而是将对<code class="fe lw lx ly lz b">NetworkManager</code>的引用传递到<code class="fe lw lx ly lz b">UserViewModel</code>的初始化器中。</p><p id="5b95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这使得<code class="fe lw lx ly lz b">UserViewModel</code>更加灵活，因为它可以被赋予任何符合<code class="fe lw lx ly lz b">NetworkManager</code>协议的对象，而不仅仅是<code class="fe lw lx ly lz b">NetworkManager</code>的特定实现。这使得测试<code class="fe lw lx ly lz b">UserViewModel</code>变得更加容易，因为在测试过程中可以注入一个模拟对象。</p><p id="ab22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们将尝试把干净的架构和依赖注入混合在一起，使用我们在前面例子中的知识来获得一个完整清晰的观点。</p><p id="38c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"/></p><h2 id="ac9c" class="mf mg iq bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw mx bi translated">代码适应</h2><p id="c644" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">基于第一个示例代码，以及我们对DI的了解:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="94b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">域层中的<code class="fe lw lx ly lz b">MyViewModel</code>类是用<code class="fe lw lx ly lz b">DataFetcher</code>协议的一个实例构造的，该实例是在创建时注入其中的。</p><p id="e465" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这允许<code class="fe lw lx ly lz b">MyViewModel</code>类使用注入的<code class="fe lw lx ly lz b">DataFetcher</code>实例从网络或本地数据库获取数据，而不需要知道或关心使用的是<code class="fe lw lx ly lz b">DataFetcher</code>协议的哪个具体实现。</p><p id="d750" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本例中依赖注入的使用有助于进一步分离架构的不同层。</p><p id="3472" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lw lx ly lz b">MyViewModel</code>类没有紧密耦合到<code class="fe lw lx ly lz b">DataFetcher</code>协议的特定实现，可以独立于数据访问层中的其他类进行测试和维护。这使得添加新功能或对应用程序进行更改变得更加容易，而不会影响其他层。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="b76f" class="nf mg iq bd mh ng ny ni mk nj nz nl mn jw oa jx mq jz ob ka mt kc oc kd mw np bi translated">奖金</h1><p id="4aa3" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">现在，您已经理解了DI和CleanArch是如何在幕后工作的，您可能想要自动化在您的<code class="fe lw lx ly lz b">ViewModel</code>中注入大量<code class="fe lw lx ly lz b">DataFetcher</code>实例的过程。</p><p id="0217" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但有时这可能需要大量的工作。接下来，一些构建良好的Swift软件包可以帮助我们实现流程自动化，比如我个人最喜欢的<a class="ae od" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank"> Resolver </a>。</p><h2 id="6bea" class="mf mg iq bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw mx bi translated"><strong class="ak">解析器用途</strong></h2><p id="e067" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">知道我们大多数人都懒得阅读文档，我使用<code class="fe lw lx ly lz b">Resolver</code>转换了我们之前使用的同一个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cf6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，域层中的<code class="fe lw lx ly lz b">MyViewModel</code>类用<code class="fe lw lx ly lz b">@Injected</code>属性标记，以表明它需要在创建时将<code class="fe lw lx ly lz b">DataFetcher</code>协议的一个实例注入其中。</p><p id="a9ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用注入的<code class="fe lw lx ly lz b">DataFetcher</code>实例，<code class="fe lw lx ly lz b">Resolver</code>包用于注册<code class="fe lw lx ly lz b">MyViewModel</code>类并指定如何构造它。</p><p id="927f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当应用程序运行时，<code class="fe lw lx ly lz b">Resolver</code>包将自动创建一个<code class="fe lw lx ly lz b">MyViewModel</code>类的实例，并根据<code class="fe lw lx ly lz b">Resolver</code>扩展中指定的注册将<code class="fe lw lx ly lz b">DataFetcher</code>协议的适当实现注入其中。</p><p id="f5dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，<code class="fe lw lx ly lz b">MyViewModel</code>类可以使用注入的<code class="fe lw lx ly lz b">DataFetcher</code>实例从网络或本地数据库获取数据，而不需要知道或关心正在使用的是<code class="fe lw lx ly lz b">DataFetcher</code>协议的哪个具体实现。</p><p id="faae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中使用<code class="fe lw lx ly lz b">Resolver</code>包有助于进一步分离架构的不同层，并使管理和测试它们之间的依赖关系变得容易。</p><p id="1c16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lw lx ly lz b">MyViewModel</code>类没有紧密耦合到<code class="fe lw lx ly lz b">DataFetcher</code>协议的特定实现，并且可以独立于数据访问层中的其他类进行测试和维护。这使得添加新功能或对应用程序进行更改变得更加容易，而不会影响其他层。在我的下一篇<a class="ae od" rel="noopener ugc nofollow" target="_blank" href="/testing-a-swiftui-combine-ios-app-using-clean-architecture-f7dee1ba5342">文章</a>中，会有更多关于相同例子的测试。</p></div></div>    
</body>
</html>