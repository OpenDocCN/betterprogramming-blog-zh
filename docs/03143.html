<html>
<head>
<title>How to Hash in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中散列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-hash-in-python-8bf181806141?source=collection_archive---------1-----------------------#2020-01-23">https://betterprogramming.pub/how-to-hash-in-python-8bf181806141?source=collection_archive---------1-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6604" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">加密、解密、校验和等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/24d04734b04587a101c9151a760cf37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZXzU561zLq1calah"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@vincentiu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">文森特·索罗门</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="5952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希是大多数编程语言的关键部分。大量的数据可以在一个固定的缓冲区中表示。键值结构使用散列来存储引用。</p><p id="e46a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希用于保护。哈希可以是确定性的，也可以是不确定性的。数据的微小变化或非常相似的情况下，哈希可能会有很大的不同。</p><p id="9259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将回顾Python中最常见的数据散列方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="26b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.内置散列法</h1><p id="8a87" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python提供了内置的<code class="fe mz na nb nc b">.hash()</code>函数，如下所示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="df30" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; hash("test")<br/>2314058222102390712</span></pre><p id="4905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是在Python 2.7运行的，我们试试Python 3.7。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bcfe" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; hash("test")<br/>5946494221830395164</span></pre><p id="283d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个新的Python调用，结果都是不同的。Python从未保证过<code class="fe mz na nb nc b">.hash()</code>是确定性的。</p><p id="144b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python 2.x中，它在大多数情况下是确定的，但并不总是如此。Python 3.x在<code class="fe mz na nb nc b">.hash()</code>中加入了随机性，以提高安全性。字典、集合和列表的默认排序顺序由内置哈希支持。</p><p id="a2c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有一个<a class="ae ky" href="https://github.com/neuml/py27hash" rel="noopener ugc nofollow" target="_blank">完整的项目</a>，涵盖了Python 3.x中的Python 2.x哈希。一般来说，不应该依赖<code class="fe mz na nb nc b">.hash()</code>进行任何跨Python调用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4fff" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.总和检查（checksum的复数形式）</h1><p id="409d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">校验和用于验证文件中的数据。ZIP文件使用校验和来确保文件在解压缩时不会损坏。与Python的内置哈希不同，它是确定性的。相同的数据每次都会返回相同的结果。</p><p id="b645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个使用<a class="ae ky" href="https://www.zlib.net/" rel="noopener ugc nofollow" target="_blank"> zlib </a>的alder32和crc32的例子。Alder32通常是更好的选择，因为它比crc32快得多，而且几乎和crc32一样可靠。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8b65" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; import zlib<br/>&gt;&gt;&gt; zlib.adler32(b"test")<br/>73204161<br/>&gt;&gt;&gt; zlib.crc32(b"test")<br/>3632233996</span></pre><p id="5970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于小型数据库，adler32可以用作简单的ID哈希。但是随着数据的增长，冲突将很快成为一个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f9d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.安全散列</h1><p id="11b4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">安全散列和消息摘要已经发展了多年。从MD5到SHA1到SHA256再到SHA512。</p><p id="e7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每种方法的大小都会增加，从而提高安全性并降低哈希冲突的风险。冲突是指两个不同的数据数组解析为相同的哈希。</p><p id="fbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希可以获取大量任意数据并构建内容摘要。开源软件为他们的软件包建立摘要，帮助用户知道他们可以相信文件没有被篡改。对文件的小改动会导致一个非常不同的散列。</p><p id="cde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看两个MD5散列在改变一个字符后有多大的不同。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9999" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; import hashlib<br/>&gt;&gt;&gt; hashlib.md5(b"test1").hexdigest()<br/>'5a105e8b9d40e1329780d62ea2265d8a'<br/>&gt;&gt;&gt; hashlib.md5(b"test2").hexdigest()<br/>'ad0234829205b9033196ba818f7a872b'</span></pre><p id="848c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一些常见的安全哈希算法。</p><h2 id="782b" class="nh md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">MD5–16字节/128位</h2><p id="81d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">MD5散列是16字节或128位长。请参见下面的示例，注意十六进制摘要将每个字节表示为十六进制字符串(即前导09是一个字节)。MD5散列不再常用。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d32c" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; import hashlib<br/>&gt;&gt;&gt; hashlib.md5(b"test").hexdigest()<br/>'098f6bcd4621d373cade4e832627b4f6'<br/>&gt;&gt;&gt; len(hashlib.md5(b"test").digest())<br/>16</span></pre><h2 id="525a" class="nh md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">SHA1–20字节/160位</h2><p id="74d5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">SHA1散列是20字节或160位长。SHA1哈希也不再常用。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="15cd" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; import hashlib<br/>&gt;&gt;&gt; hashlib.sha1(b"test").hexdigest()<br/>'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3'<br/>&gt;&gt;&gt; len(hashlib.sha1(b"test").digest())<br/>20</span></pre><h2 id="7336" class="nh md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">sha 256–32字节/256位</h2><p id="0fac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">SHA256哈希是32字节或256位长。SHA256哈希是常用的。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="687f" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; import hashlib<br/>&gt;&gt;&gt; hashlib.sha256(b"test").hexdigest()<br/>'9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08'<br/>&gt;&gt;&gt; len(hashlib.sha256(b"test").digest())<br/>32</span></pre><h2 id="00e0" class="nh md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">sha 512–64字节/512位</h2><p id="0fe8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">SHA512哈希的长度为64字节或512位。SHA512哈希是常用的。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b5ce" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; import hashlib<br/>&gt;&gt;&gt; hashlib.sha512(b"test").hexdigest()<br/>'ee26b0dd4af7e749aa1a8ee3c10ae9923f618980772e473f8819a5d4940e0db27ac185f8a0e1d5f84f88bc887fd67b143732c304cc5fa9ad8e6f57f50028a8ff'<br/>&gt;&gt;&gt; len(hashlib.sha512(b"test").digest())<br/>64</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b60" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.近似重复检测</h1><p id="3f4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，当数据发生变化时，上述所有方法都会生成明显不同的散列。</p><p id="d810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">散列函数的一个很好的特性是通过对数据的微小改变来生成明显不同的散列，尤其是对于消息摘要。想象一下，如果有人篡改了一个文件，而散列只是略有不同，那就不好了。</p><p id="7d24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果目标是找到<em class="nx">相似的</em>内容呢？重复或近似重复检测有助于减少存储的数据量。</p><p id="b47a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些用例需要识别微妙的数据差异，如剽窃检测。下面的例子将安装<a class="ae ky" href="https://github.com/leonsim/simhash" rel="noopener ugc nofollow" target="_blank"> Simhash </a> Python库来演示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fc35" class="nh md it nc b gy ni nj l nk nl">pip install simhash</span></pre><p id="b5e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，将运行以下代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，对于接近的数据，哈希是多么相似。但是对于不同的数据来说，就差得多了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ad1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.感知哈希</h1><p id="0246" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们要讨论的最后一种哈希是感知哈希。这种哈希方法用于检测图像和视频中的差异。</p><p id="5506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的一个例子是检测视频中的近似重复帧。可以使用算法来消除视频中重复内容的存储，或者确定图像是否足够接近以将其视为重复，从而节省空间。</p><p id="87a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子显示了两个近似重复的图像，以及它们的感知哈希有多接近。<a class="ae ky" href="https://github.com/JohannesBuchner/imagehash" rel="noopener ugc nofollow" target="_blank"> ImageHash </a> Python库用于演示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c7e5" class="nh md it nc b gy ni nj l nk nl">pip install ImageHash</span></pre><p id="69aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用了以下图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/95d2c8bd70d68fe20e03ea3537aa0499.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*Vdp6EeaPuYX-FnZM0wstJA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原象</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9303b67e85a25c97bc4c54537ba1e002.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*KH3lu2igRbcfKDKvqXbttg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">修改后的图像—删除了“迄今为止4分钟阅读(894个单词)”</p></figure><p id="0ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，底部的图像几乎是相同的，除了它删除了右下角的文本。如果使用像MD5这样的安全散列，散列将与设计的显著不同。让我们看看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，散列是完全不同的。现在让我们试试ImageHash。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希值不同，但非常接近。结尾只有一个字节不一样。ImageHash允许减去两个散列来得到差值。</p><p id="d20b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，可能希望这是一个副本，或者检测图像中的细微差异可能很重要。感知哈希为开发人员提供了检测这一点的选项。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bba2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">结论</strong></h1><p id="7866" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文介绍了在Python中散列数据的许多不同方法。根据不同的用例，这些方法为构建散列提供了许多选项。希望这有助于当前或未来的项目。</p></div></div>    
</body>
</html>