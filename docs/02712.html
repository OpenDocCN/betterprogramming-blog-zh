<html>
<head>
<title>How To Use Kubernetes Secrets for Storing Sensitive Config Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Kubernetes的秘密来存储敏感的配置数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-kubernetes-secrets-for-storing-sensitive-config-data-f3c5e7d11c15?source=collection_archive---------2-----------------------#2019-12-19">https://betterprogramming.pub/how-to-use-kubernetes-secrets-for-storing-sensitive-config-data-f3c5e7d11c15?source=collection_archive---------2-----------------------#2019-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb91" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">因为你的钥匙和秘密应该只是秘密</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0ef9dfd012b7aa4fbb333be6363f18e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJ_xufkMdFS7v8vd7bx-9g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JOSHUA COLEMAN 在<a class="ae kv" href="https://unsplash.com/s/photos/storage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e0eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你好，欢迎👋👋简而言之，我们继续我们的Kubernetes之旅。在之前的一篇博客中，我们看到了如何使用<code class="fe ls lt lu lv b">ConfigMap</code>对象<a class="ae kv" href="https://itnext.io/learn-how-to-configure-your-kubernetes-apps-using-the-configmap-object-d8f30f99abeb" rel="noopener ugc nofollow" target="_blank">配置Kubernetes应用</a>。在本帖中，我们将探讨Kubernetes <code class="fe ls lt lu lv b">Secrets</code>以及如何使用它们来存储需要安全处理的敏感配置数据(例如，数据库凭证、API密钥等)。).</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/c2b7ce851ff940c12505e1aa99bf6b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*G46fIWLhBBQTVPgWEcRGQw.png"/></div></figure><p id="c11d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像往常一样，这将是一个示例驱动的过程，您将会学到:</p><ul class=""><li id="2d26" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">如何创建<code class="fe ls lt lu lv b">Secrets</code> (CLI，<code class="fe ls lt lu lv b">yaml</code>等。)和</li><li id="024d" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">在应用程序中使用它们的各种方式(环境变量、体积等。)</li></ul><p id="90b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码(和<code class="fe ls lt lu lv b">YAML</code>)可以在GitHub 上<a class="ae kv" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell/blob/master/secrets" rel="noopener ugc nofollow" target="_blank">获得。</a></p><p id="9947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章分为两个逻辑部分:创建<code class="fe ls lt lu lv b">Secrets</code>的方法和在应用程序中使用<code class="fe ls lt lu lv b">Secrets</code>的技术。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="4c90" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">先决条件</h1><p id="0d2b" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">要浏览本文中的例子，您需要的只是一个Minikube集群和一个访问该集群的kubectl CLI工具。</p><p id="a20b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<a class="ae kv" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>作为单节点Kubernetes集群安装在您计算机上的虚拟机中。在Mac上，您可以简单地:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="b1e2" class="nt mt iq lv b gy nu nv l nw nx">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 \<br/>  &amp;&amp; chmod +x minikube</span><span id="3d06" class="nt mt iq lv b gy ny nv l nw nx">sudo mv minikube /usr/local/bin</span></pre><p id="b38d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装<a class="ae kv" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>与Minikube集群交互。在Mac上，您可以:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="64bf" class="nt mt iq lv b gy nu nv l nw nx">curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s <a class="ae kv" href="https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl</a></span><span id="ba14" class="nt mt iq lv b gy ny nv l nw nx">chmod +x ./kubectl</span><span id="e103" class="nt mt iq lv b gy ny nv l nw nx">sudo mv ./kubectl /usr/local/bin/kubectl</span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="7b00" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">创造秘密</h1><p id="1e27" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">让我们看看创建<code class="fe ls lt lu lv b">Secret</code>的技巧。</p><h2 id="e923" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated">使用<code class="fe ls lt lu lv b">data</code>部分</h2><p id="6386" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">可以在定义的<code class="fe ls lt lu lv b">data</code>部分创建一个<code class="fe ls lt lu lv b">Secret</code>以及作为键值对存储的配置数据。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="bcf6" class="nt mt iq lv b gy nu nv l nw nx">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: service-apikey<br/>data:<br/>  apikey: Zm9vYmFy</span></pre><p id="84f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Secret</code>包含代表敏感信息的键值数据，其中<code class="fe ls lt lu lv b">apikey</code>是键，值是一个<code class="fe ls lt lu lv b">base64</code>编码的字符串。</p><p id="f09c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在Kubernetes创建这个<code class="fe ls lt lu lv b">Secret</code>:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="fab8" class="nt mt iq lv b gy nu nv l nw nx">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/secret-data.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/secret-data.yaml</a></span></pre><p id="4680" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，YAML文件直接从<a class="ae kv" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中引用，但是您也可以将该文件下载到您的本地机器上，并以同样的方式使用它。</p><p id="f784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确认<code class="fe ls lt lu lv b">Secret</code>已经创建:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="ccea" class="nt mt iq lv b gy nu nv l nw nx">kubectl get secret/service-apikey -o yaml</span></pre><p id="3dfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将得到类似于以下内容的YAML响应:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="e5b4" class="nt mt iq lv b gy nu nv l nw nx">apiVersion: v1<br/>data:<br/>  apikey: Zm9vYmFy<br/>kind: Secret<br/>metadata:<br/>  annotations:<br/>    kubectl.kubernetes.io/last-applied-configuration: |<br/>      {"apiVersion":"v1","data":{"apikey":"Zm9vYmFy"},"kind":"Secret","metadata":{"annotations":{},"name":"service-apikey","namespace":"default"}}<br/>  creationTimestamp: "2019-12-17T11:11:27Z"<br/>  name: service-apikey<br/>  namespace: default<br/>  resourceVersion: "113009"<br/>  selfLink: /api/v1/namespaces/default/secrets/service-apikey<br/>  uid: 671b547c-3316-4916-b6dc-be2b551b974e<br/>type: Opaque</span></pre><p id="58e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用kubectl get获取<code class="fe ls lt lu lv b">Secret</code>细节不会泄露其内容。</p><p id="1798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe ls lt lu lv b">apikey: Zm9vYmFy</code>是我们在YAML清单中提供的。您可以通过解码来检查纯文本格式:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="ced6" class="nt mt iq lv b gy nu nv l nw nx">echo 'Zm9vYmFy' | base64 --decode</span><span id="1569" class="nt mt iq lv b gy ny nv l nw nx">//foobar</span></pre><h2 id="f53d" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated"><strong class="ak">使用字符串数据段</strong></h2><p id="f81e" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">上例中使用的<code class="fe ls lt lu lv b">data</code>属性用于保存<code class="fe ls lt lu lv b">base64</code>编码信息。如果您想安全地存储纯文本数据，您可以使用<code class="fe ls lt lu lv b">stringData</code>部分。这里有一个例子:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="d135" class="nt mt iq lv b gy nu nv l nw nx">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: plaintext-secret<br/>stringData:<br/>  foo: bar<br/>  mac: cheese</span></pre><p id="07bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">foo</code>和<code class="fe ls lt lu lv b">mac</code>的值作为纯文本传递。创建此<code class="fe ls lt lu lv b">Secret</code>并确认:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="fa29" class="nt mt iq lv b gy nu nv l nw nx">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/secret-plaintext.yaml</span><span id="5c6b" class="nt mt iq lv b gy ny nv l nw nx">kubectl get secret/plaintext-secret -o yaml</span></pre><p id="c6b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是YAML回应的<code class="fe ls lt lu lv b">data</code>部分。实际数据以<code class="fe ls lt lu lv b">base64</code>编码格式存储。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="f4c7" class="nt mt iq lv b gy nu nv l nw nx">data:<br/>  foo: YmFy</span></pre><p id="5bb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您解码数据，您可以确认它与我们提供的原始纯文本输入(<code class="fe ls lt lu lv b">bar</code>)相匹配</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="4197" class="nt mt iq lv b gy nu nv l nw nx">echo 'YmFy' | base64 --decode</span><span id="df2f" class="nt mt iq lv b gy ny nv l nw nx">//bar</span></pre><p id="88ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe ls lt lu lv b">data</code>部分不接受纯文本属性。试图这样做将导致类似于<em class="ok"> </em> this: <em class="ok"> </em> <code class="fe ls lt lu lv b"><em class="ok">illegal base64 data at input byte 8</em></code>的错误</p><h2 id="fb56" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated"><strong class="ak">文件内容</strong></h2><p id="4968" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">您也可以将整个文件的内容作为输入提供给<code class="fe ls lt lu lv b">stringData</code>部分。这可能是这样的:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="731d" class="nt mt iq lv b gy nu nv l nw nx">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: secret-in-a-file<br/>stringData:<br/>  app-config.yaml: |-<br/>    hello: world<br/>    john: doe</span></pre><h2 id="fd58" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated">创建此<code class="fe ls lt lu lv b">Secret</code></h2><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="1edd" class="nt mt iq lv b gy nu nv l nw nx">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/secret-file.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/secret-file.yaml</a></span></pre><p id="c2cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个结果<code class="fe ls lt lu lv b">Secret</code>将包含一个名为<code class="fe ls lt lu lv b">app-config.yaml</code>的密钥，其内容(值)将是所提供数据的<code class="fe ls lt lu lv b">base64</code>编码。</p><p id="c30a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像往常一样，您在Kubernetes中确认这一点，并解码内容。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="17a7" class="nt mt iq lv b gy nu nv l nw nx">kubectl get secret/secret-in-a-file -o yaml<br/>echo '&lt;"data" content in yaml response&gt; | base64 --decode</span></pre><p id="c239" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:当您使用这种技术时，您的应用程序负责解析出代表<code class="fe ls lt lu lv b">Secret</code>配置的数据。在这种情况下，它碰巧是换行符分隔的键-值对，但也可能是其他任何东西。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="7f1b" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">使用<code class="fe ls lt lu lv b">kubectl</code></h1><p id="fac4" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">你可以使用<code class="fe ls lt lu lv b">kubectl create secret</code>命令来创建<code class="fe ls lt lu lv b">Secret</code>对象</p><h2 id="3799" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated"><strong class="ak">使用</strong> <code class="fe ls lt lu lv b"><strong class="ak">--from-literal</strong></code></h2><p id="7eae" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">您可以使用CLI使用纯文本数据创建<code class="fe ls lt lu lv b">Secret</code>(这将以<code class="fe ls lt lu lv b">base64</code>编码格式存储在Kubernetes中):</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="aba8" class="nt mt iq lv b gy nu nv l nw nx">kubectl create secret generic redis-credentials --from-literal=user=poweruser --from-literal=password='f0ob@r'</span></pre><h2 id="ba01" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated"><strong class="ak">使用</strong> <code class="fe ls lt lu lv b"><strong class="ak">--from-file</strong></code></h2><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="9180" class="nt mt iq lv b gy nu nv l nw nx">kubectl create secret generic topsecret --from-file=api_keys.txt</span></pre><p id="a7a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将创建一个秘密(<code class="fe ls lt lu lv b">topsecret</code>)</p><ul class=""><li id="af4d" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">与文件同名的密钥，即本例中的<code class="fe ls lt lu lv b">api_keys.txt</code></li><li id="758d" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">和值作为文件的内容</li></ul><h2 id="e3b7" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated"><strong class="ak">从一个目录中的文件</strong></h2><p id="c62d" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">您可以简单地指向一个目录，其中的所有文件都将用于创建<code class="fe ls lt lu lv b">Secret</code>。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="e356" class="nt mt iq lv b gy nu nv l nw nx">kubectl create secret generic topsecrets --from-file=/home/credentials/</span></pre><p id="6a91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你最终会得到</p><ul class=""><li id="be5e" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">多个密钥将与单个文件名相同</li><li id="dad6" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">该值将是相应文件的内容</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="7508" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">使用秘密</h1><p id="972b" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">为了让秘密有用，我们需要确保它们对我们的应用程序(例如，pod)可用。让我们探索一下我们能做到这一点的方法</p><h2 id="748f" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated">环境变量</h2><p id="beea" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">您可以将<code class="fe ls lt lu lv b">Secret</code>数据作为环境变量在<code class="fe ls lt lu lv b">Pod</code>中使用(就像<code class="fe ls lt lu lv b">ConfigMap</code>)。这里有一个例子:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="e6cd" class="nt mt iq lv b gy nu nv l nw nx">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: pod1<br/>spec:<br/>  containers:<br/>    - name: nginx<br/>      image: nginx<br/>      env:<br/>        - name: API_KEY<br/>          valueFrom:<br/>            secretKeyRef:<br/>              name: service-apikey<br/>              key: apikey</span></pre><p id="8af4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe ls lt lu lv b">Secret</code> <code class="fe ls lt lu lv b">service-apikey</code>中的键<code class="fe ls lt lu lv b">apikey</code>，并确保它的值作为<code class="fe ls lt lu lv b">Pod</code>中的环境变量<code class="fe ls lt lu lv b">API_KEY</code>可用。</p><p id="f6e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe ls lt lu lv b">Pod</code>(假设您有根据之前的示例创建的<code class="fe ls lt lu lv b">Secret</code>)并确认。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="6dae" class="nt mt iq lv b gy nu nv l nw nx">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/pod-secret-env.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/pod-secret-env.yaml</a></span><span id="93ad" class="nt mt iq lv b gy ny nv l nw nx">kubectl get pods -w</span></pre><p id="7367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等待<code class="fe ls lt lu lv b">Pod</code>转换到<code class="fe ls lt lu lv b">Running</code>状态。然后，确认环境变量已经被注入到<code class="fe ls lt lu lv b">Pod</code>中。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="0086" class="nt mt iq lv b gy nu nv l nw nx">kubectl exec pod1 -- env | grep API_KEY</span></pre><p id="bc66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该会得到这样的回应——<code class="fe ls lt lu lv b">API_KEY=foobar</code>。</p><p id="4597" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe ls lt lu lv b">envFrom</code>来方便地使用所有条目作为<code class="fe ls lt lu lv b">Pod</code>中的环境变量，而不是引用<code class="fe ls lt lu lv b">Secret</code>中的单个条目。你可以这样使用它:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="9328" class="nt mt iq lv b gy nu nv l nw nx">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: pod2<br/>spec:<br/>  containers:<br/>    - name: nginx<br/>      image: nginx<br/>      envFrom:<br/>        - secretRef:<br/>            name: plaintext-secret</span></pre><p id="226c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用<code class="fe ls lt lu lv b">envFrom.secretRef</code>来指代<code class="fe ls lt lu lv b">plaintext-secret</code> <code class="fe ls lt lu lv b">Secret</code>。要创建这个<code class="fe ls lt lu lv b">Pod</code>:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="4514" class="nt mt iq lv b gy nu nv l nw nx">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/pod-secret-envFrom.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/pod-secret-envFrom.yaml</a></span><span id="7ee8" class="nt mt iq lv b gy ny nv l nw nx">kubectl get pods -w</span></pre><p id="4ad3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等待<code class="fe ls lt lu lv b">Pod</code>转换到<code class="fe ls lt lu lv b">Running</code>状态，然后确认环境变量的存在。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="3856" class="nt mt iq lv b gy nu nv l nw nx">kubectl exec pod2 -- env | grep foo<br/>//foo=bar</span><span id="389d" class="nt mt iq lv b gy ny nv l nw nx">kubectl exec pod2 -- env | grep mac<br/>//mac=cheese</span></pre><p id="6aa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这证实了<code class="fe ls lt lu lv b">foo</code>和<code class="fe ls lt lu lv b">mac</code>都作为环境变量与它们的解码值(即<code class="fe ls lt lu lv b">bar</code>和<code class="fe ls lt lu lv b">cheese</code>)一起被添加到<code class="fe ls lt lu lv b">the</code> Pod中</p><h2 id="b17a" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated"><strong class="ak">卷</strong></h2><p id="90fe" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">您可以将<code class="fe ls lt lu lv b">Secrets</code>作为<code class="fe ls lt lu lv b">Volume</code>安装在<code class="fe ls lt lu lv b">Pod</code>内。例如:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="0fae" class="nt mt iq lv b gy nu nv l nw nx">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: pod3<br/>spec:<br/>  containers:<br/>    - name: nginx<br/>      image: nginx<br/>      volumeMounts:<br/>        - name: apikey-config-volume<br/>          mountPath: /secret<br/>          readOnly: true<br/>  volumes:<br/>    - name: apikey-config-volume<br/>      secret:<br/>        secretName: service-apikey</span></pre><p id="0d78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">apikey-config-volume</code>卷是指<code class="fe ls lt lu lv b">service-apikey</code> <code class="fe ls lt lu lv b">Secret</code>。要创建这个<code class="fe ls lt lu lv b">Pod</code>:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="f2e2" class="nt mt iq lv b gy nu nv l nw nx">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/pod-secret-volume.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/pod-secret-volume.yaml</a></span><span id="7efa" class="nt mt iq lv b gy ny nv l nw nx">kubectl get pods -w</span></pre><p id="0dd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等待<code class="fe ls lt lu lv b">Pod</code>转换到<code class="fe ls lt lu lv b">Running</code>状态。然后执行以下命令:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="951e" class="nt mt iq lv b gy nu nv l nw nx">kubectl exec pod3 -- cat /secret/apikey<br/>//foobar</span></pre><p id="8b70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这确认了密钥<code class="fe ls lt lu lv b">service-apikey</code>中的密钥<code class="fe ls lt lu lv b">apikey</code>作为一个文件(名为<code class="fe ls lt lu lv b">apikey</code>)被安装在<code class="fe ls lt lu lv b">/secret</code>目录中(具体见Pod)。该文件的内容只是秘密值，即本例中的<code class="fe ls lt lu lv b">foobar</code>。</p><h2 id="0570" class="nt mt iq bd mu nz oa dn my ob oc dp nc lf od oe ne lj of og ng ln oh oi ni oj bi translated"><strong class="ak">使用</strong> <code class="fe ls lt lu lv b"><strong class="ak">imagePullSecrets</strong></code></h2><p id="7856" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">有一种方法可以使用<code class="fe ls lt lu lv b">Secrets</code>,这样您的应用程序Pod就可以使用它来认证并从私有Docker注册中心获取Docker图像。</p><p id="53ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Secrets</code>其实有三种类型:</p><ul class=""><li id="a2ff" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated"><code class="fe ls lt lu lv b">generic</code>——用于存储键值对，就像我们在前面的例子中看到的那样</li><li id="be71" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated"><code class="fe ls lt lu lv b">tls</code> -将公钥/私钥对信息存储为<code class="fe ls lt lu lv b">Secrets</code></li><li id="f496" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated"><code class="fe ls lt lu lv b">docker-registry</code> -用于向Docker注册表认证的凭证。</li></ul><p id="7d6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这项技术的使用方法非常简单:</p><ul class=""><li id="0cae" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">使用<code class="fe ls lt lu lv b">docker-registry</code> <code class="fe ls lt lu lv b">Secret</code>类型在Kubernetes中存储私有Docker注册表凭证。</li><li id="0fd4" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">然后使用<code class="fe ls lt lu lv b">imagePullSecrets</code>(在Pod中)来引用包含Docker注册凭证的<code class="fe ls lt lu lv b">Secret</code>。</li></ul><p id="5138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个例子总是有帮助的:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="0152" class="nt mt iq lv b gy nu nv l nw nx">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: pod4<br/>spec:<br/>  containers:<br/>    - name: privateapp<br/>      image: abhirockzz/test-private-repo:latest<br/>      command: ["/bin/sh"]<br/>      args: ["-c", "while true; do date; sleep 5;done"]<br/>  imagePullSecrets:<br/>    - name: docker-repo-secret</span></pre><p id="0cca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看<code class="fe ls lt lu lv b">imagePullSecrets.name</code>怎么指代一个叫<code class="fe ls lt lu lv b">docker-repo-secret</code>的<code class="fe ls lt lu lv b">Secret</code>。让我们创造它。</p><p id="1a10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但在此之前，请确保您有一个私人Docker注册表。我用的是<code class="fe ls lt lu lv b"><a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">DockerHub</a></code>，其他的你也可以选。</p><p id="181d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先使用<code class="fe ls lt lu lv b">kubectl create secret docker-registry</code>命令创建一个包含您的Docker凭证的<code class="fe ls lt lu lv b">Secret</code>(名为<code class="fe ls lt lu lv b">docker-repo-secret</code>)。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="e6c3" class="nt mt iq lv b gy nu nv l nw nx">kubectl create secret docker-registry docker-repo-secret --docker-server=DOCKER_REG_SERVER --docker-username=DOCKER_REG_USERNAME --docker-password=DOCKER_REG_PASSWORD --docker-email=DOCKER_REG_EMAIL</span></pre><p id="6284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Docker Hub:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="3233" class="nt mt iq lv b gy nu nv l nw nx">kubectl create secret docker-registry docker-repo-secret --docker-server=https://index.docker.io/v1/ --docker-username=foobarbaz --docker-password=t0ps3cr3t --docker-email=foobarbaz@gmail.com</span><span id="d8ff" class="nt mt iq lv b gy ny nv l nw nx">kubectl get secret/docker-repo-secret -o yaml</span></pre><p id="8ff1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">https://index.docker.io/v1/</code>是Docker Hub注册服务器</p><p id="83a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进行测试，我们将使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://hub.docker.com/_/busybox" rel="noopener ugc nofollow" target="_blank">busybox</a></code>图像和<code class="fe ls lt lu lv b">tag</code>图像</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="6a29" class="nt mt iq lv b gy nu nv l nw nx">docker pull busybox<br/>docker tag busybox [DOCKER_REG]/[DOCKER_PRIVATE_REPO]:[IMAGE_TAG]</span><span id="26bb" class="nt mt iq lv b gy ny nv l nw nx">e.g. <br/>docker tag busybox abhirockzz/test-private-repo:latest</span></pre><p id="cdf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…和<code class="fe ls lt lu lv b">push</code> it</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="4a9d" class="nt mt iq lv b gy nu nv l nw nx">docker push [DOCKER_REG]/[DOCKER_PRIVATE_REPO]:[IMAGE_TAG]</span><span id="e7da" class="nt mt iq lv b gy ny nv l nw nx">e.g. <br/>docker push abhirockzz/test-private-repo:latest</span></pre><p id="c7a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦私有回购准备就绪，您就可以创建<code class="fe ls lt lu lv b">Pod</code>，它将使用通过<code class="fe ls lt lu lv b">Secret</code>提供给它的注册表凭证从私有回购中提取映像</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="00c4" class="nt mt iq lv b gy nu nv l nw nx">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/pod-secret-docker.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/secrets/pod-secret-docker.yaml</a></span><span id="111d" class="nt mt iq lv b gy ny nv l nw nx">kubectl get pods -w</span></pre><p id="0b10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等待<code class="fe ls lt lu lv b">Pod</code>移动到<code class="fe ls lt lu lv b">Running</code>状态。</p><p id="cccd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您看到一个<code class="fe ls lt lu lv b">ErrImagePull</code>错误，这表明可能存在向Docker注册中心认证的问题。要获取详细信息，请使用:<code class="fe ls lt lu lv b">kubectl describe pod/pod4</code></p><p id="47ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确认pod工作正常:<code class="fe ls lt lu lv b">kubectl logs -f pod4</code></p><p id="102a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe ls lt lu lv b">busybox</code>图像本身并不真正做任何事情，我们执行:<code class="fe ls lt lu lv b">while true; do date; sleep 5;done</code>(如<code class="fe ls lt lu lv b">Pod</code>规范中所提供的)。因此，您应该会看到日志(每5秒打印一次)。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="44ec" class="nt mt iq lv b gy nu nv l nw nx">Tue Dec 17 14:17:34 UTC 2019<br/>Tue Dec 17 14:17:39 UTC 2019<br/>Tue Dec 17 14:17:44 UTC 2019<br/>Tue Dec 17 14:18:49 UTC 2019</span></pre><p id="0fb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一切都好！这意味着Pod能够使用Docker凭证从私有Docker repo中下载你的图像，Docker凭证通过<code class="fe ls lt lu lv b">imagePullSecrets</code>注入到<code class="fe ls lt lu lv b">Pod</code>中，而<code class="fe ls lt lu lv b">imagePullSecrets</code>本身引用了<code class="fe ls lt lu lv b">Secret</code></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="2775" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">很高兴知道</h1><p id="2912" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">以下是您在使用<code class="fe ls lt lu lv b">Secrets</code>时应该谨记的事项列表(并非详尽):</p><ul class=""><li id="6cdb" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated"><code class="fe ls lt lu lv b">Secret</code>必须在任何想要使用它的<code class="fe ls lt lu lv b">Pod</code>之前被创建。</li><li id="68ed" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated"><code class="fe ls lt lu lv b">Secrets</code>在一个<code class="fe ls lt lu lv b">namespace</code>内适用，即它们只能由同一个<code class="fe ls lt lu lv b">namespace</code>内的<code class="fe ls lt lu lv b">Pods</code>使用</li><li id="fc56" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">如果在<code class="fe ls lt lu lv b">Secret</code>中引用了一个不存在的键(使用<code class="fe ls lt lu lv b">secretKeyRef</code>，则<code class="fe ls lt lu lv b">Pod</code>不会启动</li><li id="7c5d" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">1mb是个人的大小限制<code class="fe ls lt lu lv b">Secrets</code></li></ul><p id="31ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是本期《果壳中的库伯内特》系列的全部内容。敬请关注更多内容！</p><p id="bcc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对使用<a class="ae kv" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure </a>学习Kubernetes和Containers感兴趣，只需<a class="ae kv" href="https://azure.microsoft.com/en-us/free/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">创建一个免费账户</a>就可以开始了。一个好的起点是使用文档中的<a class="ae kv" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">快速入门、教程和代码示例</a>来熟悉该服务。我也强烈推荐查看50天的Kubernetes学习路径。高级用户可能希望参考<a class="ae kv" href="https://docs.microsoft.com/azure/aks/best-practices?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Kubernetes最佳实践</a>或观看一些<a class="ae kv" href="https://azure.microsoft.com/resources/videos/index/?services=kubernetes-service&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">视频</a>以了解演示、主要特性和技术会议。</p><p id="4311" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的希望你喜欢这篇文章，并从中学到了一些东西。🙌</p></div></div>    
</body>
</html>