<html>
<head>
<title>Visual Regression Testing Is Awesome</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">视觉回归测试棒极了</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/visual-regression-testing-is-awesome-a6ac081ce58f?source=collection_archive---------5-----------------------#2021-12-08">https://betterprogramming.pub/visual-regression-testing-is-awesome-a6ac081ce58f?source=collection_archive---------5-----------------------#2021-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9ef1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实现持续交付的里程碑</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/04718132c02bb25a4f9fa43b779f283a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aq0QvIEEchoIEQu8r6EHpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">由Brgfx / Freepik设计</a></p></figure><p id="c761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试的重要性怎么强调都不为过。它帮助我们识别缺陷，减少瑕疵，增加代码的整体健壮性。我们可以理解我们的代码是如何处理极限情况的。我们可以将测试分为三类:</p><ul class=""><li id="26b9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">单元测试</li><li id="3e54" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">集成测试</li><li id="ed68" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">端到端测试</li></ul><p id="0b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些共同构成了测试金字塔。它是一个框架，帮助开发人员和QAs确保生产出高质量的软件。在这三个国家中，e2e是最具挑战性的。</p><p id="9a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？因为我们直接测试最终应用，这带来了许多挑战。这些年来，工具有了显著的改进。为了执行端到端的web测试，我们有一些很棒的工具，比如木偶师、剧作家、Selenium和Cypress。</p><p id="bbbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这些工具只是关注于从浏览器中断言元素、导航、交互性和其他特性的存在。他们缺少测试的一个重要方面:用户实际看到的东西。这就是所谓的视觉测试。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e8cd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">什么是视觉回归测试？</h1><p id="b4d5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">视觉测试是一个简单而强大的概念:断言用户看到的是否正是我们期望他看到的。这意味着元素的颜色、位置和形状等任何细节都和它们在DOM中的存在一样重要。</p><p id="7a20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过一个例子来看看。假设我们的登录页面如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/8074dcd28c20cc5c67888f25d1e88026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2sB8xE_CMqNkFA-cGEbUqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自lingoda.com的说明</p></figure><p id="04b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个重构PR，它产生如下布局:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/2f3cae762edd8b322adbad8bef66f762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BaYn_ghHSqiKbwJUd0XRuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模拟破碎的用户界面布局</p></figure><p id="b655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到上述变化，我们的传统e2e测试不会失败。该按钮存在、可点击且功能正常。只有按钮的布局在视觉上被破坏了，但这并不影响它的交互性。</p><p id="4773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于上述变化非常明显，QA可能会在测试阶段发现它。但是如果变化更微妙呢？如果按钮只是窄了10px呢？这可能会被忽视。人类在重复性任务上效率低下。这就是为什么我们不断依赖计算机来做这种工作。</p><p id="cbff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们拒绝做可视化回归测试呢？如果我们在几周、几个月、几年内增加一些小的变化，我们最终会得到一个在我们眼前不断变形和发展的应用程序。</p><p id="d738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在生产中捕捉UI故障是很耗费资源的。我们有一系列问题要回答。布局是怎么被打破的？破了多少次了？它应该是什么样子的？</p><p id="2be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不对我们的应用程序进行可视化测试会带来一些大风险:</p><ul class=""><li id="c6b6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">开发成本:</strong>识别+修复+手工回归+出货生产。</li><li id="a103" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">公司品牌:</strong>产品中不断引入的小故障会影响用户对我们应用程序质量的感知。</li><li id="bf2f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">对收入的影响:</strong>误放CTA、意外移除等都会影响我们的业务收入。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d10b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">功能测试能涵盖视觉问题吗？</h1><p id="cd1a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">鉴于我们已经确定了风险，我们可能想要采取行动。因为我们已经有了很棒的e2e工具，我们能调整我们的e2e功能测试来捕捉所有这些视觉上的错误吗？可行吗？是的，在某种程度上。我们可以断言元素的位置、大小、颜色、形状……这些都可以从DOM中获得。</p><p id="5071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想走这条路吗？绝对不行！为什么？</p><ul class=""><li id="8555" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">断言UI元素会大大增加我们的测试套件。</li><li id="ea3f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">测试不会有可读性，也不会充满神奇的数字。</li><li id="6d9d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当一个测试失败时，要知道它是否是一个有意的改变是非常耗时的。我们缺乏可视化的工具来显示差异。</li><li id="b7e5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个微小的UI更改可能会破坏数百个需要手动修复的测试。</li><li id="2eca" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们的测试套件不容易扩展。如果我们想要支持一个新的屏幕分辨率，我们将手动将其添加到所有现有的测试中。</li></ul><p id="aede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我们决定继续使用这个解决方案，我们也不可能做到超级精确。为此，我们必须模拟浏览器的渲染过程。所以一开始就接受失败是值得的。</p><p id="fef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能雇佣更多的QA工程师来帮助解决这个问题吗？如前所述，人类往往会对重复的任务感到厌倦。他们不可能发现所有的问题。即使我们的QA团队非常擅长发现差异，他们也只能做到这一点。</p><p id="7655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来计算一些数字:</p><ul class=""><li id="6bb9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们想测试一个有10个屏幕的web应用程序。</li><li id="f2a9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">每个屏幕有2个变体。</li><li id="b972" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们支持4种不同的语言。</li><li id="2c13" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们想确保输出工作在3种不同的浏览器和3种不同的屏幕分辨率。</li></ul><p id="a8d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们需要测试:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="078a" class="nt mr it np b gy nu nv l nw nx">10 [screens] * 2 [variants] * 4 [lang] * 3 [browsers] * 3 [screen res] = <strong class="np iu">720 outputs</strong></span></pre><p id="bce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们无法管理和扩展手动测试过程。因为我们看到功能e2e测试不适合这个目的，所以我们只有一个选择:可视化回归测试。这是实现持续交付的唯一可行的解决方案。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dbd5" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何进行可视化回归测试</h1><p id="5be7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">幸运的是，有一些好的服务可以提供可视化测试。他们将为我们做所有的重活。他们将处理和识别UI上的变化。然后，由我们来决定这些UI更改是否是有意的，或者是否需要采取任何进一步的措施。</p><p id="6414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是如何工作的？它们提供了与我们喜爱的e2e测试工具的集成，并公开了一个开发人员友好的API。所以我们可以使用我们最喜欢的Cypress或Selenium引擎，并在上面添加一个视觉测试。这将是我们测试的额外一层。</p><p id="8ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谁是这个领域的顶尖选手？我们可以按照开源和专有对它们进行分组:</p><ul class=""><li id="b01f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">开源:</strong>选择不少。排在前面的是<code class="fe ny nz oa np b">BackstopJS</code>和<code class="fe ny nz oa np b">Loki</code>。不幸的是，这些都缺乏在线审批流程。这是我们测试工作流程中的必备功能。选项是我们自己构建它，然后托管它。</li><li id="a679" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">专有:</strong>SaaS顶级支付宝产品有<code class="fe ny nz oa np b">Percy</code><strong class="lb iu"/><code class="fe ny nz oa np b">Applitools</code>。他们几乎可以提供我们需要的任何东西。</li></ul><p id="5dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，花时间开发我们自己的批准工具流是不值得的。所以我们只能在<strong class="lb iu">珀西</strong>和<strong class="lb iu">应用工具</strong>之间做出选择。他们有什么不同？如何在它们之间做出选择？</p><p id="ab01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它们的主要区别和注意事项:</p><h2 id="a6a1" class="nt mr it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated"><strong class="ak">珀西</strong></h2><p id="40de" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">珀西工具最近被Browserstack收购，现在是他们生态系统的一部分。如果我们已经在使用他们的服务，这将是一个很大的好处。</p><p id="7bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它在内部是如何运作的？它确实将HTML流式传输到他们的服务器，并在那里进行渲染和截图。它会将这些与该页面的基线进行比较，并计算出差异。整个过程异步运行，并在我们的CI中发布。例如通过行动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/f11c1fb9c946e5be54042cbd2825bd27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*YIxBE0vzTRWZ24oJ.png"/></div></figure><p id="9acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义视觉差异的阈值是多少？它可以在他们的用户界面中根据我们的喜好进行调整。模式多样:<code class="fe ny nz oa np b">Strict</code>、<code class="fe ny nz oa np b">Recommended</code>、<code class="fe ny nz oa np b">Relaxed</code>。</p><p id="5705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们比较一下<code class="fe ny nz oa np b">strict</code>和<code class="fe ny nz oa np b">recommended</code>设置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/6052efba37e7fe566d094f5b5a345302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUtwqkMMJb3nQMu_pshmSg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">percy.io的严格敏感度字幕</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/48d1bae82a69396a0f0893bba27c514b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLdlAVNAIzV-KVsqzIZAUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">percy.io推荐的灵敏度标题</p></figure><p id="3023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，推荐的那个做得很好。</p><p id="eb40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面珀西行动的例子。让我们在下面看看当前基线(左)与新快照(右)。他们看起来几乎一模一样。由于这种差异很微妙，很可能不会被人眼注意到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/f3d9e9c3b3f392bd9d94732842827e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pa6F3ruzw8qwdxWRbXVpqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基线与新截图</p></figure><p id="13c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">珀西引擎将处理这两幅图像并输出它们的差异。现在很清楚是什么改变了:按钮中的填充。这将由我们来决定是否有意改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/19c9f6e6efd993c4c4e59093559a47a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSI5R1_yCE3bESpgd20p0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">处理差异的结果</p></figure><p id="fef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它如何处理动态数据？简单地说。我们应用程序中的任何动态元素都需要通过媒体查询隐藏起来，或者采用任何策略，比如冻结日期。</p><h2 id="74a2" class="nt mr it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">应用工具</h2><p id="30cd" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这个工具比珀西复杂一点。它给视觉测试带来了人工智能能力。这是什么意思？这个系统将从一个全新的层面理解我们的系统。这将导致更好的视觉测试质量，因为它将远远超出像素水平的差异。</p><p id="2a20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它如何了解我们的应用程序？实际上是我们需要向系统反馈我们的布局是如何构建的。默认情况下，在<code class="fe ny nz oa np b">Strict</code>模式下比较整页。当需要时，我们可以定制应用程序的区域，以不同的方式声明视觉内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/e364f89aeec9bbb00a3592a8ece25f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*pYVFd7oNCVpeyIG-WyWlZA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">applitools.com描述</p></figure><ul class=""><li id="b450" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> Exact: </strong>会检测到连人眼都察觉不到的变化。不建议使用。</li><li id="4528" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">严格(默认设置):</strong>这几乎等同于珀西发现差异的方式</li><li id="5bb0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">内容</strong>:类似于严格但忽略了颜色之类的东西。</li><li id="353f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">布局</strong>:比较元素在页面上的位置和呈现方式。它是动态日期或动态内容变化元素的理想选择。</li></ul><p id="bc76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Percy一样，Applitools会将基线与当前快照进行比较，并显示其差异。这一过程类似，但由人工智能驱动，而不是基于像素。由于我们能够更好地微调我们的基线，我们可以期待更好的结果，而无需手动破解来避开动态数据。</p><p id="bd57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Applitools服务与我们的e2e提供商更紧密地结合在一起。即使AI处理仍然发生在他们的服务器上，e2e进程也会阻止测试完成，直到Applitools处理完成。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2dbe" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="51d7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们需要接受并采用可视化回归测试作为我们测试工具的一部分。这是我们实现连续交货的唯一途径。否则，我们将需要继续让QA参与到无聊的任务中，这些任务只能让我们在产品质量方面达到某一点。</p><p id="19bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过选择加入，我们可以让QA团队专注于他们真正擅长的事情。那就是确保我们的新功能符合我们的质量标准。他们将从任何手工工作中解放出来，甚至可以就如何使系统更加健壮提出自己的意见。</p><p id="bbd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">珀西vs Applitools呢？由你决定，如果你需要一个能正常工作的人，我会选珀西。测试动态元素需要更多的开发工作，但这是可以管理的。我可以看到他们在正片中赶上了AI。如果你现在需要一个更强大的工具来覆盖你的各种场景，那么就使用Applitools吧。它已经具备了你可能想要的所有功能。它被宣传为对开源项目免费。</p><p id="c989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你有疑问时，试试他们的免费试用期，然后再做决定。</p><p id="d762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯。</p><div class="or os gp gr ot ou"><a rel="noopener  ugc nofollow" target="_blank" href="/react-enzyme-vs-react-testing-library-2cac3ad20c52"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">反应酶与反应测试库</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">比较用于测试React组件的两个对比库</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">better编程. pub</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div></div></div>    
</body>
</html>