# 建造。验证。用 JavaScript 部署电子邮件。

> 原文：<https://betterprogramming.pub/build-validate-deploy-emails-in-javascript-9bbac9ab6433>

## 将事务性电子邮件集成到您的持续部署流程中

![](img/bc09db4dfb62e3541c44bfe749d3980b.png)

亚当·索罗门在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

为了满足 GDPR 的需求，很明显，我不能再推迟在我的应用程序中添加电子邮件集成了。电子邮件营销网站提供了“漂亮的、获奖的模板”，但它们缺乏的——也是我渴望的——是像我维护应用程序的其他部分一样维护电子邮件的能力:通过 GitHub 跟踪更改，以便它可以经历相同的审查和部署过程。

# 环境

您的设置不一定要与我的完全相同，但是它可以提供一些上下文。

*   **使用 npm 工作区的 Monorepo。**我有一个包含我的电子邮件模板的包和另一个集成这些电子邮件的后端功能包。重要的是这些包彼此保持同步，构建脚本进一步强制它们一起部署。
*   **GitHub 动作持续部署。**您在这里选择什么并不重要——只要您将电子邮件部署为后端的一部分。
*   **用于将电子邮件模板转换为库的 Webpack。这部分很酷，我等不及要给你看了。**
*   **用于创建模板的 MJML。**构建 HTML 邮件是一件痛苦的事，MJML 大大简化了它。
*   **MailerSend 用于创建交易电子邮件。任何服务都可以很好地工作，但是我喜欢它的一点是 API 包括了一个变量插值的策略。我用这个功能来定制我的电子邮件。**
*   **发送交易邮件的 Firebase 函数。**目前，我有一个用户请求下载数据的触发器和一个用户删除数据的触发器。两者都向用户发送电子邮件。

# 后端集成

创建可持续部署的电子邮件不仅仅是为了让部署变得容易，也是为了让开发变得容易。引导这一决策过程意味着解决后端服务如何使用电子邮件模板的问题。

## 在本地文件系统上创建电子邮件

我用 [MailerSend](https://www.mailersend.com/) 发送交易邮件。他们的电子邮件 API 需要主题行、文本格式、HTML 内容、发件人和收件人字段。在第一种方法中，我设计并编写了等效的 HTML 内容，并将其存储在文件中，这些文件将在服务器运行时加载到内存中。从 HTML 内容中，我可以提取主题行(从`<title></title>`标签)和等价的文本内容(使用 npm 库 [html 到文本](https://www.npmjs.com/package/html-to-text))。

事实证明，为电子邮件编写 HTML 内容是出了名的困难。该标准(现在已有 20 多年的历史)是在现代移动友好发展之前创建的。我认为我可以通过复制现有的电子邮件模板，然后调整它们以支持我的需求来颠覆这一过程，但结果从未像我希望的那样好。

谢天谢地，我找到了一种叫做 [Mailjet 标记语言](http://mjml.io)(简称 MJML)的格式。MJML 提供了一些简单而健壮的类似 HTML 的标签，可以编译成等价的 HTML。我很高兴找到了提高开发效率的解决方案，但这是以运行时效率为代价的。从磁盘加载 MJML 文件，将它们转换成 HTML，以及提取文本和主题内容都需要成本。我担心，随着需要更多的事务性电子邮件，运行时间成本可能会高得令人望而却步。

运行时成本起了一定作用，但是向 MJML 的过渡使得代码验证变得很烦人。文件必须先转换成 HTML 格式，然后才能在浏览器中查看。我需要一个服务器端的渲染器来缩短开发反馈循环。有了这个服务器，我考虑我的后端服务器是否可以使用这个服务来检索电子邮件 API 数据。

## 托管“电子邮件服务”

这种方法有几个优点。首先，后端服务器不再有任何文件转换操作的负担。这个“电子邮件服务”可以从单个端点以 JSON 文档的形式提供必要的内容。另一个好处是，更改电子邮件内容不一定需要更改后端服务器。这反过来鼓励了将电子邮件模板隔离到它们自己的专用包中的想法，因为它现在可以从后端服务器中分离出来。

托管电子邮件服务器有其自身的风险。首先，我必须将我所有的电子邮件模板暴露在互联网上。这本身没什么大不了的，因为内容最终会根据用户执行的操作提供给用户，但这确实有点草率。

另一个风险是可用性。当东西是本地的时——无论是在文件系统上还是在内存中——它总是可供访问的。从终端下载时，必须解决一些问题，例如，

*   如果端点不可用，我该怎么办？
*   我应该多长时间尝试访问一次该端点？
*   访问这个端点的开销是多少？
*   我应该缓存从该端点收集的数据吗？

然后是兼容性问题。MailerSend 允许您为变量插值定义占位符。例如，我有一个功能，允许用户请求下载他们数据的副本。当后端收到数据下载请求时，它会将用户数据上传到一个归档文件中，该归档文件可以通过用户在电子邮件中收到的临时链接进行访问。因为该链接不是静态信息，所以在模板中描述了一个占位符，当电子邮件准备发送时，该占位符将被 URL 替换。

添加或更改变量时会出现问题。如果后端没有提供所有变量的值，那么您可能会发送看起来不正确的电子邮件。一个解决方案将意味着必须支持同一封电子邮件的多个版本，但这似乎是低效和可悲的不必要的，因为后端是这些电子邮件的唯一消费者。

## 编译的电子邮件模板

由于文件系统电子邮件会产生不必要的运行时开销，托管电子邮件会导致可用性和兼容性问题，我最终选择的第三个选项是将这些 MJML 电子邮件文件编译成与后端兼容的代码库。这解决了兼容性问题，因为后端总是知道它正在使用的版本。可用性和运行时问题变得没有实际意义，因为必要的信息是在编译时计算的。

由于后端是用 JavaScript 编写的，所以我将重点介绍这次编译的 JavaScript 实现。然而，这个想法仍然适用于任何其他语言的选择。

使用 Webpack，我编写了自己的 MJML webpack 加载器。它将每个电子邮件模板转换成包含主题、文本和 HTML 内容字段的 Javascript 对象。代码如下:

我使用了一个[例子](https://github.com/rDr4g0n/basic-es6-webpack)来设置 webpack。

然后我将代码集成到后端服务器中。作为我的 monorepo 中的一个单独的库，我使用了 [npm 工作区](https://docs.npmjs.com/cli/v7/using-npm/workspaces)来减轻一些与本地管理的 npm 库相关的不友好。因为后端是由 Firebase 函数提供的，所以进行这种集成会有自己的尖刺坑和摆动刀片。虽然同情很有趣，但最好留给另一个讨论。

# 开发服务器

尽管不再需要托管电子邮件模板的电子邮件服务，但它在开发过程中仍然有助于确保我构建的东西看起来像我想要的样子。邮件包有一个名为`views/`的目录。该路径包含所有要构建到库中并由后端服务器使用的电子邮件模板。

然后，我设置了一个带有定制引擎的 [ExpressJS](http://expressjs.com/) 服务器，将 MJML 文件转换成 HTML 和纯文本文档，以便在浏览器中呈现。每个 MJML 文件对应于三个服务器端点:没有扩展名`.mjml`的根文件名、扩展名为`.html`的根文件名和扩展名为`.txt`的根文件名。无扩展和`.html`扩展返回相同的 HTML 输出，而`.txt`扩展返回纯文本输出。

## 可变插值

如前所述，其中一个后端功能允许用户请求一个可下载的数据存档。产生的操作向用户发送了一封电子邮件，其中包含指向其信息的自定义链接。为了将该链接注入到生成的导出电子邮件中，使用了变量插值法。因为这产生了一些可变性，所以我需要一种方法来确保生成的电子邮件的预期行为。因此，我更新了服务器，以接受作为插值的查询参数，这些参数可以被解释并转换成 HTML 和纯文本格式。代码如下:

## 管理资产

资产包括公司名称、应用程序徽标的 URL、隐私政策的链接、服务条款和订阅选项等。虽然这些信息甚至可以在 HTML 输出生成之前手动注入到电子邮件中，但我相信，将这些信息整合到单个端点中，不仅有利于电子邮件，还有利于整个应用程序。

尽管之前反对从服务器端点检索电子邮件，但从端点托管公司配置具有以下优势:

1.  更少的代码重复和错别字。我复制公司徽标或隐私政策等链接的次数越少，我就越不用担心在链接改变时更新(或忘记更新)链接。
2.  资产变更不一定要求我重新构建整个项目。一旦发生页面刷新或用户请求被触发，更新就会被反映出来。
3.  因为它是一个被管理的相对较小的 JSON 文件，所以当服务被迁移以使用新的密钥时，处理破坏兼容性的更改会更容易一些。

有了从端点检索配置的选项，这些数据现在可以用于我的电子邮件模板。我向电子邮件服务器添加了中间件，以将该配置与查询参数合并，如下所示:

# 持续部署

我可以将电子邮件构建到 JavaScript 对象中，并通过在浏览器中观察这些电子邮件来确保模板的有效性。最后，我需要将所有这些功能编织到部署中。至关重要的一点是，电子邮件库必须始终与后端服务器保持同步。因为我使用 [GitHub Actions](https://github.com/features/actions) 来管理我的部署，所以需要对后端服务工作流进行这些更改:

1.  检测到电子邮件路径更改时添加触发器。
2.  将电子邮件库构建为工作流构建的一部分。
3.  确保在部署到暂存环境时禁用发送电子邮件。

我最初认为电子邮件似乎与应用程序无关，直到我意识到它是用户在使用多种网络应用程序时的大量交互。确保电子邮件的审查行为与代码库的其余部分保持一致有很大的价值，这种方法演示了如何通过一点努力和一些小代码片段来实现这一点。

感谢阅读！