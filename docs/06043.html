<html>
<head>
<title>5 Pairs of Magic Methods in Python That You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的Python中的5对神奇方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-pairs-of-magic-methods-in-python-you-should-know-f98f0e5356d6?source=collection_archive---------2-----------------------#2020-08-28">https://betterprogramming.pub/5-pairs-of-magic-methods-in-python-you-should-know-f98f0e5356d6?source=collection_archive---------2-----------------------#2020-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7f8c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解与这些神奇方法相关的五个关键Python概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a55b246c628f695277f8e093e732f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pukyMNLwO5Uatu9t"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@liz_hixon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Liz Hixon </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="5746" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="2d1d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当谈到Python中的命名函数时，我们可以使用下划线以及字母和数字。当单词之间使用下划线时，它们没有太大的意义——它们只是通过在单词之间创建空格来提高可读性。这就是众所周知的蛇命名风格。例如，<code class="fe mn mo mp mq b">calculate_mean_score</code>比<code class="fe mn mo mp mq b">calculatemeanscore</code>更容易阅读。如你所知，除了这种使用下划线的常见方式，我们还在函数名前加上一两个下划线(例如，<code class="fe mn mo mp mq b">_func</code>，<code class="fe mn mo mp mq b">__func</code>)来表示这些函数是在类或模块中私有使用的。不带下划线前缀的名称被视为公共API。</p><p id="854d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">下划线在函数命名中的另一种用法是魔法方法，也称为特殊方法。具体来说，我们在函数名之前和之后放置两个下划线——类似于<code class="fe mn mo mp mq b">__func__</code>。由于使用了双下划线，有些人将特殊方法称为“邓德方法”或简称为“邓德”在本文中，我想回顾五对密切相关的常见魔术方法，每一对代表一个Python概念。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="cfa1" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">1.实例化:__new__和__init__</h1><p id="5c44" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在学习了Python数据结构的基础知识(例如，字典、列表)之后，您应该已经看到了一些定义定制类的例子，在这些例子中，您第一次接触到了一种神奇的方法— <code class="fe mn mo mp mq b">__init__</code>。此方法用于定义实例对象的初始化行为。具体来说，在<code class="fe mn mo mp mq b"> __init__</code>方法中，您希望为创建的实例对象设置初始属性。这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">__init__方法</p></figure><p id="dded" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">当我们使用<code class="fe mn mo mp mq b">__init__</code>方法时，我们不直接调用它。相反，<code class="fe mn mo mp mq b">__init__</code>方法成为类的构造函数方法的构建基础，它与<code class="fe mn mo mp mq b">__init__</code>方法具有相同的函数签名。例如，要创建一个新的<code class="fe mn mo mp mq b">Product</code>实例，使用下面的代码:</p><pre class="kj kk kl km gt nk mq nl nm aw nn bi"><span id="7c3e" class="no la it mq b gy np nq l nr ns">product = Product(<strong class="mq iu">"Vacuum"</strong>, 150.0)</span></pre><p id="fbc9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">与<code class="fe mn mo mp mq b">__init__</code>方法密切相关的是<code class="fe mn mo mp mq b">__new__</code>方法，我们通常不会在自定义类中实现它。本质上，<code class="fe mn mo mp mq b">__new__</code>方法实际上创建了实例对象，该对象被传递给<code class="fe mn mo mp mq b">__init__</code>方法以完成初始化过程。</p><p id="99d0" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><em class="nt">换句话说，构造一个新的实例对象(称为实例化的过程)需要依次调用</em> <code class="fe mn mo mp mq b"><em class="nt">__new__</em></code> <em class="nt">和</em> <code class="fe mn mo mp mq b"><em class="nt">__init__</em></code> <em class="nt">方法。</em></p><p id="8dab" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">下面的代码向您展示了这样一个反应链:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实例构建过程</p></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="31dc" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">2.字符串表示形式:__repr__和__str__</h1><p id="d23c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这两种方法对于为自定义类设置正确的字符串表示都很重要。在解释它们之前，让我们快速看一下下面的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">字符串表示</p></figure><p id="1dd7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><em class="nt"/><code class="fe mn mo mp mq b"><em class="nt">__repr__</em></code><em class="nt">方法应该返回一个字符串，显示如何创建实例对象。</em>具体来说，可以将字符串传递给<code class="fe mn mo mp mq b">eval()</code>来重新构造实例对象。以下代码片段向您展示了这样的操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">__repr__字符串的求值</p></figure><p id="08ba" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><em class="nt"/><code class="fe mn mo mp mq b"><em class="nt">__str__</em></code><em class="nt">方法可以返回更多关于实例对象的描述。</em>需要注意的是<code class="fe mn mo mp mq b">print()</code>函数使用了<code class="fe mn mo mp mq b">__str__</code>方法来显示实例相关的信息，如下所示。</p><pre class="kj kk kl km gt nk mq nl nm aw nn bi"><span id="2ea1" class="no la it mq b gy np nq l nr ns">&gt;&gt;&gt; print(product)<br/>Product: Vacuum, $150.00</span></pre><p id="10b7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">虽然这两个方法都应该返回字符串，但是<code class="fe mn mo mp mq b">__repr__</code>方法通常是为开发人员设计的，所以我们希望显示实例化信息，而<code class="fe mn mo mp mq b">__str__</code>方法是为普通用户设计的，所以我们希望显示更多的信息。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="153e" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">3.迭代:__iter__和__next__</h1><p id="9e53" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以用代码自动化的一个关键操作是为我们重复某项工作，它的实现涉及到作为逻辑流的for循环。就相关对象而言，可以在for循环中使用的是iterable。for循环的基本形式如下所示:</p><pre class="kj kk kl km gt nk mq nl nm aw nn bi"><span id="3899" class="no la it mq b gy np nq l nr ns">for item in iterable:<br/>    # Operations go here</span></pre><p id="f498" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在底层，iterable被转换为迭代器，它为每个循环提供iterable中的项。<em class="nt">一般来说，迭代器是Python对象，可以用来渲染要迭代的项目。</em> <strong class="lt iu"> </strong>通过实现<code class="fe mn mo mp mq b">__iter__</code>特殊方法完成转换。此外，检索迭代器的下一项涉及到<code class="fe mn mo mp mq b">__next__</code>特殊方法的实现。让我们继续前面的例子，让我们的<code class="fe mn mo mp mq b">Product</code>类在for循环中作为迭代器工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义迭代器</p></figure><p id="13b4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如上所示，我们在<code class="fe mn mo mp mq b">__iter__</code>方法中创建了一个包含免费样本的对象列表，为定制类实例创建了一个迭代器。为了实现迭代行为，我们通过呈现免费样本列表中的对象来实现<code class="fe mn mo mp mq b">__next__</code>方法。当我们用完免费样本时，迭代结束。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="4cbd" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">4.上下文管理器:__enter__和__exit__</h1><p id="ad97" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们在Python中处理文件对象时，您可能遇到的最常见的语法可能是这样的:</p><pre class="kj kk kl km gt nk mq nl nm aw nn bi"><span id="6ed1" class="no la it mq b gy np nq l nr ns">with open('filename.txt') as file:<br/>    # Your file operations go here</span></pre><p id="41b9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">with</code>语句的使用被称为上下文管理器技术。具体来说，在上面的文件操作示例中，<code class="fe mn mo mp mq b">with</code>语句将为文件对象创建上下文管理器，并且在文件操作之后，上下文管理器将帮助我们关闭文件对象，使得共享资源(即，文件)可用于其他进程。</p><p id="52a3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">所以，<em class="nt">一般来说，上下文管理器是管理共享资源</em>的Python对象，比如为我们打开和关闭。没有它们，我们必须手动管理它们，这很容易出错。</p><p id="8614" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">为了用自定义类实现这样的行为，我们的类需要实现<code class="fe mn mo mp mq b">__enter__</code>和<code class="fe mn mo mp mq b">__exit__</code>方法。<code class="fe mn mo mp mq b">__enter__</code>方法设置上下文管理器，为我们操作准备所需的资源，而<code class="fe mn mo mp mq b">__exit__</code>方法是清理任何应该释放的已用资源，使它们可用。让我们考虑一下前面的<code class="fe mn mo mp mq b">Product</code>类的简单例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上下文管理器</p></figure><p id="25f7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">正如您所看到的，当实例对象嵌入到一个<code class="fe mn mo mp mq b">with</code>语句中时，就会调用<code class="fe mn mo mp mq b">__enter__</code>方法。当操作在<code class="fe mn mo mp mq b">with</code>语句中完成时，调用<code class="fe mn mo mp mq b">__exit__</code>方法。</p><p id="d20f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">然而，应该注意的是，我们可以实现<code class="fe mn mo mp mq b">__enter__</code>和<code class="fe mn mo mp mq b">__exit__</code>方法来创建上下文管理器。使用上下文管理器装饰函数可以更容易地做到这一点——您可以在我之前的文章中找到关于这个主题的更多信息。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="c4b4" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">5.更精细的属性访问控制:__getattr__和__setattr__</h1><p id="9896" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您有其他语言的编程经验，您可能已经习惯于为实例属性设置显式的getters和setters。在Python中，我们不需要对每个单独的属性使用这些访问控制技术。然而，我们可以通过实现<code class="fe mn mo mp mq b">__getattr__</code>和<code class="fe mn mo mp mq b">__setattr__</code>方法来进行一些控制。具体来说，当访问实例对象的属性时会调用<code class="fe mn mo mp mq b">__getattr__</code>方法，而当我们设置实例对象的属性时会调用<code class="fe mn mo mp mq b">__setattr__</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">属性的访问控制</p></figure><p id="022e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">每次我们试图设置对象的属性时，都会调用<code class="fe mn mo mp mq b">__setattr__</code>方法。要正确使用它，您必须通过使用super()来使用超类方法。否则，它将陷入无限递归。</p><p id="5eae" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">设置完<code class="fe mn mo mp mq b">formatted_name</code>属性后，该属性将成为<code class="fe mn mo mp mq b">__dict__</code>对象的一部分，所以<code class="fe mn mo mp mq b">__getattr__</code>不会被调用。</p><p id="3080" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">顺便提一下，还有另一个与访问控制密切相关的特殊方法叫做<code class="fe mn mo mp mq b">__getattribute__</code>，它类似于<code class="fe mn mo mp mq b">__getattr__</code>，但是每次访问一个属性时都会被调用。在这方面，它类似于<code class="fe mn mo mp mq b">__setattr__ </code>——同样，您应该使用<code class="fe mn mo mp mq b">super()</code>来实现<code class="fe mn mo mp mq b">__getattribute__</code>方法，以避免无限递归错误。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="823c" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">结论</h1><p id="aa33" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们回顾了五对重要的特殊方法，通过这些方法，我们学习了与每一对相关的五个Python概念。我希望您对这些概念以及如何在自己的Python项目中使用特殊方法有更好的理解。</p></div></div>    
</body>
</html>