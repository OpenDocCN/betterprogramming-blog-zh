<html>
<head>
<title>Understanding SwiftUI Data Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解SwiftUI数据流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-swiftui-data-flow-79429a49ae35?source=collection_archive---------3-----------------------#2019-08-05">https://betterprogramming.pub/understanding-swiftui-data-flow-79429a49ae35?source=collection_archive---------3-----------------------#2019-08-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1bb4" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">一些关键协议和属性包装器的初级读本</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/942752ebb3c9b6370a2705cd33877b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3ZnXTNE15lZBcgjwSHdYA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">摘自https://developer.apple.com/videos/play/wwdc2019/226/ WWDC 2019关于SwiftUI数据流的主题演讲:<a class="ae kz" href="https://developer.apple.com/videos/play/wwdc2019/226/" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="50d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我见过许多人在SwiftUI中构建他们的应用程序时遇到困难——因为这是一个全新的范例，而且因为它几乎没有官方文档。我想通过这篇文章来分享SwiftUI所公开的各种属性包装器的用例，以帮助您的应用程序中的数据流。</p><p id="81c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">即使有点过时(因为SwiftUI已经收到了很多重构)，我也不能充分推荐2019年关于SwiftUI数据流的WWDC会议。正是由于这次会议，我第一次掌握了SwiftUI的全部功能，并启动了<a class="ae kz" href="https://github.com/Dimillian/MovieSwiftUI" rel="noopener ugc nofollow" target="_blank"> MovieSwiftUI </a>。</p><div class="lw lx gq gs ly lz"><a href="https://developer.apple.com/videos/play/wwdc2019/226/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">通过SwiftUI的数据流- WWDC 2019 -视频-苹果开发者</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">SwiftUI是从头开始构建的，让您可以编写漂亮而正确的用户界面，避免不一致…</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">developer.apple.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kt lz"/></div></div></a></div><p id="81ed" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你得看看苹果的SwiftUI数据流文档，是最新的，一点也不差。它有些缺乏具体的例子，这是我在本文中试图提供的。</p><div class="lw lx gq gs ly lz"><a href="https://developer.apple.com/documentation/swiftui/state_and_data_flow" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">状态和数据流</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">状态和绑定将视图连接到应用程序的基础数据模型。当您声明一个状态时，SwiftUI会存储它以用于…</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">developer.apple.com</p></div></div></div></a></div></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="bed2" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">可观察物体</h1><p id="d65b" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated"><code class="fe ns nt nu nv b"><a class="ae kz" href="https://developer.apple.com/documentation/combine/observableobject" rel="noopener ugc nofollow" target="_blank">ObservableObject</a></code>是一个协议，是<a class="ae kz" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">组合</a>框架的一部分。要使用它，您只需将协议添加到您的模型类，然后标记<code class="fe ns nt nu nv b">@Published</code>您希望SwiftUI在该模型中观察的任何属性。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><h2 id="9c4a" class="ny mw iu bd mx nz oa dn nb ob oc dp nf lj od oe nh ln of og nj lr oh oi nl oj bi translated">什么时候用？</h2><p id="47dc" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">这是一个很好的协议，可以在您的视图模型上使用，或者如果您没有或不需要视图模型，可以直接在您的模型上使用。基本上，任何需要保存您将在视图中直接使用的属性的对象都应该用<code class="fe ns nt nu nv b">@Published</code>标记/包装在<code class="fe ns nt nu nv b">ObservableObject</code>中。你可以把它看作SwiftUI模型基类——尽管它是一个协议，而不是一个类。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="fd37" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">@ObservedObject</h1><p id="2c79" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">您可能已经猜到，这个属性包装器将在convert中与符合<code class="fe ns nt nu nv b">ObservableObject</code>的ViewModel类一起使用。它会将您的对象包装成一个动态视图属性，允许SwiftUI订阅您的对象，并在您的模型中的某个<code class="fe ns nt nu nv b"> @Published</code>属性发生变化时使其视图体无效。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><h2 id="2323" class="ny mw iu bd mx nz oa dn nb ob oc dp nf lj od oe nh ln of og nj lr oh oi nl oj bi translated">什么时候用？</h2><p id="fce3" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">每当您需要将一个<code class="fe ns nt nu nv b">ObservableObject</code>绑定到您的视图时使用它。换句话说，任何时候你都需要更新你的视图。</p><h2 id="1af0" class="ny mw iu bd mx nz oa dn nb ob oc dp nf lj od oe nh ln of og nj lr oh oi nl oj bi translated">注意</h2><p id="9b73" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">SwiftUI视图是值类型(因为它们是Struct ),例如，如果视图是由父视图重新创建的，那么它不会将您的对象保留在其视图范围内。所以最好通过引用传递那些可观察的对象，并有一种容器视图，或holder类，它将实例化和引用那些对象。如果该视图是对该对象的唯一引用，并且因为SwiftUI更新了其父视图而重新创建了该视图，那么您将丢失您的<code class="fe ns nt nu nv b">ObservedObject</code>的当前状态。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="041e" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">@州</h1><p id="3140" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated"><code class="fe ns nt nu nv b"><a class="ae kz" href="https://developer.apple.com/documentation/swiftui/state" rel="noopener ugc nofollow" target="_blank">@State</a> </code>一个在SwiftUI中会经常用到的属性包装器。它创建一个持久值(在视图刷新之间持久)。如上所述，理解SwiftUI视图是结构并且它们是值类型是很重要的——swift ui可以出于任何原因随时重新创建您的视图。因此，按照设计，视图中的所有属性都是不可变的，并且会在视图被重新创建时被重新创建——例如，仅仅因为父视图决定这样做。您可以将其视为本地视图状态。</p><p id="05e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，如果您想为这个视图创建一个本地的、持久化的值，您可以改变它(然后触发一个视图更新)，您可以使用<code class="fe ns nt nu nv b">@State</code>属性包装器。额外的好处是，SwiftUI还会订阅它，并在视图或绑定发生变化时，使视图的相关部分失效并刷新。</p><p id="b6fb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如您在下面这段代码中看到的，SwiftUI的<code class="fe ns nt nu nv b">Tabbar</code>组件<code class="fe ns nt nu nv b">TabView</code>接受一个绑定，您可以通过使用<code class="fe ns nt nu nv b">$</code>从<code class="fe ns nt nu nv b">@State</code>属性生成绑定。我们将在下一节中更多地讨论绑定。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><h2 id="d7d3" class="ny mw iu bd mx nz oa dn nb ob oc dp nf lj od oe nh ln of og nj lr oh oi nl oj bi translated">什么时候用？</h2><p id="f6b4" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">任何时候你需要存储和持久化一个与你的视图相关的状态。您需要将<code class="fe ns nt nu nv b">@State</code>属性包装器视为需要持久化的特定于视图的本地数据。它可以是<code class="fe ns nt nu nv b">Tabbar</code>的选中标签，或者是<code class="fe ns nt nu nv b">TextField</code>的文本值，或者是<code class="fe ns nt nu nv b">Image</code>视图的<code class="fe ns nt nu nv b">UIImage</code>值。还有一个<code class="fe ns nt nu nv b">Bool</code>值，用于控制<code class="fe ns nt nu nv b">.sheet</code>、<code class="fe ns nt nu nv b">.popover</code>或<code class="fe ns nt nu nv b">.actionSheet</code>是否出现。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="187a" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">@绑定</h1><p id="1f46" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">属性包装器是一种创建双向连接的方法，该连接指向由其他东西管理的值。它很可能是来自父视图的<code class="fe ns nt nu nv b">@State</code>——这是使用它的最常见方式。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="e0c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，你可以看到我的<code class="fe ns nt nu nv b">NotificationBadge</code>组件——把它想象成一个烤面包机，当用户做一些动作时，它会在屏幕底部显示几秒钟。</p><p id="960d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">isShown <code class="fe ns nt nu nv b">Bool</code>属性通过绑定传递。这意味着当你创建一个<code class="fe ns nt nu nv b">NotificationBadge</code>视图时，你需要传递一个由<code class="fe ns nt nu nv b">@State</code>控制的<code class="fe ns nt nu nv b">Bool</code>。您可以使用<code class="fe ns nt nu nv b">$</code>从一个状态创建一个绑定。您也可以手动创建一个绑定(稍后将详细介绍)，或者从一个<code class="fe ns nt nu nv b">ObservableObject</code> <code class="fe ns nt nu nv b">@Published</code>属性创建一个绑定。</p><p id="e583" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您还可以改变绑定值。例如，我可以在我的<code class="fe ns nt nu nv b">NotificationBadge</code>组件中使用<code class="fe ns nt nu nv b">isShow.value = false</code>将其转换为false。这将使<code class="fe ns nt nu nv b">State</code>变异，因此它更新了<code class="fe ns nt nu nv b">NotificationBadge</code>和父视图状态。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">以下是如何使用NotificationBadge的示例</p></figure><h2 id="a32a" class="ny mw iu bd mx nz oa dn nb ob oc dp nf lj od oe nh ln of og nj lr oh oi nl oj bi translated">什么时候用？</h2><p id="45cc" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">上面的例子是一个很好的例子。<code class="fe ns nt nu nv b">Binding</code>通常用于传递一个由父视图控制和持久化的值，当这个值改变时使你的视图失效。是<code class="fe ns nt nu nv b">TextField</code>、<code class="fe ns nt nu nv b">Toggle</code>、自定义组件等的好工具。通过传递一个<code class="fe ns nt nu nv b">@State</code>作为绑定，您可以在复杂的视图层次结构中传播更改和创建关系，同时确保只有一个视图保持其值。</p><h2 id="e4b1" class="ny mw iu bd mx nz oa dn nb ob oc dp nf lj od oe nh ln of og nj lr oh oi nl oj bi translated"><strong class="ak">手动创建绑定</strong></h2><p id="acdf" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">你也可以自己创建一个<code class="fe ns nt nu nv b">Binding&lt;Value&gt;</code>。Apple为此提供了一个非常方便的init方法。这个特性的强大之处在于，当值被设置并从您选择的存储器中读取时，您可以触发动作和副作用。在我的例子中，我主要使用它来绑定到存储在我的<code class="fe ns nt nu nv b">AppState</code> redux存储中的一个值，并在它被设置时分派期望的动作。这是我的上下文菜单的一个例子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="c1c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如您所见，我在按钮操作中切换绑定，这将分派我的商店的操作，并将绑定值更新为所需的布尔值，这最终将更新我的视图。干净简单。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="c012" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">@环境对象</h1><div class="lw lx gq gs ly lz"><a href="https://developer.apple.com/documentation/swiftui/environmentobject" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">环境对象</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">一种动态视图属性，使用祖先视图提供的可绑定对象来使当前视图无效…</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">developer.apple.com</p></div></div></div></a></div><p id="645d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ns nt nu nv b">@EnvironmentObject</code>是一个属性包装器，如果您向当前视图层次结构的任何父视图提供一个<code class="fe ns nt nu nv b">.environmentObject()</code>就可以使用它。</p><p id="3b9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你提供的对象必须符合<code class="fe ns nt nu nv b">ObservableObject</code>，如果你提供了你的应用的根视图，如下面的示例代码，它将在你的应用的任何视图中可用。如果你想在应用程序的整个生命周期中拥有一个可用的对象，这是一个强大的工具。</p><p id="7162" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我使用的Redux模式中，我注入了整个持有<code class="fe ns nt nu nv b">AppState</code>的<code class="fe ns nt nu nv b">store</code>，所以我可以在任何视图中访问它。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="5cfd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，在任何视图中，您都可以使用<code class="fe ns nt nu nv b">@EnvironmentObject </code>属性包装器。您的视图订阅它，并根据您从对象中获得的数据更新它的内容。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="66a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，我使用了属性包装器，所以我的视图可以访问并订阅在根视图中注入的<code class="fe ns nt nu nv b">EnvironmentObject</code>。</p><h2 id="649f" class="ny mw iu bd mx nz oa dn nb ob oc dp nf lj od oe nh ln of og nj lr oh oi nl oj bi translated">什么时候用？</h2><p id="f362" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">上面的例子就是一个很好的例子。我的存储保存了对我的应用程序至关重要的模型和数据，因此让它始终注入和可用是有意义的。我的观点将随着它的更新而更新。</p><p id="7049" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这基本上是一个依赖注入系统，所以它也是一个强大的预览和调试工具。例如，我注入了一个样本存储，这样我就可以模拟数据，而无需启动网络查询。</p><p id="87a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您还可以为您的UI注入自定义值——可能是动态调色板。也许还有一些数据库管理器，它将在他持有的包装了<code class="fe ns nt nu nv b">@Published</code>属性的对象中发布结果。</p><p id="0f58" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ns nt nu nv b">EnvironmentObject.</code>有很多很多可能性，如果你熟悉Swift上的其他依赖对象库，你会很快看到它能打开的大门。</p><p id="1755" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果没有，这是为应用程序中使用的模型提供某种持久性的最佳位置，而不是，例如，单一变量或全局变量。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="cc9c" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">结论</h1><p id="00bf" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">我希望这篇文章对SwiftUI数据流这个大主题有所启发。虽然UIKit在这个主题上没有施展任何魔法，但是SwiftUI提供了许多工具，并且在某种程度上，它比UIKit更“在轨道上”。这有点难掌握，但是一旦你开始熟练使用它，你的应用程序就会像变魔术一样工作并更新它们的视图！</p><p id="e321" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我看来，它还能让开发人员花更少的时间设计他们的模型层，而花更多的时间在UI上。如果您正确使用这些工具，您可以删除大量杂乱的代码、手动绑定、通知、委托、闭包完成处理程序等。</p><p id="88ae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读！</p></div></div>    
</body>
</html>