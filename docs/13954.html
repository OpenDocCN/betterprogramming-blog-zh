<html>
<head>
<title>Build and Deploy TypeScript Functions Using Vercel and Prisma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vercel和Prisma构建和部署TypeScript函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-and-deploy-typescript-functions-using-vercel-and-prisma-997b3e2415dd?source=collection_archive---------9-----------------------#2022-10-18">https://betterprogramming.pub/build-and-deploy-typescript-functions-using-vercel-and-prisma-997b3e2415dd?source=collection_archive---------9-----------------------#2022-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c349" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个由无服务器功能和数据库支持的行星追踪应用程序，点击一下就可以部署到网络上</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ef990db0c36ef24b64f7c618861600f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDZL_j2FHiaBi6eEytN5JQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lanirudhreddy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿尼鲁德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/planet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="fd10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vercel是一个允许您轻松配置和部署应用程序的平台，它有一个很棒的免费层。作为其产品的一部分，您可以创建Vercel函数，这些函数运行在服务器上，充当应用程序的后端。这使得构建可伸缩和持久的web应用程序变得简单。</p><p id="f6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程将研究如何使用TypeScript(Javascript的一个强类型子集)、Prisma(一个强大的ORM)和SQLite来实现这一点。最后，您将知道如何创建和部署自己的应用程序，并能够存储和检索数据。我们将创建一个应用程序，让你添加新的行星到数据库中，然后查看它们。</p><p id="d4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">你可以在</em>  <em class="lv">这里找到本文的所有代码</em> <a class="ae ky" href="https://github.com/asleepyghost/vercel-prisma-golang-article" rel="noopener ugc nofollow" target="_blank"> <em class="lv">。</em></a></p><h1 id="0ec5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">前端设置</h1><p id="cf03" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">虽然前端在这里并不重要，因为本教程更多的是关于作为后端的函数。我们仍然会设置一些基本的东西。有一个记录数据的地方是很好的，它将更好地模拟真实世界的应用程序。</p><p id="5e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用任何你想要的框架，但是我将使用React和Create-React-App。</p><p id="977e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe mt mu mv mw b">npx create-react-app my-app</code>。</p><p id="3e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:如果出现这样的错误:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="e3e5" class="nb lx it mw b gy nc nd l ne nf">You are running `create-react-app` &lt;version&gt;, which is behind the latest release (&lt;version&gt;).</span><span id="400c" class="nb lx it mw b gy ng nd l ne nf">We no longer support global installation of Create React App.</span><span id="a68e" class="nb lx it mw b gy ng nd l ne nf">Please remove any global installs with one of the following commands:</span><span id="a436" class="nb lx it mw b gy ng nd l ne nf">- npm uninstall -g create-react-app</span><span id="394e" class="nb lx it mw b gy ng nd l ne nf">- yarn global remove create-react-app</span></pre><p id="fd3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请按照说明卸载全局create-react-app包并运行<code class="fe mt mu mv mw b">npx clear-npx-cache</code>，然后再次运行该命令。它可能在不清除npx缓存的情况下工作，但对我来说没有。</p><h1 id="b9a5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Vercel设置</h1><p id="f75d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">去<a class="ae ky" href="https://vercel.com" rel="noopener ugc nofollow" target="_blank">https://vercel.com</a>创建一个账户。</p><p id="4c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后您会想要导入一个GitHub存储库，所以让我们来创建它。转到<a class="ae ky" href="https://github.com" rel="noopener ugc nofollow" target="_blank">https://github.com</a>并创建您的新存储库。完成后，从快速设置部分获取repo URL，并在您的终端中刚刚创建的应用程序的根目录下输入以下命令。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="5b3b" class="nb lx it mw b gy nc nd l ne nf">git remote add origin &lt;repository-url&gt;</span></pre><p id="c0ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后只需添加、提交和推送现有内容。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="032b" class="nb lx it mw b gy nc nd l ne nf">git add -A<br/>git commit -m 'Initial commit'<br/>git push --set-upstream origin main</span></pre><p id="1a9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你刷新GitHub窗口，你会看到你所有的文件。</p><p id="61d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，回到韦尔塞尔，在这个观点上:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/755c53af29124f468f30076d14de81c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYaoLC6WKugqZnbwE8D17Q.png"/></div></div></figure><p id="7905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点按“继续GitHub”并导入您的新项目，然后按照向导进行设置。如果您使用一个众所周知的框架，Vercel可能已经为您预填充了所有正确的命令。否则，您必须为您选择的方法手动输入这些信息。</p><p id="65e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署完成后，您应该能够通过Vercel仪表板访问托管站点。</p><h1 id="aed1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">一个基本的Vercel函数</h1><p id="f3ab" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们将快速创建一个简单的函数来测试我们的Vercel设置。</p><p id="4dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，运行<code class="fe mt mu mv mw b">npm i @vercel/node</code>。对于我们接下来要使用的一些类型，我们需要这个包。</p><p id="b14c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vercel函数位于项目根目录下的一个<code class="fe mt mu mv mw b">api/</code>文件夹中。现在创建这个。</p><p id="4c9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将一个<code class="fe mt mu mv mw b">index.ts</code>文件添加到您的文件夹中，并粘贴以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="51d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的函数的URL将与其在API文件夹中的位置相匹配。因此，我们刚刚创建的这个函数将可以在服务器上的同名路径中访问:<code class="fe mt mu mv mw b">/api</code>。如果我们把一个函数放在<code class="fe mt mu mv mw b">/api/users</code>文件夹中，那么它可以在路径<code class="fe mt mu mv mw b">/api/users</code>中被访问。如果我们使用一个段，比如<code class="fe mt mu mv mw b">/api/users/get/[id].ts</code>，那么我们将能够点击<code class="fe mt mu mv mw b">/api/users/get/&lt;some-id&gt;</code>，然后检索我们通过请求对象传递的id。如果这还不完全合理，也不要担心。教程结束的时候就知道了。</p><h1 id="b3ff" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">运行我们的功能</h1><p id="238c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，您可以在您的终端中运行<code class="fe mt mu mv mw b">vercel dev</code>。它将引导您完成一个向导，您可以在其中设置您的项目并将其链接到您创建的Vercel项目(当选项出现时，您必须复制并粘贴这个项目的名称)。这个命令将启动一个本地服务器，运行你的前端和后端功能。</p><p id="05df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦完成，访问<code class="fe mt mu mv mw b">localhost:3000</code>，我们可以写一些代码来测试这个功能。</p><h1 id="d68d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">测试功能</h1><p id="5bf5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了检查这个函数是否正常工作，我们只需使用一些HTTP库来调用正确的URL。我就用<code class="fe mt mu mv mw b">axios</code>。</p><p id="e438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行<code class="fe mt mu mv mw b">npm i axios</code>将它安装到您的项目中。</p><p id="9de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，打开<code class="fe mt mu mv mw b">App.js</code>文件，该文件可以在项目的<code class="fe mt mu mv mw b">src</code>文件夹中找到。删除所有内容并粘贴到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e9c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是为了使代码干净并且易于使用。保存此文件。你在<code class="fe mt mu mv mw b">http://localhost:3000</code>的应用也应该更新。</p><p id="376d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您加载该窗口，然后检查运行<code class="fe mt mu mv mw b">npx vercel dev</code>的终端窗口，您应该会看到文本<code class="fe mt mu mv mw b">Hello World</code>。</p><p id="8fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于上面的代码是做什么的，我不会讲太多细节，因为这是非常基本的，不是本教程要讲的。但是通过调用服务器上的<code class="fe mt mu mv mw b">api/</code>路由，我们已经在我们的<code class="fe mt mu mv mw b">src/</code>文件夹中的相同路径下调用了索引文件中的处理程序。稍后，您将看到当我们调用不同的路径时会发生什么。</p><p id="2519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，您已经创建了一个react项目，创建了一个TypeScript函数，部署了两者，并通过Axios请求将它们连接起来。从这里开始，您就有了开始构建整个应用程序的基础工具。</p><p id="eae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您愿意留下来，我们接下来将使用Prisma建立一个内存数据库，生成一个模式，并创建两条允许我们存储和检索一些数据的路径。一旦完成，您将拥有一个端到端的应用程序，并具有持久性。</p><h1 id="3a68" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">普里斯马</h1><p id="4c6b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要将Prisma添加到您的项目中，导航到根目录并运行<code class="fe mt mu mv mw b">npx prisma init</code>。</p><p id="56c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到已经创建了一个包含模式文件的<code class="fe mt mu mv mw b">prisma/</code>文件夹。这将包含您的Prisma配置和您的模型。</p><p id="a493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在打开这个文件，你会看到两件事。首先是一个<code class="fe mt mu mv mw b">generator</code>街区。你可以忽略这个；它只是告诉Prisma你正在使用js客户端。</p><p id="65d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个是<code class="fe mt mu mv mw b">datasource</code>块。Prisma可以使用许多数据库，如Postgres和Mongo。它的一个主要好处是，不管底层数据库技术如何，它都允许您编写相同的代码。<code class="fe mt mu mv mw b">datasource</code>块是您定义想要使用的数据库的地方。</p><p id="928c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，它被设置为Postgres数据库，但是我们将把它改为<code class="fe mt mu mv mw b">sqlite</code>。连接Postgres数据库超出了本文的范围，但是要知道，对于Postgres、Mongo或其他任何东西，您将要做的一切都是一样的，如果您将来想添加其中一个的话。</p><p id="e5ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新<code class="fe mt mu mv mw b">datasource</code>块，如下所示:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="7278" class="nb lx it mw b gy nc nd l ne nf">datasource db {<br/>  provider = "sqlite"<br/>  url      = "file:./dev.db"<br/>}</span></pre><p id="01b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<code class="fe mt mu mv mw b">url</code>属性指向一个文件<code class="fe mt mu mv mw b">dev.db</code>，Prisma将在这里记录我们所有的数据库写操作。现在在<code class="fe mt mu mv mw b">prisma</code>文件夹中创建它。</p><h1 id="05d8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">创建模型</h1><p id="cbf1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">模型定义了我们希望在应用程序中使用的数据类型，并直接对应于数据库中的表。</p><p id="637d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下内容粘贴到您的<code class="fe mt mu mv mw b">schema.prisma</code>文件中:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9770" class="nb lx it mw b gy nc nd l ne nf">model Planet {<br/>  id   String <a class="ae ky" href="http://twitter.com/unique" rel="noopener ugc nofollow" target="_blank">@unique</a> <a class="ae ky" href="http://twitter.com/default" rel="noopener ugc nofollow" target="_blank">@default</a>(cuid())<br/>  name String<br/>  size Int<br/>}</span></pre><p id="15be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prisma最好的一点就是容易理解，上面的代码也不例外。它说我们想要在数据库中创建一个包含三列的<code class="fe mt mu mv mw b">Planet</code>表:<code class="fe mt mu mv mw b">id</code>、<code class="fe mt mu mv mw b">name</code>和<code class="fe mt mu mv mw b">size</code>。<code class="fe mt mu mv mw b">id</code>字段被标记为<code class="fe mt mu mv mw b">@unique</code>，将其设置为该记录的主键(这是我们识别该特定记录的方式)。</p><p id="fc66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有模型必须至少有一个唯一字段。否则，不可能在数据库中找到它们。现在，运行<code class="fe mt mu mv mw b">npx prisma db push</code>将您的模式推送到数据库。</p><p id="7701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，运行<code class="fe mt mu mv mw b">npx prisma generate</code>。这将创建一个Prisma客户端，您可以使用它来执行数据库操作。它还将为您的所有数据库模型生成TypeScript类型，这意味着您永远不必手动维护一组独立于您的数据库的类型。这是避免由不同步类型引起的错误的好方法。</p><h1 id="15f4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">新的行星功能</h1><p id="e803" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，导航回您的<code class="fe mt mu mv mw b">api/</code>文件夹，并在路径<code class="fe mt mu mv mw b">api/planet/new.ts</code>下创建一个<code class="fe mt mu mv mw b">new.ts</code>文件。这将是我们负责向数据库添加新行星的API路径。</p><p id="971b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，Prisma是一种非常简单的技术，所以像数据库写入这样的事情很容易。这里，我们在第4行实例化了Prisma客户端，然后在第7行，我们调用了<code class="fe mt mu mv mw b">planet</code>表上的<code class="fe mt mu mv mw b">create</code>方法。之后，我们只需将想要保存的数据传递给它。第14行返回一个对FE的响应，表示一切顺利。</p><p id="2b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我在这个函数中添加了<code class="fe mt mu mv mw b">async</code>关键字，因为数据库操作是异步的。</p><h1 id="ddbe" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">调用新的行星函数</h1><p id="76c3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们需要在前端调用新的planet函数。我不会对下面的代码进行过多的描述，因为它只是React的内容，并不是本教程的真正内容。</p><p id="642a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我首先向<code class="fe mt mu mv mw b">App.js</code>组件添加了两个状态字段和一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2ed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我给<code class="fe mt mu mv mw b">App.js</code>组件添加了一些JSX，这样我们可以输入一些星球的细节并保存它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，运行<code class="fe mt mu mv mw b">npx vercel dev</code>并导航至<code class="fe mt mu mv mw b">localhost:3000</code>。打开你的浏览器开发工具，在框中输入一些细节，点击保存。您应该会看到一个以<code class="fe mt mu mv mw b">Planet created</code>为主体的<code class="fe mt mu mv mw b">200</code>响应。</p><p id="8740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将设置一个函数来返回所有的行星，并将它们呈现到页面上。</p><h1 id="d50c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">所有行星功能</h1><p id="392a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，在您的<code class="fe mt mu mv mw b">new.ts</code>文件旁边，创建一个<code class="fe mt mu mv mw b">all.ts</code>文件。把这个放进去:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prisma的<code class="fe mt mu mv mw b">findMany</code>函数，如果没有传递任何参数，就返回该表中的所有记录。这就是我们所需要的。</p><h1 id="82bd" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">调用所有行星函数</h1><p id="e722" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了显示行星，我们需要向<code class="fe mt mu mv mw b">App.js</code>组件添加更多的状态字段和函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ff41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">getPlanets</code>函数调用API，我们必须在<code class="fe mt mu mv mw b">useEffect</code>钩子中和保存一个新星球后调用它，这样列表就可以实时更新。</p><p id="6491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们只需要添加JSX来显示我们创建的行星。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="b7ea" class="nb lx it mw b gy nc nd l ne nf">&lt;div&gt;<br/>  &lt;h2&gt;Planets&lt;/h2&gt;<br/>  {planets.map((planet) =&gt; (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;{planet.name}&lt;/h3&gt;<br/>      &lt;p&gt;{planet.size}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  ))}<br/>&lt;/div&gt;</span></pre><p id="a2b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该就是这样了。如果你最后一次导航到<code class="fe mt mu mv mw b">http://localhost:3000</code>，你应该会看到你在最后一部分创建的星球被渲染在那里。如果你添加一个新的，它也会出现。</p><p id="c6a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需最少的代码，您就可以将一个数据库支持的应用程序部署到web上，而无服务器后端完全由Vercel管理和扩展。你可以在这里建造任何你想要的东西。</p></div></div>    
</body>
</html>