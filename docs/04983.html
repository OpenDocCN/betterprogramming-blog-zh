<html>
<head>
<title>How to Build a Service-Agnostic Analytics Layer Into Your iOS App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在您的iOS应用中构建一个与服务无关的分析层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-service-agnostic-analytics-layer-into-your-ios-app-da533059c818?source=collection_archive---------11-----------------------#2020-05-27">https://betterprogramming.pub/how-to-build-a-service-agnostic-analytics-layer-into-your-ios-app-da533059c818?source=collection_archive---------11-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9174" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无论您使用什么分析服务，触发一次事件并将其记录在正确的服务中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de9327c32d8a06fec55f9fc3a00e4c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mP_x5F-8LnqndbUv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hngstrm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨利&amp;公司</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="6ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们为了分析的目的想要集成一个库。我们可以从按照指南设置库开始，然后跟踪事件。太棒了。一切正常。</p><p id="6b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但很快，我们可能会开始询问如何集成其他库进行分析，每个库可以负责跟踪应用程序中的不同事件。此时，一切都变得更加困难，我们到处都有分析代码，我们的应用程序需要处理所有的库。我们的代码不再可维护。</p><p id="6dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将有助于减少外部库和代码之间的耦合。这个解决方案也可以用于其他主题。最佳实践是不要直接依赖外部库。</p><p id="a6ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们可以用来解决问题的图表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/8ea375cfa28a0f2a90ade5e0b1a8144c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eiOoijDnkf7Texg4_2vKxw.jpeg"/></div></div></figure><p id="4612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个图有很多好处。我们有包装器层，它将抽象我们使用的不同SDK的接口。每当我们想要包含一个新的服务时，我们只需要创建一个新的包装器。此外，每个服务可以订阅它想要跟踪的事件列表，让我们可以自由地跟踪每个库中的不同事件。另一个目标涉及我们的应用程序，它不知道任何关于正在使用的服务的信息，因为它只知道<code class="fe lw lx ly lz b">AnalyticsManager</code>。因此，当我们的应用程序想要跟踪某个东西时，它只需要调用<code class="fe lw lx ly lz b">AnalyticsManager</code>。</p><p id="f44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经有理论了，那就开始吧。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9ed0" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">AnalyticsServiceType协议</h1><p id="b29d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在该协议中，我们有两个几乎所有分析软件开发套件都具备的主要功能:</p><ul class=""><li id="9f12" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">初始化</li><li id="e380" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">跟踪</li></ul><p id="d223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们还有一个额外的属性，那就是我们想要跟踪的事件列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="13e8" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">事件和部分事件</h1><p id="d456" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们可以在一个枚举上表示不同的事件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a0f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">AnalyticsEvent</code>上，我们有一些其他的属性，比如<code class="fe lw lx ly lz b">analyticsSection</code>。该属性允许我们将所有事件组织得更加有序，因为我们可以对共享相同上下文的事件进行分组(例如，入职、用户设置等)。</p><p id="b99b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们使用<code class="fe lw lx ly lz b">AnalyticsSection</code>来订阅每个服务。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="f361" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">包装材料</h1><p id="550d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这是包装协议的<a class="ae ky" href="https://gist.github.com/lucasPelizza/a3f126a7c15e423f5fb070601473bba5" rel="noopener ugc nofollow" target="_blank">示例实现</a>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b7a1" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">分析经理</h1><p id="a06d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们需要创建的最后一个类是我们的<code class="fe lw lx ly lz b">AnalyticsManager</code>。在这种情况下，<code class="fe lw lx ly lz b">AnalyticsManager</code>不是单例，因为我试图避免在代码中创建单例。还有，我用DI。我并不是说使用单例是错误的——这取决于你。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1c7e" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">加班</h1><p id="f339" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有了尽可能隔离我们的应用程序的想法，我们可以在不同的目标上创建所有的类和协议，实现我们的应用程序和分析材料之间的真正隔离。</p><p id="46d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是我们可以创建的一些附加文件。</p><h2 id="5f44" class="nu mi it bd mj nv nw dn mn nx ny dp mr li nz oa mt lm ob oc mv lq od oe mx of bi translated">AnalyticsServiceIntegrationType</h2><p id="1cfe" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这个枚举用于<code class="fe lw lx ly lz b">AnalyticsManager</code>的初始化，允许我们的应用程序不与任何外部库联系。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f1ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用我们的分析层:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a9df" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="3d0b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">每当我们的应用程序依赖于外部实现时，它都是未来的头痛问题。我们可以通过编写一些协议和包装库来减少耦合，从而避免这种情况。如果我们遵循这种模式，我们将能够灵活地更改/添加分析SDK。</p><p id="2807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以遵循这种模式，同时进行一些小的修改，以便与其他库一起使用。</p></div></div>    
</body>
</html>