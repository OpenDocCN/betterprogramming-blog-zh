<html>
<head>
<title>Modern Networking Layers in iOS Using Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中使用Async/Await的现代网络层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-networking-layers-in-ios-using-async-await-ab98a4b5802c?source=collection_archive---------3-----------------------#2022-03-16">https://betterprogramming.pub/modern-networking-layers-in-ios-using-async-await-ab98a4b5802c?source=collection_archive---------3-----------------------#2022-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2c1b4c00473078f8570a829dde63a2be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fm8Tib7EcTHHh-jK5e3eGw.png"/></div></div></figure><div class=""/><div class=""><h2 id="3258" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated"><em class="kq">重新审视利用Swift并发模型的网络主题</em></h2></div><p id="a9c0" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我必须承认:制作网络层对我来说一直是一个令人兴奋的话题。自从2007年初iOS编程的第一天开始，每个新项目都代表了一个新的机会来完善甚至打破我迄今为止使用的整个方法。我最后一次尝试就这个话题<a class="ae ln" href="https://danielemargutti.medium.com/network-layers-in-swift-updated-version-539d9c636b8" rel="noopener">写点东西是在2017年</a>，我认为这是改用Swift语言后的一个里程碑。</p><p id="a144" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从那以后已经很久了；这种语言像系统框架一样发展，最近，随着新的<a class="ae ln" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" rel="noopener ugc nofollow" target="_blank"> Swift并发模型</a>的引入，我决定更进一步，更新我的网络层方法。这个新版本经历了彻底的重新设计，允许你用一行代码写一个<a class="ae ln" href="https://github.com/immobiliare/RealHTTP" rel="noopener ugc nofollow" target="_blank">请求:</a></p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="cdc5" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这时候你可能在想:<em class="lu">我为什么要做我的客户端而不是依赖Alamofire？你说得对。新的实现不可避免地是不成熟的，并且在一定时间内会成为问题的根源。尽管如此，您有机会创建一个与您的软件的微调集成，并避免第三方依赖。此外，你可以利用苹果的新技术，比如<a class="ae ln" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank"> URLSession </a>、<a class="ae ln" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank"> Codable </a>、<a class="ae ln" href="https://developer.apple.com/videos/play/wwdc2021/10132/" rel="noopener ugc nofollow" target="_blank"> Async/Await </a>、&amp;、T16】 Actors 。<br/>可以在GitHub上找到代码；该项目名为<a class="ae ln" href="https://github.com/immobiliare/RealHTTP" rel="noopener ugc nofollow" target="_blank"> RealHTTP </a>。</em></p><h1 id="d794" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">客户</h1><p id="f2b3" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">让我们从定义一个表示客户端的类型开始。客户机(以前称为<code class="fe ms mt mu mv b"><a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Sources/RealHTTP/Client/HTTPClient/HTTPClient.swift" rel="noopener ugc nofollow" target="_blank">HTTPClient</a></code>)是一种结构，它带有cookies、头、安全选项、验证器规则、超时以及一组请求之间可能共有的所有其他共享设置。当您在客户端中运行请求时，所有这些属性都自动来自客户端，除非您在单个请求中对其进行自定义。</p><p id="3cac" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，当您执行一个auth调用并接收一个JWT令牌时，您可能希望在客户端级别设置凭证，因此任何其他请求都会包含这些数据。验证器也会发生同样的情况:为了避免复制数据验证的逻辑，您可能希望创建一个新的验证器，并让客户机为它获取的每个请求执行它。客户端也是实现基本<code class="fe ms mt mu mv b">URLSession</code>实现中没有的重试机制的绝佳候选。</p><h1 id="49f6" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">请求</h1><p id="9b43" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">可以想象，一个请求(以前的<code class="fe ms mt mu mv b"><a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Sources/RealHTTP/Client/HTTPRequest/HTTPRequest.swift" rel="noopener ugc nofollow" target="_blank">HTTPRequest</a></code>)封装了一个对端点的调用。</p><p id="a470" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你已经阅读了关于这个主题的其他文章，你可能会发现一个常见的选择是使用<a class="ae ln" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" rel="noopener ugc nofollow" target="_blank"> Swift的通用</a>来处理请求的输出。<br/>类似于:<code class="fe ms mt mu mv b">struct HTTPRequest&lt;Response&gt;</code>。</p><p id="0f78" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它允许您将输出对象类型与请求本身紧密地联系起来。虽然这是对这个奇妙构造的巧妙使用，但我发现它使请求变得有点限制性。从实际的角度来看，你可能需要使用<a class="ae ln" href="https://fabernovel.github.io/2020-06-03/approaches-to-type-erasure-in-swift" rel="noopener ugc nofollow" target="_blank">类型擦除</a>来处理上下文之外的对象。此外，从概念上讲，我更喜欢将请求阶段(fetch ~&gt;get raw data ~&gt;object decode)分开并易于识别。</p><p id="4df5" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出于这些原因，我选择避免泛型，从请求中返回原始响应(<code class="fe ms mt mu mv b">HTTPResponse</code>);因此，该对象将包含所有允许轻松解码的函数(我们将在下面看一下)。</p><h1 id="d85c" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">配置请求</h1><p id="7e91" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">正如我们所说的，请求必须允许我们轻松地设置调用的所有相关属性，尤其是“HTTP方法”、“路径”、“查询变量”和“主体”。Swift开发者最爱什么？类型安全。</p><p id="097e" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我用两种方式完成了它:使用配置对象而不是文字和协议来提供可扩展的配置以及一组预制的构建器函数。</p><p id="d727" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是请求配置的一个示例:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="58b2" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类型安全的一个典型例子是成为枚举的HTTP方法；还包括使用自定义<code class="fe ms mt mu mv b">HTTPHeader</code>对象管理的标题，因此您可以编写如下内容:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="f3f9" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它支持类型安全密钥声明和自定义文本。</p><p id="d77b" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用协议的最好例子是请求的主体设置。虽然它最终是一个二进制流，但我决定创建一个结构来保存数据内容，并添加一组实用方法来创建最常见的主体结构(<code class="fe ms mt mu mv b">HTTPBody</code>):多部分表单、JSON编码的对象、输入流、URL编码的主体等。</p><p id="7cbb" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果是:</p><ul class=""><li id="b011" class="mw mx jb kt b ku kv kx ky la my le mz li na lm nb nc nd ne bi translated">可扩展接口:您可以为自己的数据结构创建自定义主体容器，并直接设置它们。只要让它符合<code class="fe ms mt mu mv b">HTTPSerializableBody</code>协议，允许在需要时对数据流进行自动序列化。</li><li id="7d15" class="mw mx jb kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated">易于使用的API集:您可以直接从<code class="fe ms mt mu mv b">HTTPBody</code>结构提供的静态方法中创建所有这些容器</li></ul><p id="e29d" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一个多部分表单的示例:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="f6ed" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用JSON编码的对象生成主体也只需要一行代码:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1f8d" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当一个请求被传递给客户机时，相关的<code class="fe ms mt mu mv b">URLSessionTask</code>被自动创建(在另一个线程中),因此标准的<code class="fe ms mt mu mv b">URLSession</code>流被执行。底层逻辑仍然使用<code class="fe ms mt mu mv b">URLSessionDelegate</code>(以及家族的其他委托)；你可以在<code class="fe ms mt mu mv b"><a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Sources/RealHTTP/Client/Internal/HTTPDataLoader/HTTPDataLoader.swift" rel="noopener ugc nofollow" target="_blank">HTTPDataLoader</a></code>课上找到更多。</p><h1 id="32d3" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">执行请求</h1><p id="557d" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated"><code class="fe ms mt mu mv b">HTTPClient</code>充分利用async/await，从服务器返回原始响应。运行一个请求很简单:只需调用它的<code class="fe ms mt mu mv b">fetch()</code>函数。它接受一个可选的客户端参数；如果没有设置，则使用默认的singleton <code class="fe ms mt mu mv b">HTTPClient</code>实例(这意味着cookies、头文件和其他配置设置都与这个共享实例相关)。</p><p id="5596" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，请求被添加到目的地客户端，并且根据配置，将被异步执行。数据流的序列化和反序列化都在另一个<code class="fe ms mt mu mv b"><a class="ae ln" href="https://developer.apple.com/videos/play/wwdc2021/10194/" rel="noopener ugc nofollow" target="_blank">Task</a></code>(为了简单起见，另一个线程)中进行。这允许我们减少在<code class="fe ms mt mu mv b">HTTPClient</code>上完成的工作量。</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="8f9e" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">回应</h1><p id="1119" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">请求的响应类型为<code class="fe ms mt mu mv b"><a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Sources/RealHTTP/Client/HTTPResponse/HTTPResponse.swift" rel="noopener ugc nofollow" target="_blank">HTTPResponse</a></code>；这个对象封装了关于操作的所有东西，包括原始数据、状态代码、可选错误(从服务器接收或由响应验证器生成)以及对集成调试有效的度量数据。</p><p id="083c" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步是将原始响应转换成有效的对象(有/没有DAO)。<code class="fe ms mt mu mv b">decode()</code>函数允许您传递期望的输出对象类。通常，它是一个<code class="fe ms mt mu mv b">Codable</code>对象，但启用自定义对象解码也是必不可少的，因此您也可以使用任何符合<code class="fe ms mt mu mv b">HTTPDecodableResponse</code>协议的对象。这个协议只是定义了一个静态函数:<code class="fe ms mt mu mv b">static func decode(_ response: HTTPResponse) throws -&gt; Self?</code>。</p><p id="eeb6" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实现自定义的<code class="fe ms mt mu mv b">decode()</code>函数，你可以做任何你想做的事情来获得预期的输出。比如我是<a class="ae ln" href="https://github.com/SwiftyJSON/SwiftyJSON" rel="noopener ugc nofollow" target="_blank"> SwiftyJSON </a>的坚定粉丝。它最初可能看起来比“Codable”更冗长，但它也提供了更多的灵活性，更好的故障处理，以及更透明的转换过程。</p><p id="bf8c" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于大多数情况下，您可能只想以输出解码对象结束，<code class="fe ms mt mu mv b">fetch()</code>操作还提供了可选的解码参数，因此您可以在单次传递中进行fetch &amp;解码，而无需传递原始响应。</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="bab9" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个可选的<code class="fe ms mt mu mv b">fetch()</code>函数将获取和解码结合在一个函数中；当您不需要获得响应的内部细节，而只需要获得解码的对象时，您可能会发现这很有帮助。</p><h1 id="2edd" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">验证/修改响应</h1><p id="5aac" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">使用定制客户机而不是共享客户机是为了定制与端点通信背后的逻辑。例如，我们将与两个具有不同逻辑的不同端点进行通信(哦，天哪，遗留环境……)。这意味着结果和错误被不同地处理。</p><p id="5173" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，旧的遗留系统远远不是一个类似REST的系统，它把错误放在请求的主体中；新的一个使用闪亮的HTTP状态代码。</p><p id="88ea" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了处理这些和更复杂的情况，我们引入了响应验证器的概念，它与<a class="ae ln" href="https://express-validator.github.io/docs/" rel="noopener ugc nofollow" target="_blank"> Express的验证器</a>非常相似。基本上，验证器由一个协议和一个提供请求及其原始响应的函数定义，允许您决定下一步。</p><p id="01ca" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以拒绝响应并抛出错误、接受响应或修改响应、立即重试或在执行替代请求后重试(这是需要在对原始请求进行进一步尝试之前刷新的过期JWT令牌的示例)。</p><p id="b406" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">验证器在响应发送到应用程序级别之前按顺序执行。您可以为客户端分配多个验证器，并且所有这些验证器都可以与最终输出一致。这是标准<code class="fe ms mt mu mv b"><a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Sources/RealHTTP/Client/Internal/HTTPResponseValidator/HTTPValidator.swift" rel="noopener ugc nofollow" target="_blank">HTTPResponseValidator</a></code>的简化版本:</p><p id="9ce0" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://gist.github.com/malcommac/decbd7a0c57218dae2c5b9af6b4af246" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/mal commac/decbd 7a 0 c 57218 DAE 2c 5b 9 af6 B4 af246</a></p><p id="e0ee" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以用不同的行为来扩展/配置它。此外，<code class="fe ms mt mu mv b"><a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Sources/RealHTTP/Client/Internal/HTTPResponseValidator/HTTPAltRequestValidator.swift" rel="noopener ugc nofollow" target="_blank">HTTPAltResponseValidator</a></code>是实现重试/呼叫后逻辑的正确验证器。验证器可以返回由<code class="fe ms mt mu mv b"><a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Sources/RealHTTP/Client/Internal/HTTPResponseValidator/HTTPValidator.swift#L38" rel="noopener ugc nofollow" target="_blank">HTTPResponseValidatorResult</a></code>定义的以下操作之一:</p><ul class=""><li id="2f79" class="mw mx jb kt b ku kv kx ky la my le mz li na lm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">nextValidator</code>:只需将手柄传递给下一个验证器</li><li id="a316" class="mw mx jb kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">failChain</code>:停止链并返回该请求的错误</li><li id="64be" class="mw mx jb kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">retry</code>:用策略重试起源请求</li></ul><h1 id="0324" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">重试策略</h1><p id="a51a" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">Alamofire的优势之一是适应和重试请求的基础设施。用回调来重新实现它并不容易，但是用异步/等待来实现就容易多了。我们想实现两种重试策略:一种是简单的延迟重试，另一种是更复杂的执行原始请求后的备用调用重试。</p><p id="8d7d" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重试策略在由名为<code class="fe ms mt mu mv b"><a class="ae ln" href="https://github.com/immobiliare/RealHTTP/tree/main/Sources/RealHTTP/Client/Internal/HTTPDataLoader" rel="noopener ugc nofollow" target="_blank">HTTPDataLoader</a></code>的自定义内部对象管理的<code class="fe ms mt mu mv b">URLSessionDelegate</code>中处理。</p><p id="dd5e" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一个过于简化的逻辑版本，你可以在这里<a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Sources/RealHTTP/Client/Internal/HTTPDataLoader/HTTPDataLoader.swift#L66" rel="noopener ugc nofollow" target="_blank">找到</a>(以及注释):</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="08c0" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lu">如果您正在考虑使用自动重试来解决连接问题，请考虑改用</em><a class="ae ln" href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration/2908812-waitsforconnectivity" rel="noopener ugc nofollow" target="_blank"><em class="lu">waitsForConnectivity</em></a><em class="lu">。如果请求确实因为网络问题而失败，通常最好向用户传达一个错误。使用</em><a class="ae ln" href="https://developer.apple.com/documentation/network/nwpathmonitor" rel="noopener ugc nofollow" target="_blank"><em class="lu">NWPathMonitor</em></a><em class="lu">您仍然可以监控到您的服务器的连接并自动重试。</em></p><h1 id="441e" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">排除故障</h1><p id="823d" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">调试很重要；与后端团队交换网络呼叫的标准方式是cURL。它不需要介绍。<code class="fe ms mt mu mv b">HTTPRequest</code>和<code class="fe ms mt mu mv b">HTTPResponse</code>都有一个<a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Sources/RealHTTP/Client/Internal/Other%20Structures/cURLHelper.swift" rel="noopener ugc nofollow" target="_blank">扩展</a>，为底层<code class="fe ms mt mu mv b">URLRequest</code>生成一个卷曲命令。</p><p id="0469" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理想情况下，您应该在请求/响应时调用<code class="fe ms mt mu mv b">cURLDescription</code>，您将自动获得所有信息，包括父节点的<code class="fe ms mt mu mv b">HTTPClient</code>设置。</p><h1 id="b2b1" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">其他功能</h1><p id="957e" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">这篇文章会很长。我们没有讨论像<a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Documentation/5.Security_Options.md#security-options" rel="noopener ugc nofollow" target="_blank"> SSL锁定</a>、<a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Documentation/4.Handle_LargeData_Requests.md#handle-large-data-request" rel="noopener ugc nofollow" target="_blank">大文件下载/恢复</a>、<a class="ae ln" href="https://github.com/immobiliare/RealHTTP/blob/main/Documentation/7.Stubber.md#http-stubber" rel="noopener ugc nofollow" target="_blank">请求模仿</a>和HTTP缓存这样的主题。所有这些特性目前都已经在GitHub项目中实现，所以如果你感兴趣的话，可以直接查看源代码。顺便说一下，我重用了您在上面看到的相同方法。</p><h1 id="062e" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">组装API</h1><p id="f359" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在，我们已经创建了一个现代化的轻量级网络基础设施。</p><p id="c9f4" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lu">但是我们的API实现呢？</em></p><p id="eb19" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于较小的应用程序，直接使用<code class="fe ms mt mu mv b">HTTPClient</code>而不创建API定义是可以接受的。但是通常在某个地方定义可用的API是一个好主意，这样可以减少代码中的混乱，并避免由于重复而可能出现的错误。</p><p id="b737" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lu">就我个人而言，我不喜欢</em> <a class="ae ln" href="https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md" rel="noopener ugc nofollow" target="_blank"> <em class="lu">的Moya方式</em> </a>，<em class="lu">的方式，在那里你将API建模为一个enum，每个属性都有一个单独的开关。我认为这通常令人困惑，因为您将配置请求的所有属性分散和混合在一个文件中。最终，它很难阅读和修改，当你添加一个新的端点时，你应该在这一大块代码中上下移动。</em></p><p id="c8b4" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的方法是让一个对象能够配置一个有效的<code class="fe ms mt mu mv b">HTTPRequest</code>准备好传递给一个<code class="fe ms mt mu mv b">HTTPClient</code>。对于这个例子，我们将使用<a class="ae ln" href="https://developers.themoviedb.org/3/search/search-movies" rel="noopener ugc nofollow" target="_blank">movie db API</a>🍿(您应该注册一个免费帐户以获得有效的API密钥)。</p><p id="7b75" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们使用我们构建的网络层作为一个实际的例子。为了简单起见，我们将考虑两个API:一个用于获取即将上映/热门/顶级电影，另一个用于搜索。</p><p id="9820" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们想通过enum使用namespacing来创建一个容器，在这里我们将为一个特定的上下文放置所有的资源，在我们的例子中是<code class="fe ms mt mu mv b">Rankings</code>和<code class="fe ms mt mu mv b">Movies</code>。</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7f88" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">资源描述远程服务提供的特定服务；它接受几个输入参数，并使用它们来生成一个准备执行的有效的<code class="fe ms mt mu mv b">HTTPRequest</code>。<code class="fe ms mt mu mv b">APIResourceConvertible</code>协议描述了这一过程:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="8aad" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">Search</code>是一个在MovieDB中搜索电影的资源。它可以用一个必需的参数(<code class="fe ms mt mu mv b">query</code>字符串)和另外两个可选参数(释放)<code class="fe ms mt mu mv b">year</code>和<code class="fe ms mt mu mv b">includeAdults</code>过滤器初始化。</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="20b4" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">request()</code>函数根据MovieDB API文档生成一个有效的请求。我们可以为每部电影重复这一步，创建一个<code class="fe ms mt mu mv b">Lists</code>资源，以获得<code class="fe ms mt mu mv b">upcoming</code>、<code class="fe ms mt mu mv b">popular</code>和<code class="fe ms mt mu mv b">topRated</code>电影的排名列表。我们将把它放入名称空间<code class="fe ms mt mu mv b">Rankings</code>:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="374d" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">MoviesPage</code>表示一个<code class="fe ms mt mu mv b">Codable</code>对象，它反映了MovieDB每次调用的结果:使用这种方法，我们有三个好处:</p><ul class=""><li id="264a" class="mw mx jb kt b ku kv kx ky la my le mz li na lm nb nc nd ne bi translated">API调用根据它们的上下文组织在名称空间中</li><li id="cb3c" class="mw mx jb kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated">每个资源都描述了一种创建远程请求的类型安全方法</li><li id="94f4" class="mw mx jb kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated">每个资源都包含生成有效HTTP请求的所有逻辑</li></ul><p id="4935" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一件事:我们应该被允许使用一个<code class="fe ms mt mu mv b">HTTPClient</code>来执行一个<code class="fe ms mt mu mv b">APIResourceConvertible</code>调用，并返回一个类型安全的对象，如前所述。这非常简单，如下图所示:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2fec" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们将创建我们的<code class="fe ms mt mu mv b">HTTPClient</code>:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="de7b" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以执行我们的调用:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="657e" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在这里找到这个<a class="ae ln" href="https://gist.github.com/malcommac/cfb475d7bd10c07ccda5401d652b53e4" rel="noopener ugc nofollow" target="_blank">例子的完整源代码。</a></p><h2 id="9910" class="nk lw jb bd lx nl nm dn mb nn no dp mf la np nq mh le nr ns mj li nt nu ml nv bi translated">结论</h2><p id="f125" class="pw-post-body-paragraph kr ks jb kt b ku mn kc kw kx mo kf kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在，我们有了一个基于async/await的易于使用的现代网络层，我们可以对其进行定制。我们完全控制了它的功能，并且完全了解它的机制。</p><p id="ca29" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的网络库是在MIT许可下发布的，它叫做<a class="ae ln" href="https://github.com/immobiliare/RealHTTP" rel="noopener ugc nofollow" target="_blank">real http</a>；我们在维护和发展它。如果你喜欢这篇文章，请考虑为这个项目添加一个明星或者为它的发展做出贡献。</p><div class="ip iq gp gr ir nw"><a href="https://github.com/immobiliare/RealHTTP" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd jc gy z fp ob fr fs oc fu fw ja bi translated">GitHub - immobiliare/RealHTTP:🌀为Swift构建的带有异步/等待的Web API客户端和存根</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">RealHTTP是一个轻量级但功能强大的基于async/await的客户端HTTP库，由Swift开发。这个的目标是…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ix nw"/></div></div></a></div><pre class="lo lp lq lr gt ol mv om on aw oo bi"><span id="e16c" class="nk lw jb mv b gy op oq l or os"><strong class="mv jc">Want to Connect?</strong></span><span id="206d" class="nk lw jb mv b gy ot oq l or os">Check out <a class="ae ln" href="https://www.offnotes.org" rel="noopener ugc nofollow" target="_blank">my offnotes newsletter</a> here.</span></pre></div></div>    
</body>
</html>