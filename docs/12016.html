<html>
<head>
<title>How To Share a Postgres Socket Between Docker Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Docker容器之间共享Postgres套接字</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-share-a-postgres-socket-between-docker-containers-ad126e430de7?source=collection_archive---------3-----------------------#2022-05-05">https://betterprogramming.pub/how-to-share-a-postgres-socket-between-docker-containers-ad126e430de7?source=collection_archive---------3-----------------------#2022-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c203" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">非本地容器上的本地PG会话</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cfdadfd23353b42928823fc0db962ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2hIVUWlsVrjIQoaTG6Aig.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@campaign_creators?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">活动创作者</a>在<a class="ae ky" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建Docker容器是一项非常简单的任务。你抓取一个图像，运行几个命令，几分钟内你就有了一个完整的环境。当事情需要变得更复杂时会发生什么？</p><p id="6cdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">坚持呢？开放港口？共享资源？</p><p id="a769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在构建一个复杂的数据库设置，其中有许多服务连接到Postgres容器，如果不小心的话，很快就会变得一团糟。管理Postgres配置和臭名昭著的<code class="fe lv lw lx ly b">pg_hba</code>文件是一件苦差事，但有一种更简单的方法可以绕过它。</p><p id="37ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一点小魔法，数据库就有可能看起来像和你的其他服务在同一个容器中。</p><p id="aecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，大多数PG配置允许一些本地用户连接到数据库。你不需要打开任何端口，允许任何主机，或摆弄访问列表。在本文中，我们将探索如何在同一父主机上的容器之间建立和共享这种本地连接。这在设置复杂的数据库部署或构建功能丰富的开发环境时节省了时间。</p><h1 id="906d" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">先决条件</h1><p id="6d85" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">本指南假设您已经在将要使用的父主机上安装了Docker和Docker Compose。如果您还不知道，请查看下面的链接:</p><ul class=""><li id="0d12" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><a class="ae ky" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">获取Docker </a></li><li id="c893" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><a class="ae ky" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">获取Docker撰写</a></li></ul><p id="b81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要为持久性卷分配一些存储空间。一开始您不需要太多，但是如果您打算将数据库数据保存在主机上，您将希望选择一个适合您的估计使用的路径和大小。</p><p id="bb59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦Docker准备好在主机上运行，我们就可以开始构建我们的Compose文件了。</p><h1 id="eeac" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">Docker撰写文件</h1><p id="1468" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在这个例子中，我们将使用一个<code class="fe lv lw lx ly b">docker-compose.yml</code>文件。这将允许我们从一个文件中一次旋转出许多不同的容器。在这个文件中，我们将有两个服务。第一个是Postgres，第二个是我们需要本地数据库访问的测试应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/6cc74a7b00bc43be252d9b5c836dbe07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inbHqfqcSdBVR0YLTsoe5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/tateg/53ee3072efd1799a3e215a9ebf47e09a" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a></p></figure><p id="be7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析一下这个文件中发生了什么:</p><ul class=""><li id="7dc0" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">我们有两个服务(容器)，第一个是我们的Postgres数据库，第二个是我们的“应用”。第二个只是另一个Postgres数据库，它将使用<code class="fe lv lw lx ly b">psql</code>连接到第一个数据库。</li><li id="8aa4" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">我们通过与两个容器共享卷，将Unix套接字从第一个Postgres传递到第二个Postgres。该插座通常位于<code class="fe lv lw lx ly b">/var/run/postgresql</code>处。</li><li id="a85a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">在我们的第二个“app”服务中，我们使用了一个旧的Postgres映像，并修改了入口点，使其使用<code class="fe lv lw lx ly b">psql</code>连接到数据库，并运行<code class="fe lv lw lx ly b">SELECT</code>语句来显示版本信息。</li><li id="1320" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">Postgres版本在“app”服务中是不同的，以说明它如何明确地连接到第一个Postgres实例，而不是在同一容器中的本地。在实际的生产应用程序中，你只需使用一个数据库适配器或某种类型的<a class="ae ky" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank"> ORM </a>库，并将其指向套接字。</li><li id="52fc" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">我们还将第二个“app”服务的用户改为使用<code class="fe lv lw lx ly b">postgres</code>而不是<code class="fe lv lw lx ly b">root</code>，这样我们就不必更改数据库中套接字或角色的任何权限。生产应用程序应该使用具有适当权限的适当范围的用户。</li></ul><h1 id="7dd1" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">把所有的放在一起</h1><p id="dda0" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在是时候运行我们的Docker合成文件并查看结果了。只需在与<code class="fe lv lw lx ly b">docker-compose.yml</code>文件相同的目录下发出以下命令来运行整个合成:</p><pre class="kj kk kl km gt nm ly nn no aw np bi"><span id="0470" class="nq mb it ly b gy nr ns l nt nu">docker-compose up --build</span></pre><p id="7a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建完成后，您应该会看到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/9d47d5113145f46b2306e16a34983d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKnpTSvYVPRJjasopjPbzg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker合成输出。</p></figure><p id="fc1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到我们的数据库启动了，我们的应用程序连接了，并且成功执行了<code class="fe lv lw lx ly b">SELECT</code>。注意应用程序的输出如何显示Postgres版本<code class="fe lv lw lx ly b">14</code>，而不是安装在应用程序容器中的版本<code class="fe lv lw lx ly b">12</code>。这意味着我们已经连接到从主机安装到容器中的插座。</p><p id="1085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在启动任何容器时遇到问题，您可以使用以下命令重新构建它们:</p><pre class="kj kk kl km gt nm ly nn no aw np bi"><span id="8bcf" class="nq mb it ly b gy nr ns l nt nu">docker-compose up --build --force-recreate</span></pre><h1 id="bb4d" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">最后的想法</h1><p id="7ba5" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">虽然这只是一个测试应用程序，它实际上并没有做任何有用的事情，但是您可以很容易地使用相同的方法来连接您自己的应用程序或服务。</p><p id="11f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法允许您避免处理遗留应用程序的情况，遗留应用程序很难容器化，因为它与本地数据库紧密相关。虽然大多数现代的数据库支持的应用程序应该支持连接到远程数据库，但是有些情况下您可能希望使用套接字进行连接。</p><p id="087c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是出于安全性考虑还是仅仅因为缺乏灵活性，在容器之间共享套接字都是一个快速而简单的选择。</p><p id="3a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！如果你喜欢这篇文章，请看看我下面的其他几篇文章:</p><ul class=""><li id="f907" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-a-useful-linux-login-banner-on-aws-with-ansible-4c000aba1258"> <em class="lz">用Ansible </em> </a>在AWS上搭建一个有用的Linux登录Banner</li><li id="fd95" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/lightweight-efficient-database-alternatives-for-python-bb990eee752"><em class="lz">Python的轻量级高效数据库替代品</em> </a></li></ul></div></div>    
</body>
</html>