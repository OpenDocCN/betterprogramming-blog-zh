<html>
<head>
<title>Django Database Optimization Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django数据库优化技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/django-database-optimization-tips-4e11631dbc2c?source=collection_archive---------0-----------------------#2019-06-07">https://betterprogramming.pub/django-database-optimization-tips-4e11631dbc2c?source=collection_archive---------0-----------------------#2019-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="97f6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Django ORM优化备忘单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7c8c7b2a5e1260413be3b1f0c25efb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NfgBteJ0tzuzx3WSSqW3Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="263e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将浏览一些关键的优化技巧，而不是讨论每一点。请阅读Django官方文档了解全部细节。</p><p id="e38c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整篇文章中，我们将使用以下模型:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7439" class="ma mb it lw b gy mc md l me mf">class Author(models.Model):<br/>    name = models.CharField(max_length=200)<br/>    email = models.EmailField()<br/><br/>    def __str__(self):<br/>        return self.name<br/> <br/>class Blog(models.Model):<br/>    name = models.CharField(max_length=100)<br/>    tagline = models.TextField()<br/><br/>    def __str__(self):<br/>        return self.name<br/><br/>class Entry(models.Model):<br/>    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)<br/>    headline = models.CharField(max_length=255)<br/>    body_text = models.TextField(blank=True)<br/>    likes = models.IntegerField(blank=True, default=0)<br/>    authors = models.ManyToManyField(Author, blank=True)<br/>    <br/>    class Meta:<br/>        default_related_name = 'entries'<br/><br/>    def __str__(self):<br/>        return self.headline</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f403" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">了解查询集计算和缓存</h1><p id="7b0f" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">Django开发人员必须了解QuerySet评估和缓存，以优化数据库命中。我已经写了一篇关于它的详细文章<a class="ae ky" href="https://medium.com/@goutomroy/understanding-django-database-querysets-and-its-optimizations-1765cb9c36e5?postPublishedType=repub" rel="noopener">这里</a>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="68eb" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">明智地使用get()</h1><p id="e96c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当您知道只有一个对象匹配您的查询时，请使用get。如果没有条目与查询匹配，<code class="fe nj nk nl lw b">get()</code>将引发一个<code class="fe nj nk nl lw b">DoesNotExist</code>异常。如果多个条目匹配查询，<code class="fe nj nk nl lw b">get()</code>将引发一个<code class="fe nj nk nl lw b">MultipleObjectsReturned</code>异常。像这样使用<code class="fe nj nk nl lw b">get()</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f6df" class="ma mb it lw b gy mc md l me mf">try:<br/>    one_entry = Entry.objects.get(blog=2000)<br/>except Entry.DoesNotExist:<br/>    # query did not match to any item.<br/>    pass<br/>except Entry.MultipleObjectsReturned:<br/>    # query matched multiple items.<br/>    pass<br/>else:<br/>    # query matched to just one item<br/>    print(one_entry)</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9ccc" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用可用的调试工具</h1><p id="b6a8" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">使用<a class="ae ky" href="https://github.com/jazzband/django-debug-toolbar" rel="noopener ugc nofollow" target="_blank"> django-debug-toolbar </a>和<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/#explain" rel="noopener ugc nofollow" target="_blank"> QuerySet.explain() </a>来确定代码的效率。了解<code class="fe nj nk nl lw b">django.db.connection</code>，它记录了用<a class="ae ky" href="https://docs.djangoproject.com/en/2.2/faq/models/#faq-see-raw-sql-queries" rel="noopener ugc nofollow" target="_blank">当前连接</a>进行的查询。我已经编写了一个查询调试器<a class="ae ky" href="https://gist.github.com/goutomroy/d61fc8a8445954c71b5585af042e5cf4" rel="noopener ugc nofollow" target="_blank"> decorator </a>来获取函数中的查询数——您可以用它来检查查询的效率。还有一个很好的包<code class="fe nj nk nl lw b"><a class="ae ky" href="https://github.com/jazzband/django-silk" rel="noopener ugc nofollow" target="_blank">django-silk</a></code>也很好用。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="38cc" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">尽可能使用迭代器</h1><p id="16ec" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">QuerySet通常在计算发生时缓存其结果，并且对于使用该QuerySet的任何进一步操作，它首先检查缓存的结果。但是当你使用<code class="fe nj nk nl lw b">iterator()</code>时，它不检查任何缓存，而是直接从数据库中读取结果。它不会将结果保存到QuerySet。</p><p id="7037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个QuerySet，它返回大量具有大量内存的对象，您只需要访问一次，您可以使用<code class="fe nj nk nl lw b">iterator()</code>。</p><p id="67e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，所有条目都将从数据库中取出并加载到内存中，然后遍历每一个条目。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="969e" class="ma mb it lw b gy mc md l me mf">q = Entry.objects.all()<br/>for each in q:<br/>    do_something(each)</span></pre><p id="4589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<code class="fe nj nk nl lw b">iterator()</code>时，Django将保持SQL连接打开，读取每一行，并在读取下一行之前调用<code class="fe nj nk nl lw b">do_something()</code>。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1900" class="ma mb it lw b gy mc md l me mf">q = Entry.objects.all().iterator()<br/>for each in q:<br/>    do_something(each)</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4665" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用持久性数据库连接</h1><p id="9eca" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">每次请求到来时，Django都会打开一个新的数据库连接，并在请求完成时关闭它。<code class="fe nj nk nl lw b"><a class="ae ky" href="https://docs.djangoproject.com/en/2.2/ref/settings/#std:setting-CONN_MAX_AGE" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">CONN_MAX_AGE</strong></a></code> <strong class="lb iu"> </strong>负责此行为——默认值为0。但是应该设置为多少秒呢？这取决于你网站的流量——流量越大，保持连接所需的时间就越长。我建议设置一个相对较小的值，如<code class="fe nj nk nl lw b">60</code>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="67b5" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用<code class="fe nj nk nl lw b">select_related()</code>和<code class="fe nj nk nl lw b">prefetch_related()</code></h1><p id="2560" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在Django中,<code class="fe nj nk nl lw b">select_related</code>和<code class="fe nj nk nl lw b">prefetch_related</code>都是为了阻止由于访问相关对象而导致的大量数据库查询。我已经写了一篇详细的文章<a class="ae ky" href="https://medium.com/@goutomroy/django-select-related-and-prefetch-related-f23043fd635d" rel="noopener">在这里</a>关于它。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="455b" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用F表达式</h1><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4093" class="ma mb it lw b gy mc md l me mf"># Don't<br/>for entry in Entry.objects.all():<br/>    entry.likes += 1<br/>    entry.save()<br/>    <br/># Do<br/>Entry.objects.update(likes=F('likes') + 1)</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="fc46" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用聚合</h1><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b87b" class="ma mb it lw b gy mc md l me mf"># Don't<br/>most_liked = 0<br/>for entry in Entry.objects.all():<br/>    if entry.likes &gt; most_liked:<br/>        most_liked = entry.likes<br/># Do<br/>most_liked = Entry.objects.all().aggregate(Max('likes'))['likes__max']</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4891" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">直接使用外键值</h1><p id="f98f" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">Django ORM自动检索和缓存外键，所以使用它们而不是点击不必要的数据库查询。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b1cb" class="ma mb it lw b gy mc md l me mf"># Don't. Needs database hit<br/>blog_id = Entry.objects.get(id=200).blog.id<br/><br/># Do. The foreign key is already cached, so no database hit<br/>blog_id = Entry.objects.get(id=200).blog_id<br/><br/># Do. No database hit<br/>blog_id = Entry.objects.select_related('blog').get(id=200).blog.id</span></pre><h1 id="affc" class="mn mb it bd mo mp nm mr ms mt nn mv mw jz no ka my kc np kd na kf nq kg nc nd bi translated">不在乎就不要点结果</h1><p id="9d2e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">排序不是免费的-要排序的每个字段都是数据库必须执行的操作。如果一个模型有一个默认的排序(<code class="fe nj nk nl lw b"><a class="ae ky" href="https://docs.djangoproject.com/en/2.2/ref/models/options/#django.db.models.Options.ordering" rel="noopener ugc nofollow" target="_blank">Meta.ordering</a></code>)并且你不需要它，通过调用没有参数的<code class="fe nj nk nl lw b"><a class="ae ky" href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/#django.db.models.query.QuerySet.order_by" rel="noopener ugc nofollow" target="_blank">order_by()</a></code>在<code class="fe nj nk nl lw b">QuerySet</code>上移除它。向数据库添加索引可能有助于提高排序性能。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="b233" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用<code class="fe nj nk nl lw b">count()</code>和<code class="fe nj nk nl lw b">exists()</code></h1><p id="2b41" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果不需要QuerySet的内容，使用count()和exists()。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="51ce" class="ma mb it lw b gy mc md l me mf"># Don't<br/>count = len(Entry.objects.all())  # Evaluates the entire queryset<br/><br/># Do<br/>count = Entry.objects.count()  # Executes more efficient SQL to determine count<br/><br/># Don't<br/>qs = Entry.objects.all()<br/>if qs:<br/>   pass<br/>  <br/># Do<br/>qs = Entry.objects.exists()<br/>if qs:<br/>   pass</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9adb" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用批量添加(*objs)到<code class="fe nj nk nl lw b">ManyToManyField</code>字段</h1><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5329" class="ma mb it lw b gy mc md l me mf">author1 = Author(name='author1')<br/>author2 = Author(name='author2')<br/>author3 = Author(name='author3')<br/>entry = Entry.objects.get(id=1)<br/><br/># Don't<br/>entry.authors.add(author1)<br/>entry.authors.add(author2)<br/>entry.authors.add(author3)<br/><br/># Do<br/>entry.authors.add(author1, author2, author3)</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="1128" class="ma mb it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">对批量操作使用Delete()和Update()</h2><p id="9a34" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果您想一次删除或更新一组模型实例，请分别使用delete()和update()。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fc41" class="ma mb it lw b gy mc md l me mf"># Don't.Delete one by one.<br/>for entry in Entry.objects.all():<br/>    entry.delete()<br/>    <br/># Do.Delete all at once.<br/>Entry.objects.all().delete()<br/><br/># Don't<br/>for entry in Entry.objects.all():<br/>    entry.likes += 1<br/>    entry.save()<br/>    <br/># Do<br/>Entry.objects.update(likes=F('likes')+1)</span></pre><h2 id="40a9" class="ma mb it bd mo nr ns dn ms nt nu dp mw li nv nw my lm nx ny na lq nz oa nc ob bi translated">使用bulk_create()</h2><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7fe0" class="ma mb it lw b gy mc md l me mf"># Don't<br/>for i in range(20):<br/>    Blog.objects.create(name="blog"+str(i), headline='tagline'+str(i))<br/><br/># Do<br/>blogs = []<br/>for i in range(20):<br/>    blogs.append(Blog(name="blog"+str(i), headline='tagline'+str(i)))<br/>Blog.objects.bulk_create(blogs)</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="c61e" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用values()，values_list()，<code class="fe nj nk nl lw b">defer(), only()</code></h1><p id="5958" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当您需要<code class="fe nj nk nl lw b">QuerySet</code>结果中的某些字段，并且想要列表、元组或字典中的结果时，使用<code class="fe nj nk nl lw b"><a class="ae ky" href="https://docs.djangoproject.com/en/2.1/ref/models/querysets/#values" rel="noopener ugc nofollow" target="_blank">values()</a></code>和<code class="fe nj nk nl lw b"><a class="ae ky" href="https://docs.djangoproject.com/en/2.1/ref/models/querysets/#values-list" rel="noopener ugc nofollow" target="_blank">values_list()</a></code>。</p><p id="3183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要<code class="fe nj nk nl lw b">QuerySet</code>结果中的某些字段，并且想要QuerySet中的模型字段而不是列表、元组或字典时，请使用<code class="fe nj nk nl lw b"><a class="ae ky" href="https://docs.djangoproject.com/en/2.1/ref/models/querysets/#defer" rel="noopener ugc nofollow" target="_blank">defer()</a></code>和<code class="fe nj nk nl lw b"><a class="ae ky" href="https://docs.djangoproject.com/en/2.1/ref/models/querysets/#only" rel="noopener ugc nofollow" target="_blank">only()</a></code>。</p></div></div>    
</body>
</html>