<html>
<head>
<title>What’s New in Java 14?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 14有什么新特性？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-java-14-a472ec291c05?source=collection_archive---------4-----------------------#2020-02-09">https://betterprogramming.pub/whats-new-in-java-14-a472ec291c05?source=collection_archive---------4-----------------------#2020-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b5bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">16个主要增强功能、2400个错误修复等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6195b8f44046fc764d0eefc511e6f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KR10fCJjIz5JDzQj9CqAog.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@fossy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Fab Lentz </a>在<a class="ae ky" href="https://unsplash.com/s/photos/idea?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java 14准备在2020年3月17日发布。除了约2400个错误修复和小的增强，新版Java包含16个主要增强，也称为jep(Java增强建议)。</p><p id="9fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看Java 14中的主要更新:新的开关表达式、更好的<code class="fe lv lw lx ly b">NullPointerException</code> s、垃圾收集的改进、JFR事件流等等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/4ad902786c4a1039b00769d54ecccc1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/0*ABhRToGeo9b4Y5CE.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="f11e" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">切换表达式</h1><p id="2faf" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Java语言的这一更新在Java 12和13中已经可用，但只是作为预览语言特性，这意味着它在默认情况下是不可用的。最后，Java 14发布了新的开关表达式。长话短说，Java 14引入了一种新的简化形式的带有<code class="fe lv lw lx ly b">case L -&gt; ...</code>标签的开关块。在某些情况下，新的开关表达式可能有助于简化代码。这里有几个例子。</p><p id="6163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个描述工作日的枚举。我们可以使用新的开关表达式编写以下代码:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="225a" class="ni mi it ly b gy nj nk l nl nm">switch (day) {<br/>    case MONDAY              -&gt; System.out.println("Aweful");<br/>    case TUESDAY, WEDNESDAY  -&gt; System.out.println("Okay");<br/>    case THURSDAY            -&gt; System.out.println("Good");<br/>    case FRIDAY              -&gt; System.out.println("Great");<br/>    case SATURDAY, SUNDAY    -&gt; System.out.println("Awesome");<br/>}</span></pre><p id="8d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们只对每个<code class="fe lv lw lx ly b">case</code>使用了一个单一的表达。注意，<code class="fe lv lw lx ly b">switch</code>块没有使用任何<code class="fe lv lw lx ly b">break</code>语句，这使得它更短。下一个示例显示了新的开关表达式如何返回值:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="0ae6" class="ni mi it ly b gy nj nk l nl nm">int numLetters = switch (day) {<br/>    case MONDAY, FRIDAY, SUNDAY -&gt; 6;<br/>    case TUESDAY                -&gt; 7;<br/>    case THURSDAY, SATURDAY     -&gt; 8;<br/>    case WEDNESDAY              -&gt; 9;<br/>};</span></pre><p id="fa83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以编写多行代码块，用新的关键字<code class="fe lv lw lx ly b">yield</code>返回值:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f692" class="ni mi it ly b gy nj nk l nl nm">int result = switch (s) {<br/>    case "Foo" -&gt; 1;<br/>    case "Bar" -&gt; 2;<br/>    default    -&gt; {<br/>        System.out.println("Neither Foo nor Bar, hmmm...");<br/>        yield 0;<br/>    }<br/>};</span></pre><p id="a0c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用新的开关表达式时，有几件重要的事情需要记住。例如，新开关表达式的情况必须是详尽的。这意味着，对于所有可能的值，必须有一个匹配的开关标签。或者，由于<code class="fe lv lw lx ly b">yield</code>现在是一个关键字，名为<code class="fe lv lw lx ly b">yield</code>的类现在在Java 14中是非法的。</p><p id="8839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多新的开关表达，欢迎阅读<a class="ae ky" href="https://openjdk.java.net/jeps/361" rel="noopener ugc nofollow" target="_blank"> JEP 361 </a>。作者提供了大量关于新开关表达式的有用信息。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c97f" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">有用的NullPointerExceptions</h1><p id="0366" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当代码试图取消引用一个空引用时，JVM抛出一个<code class="fe lv lw lx ly b">NullPointerException</code> (NPE)。所有Java开发人员以前都见过它们。例如，以下代码可能会导致NPE:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="855b" class="ni mi it ly b gy nj nk l nl nm">foo.bar = 10;</span></pre><p id="61a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NPE将如下所示:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="40c9" class="ni mi it ly b gy nj nk l nl nm">Exception in thread "main" java.lang.NullPointerException<br/>    at App.main(App.java:17)</span></pre><p id="746c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异常消息包含一个文件名和一行发生空解引用的地方。对于<code class="fe lv lw lx ly b">foo.bar = 10;</code>语句，不难发现NPE是因为<code class="fe lv lw lx ly b">foo</code>变量为空而被抛出的。不幸的是，有时并不清楚到底是什么导致了NPE。例如，如果<code class="fe lv lw lx ly b">a</code>、<code class="fe lv lw lx ly b">b</code>或<code class="fe lv lw lx ly b">c</code>为空，那么将抛出一个NPE:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="eb7f" class="ni mi it ly b gy nj nk l nl nm">a.b.c.d = 42;</span></pre><p id="e052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，无论哪个字段为空，NPE看起来都是一样的。它没有给出任何实际上哪个字段为空的线索。</p><p id="3ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个例子。如果嵌套数组之一为空，则会导致NPE:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="a472" class="ni mi it ly b gy nj nk l nl nm">a[i][j][k] = 99;</span></pre><p id="3080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，无论哪个数组为空，NPE看起来都是一样的。</p><p id="8acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java 14解决了这个问题，使NPEs更加友好。现在JVM可以判断出哪个变量为空，然后在异常消息中让用户知道。例如，行<code class="fe lv lw lx ly b">foo.bar = 10;</code>中的空解引用将导致以下NPE:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="771a" class="ni mi it ly b gy nj nk l nl nm">Exception in thread "main" java.lang.NullPointerException: <br/>        Cannot assign field "bar" because "foo" is null<br/>    at App.main(App.java:17)</span></pre><p id="1382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">a.b</code>为空，行<code class="fe lv lw lx ly b">a.b.c.d = 41;</code>中的空解引用将导致以下NPE:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="29ec" class="ni mi it ly b gy nj nk l nl nm">Exception in thread "main" java.lang.NullPointerException: <br/>        Cannot read field "c" because "a.b" is null<br/>    at App.main(App.java:17)</span></pre><p id="3d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">NullPointerException</code> s中的新信息可能非常有助于分析其根本原因，并且可以使开发人员的生活稍微轻松一些。顺便说一下，自2006年以来，SAP的JVM中就有了这种改进。可惜用了14年才最终带入OpenJDK。</p><p id="d104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对细节感兴趣，<a class="ae ky" href="https://openjdk.java.net/jeps/358" rel="noopener ugc nofollow" target="_blank"> JEP 358 </a>的作者提供了很多关于这个新特性的信息。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="255a" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">包装工具(培养箱)</h1><p id="846c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">目前，Java应用程序通常作为简单的JAR文件分发。然而，这不是很方便，尤其是对于应用程序的用户来说。如果Java应用程序是像Windows上的MSI或Mac上的DMG那样的可安装包，那就好得多了。这将允许以用户熟悉的方式分发、安装和卸载Java应用程序。</p><p id="9458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://openjdk.java.net/jeps/343" rel="noopener ugc nofollow" target="_blank"> JEP 343 </a>推出了<code class="fe lv lw lx ly b">jpackage</code>工具，该工具将Java应用打包成一个特定于平台的包，其中包含所有必要的依赖项。以下是支持的包格式列表:</p><ul class=""><li id="69c2" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">Linux上的DEB和RPM</li><li id="61d0" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">苹果电脑上的PKG和DMG</li><li id="3dda" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">Windows上的MSI和EXE</li></ul><p id="0171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何使用新工具的示例:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="aa30" class="ni mi it ly b gy nj nk l nl nm">$ jpackage --name myapp --input lib --main-jar main.jar \<br/>  --main-class myapp.Main</span></pre><p id="eb7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它获取<code class="fe lv lw lx ly b">lib/main.jar</code>文件，并以最适合于运行它的系统的格式生成一个包。入口点是<code class="fe lv lw lx ly b">myapp.Main</code>类。</p><p id="b1a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JEP的作者提供了相当多关于新工具的有用<a class="ae ky" href="https://openjdk.java.net/jeps/343" rel="noopener ugc nofollow" target="_blank">信息。</a></p><p id="b0da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe lv lw lx ly b">jpackage</code>工具在JDK 14中可用，但它是作为孵化器模块提供的，这意味着该功能不能保证是稳定的，可能会在未来的版本中进行修订。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="982f" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">更好的垃圾收集</h1><p id="9507" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Java 14在垃圾收集方面包含了多项增强。</p><p id="d5b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JEP 345通过实现NUMA感知的内存分配来改进G1垃圾收集器。顺便说一下，NUMA代表非统一内存访问。这个特性已经在并行垃圾收集器中实现了很长时间。现在，通过使用新的<code class="fe lv lw lx ly b">+XX:+UseNUMA</code>命令行选项运行Java，也可以在G1启用它。这应该会提高大型计算机上的G1性能。</p><p id="d05d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://openjdk.java.net/jeps/363" rel="noopener ugc nofollow" target="_blank"> JEP 363 </a>移除了几年前就被弃用的并发标记清除(CMS)垃圾收集器。再见CMS！</p><p id="6730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://openjdk.java.net/jeps/364" rel="noopener ugc nofollow" target="_blank"> JEP 364 </a>和<a class="ae ky" href="https://openjdk.java.net/jeps/365" rel="noopener ugc nofollow" target="_blank"> JEP 365 </a>使Z垃圾收集器(ZGC)在macOS和Windows上可用。ZGC是几年前添加到JVM中的并发垃圾收集器。ZGC试图减少垃圾收集的暂停时间，可以处理从几百兆字节到几兆字节大小的堆。以前，收集器只能在Linux上运行。<br/> <br/> <a class="ae ky" href="https://openjdk.java.net/jeps/366" rel="noopener ugc nofollow" target="_blank"> JEP 366 </a>不赞成并行清除和串行旧垃圾收集算法的结合。这种组合必须由用户使用<code class="fe lv lw lx ly b">-XX:+UseParallelGC -XX:-UseParallelOldGC</code>命令行选项来启用。作者认为这种组合并不常见，但需要大量的维护工作。事实上，选项<code class="fe lv lw lx ly b">-XX:UseParallelOldGC</code>现在已经被否决了。如果使用不赞成使用的模式，将会显示警告。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e0ea" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">JFR事件流</h1><p id="d6e0" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">JDK飞行记录器(JFR)是一个事件记录器，内置于JVM中。它捕获关于JVM本身以及在JVM中运行的应用程序的诊断和分析数据。JFR曾经是一个专有工具，但它在2018年作为OpenJDK 11的一部分发布的Java中是开源的。</p><p id="56fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用JFR提供的数据，用户必须开始记录，停止记录，将内容转储到磁盘，然后解析记录文件。这对于应用程序概要分析来说非常有效，但是对于监控来说就不太好了。</p><p id="e859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java 14中，JFR允许用户异步订阅事件。用户现在可以注册一个处理程序，它将被调用以响应事件的到来。<code class="fe lv lw lx ly b">RecordingStream</code>类提供了过滤和消费事件的统一方法。JEP的作者提供了一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多信息可在<a class="ae ky" href="https://openjdk.java.net/jeps/349" rel="noopener ugc nofollow" target="_blank"> JEP 349 </a>找到。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="fae6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">语言预览功能</h1><p id="5df4" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Java 14包含对Java语言的几个更新，缺省情况下这些更新还不可用。</p><p id="e9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，<a class="ae ky" href="https://openjdk.java.net/jeps/305" rel="noopener ugc nofollow" target="_blank"> JEP 305 </a>用一个绑定变量扩展了<code class="fe lv lw lx ly b">instanceof</code>操作符。这里有一个例子:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e27d" class="ni mi it ly b gy nj nk l nl nm">if (obj instanceof String s) {<br/>    // can use s here<br/>}</span></pre><p id="aa1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">obj</code>是<code class="fe lv lw lx ly b">String</code>的一个实例，那么它就被转换成<code class="fe lv lw lx ly b">String</code>，并赋给绑定变量<code class="fe lv lw lx ly b">s</code>。</p><p id="7e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，<a class="ae ky" href="https://openjdk.java.net/jeps/359" rel="noopener ugc nofollow" target="_blank"> JEP 359 </a>将记录引入Java语言。记录有名称和状态描述。状态描述声明了记录的组成部分。记录也可以有主体。这里有一个简短的例子:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e7b8" class="ni mi it ly b gy nj nk l nl nm">record Point(int x, int y) {}</span></pre><p id="1d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三，在收集了对Java 13的反馈后，<a class="ae ky" href="https://openjdk.java.net/jeps/368" rel="noopener ugc nofollow" target="_blank"> JEP 368 </a>为文本块添加了几个新的转义序列，这些序列是之前作为语言预览特性在Java 13中引入的。</p><p id="d958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，这三个更新仍然只能作为默认情况下不启用的预览语言功能使用。要启用新语法，您必须使用<code class="fe lv lw lx ly b">--enable-preview --release 14</code>选项运行Java编译器，然后使用<code class="fe lv lw lx ly b">--enable-preview</code>选项启动<code class="fe lv lw lx ly b">java</code>:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="24ad" class="ni mi it ly b gy nj nk l nl nm">$ javac -d classes --enable-preview --release 14 Test.java<br/>$ java -classpath classes --enable-preview Test</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9827" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">其余的</h1><p id="1ad8" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Java 14还有什么变化？</p><p id="5d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JEP 370 引入了一个API，允许Java应用安全有效地访问Java堆之外的外部内存。听起来很吓人。新的API应该成为<code class="fe lv lw lx ly b">java.nio.ByteBuffer</code>和<code class="fe lv lw lx ly b">sun.misc.Unsafe</code>类的替代品。该功能作为孵化模块提供。</p><p id="f6fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://openjdk.java.net/jeps/352" rel="noopener ugc nofollow" target="_blank"> JEP 352 </a>增加了新的文件映射模式，这样<code class="fe lv lw lx ly b">FileChannel</code> API可以用来创建引用非易失性存储器(NVM)的<code class="fe lv lw lx ly b">MappedByteBuffer</code>实例。</p><p id="45c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java 11中不赞成使用Pack200工具。现在<a class="ae ky" href="https://openjdk.java.net/jeps/367" rel="noopener ugc nofollow" target="_blank"> JEP 367 </a>移除了工具及其API。</p><p id="45e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你了解Solaris和SPARC，<a class="ae ky" href="https://openjdk.java.net/jeps/362" rel="noopener ugc nofollow" target="_blank"> JEP 362 </a>放弃了对Solaris/SPARC、Solaris/x64和Linux/SPARC平台的支持。将来，这些平台上的端口很可能会从OpenJDK中移除。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="cb34" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="4e0b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">与Java 13中的五个jep相比，新的Java 14提供了更多重要的增强。这些更新涉及各个领域。最有可能的是，Java开发人员最感兴趣的更新将是新的开关表达式和增强的<code class="fe lv lw lx ly b">NullPointerException</code>。不要忘记尝试新的语言预览功能，并向JDK开发人员提供您的反馈。享受全新的Java 14！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1b6d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">环</h1><ul class=""><li id="e6ba" class="nn no it lb b lc mz lf na li od lm oe lq of lu ns nt nu nv bi translated"><a class="ae ky" href="https://openjdk.java.net/projects/jdk/14/" rel="noopener ugc nofollow" target="_blank"> OpenJDK 14时间表和增强功能列表</a></li></ul></div></div>    
</body>
</html>