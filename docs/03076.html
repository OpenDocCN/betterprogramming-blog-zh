<html>
<head>
<title>Pull to Refresh in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中拉动以刷新</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pull-to-refresh-in-swiftui-6604f54a01d5?source=collection_archive---------4-----------------------#2020-01-19">https://betterprogramming.pub/pull-to-refresh-in-swiftui-6604f54a01d5?source=collection_archive---------4-----------------------#2020-01-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="92bb" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">利用UIViewRepresentable和UIHostingController在SwiftUI视图中嵌入刷新控件</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c896724b02055434f2f93bfdb1526a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Khrnc7VxYOCr_zrs"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@luferlex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢肯·萨贝拉诺</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5ccd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们几乎处于年度WWDC会议的中间阶段(在撰写本文时，2019年和2020年各有六个月的时间)，尽管SwiftUI的引入在iOS社区中创造了欢乐，但我们仍然不能放弃UIKit框架。</p><p id="b24e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI目前缺少许多功能，这使得UIKit现在不可或缺。</p><p id="e934" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在SwiftUI API还没有包含的功能中，这么多，<em class="lw">活动指示器</em>和<em class="lw">拉刷新</em>是最被错过的两个功能。</p><p id="db75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">几乎每个应用程序都需要向下滑动来刷新视图，还需要一个活动指示器来显示内容加载时的进度。</p><p id="a2d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">令人高兴的是，我们支持在SwiftUI中嵌入UIViews的<code class="fe lx ly lz ma b">UIViewRepresentable</code>协议和将SwiftUI视图添加到<code class="fe lx ly lz ma b">UIViewController</code>的<code class="fe lx ly lz ma b">UIHostingController</code>类。</p><p id="8319" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">借助UIKit和SwiftUI之间顺畅的互操作性，我们可以对一些缺失的SwiftUI实现提出自己的定制实现，这就是本文背后的想法。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="2937" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">我们的目标</h1><ul class=""><li id="74d4" class="na nb iu lc b ld nc lg nd lj ne ln nf lr ng lv nh ni nj nk bi translated">在我们的iOS应用程序中的SwiftUI列表上添加一个拉至刷新视图。</li><li id="076b" class="na nb iu lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">我们将使用<code class="fe lx ly lz ma b">UIHostingController</code>和<code class="fe lx ly lz ma b">UIViewRepresentable</code>来允许在带有<code class="fe lx ly lz ma b">UIRefreshControl</code>的<code class="fe lx ly lz ma b">UIScrollView</code>(ui kit的)中嵌入SwiftUI子视图。</li><li id="b2c2" class="na nb iu lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">利用<code class="fe lx ly lz ma b">GeometryReader</code>获得视图的维度。</li></ul></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="0735" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">最终目的地</h1><p id="13e2" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">下图展示了在这篇文章结束时我们将实现的目标:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nt"><img src="../Images/bc2a1938f1d5272dbf07541bca54964a.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/1*YTi9F4cuXxtPUdmvdM0n8Q.gif"/></div></figure></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="7d1f" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">设置我们的数据模型</h1><p id="f601" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">首先，让我们创建一个保存唯一ID和文本的结构。该结构需要符合<code class="fe lx ly lz ma b">Identifiable</code>协议，以允许SwiftUI列表独立于其他元素识别每个行元素。</p><pre class="kk kl km kn gu nu ma nv nw aw nx bi"><span id="6f61" class="ny mj iu ma b gz nz oa l ob oc">struct Model: Identifiable {</span><span id="a1d7" class="ny mj iu ma b gz od oa l ob oc">var id = UUID()<br/>var title: String</span><span id="c294" class="ny mj iu ma b gz od oa l ob oc">}</span></pre><p id="619a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，让我们创建一个符合<code class="fe lx ly lz ma b">ObservableProtocol</code>的类，它将允许我们宣布模型中的更改，以便它自动更新SwiftUI视图的主体。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oe of l"/></div></figure><p id="32e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每次对列表执行拉至刷新操作时，都会触发<code class="fe lx ly lz ma b">shuffleList</code>。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="08a2" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">创建SwiftUI子视图</h1><p id="4a7b" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">让我们创建一个包含列表的子SwiftUI视图。这个视图最终将嵌入到一个带有拉至刷新控件的<code class="fe lx ly lz ma b">ScrollView</code>中。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oe of l"/></div></figure><p id="92f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每当来自<code class="fe lx ly lz ma b">DataModel</code>的<code class="fe lx ly lz ma b">Published</code>属性改变时，<code class="fe lx ly lz ma b">ObservedObject</code>属性包装器更新元素列表。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="840b" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">SwiftUI和UIKit互操作性</h1><p id="762c" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">SwiftUI的<code class="fe lx ly lz ma b">List</code>和<code class="fe lx ly lz ma b">ScrollView</code>目前都不具备添加<code class="fe lx ly lz ma b">RefreshControl</code>视图的能力。</p><p id="1ae8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，让我们回到UIKit的经典<code class="fe lx ly lz ma b">UIScrollView</code>上来。我们将把它包装在一个符合<code class="fe lx ly lz ma b">UIViewRepresentable</code>协议的结构中。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oe of l"/></div></figure><p id="a4f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，我们做了相当多的事情。让我们把它们记下来。</p><ul class=""><li id="37eb" class="na nb iu lc b ld le lg lh lj og ln oh lr oi lv nh ni nj nk bi translated">将<code class="fe lx ly lz ma b">UIRefreshControl</code>与<code class="fe lx ly lz ma b">UIScrollView</code>相加，并监听值的变化，以了解拉至刷新控制的状态。</li><li id="bcc2" class="na nb iu lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">Coordinator类充当我们在<code class="fe lx ly lz ma b">makeUIView</code>函数中创建的UIKit视图的代表。它响应刷新控件上的用户事件，并在刷新完成后向<code class="fe lx ly lz ma b">DataModel</code>追加一个新元素。</li><li id="913b" class="na nb iu lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated"><code class="fe lx ly lz ma b">SwiftUIList</code>是我们创建的自定义SwiftUI视图，它将<code class="fe lx ly lz ma b">DataModel</code>保存在一个列表中。使用<code class="fe lx ly lz ma b">UIHostingController</code>，我们嵌入<code class="fe lx ly lz ma b">SwiftUIList</code>作为<code class="fe lx ly lz ma b">UIScrollView</code>的子<code class="fe lx ly lz ma b">UIView</code>。</li></ul><p id="9094" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你看到的粗体的宽度和高度属性是设置孩子<code class="fe lx ly lz ma b">UIView</code>的尺寸所必需的。我们将使用<code class="fe lx ly lz ma b">GeometryReader</code>来获取这些，如下图所示。</p></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="4693" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">构建内容视图，使用GeometryReader</h1><p id="f01b" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">最后，我们将在<code class="fe lx ly lz ma b">ContentView</code>的<code class="fe lx ly lz ma b">body</code>中添加<code class="fe lx ly lz ma b">CustomScrollView</code> SwiftUI视图，并使用<code class="fe lx ly lz ma b">GeometryReader</code>传递宽度和高度，这是一个容器视图，它将其内容定义为自身大小的函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oe of l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oj"><img src="../Images/f37ef8f9317ffa965c0d26839a642307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rzB9rZ7FwFcVdAoE0J73w.png"/></div></div></figure></div><div class="ab cl mb mc hy md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="in io ip iq ir"><h1 id="a9c3" class="mi mj iu bd mk ml mm mn mo mp mq mr ms ka mt kb mu kd mv ke mw kg mx kh my mz bi translated">结论</h1><p id="b260" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">总之，我们通过利用将SwiftUI转换为UIKit视图的<code class="fe lx ly lz ma b">UIHostingController</code>和将UIKit视图转换为SwiftUI的<code class="fe lx ly lz ma b">UIViewRepresentable</code>,创建了一个在SwiftUI视图中使用的快速拉刷新实现。</p><p id="7644" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每个人的WWDC 2020愿望清单上都有一个可以轻松用于生产应用的重大SwiftUI升级。</p><p id="a8a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/SwiftUIPullToRefresh" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到上述iOS应用的完整源代码。</p><p id="fb24" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>