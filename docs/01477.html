<html>
<head>
<title>Weak and Unowned keywords in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的弱关键字和无主关键字</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/weak-and-unowned-keywords-in-swift-7bda8bdd97c4?source=collection_archive---------5-----------------------#2019-09-16">https://betterprogramming.pub/weak-and-unowned-keywords-in-swift-7bda8bdd97c4?source=collection_archive---------5-----------------------#2019-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d0f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么在闭包中使用它们很重要—一个例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/11ac0c7f14376820e2ab64b0f7eceeea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcIjZwfAqnliUq6FR8tMyg.png"/></div></div></figure><p id="01ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你熟悉Swift，你应该听说过关键字<em class="lq">无主</em>和<em class="lq">弱</em>。如果你没有听说过他们，现在就去查查吧。我不会解释关于关键词的一切，但我会告诉你为什么你应该知道和使用它们。</p><p id="ce1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们在闭包中不使用无主或弱关键字，会发生什么？<br/>简而言之就是:内存泄露！最长的答案是:让我给你看…</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="89bd" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">让我们看看它是如何工作的！</h1><p id="adbc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了演示不使用无主或弱关键字如何会造成内存泄漏，我编写了一个简单的应用程序，让您输入web请求状态代码，然后在一个<code class="fe mv mw mx my b">tableview</code>中显示它们以及相应的猫图片。</p><p id="28de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我没有想到将状态代码和猫图片配对的惊人想法，但我确实发现了这个伟大的、易于使用的API，它:</p><div class="mz na gp gr nb nc"><a href="https://http.cat/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">HTTP猫</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">一个API为可怕的HTTP猫！在你的网站中使用它来显示有趣的错误信息。</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">http.cat</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><p id="39f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在示例应用程序中使用它似乎是一个有趣的API。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="060b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">应用程序设置</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/de79de928c187a3bca1b4f3afb9c4432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIcu_U55uhKDyFePVoDE9w.png"/></div></div></figure><p id="0068" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设置非常简单。打开应用程序时，首先会出现一个带有“开始”按钮的屏幕。按下按钮，出现主视图。在主视图中，您可以输入一个三位数的状态代码，然后按“查找”。所有输入的状态代码都显示在下面的<code class="fe mv mw mx my b">tableview</code>中。如果可以从<a class="ae ns" href="https://http.cat/404" rel="noopener ugc nofollow" target="_blank"> http.cat/【状态代码】</a>查询图像，则该图像会显示在相应状态代码的旁边。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c323" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">数据模型</h1><p id="8a16" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">数据模型相当简单。我们有一个班——<code class="fe mv mw mx my b">CatStatus</code>。有<code class="fe mv mw mx my b">value</code>(状态码值)<strong class="kw iu"> </strong> <code class="fe mv mw mx my b">imageData</code>的变量，还有一个名为<code class="fe mv mw mx my b">updated</code>的函数，当API请求完成并且<code class="fe mv mw mx my b">imageData</code>已经更新时调用。</p><pre class="kj kk kl km gt nt my nu nv aw nw bi"><span id="958d" class="nx lz it my b gy ny nz l oa ob">import Foundation<br/><br/>class CatStatus {<br/>    let value: String<br/>    var imageData: Data?<br/>    var updated: (()-&gt;())?<br/>    <br/>    init(value: String) {<br/>        self.value = value<br/>    }<br/>    <br/>    func makeRequest() {<br/>        DispatchQueue.global().async {<br/>            if let url = URL(string: "https://http.cat/\(self.value)") {<br/>                if let data = try? Data(contentsOf: url) {<br/>                    self.imageData = data<br/>                    <br/>                    if let updated = self.updated {<br/>                        updated()<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="e71d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<strong class="kw iu"> </strong> <code class="fe mv mw mx my b">makeRequest()</code>向http.cat API发出请求，向cat映像查询给定的状态代码。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f20b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">视图控制器</h1><p id="a055" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当用户点击“查找”按钮时，在视图控制器中执行以下功能:</p><pre class="kj kk kl km gt nt my nu nv aw nw bi"><span id="c1e6" class="nx lz it my b gy ny nz l oa ob">@IBAction func didSubmit() {<br/>        if let text = self.textField?.text {<br/>            if text.count == 3 {<br/>                self.textField?.textColor = .black // status code is valid<br/>                self.textField?.text = nil<br/>                <br/>                let newCat = CatStatus(value: text)<br/>                self.cats.append(newCat)<br/>                <br/>                let indexPath = IndexPath(row: cats.count - 1, section: 0)<br/>                tableView?.insertRows(at: [indexPath], with: .automatic)<br/>                <br/>                newCat.updated = { [unowned self] in<br/>                    DispatchQueue.main.async {<br/>                        self.tableView?.reloadRows(at: [indexPath], with: .automatic)<br/>                    }<br/>                }<br/>                newCat.makeRequest()<br/>            } else {<br/>                self.textField?.textColor = .red // status code has more or less than 3 digits<br/>            }<br/>            if text.count == 0 {<br/>                self.textField?.textColor = .black // status code is empty<br/>            }<br/>        }<br/>    }</span></pre><p id="86f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先检查文本是否不为nil，文本长度是否为3——这意味着我们可能有一个有效的状态代码，应该向<code class="fe mv mw mx my b">tableview</code>添加一个新行。我们创建一个新的<code class="fe mv mw mx my b">CatStatus</code>实例，并将其添加到我们的<code class="fe mv mw mx my b">cats</code>列表中。然后我们告诉<code class="fe mv mw mx my b">tableview</code>应该插入新的一行。</p><p id="f087" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在有趣的部分来了:我们想告诉新的<code class="fe mv mw mx my b">CatStatus</code>发出一个API请求。我们首先设置<code class="fe mv mw mx my b">updated</code>变量，这样当<code class="fe mv mw mx my b">imageData</code>更新时我们会得到通知。如果<code class="fe mv mw mx my b">imageData</code>已经更新，我们希望<code class="fe mv mw mx my b">tableview</code>重新加载相应的行。</p><p id="4983" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们开始请求。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0e2d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><code class="fe mv mw mx my b"><strong class="ak">Unowned and Weak Keywords</strong></code></h1><p id="08a4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这是有趣的部分。可以看到<code class="fe mv mw mx my b">[unowned self]</code> <strong class="kw iu"> </strong>目前被注释掉了。但是我们写<code class="fe mv mw mx my b">[unowned self]</code> <strong class="kw iu"> </strong>和不写有什么区别呢？让我们运行应用程序，你会看到。然后我会解释关键字的作用。</p><pre class="kj kk kl km gt nt my nu nv aw nw bi"><span id="37ca" class="nx lz it my b gy ny nz l oa ob">newCat.updated = { // [unowned self] in<br/>    DispatchQueue.main.async {<br/>        self.tableView?.reloadRows(at: [indexPath], with: .automatic)<br/>    }<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0c77" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">实验</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/72a0e8fe87c563d791f70cccf84114c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VS2HaLnajotIL9seskjj8A.png"/></div></div></figure><p id="4dcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我运行了两次应用程序。先用<code class="fe mv mw mx my b">[unowned self]</code> <strong class="kw iu"> </strong>注释掉再不用。代码中没有其他变化。您将看到内存使用的差异。</p><p id="3685" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应用程序运行由以下步骤组成:</p><ol class=""><li id="229e" class="od oe it kw b kx ky la lb ld of lh og ll oh lp oi oj ok ol bi translated">打开应用程序</li><li id="2b6e" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">点击“开始”</li><li id="cc7b" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">填写“100”作为状态代码，点击“查找”</li><li id="52cb" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">填写“200”作为状态代码，点击“查找”</li><li id="ca9c" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">填写“300”作为状态代码，点击“查找”</li><li id="44f5" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">填写“400”作为状态代码，点击“查找”</li><li id="f552" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">点击“返回”</li><li id="0bf5" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">重复步骤2。-7.再来三次</li></ol><h2 id="9986" class="nx lz it bd ma or os dn me ot ou dp mi ld ov ow mk lh ox oy mm ll oz pa mo pb bi translated">第一次排练</h2><p id="24a8" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">第一次运行时<code class="fe mv mw mx my b">[unowned self]</code> <strong class="kw iu"> </strong>被注释掉，导致内存使用情况如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/35b031469a99ac81207360753821dedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFRPgDwNhVjXXDGYWzsebA.png"/></div></div></figure><p id="300d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，内存使用量稳步增长。每次查询图像时，都会使用更多的内存。需要注意的是，并非所有图像都同时显示。当我们返回到第一个屏幕时，先前查询的数据会被忘记，但不会被释放。</p><h2 id="e0c3" class="nx lz it bd ma or os dn me ot ou dp mi ld ov ow mk lh ox oy mm ll oz pa mo pb bi translated">第二次排练</h2><p id="6869" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">未注释掉<code class="fe mv mw mx my b">[unowned self]</code>的第二次运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/5eadef09731511a6386cd4941175bd42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFKFBBCKO_NM7OHnfI4g2A.png"/></div></div></figure><p id="77f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，每次我们返回主屏幕时，分配给查询图像的内存都会被释放。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="09c0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">说明</h1><p id="1c62" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为什么第一次运行时没有释放内存？</p><pre class="kj kk kl km gt nt my nu nv aw nw bi"><span id="bc35" class="nx lz it my b gy ny nz l oa ob">newCat.updated = { // [unowned self] in<br/>    DispatchQueue.main.async {<br/>        self.tableView?.reloadRows(at: [indexPath], with: .automatic)<br/>    }<br/>}</span></pre><p id="9b18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Swifts magic具有自动内存管理功能:</p><ul class=""><li id="1151" class="od oe it kw b kx ky la lb ld of lh og ll oh lp pe oj ok ol bi translated">每当我们创建一个强引用，引用计数就增加一</li><li id="11e4" class="od oe it kw b kx om la on ld oo lh op ll oq lp pe oj ok ol bi translated">每当我们释放一个强引用，引用计数就减一</li></ul><p id="b064" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，swift就知道一个对象是否仍被另一个对象引用，是否应该保持活动状态。如果引用计数为零，则对象被释放。</p><p id="8c58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这样的闭包中发生的事情是，由于我们引用了<code class="fe mv mw mx my b">self</code>，我们创建了一个新的强引用，因此引用计数增加了1。现在当我们回到第一个观点时，应该发生的是:</p><ul class=""><li id="2b1d" class="od oe it kw b kx ky la lb ld of lh og ll oh lp pe oj ok ol bi translated">视图控制器实例被释放，因为我们不再引用它</li><li id="4b44" class="od oe it kw b kx om la on ld oo lh op ll oq lp pe oj ok ol bi translated">所有的<code class="fe mv mw mx my b">CatStatus</code>实例都被释放，因为我们不再引用它们</li><li id="90f4" class="od oe it kw b kx om la on ld oo lh op ll oq lp pe oj ok ol bi translated">所有的<code class="fe mv mw mx my b">imageData</code>变量都被释放，因为我们不再引用它们</li></ul><p id="501b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这不会发生，因为这个闭包仍然保存着对<code class="fe mv mw mx my b">ViewController</code>实例的引用(这里:<code class="fe mv mw mx my b">self</code>)。这意味着<code class="fe mv mw mx my b">ViewController</code>没有被释放。因此，仍然有对<code class="fe mv mw mx my b">CatStatus</code>实例的引用，因此也有对<code class="fe mv mw mx my b">imageData</code>变量的引用。</p><p id="c677" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果是我们无法访问大量使用中的内存。</p><p id="94fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决方案:在封口中使用<code class="fe mv mw mx my b">[unowned self]</code>或<code class="fe mv mw mx my b">[weak self]</code>。这样我们仍然可以引用自我，但是没有创建强引用。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="cf2c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">无主还是弱小？</h1><p id="ce84" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当我们不使用强引用时，调用闭包时self可能已经被释放了。</p><p id="2265" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们使用<code class="fe mv mw mx my b">unowned</code>并且<code class="fe mv mw mx my b">self</code>已经被释放时，应用程序崩溃。因此，如果你100%确定这种情况不会发生，只使用无主<strong class="kw iu"> </strong>是很重要的。</p><p id="b9cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们使用<code class="fe mv mw mx my b">wea<strong class="kw iu">k</strong></code>并且<code class="fe mv mw mx my b">self</code>已经被释放，那么self将为零。这意味着当使用<code class="fe mv mw mx my b">weak</code>时，<code class="fe mv mw mx my b">self</code>将是可选的。这使我们有可能在<code class="fe mv mw mx my b">self</code>被解除分配时处理该情况。</p><p id="9fc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在大多数情况下，使用<code class="fe mv mw mx my b">weak</code>是有意义的，因为它更安全。我在这个例子中使用了<code class="fe mv mw mx my b">unowned</code>,因为这意味着我需要修改更少的代码。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="bf8f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="f307" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">尽管swift使内存管理比Objective-C早期要容易得多，但深入研究它并理解引用计数是如何工作的仍然很重要。</p><p id="c610" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我使用了一个有限而简单的应用程序来展示内存泄漏是如何发生的，在这种情况下，没有被释放的图像数据会非常快地增加已用内存。在现实世界中，应用程序可能会运行很长时间，即使很小的泄漏也会在很长时间内造成问题。</p><p id="9eff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你还没有了解<code class="fe mv mw mx my b">unowned</code>和<code class="fe mv mw mx my b">weak</code>的话，就把这个当作学习的动力吧。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="1d5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在此处找到示例应用程序代码:</p><div class="mz na gp gr nb nc"><a href="https://github.com/kristiinara/MemoryleaksTestApp" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">kristiinara/memoryleaktestapp</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">创建这个TestApp是为了演示为什么我们应该在swift中使用无主和弱关键字</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="pf l nn no np nl nq ks nc"/></div></div></a></div><p id="9576" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有很棒的文章详细解释了<code class="fe mv mw mx my b">unowned</code>和<code class="fe mv mw mx my b">weak</code>，比如:</p><div class="mz na gp gr nb nc"><a href="https://blog.bobthedeveloper.io/swift-retention-cycle-in-closures-and-delegate-836c469ef128" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">关闭和委托中的快速保留周期</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">我们来理解一下【弱自我】、【无主自我】，弱var</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">blog.bobthedeveloper.io</p></div></div><div class="nl l"><div class="pg l nn no np nl nq ks nc"/></div></div></a></div></div></div>    
</body>
</html>