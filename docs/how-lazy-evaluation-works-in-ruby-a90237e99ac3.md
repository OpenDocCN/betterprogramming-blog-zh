# Ruby 中惰性求值的工作原理

> 原文：<https://betterprogramming.pub/how-lazy-evaluation-works-in-ruby-a90237e99ac3>

## 让我们变得懒惰——只迭代我们真正需要的东西！

![](img/7981ba16b50ea33a3a78c590dcbeda01.png)

照片由[德鲁·科夫曼](https://unsplash.com/@drewcoffman?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

在我们的日常工作中，作为开发人员，我们经常不得不处理大数据，有时是未知大小的数据。我们解析大文件并导入我们需要的东西，我们从各种网站收集一些数据来搜索某些东西，或者我们只是使用我们自己数据库中的一些大数据来转换它并对它做一些事情。

为了有效地做到这一点，我们有许多选择。像大多数语言一样，Ruby 为我们提供了很多处理这种情况的选项。当处理文件时，我们可以一行一行地读取它们，我们可以借助自己编写的方法和传递数据块，将数据分成更小的块。但是，我们还有另一个不常用的选项:惰性枚举。

# 什么是懒惰枚举？

惰性枚举意味着只有当我们处理结果时才处理表达式。有些语言在默认情况下是懒惰的，比如 [Haskell](https://en.wikipedia.org/wiki/Haskell_(programming_language)) ，还有许多其他语言正在实现一种懒惰地计算表达式的方法。

使用惰性枚举，可以创建一个只在需要时才处理的转换管道，如果需要，管道可以作为一个整体一次处理一个项目。一个小的代码示例将说明这一点:

当您运行这个代码片段时，您会注意到`map`和`take_while`块中的 put 被一个接一个地调用。这意味着在继续数组中的下一项之前，该项从一个块流到下一个块。相反，如果您删除了对`lazy`方法的调用，那么在进入管道的下一步之前，这些块会将所有的项打印到终端，因此这些步骤是针对数组中的所有项按顺序处理的。

让我们自己来看看这个:

```
Enumerator::Lazy
item: one
item: eno
item: two
item: owt
item: three
item: eerht
[["eno", "four"], ["owt", "five"], ["eerht", "six"]]
```

那么，当我们处理大量数据时，如何利用这一点呢？

# 懒惰 IO 读取

当我们打开一个文件并访问这些行时，我们实际上有了一个枚举器。通过调用 lazy 方法，我们现在可以以一种对内存更敏感的方式访问它们，就像这样:

对方法`each_line`的调用正在生成一个枚举器，现在我们可以将它转换成一个枚举器::Lazy。当您使用函数管道来获得您想要的行时，这尤其有用。这适用于所有具有 each_*操作的 IO 对象，因此当我们从套接字读取时，它以同样的方式工作。

但是，我们现在应该默认使用懒惰枚举吗？让我们来看看它们在较少迭代次数下的性能比较:

## 谎言、更多的谎言和基准

在许多默认为懒惰的语言中，懒惰的性能损失实际上是不存在的。但是，对于 Ruby 来说，这有点不同。下面是一个小基准，它懒洋洋地评估一个大数组中的所有项目:

以下是我电脑的测试结果:

```
Warming up --------------------------------------
             lazy:      6.000  i/100ms
            eager:     24.000  i/100ms
Calculating -------------------------------------
             lazy:      75.752  (± 4.0%) i/s -    156.000  in   2.063805s
            eager:     254.646  (± 6.7%) i/s -    528.000  in   2.083519s

Comparison:
            eager: :      254.6 i/s
             lazy: :       75.8 i/s - 3.36x  (± 0.00) slower
```

所以，懒惰的评估比急切的解决方案慢三倍以上。但是，如果我们只想做几个项目，会发生什么呢？让我们稍微调整一下基准，找出答案:

这变化很大！以下是输出:

```
Warming up --------------------------------------
             lazy:     23.021k i/100ms
            eager:     22.000  i/100ms
Calculating -------------------------------------
             lazy:     206.116k (±26.3%) i/s -    368.336k in   2.095998s
            eager:     229.351  (± 7.4%) i/s -    462.000  in   2.026127s

Comparison:
             lazy: :   206115.6 i/s

            eager: :      229.4 i/s - 898.69x  (± 0.00) slower
```

现在，懒惰的评价真的是值得的！lazy 版本比 eager 解决方案快几个数量级，因为当它找到它要寻找的所有项目时就停止迭代，而 eager 解决方案反转数组中的所有条目，然后取前五个元素。

# 基准裁决

这清楚地表明，当我们处理数据集中的许多甚至大部分项目时，惰性计算是相当慢的。但是，当我们处理数据的子集时，我们可以快得多！当然，这并不总是正确的。如果我们在数据集中搜索一个条目，并在最后一个条目中找到它，我们会慢一些。所以，我们必须注意什么时候使用它。

# 警告的话

此外，我们必须知道对于`Enumerator::Lazy`模块可用的方法。例如，方法`#reduce`和`#each_with_object`对 Enumerator::Lazy 不可用，因为我们不知道这个对象的最终结果是什么类型。如果我们想将这些方法包含到我们的管道中，我们必须在之后再次调用 lazy 方法。[这里的](https://ruby-doc.org/core-2.7.0/Enumerator/Lazy.html#method-i-take)是所有可用方法的文档链接。

# 结论

当处理大型数据集的子集时，Ruby 中的惰性求值是一个很好的特性。但是，如果它真的对您的用例有用，那么每次都必须单独进行评估。

*不是中等会员？* [*在这里报名*](https://grnt-grdwhl.medium.com/membership) *并支持我的写作过程！*