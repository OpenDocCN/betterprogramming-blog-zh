<html>
<head>
<title>Automate JIRA Cloud Workflow With Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Golang自动化JIRA云工作流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automate-jira-cloud-workflow-with-golang-2de29828aad6?source=collection_archive---------7-----------------------#2021-08-11">https://betterprogramming.pub/automate-jira-cloud-workflow-with-golang-2de29828aad6?source=collection_archive---------7-----------------------#2021-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="164d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过自动化日常工作来改善JIRA的内部流程，从而减少开发人员的工作量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3895f281f7175311d037ef27d5877ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXyQ2Z_oGuNTUqdsNPvSmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ky kz ep" href="https://medium.com/u/7fab1d3f6ce0?source=post_page-----2de29828aad6--------------------------------" rel="noopener" target="_blank">珀西·博尔默</a>拍摄</p></figure><p id="da20" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">JIRA是一个非常流行的跟踪问题和项目管理的框架。它允许项目领导或scrum masters建立项目并创建问题，然后分配给开发人员。对于使用敏捷开发和跟踪开发团队的工作过程来说，这是一个很好的框架。</p><p id="9b86" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">JIRA提供了大量的功能，但偶尔会出现通过后端服务控制JIRA的需求。这是一个经常被遗忘的话题，但是有时候帮助开发团队更快开发的服务是很棒的。这可以通过创建从后端管理JIRA的软件来实现。</p><p id="a38f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，我们将依靠云托管的JIRA。</p><h1 id="92a5" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">从Golang服务连接到JIRA云</h1><p id="06ce" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">要开始使用JIRA，我们首先需要验证并创建一个连接的客户端。我们需要从官方的<a class="ae lw" href="https://id.atlassian.com/manage-profile/security/api-tokens" rel="noopener ugc nofollow" target="_blank"> Atlassian API密钥管理控制台</a>获取一个新的API密钥。您可以访问该链接并创建您的API密钥。在顶部，您会看到一个创建令牌的蓝色按钮。输入一个名称，以便您可以轻松地与令牌相关联，并记住保存令牌。您不能再次查看它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/bb2525a8035989e8f66dccd124acab1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-pURzHiGl5yue4jFd_CkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA API令牌创建</p></figure><p id="f3da" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将使用名为<code class="fe mv mw mx my b"><a class="ae lw" href="https://github.com/andygrunwald/go-jira" rel="noopener ugc nofollow" target="_blank">go-jira</a></code>的Golang包。这个包将帮助我们轻松地使用JIRA API，但是请记住，您也可以将REST API与常规HTTP一起使用。但是既然已经有人为我们做了，为什么还要重新发明轮子呢？</p><p id="0cab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了进行连接，我们需要使用三个环境变量:</p><ul class=""><li id="abb3" class="mz na it lc b ld le lg lh lj nb ln nc lr nd lv ne nf ng nh bi translated"><code class="fe mv mw mx my b">JIRA_USER </code> =您的JIRA用户的用户名</li><li id="328e" class="mz na it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated"><code class="fe mv mw mx my b">JIRA_TOKEN</code> <strong class="lc iu"> </strong> =这是我们之前创建的令牌</li><li id="88da" class="mz na it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated"><code class="fe mv mw mx my b">JIRA_URL</code> <strong class="lc iu"> </strong> =您的JIRA云的基本URL</li></ul><p id="e5e6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我将环境变量存储在一个在运行时加载的<code class="fe mv mw mx my b">.env</code>文件中。这是我经常做的事情，所以对我来说控制多个项目的环境变量很容易。有一个超级光滑的Golang包叫<code class="fe mv mw mx my b"><a class="ae lw" href="https://github.com/joho/godotenv" rel="noopener ugc nofollow" target="_blank">godotenv</a></code>。</p><p id="3ab8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们下载这些包，然后使用以下命令创建一个新的<code class="fe mv mw mx my b">main.go</code>和一个<code class="fe mv mw mx my b">.env</code>文件:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="1e71" class="nr ly it my b gy ns nt l nu nv">mkdir jira-test<br/>cd jira-test<br/>go mod init jira-test<br/>go get github.com/andygrunwald/go-jira<br/>go get github.com/joho/godotenv<br/>touch main.go<br/>touch .env</span></pre><p id="8190" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">用您的凭证更新<code class="fe mv mw mx my b">.env</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">。env —测试程序中使用的环境变量</p></figure><p id="fec0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后打开main.go并确保连接正常。我们将首先创建一个<code class="fe mv mw mx my b">jira.BasicAuthTransport</code>结构，它包含。环境文件。</p><p id="cd37" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们使用的吉拉包拥有客户端的所有域，所以我们使用<code class="fe mv mw mx my b">client.User</code>等来获取用户信息。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA —连接到JIRA云并获取用户资料</p></figure><p id="44a6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尝试通过运行来执行程序，您应该会看到所提供的用户配置文件。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="ea48" class="nr ly it my b gy ns nt l nu nv">go run main.go</span></pre><h1 id="82af" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">列出所有项目和问题</h1><p id="14c1" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">简单地打印用户资料对我们没有帮助。我们可以做得更多！</p><p id="379f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们打印所有存在的项目。正如我之前提到的，JIRA客户端的所有域都是独立的，所以正如我们使用用户域来执行用户查询一样，我们将使用<code class="fe mv mw mx my b">Project</code>来执行针对项目的查询。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA —列出用户可以使用的所有项目</p></figure><p id="0a1f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们还可以使用代表吉拉查询语言的<a class="ae lw" href="https://www.atlassian.com/blog/jira-software/jql-the-most-flexible-way-to-search-jira-14" rel="noopener ugc nofollow" target="_blank"> JQL </a>搜索某些问题。这是一种简单的基于字符串的查询语言，允许我们缩小要收集的问题的范围。</p><p id="6be8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">通过使用具有搜索功能的客户端中的发布域来发送请求。我们从使用一个简单的搜索开始，我们将很快扩展它。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA-根据输入的JQL字符串搜索问题</p></figure><p id="6cec" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们更新<code class="fe mv mw mx my b">main.go</code>来尝试一下，你需要改变JQL来匹配你自己JIRA的一些项目。我们将编写一个JQL字符串，仅过滤出与某个项目相关的问题。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="7704" class="nr ly it my b gy ns nt l nu nv">project = 'PROJECTNAME'</span></pre><p id="78e2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您还可以添加更具体的过滤器，比如某个特定的状态或类型。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="cabf" class="nr ly it my b gy ns nt l nu nv">project = 'PROJECTNAME' and Status = 'Done'<br/>project = 'PROJECTNAME' and Type = 'Feature'</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA —根据您的JQL字符串列出所有问题</p></figure><p id="7f3f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在更改了JQL之后，尝试运行它，看看是否得到了正确的输出。请注意，JIRA将收到的结果数量限制为1000个。因此，如果您有超过1000个问题，您可能需要应用搜索选项。如果您注意到了的话，<code class="fe mv mw mx my b">Search</code>函数接受两个参数:其中一个是搜索选项。您可以创建一个简单的for循环来排出所有问题。从<code class="fe mv mw mx my b">Search</code>返回的结果返回找到的问题总数，因此我们可以继续搜索，直到达到最大值。</p><p id="0e49" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mv mw mx my b">go-jira</code>库的例子提供了一个很好的例子，我们将重用这段代码。让我们用下面的代码更新<code class="fe mv mw mx my b">getIssues</code>以匹配示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA-获取所有问题，即使存在超过最大数量的结果</p></figure><p id="6c97" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个库提供了更多的特性，比如从sprint中抓取所有问题。请务必查看<a class="ae lw" href="https://pkg.go.dev/github.com/andygrunwald/go-jira#SprintService.GetIssuesForSprint" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="c8d4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您也可以使用<code class="fe mv mw mx my b">client.Issue.Create</code>创建新的问题。文档中又有一个极好的例子，我不会在这里制造任何问题。但是你可以看看下面的列表，这是安迪·格伦瓦德做的一个例子。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA——制造新问题</p></figure><h1 id="3002" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">过渡一个问题</h1><p id="6cf4" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">大多数时候。我发现状态之间的转换问题是最常见的用例。因此，让我们尝试将问题从一种状态转移到另一种状态。</p><p id="21e4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">JIRA在这里提供了关于什么是过渡以及它如何工作的很好的文档。</p><p id="ac7f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将创建一个函数<code class="fe mv mw mx my b">getIssueTransition</code>,它接受一个想要的状态，并返回适当的转换用于该状态。过渡很重要，因为我们确实需要识别过渡来解决问题。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA —获取转换，现在只返回一个空转换</p></figure><p id="f972" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我们已经完成了所需的过渡，我们可以简单地提出一个问题。更新过滤，以便通过更新JQL或对问题进行排序来获得您需要的问题。我会做一个硬编码版本来搜索某个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA —将问题从搁置转为进展</p></figure><p id="87e3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们应该先实现主应用的<code class="fe mv mw mx my b">transitionIssue</code>功能，然后才能触发它。这是一个围绕客户端的超级简单的包装函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIRA —将问题从一种状态转移到下一种状态</p></figure><p id="ad1f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">将问题密钥切换到想要的问题后执行程序，您应该会看到它被移动。</p><h1 id="85a4" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="75ac" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">现在，您已经掌握了如何从后端服务集成JIRA的基本知识。JIRA API提供了大量的功能，我们无法在这里一一介绍，但是您已经有了入门的基础。第三方库(go-吉拉)很棒，因为它也提供了使用未实现的API端点的能力。</p><p id="9d55" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我见过的一些自动化的想法都是进入某个状态的问题被来自Git存储库的信息填充，CI/CD故障被自动更新，等等。</p><p id="bf71" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你自动化什么真的取决于你的想象力。有能力修改/改变附件等等。</p><p id="341f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我希望你能和我一样顺利。你可以在<a class="ae lw" href="https://github.com/percybolmer/demo-jira-with-golang" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这篇文章的完整代码。</p><p id="03da" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一如既往，如果有任何问题，请随时联系我们。</p></div></div>    
</body>
</html>