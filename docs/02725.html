<html>
<head>
<title>How to Debug REST Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何调试REST请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-4-levels-of-rest-debugging-e35269e9da18?source=collection_archive---------4-----------------------#2019-12-20">https://betterprogramming.pub/the-4-levels-of-rest-debugging-e35269e9da18?source=collection_archive---------4-----------------------#2019-12-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="4471" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">通过以四种不同的方式监视正在交换的数据来找到那个烦人的bug</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/50a4a5a478b53d99b0f96ba76b59006a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWu6Dvge0h1BiKlm2KJA7w.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由<a class="ae kz" href="https://pixabay.com/users/mohamed_hassan-5229782/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4445206" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>来自<a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4445206" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="5cc6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不管您是在Angular、React、Vue、Backbone还是JavaScript前端，在某些时候您可能需要与后端服务进行通信。但是，当您的后端回复一个不需要的非2xx回复时，会发生什么呢？你传输了你的后端所期望的有效载荷了吗？您是否包含了所需的精确的HTTP头？可能在协议层面有问题吗？</p><p id="386e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将回顾一些有效调试REST调用的常用方法:JavaScript控制台、网络监视器、中间人服务器和网络流量分析。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7d5d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">REST请求的基本要素</h1><p id="d0d0" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果你想知道REST是如何以及何时被定义为一个概念的，维基百科有一个有趣的页面。</p><p id="3201" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">总之，REST，即表述性状态转移，是一种“软件架构风格，它定义了一组用于创建Web服务的约束。”早在2000年，Roy Fielding在他的博士论文“架构风格和基于网络的软件架构的设计”中首次定义了它。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/890f49753f7e022b7da1a3bfdeeb1dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rjo4QKJ-04Y2KY9mZ5LJ4g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">REST请求的基本元素(图片由作者提供)</p></figure><p id="6d75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了我们接下来将要讨论的调试方法和工具，让我们快速回顾一下组成rest请求的基本元素:</p><ul class=""><li id="8c36" class="nb nc iu lc b ld le lg lh lj nd ln ne lr nf lv ng nh ni nj bi translated"><strong class="lc iv">端点:</strong>这是REST调用的服务器端接收者所在的位置或地址。它被定义为一个URL，最完整的形式可能看起来像<code class="fe nk nl nm nn b">protocol://domain/path?queryParameters</code> <em class="no">。</em></li><li id="2543" class="nb nc iu lc b ld np lg nq lj nr ln ns lr nt lv ng nh ni nj bi translated"><strong class="lc iv">方法:</strong>http请求method⁴指示对给定资源要执行的操作。也称为HTTP动词，它是以下之一:GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE和PATCH。</li><li id="a292" class="nb nc iu lc b ld np lg nq lj nr ln ns lr nt lv ng nh ni nj bi translated"><strong class="lc iv">头:</strong> HTTP headers⁵由附加信息组成，这些信息伴随着从客户端传递到服务器的HTTP请求，反之亦然。您的请求可能有也可能没有相关联的标题。</li><li id="874b" class="nb nc iu lc b ld np lg nq lj nr ln ns lr nt lv ng nh ni nj bi translated"><strong class="lc iv">正文:</strong>HTTP消息正文是在HTTP事务消息中传输的任何附加数据，紧跟在消息头之后。主体是可选的，并不是所有的请求都需要主体。</li></ul><p id="6bd3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您首选的后端框架的控制器<em class="no"> </em>逻辑必须匹配一个传入的REST请求的所有元素，以便为其提供服务。</p><p id="ce79" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么什么会出错呢？如果您动态地创建您的端点，您的处理可能会导致URL的重要部分丢失。您的请求中使用的HTTP方法可能与后端预期的方法不匹配。或者一个重要的报头可能没有被注入或者可能被拼错。</p><p id="bcfe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的小节中，我们将研究当后端拒绝服务客户端REST调用时，增加调试客户端REST调用复杂性的四种不同方法。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="33ae" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">第1级:浏览器控制台</h1><p id="79ba" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果你仔细计划你的信息，你的因特网浏览器的控制台，虽然穷人调试的选择，可以是有帮助的。</p><p id="40ef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，即使您使用一个前端框架来热重新加载您的代码，通过添加输出语句来更改代码可能也不是最有效的调试方式。</p><p id="a2ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，您仍然可以利用浏览器的控制台来显示调试消息，以便让您立即了解正在执行的代码，以及作为REST调用的一部分而生成和交换的关键数据结构。</p><p id="fa41" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据经验，尽量减少使用浏览器控制台的日志。在你的前端代码中散布调试信息变成了一项技术债务，除非你有一个静态代码分析工具，比如<a class="ae kz" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank"> SonarQube </a>来为你指出它们，否则它们可能会被遗忘。</p><p id="f388" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，如果浏览器控制台是您唯一的选择，至少可以考虑使用日志框架。前端日志记录框架允许您根据级别和其他可能的附加属性将调试消息分组。</p><p id="5565" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据您需要进一步调试应用程序的哪一部分，您可以有选择地启用和禁用特定的组件级日志记录组，从而了解您需要的特定代码。当您准备好投入生产时，您可以通过轻击一个中心配置变量来禁用所有不必要的日志记录。</p><p id="843d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据您在前端使用的框架，有许多日志记录框架可供选择，因此这里没有必要重新发明轮子。这里有一个你可能想尝试的快速选择:</p><p id="fd29" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">JavaScript/NodeJS: <a class="ae kz" href="https://www.npmjs.com/package/ulog" rel="noopener ugc nofollow" target="_blank"> ulog </a>，<a class="ae kz" href="https://www.npmjs.com/package/winston" rel="noopener ugc nofollow" target="_blank">Winston</a><br/>Angular:<a class="ae kz" href="https://www.npmjs.com/package/ngx-logger" rel="noopener ugc nofollow" target="_blank">NGX Logger</a><br/>Vue:<a class="ae kz" href="https://www.npmjs.com/package/vuejs-logger" rel="noopener ugc nofollow" target="_blank">vuejs-Logger</a><br/>React:<a class="ae kz" href="https://github.com/webcerebrium/react-logger-lib" rel="noopener ugc nofollow" target="_blank">React-Logger-lib</a></p><p id="54e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，你可以像脸书和CNN一样，使用浏览器控制台发出一些奇特的或预防性的通知:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/5e7ef9aab7482079c87fc3b5a9441fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Py59Thk7shW5BgOjwqbtTA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">脸书浏览器控制台(图片来自作者)</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/5d915a896cff26b021cb6b861554f6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pU0O4X9KEp1mBN7nxB7bSg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">CNN.com浏览器控制台(图片来自作者)</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="309d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">第2级:浏览器网络监视器/调试器</h1><p id="63b9" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果浏览器控制台的调试功能不足以找出问题所在，并且您的REST调用不被后端接受，那么您的浏览器的网络监视器/调试器就该派上用场了。</p><p id="cbf8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">“网络调试器”选项卡是JavaScript或开发人员控制台中的一个选项卡，在所有浏览器中都可以找到。尽管它在不同的浏览器之间看起来略有不同，但它的基本功能是相同的。它允许您查看浏览器获取外部资源的每个网络请求。</p><p id="4c8f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了研究网络选项卡的一些有趣特性，我们将使用由<a class="ae kz" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>提供的在线<a class="ae kz" href="https://petstore.swagger.io/" rel="noopener ugc nofollow" target="_blank"> Petstore </a>示例应用程序:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nw"><img src="../Images/15316b0aec206b9ebd11d5b27a17a8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpaJHoXkF3q_si19yX1Amw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Petstore示例应用程序(图片由作者提供)</p></figure><p id="c6aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Swagger的直观设计允许我们选择一个API端点，并直接从浏览器中测试它。让我们使用Chrome为<code class="fe nk nl nm nn b">/pet/1</code>发出一个<code class="fe nk nl nm nn b">GET</code>请求:</p><ul class=""><li id="e3ce" class="nb nc iu lc b ld le lg lh lj nd ln ne lr nf lv ng nh ni nj bi translated">打开位于<a class="ae kz" href="https://petstore.swagger.io/" rel="noopener ugc nofollow" target="_blank">https://Petstore . swagger . io</a>的pet store应用程序</li><li id="c525" class="nb nc iu lc b ld np lg nq lj nr ln ns lr nt lv ng nh ni nj bi translated">点击<code class="fe nk nl nm nn b">/pet/{petId}</code>旁边的蓝色获取按钮</li><li id="e824" class="nb nc iu lc b ld np lg nq lj nr ln ns lr nt lv ng nh ni nj bi translated">点击“尝试一下”</li><li id="9805" class="nb nc iu lc b ld np lg nq lj nr ln ns lr nt lv ng nh ni nj bi translated">输入“1”作为宠物ID，然后点击蓝色的“执行”按钮</li></ul><p id="2aab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你的Chrome的网络标签现在应该看起来像这样:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nx"><img src="../Images/f24b71ebe8ba3d7edba09e90c24f737d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZo0TCwJ-gkalJUqIOeB8w.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Chrome的默认网络标签(图片由作者提供)</p></figure><p id="7339" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有几个按钮和配置选项。一些最有用的是清除按钮(1)、请求类型选择(2)和网络设置按钮(3)。</p><p id="47ff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用网络设置下的选项，您可以将网络输出转换为更紧凑的形式，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ny"><img src="../Images/15bdeceac772d4a3f6724399576f39f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t62UcJnICVs-sdZLuik8AQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Chrome网络标签的精简版(图片由作者提供)</p></figure><p id="9823" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过单击左侧的请求，您可以在右侧看到该请求的详细信息。有五个主要的细节部分，描述了交换的头、接收到的响应的预览(如果是受支持的格式之一，就很好地格式化)、接收到的原始响应、使用的HTTP cookies，以及关于请求定时的各种信息。</p><p id="bb9a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Network选项卡提供了大量的信息，本质上揭示了REST调用背后的大量信息。通过浏览捕获的请求，Network选项卡使您能够调查您的客户端到底发送了什么，以便有效地与您的后端所期望的进行交叉检查。</p><p id="8f2d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们进入第3级之前，让我们快速突出显示网络选项卡的一个有趣功能。</p><p id="63a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您需要快速重放REST调用时，不需要在UI中重复您的操作，只需右键单击请求并选择“Copy as <a class="ae kz" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank"> cURL </a>”</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nz"><img src="../Images/0d3e63cd152a59624eeb4ff3fd454c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*8MfkUZazGMhHL3EM4gaG5g.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将请求复制为cURL(图片由作者提供)</p></figure><p id="48a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，您可以打开您最喜欢的命令行界面(CLI ),粘贴请求以重放它:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ny"><img src="../Images/bf76d7f91bfa9a94ce6e3078c49141a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErwnHH8AhS5yxogLsIWI_Q.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">用cURL重放请求(图片由作者提供)</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0654" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">第三层:中间人代理</h1><p id="9759" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">当您想要调试浏览器生成的调用时，浏览器JavaScript控制台和网络选项卡非常方便。如果您有一个采用嵌入式REST客户端的后端应用程序，会怎么样？这就是man-in-the-middle⁶发挥作用的地方。</p><p id="9585" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在密码学和计算机科学中，中间人(MITM)是一个与<em class="no">攻击相关的术语。</em>它用于描述攻击者秘密中继并可能改变两方之间的通信的攻击，这两方认为他们正在直接相互通信。</p><p id="3e78" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">出于调试目的，我们将借用MITM的概念，但不执行攻击或改变请求的内容——只是记录它。通过位于REST客户机和REST服务器的中间，我们可以从两个方向观察流量，并向第三方提供洞察和日志记录。</p><p id="d78e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来看看效果如何。</p><h2 id="2e9d" class="oa me iu bd mf ob oc dn mj od oe dp mn lj of og mp ln oh oi mr lr oj ok mt ol bi translated">直接请求-答复</h2><p id="3a9b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">最简单的直接请求-回复序列只涉及客户端和REST服务器。您直接请求服务器地址和端口，然后收到一个回复:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj om"><img src="../Images/ae609a96c4c5bbd41aed51911dc55143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUO4jDO3hPA1omcNwv0ooQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">直接的请求-回复呼叫(图片由作者提供)</p></figure><p id="07b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">显然，这里没有中间人，所以让我们继续介绍一个。</p><h2 id="f4ac" class="oa me iu bd mf ob oc dn mj od oe dp mn lj of og mp ln oh oi mr lr oj ok mt ol bi translated">MITM请求-答复</h2><p id="431a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在MITM场景中，我们在架构中引入了一个额外的部分。这是一个位于REST客户端和REST端点之间的组件:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj on"><img src="../Images/14ad68198ef963b55cda865f1f2c2139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pym5ZE-3UrFVWJ9A_hq8A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">MITM代理的请求回复(图片由作者提供)</p></figure><p id="fbc7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">MITM代理侦听特定端口上的传入请求，然后将所有捕获的请求重新请求到目标服务器和端口。</p><p id="2cb1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦目标服务器提供了回复，MITM代理就会将回复转发回原来的REST客户端，同时在本地记录所有流量。</p><p id="fe60" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的客户端仍然不知道所有这些发生在幕后，您不需要修改任何代码，除非引入代理URL。根据应用程序的底层框架和架构，这可能是您需要传递的命令行选项或应用程序内配置选项。</p><h2 id="ce8a" class="oa me iu bd mf ob oc dn mj od oe dp mn lj of og mp ln oh oi mr lr oj ok mt ol bi translated">使用MITM代理</h2><p id="986a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">您可以使用一个名为<a class="ae kz" href="https://mitmproxy.org/" rel="noopener ugc nofollow" target="_blank"> mitmproxy </a>的优秀开源项目毫不费力地启动您的本地MITM代理。这个代理工具适用于所有主流操作系统，也可以在<a class="ae kz" href="https://hub.docker.com/r/mitmproxy/mitmproxy/" rel="noopener ugc nofollow" target="_blank"> Docker镜像</a>中使用。对于这一实际操作部分，我们将使用<code class="fe nk nl nm nn b">mitmproxy</code>、<em class="no"> </em>的Docker图像，我们还将公开其web界面，以便我们可以使用互联网浏览器查看收集的日志。</p><p id="3790" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要使用Docker启动<code class="fe nk nl nm nn b">mitmproxy</code>，您可以发出以下命令:</p><pre class="kk kl km kn gu oo nn op oq aw or bi"><span id="fe48" class="oa me iu nn b gz os ot l ou ov">docker run --rm -it \<br/> -p 8080:8080 \<br/> -p 8081:8081 \<br/> mitmproxy/mitmproxy mitmweb \<br/>  --web-iface 0.0.0.0</span></pre><p id="bde7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这将在端口8080上启动代理侦听，在端口8081上公开其web接口。我们现在可以使用cURL重试之前的REST请求，这次使用<code class="fe nk nl nm nn b">mitmproxy</code>作为我们的代理服务器:</p><pre class="kk kl km kn gu oo nn op oq aw or bi"><span id="69f8" class="oa me iu nn b gz os ot l ou ov">curl -k --proxy <a class="ae kz" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a> <a class="ae kz" href="http://petstore.swagger.io/v2/pet/1" rel="noopener ugc nofollow" target="_blank">http://petstore.swagger.io/v2/pet/1</a></span></pre><p id="d109" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们打开<code class="fe nk nl nm nn b">mitmproxy</code> <em class="no"> </em>的web界面，检查一下捕捉到了什么:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/1643d26b0e93dba4c10a34f97ba8af33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ml7QPAAdUlbP1XjN37uNXQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">mitmproxy的web界面(图片由作者提供)</p></figure><p id="e77f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在左边，我们看到捕获的原始请求，在右边，我们看到为这个请求交换的数据。</p><p id="7f11" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个界面似乎类似于我们在上面第1级中检查的浏览器的网络选项卡；然而，<code class="fe nk nl nm nn b">mitmproxy</code>提供了更多的选项来拦截请求、保存HTTP对话、重放客户端和服务器端响应、过滤和操作内容等。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="71f0" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">第4级:网络流量分析</h1><p id="f664" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">恭喜你，你已经升到第4级了。在前面的所有级别中，调试是通过检查我们和数据之间的另一个应用层已经解释的信息来进行的。在这一层，我们向下移动到网络表示层，这样我们就可以直接在数据包层调试信息。</p><p id="b9a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，这不是需要调试REST调用的典型级别。通常，问题出在你的更高层。但是，这一级别的调试允许您发现协议级的更深层次的问题，如连接性问题、安全性问题、数据包丢失、延迟等。早期的调试级别不能帮助你。</p><p id="f155" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以让我们捕捉一些网络数据。</p><p id="d6db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">网络流量分析需要一种方法来捕获网络接口传输的数据包。该类别中最著名的免费工具是<a class="ae kz" href="https://www.wireshark.org/" rel="noopener ugc nofollow" target="_blank">Wireshark</a>(Ethereal的一个分支)。Wireshark是世界上最重要、使用最广泛的网络协议分析器，它让您从微观层面了解网络上发生的事情。</p><p id="4ff6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Wireshark是如此令人印象深刻的综合网络流量分析工具，以至于需要几篇独立的文章来解释它。因此，我将只尝试触及表面，并快速向您展示如何捕获和可视化您的HTTP流量。</p><h2 id="adc5" class="oa me iu bd mf ob oc dn mj od oe dp mn lj of og mp ln oh oi mr lr oj ok mt ol bi translated">网络捕获和包过滤</h2><p id="0cbe" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果您开始Wireshark的捕获，您会看到许多许多数据包被捕获。你要做的第一件事是过滤那些感兴趣的包。再次使用上面的Petstore示例，我们可以看到我们要与之通信的服务器是<code class="fe nk nl nm nn b">petstore.swagger.io</code>，因此我们需要过滤进出该地址的网络数据包。</p><p id="890d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Wireshark中设置这样的过滤器只需要几个步骤:</p><ul class=""><li id="85da" class="nb nc iu lc b ld le lg lh lj nd ln ne lr nf lv ng nh ni nj bi translated">转到视图&gt;名称解析，并启用所有解析选项。</li><li id="1f4d" class="nb nc iu lc b ld np lg nq lj nr ln ns lr nt lv ng nh ni nj bi translated">使用以下过滤器:<code class="fe nk nl nm nn b">ip.host == petstore.swagger.io</code></li></ul><p id="2049" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过单击蓝色鳍图标开始网络捕获。您应该得到类似于以下输出的内容:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/57f2d7bb1b34e2e73018826c3cca1cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ea-Qp27RrIDWZb8uLcRlaQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Wireshark捕获(图片由作者提供)</p></figure><p id="ed93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以上捕获包括您的主机与<code class="fe nk nl nm nn b">petstore.swagger.io</code>通信并执行<code class="fe nk nl nm nn b"><a class="ae kz" href="http://petstore.swagger.io/v2/pet/1" rel="noopener ugc nofollow" target="_blank">pet/1</a></code>的REST调用时发送和接收的所有网络数据包。您可以通过单击上半部分绿色的特定请求/响应来查看每个数据包的完整详细信息。</p><p id="e911" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一种更方便的可视化完整交换的方法是右键单击请求/响应行，然后选择<code class="fe nk nl nm nn b">Follow &gt; TCP Stream</code>:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ox"><img src="../Images/2c516690e7584d139802d9381386d6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*MrhPlKij5epprN8dqYsxvw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在Wireshark中跟踪TCP流(图片由作者提供)</p></figure><p id="9f87" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Wireshark可能不是最直观的工具，需要时间来掌握；但是，它可以帮助您在尽可能低的级别发现问题。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="194c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="cb64" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">有时，当我们开发REST客户端时，我们发现REST后端拒绝提供适当的回复。</p><p id="d4a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章中，我们研究了四个不同层次的递增复杂性。让我们能够了解其余的数据交换。</p><p id="4dca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">JavaScript控制台、网络监视器、中间人服务器和网络流量分析是前端软件开发人员识别问题的重要工具。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="cd68" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">参考</h1><p id="3136" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">[1]维基百科。2005.表象状态转移【在线百科】。<a class="ae kz" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/representative _ state _ transfer</a>(2019-12月访问)。<br/> [2]维基百科。2005.罗伊·托马斯·菲尔丁[在线百科]。<a class="ae kz" href="https://en.wikipedia.org/wiki/Roy_Fielding" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Roy_Fielding</a>(2019年12月访问)。<br/> [3]菲尔丁，R. 2000。架构风格和基于网络的软件架构设计。<a class="ae kz" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" rel="noopener ugc nofollow" target="_blank">http://www . ics . UCI . edu/~ fielding/pubs/dissertation/rest _ arch _ style . htm</a>(访问时间2019–Dec)。<br/>【4】MDN网络文档。2016.HTTP请求方法[网站]。https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods(2019年12月访问)。<br/> [5] MDN网络文档。2010.HTTP头[网站]。<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers</a>(2019年12月访问)。<br/>【6】维基百科。2005.中间人攻击【在线百科】。<a class="ae kz" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Man-in-the-middle_attack</a>(2019年12月访问)<br/>【7】维基百科。2005.域名系统【在线百科】。<a class="ae kz" href="https://en.wikipedia.org/wiki/Domain_Name_System" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Domain_Name_System</a>(2019年12月访问)</p></div></div>    
</body>
</html>