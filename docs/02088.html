<html>
<head>
<title>5 Lesser-Known Features of WKWebView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WKWebView的5个鲜为人知的功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-lesser-known-features-of-wkwebview-f20c94998c11?source=collection_archive---------6-----------------------#2019-11-05">https://betterprogramming.pub/5-lesser-known-features-of-wkwebview-f20c94998c11?source=collection_archive---------6-----------------------#2019-11-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="65b8" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在您的iOS应用程序中运行JavaScript，拦截URL，等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/e3412028c0370eb3b7db411dcf43dab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hFbucvzj1J2n-l_j"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@_imkiran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sai Kiran Anagani </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="abff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS和Web历史悠久。他们的历史可以分为两个时代:摇摇欲坠的统治<code class="fe lw lx ly lz b">UIWebView</code>之后是救世主<code class="fe lw lx ly lz b">WKWebView</code>。<code class="fe lw lx ly lz b">UIWebView</code>从iOS 12开始就被弃用了。如果有一点点痕迹，苹果甚至不会接受应用程序提交。当它的继任者表现更好的时候，他们为什么要这样做呢？</p><p id="df16" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">WKWebView</code>是<code class="fe lw lx ly lz b">WebKit</code>框架的一部分，在应用程序的主线程之外运行，因此有助于其稳定性和卓越的性能。</p><p id="ed3d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于初学者来说，要加载内容，比如说在一个<code class="fe lw lx ly lz b">WKWebView</code>中加载一个URL字符串，我们只需执行以下操作:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="7b60" class="me mf iu lz b gz mg mh l mi mj">guard let url = URL(string: string) else { return }<br/>let request = URLRequest(url: url)<br/>webView?.load(request)</span></pre><p id="1032" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了内容加载和CSS样式，你还可以做更多的事情。</p><p id="7fb4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下部分是<code class="fe lw lx ly lz b">WKWebView</code>相对较少为人所知的特性的清单。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="ef4d" class="mr mf iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">1.拦截Web URL</h1><p id="98e1" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">通过实现<code class="fe lw lx ly lz b">WKNavigationDelegate</code>协议的<code class="fe lw lx ly lz b">decidePolicyFor</code>功能，我们可以在导航过程中拦截中间URL。下面的代码片段展示了这是如何实现的:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="c79c" class="me mf iu lz b gz mg mh l mi mj">func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) {</span><span id="f21b" class="me mf iu lz b gz nn mh l mi mj">  let urlString = navigationAction.request.url?.absoluteString ?? ""<br/>  let pattern = "interceptSomeUrlPattern"<br/>  if urlString.contains(pattern){</span><span id="241c" class="me mf iu lz b gz nn mh l mi mj">     var splitPath = urlString.components(separatedBy: pattern)</span><span id="5b56" class="me mf iu lz b gz nn mh l mi mj">  }<br/>}</span></pre></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="4f6e" class="mr mf iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">2.JavaScript警报</h1><p id="58a8" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">默认情况下，来自JavaScript的提示不会出现在<code class="fe lw lx ly lz b">WKWebView</code>中，因为它不是UIKit的一部分。因此，我们需要实现<code class="fe lw lx ly lz b">WKUIDelegate</code>协议，以便在提示中显示警告、确认或文本输入。</p><p id="4cef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是每个不同警报或行动表的方法:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="77a0" class="me mf iu lz b gz mg mh l mi mj">func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -&gt; Void)<br/><br/>func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -&gt; Void) <br/><br/><br/>func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -&gt; Void) {<br/><br/>        let alertController = UIAlertController(title: nil, message: prompt, preferredStyle: .alert)<br/><br/>        alertController.addTextField { (textField) in<br/>            textField.text = defaultText<br/>        }<br/>        alertController.addAction(UIAlertAction(title: "Ok", style: .default, handler: { (action) in<br/>            if let text = alertController.textFields?.first?.text {<br/>                completionHandler(text)<br/>            } else {<br/>                completionHandler(defaultText)<br/>            }<br/>        }))<br/><br/>        self.present(alertController, animated: true, completion: nil)<br/> }</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj no"><img src="../Images/ba504f557ba22606ade655470a22f650.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/1*uHPegNWCyGiPsFb43qHYGw.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">WKWebView中的JavaScript提醒</p></figure></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="7bef" class="mr mf iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">3.配置URL操作</h1><p id="7d84" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">使用<code class="fe lw lx ly lz b">decidePolicyFor</code>功能，您不仅可以通过呼叫、facetime和邮件等操作控制外部导航，还可以选择限制某些URL的打开。下面这段代码展示了每一种情况。</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="4aef" class="me mf iu lz b gz mg mh l mi mj">func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) {<br/><br/>guard let url = navigationAction.request.url else {<br/>            decisionHandler(.allow)<br/>            return<br/>        }<br/><br/> if ["tel", "sms", "mailto"].contains(url.scheme) &amp;&amp; UIApplication.shared.canOpenURL(url) {<br/>            UIApplication.shared.open(url, options: [:], completionHandler: nil)<br/>            decisionHandler(.cancel)<br/>        } else {<br/>            if let host = navigationAction.request.url?.host {<br/>               if host == "www.notsafeforwork.com" {<br/>                  decisionHandler(.cancel)<br/>               }<br/>               else{<br/>                   decisionHandler(.allow)<br/>               }<br/>            }<br/>        }        <br/>  }<br/>}</span></pre><h1 id="f0ff" class="mr mf iu bd ms mt np mv mw mx nq mz na ka nr kb nc kd ns ke ne kg nt kh ng nh bi translated">4.使用WKWebView验证</h1><p id="50e1" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated">当您在<code class="fe lw lx ly lz b">WKWebView</code>中的URL需要用户授权时，您需要实现以下方法:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="e64f" class="me mf iu lz b gz mg mh l mi mj">func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) {<br/>        <br/>        let authenticationMethod = challenge.protectionSpace.authenticationMethod<br/>        if authenticationMethod == NSURLAuthenticationMethodDefault || authenticationMethod == NSURLAuthenticationMethodHTTPBasic || authenticationMethod == NSURLAuthenticationMethodHTTPDigest {<br/>            //Do you stuff  <br/>        }<br/>        completionHandler(NSURLSessionAuthChallengeDisposition.UseCredential, credential)<br/>}</span></pre><p id="29c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">收到身份验证质询后，您可以确定它需要的身份验证类型(用户凭据或证书),并相应地使用提示或预定义的凭据来处理条件</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="567c" class="mr mf iu bd ms mt mu mv mw mx my mz na ka nb kb nc kd nd ke ne kg nf kh ng nh bi translated">5.跨WKWebViews共享Cookies</h1><p id="4a5e" class="pw-post-body-paragraph la lb iu lc b ld ni jv lf lg nj jy li lj nk ll lm ln nl lp lq lr nm lt lu lv in bi translated"><code class="fe lw lx ly lz b">WKWebView</code>的每个实例都有自己的cookie存储。为了跨多个<code class="fe lw lx ly lz b">WKWebView</code>实例共享cookies，我们需要使用如下所示的<code class="fe lw lx ly lz b">WKHTTPCookieStore</code>:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="d0d7" class="me mf iu lz b gz mg mh l mi mj">let cookies = HTTPCookieStorage.shared.cookies ?? []<br/>for (cookie) in cookies {<br/>   webView.configuration.websiteDataStore.httpCookieStore.setCookie(cookie)<br/>}</span></pre></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><p id="ea34" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">WKWebView的其他功能，如显示正在加载的URL的进度更新，这些天来相当普遍。</p><p id="55d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">ProgressViews</code>可以通过监听<code class="fe lw lx ly lz b">estimatedProgress</code>的<code class="fe lw lx ly lz b">keyPath </code>值来更新，方法如下:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="c063" class="me mf iu lz b gz mg mh l mi mj">override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)</span></pre><p id="ee34" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就结束了。我希望你喜欢读它。</p></div></div>    
</body>
</html>