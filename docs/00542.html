<html>
<head>
<title>Beginning Python Programming — Part 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python编程入门—第10部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginning-python-programming-part-10-afd00b71f04e?source=collection_archive---------4-----------------------#2019-06-07">https://betterprogramming.pub/beginning-python-programming-part-10-afd00b71f04e?source=collection_archive---------4-----------------------#2019-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b2144ee2c4dadce95f45ee0e6f215fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CB5OshHHEYumWyAw"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@hue12_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> hue12摄影</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e202" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上一篇文章中，我们讨论了与错误相关的所有内容，以帮助减少程序中的错误数量。</p><div class="le lf gp gr lg lh"><a href="https://medium.com/better-programming/beginning-python-programming-part-8-45cad890e6b" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">Python编程入门—第9部分</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">关于Python中的错误处理，您需要知道的一切</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jz lh"/></div></div></a></div><p id="94c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天我们将更进一步，学习更多的技巧来帮助你减少代码中的错误数量。</p><p id="7f27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你像我希望的那样一直在练习，你可能已经做了一个相当大的程序，吃了晚饭或者出去了，当你回来的时候，你感觉有点迷失在你的代码中。</p><p id="c31e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编程入门的时候经常会迷路。如果你因为忘记了五分钟前写的东西而分心，你会感到沮丧。别担心。我们大多数人都经历过。我有好消息；随着时间的推移，它会变得更容易。需要多长时间取决于你练习了多少。</p><p id="0f3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我来说，我花了大约六个月的时间进行日常编码。从我醒来到睡觉，甚至周末，我都在写代码。不要误会我；这并不意味着我没有生活。我还是出去玩了。有时我会精疲力尽，不得不停止写代码一两天。即使在那时，我仍然在阅读文章，并试图在我所做的事情上做得更好。</p><p id="4098" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以继续练习。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e77c" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">代码结构</h1><p id="c2e9" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">互联网上有大量的指南告诉你如何编写代码，也有关于如何格式化代码的文档，但是结构化代码总是留给开发人员去做。我不是说“让我们制定一个标准。”这将是太多的工作，但我们都同意，你的代码有一个通用的起点，这就是我将要讨论的。因为我们还没有介绍模块或文件导入，所以我可以先花点时间来做这件事。</p><h2 id="a1a8" class="ng me it bd mf nh ni dn mj nj nk dp mn kr nl nm mr kv nn no mv kz np nq mz nr bi translated">进口</h2><p id="0b52" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">导入允许您导入位于其他文件或模块中的代码。例如，如果我有一个名为<code class="fe ns nt nu nv b">models.py</code>的文件，里面有一个<code class="fe ns nt nu nv b">Person</code>类，我需要在另一个名为<code class="fe ns nt nu nv b">app.py</code>的文件中使用它，我不能只调用<code class="fe ns nt nu nv b">Person</code>类，它就会工作；我得先导入它。那么我们如何做到这一点呢？</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="ba34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">import</code>是Python中一个独特的关键字，它告诉解释器去别处寻找稍后将在这个文件中被调用的代码。当解释器运行<em class="oc">这个</em>文件中的代码时，它是第一个被处理的东西。在这个例子中，我们导入整个<code class="fe ns nt nu nv b">models</code>文件。我们只包括文件名；不是分机。</p><p id="3f48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这允许我们使用出现在<code class="fe ns nt nu nv b">models.py</code>中的每一个类或函数。这是可以的，但有时我们希望明确我们导入的内容。相反，我们可以使用<code class="fe ns nt nu nv b">from ... import</code>。</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="8543" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们有一个更好的import语句版本。我们只导入<code class="fe ns nt nu nv b">Person</code>类。如果我们要有一个<code class="fe ns nt nu nv b">Dog</code>类，我们需要一个单独的导入，或者我们可以在<code class="fe ns nt nu nv b">Person</code>后面加上<code class="fe ns nt nu nv b">Dog</code>，用逗号隔开。</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="8865" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用与您的代码无关的其他导入，您可能会对此感兴趣。例如，如果你打开一个Python控制台并输入<code class="fe ns nt nu nv b">import this</code>，你会在控制台窗口中看到<em class="oc"> The Zen of Python，</em>作者Tim Peters。</p><p id="80c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个和这篇文章有关，所以我准备贴在下面。</p><blockquote class="od oe of"><p id="6d6a" class="kg kh oc ki b kj kk kl km kn ko kp kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated">蒂姆·彼得斯的《Python之禅》</p><p id="21df" class="kg kh oc ki b kj kk kl km kn ko kp kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated">漂亮总比难看好。<br/>显性比隐性好。<br/>简单胜于复杂。<br/>复杂总比复杂好。<br/>扁平比嵌套好。<br/>稀不如密。<br/>可读性很重要。特例不足以特殊到打破规则。<br/>虽然实用性胜过纯粹性。错误永远不会无声无息地过去。<br/>除非明确消音。<br/>面对暧昧，拒绝猜测的诱惑。应该有一种——最好只有一种——显而易见的方法来做这件事。除非你是荷兰人，否则这种方式一开始可能并不明显。现在总比没有好。<br/>虽然永远也不会比现在*好。如果实现很难解释，这是个坏主意。如果实现容易解释，这可能是个好主意。名称空间是一个非常棒的主意——让我们多做一些吧！</p></blockquote><p id="f8b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通读几遍，并在编写代码时尽量记住这一点。</p><p id="d39a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个有趣的是<code class="fe ns nt nu nv b">import antigravity</code>。</p><h2 id="a070" class="ng me it bd mf nh ni dn mj nj nk dp mn kr nl nm mr kv nn no mv kz np nq mz nr bi translated">模块</h2><p id="5d34" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">模块只是包含相关代码的文件夹，比如助手、服务甚至模型。</p><p id="01ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我打这封信时，我意识到我从未真正解释过什么是模型。模型主要是程序运行时用来存储数据的对象。一个人、一只狗、一只猫或一个地方可以被认为是一个模型。这些模型允许您将特定对象的数据作为一个值传递，而不是多个值。</p><p id="c702" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到模块。模块和文件夹在结构上的区别在于，模块内部包含一个名为<code class="fe ns nt nu nv b">__init__.py</code>的文件。该文件可以是空白的，或者它可以为任何导入该模块的人提供初始配置信息。</p><pre class="nw nx ny nz gt oj nv ok ol aw om bi"><span id="bf38" class="ng me it nv b gy on oo l op oq">my_project/<br/>    models/<br/>        __init__.py<br/>        person.py<br/>        dog.py<br/>        cat.py<br/>    app.py</span></pre><p id="9172" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用上面的文件夹结构，我们可以使用以下语法导入person类:</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1618" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以调整<code class="fe ns nt nu nv b">__init__.py</code>来包含导入语句，以便在其他地方更容易。</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5343" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为这些文件属于一个模块，我们可以使用<code class="fe ns nt nu nv b">.</code>来表示当前的文件夹，而不用输入<code class="fe ns nt nu nv b">models</code>。这对于小型项目来说没问题，但是在大型项目中，知道从哪里导入可能更有意义，特别是如果您有嵌套模块的话。</p><p id="9c5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当我们需要导入<em class="oc"> models </em>文件夹中的任何类时，它变得更加易于管理。</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="805c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看到多简单了吗？<code class="fe ns nt nu nv b">models</code>因为<code class="fe ns nt nu nv b">__init__.py</code>知道不同的类，我们可以直接导入这些类，而不必引用每个类所在的文件。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0896" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">文件结构</h1><p id="0298" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">好了，知道了导入之后，让我们从代码结构开始，更确切地说是文件结构。</p><p id="5e31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当编写程序时，我们需要确保我们的代码是可读的。我不知道你，但我倾向于从上到下，从左到右阅读。为什么我们的代码不能这样做呢？</p><p id="68be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我只能使用一个Python文件时，比如当我正在编写一个脚本时，我希望它遵循以下模式:</p><pre class="nw nx ny nz gt oj nv ok ol aw om bi"><span id="c47c" class="ng me it nv b gy on oo l op oq">[import statements]</span><span id="6fd9" class="ng me it nv b gy or oo l op oq">[global variables/constants]</span><span id="a60c" class="ng me it nv b gy or oo l op oq">[class declarations]</span><span id="0f99" class="ng me it nv b gy or oo l op oq">[helper/one shot functions]</span><span id="9302" class="ng me it nv b gy or oo l op oq">entry point</span></pre><p id="0527" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我用方括号是因为它们是可选的；你可能不总是需要进口或任何其他项目。您的代码应该从某个地方开始，默认情况下，这是在顶级范围。这就是我们的<code class="fe ns nt nu nv b">print</code>语句奏效的原因。</p><p id="87cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当首先需要调用的是一个函数时，标准惯例是使用下面的语法来启动程序。</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0c75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于这方面的更多信息，请查看这篇关于堆栈溢出的<a class="ae kf" href="https://stackoverflow.com/a/419185" rel="noopener ugc nofollow" target="_blank">好文章</a>。</p><p id="5e40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我以这种特殊的顺序安排版面，因为这样最有意义。</p><ol class=""><li id="1cc4" class="os ot it ki b kj kk kn ko kr ou kv ov kz ow ld ox oy oz pa bi translated">导入应该总是在你需要它们的任何范围的顶端；通常，这是文件的顶部。</li><li id="ed50" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld ox oy oz pa bi translated">接下来应该是全局变量和常量。打开代码，在顶部看到所有的固定变量总是好的；当他们中的一个需要改变的时候，它会减少以后的搜索。</li><li id="803f" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld ox oy oz pa bi translated">接下来是类声明，因为在添加更多代码时，它们可能需要新的字段或引用。</li><li id="06b9" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld ox oy oz pa bi translated">一次性函数包含在上面的帮助函数中，但它们通常位于帮助函数之上，它们之所以得名是因为它们在程序运行时只被调用一次。这是用于环境变量的状态配置，或者可能设置程序来处理与另一个源的认证。</li><li id="3341" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld ox oy oz pa bi translated">助手函数是你会反复使用的代码，比如生成一个随机数或者对一系列数字求和。</li><li id="f6ef" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld ox oy oz pa bi translated">入口点是代码开始的地方。我们把它放在底部，因为在以前的C/C++时代，你需要把所有的声明都放在顶部。这只是出于习惯，你会经常看到这种情况。</li></ol><figure class="nw nx ny nz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pg"><img src="../Images/ee4ab8a20b6d1bb7ea9a8275f3345e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WRN11IkFllzNroV0"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="ac0b" class="md me it bd mf mg ph mi mj mk pi mm mn mo pj mq mr ms pk mu mv mw pl my mz na bi translated">原则</h1><p id="5a7a" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">你的项目应该是有意义的，就像你把东西放在整个房子的房间里一样。在编程中，我们没有沙发、烤箱或床，但我们有模型、服务、视图、助手、API和应用程序。</p><p id="ab1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Django在分离功能方面做得很好，迫使你使用合适的项目结构。</p><p id="23bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们进入项目结构之前，我想介绍一些原则。</p><p id="37a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，<em class="oc">“如果它没坏，就不要修理它。”这应该是一个非常简单的原则。如果你写的代码有效，即使你不知道它是如何工作的，也不要去管它。如果你试图修理它，你很可能会把它弄坏，而且不知道如何把它恢复原样。</em></p><p id="a5c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="oc">信息隐藏</em>。这仅仅是确保可访问性(由访问控制定义)在您编写的每段代码上都尽可能地受到限制。如果没有其他人应该看到<code class="fe ns nt nu nv b">my_super_secret_function()</code>，就不要公开。前面加个<code class="fe ns nt nu nv b">_</code>，别人就知道不用了。如果您有构建URL的网络代码，让网络类创建URL；在networking类中将该方法设置为private。</p><p id="82c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="oc">松耦合</em>。这听起来很抽象，其实不然。当一个类使用另一个类的一部分时，只从这个类中获取你需要的东西；不要在原始类中实例化那个类。否则，你会得到一个强引用。松散耦合只是保持类间低依赖性的结果。使用字典、列表或集合来帮助减少每个班级之间的相互了解。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fd7e" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">项目结构</h1><p id="8a80" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">你的项目结构会根据你需要做什么而改变。有时您只需要一个文件，但是当您需要更多文件时，您如何跟踪所有文件呢？</p><p id="139a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我的典型文件结构，适用于大中型纯Python应用程序。</p><pre class="nw nx ny nz gt oj nv ok ol aw om bi"><span id="3834" class="ng me it nv b gy on oo l op oq">my_project/<br/>  app/<br/>    __init__.py<br/>    main.py<br/>    helper1.py<br/>    helper2.py</span><span id="87e1" class="ng me it nv b gy or oo l op oq">models/<br/>    __init__.py<br/>    class1.py<br/>    class2.py<br/>    class3.py</span><span id="ba2d" class="ng me it nv b gy or oo l op oq">services/<br/>    __init__.py<br/>    auth_service.py<br/>    database_service.py<br/>    network_service.py</span><span id="8248" class="ng me it nv b gy or oo l op oq">tests/<br/>    __init__.py<br/>    classes_test.py<br/>    app_test.py<br/>    services_test.py</span><span id="9e69" class="ng me it nv b gy or oo l op oq">venv/<br/>    ..</span><span id="a644" class="ng me it nv b gy or oo l op oq">app.py<br/>  config.py<br/>  requirements.txt<br/>  test_requirements.txt<br/>  .env<br/>  .secrets</span></pre><p id="4f05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个项目中，我们有一个<code class="fe ns nt nu nv b">app</code>模块，它包含了我们应用程序的所有业务逻辑；也就是将数据从一个地方移动和转换到另一个地方的代码。</p><p id="b635" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以被称为任何东西，但我只是让它容易理解。<code class="fe ns nt nu nv b">main.py</code>不是我们应用程序的入口点，但它是我们程序开始工作的地方。这些<code class="fe ns nt nu nv b">helper#.py</code>文件可能并不必要，但是我们在这里使用它们只是因为它是一个例子。</p><p id="aba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">models</code>包含我们将在整个应用程序中使用的所有模型(即类)。</p><p id="26c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">services</code>包括我们所有的后台代码。这种代码可能写起来并不有趣，但我们需要多次使用它，而且它太大了，无法在一个文件下工作。在这里，我们有用于与服务器进行身份验证、连接到数据库并对数据库执行CRUD操作(创建、读取、更新、删除)的代码，以及网络代码，因此我们不必继续编写代码来确保得到响应，如果没有得到响应就记录错误。</p><p id="62d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">tests</code>包含我们所有的测试。测试文件可以是基于模块的，也可以是基于文件的，这取决于需要，如果需要的话，我们可以将它们分解到它们的模块中。</p><p id="4fb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">venv</code>是我们没有涉及到的，但这是针对<em class="oc">虚拟环境</em>的，我将在后面的教程中介绍。当您使用它时，它会自动为您创建，现在可以安全地忽略它。</p><p id="d244" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">app.py</code>是我们用来启动程序的文件。这通常包含一个导入，导入让仓鼠在轮子上运行的主文件。</p><p id="bedf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">config.py</code>是一个<code class="fe ns nt nu nv b">Config</code>类，包含我们应用程序的默认运行配置。这不是必需的，但却是一个不错的选择。</p><p id="57d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">requirements.txt</code>和<code class="fe ns nt nu nv b">test_requirements.txt</code>未涉及，但它们提供了运行该程序所需的外部模块及其版本号的列表。我喜欢把这些分开，所以我不在我的产品代码中包含任何测试模块。</p><p id="e045" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">.env</code>是*nix系统上的一个隐藏文件，我们会创建它来存储环境变量。它无论如何都不安全，但是我们可以稍后解析它，并根据需要提取值。</p><p id="4b06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ns nt nu nv b">.secrets</code>与<code class="fe ns nt nu nv b">.env</code>相同，除了它可以用来存储用户名和密码。我强烈建议您只在部署到docker/podman容器时使用类似的东西，这样您就可以在文件被读入内存后删除它。你还需要确保你的程序有一个运行循环(像web服务器一样)，这样它就不会结束运行。一旦出现这种情况，所有这些变量都会从内存中释放出来。</p><figure class="nw nx ny nz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pm"><img src="../Images/f3293df0e2f6c2ba7d21f0b9e7de17d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LesbollEokwxiMdh"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@2mduffel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克·达弗尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="b6a4" class="md me it bd mf mg ph mi mj mk pi mm mn mo pj mq mr ms pk mu mv mw pl my mz na bi translated">编码指南</h1><p id="c270" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">Python的开发者已经创建了一些标准，称为PEPs。最著名的是PEP 8风格指南。这是一份很长的文件，但很有帮助。</p><p id="4c3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些亮点:</p><ul class=""><li id="fb24" class="os ot it ki b kj kk kn ko kr ou kv ov kz ow ld pn oy oz pa bi translated">行长度不应超过80个字符。一些格式化程序(如Black)认为这已经过时，建议使用更宽松的88个字符。</li><li id="2cc5" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld pn oy oz pa bi translated">如果你不得不超过80个字符，总是硬包装在120个字符。</li><li id="ceec" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld pn oy oz pa bi translated">需要多行的冗长公式建议在运算符前断开(+-*/)。</li><li id="4581" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld pn oy oz pa bi translated">在顶级函数和类之间使用两行空行，在类中的方法之间使用一行空行，在函数中尽量少用空行来表示逻辑部分。</li><li id="6149" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld pn oy oz pa bi translated">从不同模块的导入应该总是在不同的行上。</li><li id="2542" class="os ot it ki b kj pb kn pc kr pd kv pe kz pf ld pn oy oz pa bi translated">应避免通配符输入(<code class="fe ns nt nu nv b">from models import *</code>)。不清楚进口的是什么。</li></ul><p id="744b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有很多东西要看，所以我强烈建议你读一读。</p><p id="8fad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个要看的文档是<a class="ae kf" href="https://www.python.org/dev/peps/pep-0257/" rel="noopener ugc nofollow" target="_blank"> PEP 257 </a>，它涵盖了docstrings。这也是强烈推荐的，因为docstring提供了每个函数的功能描述以及它在支持docstring的编辑器中返回的内容(PyCharm，VS Code)，从而使您的工作变得简单。</p><h2 id="6b0e" class="ng me it bd mf nh ni dn mj nj nk dp mn kr nl nm mr kv nn no mv kz np nq mz nr bi translated">使用描述性变量名称</h2><p id="7b94" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">不要像人们在C/C++中那样，试图用一个字母的变量来混淆代码。这些年来，<code class="fe ns nt nu nv b">i</code>、<code class="fe ns nt nu nv b">j</code>、<code class="fe ns nt nu nv b">k</code>、<code class="fe ns nt nu nv b">l</code>、<code class="fe ns nt nu nv b">m</code>、<code class="fe ns nt nu nv b">n</code>、<code class="fe ns nt nu nv b">t</code>、<code class="fe ns nt nu nv b">x</code>、<code class="fe ns nt nu nv b">y</code>和<code class="fe ns nt nu nv b">z</code>有太多的值，它们可以代表任何东西。告诉我你有一个程序可以计算一段时间内以给定速度行驶的距离，除了<code class="fe ns nt nu nv b">j</code>、<code class="fe ns nt nu nv b">k,</code>和<code class="fe ns nt nu nv b">m</code>什么都没说；这很好，高级开发人员，但是什么是<code class="fe ns nt nu nv b">k</code>？<em class="oc">高级dev看代码一分钟……</em>啊，<code class="fe ns nt nu nv b">k</code>是速度变量。</p><p id="46ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">真的吗？谁会知道<code class="fe ns nt nu nv b">k</code>是速度变量，而不用考虑高级开发人员用来编写程序的公式呢？重点不就是我们应该能够立即看到一段代码并说“是的，这是速度设置的地方；我可以在这里添加一个五分钟的休息时间来模拟一次停顿，并在高级开发人员告诉我<code class="fe ns nt nu nv b">k</code>是什么的相同时间内完成。”</p><p id="1e53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于单字母变量的一点历史:开发人员使用单字母变量的原因是自动完成功能不存在，而且开发人员不想尽可能多地输入。它还确保程序员不会拼错变量名。这相当于在21世纪初用手机发短信。我们用了<em class="oc"> lol，c u l8r，&lt; 3 u，</em>和<em class="oc"> ttyl </em>。为了缩短我们的单词，我们只需要按下按钮20次，而不是100次，如果我们真的拼出了完整的单词。时代变了；几乎每一种主流编程语言都有自动完成功能。</p><p id="b90d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时候还可以；例如，if语句中的临时变量，您仍然可以在离您键入的地方五行之外看到声明。这就像在iPhone上使用<code class="fe ns nt nu nv b">lol</code>。一切都好。但是当你在一个类或结构中使用<code class="fe ns nt nu nv b">a</code>作为变量时，那就有问题了。当我看到有人在智能手机上输入<code class="fe ns nt nu nv b">c u l8r</code>时，我会摇头。<em class="oc">但是你不是要换键盘类型才能打8键吗？似乎比它值得做的还要多。同样，对于全局单字母变量，您必须弄清楚它代表什么，然后才能在八个月后的更改中使用它；似乎比它的价值更多的工作。</em></p><p id="929b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你忘记了我所说的一切，只要记住总是使用描述性变量和常数。我一直在没有自动完成的情况下从头开始编写这些教程，键入一些很长的变量名，很少使用复制粘贴。使用自动完成功能给变量起一个描述性的名字<em class="oc">应该不成问题。</em></p><h1 id="501f" class="md me it bd mf mg ph mi mj mk pi mm mn mo pj mq mr ms pk mu mv mw pl my mz na bi translated">摘要</h1><p id="2752" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">今天，我们讨论了一些需要记住的原则，从其他文件和模块引入代码的import语句，基本文件和项目结构，以及PEP标准，为您在代码中应该实现的目标提供了路线图。</p><p id="2f49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我强烈建议你回顾一下之前的例子，尽量把它们做的漂亮一点。我将是第一个告诉你，使你的代码干净可能是困难的。我的代码远没有我所希望的整洁，但是它是有效的。这是你做得越多越擅长的技能之一。</p><h2 id="8ddd" class="ng me it bd mf nh ni dn mj nj nk dp mn kr nl nm mr kv nn no mv kz np nq mz nr bi translated">建议扫描</h2><p id="234b" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">我说扫描不是阅读；读书是理想的，但一开始你不会记住一半。挑出你认同的重要部分，并从那里开始。</p><div class="le lf gp gr lg lh"><a href="https://www.python.org/dev/peps/pep-0008" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">PEP 8风格的Python代码指南</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">Python编程语言的官方主页</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">www.python.org</p></div></div><div class="lq l"><div class="po l ls lt lu lq lv jz lh"/></div></div></a></div><p id="7f89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和</p><div class="le lf gp gr lg lh"><a href="https://www.python.org/dev/peps/pep-0257/" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">PEP 257 -文档字符串约定</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">Python编程语言的官方主页</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">www.python.org</p></div></div><div class="lq l"><div class="pp l ls lt lu lq lv jz lh"/></div></div></a></div><p id="c8d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他的pep，但是如果你想看的话，我会让你自己决定。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b4e1" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">下一步是什么？</h1><p id="34fa" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">根据我的Swift文章，我们涵盖了异步。我认为在开始异步编程之前，我们还有更重要的事情要做。虽然一次做多件事很有趣，但我认为如果我们先讨论虚拟环境和PyPI会更好。</p><p id="4f0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然我提到我不会讨论外部模块，但我并没有说我不会讨论如何获取它们，所以虚拟环境和获取Python包将在下一篇文章中讨论。</p><div class="le lf gp gr lg lh"><a href="https://medium.com/better-programming/beginning-python-programming-part-11-1dc915b4f0fd" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">Python编程入门—第11部分</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">使用模块和虚拟环境</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="pq l ls lt lu lq lv jz lh"/></div></div></a></div></div></div>    
</body>
</html>