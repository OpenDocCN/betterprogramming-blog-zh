<html>
<head>
<title>The Case for Using Custom Back Buttons in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中使用自定义后退按钮的案例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-case-for-using-custom-back-buttons-in-swiftui-99b3124f3572?source=collection_archive---------6-----------------------#2020-08-27">https://betterprogramming.pub/the-case-for-using-custom-back-buttons-in-swiftui-99b3124f3572?source=collection_archive---------6-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a05c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">夺回你认为SwiftUI为了简单而牺牲的控制权</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7d13d129ce063a7608f01a28edf2435c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tMOGBJxLPx-iwYhrj1Q5w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="13c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SwiftUI简化了应用程序中的许多常见功能、能力和控制。很明显，开发过程中的一个焦点是考虑开发人员如何简单地合并通用UI元素，并且自动处理大量开销。该框架甚至考虑了可用性和设计的角度。</p><p id="77ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这非常受iOS社区的欢迎，他们有使用界面构建器、故事板和视图控制器的经验。任何处理过即使是最简单的功能所要求的复杂性的人都可以理解SwiftUI的好处。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="fd4b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">有什么问题吗？</h1><p id="574f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">随着开发人员开始用SwiftUI构建越来越复杂的应用，有时感觉功能(如导航)几乎<em class="my">过于</em>简单。当我浏览堆栈溢出Q &amp; A时，我看到越来越多的标记问题要求更多的开发控制。类似地，我看到了许多解决方案，包括包装旧的UIKit解决方案来填补空白。</p><p id="26a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望随着SwiftUI的不断成熟和发展，我们将会看到越来越少的UIKit和越来越多的SwiftUI(这在今年的WWDC20上肯定会出现)。</p><p id="7763" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我也希望我们只是在万不得已的情况下才使用另一个框架。也许我们可以找到纯粹的SwiftUI解决方案，就像苹果建议的那样，尽管它们可能看起来粗糙和/或不太漂亮。不过，我认为，我们引入UIKit也是一样的做法。</p><p id="69a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">郑重声明:我并不真的反对uik it——只是希望减少依赖性，看到一个新的框架独立存在。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a6a9" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">SwiftUI Unwind？</h1><p id="7d5d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">开发人员似乎错过的一个能力是放松。我们有一个带导航的“免费”后退按钮，但是没有添加任何代码或补全的选项。回到过去的UIKit时代，有一些选择。如果我们使用了<code class="fe mz na nb nc b">segue</code>，我们可以将代码放入展开中。另一个选择是使用<code class="fe mz na nb nc b">viewWillDisapear</code>或其他生命周期事件。</p><p id="223e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于SwiftUI，在开发人员希望在导航回父节点之前运行一些代码的情况下(而不是在绑定改变时立即运行)，我们自然可以“免费”做的最好的事情是触发<code class="fe mz na nb nc b">.onDisappear</code>(被列为SwiftUI生命周期事件之一的<a class="ae nd" href="https://medium.com/flawless-app-stories/the-simple-life-cycle-of-a-swiftui-view-95e2e14848a2" rel="noopener">)。然而，这在技术上是运行的，因为父元素已经进入视图，这可能会产生尴尬的UI结果。由于NavigationView中的父视图已经出现，<code class="fe mz na nb nc b">onAppear</code>不是一个安全的选择。</a></p><p id="2b9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种方法是自己动手，创建一个自定义的后退按钮。这是很自然的，因为尽管我们没有使用免费创建的按钮，但是我们可以在视图中添加栏项目。如果我们的应用程序需要的不仅仅是简单的向后导航，我们绝对应该利用这种方法。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="2dff" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">创建我们的后退按钮</h1><p id="899e" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">创建一个新的后退按钮实际上很简单，尽管在这个过程中可能会向您介绍一些新的修饰符等等。这里假设您有一个详细视图，您正在使用NavigationView沿着链<em class="my">向下导航到</em>，并且想要使用后退按钮从沿着链<em class="my">向上导航。</em></p><p id="26f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，在通常声明视图属性的地方，需要引入一个名为<code class="fe mz na nb nc b">presentationMode</code>的系统环境属性:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="4988" class="ni mc it nc b gy nj nk l nl nm">@Environment(\.presentationMode) var presentationMode</span></pre><p id="644d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，苹果文档似乎缺乏关于<code class="fe mz na nb nc b">presentationMode</code>的深度(对于<a class="ae nd" href="https://developer.apple.com/documentation/swiftui/environmentvalues/3363874-presentationmode" rel="noopener ugc nofollow" target="_blank">实例属性</a>，对于<a class="ae nd" href="https://developer.apple.com/documentation/swiftui/presentationmode" rel="noopener ugc nofollow" target="_blank">结构</a>就更少了)。我们所知道的是，它是绑定到应用环境的所有视图的默认属性。这一点很重要。</p><p id="025c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果视图是导航层次结构的一部分，那么它们带有与导航交互的修饰符。在我们的例子中，我们想要添加一些修改器到我们的细节视图的最上层(例如包含堆栈)。</p><p id="3d3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个修改器将隐藏默认的后退按钮:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="79f9" class="ni mc it nc b gy nj nk l nl nm">.navigationBarBackButtonHidden(true)</span></pre><p id="52c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要的第二个修饰符将允许我们向导航栏添加项目(导航后代视图顶部的保留空间):</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="b7a0" class="ni mc it nc b gy nj nk l nl nm">.navigationBarItems(leading: &lt;View(s)&gt;)</span></pre><p id="08c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于我们的目的，我们将创建一个这样的按钮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="74cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！我们现在有了back按钮，可以在实际关闭视图之前运行代码。</p><p id="42a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="my">注意:您可能会注意到，我们在按钮文本中添加了“Back”。如果我们想要父视图的名称，我们需要将它传递给后代(作为一个属性也可以，不需要状态)。</em></p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ed93" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">备份场景</h1><p id="624f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">为什么有人想要一个自定义的后退按钮？有一种观点认为，大多数场景都可以用现有的方法来解决——尤其是使用绑定和组合。这里有几个我认为有用的场景。</p><h2 id="228e" class="ni mc it bd md np nq dn mh nr ns dp ml lh nt nu mn ll nv nw mp lp nx ny mr nz bi translated">场景一:你确定吗？</h2><p id="7331" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">需要自定义后退按钮的一种可能情况是，希望在导航之前在当前视图上执行一个操作。其中一个例子是询问用户是否确定要返回(据我所知，这是一个开创性的例子)。</p><p id="9234" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们可以向视图添加一个警告，提示用户是否确定要返回。我们还将把<code class="fe mz na nb nc b">dismiss</code>呼叫从我们的后退按钮移出，变成肯定提醒:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="420b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们希望通过后退按钮触发警报:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="b88d" class="ni mc it nc b gy nj nk l nl nm">// Add a new State to your View<br/>@State var showAlert: Bool = false</span><span id="08a2" class="ni mc it nc b gy oa nk l nl nm">// Add the following trigger inside the Back button<br/>// Note: we set to true, not toggle<br/>self.showAlert = true</span></pre><h2 id="8834" class="ni mc it bd md np nq dn mh nr ns dp ml lh nt nu mn ll nv nw mp lp nx ny mr nz bi translated">场景2:当我准备好的时候同步</h2><p id="c7ce" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果数据是在屏幕上创建或编辑的，可能会有这样一种情况，我们不一定希望这些更改是可绑定的。也许我们更希望用户继续他们的体验，只有在他们通过点击后退按钮表示完成后，我们才开始存储/同步数据。甚至在此之前篡改数据。</p><p id="d4cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据可能已经在当前视图中可用。只需在我们的<code class="fe mz na nb nc b">dismiss</code>之前的back按钮中添加必要的代码。</p><h2 id="d024" class="ni mc it bd md np nq dn mh nr ns dp ml lh nt nu mn ll nv nw mp lp nx ny mr nz bi translated">场景3:传递回调以获得更动态的导航</h2><p id="4fa8" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果我们有一个视图，我们计划导航回多个不同的后代，会发生什么？在返回到该视图时，我们想要运行某种进程(如前所述，<code class="fe mz na nb nc b">onAppear</code>在返回到父视图时不计算在内)。</p><p id="beda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想做的事情主要发生在父视图中，让每个潜在的后代强制兼容它不应该知道的事情可能会很乏味和难以控制。那么，解决方案就是传递一个回调闭包，让它在我们的back按钮中运行！</p><p id="36fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使后代看不到需要做的事情的复杂性，而只是让它成为信使和触发器。</p><p id="cb30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接受和运行闭包的方法如下:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="4b9c" class="ni mc it nc b gy nj nk l nl nm">// Make a closure an optional parameter in the descendant View<br/>var onBack: (<!-- -->() -&gt; Void)? = nil</span><span id="91ff" class="ni mc it nc b gy oa nk l nl nm">// In our Back button, we'll run the closure, provided it's not nil<br/>onBack?()</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="1895" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">夺回控制权</h1><p id="4863" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我喜欢swift ui——在今年的WWDC20之后更是如此。虽然还有一些成熟的东西要走，但这并不意味着我们不能编写完全健壮和强大的应用程序。相反，我期待看到一些用SwiftUI编写的很棒的应用。</p><p id="e9ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，虽然SwiftUI确实弥补了很多不足，并使事情变得简单，但这并不意味着我们不能获得创建出色应用程序所需的访问和控制。</p><p id="1735" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">四处挖掘，夺回你认为已经失去的控制权！</p></div></div>    
</body>
</html>