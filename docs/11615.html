<html>
<head>
<title>Why is Flutter Fast?— Part 2: Layered Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Flutter很快？—第2部分:分层架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-is-flutter-fast-part-2-layered-architecture-c8954b03e994?source=collection_archive---------4-----------------------#2022-04-04">https://betterprogramming.pub/why-is-flutter-fast-part-2-layered-architecture-c8954b03e994?source=collection_archive---------4-----------------------#2022-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8be0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一系列文章中，我们旨在回答这个问题:“为什么Flutter很快？”。根据<a class="ae kl" href="https://twitter.com/adambarth" rel="noopener ugc nofollow" target="_blank"> Adam Barth </a>的说法，他是Flutter项目的联合创始人，也是Flutter库中<a class="ae kl" href="https://github.com/flutter/flutter/graphs/contributors?from=2014-10-19&amp;to=2014-10-20&amp;type=c" rel="noopener ugc nofollow" target="_blank">第一次提交的作者，Flutter之所以快是因为</a><a class="ae kl" href="https://youtu.be/UUfXWzp0-DU?t=194" rel="noopener ugc nofollow" target="_blank">它很简单</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/95e0f6755e0a15e7c838c72c274a1775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4fU1lRYOFU4D1RbfF1PHtQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">亚当·巴斯在他著名的<a class="ae kl" href="https://youtu.be/UUfXWzp0-DU" rel="noopener ugc nofollow" target="_blank">渲染管道</a>演讲中</p></figure><p id="ea45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分，我们将解释Flutter的分层架构及其对性能的影响。要更详细地了解架构，我建议阅读Flutter早期的著名博客文章:<a class="ae kl" href="https://medium.com/flutter-community/the-layer-cake-widgets-elements-renderobjects-7644c3142401" rel="noopener"> The Layer Cake </a>和关于这个主题的最佳资源在<a class="ae kl" href="https://docs.flutter.dev/resources/architectural-overview#architectural-layers" rel="noopener ugc nofollow" target="_blank"> Flutter网站</a>。</p><ul class=""><li id="e53c" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><a class="ae kl" href="https://ulusoyca.medium.com/why-is-flutter-fast-part-1-sublinear-building-317572cd6b47" rel="noopener">第1部分:次线性建筑</a></li><li id="a640" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">第二部分:分层架构</strong></li><li id="4de7" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://ulusoyca.medium.com/why-is-flutter-fast-part-3-rendering-pipeline-3a31056355e5" rel="noopener">第三部分:渲染管道</a></li></ul><h1 id="cc5d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">颤动前</h1><p id="fd61" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">了解Flutter的历史和它最初要解决的问题对于理解Flutter是如何工作的非常有帮助。解释《Flutter》前传的最佳资源来自其联合创始人亚当·巴斯和埃里克·塞德尔·T21。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="b0d6" class="mv lr iq bd ls mw mx dn lw my mz dp ma jy na nb me kc nc nd mi kg ne nf mm ng bi translated">从Webkit到Blink</h2><p id="f2d0" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">WebKit是Safari和macOS、iOS和Linux上的许多其他应用程序使用的开源网络浏览器引擎。当谷歌Chrome在2008年首次发布时，它使用了WebKit引擎。</p><p id="d116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">苹果和谷歌团队正在学习如何一起操作Webkit，尽管他们为利益冲突的公司工作。随着Google Chrome的发展，Webkit需要越来越多的改变，这拖慢了两个团队的进度。</p><p id="78fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2013年，谷歌分叉Webkit，开始使用自己的网页浏览器引擎“Blink”。Blink引擎包括DOM、HTML DOM和CSS渲染引擎、Web IDL实现、Skia图形引擎和V8 JavaScript引擎[ <a class="ae kl" href="https://en.wikipedia.org/wiki/Blink_(browser_engine)" rel="noopener ugc nofollow" target="_blank"> 17 </a> ]。</p><h2 id="985e" class="mv lr iq bd ls mw mx dn lw my mz dp ma jy na nb me kc nc nd mi kg ne nf mm ng bi translated">让网络更适合移动设备</h2><p id="0269" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">Chrome团队知道，他们在2000年代末的移动热潮中姗姗来迟。自从Chrome开始拥有自己的引擎，该团队开始研究如何改善移动平台上的网络体验。这种方法剥离了网络平台，只使用其必要的部分。为此，2013年启动了" Bravo "项目。</p><p id="e916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">project Bravo的想法是通过互联网从一个URL获取序列化为JSON的Javascript代码，并在自托管框架中显示内容。Javascript代码直接运行到图形库、一些网络API和特定于平台的API。</p><p id="b050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">web平台使用WebGL，这是一个标准的Javascript API，用于通过GPU加速渲染图形。代替WebGL，project Bravo将OpenGL作为移动设备中GPU加速的目标，并负责构建自己的渲染树。该团队还重新考虑了从CSS继承的布局模型。</p><h2 id="a64c" class="mv lr iq bd ls mw mx dn lw my mz dp ma jy na nb me kc nc nd mi kg ne nf mm ng bi translated">打开天空！</h2><p id="5cc3" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">Bravo项目在内部结束，从未公开，但实验为颤振铺平了道路。2014年，剃刀计划启动。该团队实现了将Blink缩小52%，并能够将HTML解析体验提高19倍。这些有希望的结果导致Adam和Eric离开Chromium团队，开始了一个名为<code class="fe nh ni nj nk b">Sky</code>的新项目，也就是我们今天所知的<code class="fe nh ni nj nk b">Flutter</code>库。</p><p id="4464" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Sky的最初几天，团队从Blink中删除了数千行代码。因为他们没有任何使用Sky框架的客户，所以他们能够快速应用突破性的变化。然而，他们过于依赖Javascript，无法从与Javascript相关的Chromium团队获得对他们请求的响应。他们开始寻找新的语言，并得到了Dart团队的支持。这对双方来说是一个双赢的案例，最终，Dart的使用在采用Flutter后蓬勃发展。</p><p id="4982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该团队发现了一种使用SkyShell在Android中运行Dart代码的方法。SkyShell是一个通用的应用程序，可以通过网络加载天空应用程序。独立的SkyShell.apk用于测试，增加了Google内部团队对Sky项目的兴趣。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7db1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2015年，天空项目规模迅速扩大。通过与Dart团队合作，他们能够为iOS编译应用程序，支持离线模式，从框架中移除天空元素(DOM)，并引入小部件树和渲染树。</p><p id="e7c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，该团队决定将该项目重命名为Flutter，这只是谷歌收购的一个随机可用的域名。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nl"><img src="../Images/2085a9ea2d6343f02303c92ab9ccec9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GekoKDvAwFPHjUWQ"/></div></div></figure><h1 id="3681" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">什么是本土？</h1><p id="75f8" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">什么使一个应用成为本地的是一个有争议的问题。一个Flutter应用可以被认为是原生应用吗？Adam Barth说是的，因为Flutter应用程序中的小部件是用最终开发者用来构建他们的应用程序的相同技术构建的。对于移动和桌面，Flutter应用程序源代码被编译为机器代码，并由输出文件附带的Dart虚拟机或Dart运行时执行，处理内存分配和垃圾收集。</p><blockquote class="nm"><p id="fb7c" class="nn no iq bd np nq nr ns nt nu nv kk dk translated">“Flutter应用程序被直接编译成机器代码，无论是英特尔x64还是ARM指令，如果面向web，则编译成JavaScript。”[6]</p></blockquote><p id="2fae" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">在Android原生开发中，整个源代码首先被编译成字节码。<a class="ae kl" href="https://source.android.com/devices/tech/dalvik" rel="noopener ugc nofollow" target="_blank"> Android Runtime (ART) </a>在安装时执行字节码到机器码的翻译，以便设备理解本机指令。机器代码由设备的运行时环境执行[14]。</p><p id="6e55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在iOS原生开发中，<a class="ae kl" href="https://medium.com/@jyaunches/introduction-to-the-llvm-for-a-ios-engineer-8c00ed0f9ff0" rel="noopener"> LLVM </a>负责将源代码编译成机器码。源代码首先被编译成中间语言(IR)。然后，LLVM后端为目标设备[ <a class="ae kl" href="https://medium.com/@jyaunches/introduction-to-the-llvm-for-a-ios-engineer-8c00ed0f9ff0" rel="noopener"> 11 </a> ]生成机器代码。</p><p id="4b63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当开发“本地”应用程序时，我们使用平台UI库提供的库在屏幕上绘制UI组件。例如，您添加到应用程序中的按钮可能看起来不同，这取决于安装应用程序的设备的Android API版本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ob"><img src="../Images/fe464e69f5bb1d3f464d5be391777900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JQq9Vcn8cGzoofvZCEl6Q.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">对话框的外观取决于平台API</p></figure><p id="8605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">平台UI库是平台渲染API的桥梁，如<a class="ae kl" href="https://www.opengl.org/" rel="noopener ugc nofollow" target="_blank"> OpenGL </a>、<a class="ae kl" href="https://developer.apple.com/metal/" rel="noopener ugc nofollow" target="_blank"> Metal </a>、<a class="ae kl" href="https://www.vulkan.org/" rel="noopener ugc nofollow" target="_blank"> Vulkan </a>。由于可移植性和安全性(内存错误)的原因，这些UI库是用特定于平台的高级语言实现的，例如Java、Swift、Objective-C。它们与设备CPU或GPU通信，在屏幕上绘制像素。</p><p id="1fb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们从较低级到OS层时，几乎不可能使用高级语言，因为它们的特性会导致内存错误。在iOS和Android操作系统中，下层是用C实现的，C++。最近，Android也在Rust中开始支持开发原生操作系统组件。[ <a class="ae kl" href="https://security.googleblog.com/2021/04/rust-in-android-platform.html" rel="noopener ugc nofollow" target="_blank"> 10 </a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6d62412d2b71ae061f3909b7007d8ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/0*NbWy6QXy0A2E8KLE.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">摘自[ <a class="ae kl" href="https://security.googleblog.com/2021/04/rust-in-android-platform.html" rel="noopener ugc nofollow" target="_blank"> 10 </a></p></figure><p id="122e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Android平台提供的<a class="ae kl" href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/widget/" rel="noopener ugc nofollow" target="_blank"> <em class="od"> widget </em> </a>文件夹是构建在<a class="ae kl" href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/" rel="noopener ugc nofollow" target="_blank"> <em class="od">视图</em> </a>文件夹之上的一层。当从这个文件夹中选择一个小部件时，原生Android开发者应该总是考虑他们的应用支持的最低Android API版本。考虑到Android设备获得新的API更新有多晚，这对开发者来说可能是一个严重的问题。这个问题是通过在应用程序包中包含<a class="ae kl" href="https://developer.android.com/jetpack/androidx" rel="noopener ugc nofollow" target="_blank"> Android Jetpack库</a>(以前称为支持库)来解决的，以便在具有不同Android版本的设备之间提供向后兼容性。[ <a class="ae kl" href="https://developer.android.com/jetpack/androidx" rel="noopener ugc nofollow" target="_blank"> 7 </a></p><h1 id="3692" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">颤振与其他</h1><p id="717e" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">传统的跨平台框架是OEM小部件或Web视图的包装器。在前一种情况下，开发人员在抽象层的帮助下使用原生UI组件构建应用程序。比如React原生开发者用JavaScript写代码。</p><p id="09d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React Native的桥接系统用于提供本机端和Javascript线程之间的双向异步通信。这是一个高级语言和许多高级语言之间的翻译过程。由于UI逻辑通过抽象层从一个地方到另一个地方，因此可能会出现意外的性能问题。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oe"><img src="../Images/184a11b18f5a7ffdbd555db70aaeca39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNqZP5JcO3zsuc40WGS0Cg.png"/></div></div></figure><p id="7218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flutter采用了不同于其他跨平台技术的方法。UI使用自己的库而不是平台UI库显示在屏幕上，这消除了一个抽象级别。</p><p id="5ae5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设备GPU与应用程序附带的图形库一起使用。这使得Flutter能够根据设备的能力提供每秒60帧或120帧(fps)的性能。Flutter UI工具包本身并不能保证这种性能。它只提供了有效的算法来防止部件树中某些部件上不必要的构建、布局和绘制阶段。每当设备调用有一个要渲染的帧时，Flutter就会接受这个调用，并从构建阶段开始渲染过程。毕竟，性能取决于目标设备的刷新率，以及应用程序代码实现的效率，以便能够在构建阶段快速响应[12]。</p><p id="0e69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flutter的框架层通过直接与引擎层中的<a class="ae kl" href="https://skia.org/" rel="noopener ugc nofollow" target="_blank"> Skia </a>通信来绕过平台UI库，引擎层为GPU提供指令。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi of"><img src="../Images/ee76d10acda0251893e2c4679e27d3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPeoZr6v40kOq72aywb9dg.png"/></div></div></figure><p id="edb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">取代<em class="od">原生</em> UI组件，Flutter应用使用了包含在Flutter SDK中的<em class="od">原生</em> UI组件。由于这种方法，Flutter应用程序中使用的小部件的质量和灵活性独立于底层平台提供的内置解决方案。</p><p id="26c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发者可以根据谷歌的<a class="ae kl" href="https://material.io/design" rel="noopener ugc nofollow" target="_blank">材料设计</a>、苹果的<a class="ae kl" href="https://developer.apple.com/design/" rel="noopener ugc nofollow" target="_blank">人机界面指南</a>和微软的<a class="ae kl" href="https://docs.microsoft.com/en-us/windows/apps/design/" rel="noopener ugc nofollow" target="_blank"> Fluent设计系统</a>的规范，使用<a class="ae kl" href="https://docs.flutter.dev/development/ui/widgets/material" rel="noopener ugc nofollow" target="_blank">素材库</a>、<a class="ae kl" href="https://docs.flutter.dev/development/ui/widgets/cupertino" rel="noopener ugc nofollow" target="_blank">库比蒂诺库</a>或<a class="ae kl" href="https://pub.dev/packages/fluent_ui" rel="noopener ugc nofollow" target="_blank"> fluent_ui包</a>中的小部件。或者，开发者也可以在<a class="ae kl" href="https://docs.flutter.dev/development/ui/widgets" rel="noopener ugc nofollow" target="_blank"> widgets </a>库的基础上，根据他们自己的设计语言创建他们自己的widgets集合。</p><h1 id="1299" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">图层模型</strong></h1><p id="711a" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">Flutter有一个分层的架构，其中所有层都是独立的、可替换的，并且每个层都依赖于下面的层。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi og"><img src="../Images/cd728e4fdd399bfdbf351795fd73b01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UBcnPVgeU3xgNY19"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">颤动的建筑层</p></figure><p id="ec8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将Navigator 2.0实现作为这种分层架构模型的一个例子。平台提供了在屏幕间导航的方式。移动平台利用手势，浏览器有后退和前进按钮，一些Android手机有系统后退按钮，人们对它应该如何工作有不同的想法。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oh mu l"/></div></figure><p id="11dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据分层模型，在框架层的widgets库中提供了一个通用导航API，而不需要知道app使用在哪个平台上。特定于平台的实现细节包含在引擎层中。</p><p id="e154" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从框架层的内容开始。<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>是由<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件管理的条目。<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件包装<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>小部件并配置导航历史。这些类是在框架层的<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/widgets/widgets-library.html" rel="noopener ugc nofollow" target="_blank">widgets</a></code>库中实现的。</p><p id="f586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/cupertino/CupertinoPageRoute-class.html" rel="noopener ugc nofollow" target="_blank">CupertinoPageRoute</a></code>和<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/material/MaterialPageRoute-class.html" rel="noopener ugc nofollow" target="_blank">MaterialPageRoute</a></code>类是<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/widgets/Route-class.html" rel="noopener ugc nofollow" target="_blank">Route</a></code>类的两个具体实现，它们都用来用一个过渡替换整个屏幕。前者是<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/cupertino/cupertino-library.html" rel="noopener ugc nofollow" target="_blank">cupertino</a></code>库的一部分，并提供iOS风格的过渡，而后者是<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/material/material-library.html" rel="noopener ugc nofollow" target="_blank">material</a></code>库的一部分，并根据<a class="ae kl" href="https://material.io/design" rel="noopener ugc nofollow" target="_blank">材料设计</a>中的规范提供平台自适应的过渡。这些库构建在框架层的小部件库之上。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oi"><img src="../Images/8ec70feaf333b1b7543622a8627e9788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSpH65iun8fg1HhUxQarFA.png"/></div></div></figure><p id="5f3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nh ni nj nk b"><a class="ae kl" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener">RouteInformation</a></code>是包含路线信息的数据容器，在框架层内部使用。<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件<a class="ae kl" href="https://api.flutter.dev/flutter/services/SystemNavigator/routeInformationUpdated.html" rel="noopener ugc nofollow" target="_blank">监听</a>来自在<em class="od">引擎</em>层中实现的平台通道的路由更新。</p><p id="6b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当有来自引擎的路由更新时，<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件实例化一个将在框架层中使用的<code class="fe nh ni nj nk b"><a class="ae kl" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener">RouteInformation</a></code>。同样，由于应用程序中的用户交互，底层平台可能需要了解导航更新。例如，在Flutter Web应用程序中，当内容由于按钮按下而改变时，浏览器地址栏可能需要更新。在这种情况下，<em class="od">引擎</em>从<code class="fe nh ni nj nk b"><a class="ae kl" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件创建的<code class="fe nh ni nj nk b"><a class="ae kl" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener">RouteInformation</a></code>中获取必要的信息，并相应地更新其<code class="fe nh ni nj nk b"><a class="ae kl" href="https://github.com/flutter/engine/blob/99fa4a1ab34317c40b03d2aaf9c0b172c684a871/lib/web_ui/lib/src/engine/navigation/history.dart" rel="noopener ugc nofollow" target="_blank">BrowserHistory</a></code>。</p><p id="be57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，框架层依靠引擎层来构建导航历史。然而，它不需要知道底层平台的细节。例如，按下浏览器中的后退/前进按钮，以及从移动操作系统接收一个<a class="ae kl" href="https://developer.android.com/reference/android/content/Intent" rel="noopener ugc nofollow" target="_blank">意图</a>，在引擎层有不同的实现，但最终，输出将是一个<code class="fe nh ni nj nk b"><a class="ae kl" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener">RouteInformation</a></code>用于框架层。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d2932fd8a70d8168108b21c881d587f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwXT1-SrcJ_h9KgCp4Q_lQ.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/655c32a5b75d7d3610916ee946c26cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmILz78ZP3oASE1K2KR5Wg.png"/></div></div></figure><p id="9a6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于Navigator 2.0 API的更多信息可以从我之前的文章系列中阅读。</p><h1 id="aba0" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">发动机</h1><p id="f092" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">Flutter引擎层是用C、C++、Java、Objective-C和Dart语言构建的。该架构中用C++编写的两个主要部分是2D图形库和文本渲染。将这些部分保留在C++中的主要原因是，这些解决方案已经在Skia for 2D图形和Android开源项目(<a class="ae kl" href="https://source.android.com/" rel="noopener ugc nofollow" target="_blank"> AOSP </a>)的文本渲染库中使用了多年。这意味着Android的文本渲染解决方案被移植到iOS应用[ <a class="ae kl" href="https://www.dotnetrocks.com/default.aspx?ShowNum=1513" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]。</p><p id="2248" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Skia是由Google维护的开源图形渲染库。虽然Flutter是一项年轻的技术，但Skia自2005年以来就已经存在，并被许多平台使用，包括Google Chrome、Chrome OS、Android、Mozilla Firefox等等。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oj"><img src="../Images/a280e58eb1c18ae81f380464b0a76e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_Gm4rOFlAf653oiYvi2dg.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">颤振发动机(摘自[13])</p></figure><p id="fad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flutter中的Skia支持各种特定于平台的后端，为设备中可用的GPU生成指令。比如iOS设备的<a class="ae kl" href="https://developer.apple.com/metal/" rel="noopener ugc nofollow" target="_blank"> Metal </a>用<a class="ae kl" href="https://medium.com/flutter/announcing-flutter-1-17-4182d8af7f8e" rel="noopener">版本1.17 </a>引入了颤振引擎。</p><blockquote class="ok ol om"><p id="3c6f" class="jn jo od jp b jq jr js jt ju jv jw jx on jz ka kb oo kd ke kf op kh ki kj kk ij bi translated">“苹果在iOS上对Metal的支持提供了对底层GPU的近乎直接的访问，是苹果推荐的图形API。在完全支持Metal的iOS设备上，Flutter现在默认使用它，使你的Flutter应用程序在大多数时候运行得更快，平均提高<a class="ae kl" href="https://github.com/flutter/flutter/issues/53768" rel="noopener ugc nofollow" target="_blank">渲染速度约50%</a>(取决于你的工作负载)。”8 </p></blockquote><p id="1b65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建和维护自定义引擎层是一项复杂的任务。虽然颤振团队明确表示，他们不反对定制发动机，但他们警告说，由于维护成本可能存在风险。Flutter团队不认为定制引擎层是一个长期的解决方案，应该尽快避免，特别是如果目标平台的层已经由Flutter现成提供的话。[ <a class="ae kl" href="https://github.com/flutter/flutter/wiki/Custom-Flutter-Engine-Embedders" rel="noopener ugc nofollow" target="_blank"> 9 </a></p><h2 id="9d67" class="mv lr iq bd ls mw mx dn lw my mz dp ma jy na nb me kc nc nd mi kg ne nf mm ng bi translated">AOT Vs JIT编译</h2><p id="4980" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">Flutter应用程序的发布版本中的Dart代码直接编译为本机、ARM和x86库，或者在面向web时编译为Javascript代码。这种编译过程被称为提前编译(AOT)。</p><p id="649d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flutter的调试版本是实时编译的(JIT ),并与Dart虚拟机(VM)一起发布。这使得能够向正在运行的VM注入新的类、方法和字段。热重装就是这个注入的过程，同时使用app的最后一个状态[2]。</p><p id="c52a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如第一篇文章提到的，Flutter应用开发者的职责是用widget树描述UI的状态，框架的职责是用元素树中自顶向下的元素的<code class="fe nh ni nj nk b"><a class="ae kl" href="https://medium.com/r?url=https%3A%2F%2Fapi.flutter.dev%2Fflutter%2Fwidgets%2FElement%2FupdateChild.html" rel="noopener">updateChild</a></code>方法更新状态。</p><p id="99a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，对于开发者来说，一切都是小部件，框架提供了“<em class="od">精心设计的算法和数据结构来高效处理大量的小部件”</em> [ <a class="ae kl" href="https://docs.flutter.dev/resources/inside-flutter#a1" rel="noopener ugc nofollow" target="_blank"> 4 </a> ] <em class="od">。</em>由于这种关注点的分离，框架能够通过热重载在运行的应用程序中立即反映窗口小部件树中的变化。</p><p id="afc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">热重新加载可以被认为是在Web浏览器中编辑CSS。尽管到目前为止，Flutter Web应用程序仍然不支持hot reload，但由于Flutter [ <a class="ae kl" href="https://www.dotnetrocks.com/default.aspx?ShowNum=1513" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]中包含的声明性范例，它在其他平台上工作得足够好了。我建议看下面的短片，它解释了热重装是如何工作的，以及在什么情况下需要热重启。感谢安德鲁·菲茨的精彩视频和精彩的视觉解释。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="1982" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">嵌入器</h1><blockquote class="nm"><p id="ae09" class="nn no iq bd np nq nr ns nt nu nv kk dk translated">"对于底层操作系统，Flutter应用程序的打包方式与任何其他本地应用程序一样."[ <a class="ae kl" href="https://docs.flutter.dev/resources/faq" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]</p></blockquote><p id="ebe6" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">当我们创建一个新的Flutter项目时，不同平台的嵌入层由Flutter提供。嵌入层使用引擎层作为库。它是一个颤振应用程序启动时的起点。它是用特定于平台的语言编写的，托管着Flutter引擎。</p><p id="1fb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Embedder支持与底层操作系统的通信，为UI获取线程，并提供纹理。嵌入者的职责是生命周期管理、输入手势、窗口大小和平台消息[ <a class="ae kl" href="https://docs.flutter.dev/resources/architectural-overview" rel="noopener ugc nofollow" target="_blank"> 6 </a> ]。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/fa7786496768bb61f17017099900d90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtWV3Gg2u2_4rheMPbDBAw.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">底层平台的入口点</p></figure><p id="949e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在稳定频道中，我们看到熟悉的文件夹名称，如<code class="fe nh ni nj nk b">android</code>、<code class="fe nh ni nj nk b">ios</code>、<code class="fe nh ni nj nk b">web</code>、<code class="fe nh ni nj nk b">windows</code>。这些是嵌入层的文件夹。如果我们想为特定的平台添加嵌入器，我们应该使用命令:<code class="fe nh ni nj nk b">flutter create --platforms<strong class="jp ir">=</strong>windows,macos,linux</code>显式地指定它们。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d7b86a0e9423b729c9f7f47945a3a6d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aw43Ix_zOxcum9Wv"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">Windows的颤振体系结构</p></figure><p id="ca3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嵌入式层包含在Flutter SDK中，但不必局限于这些常用的平台。由于Flutter架构层是可替换的，特定于平台的定制嵌入器可以集成到其余的层中。我们看到由索尼领导的用于嵌入式Linux设备的<code class="fe nh ni nj nk b"><a class="ae kl" href="https://github.com/sony/flutter-embedded-linux" rel="noopener ugc nofollow" target="_blank">flutter-elinux</a></code>项目，以及用于将Flutter移植到装有Tizen OS的设备的<code class="fe nh ni nj nk b"><a class="ae kl" href="https://github.com/flutter-tizen/flutter-tizen#flutter-for-tizen" rel="noopener ugc nofollow" target="_blank">flutter-tizen</a></code>项目。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oq"><img src="../Images/1a024d5207d825781cc3897c3d9741e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*da87rAfVpNkO11V7.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">为嵌入式Linux (eLinux)而战——<a class="ae kl" href="https://github.com/sony/flutter-embedded-linux" rel="noopener ugc nofollow" target="_blank">索尼</a></p></figure><p id="db46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Web应用程序被沙箱化在Web浏览器应用程序中。因此，Flutter Web架构不包括提供与底层操作系统通信的嵌入器。例如，我们不能将<code class="fe nh ni nj nk b"><a class="ae kl" href="https://flutter.dev/docs/development/platform-integration/web#can-i-use-dartio-with-a-web-app" rel="noopener ugc nofollow" target="_blank">dart.io</a></code>库导入到Flutter Web项目。由于其他平台的引擎层包含与底层操作系统接口的逻辑，因此Flutter Web应用程序的<strong class="jp ir"> <em class="od">引擎</em> </strong>是标准浏览器API之上的C++ Flutter引擎的重新实现。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oi"><img src="../Images/02f48a6b0b02695215624238ca4b326b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OwJdGa4ChvIiJz9-.png"/></div></div></figure><h1 id="d400" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="d834" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在本文中，我们解释了Flutter的像素驱动架构，而不是依赖于平台小部件。我们提到了Flutter如何通过自己的渲染引擎库消除了一个抽象层次。</p><p id="330b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://ulusoyca.medium.com/why-is-flutter-fast-part-3-rendering-pipeline-3a31056355e5" rel="noopener">下篇</a>中，我们将继续回答“为什么Flutter快？”通过解释颤振的简单渲染管道。</p><h1 id="462b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="3b48" class="lc ld iq jp b jq mo ju mp jy or kc os kg ot kk ou li lj lk bi translated">与蒂姆·斯内思和亚当·巴思一起跳舞。网石！播客</li><li id="a679" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated">常见问题，<a class="ae kl" href="https://docs.flutter.dev/resources/faq" rel="noopener ugc nofollow" target="_blank"> docs.flutter.dev </a></li><li id="dd9c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://developer.android.com/reference/android/view/View" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/reference/android/view/View</a></li><li id="3cba" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://docs.flutter.dev/resources/inside-flutter#a1" rel="noopener ugc nofollow" target="_blank">内部颤动</a></li><li id="b35b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://medium.com/kinandcartacreated/flutter-the-skys-the-limit-84887c8f650d" rel="noopener">飘起——前途无量</a>，<a class="ae kl" href="https://medium.com/@swav.kulinski?source=post_page-----84887c8f650d-----------------------------------" rel="noopener">斯瓦夫·库林斯基</a></li><li id="b0ac" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://docs.flutter.dev/resources/architectural-overview" rel="noopener ugc nofollow" target="_blank">颤振建筑概述</a></li><li id="20af" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated">AndroidX概述，<a class="ae kl" href="https://developer.android.com/jetpack/androidx" rel="noopener ugc nofollow" target="_blank">developer.android.com</a></li><li id="7e44" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://medium.com/flutter/announcing-flutter-1-17-4182d8af7f8e" rel="noopener">宣布颤振1.17 </a></li><li id="52da" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://github.com/flutter/flutter/wiki/Custom-Flutter-Engine-Embedders" rel="noopener ugc nofollow" target="_blank">定制颤振发动机嵌入器</a></li><li id="2e78" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://security.googleblog.com/2021/04/rust-in-android-platform.html" rel="noopener ugc nofollow" target="_blank">安卓平台中的铁锈</a></li><li id="3ce0" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://medium.com/@jyaunches/introduction-to-the-llvm-for-a-ios-engineer-8c00ed0f9ff0" rel="noopener">面向iOS开发者的LLVM简介</a></li><li id="c312" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated">软件工程广播，第437集:颤动的架构</li><li id="b84b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://www.youtube.com/watch?v=VUiVkDpikDI&amp;ab_channel=StrangeLoopConference" rel="noopener ugc nofollow" target="_blank">“颤动:我们如何在谷歌构建未来的UI框架”作者Eric Seidel </a></li><li id="4ad8" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://medium.com/@yuvraazkhattri/advance-android-android-bytecode-compilation-jvm-dvm-art-dex-apk-arm-arm4-x86-bbf7de997dca" rel="noopener">进阶Android : Android字节码编译构建流程+(JVM，DVM，ART，.德克斯，。APK) </a></li><li id="5f23" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://www.youtube.com/watch?v=xqGAC5QCYuQ&amp;ab_channel=RubberDuckEng" rel="noopener ugc nofollow" target="_blank">扑之前，橡皮鸭工程|第100集</a></li><li id="40b0" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://www.wired.com/2013/04/blink/" rel="noopener ugc nofollow" target="_blank">谷歌Chrome与苹果的WebKit分手</a></li><li id="3074" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk ou li lj lk bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Blink_(browser_engine)" rel="noopener ugc nofollow" target="_blank">眨眼，维基百科</a></li></ol></div></div>    
</body>
</html>