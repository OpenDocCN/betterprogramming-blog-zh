<html>
<head>
<title>How to Remove Sensitive Data and Plaintext Secrets From GitHub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从GitHub中删除敏感数据和明文秘密</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-remove-sensitive-data-and-plaintext-secrets-from-github-ca8ca0b7675a?source=collection_archive---------10-----------------------#2022-07-26">https://betterprogramming.pub/how-to-remove-sensitive-data-and-plaintext-secrets-from-github-ca8ca0b7675a?source=collection_archive---------10-----------------------#2022-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3116" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">保持你的存储库干净，以避免被黑客攻击</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c48d4b1efc9bc25a894b4576e4641685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*piaBkjRfTAbmZpsL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@stillnes_in_motion?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">静止不动</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">不飞溅</a>上拍摄</p></figure><p id="db8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些开发人员爱快速编码，爱偷工减料，我也为之心虚！这意味着敏感数据(例如，明文秘密、应用程序编程接口[API]密钥、密码等。)可能会意外地提交到您的git存储库中。如果您在本地开发，这可能没问题，但是当使用GitHub这样的托管服务时，这可能是个问题。</p><p id="087c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读<a class="ae ky" href="https://www.secjuice.com/secjuice-squeeze-vol-7-infosec-news/" rel="noopener ugc nofollow" target="_blank"> Secjuice Squeeze Volume 7 </a>，其中包含一个关于在GitHub上发现星巴克API密钥的故事。</p><h1 id="8159" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">背景</h1><p id="ee0c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我在几个git存储库上工作，其中大部分都提交了敏感数据。他们有API密匙，AWS密匙，密码，你能想到的！作为一名安全工程师，我想补救这一点。看起来工作量很大。有多个存储库，但他们有这些“肮脏”的提交可以追溯到几年前。我将分享我是如何通过移除秘密来清理脏提交的。</p><h1 id="5866" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">来自GitHub帮助的指导</h1><p id="b02a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我使用了GitHub的官方文档来开始。我通读了一遍，似乎很简单。我只需要使用<a class="ae ky" href="https://rtyley.github.io/bfg-repo-cleaner/" rel="noopener ugc nofollow" target="_blank"> BFG回购清理器</a>，并要求开发人员删除存储库并再次克隆它。小菜一碟！至少我是这么认为的。</p><p id="4a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://help.github.com/en/articles/removing-sensitive-data-from-a-repository" rel="noopener ugc nofollow" target="_blank">https://help . github . com/en/articles/remove-sensitive-data-from-a-repository</a></p><h1 id="cb60" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用BFG回购清洁剂</h1><p id="5af3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">BFG Repo-Cleaner是一个Java程序，它利用git过滤器分支来修改现有的提交并替换内容。Git过滤器分支是一个相当繁琐的过程(参见上面的GitHub帮助文档)，所以我很高兴BFG简化了它。</p><p id="cb66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我用来清理提交的过程。</p><p id="c054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)我将Java应用程序下载到我的<code class="fe ms mt mu mv b">~/Downloads</code>文件夹中。</p><p id="371b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)我创建了一个<code class="fe ms mt mu mv b">~/Documents/bfg-secrets-all.txt</code>文件。我确保将它放在我的git存储库之外，以避免不小心犯下它，从而违背这个练习的目的！</p><p id="ebed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为每个我想清除的秘密添加了一行。每行必须以<code class="fe ms mt mu mv b">regex:</code>或<code class="fe ms mt mu mv b">glob:</code>开头，为了简单和熟悉，我决定使用正则表达式。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="7403" class="na lw it mv b gy nb nc l nd ne">regex:8cea3229-09cd-4b89-9dce-f0f9b0697406<br/>regex:815e9bc4-d795-4961-ab8b-50ddf8a391fe</span></pre><p id="fc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我搜索了特定的秘密，但是我可以使用实际的正则表达式。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="68ba" class="na lw it mv b gy nb nc l nd ne">regex:\w{8}-\w{4}-\w{4}-\w{4}-\w{12}</span></pre><p id="a434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)我煞费苦心地从每个存储库中删除了所有的秘密。我利用<a class="ae ky" href="https://medium.com/the-node-js-collection/making-your-node-js-work-everywhere-with-environment-variables-2da8cdf6e786" rel="noopener">环境变量</a>、<a class="ae ky" href="https://aws.amazon.com/kms/" rel="noopener ugc nofollow" target="_blank"> AWS密钥管理服务</a>和<a class="ae ky" href="https://linux-audit.com/linux-history-how-dot-files-became-hidden-files/" rel="noopener ugc nofollow" target="_blank">点文件</a>将敏感数据移出提交的文件。</p><p id="000b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4)我转到GitHub存储库设置中的分支保护规则，并启用强制推送。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/299d04cf28bbccc99ed8a47949835374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IgmlTcmC5txVwI7F.png"/></div></div></figure><p id="69d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5)我运行了以下命令来检查脏提交。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="87c7" class="na lw it mv b gy nb nc l nd ne">java -jar ~/Downloads/bfg-1.13.0.jar --replace-text ~/Documents/bfg-secrets-all.txt</span></pre><p id="33a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它要么说没有脏提交，要么打印出一个脏提交列表。请参见清理后的示例输出。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="32c6" class="na lw it mv b gy nb nc l nd ne">Commit Tree-Dirt History<br/>------------------------</span><span id="eba9" class="na lw it mv b gy ng nc l nd ne">    Earliest                                              Latest<br/>    |                                                          |<br/>    ..DDDDDDDDDDDDDDDDDDDDDDDDDDDDmmDmmDDDDmDDDDDDmmmmmmmmmmmmDD</span><span id="0c6c" class="na lw it mv b gy ng nc l nd ne">    D = dirty commits (file tree fixed)<br/>    m = modified commits (commit message or parents changed)<br/>    . = clean commits (no changes to file tree)</span><span id="24df" class="na lw it mv b gy ng nc l nd ne">                            Before     After   <br/>    -------------------------------------------<br/>    First modified commit | 06f9e3e4 | cc990b18<br/>    Last dirty commit     | e587f82e | f7ded7dc</span></pre><p id="9884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6)然后我把所有的改动都推上去了。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ee6f" class="na lw it mv b gy nb nc l nd ne">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive<br/>git push origin --force --all<br/>git push origin --force --tags</span></pre><p id="c08c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7)要求开发人员删除存储库并再次克隆它。</p><p id="d36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">8)我访问了GitHub上的存储库，确保提交看起来像这样:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6784" class="na lw it mv b gy nb nc l nd ne">- apiKey = 'placeholder';<br/>+ apiKey = '8cea3229-09cd-4b89-9dce-f0f9b0697406';</span></pre><p id="b5d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在它看起来像这样:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="cbe9" class="na lw it mv b gy nb nc l nd ne">- apiKey = 'placeholder';<br/>+ apikey = '***REMOVED***';</span></pre><p id="b657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">9)我庆祝是因为我以为我完成了。</p><h1 id="8393" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从所有分支中删除敏感数据</h1><p id="d545" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">过了一会儿，我转到了一个不同的、过时的分支。我碰巧在提交历史中看到了一个明文形式的API密钥。BFG回购清洁工说，它清除了提交历史！</p><p id="e3a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我意识到BFG Repo-Cleaner只清理签出的git分支。有道理。这与整个git工作流是一致的。</p><p id="f52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不得不为每个分支重复BFG过程，并要求开发人员删除他们的存储库并再次克隆它们。</p><p id="34c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至少现在所有的树枝都被清理干净了。我的担心现在已经过去了。</p><h1 id="21b6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从GitHub Pull请求中删除敏感数据</h1><p id="2d30" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我访问了一个旧的pull请求(PR ),在提交历史中看到了一个明文形式的API键。又来了！我用BFG回购清洁剂清洁了每一根树枝。这是怎么回事？！忽悠我一次；你真可耻。忽悠我两次；我感到羞耻。</p><p id="1e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原来GitHub PRs是独立于git库的。这似乎是显而易见的，因为PR是一个外部文档，允许评审者批准一个分支是否应该合并到另一个分支。当PR被批准和合并时，GitHub执行git合并功能。</p><p id="c74b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BFG Repo-Cleaner是为git库而不是GitHub pull请求设计的。因此，我需要手动删除所有这些PRs及其提交。</p><p id="7064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二次PR和40次提交之后，我意识到手动检查数百个PR和数千个提交的秘密是困难的，并且容易出现人为错误。</p><p id="7b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定我需要一个自动的方法来找到所有的PRs和有脏提交的提交。我决定使用<a class="ae ky" href="https://developer.github.com/v3/" rel="noopener ugc nofollow" target="_blank"> GitHub API </a>。</p><p id="83ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于版权原因，我不能分享我写的剧本。我正在描述我用来构建脚本的思维过程。</p><p id="70fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)我创建了一个<a class="ae ky" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank">个人访问令牌</a>。</p><p id="d417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)我创建了一个Node.js脚本来测试token。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="253c" class="na lw it mv b gy nb nc l nd ne">mkdir myscript<br/>npm init -y<br/>npm install github-api<br/>touch index.js</span><span id="980b" class="na lw it mv b gy ng nc l nd ne">/* index.js */<br/>'use strict'<br/>const GitHub = require('github-api');<br/>const gh = new GitHub({ token });</span></pre><p id="1ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)我用GitHub组织所有的库。我更新了脚本以获取所有的存储库。该脚本列出了所有的存储库。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f5fa" class="na lw it mv b gy nb nc l nd ne">gh.getOrganization(orgName);<br/>const repos = org.getRepos();<br/>console.log(repos);</span></pre><p id="7f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4)我选择了一个存储库。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="1773" class="na lw it mv b gy nb nc l nd ne">const repo = gh.getRepo(repos[0].owner.login, repos[0].name);</span></pre><p id="e55e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5)我获得了它所有的pr。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0cb7" class="na lw it mv b gy nb nc l nd ne">const prs = repo.listPullRequests(options);</span></pre><p id="775c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6)我选了一个PR。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ea00" class="na lw it mv b gy nb nc l nd ne">const pr = prs[0];</span></pre><p id="64db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7)我获得了在PR中创建、修改和删除的所有文件。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2898" class="na lw it mv b gy nb nc l nd ne">const files = repo.listPullRequestFiles(repo, pr.number);</span></pre><p id="84a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">8)我看了前面用的<code class="fe ms mt mu mv b">bfg-secrets-all.txt</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">9)我使用之前使用的<code class="fe ms mt mu mv b">bfg-secrets-all.txt</code>文件搜索了每个文件中的差异，并创建了一个CSV输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">10)我将更新代码以遍历每个存储库、PRs和文件。</p><p id="0dcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">11)我联系了<a class="ae ky" href="https://support.github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub支持</a>删除整个PR或跟踪引用，您也可以使用GitHub API获取该信息(参见下面的示例脚本)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="be44" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">再次检查仓库</h1><p id="6a29" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在清理完存储库后，我等了几个星期，再次在存储库上运行了BFG回购清除器。我发现一些存储库又有敏感数据了。我了解到一个开发人员忘记删除存储库，并使用未清理的存储库进行提交。</p><p id="34a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一段时间后检查存储库以确保它们是干净的是一个好主意。</p><h1 id="9cec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">阻止开发人员提交</h1><p id="1f9d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这似乎是一场永无止境的战斗:我清理，一个开发人员不小心犯了一个秘密，我偶然发现它，我再次清理，循环重复。我首先想要一个过程来帮助防止这种情况。</p><p id="144f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定在提交之前使用git钩子来检查提交。我决定检查预提交git挂钩。</p><p id="e641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)我创建了一个可执行的预提交脚本。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="96a8" class="na lw it mv b gy nb nc l nd ne">touch .git/hooks/pre-commit<br/>chmod +x .git/hoooks/pre-commit</span><span id="803e" class="na lw it mv b gy ng nc l nd ne"># pre-commit<br/>#!/bin/sh</span><span id="6d02" class="na lw it mv b gy ng nc l nd ne">if $(grep -rqE "\w{8}-\w{4}-\w{4}-\w{4}-\w{12}"  *) ; then<br/>  echo 'Found a matching secret'<br/>  exit 1<br/>fi</span></pre><p id="afae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)我用一个秘密创建了一个文件来测试它。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9855" class="na lw it mv b gy nb nc l nd ne">echo 8cea3229-09cd-4b89-9dce-f0f9b0697406 &gt; secres.txt<br/>git commit -a -m 'Testing'</span></pre><p id="0051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我得到了下面的输出，文件没有被提交。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d8bb" class="na lw it mv b gy nb nc l nd ne">Found a matching secret</span></pre><p id="0ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)我需要一种方法来创建存储库的这一部分。目前，它只能在我的机器上运行。我利用了每个存储库用于一个Node.js项目。我添加了一个安装后脚本，以确保git hook脚本可以在每个开发人员的机器上工作。</p><p id="80d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更新了<code class="fe ms mt mu mv b">package.json</code>文件。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4b7b" class="na lw it mv b gy nb nc l nd ne">{<br/>  "scripts": {<br/>    "postinstall": "git config core.hooksPath .githooks"<br/>  }<br/>}</span></pre><p id="b737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4)我把git hook脚本复制到一个可提交的目录，并提交它；您不能提交<code class="fe ms mt mu mv b">.git</code>目录中的文件。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d527" class="na lw it mv b gy nb nc l nd ne">mkdir .githooks<br/>mv .git/hooks/pre-commit .githooks<br/>git add .githooks/pre-commit<br/>git commit -m "Added pre-commit hook script."</span></pre><p id="4d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5)所有的开发人员都需要下载最新的代码，并在他们的机器上运行<code class="fe ms mt mu mv b">npm install</code>命令。</p><p id="e78b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6)另一种方法是允许<code class="fe ms mt mu mv b">npm install</code>将钩子复制到<code class="fe ms mt mu mv b">.git/hooks</code>目录。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8073" class="na lw it mv b gy nb nc l nd ne">{<br/>  "scripts": {<br/>    "postinstall": "cp .githooks/* .git/hooks"<br/>  }<br/>}</span></pre><h1 id="0c69" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="4df0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将敏感数据和明文秘密提交给GitHub存储库可能会削弱您的安全姿态，并且需要在事后努力清理它。</p><p id="8f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用<a class="ae ky" href="https://rtyley.github.io/bfg-repo-cleaner/" rel="noopener ugc nofollow" target="_blank"> BFG回购清理器</a>来清理你提交历史中的秘密。确保清理每个分支，强制推行更改，并在一段时间后再次运行BFG，以确保不会再次引入敏感数据。</p><p id="efbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用BFG后，您可能会在GitHull pull请求中发现敏感数据。您可以使用<a class="ae ky" href="https://developer.github.com/v3/" rel="noopener ugc nofollow" target="_blank"> GitHub API </a>来查找包含敏感数据的拉请求。将这些发现发送给<a class="ae ky" href="https://support.github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub支持</a>，并要求他们删除拉取请求或其跟踪参考。</p><p id="af23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用git预提交挂钩来帮助防止提交敏感数据。</p></div></div>    
</body>
</html>