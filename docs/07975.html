<html>
<head>
<title>Build a Reddit Clone With React and Dgraph Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React和Dgraph Cloud构建Reddit克隆</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-reddit-clone-with-react-and-slash-graphql-95bfb1c847e4?source=collection_archive---------10-----------------------#2021-03-10">https://betterprogramming.pub/build-a-reddit-clone-with-react-and-slash-graphql-95bfb1c847e4?source=collection_archive---------10-----------------------#2021-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2d52" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Readit:我为一个书虫社区制作的网络应用，用来讨论他们最喜欢的书</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b003d564a03e198bbc6c599dc325245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpMTUSdt4gTBnhAxiyVd7A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阅读1984年子编辑的子编辑页面。作者照片。</p></figure><p id="c346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">社交媒体应用程序是使用图形数据库和GraphQL APIs的完美候选。复杂数据查询和关系的组合是无穷无尽的。</p><p id="8efd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以Reddit为例。该应用程序由子编辑(或主题)组成。用户可以在这些子编辑中创建帖子，这意味着帖子和子编辑之间存在多对一的关系。每个帖子只属于一个子编辑，每个子编辑可以包含许多帖子。用户可以对帖子发表评论，这导致了帖子和评论之间的另一种多对一关系。每个评论只属于一个帖子，每个帖子可以有很多评论。用户和帖子之间以及用户和评论之间也是多对一的关系。每个评论和帖子都是由单个用户发表的，单个用户可以有许多评论和帖子。</p><p id="0853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Reddit这样的应用程序中，应用程序的每个页面都需要这些数据的不同子集。使用传统的REST API端点可能意味着开发几个独特的端点，每个端点都经过定制以满足特定用例的需求。然而，GraphQL APIs基于这样一种思想，即开发人员可以使用单个API端点来挑选任何给定页面所需的相关数据。</p><p id="3083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将强调GraphQL的灵活性，以及使用来自<a class="ae lv" href="https://dgraph.io/cloud" rel="noopener ugc nofollow" target="_blank"> Dgraph Cloud </a>的托管后端是多么容易，以便前端开发人员准确获得他们应用程序每个页面所需的数据。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="dc91" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">演示应用程序— Readit</h1><p id="22ae" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本文的其余部分，我们将使用的<a class="ae lv" href="http://tylerhawkins.info/reddit-clone/build/" rel="noopener ugc nofollow" target="_blank">演示应用</a>是Readit，它是Reddit的克隆版，但是是为图书爱好者准备的(明白吗？).该应用程序的构建使用了:</p><ul class=""><li id="09af" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><a class="ae lv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">对用户界面做出反应</a></li><li id="7303" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae lv" href="https://reactrouter.com/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React路由器</a>用于客户端路由</li><li id="cd06" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae lv" href="https://dgraph.io/cloud" rel="noopener ugc nofollow" target="_blank">用于GraphQL后端和数据库的图形云</a></li><li id="99d9" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae lv" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo客户端</a>用于方便前端和后端之间的通信</li></ul><p id="dc3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，应用程序中的基本数据类型是子编辑(“子阅读”)、帖子、评论和用户。图表可能有助于直观地突出构成我们图表的每个节点之间的关系:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e6137729dc53f03d3532e6ba0ddc8e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/0*SkGTBHt_S3vbHd6r"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">图中的节点关系</em></p></figure><p id="ab9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序包含查看主页、查看单个子阅读、查看特定帖子和查看单个用户的路径。在这里，我们看到了主页:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/acb56465526de08e7c918b016f43614c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r3fFAu0_oZ2kawzO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky"> Readit主页</em></p></figure><p id="c7a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想在家继续或者在你的机器上尝试一下，这个应用的所有<a class="ae lv" href="https://github.com/thawkin3/reddit-clone" rel="noopener ugc nofollow" target="_blank">代码都可以在GitHub </a>上找到。您也可以<a class="ae lv" href="http://tylerhawkins.info/reddit-clone/build/" rel="noopener ugc nofollow" target="_blank">在我的网站</a>上查看演示应用。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="767a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">配置Dgraph云后端</h1><p id="9823" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们已经对应用程序有了一个大致的了解，让我们开始吧。首先，我们将使用<a class="ae lv" href="https://dgraph.io/cloud" rel="noopener ugc nofollow" target="_blank">图形云</a>创建一个后端。对于那些不熟悉这项服务的人来说，Dgraph是一个为云构建的原生GraphQL图形数据库。</p><p id="3740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需稍加配置，您就可以获得一个图形数据库以及一个用于处理数据库的API端点。Dgraph的免费层非常适合学习和入门，所以我就用了这个。如果您需要让后端生产就绪，更多高级功能(如共享和专用集群)可在额外的付费层上获得。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/b140d3a1edb9bf76af997b0917495a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tfgy8ltWIgqB1pIooizpaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">配置新的Dgraph云后端</em></p></figure><p id="4822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这是一个演示应用程序，我们可以为产品类型选择Starter选项。但是，生产应用程序应该使用共享或专用实例的更高层。我把我的地区命名为“美国西部2”，因为那是离我最近的地区。我使用“reddit-clone”作为名称，但是您可以随意使用任何您喜欢的名称。</p><p id="a617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">填写完所有选项后，我们可以单击“Launch”来启动新的后端。创建后端后，我们将看到一个概述页面，其中包含新的后端API端点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/28354d69244ad5af8742aaa7ed2f078a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pt8De8a9r2yeUe-GXMX5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">新的后端API端点</em></p></figure><p id="537c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候构建一个模式了。该模式声明了我们将在应用程序中使用并存储在数据库中的各种类型的数据。我们可以直接在模式编辑器中输入模式信息，或者为了获得更好的交互体验，使用UI模式。让我们使用UI模式来创建我们的模式。GUI帮助我们配置我们的类型、它们的字段，甚至各种类型和字段之间的关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/a555c657c14995115367a4c07e7e9644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Euc2Ea9f5lYfFuURA4ZlpQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">在UI模式下创建模式</em></p></figure><p id="3742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建模式后，我们可以单击“Deploy”按钮将其正式化。如果我们现在查看Schema Editor视图，我们将看到生成的GraphQL片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="99fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，每个字段都有一个关联的类型。例如，我们创建的<code class="fe ns nt nu nv b">Comment</code>类型有一个<code class="fe ns nt nu nv b">id</code>字段，其中包含由Dgraph Cloud生成的惟一标识符。它有一个<code class="fe ns nt nu nv b">commentContent</code>字段，包含用户输入的字符串文本。它有一个<code class="fe ns nt nu nv b">voteCount</code>字段，该字段是一个整数，表示评论获得的投票数。最后，<code class="fe ns nt nu nv b">user</code>字段引用写评论的用户，而<code class="fe ns nt nu nv b">post</code>字段引用发表评论的帖子。</p><p id="04dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">评论和用户之间的关系由<code class="fe ns nt nu nv b">@hasInverse</code>指令指定，该指令告诉Dgraph Cloud】类型通过<code class="fe ns nt nu nv b">User</code>类型上的<code class="fe ns nt nu nv b">comments</code>字段链接到<code class="fe ns nt nu nv b">User</code>类型。评论和帖子的关系也是如此。</p><p id="f991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还会注意到我们的一些字段包含了<code class="fe ns nt nu nv b">@search</code>指令。这允许我们通过这些可搜索的字段来过滤我们的查询。例如，我们可以通过针对<code class="fe ns nt nu nv b">name</code>字段的特定文本字符串来过滤查询结果，从而找到特定的子编辑。当通过用户的<code class="fe ns nt nu nv b">userName</code>字段过滤用户结果时也是如此。</p><p id="e962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是用一些种子数据填充数据库，我们可以使用API Explorer来完成。在本文中，我们不会讨论填充数据所需的所有变化，但是您可以在GitHub上查看GraphQL片段。这些片段用于创建子阅读、用户、帖子和评论。</p><p id="100a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面是我用来创建几个子阅读的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="464f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">配置前端</h1><p id="68f4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们已经创建了后端，我们可以继续构建前端。我们将使用<a class="ae lv" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> </a> <code class="fe ns nt nu nv b"><a class="ae lv" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">create-react-app</a></code>生成一个框架应用程序作为起点，然后继续在此基础上构建应用程序。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="79d2" class="oa me it nv b gy ob oc l od oe">yarn create react-app reddit-clone<br/>cd reddit-clone</span></pre><p id="39b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将安装<code class="fe ns nt nu nv b">react-router-dom</code>,以便我们可以使用React Router在单页应用程序中进行客户端路由:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="548d" class="oa me it nv b gy ob oc l od oe">yarn add react-router-dom</span></pre><p id="9967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用React Router，我们可以为我们的每个页面创建路由:home、subreadit、post和user。以下是<code class="fe ns nt nu nv b">App</code>组件及其每条路线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6e26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将为<a class="ae lv" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo Client </a>安装几个包，这是一个用于使用GraphQL的JavaScript状态管理库。虽然可以使用类似于<code class="fe ns nt nu nv b">fetch</code> API的东西直接向GraphQL API端点发出请求，但是Apollo Client使这个过程更加简单。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="43bb" class="oa me it nv b gy ob oc l od oe">yarn add @apollo/client graphql</span></pre><p id="a05c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="of">注意:我们已经安装了</em> <code class="fe ns nt nu nv b"><em class="of">graphql</em></code> <em class="of">包以及</em> <code class="fe ns nt nu nv b"><em class="of">@apollo/client</em></code> <em class="of">包，尽管我们从未在代码中直接使用过</em> <code class="fe ns nt nu nv b"><em class="of">graphql</em></code> <em class="of">包。这是因为</em> <code class="fe ns nt nu nv b"><em class="of">graphql</em></code> <em class="of">是</em> <code class="fe ns nt nu nv b"><em class="of">@apollo/client</em></code> <em class="of">的</em> <code class="fe ns nt nu nv b"><em class="of">peerDependency</em></code> <em class="of">并且在内部使用以便于在JavaScript中使用GraphQL。</em></p><p id="22cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经安装了Apollo客户端，我们可以轻松地从GraphQL后端查询数据，并在React组件中使用它。我们可以首先像这样创建Apollo客户机:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以将主<code class="fe ns nt nu nv b">App</code>组件包装在<code class="fe ns nt nu nv b">index.js</code>文件的<code class="fe ns nt nu nv b">ApolloProvider</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="99ad" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">主页</h1><p id="bc7b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们已经设置好了路由，Apollo也准备好了，我们可以开始为每条路由构建页面。主页显示了热门子读物列表和热门用户列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c24920b21e2d844abc7de9607d55b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u8g4uE6CaldbX0LR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky"> Readit主页</em></p></figure><p id="bf53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以向端点查询该信息，然后使用Apollo声明性地处理<code class="fe ns nt nu nv b">loading</code>、<code class="fe ns nt nu nv b">error</code>和响应<code class="fe ns nt nu nv b">data</code>状态。<code class="fe ns nt nu nv b">HomePage</code>组件的代码全文如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c8a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在检索用户信息时，我们不需要获取用户的所有帖子和评论。我们对主页唯一感兴趣的是每个用户有多少帖子和多少评论。我们可以使用<code class="fe ns nt nu nv b">postsAggregate</code>和<code class="fe ns nt nu nv b">commentsAggregate</code>中的<code class="fe ns nt nu nv b">count</code>字段来查找相关数字。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d755" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">子阅读页面</h1><p id="33a9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果我们点击主页中的一个子阅读，我们将被带到该子阅读的页面，在那里我们可以看到该主题下的所有帖子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a1b42e3b8494832cd635387fc93ef06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5WhwvtEm9MtJ4zKJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">阅读1984年的子阅读页</em></p></figure><p id="5224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个页面上，我们需要subreadit名称和描述的数据——就像我们在主页上一样。我们现在还需要获取属于这个子阅读的所有文章。对于每个帖子，我们需要帖子标题、投票数和评论数，以及发布帖子的用户的用户名。不过，我们还不需要实际的评论，因为它们没有显示在这个页面上。</p><p id="5800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe ns nt nu nv b">SubreaditPage</code>组件的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d801" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">帖子页面</h1><p id="1f84" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一旦我们找到了我们想看的感兴趣的帖子，我们可以点击链接来查看单个帖子页面。该页面向我们展示了原始帖子以及帖子上的所有评论:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/52a98562b2050bf59098d3c56f882cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6EqGVFmk40b0ogD8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">阅读奥斯卡帖子的帖子页</em></p></figure><p id="f85b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们需要subreadit页面上的所有相同的帖子数据，但现在我们还需要知道帖子是在哪个subreadit上发布的，我们需要帖子上的所有评论。对于每个评论，我们需要知道发布它的用户的用户名，实际的评论内容是什么，以及它有多少投票。</p><p id="2ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">PostPage</code>的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="22e1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">用户页面</h1><p id="aaa8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最后，如果我们决定查看用户的个人资料，我们可以看到他们发表的所有帖子和评论:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94c81b4fda453d5f1d928c80143fa954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XMbnG3-O83MY11uW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">阅读奥斯卡·马丁内斯的用户页面</em></p></figure><p id="6419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个页面应该显示用户的用户名，简历，文章数量和评论数量。我们还需要他们所有的帖子和评论。对于每个帖子，我们需要知道它发布的子标题，帖子标题，以及投票和评论的数量。对于每个评论，我们需要知道它是对哪个帖子的评论，评论内容是什么，以及它得到的投票数。</p><p id="816b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">UserPage</code>的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个页面是迄今为止最复杂的，因为我们需要查询的不仅仅是汇总数据或聚合计数数据。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8dc5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="5b28" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">正如我们所见，我们应用程序中的每个页面都需要独特的数据部分。有些页面只需要高层次的摘要，比如用户发表的评论或帖子的数量。其他页面需要更深入的结果，如实际的评论和实际的帖子。根据页面的不同，您可能需要更多或更少的信息。</p><p id="04d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用GraphQL和Dgraph Cloud的好处是可以灵活地查询每个页面所需的数据——不多也不少。对于每个请求，我们使用同一个API端点，但是请求不同的字段。这极大地简化了开发工作，因为我们不需要为每个页面创建一个新的后端端点(或者更糟糕的是，创建一个端点来检索庞大的数据负载，然后我们必须筛选以找到我们需要的数据的子集)。</p><p id="634b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL可以让您在需要的时候轻松快捷地请求正确的数据。</p></div></div>    
</body>
</html>