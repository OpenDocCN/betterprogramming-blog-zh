<html>
<head>
<title>How to Get Users’ Swipe Direction in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中获取用户的滑动方向</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-get-users-swipe-direction-in-swiftui-b482a6a8771b?source=collection_archive---------11-----------------------#2020-08-17">https://betterprogramming.pub/how-to-get-users-swipe-direction-in-swiftui-b482a6a8771b?source=collection_archive---------11-----------------------#2020-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f5b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用拖动手势的位置来获取推送的方向</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6bf08592672439573cfe07530bdfd11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V3P6OwgI3QTsiMlx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@davidgrdm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·格兰穆金</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="523d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">简单用户界面</h1><p id="af2e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">对于UI，让我们有一个<code class="fe mu mv mw mx b">ZStack</code>包含一个颜色和文本，当滑动方向改变时，它也会改变。<code class="fe mu mv mw mx b">Color</code>结构可以表现为一个视图。正因为如此，我们可以直接在我们的<code class="fe mu mv mw mx b">ZStack</code>里面加上<code class="fe mu mv mw mx b">Color.red</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="12bb" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">创建两个变量—一个用于颜色，一个用于文本。在我们的<code class="fe mu mv mw mx b">ZStack</code>中，添加我们的<code class="fe mu mv mw mx b">color</code>变量和一个接受方向字符串变量的<code class="fe mu mv mw mx b">Text</code>视图。使用<code class="fe mu mv mw mx b">.edgesIgnoringSafeArea(.all)</code>用我们选择的颜色覆盖整个屏幕:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d939" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">拖拽手势</h1><p id="d503" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">再创建两个变量。第一个变量用于保存拖动的开始位置，而第二个变量是一个布尔值，用于检测滑动动作的开始。给我们的<code class="fe mu mv mw mx b">ZStack</code>加一个<code class="fe mu mv mw mx b">DragGesture</code>。我们将同时需要<code class="fe mu mv mw mx b">.onChanged</code>和<code class="fe mu mv mw mx b">.onEnded</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ca04" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">在<code class="fe mu mv mw mx b">.onChanged</code>中，将我们的<code class="fe mu mv mw mx b">startPos</code>变量赋给手势位置值。现在，我们的<code class="fe mu mv mw mx b">startPos</code>将存储在我们的<code class="fe mu mv mw mx b">ZStack</code>上检测到的每个拖动手势事件的位置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="eedd" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">在<code class="fe mu mv mw mx b">.onEnded</code>内部，计算我们的<code class="fe mu mv mw mx b">startPos</code> x坐标值和结束手势x坐标值之差的绝对值。然后，计算y坐标的相同值。现在，我们需要添加以下四个条件:</p><ul class=""><li id="339e" class="nf ng it ma b mb na me nb mh nh ml ni mp nj mt nk nl nm nn bi translated">如果开始位置的y坐标值小于结束手势的y坐标值，并且如果y坐标之间的距离大于x坐标之间的距离，则滑动方向是向下的。</li><li id="c71e" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated">如果开始位置的y坐标值大于结束手势的y坐标值，并且如果y坐标之间的距离大于x坐标之间的距离，则滑动方向向上。</li><li id="bd2e" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated">如果开始位置的x坐标值大于结束手势的x坐标值，并且如果x坐标之间的距离大于y坐标之间的距离，则滑动方向为左。</li><li id="1cbe" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated">最后，如果开始位置的x坐标值小于结束手势的x坐标值，并且如果x坐标之间的距离大于y坐标之间的距离，则滑动方向是正确的。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/e42b5568d9aeea0d8e74fa9e932a9033.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/1*4CjjG_TsE-40jmV7jDY4KQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SwiftUI中的滑动方向</p></figure><p id="06fe" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">全部完成！感谢您的阅读。</p></div></div>    
</body>
</html>