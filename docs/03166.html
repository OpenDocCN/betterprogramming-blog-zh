<html>
<head>
<title>How Would You Build document.getElementsByClassName From Scratch?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从头开始构建document . getelementsbyclassname？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-javascript-from-scratch-5caf5e7cc464?source=collection_archive---------2-----------------------#2020-01-25">https://betterprogramming.pub/building-javascript-from-scratch-5caf5e7cc464?source=collection_archive---------2-----------------------#2020-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4160" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看一个有趣的面试问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a0b2c0cd245c332bb608cbebd304baef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0L2M4H7xMQgY69sa-hM-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码示例的屏幕截图</p></figure><p id="5e59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我目前正在寻找我的第一份软件工程师工作，最近我进行了一次模拟技术面试。面试是针对JavaScript的，由两个问题组成。第一个是相当标准的算法问题，但第二个相当有趣:我被要求从头开始构建<code class="fe lr ls lt lu b">document.getElementByClassName</code>方法——就好像它不存在一样。</p><p id="b431" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我发现建立一个我以前用过很多次的方法很有启发性。它从整体上提高了我对DOM操作和JavaScript的理解。在这篇文章中，我将向您介绍我提出的解决方案。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="506d" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">目标</h1><p id="e745" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">目标是创建一个功能等同的<code class="fe lr ls lt lu b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName" rel="noopener ugc nofollow" target="_blank">document.getElementByClassName</a></code>版本。为此，我们的新功能需要以下特性:</p><ul class=""><li id="119e" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">它可以在任何HTML元素上调用。</li><li id="b780" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">它有一个参数，一个字符串，包含任意数量的类名。</li><li id="18b8" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">它返回与传入的所有类名匹配的所有元素。</li><li id="b008" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">它只返回调用该函数的元素的子元素</li></ul></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="53e2" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">例子</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="8c9a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">计划</h1><p id="4245" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">首先，我们需要为我们的功能创建一个概念性的计划:</p><ol class=""><li id="d40c" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nq ng nh ni bi translated">创建一个数组来存储所有匹配的元素。</li><li id="b2cb" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nq ng nh ni bi translated">检查类名的main元素的所有直接后代。如果有，将它们添加到数组中。</li><li id="c5a6" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nq ng nh ni bi translated">用同样的方法检查所有这些孩子的孩子。</li><li id="de47" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nq ng nh ni bi translated">重复直到不再有孩子。</li></ol><p id="75bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基于这个计划，我们需要创建一个递归帮助函数，或者一个在自己的定义中调用自己的函数，来检查主函数下的所有元素。我们将在主函数中调用这个辅助函数。main函数的返回值应该是一个元素数组，我们在顶部将它声明为一个空数组，并随着我们的进展向其添加元素。</p><p id="4ae6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们有一个可靠的计划。让我们开始编码吧！</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="757e" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">密码</h1><h2 id="6d2b" class="nr md iq bd me ns nt dn mi nu nv dp mm le nw nx mo li ny nz mq lm oa ob ms oc bi translated">步骤1:设置主函数</h2><p id="296f" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">这里我们将定义我们的主要功能。在主体中，我们将定义两个变量:<code class="fe lr ls lt lu b">elements</code>，一个数组，所有具有匹配类名的元素将被添加到该数组中；<code class="fe lr ls lt lu b">firstChildren</code>，该函数被调用的元素的所有子元素。对于后者，我们可以利用JavaScript的方法，该方法返回一个包含被调用节点的所有子元素的<code class="fe lr ls lt lu b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection" rel="noopener ugc nofollow" target="_blank">HTMLCollection</a></code>。这个<code class="fe lr ls lt lu b">HTMLCollection</code>可以当作一个数组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="8ef0" class="nr md iq bd me ns nt dn mi nu nv dp mm le nw nx mo li ny nz mq lm oa ob ms oc bi translated">步骤2:编写递归助手函数</h2><p id="d1d6" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated"><a class="ae mz" href="https://javascript.info/recursion" rel="noopener ugc nofollow" target="_blank">递归函数</a>是一个在定义中调用自身的函数，而辅助函数是一个抽象一些代码以使其既可重用又更可读的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="69b2" class="nr md iq bd me ns nt dn mi nu nv dp mm le nw nx mo li ny nz mq lm oa ob ms oc bi translated">第三步:把它们放在一起</h2><p id="a717" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">现在我们想在每个<code class="fe lr ls lt lu b">firstChildren</code>上调用<code class="fe lr ls lt lu b">checkChildren</code>方法。这个函数运行后，我们的元素数组应该包含所有匹配的元素！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="bcf3" class="nr md iq bd me ns nt dn mi nu nv dp mm le nw nx mo li ny nz mq lm oa ob ms oc bi translated">第4步:添加到HTML元素原型</h2><p id="246b" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">最后，为了能够在任何HTML元素上调用这个函数，我们需要将它添加到HTML元素<a class="ae mz" href="https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b" rel="noopener">原型</a>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d5bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就这样，我们结束了！我们的新方法<code class="fe lr ls lt lu b">getElementsByClassName2</code>现在与原来的<code class="fe lr ls lt lu b">getElementsByClassName</code>具有相同的功能。我希望你觉得这个过程和我一样有趣和翔实。</p><p id="e724" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢谢你的阅读！</p></div></div>    
</body>
</html>