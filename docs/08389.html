<html>
<head>
<title>Guide to Multi-Threading — GCD in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多线程指南iOS中的GCD</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/guide-to-multi-threading-gcd-83009f5d62cb?source=collection_archive---------2-----------------------#2021-04-26">https://betterprogramming.pub/guide-to-multi-threading-gcd-83009f5d62cb?source=collection_archive---------2-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写并发代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8a1183c4d1f311755208fd4e4bada9dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YxFcJPlwAXAmJ8x0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·安维克在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片。</a></p></figure><p id="c6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，移动设备配备了大量强大的CPU供其使用。这让你有能力制作高性能的应用程序。想象你的应用程序是一个图片库应用程序，你必须建立一个光滑的用户界面，用户可以与它互动，同时上传和下载他们的25MB高清图像。</p><p id="f8f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你绝不会希望你的应用程序在上传或下载图像时停止响应用户的触摸(反之亦然)。因此，为了确保你不会在这种情况下结束，你需要确保这两者可以发生而不会相互影响。这就是多线程概念的由来。</p><p id="97d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多线程是一个广泛的概念，它使开发人员能够将<em class="lv">并发性</em>或<em class="lv">并行性</em>注入到我们的软件中，以便我们的软件需要执行的任务可以通过优化使用CPU的时间来执行。</p><ul class=""><li id="5394" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">并行性:<strong class="lb iu"> </strong>多个任务并行一起运行的过程。</li><li id="765e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">并发:<strong class="lb iu"> </strong>这是一个给人多个任务并行运行错觉的过程。任务以这样一种方式被划分，它们被时间分片，以一种优化的方式占用CPU的时间，但是它们实际上并不是并行运行的。</li></ul><p id="9801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实际场景中，实现纯粹的并行性是不可实现的，因为有许多后台进程一直在设备中运行。因此，有时任务会并行运行，有时会并发运行。</p><p id="e6ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常有三种方法可以在iOS应用中实现多线程:</p><ol class=""><li id="1cc8" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated">线</li><li id="c48f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/DISPATCH" rel="noopener ugc nofollow" target="_blank"> GCD —大中央调度</a></li><li id="c8a7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">操作和<code class="fe ml mm mn mo b">OperationQueues</code></li></ol><p id="991d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索Grand Central Dispatch，让您的应用程序充分利用多线程。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="b071" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">中央调度中心</h1><p id="7fdb" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这可能是在您的应用程序中支持多线程的最常用的工具包。Grand Central Dispatch(或GCD <strong class="lb iu"> ) </strong>是一个面向开发人员的低级API，用于创建管理线程池的队列，或者为我们提供一些系统生成的队列来同步或异步执行任务。让我们把这个描述分成三个部分:</p><ul class=""><li id="18ff" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">创建队列或使用系统生成的队列。</li><li id="e03a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">管理线程池。</li><li id="eada" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">同步或异步执行任务。</li></ul><p id="6306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">句子的第一部分使用了术语<em class="lv">队列</em>。什么是队列，队列是用来做什么的？</p><p id="0075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">队列是一种数据结构，其行为类似于现实生活中的队列。你排在队伍的最后，在你前面的人都离开队伍后你才出来。</p><p id="e411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在GCD的上下文中，这些队列用于调度计算密集型任务。您将一个任务放入队列中，它就会被执行(稍后将详细介绍)。</p><p id="cbfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GCD跟踪所有由您创建或由系统提供的队列。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="b03a" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">创建队列</h1><p id="50cc" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在此之前，让我们先弄清楚:队列不是线程！</p><p id="a2ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以创建两种类型的队列:</p><ol class=""><li id="978e" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated">串行队列—一次只能运行一个任务。他们通常以先进先出的方式工作。理想情况下，只有一个线程与串行队列相关联。</li><li id="f3f5" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">并发队列—可以同时并发或并行运行多个任务。根据系统限制，可能有一个或多个线程池。</li></ol><p id="c62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过以下方式创建队列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="292e" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ml mm mn mo b">label </code> —队列的名称。</li><li id="bfbb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqos/qosclass" rel="noopener ugc nofollow" target="_blank">qos</a></code> —也称为服务质量。按照优先级顺序，有五个级别的QoS:</li></ul><ol class=""><li id="3c23" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated"><code class="fe ml mm mn mo b">userInteractive</code></li><li id="1f58" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><code class="fe ml mm mn mo b">userInititated</code></li><li id="105a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><code class="fe ml mm mn mo b">default</code></li><li id="0547" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><code class="fe ml mm mn mo b">utility</code></li><li id="00ac" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><code class="fe ml mm mn mo b">background</code></li></ol><ul class=""><li id="ddb5" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ml mm mn mo b">attributes</code> —您可以指定队列是否需要并发。如果没有指定，它是一个串行队列。</li><li id="debb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue/autoreleasefrequency" rel="noopener ugc nofollow" target="_blank">autoreleaseFrequency</a></code> —指定如何自动释放由提交到队列的操作块创建的对象。</li><li id="82b3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">target</code> —指定可能是最适合运行任务的队列的目标队列。</li></ul><p id="9647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以使用一些系统生成的队列来执行您的任务。</p><ul class=""><li id="9c1d" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ml mm mn mo b">DispatchQueue.main</code> —管理应用程序主线程的串行队列。</li><li id="9156" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">DispatchQueue.global</code> —管理线程池的并发队列，其中任务可以基于<code class="fe ml mm mn mo b">qos</code>参数被调度运行。</li></ul></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="09f6" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">执行任务</h1><p id="f092" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">有两种方法可以执行分派队列中的任务:</p><ol class=""><li id="dbcd" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated"><code class="fe ml mm mn mo b">async</code> —块被提交到队列并立即返回。然后，当系统有资源执行该块时，将执行该块。</li><li id="6f60" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><code class="fe ml mm mn mo b">sync</code> —提交到队列的块就像一段内嵌代码一样被执行。它将阻塞当前线程的执行，执行提交给它的代码块(在调用线程上——稍后将详细介绍),然后继续执行剩余的代码。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">队列总是以FIFO的方式执行任务。不管是串行队列还是并发队列。较早提交的块在随后提交的块之前开始执行，尽管它们可能在不同的时间结束。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="9eca" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">调度组</h1><p id="640f" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">一个<code class="fe ml mm mn mo b">DispatchGroup</code>用于并行执行不相关的任务，然后在所有任务完成后对它们做出反应。尽管这与GCD、线程和队列的一般主题无关，但是了解这个类是很重要的，因为您可能会非常频繁地使用它。</p><p id="e7a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ml mm mn mo b">DispatchGroup</code>时，你需要记住三个主要功能:</p><ol class=""><li id="3ff6" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated"><code class="fe ml mm mn mo b">enter</code></li><li id="c887" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><code class="fe ml mm mn mo b">leave</code></li><li id="67d3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><code class="fe ml mm mn mo b">notify</code></li></ol><p id="fbb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您调用<code class="fe ml mm mn mo b">enter</code>时，<code class="fe ml mm mn mo b">DispatchGroup</code>递增计数器，当您调用<code class="fe ml mm mn mo b">leave</code>时递减计数器，如果计数器值为<code class="fe ml mm mn mo b">0</code>则调用<code class="fe ml mm mn mo b">notify</code>。</p><p id="2a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是如何使用一个<code class="fe ml mm mn mo b">DispatchGroup</code>:</p><ol class=""><li id="71ba" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated">在每一个需要执行的<code class="fe ml mm mn mo b">DispatchWorkItem</code>(代码块的别称)之前调用<code class="fe ml mm mn mo b">enter</code>。</li><li id="869c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">当你的<code class="fe ml mm mn mo b">DispatchWorkItem</code>完成后，呼叫<code class="fe ml mm mn mo b">leave</code>。</li><li id="7395" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">设置一个<code class="fe ml mm mn mo b">notify</code>块，该块将在<code class="fe ml mm mn mo b">DispatchGroup</code>执行完所有<code class="fe ml mm mn mo b">DispatchWorkItems</code>后执行。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只是注意不要在调用<code class="fe ml mm mn mo b">enter</code>之前声明<code class="fe ml mm mn mo b">notify</code>块。否则，将立即调用<code class="fe ml mm mn mo b">notify</code>模块(因为<code class="fe ml mm mn mo b">DispatchGroup</code>中的计数器从<code class="fe ml mm mn mo b">0</code>开始计数)。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="9bac" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">竞赛条件</h1><p id="ee38" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">没有对竞争条件以及如何避免它们的讨论，任何线程主题都是不完整的。但是首先，让我们了解一下竞争条件。</p><p id="f88e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个简单的例子，你运行一个电子商务网站管理面板，有一个功能，通过它你可以为有效投诉的客户退款。</p><p id="3d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户向您要求退款，您按照以下基本步骤进行退款:</p><ol class=""><li id="513d" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated">投诉有效吗？</li><li id="534e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">退款已经处理了吗？</li><li id="83f3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">处理银行退款。</li><li id="787a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">通知客户退款状态。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="30e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一天，你注意到你已经为同一个订单给一个顾客退了两次款。这种情况的原因很容易是一个竞争条件。假设客户分别发出两个退款请求。</p><ul class=""><li id="6a20" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">退款请求1 →第一次收到订单退款→处理退款。</li><li id="e6c2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">退款请求2(当<code class="fe ml mm mn mo b">Refund Request 1</code>仍在处理中)→ <code class="fe ml mm mn mo b">order.refund.isProcessed</code>仍在<code class="fe ml mm mn mo b">false</code> →处理第二次退款。</li></ul><p id="fa7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这两个请求都是在多线程环境中处理的，很有可能在处理第一个退款请求时，第二个退款请求进来并检查了<code class="fe ml mm mn mo b">order.refund.isProcessed</code>仍然是<code class="fe ml mm mn mo b">false</code>，即使您已经准备好了所有的当前检查，也需要为客户启动退款。</p><p id="e2d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您可以看到<code class="fe ml mm mn mo b">order</code>是一个跨线程共享的资源(即它是一个“共享资源”)。</p><p id="1c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当多个线程试图在并发或并行执行中访问同一资源时，就会发生争用情况。</p><p id="1692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然知道这样的问题可以存在，那就来看看怎么解决吧。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="902b" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">解决方案1 —串行队列</h1><p id="11ad" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">第一种选择是连续处理操作(在我们的例子中是退款)(即只有在第一次退款完成后才会处理第二次退款)。我们可以修改我们的代码，通过将所有退款代码放入一个串行队列中来串行处理退款。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="ef09" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">僵局</h2><p id="780c" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这里要注意的一点是，串行队列带来了额外的缺点，即您仍然可能在串行队列上以死锁告终。</p><p id="00dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用串行队列操作中的<code class="fe ml mm mn mo b">sync</code>调用操作会导致死锁。</p><p id="20f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面死锁的原因是由于<code class="fe ml mm mn mo b">Block 2</code>是在<code class="fe ml mm mn mo b">serialQueue</code>中执行的，它在等待<code class="fe ml mm mn mo b">Block 1</code>完成执行，但是<code class="fe ml mm mn mo b">Block 1</code>无法完成其执行，因为<code class="fe ml mm mn mo b">Block 2</code>正在试图运行。采访中经常被问到的一个最好的例子是在主线程上调用一个<code class="fe ml mm mn mo b">DispatchQueue.main.sync</code>。这将导致应用程序因死锁而崩溃。</p><p id="c5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">始终确保不要在运行于同一串行队列的任务中调用该串行队列的<code class="fe ml mm mn mo b">sync</code>。并发队列不存在这个问题。</p><h2 id="cf33" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">同步</h2><p id="5357" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我想讨论在队列中同步运行代码块的效果，但在此之前，我们需要理解当前/调用线程的概念。</p><p id="1a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当前或调用线程是在其上调用同步任务的线程。</p><p id="4e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您执行了以下任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，<code class="fe ml mm mn mo b">serialQueue.sync</code>代码运行在<code class="fe ml mm mn mo b">main</code> <code class="fe ml mm mn mo b">DispatchQueue</code>内部。我们知道主队列将被阻塞，直到<code class="fe ml mm mn mo b">serialQueue</code>完成执行它的<code class="fe ml mm mn mo b">print("Performing serially")</code>语句，因为同步调用本质上是阻塞的。</p><p id="d74d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，执行此操作的当前线程是主线程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/4510c3617c2a1318d390d9a8cb96f892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVFIAlmEYs5kkzPJZBP2cA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DispatchQueue上的同步调用</p></figure><p id="7135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我执行了前面提到的代码片段，从左边的线程分析器面板可以看到，<code class="fe ml mm mn mo b">print</code>语句实际上运行在主线程(当前线程)上，但它是通过我创建的<code class="fe ml mm mn mo b">serialQueue</code>执行的。</p><p id="ac80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对比一下同一队列上的一个<code class="fe ml mm mn mo b">async</code>调用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/d54b5cd7624aed9bd93ef21c8258a6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtvqblSRVH6E5AWE5VLDXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DispatchQueue上的异步调用</p></figure><p id="13eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe ml mm mn mo b">async</code>调用，您可以看到<code class="fe ml mm mn mo b">print</code>不再在主线程中执行，而是在其他一些后台线程(本次运行中的线程8)中执行。</p><p id="e72a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ml mm mn mo b">sync</code>调用总是在当前/调用线程上执行，而<code class="fe ml mm mn mo b">async</code>调用可能在当前/调用线程上被调用，也可能不被调用。</p><p id="191b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的语句是一个优化，使得<code class="fe ml mm mn mo b">sync</code>块中的代码可以在同一个线程中执行(因此使其阻塞)。</p><p id="58f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里一个自然的问题可能是“如果要在同一个线程上调用，为什么还要使用一个<code class="fe ml mm mn mo b">sync</code>调用呢？为什么我不能直接内联编写代码，而不必将它放在不同队列的<code class="fe ml mm mn mo b">sync</code>调用中？”</p><p id="99e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的原因是为了防止数据竞争问题。您通常不在主调度队列上进行同步调用，而是在您创建的调度队列上进行同步调用，以确保您同步了对特定资源的读/写访问。这样，您可以确保您的资源是线程安全的。</p><p id="e6ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后面的部分中，我们将讨论一个关于访问资源的小案例研究。</p><p id="fa47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如果你从当前线程中调用<code class="fe ml mm mn mo b">DispatchQueue.main.sync</code>，它总是在主线程中执行。</p><p id="28d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们之前讨论的一个小例外，我们看到<code class="fe ml mm mn mo b">sync</code>调用通常在调用/当前线程上执行。但是通过主队列<code class="fe ml mm mn mo b">sync</code>调用执行的代码将总是在主线程上运行，而不是在调用线程上运行。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="b4f0" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">锁和信号量</h1><p id="737d" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">锁是确保对“共享资源”的访问是同步的并且不能被同时访问的另一种方式。</p><p id="b3e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是使用<code class="fe ml mm mn mo b">NSLock</code>类完成的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="80b5" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">调度障碍</h1><p id="21fd" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">屏障是队列中唯一执行的代码块(即，在屏障块需要完成执行之前提交到队列的所有块，然后屏障块执行，然后所有其他块执行)。</p><p id="dee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">屏障在串行队列中没有意义，因为在串行队列中一次只有一个块执行。</p><p id="17c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在并发队列中，您可以使用屏障标志来调度屏障块。因此，我们的退款示例将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="db77" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">案例研究—单身</h1><p id="255d" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">singleton模式是iOS开发中非常常见的模式，也是可能出现竞争情况的最佳案例之一。我将在这里讨论一个非常简单的setter/getter(而不是singleton模式到底是什么):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="52c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的类中，<code class="fe ml mm mn mo b">assets</code>数组是一个共享资源，当前可以从任何队列中读取和写入，这可能会导致竞争情况。一个常见的竞争条件问题被称为<a class="ae ky" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiU6O3S9dHuAhUHzTgGHXK4Dz8QFjAXegQIGxAC&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FReaders%25E2%2580%2593writers_problem&amp;usg=AOvVaw1btL84VFOmqtbhQmZ_BjoG" rel="noopener ugc nofollow" target="_blank">读者-作者问题</a>。</p><p id="dd22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决读写问题，我们需要序列化对共享变量<code class="fe ml mm mn mo b">assets</code>的访问。</p><p id="135a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经有三种方法可以序列化对资源的访问，但是对于这里的情况，我们将使用barrier解决方案(您可以继续使用任何最适合您的用例的解决方案)。</p><ol class=""><li id="7e45" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated">首先，将变量设为私有变量，这样外部的任何人都不能访问它。</li><li id="b04a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">然后为这个单例类创建一个私有队列。</li><li id="f361" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">提供序列化对该资源的访问的函数(<code class="fe ml mm mn mo b">assets</code>)。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个类需要注意一些事情:</p><ul class=""><li id="e977" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">这里，我们必须调度对线程的同步调用，因为读取通常必须是同步的。根据您的使用情况，您也可以随时进行<code class="fe ml mm mn mo b">async</code>呼叫。</li><li id="b544" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果您仔细观察，<code class="fe ml mm mn mo b">getAssets()</code>将在<code class="fe ml mm mn mo b">async</code>块中发出一个<code class="fe ml mm mn mo b">sync</code>调用，这是允许的，因为这是一个并发队列。</li></ul><p id="4a53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设这是一个并发队列，在<code class="fe ml mm mn mo b">async</code>块内调用<code class="fe ml mm mn mo b">sync</code>块(或<code class="fe ml mm mn mo b">sync</code>块)不会有任何问题，但是如果这是一个串行队列在<code class="fe ml mm mn mo b">async/sync</code>块内调用<code class="fe ml mm mn mo b">sync</code>块，就会导致死锁！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="b8e0" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="35c9" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在本文中，我们了解了以下内容:</p><ul class=""><li id="55fb" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">多线程与并行性</li><li id="dd10" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">DispatchQueues</code></li><li id="e366" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">DispatchGroups</code></li><li id="c7e5" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">sync</code>对<code class="fe ml mm mn mo b">async</code></li><li id="b46b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">竞态条件以及如何解决它们</li><li id="70c6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">同步调用中实际发生了什么</li><li id="51b2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">一个</li></ul><p id="e969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在阅读<code class="fe ml mm mn mo b">sync</code>和<code class="fe ml mm mn mo b">async</code>在串行队列和并发队列中执行时的行为时要特别小心。此外，请确保您了解这两种队列中任务的执行顺序。</p><p id="626f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开一个游戏场，执行你能想到的所有不同的组合，尝试推理执行的顺序和它们被执行的线程，然后回来用你在这里读到的理论进行验证。这会让你更好地理解主题，也有助于你记忆。</p></div></div>    
</body>
</html>