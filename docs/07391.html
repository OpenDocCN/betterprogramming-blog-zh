<html>
<head>
<title>Create a Zero-Downtime Deployment of Your Machine Learning API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建机器学习API的零停机部署</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-zero-downtime-deployment-of-your-machine-learning-api-6486cb6394c3?source=collection_archive---------5-----------------------#2021-01-11">https://betterprogramming.pub/create-a-zero-downtime-deployment-of-your-machine-learning-api-6486cb6394c3?source=collection_archive---------5-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="63a2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">只要你愿意，随时可以毫不犹豫地用新型号替换旧型号</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ac5d19b16cc05b3e3f864eee521b8feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LtkPGBOLXaqwS7nr-S40Hg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sarahleejs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">李宗盛</a>在<a class="ae kv" href="https://unsplash.com/s/photos/taking-off?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="49c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">机器学习API的独特之处之一是，随着新数据的到来，底层模型需要不断地重新训练。这导致频繁的重新部署，结果是频繁的停机。</p><p id="8780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您介绍一个解决这个问题的方案。下面的GIF展示了该解决方案的实际应用。左边是运行(重新)部署脚本的API服务器。右边是不断ping该API的客户端:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/78c97047324ed4b4798a0174828e75c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DLhLfdiS0PPl69T6AvyUpQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">零停机时间。</p></figure><p id="d206" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使部署脚本正在服务器上运行，API也不会返回错误！</p><p id="a62c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个的代码可以在我的GitHub上找到。它实际上是我正在开发的<a class="ae kv" href="https://github.com/RishabhMalviya/ml-deployment-template" rel="noopener ugc nofollow" target="_blank">模板项目</a>的一部分。很快会有更多。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2918" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">蓝绿色部署</h1><p id="945f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我想出的解决方案受到一种叫做<a class="ae kv" href="https://medium.com/@dantwining_26268/zero-downtime-blue-green-deployments-for-microservices-7896558623b2" rel="noopener">蓝绿色部署</a>的技术的启发。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f1e0080e19b973bb8459515e159a49f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/1*gDgzru_1eoBrLIo86ib6Sw.gif"/></div></figure><p id="a554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本的想法很简单:你用你的新模型旋转容器，等待它准备好。然后，负载平衡器将流量从旧部署(本动画中的蓝色)转移到新部署(绿色)。</p><p id="6801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的其余部分将解释这是如何实现的，包括使用的技术和来自<a class="ae kv" href="https://github.com/RishabhMalviya/ml-deployment-template/" rel="noopener ugc nofollow" target="_blank">模板项目</a>的相关代码。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="5eab" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">负载平衡器— Traefik代理</h1><p id="ec1e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">大多数人自动使用Nginx进行负载均衡，但免费的Nginx负载均衡器无法动态检测下游服务器的变化。这对我们来说是一个问题，因为这使得蓝绿部署策略的最后一步不可能实现。</p><p id="088d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们将使用名为<a class="ae kv" href="https://doc.traefik.io/traefik/" rel="noopener ugc nofollow" target="_blank"> Traefik代理</a>的替代产品。</p><h2 id="44cb" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">基本抽象</h2><p id="c837" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在理解Traefik如何解决我们的问题之前，我们需要熟悉它的底层抽象。</p><p id="02ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一段和随后的图表(都直接取自<a class="ae kv" href="https://doc.traefik.io/traefik/routing/overview/" rel="noopener ugc nofollow" target="_blank"> Traefik代理文档</a>)提供了一个很好的起点:</p><blockquote class="nk nl nm"><p id="7451" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">当您启动Traefik时，您定义了<a class="ae kv" href="https://doc.traefik.io/traefik/routing/entrypoints" rel="noopener ugc nofollow" target="_blank">入口点</a>(在它们最基本的形式中，它们是端口号)。然后，连接到这些入口点，<a class="ae kv" href="https://doc.traefik.io/traefik/routing/routers" rel="noopener ugc nofollow" target="_blank">路由器</a>分析传入的请求，看它们是否匹配一组<a class="ae kv" href="https://doc.traefik.io/traefik/routing/routers#rule" rel="noopener ugc nofollow" target="_blank">规则</a>。如果是这样，路由器可能会在将请求转发到您的<a class="ae kv" href="https://doc.traefik.io/traefik/routing/services/" rel="noopener ugc nofollow" target="_blank">服务</a>之前，使用<a class="ae kv" href="https://doc.traefik.io/traefik/middlewares/overview/" rel="noopener ugc nofollow" target="_blank">中间件</a>来转换请求。”</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/24b9289e3a0afbbc0d264f1c71748e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P793TfMjR4K-_DXh2IFEhA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">摘自<a class="ae kv" href="https://doc.traefik.io/traefik/routing/overview/" rel="noopener ugc nofollow" target="_blank"> Traefik代理文档</a>。</p></figure><p id="c5e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图在概念上可以进一步分为两个部分，每个部分都单独配置。</p><p id="7632" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">入口点是<em class="nn">静态配置</em>的一部分，而路由器和服务在<em class="nn">动态配置</em>中定义。这意味着您可以动态地添加和删除路由器和服务，Traefik将确保流量始终正常流动。</p><p id="32c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就蓝绿色部署而言，这意味着我们可以启动绿色容器并关闭蓝色容器，而不必重新初始化Traefik。由于下游容器是动态配置的一部分，Traefik将自动为我们注册这些更改。</p><p id="0091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来了解一下这是如何一步步实现的。</p><h2 id="3b2d" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">静态配置</h2><p id="78c7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Traefik负载平衡器在它自己的容器中启动。这是描述如何创建容器的docker-compose服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5124" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">command</code>键下的条目构成静态配置。这些在Traefik第一次启动时生效，以后不能更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/7f562fe0f5e9a27ec051bdaab9080045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*mGMBTZvgXVk1E71gDBHOIA.png"/></div></figure><p id="1470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能的静态配置的完整列表可以在文档中找到<a class="ae kv" href="https://doc.traefik.io/traefik/reference/static-configuration/cli/" rel="noopener ugc nofollow" target="_blank">。如果您浏览列表，您会注意到没有路由器或服务的配置选项。这是因为这些是动态组件。</a></p><p id="5532" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果继续深入，您将开始看到名为<code class="fe nu nv nw nx b">providers</code>的配置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/7542ec75ba27db19804e3d4ad583ba4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jo6SyYlEoLjDFJzYXebf1A.jpeg"/></div></div></figure><h2 id="1904" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">提供者和动态配置</h2><p id="48f8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">提供者使得Traefik中的动态配置成为可能。文档<a class="ae kv" href="https://doc.traefik.io/traefik/providers/overview/" rel="noopener ugc nofollow" target="_blank">在配置发现标题下详述了提供者</a>:</p><blockquote class="nk nl nm"><p id="ad20" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">“提供商是现有的基础设施组件，无论是编排器、容器引擎、云提供商还是键值存储。这个想法是，Traefik将查询提供者的API，以便找到关于路由的相关信息，并且每次Traefik检测到变化时，它都会动态地更新路由。"</p></blockquote><p id="a544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，提供者是Docker守护进程(如果您回到静态配置，您会发现条目<code class="fe nu nv nw nx b">providers.docker=True</code>)。Traefik <a class="ae kv" href="https://docs.docker.com/engine/api/" rel="noopener ugc nofollow" target="_blank">与Docker守护进程</a>通信，以收集关于活动Docker容器的信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/1931d8cdb43d8f63e96ffa0fb0beb9f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*GE_b-M-M18qTqmvJfdwExw.png"/></div></figure><p id="6235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们如何在Docker容器和Traefik概念(如路由器和服务)之间进行转换呢？首先，我们有来自<a class="ae kv" href="https://doc.traefik.io/traefik/routing/providers/docker/#general" rel="noopener ugc nofollow" target="_blank">文档</a>的保证:</p><blockquote class="nz"><p id="72ce" class="oa ob iq bd oc od oe of og oh oi lr dk translated">Traefik为每个容器创建一个相应的<a class="ae kv" href="https://doc.traefik.io/traefik/routing/services/" rel="noopener ugc nofollow" target="_blank">服务</a>和<a class="ae kv" href="https://doc.traefik.io/traefik/routing/routers/" rel="noopener ugc nofollow" target="_blank">路由器</a></p></blockquote><p id="d878" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">为了指定服务和路由器的配置，我们使用Docker容器标签。看看来自<code class="fe nu nv nw nx b">docker-compose.yml</code>文件的服务定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="35a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">动态配置都在<code class="fe nu nv nw nx b">labels</code>键下提供。Traefik使用它们来动态创建路由器和服务。动态配置选项的完整列表可在文档中查看<a class="ae kv" href="https://doc.traefik.io/traefik/reference/dynamic-configuration/docker/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="63af" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">动态配置详细信息(可以跳过):负载平衡器</h2><p id="960f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">您会注意到所有的动态配置键中都有<code class="fe nu nv nw nx b">loadbalancer</code>。这是因为可以部署单个容器的多个副本(使用 <code class="fe nu nv nw nx b"><a class="ae kv" href="https://docs.docker.com/compose/reference/scale/" rel="noopener ugc nofollow" target="_blank">docker-compose up</a></code> <a class="ae kv" href="https://docs.docker.com/compose/reference/scale/" rel="noopener ugc nofollow" target="_blank">命令</a>的<code class="fe nu nv nw nx b"><a class="ae kv" href="https://docs.docker.com/compose/reference/scale/" rel="noopener ugc nofollow" target="_blank">--scale</a></code> <a class="ae kv" href="https://docs.docker.com/compose/reference/scale/" rel="noopener ugc nofollow" target="_blank">选项)。因此，Traefik自动将对应于一个容器(或一组副本)的服务配置为负载平衡器。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3ab7ad4718da014c639e9cfd8a09f37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*eVdJE5U5E2NaglbHRRVXeQ.png"/></div></figure><h2 id="a813" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">动态配置详情(可跳过)<strong class="ak">:健康检查</strong></h2><p id="ac81" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">每个容器都需要一些时间来准备自己并准备好它的API。为了避免向尚未准备好的容器发送请求，Traefik允许您配置<a class="ae kv" href="https://doc.traefik.io/traefik/routing/services/#health-check" rel="noopener ugc nofollow" target="_blank">健康检查</a>。从文档中:</p><blockquote class="nz"><p id="3ad5" class="oa ob iq bd oc od oe of og oh oi lr dk translated">“Traefik将认为您的服务器是健康的，只要它们对健康检查请求返回在<code class="fe nu nv nw nx b">2XX</code>和<code class="fe nu nv nw nx b">3XX</code>之间的状态代码。”</p></blockquote><p id="9bf1" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">我已经在API的<code class="fe nu nv nw nx b">app.py</code>文件末尾添加了一个健康检查端点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ac0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为它是文件中定义的最后一个端点，所以我们可以确定如果<code class="fe nu nv nw nx b">/health</code>端点正在响应，那么所有其他端点和资源都已经成功初始化。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d7e1" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">部署脚本的演练</h1><p id="b2e5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">有了这些背景知识，让我们一行一行地浏览<a class="ae kv" href="https://github.com/RishabhMalviya/ml-deployment-template/blob/master/deploy.sh" rel="noopener ugc nofollow" target="_blank">部署脚本</a>并理解整个过程。</p><h2 id="879e" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">初始设置</h2><p id="b270" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">首先，设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="04f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经设计了部署，以便所有的容器都部署在一个Docker网络上，<code class="fe nu nv nw nx b">deployed-containers</code>。如果我们是第一次部署，许多资源会被初始化:</p><ol class=""><li id="df92" class="oo op iq ky b kz la lc ld lf oq lj or ln os lr ot ou ov ow bi translated">第一，Docker网(<code class="fe nu nv nw nx b">deployed-containers</code>)。</li><li id="279e" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">然后是反向代理(Traefik)。这是在<code class="fe nu nv nw nx b">docker-compose up -d reverse-proxy</code>行中完成的。这将加载前面显示的静态配置，并设置Traefik来监视来自Docker守护进程的更改。</li><li id="7c16" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">最后，我们需要初始化一个名为<code class="fe nu nv nw nx b">.colors</code>的文件，该文件跟踪当前/下一次部署的颜色。我从蓝绿色部署中借用了彩色部署的概念。这是我们将要运行的部署开始时的<code class="fe nu nv nw nx b">.colors</code>文件的示例:</li></ol><pre class="kg kh ki kj gt pc nx pd pe aw pf bi"><span id="e9f1" class="my mb iq nx b gy pg ph l pi pj">export DEPLOYED_COLOR="blue"<br/>export IDLE_COLOR="green"</span></pre><h2 id="adfd" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">调出新的(绿色)容器</h2><p id="84dc" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">开始时，事情会处于这种状态:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ab765509c9642710b1ef7b1beeab251f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*yV5hmRhN1Ao6hFR9WPju_w.png"/></div></figure><p id="06b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从绿色部署开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0b5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有两件事需要注意:</p><ol class=""><li id="57a8" class="oo op iq ky b kz la lc ld lf oq lj or ln os lr ot ou ov ow bi translated"><code class="fe nu nv nw nx b">— scale model=$REPLICAS</code>。它告诉docker-compose构建“绿色”部署的<code class="fe nu nv nw nx b">$REPLICAS</code>副本。</li><li id="0576" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated"><code class="fe nu nv nw nx b"><a class="ae kv" href="https://docs.docker.com/compose/reference/overview/#use--p-to-specify-a-project-name" rel="noopener ugc nofollow" target="_blank">— p $IDLE_COLOR</a></code>。它用于给<code class="fe nu nv nw nx b">docker-compose</code>指定一个项目名称空间。这对于隔离绿色和蓝色部署非常重要。</li></ol><p id="e245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这会把我们带到这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/bc425d08284411602f1bc62fa6a00af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*u1iNSVQqo3C59v6e_s9N9w.png"/></div></figure><p id="f9b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦绿色部署就绪(即，一旦运行状况检查通过)，Traefik也将开始向这些绿色部署发送流量。那么我们将处于这种状态:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ce4be047bdc03713e2ab04084391ceb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*G32_vy7V2SZEk7b94Bdnng.png"/></div></figure><h2 id="3715" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">取下旧的(蓝色)容器</h2><p id="d7b7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">下一步是取下蓝色的容器。我们必须手动操作，但只能在绿色容器准备好之后。不幸的是，没有办法从Traefik外部单独ping绿色或蓝色容器的健康端点。</p><p id="4d48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我在API中创建了一个<code class="fe nu nv nw nx b">/deployment_color</code>端点。使用它，我们可以ping Traefik负载平衡器，并确定做出响应的容器的颜色。一旦我们得到<code class="fe nu nv nw nx b">green</code>响应，我们就会知道绿色容器已经打开，我们可以继续关闭蓝色容器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1298" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还记得我们如何使用<code class="fe nu nv nw nx b">docker-compose</code>的<code class="fe nu nv nw nx b">-p</code>标志将蓝色和绿色容器隔离到单独的名称空间中吗？现在，我们可以在不影响新部署的绿色容器的情况下，关闭蓝色容器。下面是在我的本地机器上演示的过程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/5ca57d9dde9c19f7289de7a05a84a938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*U2XgbbRazUVuvRk-nYpcAw.jpeg"/></div></figure><p id="4a0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以在放下蓝色容器后，我们将到达我们想要的最终状态:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/106da97db1b6d084e69d2a05ea67e66e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*ReEIk61GADSZay9yoG3r_A.png"/></div></figure><h2 id="f714" class="my mb iq bd mc mz na dn mg nb nc dp mk lf nd ne mm lj nf ng mo ln nh ni mq nj bi translated">清除</h2><p id="62d2" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在剩下唯一要做的事情就是重置<code class="fe nu nv nw nx b">.colors</code>文件中的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0d30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并清理任何悬挂的资源:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="611e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">最终演示</h1><p id="a0e0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">下面是在我从Digital Ocean租用的Linux服务器上运行的重新部署过程的最终演示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/78c97047324ed4b4798a0174828e75c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DLhLfdiS0PPl69T6AvyUpQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没错，就是和文章开头那张一样的GIF。但是现在你有了背景。和欣赏。</p></figure><p id="98e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是您的零停机部署！感谢阅读。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="25fe" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">资源</h1><ul class=""><li id="8949" class="oo op iq ky b kz ms lc mt lf pl lj pm ln pn lr po ou ov ow bi translated"><a class="ae kv" href="https://github.com/RishabhMalviya/ml-deployment-template" rel="noopener ugc nofollow" target="_blank">https://github.com/RishabhMalviya/ml-deployment-template</a></li><li id="c14d" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr po ou ov ow bi translated">https://doc.traefik.io/traefik/routing/overview/<a class="ae kv" href="https://doc.traefik.io/traefik/routing/overview/" rel="noopener ugc nofollow" target="_blank"/></li><li id="981c" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr po ou ov ow bi translated"><a class="ae kv" href="https://doc.traefik.io/traefik/reference/static-configuration/cli/" rel="noopener ugc nofollow" target="_blank">https://doc . trae fik . io/trae fik/reference/static-configuration/CLI/</a></li><li id="49f1" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr po ou ov ow bi translated"><a class="ae kv" href="https://doc.traefik.io/traefik/reference/dynamic-configuration/docker/" rel="noopener ugc nofollow" target="_blank">https://doc . traefik . io/traefik/reference/dynamic-configuration/docker/</a></li><li id="a525" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr po ou ov ow bi translated"><a class="ae kv" href="https://github.com/RishabhMalviya/ml-deployment-template/blob/master/deploy.sh" rel="noopener ugc nofollow" target="_blank">https://github . com/RishabhMalviya/ml-deployment-template/blob/master/deploy . sh</a></li></ul></div></div>    
</body>
</html>