<html>
<head>
<title>You Must Be 64-Bit to Ride This Ferry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您必须是64位才能乘坐此渡轮</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/you-must-be-64-bit-to-ride-this-ferry-61ed45c57a93?source=collection_archive---------0-----------------------#2022-11-23">https://betterprogramming.pub/you-must-be-64-bit-to-ride-this-ferry-61ed45c57a93?source=collection_archive---------0-----------------------#2022-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8fa0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">逆向工程的像素7更新纽约水路应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a3a9d6d412de3314cce65fb8869765ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bl-jHgViHpPQerBR"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">麦克斯韦·里奇韦在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="kw kx ky"><p id="da69" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ir"> TLDR </strong>:如果你有更新的Android设备，不允许你安装NY Waterway，你可以<strong class="lc ir">下载</strong> <a class="ae kv" href="https://drive.google.com/file/d/1k4sC932ZZDepRbTJ3wCLZxJR1NsQMa_s/view?usp=share_link" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">我的修改版应用</strong> </a>。你应该始终小心安装随机应用程序，尤其是来自官方Play Store之外的来源——就像这篇由一个你从未听说过的随机家伙写的文章。如果您想特别小心，您可以提前阅读，看看APK是如何修改的(如果您愿意，甚至可以自己重复这些步骤)。</p></blockquote><p id="6d0b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">2019年，<a class="ae kv" href="https://android-developers.googleblog.com/2019/01/get-your-apps-ready-for-64-bit.html" rel="noopener ugc nofollow" target="_blank"> Google对Play Store中所有新的和更新的应用做出了64位支持要求</a>。从2021年8月开始，不支持64位架构的应用程序将无法在Play Store中用于64位设备。值得注意的是，<a class="ae kv" href="https://android-developers.googleblog.com/2022/10/64-bit-only-devices.html" rel="noopener ugc nofollow" target="_blank">新的Pixel 7和Pixel 7 Pro根本不支持安装仅32位的应用<em class="lb"/></a>。</p><p id="a354" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">对于乘坐哈德逊河渡轮的纽约人来说，这相当不方便，因为在你的手机上提供电子船票的应用程序<a class="ae kv" href="https://play.google.com/store/apps/details?id=co.bytemark.nywaterway" rel="noopener ugc nofollow" target="_blank">NY Waterway</a><em class="lb">实在是太老了</em>。它最近一次发布是在2018年6月，只包含32位架构的原生库……因此，对于新Pixel设备的用户来说，<strong class="lc ir">哈德逊河轮渡</strong>没有电子票给你！</p><p id="7fc1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我在很多年前就开始使用iPhone了，但是当我还是Android用户的时候，我经常修改操作系统和应用程序——安装定制的rom和反编译应用程序。我的一个好朋友有了新的Pixel 7 Pro，并且一直乘坐哈德逊河渡轮，所以他开玩笑地敦促我为他修复这个应用程序。开始了。</p><h1 id="d453" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">窥视应用程序</h1><p id="1606" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">让我们从检查NY Waterway应用程序开始，以确定只有32位的部分，这些部分阻止了它的安装。使用<code class="fe mw mx my mz b"><a class="ae kv" href="https://ibotpeaches.github.io/Apktool/" rel="noopener ugc nofollow" target="_blank">apktool</a></code>，我们可以提取Android应用程序并检查其代码。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="ab72" class="ne ma iq mz b be nf ng l nh ni">$ apktool d ./NYWaterway.apk<br/>I: Using Apktool 2.6.1 on NYWaterway.apk<br/>I: Loading resource table...<br/>I: Decoding AndroidManifest.xml with resources...<br/>I: Loading resource table from file: /Users/joeywatts/Library/apktool/framework/1.apk<br/>I: Regular manifest package...<br/>I: Decoding file-resources...<br/>I: Decoding values */* XMLs...<br/>I: Baksmaling classes.dex...<br/>I: Copying assets and libs...<br/>I: Copying unknown files...<br/>I: Copying original files...<br/>$ cd ./NYWaterway<br/>$ ls -l<br/>total 72<br/>-rw-r--r--    1 joeywatts  staff   8797 Nov 21 18:37 AndroidManifest.xml<br/>-rw-r--r--    1 joeywatts  staff  21382 Nov 21 18:37 apktool.yml<br/>drwxr-xr-x   14 joeywatts  staff    448 Nov 21 18:37 assets<br/>drwxr-xr-x    5 joeywatts  staff    160 Nov 21 18:37 lib<br/>drwxr-xr-x    4 joeywatts  staff    128 Nov 21 18:37 original<br/>drwxr-xr-x  178 joeywatts  staff   5696 Nov 21 18:37 res<br/>drwxr-xr-x   10 joeywatts  staff    320 Nov 21 18:37 smali<br/>drwxr-xr-x   10 joeywatts  staff    320 Nov 21 18:37 unknown</span></pre><p id="ef86" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mw mx my mz b">apktool</code>将输出一个新目录，其中包含从二进制文件反编译成人类可读的基于文本的格式Smali的应用程序字节码、捆绑的资源(比如图像)、本地库和应用程序配置。Smali可能看起来很可怕，但它比你想象的更容易接近——稍后会详细介绍……现在，让我们专注于修复64位兼容性。要做到这一点，我们需要了解正在使用哪些本地库。</p><h1 id="640f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">64位兼容性和本地库</h1><p id="00d5" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">Android应用程序通常是用Java或Kotlin编写的，这两种语言都面向Java虚拟机，这是一种高级抽象，通常可以让您不必担心特定于平台的兼容性。然而，您可以使用<em class="lb"> Java本地接口</em> (JNI)来调用本地的、特定于平台的代码(通常由C或C++等低级语言编译)。如果我们查看<code class="fe mw mx my mz b">libs</code>目录，我们可以看到纽约水道应用程序中包含的本地库。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="7bbb" class="ne ma iq mz b be nf ng l nh ni">$ ls -lR lib/*<br/>lib/armeabi:<br/>total 8352<br/>-rw-r--r--  1 joeywatts  staff   177900 Nov 21 18:37 libdatabase_sqlcipher.so<br/>-rw-r--r--  1 joeywatts  staff  1369284 Nov 21 18:37 libsqlcipher.so<br/>-rw-r--r--  1 joeywatts  staff  2314540 Nov 21 18:37 libsqlcipher_android.so<br/>-rw-r--r--  1 joeywatts  staff   402604 Nov 21 18:37 libstlport_shared.so<br/><br/>lib/armeabi-v7a:<br/>total 2552<br/>-rw-r--r--  1 joeywatts  staff  1303788 Nov 21 18:37 libsqlcipher.so<br/><br/>lib/x86:<br/>total 14616<br/>-rw-r--r--  1 joeywatts  staff  1476500 Nov 21 18:37 libdatabase_sqlcipher.so<br/>-rw-r--r--  1 joeywatts  staff  2246448 Nov 21 18:37 libsqlcipher.so<br/>-rw-r--r--  1 joeywatts  staff  3294132 Nov 21 18:37 libsqlcipher_android.so<br/>-rw-r--r--  1 joeywatts  staff   455740 Nov 21 18:37 libstlport_shared.so</span></pre><p id="3563" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们可以看到<code class="fe mw mx my mz b">lib</code>下有三个目录，分别对应不同的平台:<code class="fe mw mx my mz b">x86</code>、<code class="fe mw mx my mz b">armeabi</code>、<code class="fe mw mx my mz b">armeabi-v7a</code>。这三个平台都是32位的。绝大多数Android设备(基本上所有手机)都使用ARM架构。“armeabi”是遗留的ARM架构(Android不再支持)。ARM V7(“ARM eabi-v7a”)是32位ARM架构。对于64位ARM支持，我们期望有一个<code class="fe mw mx my mz b">arm64-v8a</code>文件夹。</p><p id="26c2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这里的另一个观察是<code class="fe mw mx my mz b">armeabi</code>和<code class="fe mw mx my mz b">x86</code>有四个库，而<code class="fe mw mx my mz b">armeabi-v7a</code>只有一个。对于要由Android应用程序加载的库，它必须调用<code class="fe mw mx my mz b">java.lang.System.loadLibrary</code>或<code class="fe mw mx my mz b">java.lang.Runtime.loadLibrary</code>。在Smali代码中搜索“loadLibrary ”,只能找到一个加载本地库的地方。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="2556" class="ne ma iq mz b be nf ng l nh ni">$ grep -r loadLibrary smali/<br/>smali//net/sqlcipher/database/SQLiteDatabase.smali:    invoke-static {v0}, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V<br/>$ grep loadLibrary -A 2 -B 3 smali/net/sqlcipher/database/SQLiteDatabase.smali<br/>    :try_start_0<br/>    const-string v0, "sqlcipher"<br/><br/>    invoke-static {v0}, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V<br/>    :try_end_0<br/>    .catchall {:try_start_0 .. :try_end_0} :catchall_0</span></pre><p id="8a46" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">唯一由应用程序直接加载的库是“sqlcipher”(<code class="fe mw mx my mz b">libsqlcipher.so</code>)。为某些架构列出的其他库文件要么是未使用的，要么只是<code class="fe mw mx my mz b">libsqlcipher.so</code>的可传递依赖。</p><p id="76f7" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们需要一个64位ARM构建的<code class="fe mw mx my mz b">lib/arm64-v8a</code>中的<code class="fe mw mx my mz b">libsqlcipher.so</code>来使应用程序与新的像素设备兼容。方便的是，SQLCipher是一个开源库。查看用于与本地sqlcipher库交互的高级粘合代码，我们可以看到所使用的库的版本。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="4d3d" class="ne ma iq mz b be nf ng l nh ni">$ grep -ri version smali/net/sqlcipher <br/>smali/net/sqlcipher/database/SQLiteDatabase.smali:.field public static final SQLCIPHER_ANDROID_VERSION:Ljava/lang/String; = "3.5.4"</span></pre><p id="d8b8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在对开源repo做了一些快速挖掘后，我可以看到真正的64位支持<a class="ae kv" href="https://github.com/sqlcipher/android-database-sqlcipher/compare/v3.5.4...v3.5.5" rel="noopener ugc nofollow" target="_blank">是在v3.5.5 </a>中实现的(比NY Waterway中使用的版本更新了一个补丁版本)。我们试试升级吧！</p><h2 id="0f03" class="nj ma iq bd mb nk nl dn mf nm nn dp mj lw no np ml lx nq nr mn ly ns nt mp nu bi translated">将SQLCipher升级到v3.5.5</h2><p id="6183" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">升级过程包括用新版本的代码替换SQLCipher Smali代码和本地库。如果SQLCipher的公共API表面发生显著变化，这将导致问题(例如，如果NY Waterway使用的公共函数更改了签名或被删除，那么用新版本替换它将导致问题)。快速浏览一下从v3.5.4到v3.5.5的变化，这里似乎不会出现问题。我下载了SQLCipher v3.5.5的AAR文件<a class="ae kv" href="https://search.maven.org/artifact/net.zetetic/android-database-sqlcipher/3.5.5/aar" rel="noopener ugc nofollow" target="_blank">，然后用<code class="fe mw mx my mz b">unzip</code>解压。</a></p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="fe24" class="ne ma iq mz b be nf ng l nh ni">$ mkdir ../sqlcipher &amp;&amp; cd ../sqlcipher<br/>$ unzip ~/Downloads/android-database-sqlcipher-3.5.5.aar<br/>Archive:  /Users/joeywatts/Downloads/android-database-sqlcipher-3.5.5.aar<br/>  inflating: AndroidManifest.xml     <br/>   creating: res/<br/>  inflating: classes.jar             <br/>   creating: jni/<br/>   creating: jni/arm64-v8a/<br/>   creating: jni/armeabi/<br/>   creating: jni/armeabi-v7a/<br/>   creating: jni/x86/<br/>   creating: jni/x86_64/<br/>  inflating: jni/arm64-v8a/libsqlcipher.so  <br/>  inflating: jni/armeabi/libsqlcipher.so  <br/>  inflating: jni/armeabi-v7a/libsqlcipher.so  <br/>  inflating: jni/x86/libsqlcipher.so  <br/>  inflating: jni/x86_64/libsqlcipher.so</span></pre><p id="3a3b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">提取之后，我们看到在<code class="fe mw mx my mz b">jni</code>目录下是本地库。它还输出一个包含所有调用本地库的Java类文件的<code class="fe mw mx my mz b">classes.jar</code>文件。这些不是小文件，所以我们需要转换这些代码，以便将其转换成<code class="fe mw mx my mz b">apktool</code>能够理解的格式。</p><p id="8ce8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">Android SDK提供了一个名为<code class="fe mw mx my mz b">d8</code>的命令行工具，可以将<code class="fe mw mx my mz b">jar</code>文件编译成Android字节码(<code class="fe mw mx my mz b">classes.dex</code>文件)。还有一个叫做<code class="fe mw mx my mz b"><a class="ae kv" href="https://github.com/JesusFreke/smali" rel="noopener ugc nofollow" target="_blank">baksmali</a></code>的工具可以将<code class="fe mw mx my mz b">dex</code>文件反编译成<code class="fe mw mx my mz b">smali</code>。将这些步骤结合在一起:</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="1844" class="ne ma iq mz b be nf ng l nh ni">$ export ANDROID_HOME=/Users/joeywatts/Library/Android/sdk<br/>$ $ANDROID_HOME/build-tools/33.0.0/d8 classes.jar \<br/>   --lib $ANDROID_HOME/platforms/android-31/android.jar<br/>$ java -jar ../baksmali.jar dis ./classes.dex</span></pre><p id="0bba" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这会产生一个包含库的Smali代码的<code class="fe mw mx my mz b">out</code>目录。因此，我们可以简单地将<code class="fe mw mx my mz b">smali/net/sqlcipher</code>替换为<code class="fe mw mx my mz b">out/net/sqlcipher</code>，将<code class="fe mw mx my mz b">lib</code>目录替换为<code class="fe mw mx my mz b">jni</code>。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="33c2" class="ne ma iq mz b be nf ng l nh ni">$ rm -r ../NYWaterway/smali/net/sqlcipher ../NYWaterway/lib<br/>$ mv out/net/sqlcipher ../NYWaterway/smali/net/sqlcipher<br/>$ mv jni ../NYWaterway/lib</span></pre><h1 id="a9f4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">构建和运行修改后的应用程序</h1><p id="cebb" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">现在，我们可以重新构建应用程序并对其进行签名，这样它就可以安装在设备上了！</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="27f6" class="ne ma iq mz b be nf ng l nh ni">$ cd ../NYWaterway<br/>$ apktool b .<br/>$ keytool -genkey -v -keystore my-release-key.keystore -alias alias_name \<br/>    -keyalg RSA -keysize 2048 -validity 10000<br/>$ $ANDROID_HOME/build-tools/33.0.0/apksigner sign \<br/>    --ks my-release-key.keystore ./dist/NYWaterway.apk</span></pre><p id="08c4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">安装<code class="fe mw mx my mz b">./dist/NYWaterway.apk</code>后，显示这个画面！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/40e067cdfb3336cbae3e817c60473b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*1gTbmZxmJSdzS9Qa_4Ujhw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">它跑了！我们确实有这个唠叨的弹出窗口😔</p></figure><h1 id="3edf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">增加目标SDK版本</h1><p id="3a8c" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">为了摆脱这个表明应用程序是为旧版本Android构建的弹出窗口，我们需要在<code class="fe mw mx my mz b">apktool.yml</code>中增加目标SDK版本。Play Store不再接受针对SDK版本&lt; 31的应用，所以我选择将其增加到那个版本。</p><p id="edb0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">针对较新版本的Android SDK可能需要更改代码，因为不推荐使用的API在较新的SDK版本中变得不可用。NY Waterway需要针对SDK v31进行一些更改。</p><h2 id="9cc8" class="nj ma iq bd mb nk nl dn mf nm nn dp mj lw no np ml lx nq nr mn ly ns nt mp nu bi translated">更安全的组件导出</h2><blockquote class="kw kx ky"><p id="150e" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kv" href="https://developer.android.com/about/versions/12/behavior-changes-12#exported" rel="noopener ugc nofollow" target="_blank">如果您的应用面向Android 12或更高版本，并且包含使用意图过滤器的活动、服务或广播接收器，您必须为这些应用组件显式声明</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.android.com/about/versions/12/behavior-changes-12#exported" rel="noopener ugc nofollow" target="_blank">android:exported</a></code> <a class="ae kv" href="https://developer.android.com/about/versions/12/behavior-changes-12#exported" rel="noopener ugc nofollow" target="_blank">属性。</a></p></blockquote><p id="cb4e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">有几个活动和一个接收者有<code class="fe mw mx my mz b">&lt;intent-filter&gt;</code> s，需要在<code class="fe mw mx my mz b">AndroidManifest.xml</code>中添加一个<code class="fe mw mx my mz b">android:exported="true"</code>属性。</p><h2 id="009f" class="nj ma iq bd mb nk nl dn mf nm nn dp mj lw no np ml lx nq nr mn ly ns nt mp nu bi translated">待定意向可变性</h2><blockquote class="kw kx ky"><p id="2c70" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kv" href="https://developer.android.com/about/versions/12/behavior-changes-12#pending-intent-mutability" rel="noopener ugc nofollow" target="_blank">如果你的应用面向Android 12，你必须指定你的应用创建的每个</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.android.com/about/versions/12/behavior-changes-12#pending-intent-mutability" rel="noopener ugc nofollow" target="_blank">PendingIntent</a></code> <a class="ae kv" href="https://developer.android.com/about/versions/12/behavior-changes-12#pending-intent-mutability" rel="noopener ugc nofollow" target="_blank">对象的可变性。这一额外要求提高了应用程序的安全性。</a></p></blockquote><p id="dfe1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这一个更棘手，因为它要求我们更改实际的代码(与项目配置或复制库的升级版本相反)。</p><p id="d2ad" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">任何时候创建一个<code class="fe mw mx my mz b">PendingIntent</code>对象，它都需要明确指定<code class="fe mw mx my mz b">FLAG_MUTABLE</code>或<code class="fe mw mx my mz b">FLAG_IMMUTABLE</code>。在以前的SDK版本中，如果没有指定标志，<code class="fe mw mx my mz b">FLAG_MUTABLE</code>是默认的。<code class="fe mw mx my mz b">PendingIntent</code>对象由类上的一组静态方法创建:<code class="fe mw mx my mz b">getActivity</code>、<code class="fe mw mx my mz b">getActivities</code>、<code class="fe mw mx my mz b">getBroadcast</code>或<code class="fe mw mx my mz b">getService</code>。我们可以从搜索这些函数的调用开始。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="08aa" class="ne ma iq mz b be nf ng l nh ni">$ grep -r -E "PendingIntent;-&gt;(getActivity|getActivities|getBroadcast|getService)" smali<br/>smali/android/support/v4/f/a/ac.smali:    invoke-static {p1, v2, v0, v2}, Landroid/app/PendingIntent;-&gt;getBroadcast(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/firebase/iid/r.smali:    invoke-static {p0, p1, v0, p4}, Landroid/app/PendingIntent;-&gt;getBroadcast(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/firebase/iid/m.smali:    invoke-static {p0, v2, v0, v3}, Landroid/app/PendingIntent;-&gt;getBroadcast(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/firebase/messaging/c.smali:    invoke-static {v0, v2, v1, v3}, Landroid/app/PendingIntent;-&gt;getActivity(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/android/gms/common/m.smali:    invoke-static {p1, p3, v0, v1}, Landroid/app/PendingIntent;-&gt;getActivity(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/android/gms/common/api/GoogleApiActivity.smali:    invoke-static {p0, v0, v1, v2}, Landroid/app/PendingIntent;-&gt;getActivity(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/android/gms/c/cbx.smali:    invoke-static {v1, v2, v0, v3}, Landroid/app/PendingIntent;-&gt;getActivity(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/android/gms/c/cbx.smali:    invoke-static {v2, v7, v1, v7}, Landroid/app/PendingIntent;-&gt;getBroadcast(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/android/gms/c/v.smali:    invoke-static {v0, v1, v2, v3}, Landroid/app/PendingIntent;-&gt;getActivity(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/android/gms/c/bj.smali:    invoke-static {v1, p2, v0, v2}, Landroid/app/PendingIntent;-&gt;getActivity(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/android/gms/c/byd.smali:    invoke-static {v1, v4, v0, v4}, Landroid/app/PendingIntent;-&gt;getBroadcast(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/>smali/com/google/android/gms/c/mr.smali:    invoke-static {v1, v3, v0, v3}, Landroid/app/PendingIntent;-&gt;getBroadcast(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;</span></pre><p id="0650" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">不少！幸运的是，大多数都是相当简单的变化。我们只需要先了解一点字节码。</p><h2 id="d261" class="nj ma iq bd mb nk nl dn mf nm nn dp mj lw no np ml lx nq nr mn ly ns nt mp nu bi translated">理解Smali</h2><p id="af10" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated"><code class="fe mw mx my mz b">invoke-static</code>字节码指令将一系列寄存器作为参数传递给静态函数。静态函数的符号看起来像<code class="fe mw mx my mz b">Landroid/app/PendingIntent;-&gt;getBroadcast(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;</code>,它是完全限定类名和函数签名的直接翻译。它以类名<code class="fe mw mx my mz b">Landroid/app/PendingIntent;</code>(或普通Java语法中的<code class="fe mw mx my mz b">android.app.PendingIntent</code>)开始。然后是函数名(<code class="fe mw mx my mz b">-&gt;getBroadcast</code>)以及参数和返回类型。<code class="fe mw mx my mz b">Landroid/content/Context;ILandroid/content/Intent;I</code>为参数，可拆分为四个参数:<code class="fe mw mx my mz b">Landroid/content/Context;</code>(<code class="fe mw mx my mz b">android.content.Context</code>)<code class="fe mw mx my mz b">I</code>(<code class="fe mw mx my mz b">int</code>)<code class="fe mw mx my mz b">Landroid/content/Intent;</code>(<code class="fe mw mx my mz b">android.content.Intent</code>)<code class="fe mw mx my mz b">I</code>(<code class="fe mw mx my mz b">int</code>)。最后，右括号后是返回类型:<code class="fe mw mx my mz b">Landroid/app/PendingIntent;</code>。</p><p id="a7e3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">因此，上述函数的<code class="fe mw mx my mz b">invoke-static {v1, v2, v3, v4}</code>将通过<code class="fe mw mx my mz b">v1</code>作为<code class="fe mw mx my mz b">Context</code>、<code class="fe mw mx my mz b">v2</code>作为第一个<code class="fe mw mx my mz b">int</code>、<code class="fe mw mx my mz b">v3</code>作为<code class="fe mw mx my mz b">Intent</code>、<code class="fe mw mx my mz b">v4</code>作为<code class="fe mw mx my mz b">int</code>。对于这些<code class="fe mw mx my mz b">PendingIntent</code>API，<code class="fe mw mx my mz b">flags</code>总是最后一个参数(<code class="fe mw mx my mz b">int</code>)，所以我们只需要确保该值总是设置了<code class="fe mw mx my mz b">FLAG_MUTABLE</code>或<code class="fe mw mx my mz b">FLAG_IMMUTABLE</code>。<a class="ae kv" href="https://developer.android.com/reference/android/app/PendingIntent#FLAG_MUTABLE" rel="noopener ugc nofollow" target="_blank"> Android SDK文档</a>揭示<code class="fe mw mx my mz b">FLAG_MUTABLE</code>的值为<code class="fe mw mx my mz b">0x02000000</code><code class="fe mw mx my mz b">FLAG_IMMUTABLE</code>为<code class="fe mw mx my mz b">0x04000000</code>。在大多数情况下，最后一个参数被指定为一个局部变量寄存器(<code class="fe mw mx my mz b">v#</code>)，该寄存器被初始化为一个常数值(如<code class="fe mw mx my mz b">const/high16 v3, 0x8000000</code>或<code class="fe mw mx my mz b">const/4 v4, 0x0</code>)。在这些情况下，我们可以简单地检查<code class="fe mw mx my mz b">FLAG_MUTABLE</code>或<code class="fe mw mx my mz b">FLAG_IMMUTABLE</code>是否被设置，如果没有，就更新常量。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="75af" class="ne ma iq mz b be nf ng l nh ni">-    const/high16 v3, 0x8000000<br/>+    const/high16 v3, 0xA000000<br/><br/>     invoke-static {v1, v2, v0, v3}, Landroid/app/PendingIntent;-&gt;getActivity(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/><br/># you may need to change from const/4 to const/high16 to specify the flag<br/># const/4 is a loading a signed 4-bit integer (seen used to load 0x0).<br/># const/high16 loads the high 16-bits from a value (the low 16-bits must be 0)<br/><br/>-    const/4 v4, 0x0<br/>+    const/high16 v4, 0x2000000</span></pre><p id="90ca" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">有一种情况(在<code class="fe mw mx my mz b">com/google/firebase/iid/r.smali</code>中)是<code class="fe mw mx my mz b">flags</code>作为参数(<code class="fe mw mx my mz b">p#</code>寄存器)传入的。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="408c" class="ne ma iq mz b be nf ng l nh ni">.method private static a(Landroid/content/Context;ILjava/lang/String;Landroid/content/Intent;I)Landroid/app/PendingIntent;<br/>    .locals 2<br/><br/>    new-instance v0, Landroid/content/Intent;<br/><br/>    const-class v1, Lcom/google/firebase/iid/FirebaseInstanceIdInternalReceiver;<br/><br/>    invoke-direct {v0, p0, v1}, Landroid/content/Intent;-&gt;&lt;init&gt;(Landroid/content/Context;Ljava/lang/Class;)V<br/><br/>    invoke-virtual {v0, p2}, Landroid/content/Intent;-&gt;setAction(Ljava/lang/String;)Landroid/content/Intent;<br/><br/>    const-string v1, "wrapped_intent"<br/><br/>    invoke-virtual {v0, v1, p3}, Landroid/content/Intent;-&gt;putExtra(Ljava/lang/String;Landroid/os/Parcelable;)Landroid/content/Intent;<br/><br/>    invoke-static {p0, p1, v0, p4}, Landroid/app/PendingIntent;-&gt;getBroadcast(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;<br/><br/>    move-result-object v0<br/><br/>    return-object v0<br/>.end method</span></pre><p id="a53c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如有必要，更新<code class="fe mw mx my mz b">p4</code>以设置<code class="fe mw mx my mz b">FLAG_MUTABLE</code>位比跟踪此功能的所有引用直到指定<code class="fe mw mx my mz b">flags</code>更容易。为此，我们需要手工编写一些字节码！等效的类似Java的代码如下所示:</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="9cd9" class="ne ma iq mz b be nf ng l nh ni">if (p4 &amp; (FLAG_IMMUTABLE | FLAG_MUTABLE) == 0) {<br/>    p4 |= FLAG_MUTABLE;<br/>}</span></pre><p id="27ad" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mw mx my mz b">FLAG_IMMUTABLE | FLAG_MUTABLE</code>是常数<code class="fe mw mx my mz b">0x6000000</code>，我们可以用<code class="fe mw mx my mz b">const/high16</code>指令将它加载到寄存器中。我们可以使用<code class="fe mw mx my mz b">and-int</code>指令与<code class="fe mw mx my mz b">p4</code>进行按位AND运算。<code class="fe mw mx my mz b">if-nez</code>如果寄存器不等于零，允许您跳转到标签。最后，<code class="fe mw mx my mz b">or-int</code>让我们对两个寄存器进行按位“或”运算。Google有关于Dalvik字节码的<a class="ae kv" href="https://source.android.com/docs/core/runtime/dalvik-bytecode" rel="noopener ugc nofollow" target="_blank">文档，这对发现指令及其语法很有用。将所有这些放在一起，我们得到下面的代码，它可以在调用<code class="fe mw mx my mz b">getBroadcast</code>之前插入。</a></p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="8ad6" class="ne ma iq mz b be nf ng l nh ni">const/high16 v3, 0x6000000 # v3 = FLAG_IMMUTABLE | FLAG_MUTABLE<br/>and-int v2, p4, v3         # v2 = p4 &amp; v3<br/>if-nez v2, :cond_0         # if (v2 != 0) { goto :cond_0; }<br/>const/high16 v3, 0x2000000 # v3 = FLAG_MUTABLE<br/>or-int p4, p4, v3          # p4 = p4 | v3<br/>:cond_0</span></pre><p id="1813" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">最后，函数顶部的<code class="fe mw mx my mz b">.locals 2</code>指令表示应该为此函数分配两个局部变量寄存器(<code class="fe mw mx my mz b">v0</code>和<code class="fe mw mx my mz b">v1</code>)。因为我们在上面的代码中又用了两个(<code class="fe mw mx my mz b">v2</code>和<code class="fe mw mx my mz b">v3</code>)，所以需要把这个改成<code class="fe mw mx my mz b">.locals 4</code>。</p><h2 id="5d4f" class="nj ma iq bd mb nk nl dn mf nm nn dp mj lw no np ml lx nq nr mn ly ns nt mp nu bi translated">文件系统权限更改</h2><blockquote class="kw kx ky"><p id="d99f" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kv" href="https://developer.android.com/about/versions/nougat/android-7.0-changes#permfilesys" rel="noopener ugc nofollow" target="_blank">私有文件的文件权限不应再被所有者放松，而试图使用</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.android.com/about/versions/nougat/android-7.0-changes#permfilesys" rel="noopener ugc nofollow" target="_blank">MODE_WORLD_READABLE</a></code> <a class="ae kv" href="https://developer.android.com/about/versions/nougat/android-7.0-changes#permfilesys" rel="noopener ugc nofollow" target="_blank">和/或</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.android.com/about/versions/nougat/android-7.0-changes#permfilesys" rel="noopener ugc nofollow" target="_blank">MODE_WORLD_WRITEABLE</a></code> <a class="ae kv" href="https://developer.android.com/about/versions/nougat/android-7.0-changes#permfilesys" rel="noopener ugc nofollow" target="_blank">这样做，将会触发</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.android.com/about/versions/nougat/android-7.0-changes#permfilesys" rel="noopener ugc nofollow" target="_blank">SecurityException</a></code> <a class="ae kv" href="https://developer.android.com/about/versions/nougat/android-7.0-changes#permfilesys" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="7245" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在<code class="fe mw mx my mz b">com/google/android/gms/ads/identifier/AdvertisingIdClient.smali</code>有一些使用<code class="fe mw mx my mz b">MODE_WORLD_READABLE</code>的<code class="fe mw mx my mz b">SharedPreferences</code> API用法。这很容易解决，因为这是一个从切换到<code class="fe mw mx my mz b">MODE_WORLD_READABLE</code> ( <code class="fe mw mx my mz b">0x1</code>)到<code class="fe mw mx my mz b">MODE_PRIVATE</code> ( <code class="fe mw mx my mz b">0x0</code>)的问题。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="c036" class="ne ma iq mz b be nf ng l nh ni">--- a/smali/com/google/android/gms/ads/identifier/AdvertisingIdClient.smali<br/>+++ b/smali/com/google/android/gms/ads/identifier/AdvertisingIdClient.smali<br/>@@ -93,7 +93,7 @@<br/> <br/>     const-string v4, "google_ads_flags"<br/> <br/>-    const/4 v5, 0x1<br/>+    const/4 v5, 0x0<br/> <br/>     invoke-virtual {v2, v4, v5}, Landroid/content/Context;-&gt;getSharedPreferences(Ljava/lang/String;I)Landroid/content/SharedPreferences;</span></pre><h2 id="e211" class="nj ma iq bd mb nk nl dn mf nm nn dp mj lw no np ml lx nq nr mn ly ns nt mp nu bi translated">Apache HTTP客户端弃用</h2><blockquote class="kw kx ky"><p id="11a0" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#apache-p" rel="noopener ugc nofollow" target="_blank">在Android 6.0中，我们移除了对Apache HTTP客户端的支持。从Android 9开始，这个库从bootclasspath中移除，默认情况下对应用程序不可用。</a></p></blockquote><p id="7312" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">NY Waterway使用的是Android版本的Apache HTTP客户端，但是对它的修复非常简单——只是对<code class="fe mw mx my mz b">AndroidManifest.xml</code>的另一个改变。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="9241" class="ne ma iq mz b be nf ng l nh ni">diff --git a/AndroidManifest.xml b/AndroidManifest.xml<br/>index 1490d73..39ccbf3 100644<br/>--- a/AndroidManifest.xml<br/>+++ b/AndroidManifest.xml<br/>@@ -16,6 +16,7 @@<br/>     &lt;permission android:name="co.bytemark.nywaterway.permission.C2D_MESSAGE" android:protectionLevel="signature"/&gt;<br/>     &lt;uses-permission android:name="co.bytemark.nywaterway.permission.C2D_MESSAGE"/&gt;<br/>     &lt;application android:allowBackup="false" android:icon="@drawable/icon" android:label="@string/app_name" android:name="co.bytemark.nywaterway2.core.NYWWApp" android:theme="@style/AppTheme"&gt;<br/>+        &lt;uses-library android:name="org.apache.http.legacy" android:required="false" /&gt;<br/>         &lt;meta-data android:name="com.google.android.gms.version" android:value="@integer/google_play_services_version"/&gt;<br/>         &lt;receiver android:exported="false" android:label="NetworkConnection" android:name="co.bytemark.android.sdk.BytemarkSDK$ConnectionChangeReceiver"&gt;<br/>             &lt;intent-filter&gt;</span></pre><h2 id="88c8" class="nj ma iq bd mb nk nl dn mf nm nn dp mj lw no np ml lx nq nr mn ly ns nt mp nu bi translated">默认情况下启用网络TLS</h2><blockquote class="kw kx ky"><p id="3d9d" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#tls-enabled" rel="noopener ugc nofollow" target="_blank">如果你的app目标是Android 9或更高版本，</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#tls-enabled" rel="noopener ugc nofollow" target="_blank">isCleartextTrafficPermitted()</a></code> <a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#tls-enabled" rel="noopener ugc nofollow" target="_blank">方法默认返回</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#tls-enabled" rel="noopener ugc nofollow" target="_blank">false</a></code> <a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#tls-enabled" rel="noopener ugc nofollow" target="_blank">。如果您的应用需要为特定的域启用明文，您必须在应用的网络安全配置中将这些域的</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#tls-enabled" rel="noopener ugc nofollow" target="_blank">cleartextTrafficPermitted</a></code> <a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#tls-enabled" rel="noopener ugc nofollow" target="_blank">明确设置为</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#tls-enabled" rel="noopener ugc nofollow" target="_blank">true</a></code> <a class="ae kv" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#tls-enabled" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="87ff" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">由于这项新的安全功能，网络请求失败。使应用程序兼容的最简单的方法就是对<code class="fe mw mx my mz b">AndroidManifest.xml</code>做另一个改变，添加<code class="fe mw mx my mz b">android:usesCleartextTraffic="true"</code>属性。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="4614" class="ne ma iq mz b be nf ng l nh ni">diff --git a/AndroidManifest.xml b/AndroidManifest.xml<br/>index 39ccbf3..69b4aa7 100644<br/>--- a/AndroidManifest.xml<br/>+++ b/AndroidManifest.xml<br/>@@ -15,7 +15,7 @@<br/>     &lt;uses-permission android:name="com.google.android.c2dm.permission.RECEIVE"/&gt;<br/>     &lt;permission android:name="co.bytemark.nywaterway.permission.C2D_MESSAGE" android:protectionLevel="signature"/&gt;<br/>     &lt;uses-permission android:name="co.bytemark.nywaterway.permission.C2D_MESSAGE"/&gt;<br/>-    &lt;application android:allowBackup="false" android:icon="@drawable/icon" android:label="@string/app_name" android:name="co.bytemark.nywaterway2.core.NYWWApp" android:theme="@style/AppTheme"&gt;<br/>+    &lt;application android:allowBackup="false" android:icon="@drawable/icon" android:label="@string/app_name" android:name="co.bytemark.nywaterway2.core.NYWWApp" android:theme="@style/AppTheme" android:usesCleartextTraffic="true"&gt;<br/>         &lt;uses-library android:name="org.apache.http.legacy" android:required="false" /&gt;<br/>         &lt;meta-data android:name="com.google.android.gms.version" android:value="@integer/google_play_services_version"/&gt;<br/>         &lt;receiver android:exported="false" android:label="NetworkConnection" android:name="co.bytemark.android.sdk.BytemarkSDK$ConnectionChangeReceiver"&gt;</span></pre><h1 id="39ca" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="d282" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">在做了以上所有的修改后，应用程序成功运行，没有一个烦人的弹出窗口说它是为旧版本的Android构建的！</p><p id="ade6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">有点出乎意料的是，使它与较新的目标SDK版本一起工作比实际修复64位问题要复杂得多，但最终，一切都只是代码，代码没有什么可怕的…</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="033f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><em class="lb">想要连接？在</em> <a class="ae kv" href="https://twitter.com/joeywatts96" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> Twitter </em> </a> <em class="lb">或</em><a class="ae kv" href="https://www.linkedin.com/in/jwatts96/" rel="noopener ugc nofollow" target="_blank"><em class="lb">LinkedIn</em></a><em class="lb">上给我发消息！</em></p></div></div>    
</body>
</html>