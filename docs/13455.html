<html>
<head>
<title>A Deep Dive Into the 3 React Pitfalls That Developers Fall Into</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究开发人员陷入的3个React陷阱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-the-3-react-pitfalls-that-developers-fall-into-41b5109870e6?source=collection_archive---------7-----------------------#2022-08-29">https://betterprogramming.pub/a-deep-dive-into-the-3-react-pitfalls-that-developers-fall-into-41b5109870e6?source=collection_archive---------7-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="57d1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帮助您了解代码是好是坏的提示</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/97af892db5a074b8447f0c5fb2964b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6Ot3k6dOOuj9aaqovqO1Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作为软件开发人员，您会不时看到代码的准确表示</p></figure><p id="9d7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我曾经指导过初级开发人员，并直接了解他们通常面临的挑战。因此，我列出了一些常见的错误，可能会对刚刚起步的低年级学生，甚至是有一点经验、希望提高自己知识的人有所帮助！</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="b89d" class="lw lx iq ls b gy ly lz l ma mb"><a class="ae mc" href="#1711" rel="noopener ugc nofollow">1. Failing To Pass a Valid Key to Element Arrays</a></span><span id="ca96" class="lw lx iq ls b gy md lz l ma mb"><a class="ae mc" href="#7e98" rel="noopener ugc nofollow">2. Mutating the State</a></span><span id="b22b" class="lw lx iq ls b gy md lz l ma mb"><a class="ae mc" href="#0ac7" rel="noopener ugc nofollow">3. Ending Up With Huge Components</a></span></pre><p id="8ef8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，我们走吧。</p><h1 id="1711" class="me lx iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">1.无法向元素数组传递有效的键</h1><p id="7e02" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">您可能已经听说过这个:当映射一个数组以将其转换为React元素之一时，您必须为每个子元素提供一个惟一的键。</p><p id="3ae9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但这是为什么呢？而且一直都是这样吗？要回答这个问题，我们必须先简单地谈谈React是如何工作的。</p><p id="ca79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每当你的应用程序中有状态或道具更新时，React都会运行其diffing算法，将旧的DOM树与新的进行比较。这是它学习什么改变了，以及最终什么需要被重新渲染的方式。</p><p id="e05b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着它遍历每个节点，并检查更新后是否有任何参数发生更改，然后在其子节点上重复相同的过程。假设我们有这两棵树:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">老树在上，新树在下</p></figure><p id="f12c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以看到，更新在孩子的底部加了一个节点:这样就好了！React处理得很好，因为它可以理解前两个节点没有改变，还有第三个新节点。然而，让我们来看一个不同的场景:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">所有三个节点都被视为新节点</p></figure><p id="ef65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">麻烦来了:更新在子节点上添加了一个新节点。当React按顺序比较每个子项时，它永远不会找到匹配项。这意味着它也将重新创建那两个没有改变的孩子。</p><p id="9b2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，子元素只是DOM元素，所以您可以说这没什么大不了的，但是当每个子元素下面都有一棵树时，这可能是一个更大的性能问题，所有这些都需要重新创建。或者当有许多孩子需要重新创建时。</p><p id="19b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不仅如此！因为React不能唯一地识别每个孩子，所以在某些情况下，它可能会弄乱东西，混淆孩子的状态。这里有一个<a class="ae mc" href="https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key" rel="noopener ugc nofollow" target="_blank">例子</a>你可以看看:在第一个输入中写一些东西，然后“添加新的开始。”</p><p id="2338" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是钥匙发挥作用的地方。让我们来看看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">React知道只有一个新节点</p></figure><p id="c0eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了。通过键，React现在可以识别现有的孩子，第二个和第三个，它知道第一个孩子在聚会上迟到了。它不会重新创建现有的子对象，因为它可以正确地匹配这些子对象。</p><p id="0628" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是如果我把索引作为一个键呢？React默认会这样做。它将伴随数组的索引，直到您提供一个实际的唯一键。它仍然会警告您这个问题，以便您可以及时处理它。那么，为什么索引不是有效的键呢？让我们看一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="851a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，第一个孩子没有被识别为新孩子，因为键匹配。但是，它的内容发生了变化，因此React将重新创建节点。其他孩子也一样。此外，您可能会遇到我们之前讨论过的相同的状态混淆问题。</p><p id="3d96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不过，有一个例外，使用索引应该没问题，那就是当你确定子元素不会被重新排序时。尽管如此，我还是建议您将它绑定到一个惟一的id，并选择使用索引作为最后的手段。</p><p id="f708" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唷，太多了。让我们进入下一个！</p><h1 id="7e98" class="me lx iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">2.改变状态</h1><p id="c293" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">同样，我也会解释这一点的原因和方法。前一点的解释给了我们一个良好的开端。</p><p id="945d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如前所述，应用程序的渲染是由道具和状态更新触发的。但是React如何知道一个状态何时被更新呢？那是我们的工作！每次我们通过预期的API设置状态时，React都知道。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8035" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只要您需要处理原始数据，事情就相当简单。然而，当您必须处理非原始数据时，它们会变得混乱，这是我经常看到出错的地方。看看这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="250b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里怎么了？我们知道必须使用React的<code class="fe nc nd ne ls b">setSandwich()</code>函数来触发重新渲染。但这还不够。我们还必须确保不改变状态，以便新旧版本可以进行比较(还记得区别吗？).反应状态是唯一不可变的。这意味着您必须在每次想要更改它时覆盖它的值。</p><p id="e91a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React在这种情况下看不到变化，因为突变导致两个版本相等。假设您在一个div中显示三明治内容:它不会被更新。因此，你仍然会看到洋葱渲染(呸！).</p><p id="4d3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，我们该如何解决这个问题呢？让我们看看下面的正确形式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2874" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是非常不同的事情。我们设置了一个新的对象，它带来了前一个状态的值(注意我们是如何从setSandwich回调中获得它的),但也覆盖了onions属性。渲染现在将正确工作，因为我们实例化了一个新的对象来设置，同时保持旧的状态不变。</p><p id="724f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，让我们来看一个关于数组的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="81b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样的故事:改变数组可以防止React注意到它的变化。现在让我们用正确的方式来做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7844" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样的原则:我们设置一个新实例化的数组，保持旧数组不变。但是，我们还没有完成！对于那些喜欢打字稿的伟大的人，我有一个技巧可以帮助你在未来避免错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="50ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，TypeScript附带了一个方便的<code class="fe nc nd ne ls b">ReadonlyArray</code>类型，它省略了我们想要避免的所有可变属性。现在写那个<code class="fe nc nd ne ls b">push()</code>会抛出一个TSLint错误！还有<code class="fe nc nd ne ls b">ReadonlyMap</code>和<code class="fe nc nd ne ls b">ReadonlySet</code>类型，你可以用同样的方式使用。</p><h1 id="0ac7" class="me lx iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">3.最终得到巨大的组件</h1><p id="adf6" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">你经常看到这种情况。你需要做一点小小的改变。打开目标组件，500行代码扑面而来。你80%的精力都花在了寻找你想要的东西上，同时尽量不去破坏其他东西。</p><p id="ea9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我会给你一些提示，告诉你如何解决这个问题，整理你的组件。首先，慢慢来。就当是写论文吧。你做你的事；你把一切都写下来。然后，只有当你完成后，你才再读一遍，检查语法错误等等。</p><p id="fe87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，当你开始写下你的组件时，不要试图立刻优化代码，因为你会在一百次之后重新做一遍。</p><p id="3157" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦你认为组件已经准备好了，你就可以看看你已经得到了什么，并考虑哪些可以改进。这就是你要找的东西:</p><p id="e58d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关注点分离。这始终是一个很好的经验法则。一个组件不应该感觉它在做太多的事情。你的组件使用了很多钩子吗？你的JSX超过几百行了吗？然后你可能要把事情分解。</p><p id="5c49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">试着在视觉上把它分成更小的部分。你应该问自己，“这属于这里吗？”或者“我的组件应该关心知道这些吗？”。这件事没有唯一正确的方法，所以做你觉得最好的，放轻松。一旦你完成了，继续把代码分解成更小的组件。</p><p id="2a49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">利用钩子。当我进入一个组件时，我主要关注的是返回的内容。也就是JSX。这是组件的主要目的，呈现某种UI。</p><p id="5fe2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，通常，为了实现所需的UI，我们必须管理来自后端、来自本地存储的数据、与UI相关的状态和逻辑(表单、导航、样式、动画)等等。</p><p id="6e80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我们还是要把主要精力放在JSX上，对吗？我的下一个建议是尽可能减少组件中的其他内容。</p><p id="d411" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有一些获取请求吗？您可能希望将它们放在单独的文件中，作为javascript函数或通过创建自己的钩子。或者，可能更好的是，您可以利用像<a class="ae mc" href="https://www.npmjs.com/package/@reduxjs/toolkit" rel="noopener ugc nofollow" target="_blank"> redux </a>(带RTK查询)或<a class="ae mc" href="https://www.npmjs.com/package/react-query" rel="noopener ugc nofollow" target="_blank"> react-query </a>这样的库。</p><p id="033c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有可能涉及到国家管理的任何形式的逻辑吗？将所有相关的东西外推到一个定制的钩子中，或者尝试一下。</p><p id="fd12" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当管理复杂的状态结构时，您可能想要考虑<code class="fe nc nd ne ls b"><a class="ae mc" href="https://it.reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer(</a>)</code>而不是<code class="fe nc nd ne ls b">useState()</code>。这是您可以推断您的状态管理的另一种方式，并给您带来其他好处。</p><p id="3593" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以你明白了。我经常喜欢制作钩子或使用别人的，因为你可以发挥创意，做任何事情，同时保持你的组件整洁干净。</p><p id="5b15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我现在要做的是给你一个这个过程的现实例子，把我刚刚给你的大部分建议付诸实践:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这是我们开始使用的示例组件</p></figure><p id="059c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我虚构的比萨店的页面。您可以通过表单选择披萨和饮料，然后提交您的订单。很棒，是吧？</p><p id="6c68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，这只是一个例子。因此，组件并不冗长或复杂，但为了演示起见，我们仍将应用我们的原则。如您所见，我们还将页眉和页脚与表单编码在一起，因此我们肯定会进行一些重构。</p><p id="191c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同时，表单逻辑和获取请求都被直接写入组件中，所以我们还可以改进这一点。</p><p id="60b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">像魔术一样！现在更容易理解发生了什么</p></figure><p id="ef54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我所做的:首先，我将页眉、表单和页脚移动到三个独立的组件中。说到表单，你看到的道具允许它像以前一样和父组件说话。这是最简单的部分。现在，让我们来看看新的挂钩。</p><p id="f603" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我已经将所有的逻辑导出到两个不同的钩子中:<code class="fe nc nd ne ls b">useForm()</code>负责表单的状态和事件管理，而<code class="fe nc nd ne ls b">useApi()</code>负责表单提交和发布。下面是它们的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nc nd ne ls b">useForm()</code>钩子处理表单的值状态和事件</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">useApi()钩子提供post函数并返回相应的响应</p></figure><p id="a563" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我按照关注点分离原则分离了逻辑。除此之外，代码几乎和以前一样，因此这也不是一个昂贵的重构任务。</p><p id="eff8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，各位，我想我们可以结束了。我希望它不会太无聊，并教会你一些新的东西。很快我将会写一篇关于React hooks的文章，所以你会感兴趣吗</p><p id="b77b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读，敬请期待更多内容。再见。</p><h1 id="2dc2" class="me lx iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">参考</h1><ul class=""><li id="a542" class="nf ng iq kx b ky mv lb mw le nh li ni lm nj lq nk nl nm nn bi translated"><a class="ae mc" href="https://en.reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">https://en.reactjs.org/docs/reconciliation.html</a></li><li id="ebd5" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated"><a class="ae mc" href="https://en.reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">https://en.reactjs.org/docs/hooks-reference.html#usestate</a></li><li id="0437" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated"><a class="ae mc" href="https://en.reactjs.org/docs/state-and-lifecycle.html#using-state-correctly" rel="noopener ugc nofollow" target="_blank">https://en . react js . org/docs/state-and-life cycle . html # using-state-correctly</a></li><li id="83d7" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated">【https://en.wikipedia.org/wiki/Separation_of_concerns T4】</li><li id="8d9b" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated"><a class="ae mc" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank">https://redux-toolkit.js.org/</a></li><li id="b105" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated"><a class="ae mc" href="https://tanstack.com/query/v4" rel="noopener ugc nofollow" target="_blank">https://tanstack.com/query/v4</a></li><li id="301a" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated"><a class="ae mc" href="https://www.npmjs.com/package/formik" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/formik</a></li><li id="fcbe" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated"><a class="ae mc" href="https://it.reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">https://it.reactjs.org/docs/hooks-reference.html#usereducer</a></li><li id="74bf" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated"><a class="ae mc" href="https://en.reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">https://en.reactjs.org/docs/hooks-custom.html</a></li></ul><h1 id="8737" class="me lx iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">封面图像</h1><ul class=""><li id="894a" class="nf ng iq kx b ky mv lb mw le nh li ni lm nj lq nk nl nm nn bi translated"><a class="ae mc" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯凯</a>在<a class="ae mc" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></li></ul></div></div>    
</body>
</html>