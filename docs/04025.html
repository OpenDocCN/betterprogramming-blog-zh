<html>
<head>
<title>Unit Testing Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-best-practices-9bceeafe6edf?source=collection_archive---------1-----------------------#2020-03-19">https://betterprogramming.pub/unit-testing-best-practices-9bceeafe6edf?source=collection_archive---------1-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d759" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可以帮助您编写更好的测试的实用建议列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b5c0392f51e8f89cc7a40fe4d8457c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YHAAP3SCgoQzlDka"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/IiEFmIXZWSw" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="1798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">免责声明</strong>:这是一组我认为在编写单元测试时非常有用的东西。我称它们为<em class="lv">最佳实践</em>，因为它们允许我编写好的、高质量的测试，更容易阅读、更易维护，并且更好地描述业务需求。</p><p id="85f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些点可能是主观的，你可能有其他的意见或有更多的项目。那很好。不要犹豫，把你的观点写在评论里。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9ee3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">开发过程中的测试</h1><p id="4c0c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">测试在开发过程中非常重要。他们给你很多好处:</p><ul class=""><li id="b9f9" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">测试验证需求。这表明您的实现正确地解决了问题。</li><li id="c3ad" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">他们在早期阶段识别缺陷。越早发现问题越好，因为修复起来更快更便宜。通过编写测试在开发过程中发现缺陷是最好的时机。</li><li id="9cd3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">提高可维护性。要编写测试，源代码应该是可测试的，这意味着它更易于维护。可测试代码通常是良好解耦的，这增加了可读性。这也迫使更好的架构。</li><li id="2125" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">让重构更安全。测试允许大的变化，并验证没有引入回归。</li><li id="023f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">有助于代码审查。因为测试清楚地表明了作者的意图，所以首先验证测试做了解决方案应该做的事情更容易。这将让我们更深入地了解实际做了些什么，使回顾变得更简单。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2430" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">不错的测试</h1><p id="61dd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们将从定义什么可以被认为是“好的测试”开始。</p><p id="f61f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，一个好的测试是:</p><ul class=""><li id="6683" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">值得信赖。这意味着它只有在被破坏的情况下才会失败。如果测试有时会失败，那么它就是不可靠的，不能称之为好的测试。</li><li id="be3d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">可读/可维护。从阅读一个测试，应该清楚它测试什么，如何做。它不应该有样板或棘手的调整状态或控制。</li><li id="e1ce" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">应该验证一个用例。这与单一责任原则有关。如果一个测试验证了多个案例，那么如果它失败了，我们不能确切地说出原因。一个好的测试验证一个用例，当它失败时，我们立即知道哪里出错了。</li><li id="f63c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">孤立无援。该测试不应影响其他测试。这特别意味着测试不应该共享一个全局状态。如果测试没有被隔离，那么它们的执行顺序会导致意想不到的结果。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="152d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">良好测试过程的最佳实践</h1><p id="f90d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">第二组最佳实践是关于一个好的测试过程。</p><p id="d9f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果满足以下条件，测试流程就是好的:</p><h2 id="3f3f" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">它是自动化的(在配置项上)</h2><p id="b537" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">测试只有在及时执行的情况下才有用。最好的选择是使用持续集成，例如，在每次提交时，持续运行您的测试。否则，很容易忘记运行测试，这使得它们没有用。</p><h2 id="a20a" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">测试是在开发期间编写的，而不是在开发之后</h2><p id="e00c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">TDD(在编写代码之前编写测试)很好，但是从一开始，可能就不太容易预见模块应该是什么样子，类的结构是什么，等等。</p><p id="ada4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果一个人不能先写测试，那也没关系。重要的是在开发的早期建立测试，不要拖到最后。</p><p id="dc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是测试帮助你写出干净的代码。分离关注点，使用接口来隐藏实现细节或一些特定于平台的细节。如果您延迟编写测试，您会发现自己处于这样一个位置，有些代码是不可测试的，并且很容易修改它。</p><h2 id="11ee" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated"><strong class="ak">为发现的每个缺陷/案例增加测试</strong></h2><p id="693a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在编写测试时，你不需要考虑所有理论上可能发生的情况(我们将在下面详细讨论)。</p><p id="258d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的事情是反映业务用例，并为发现的任何其他需求或缺陷不断添加测试。尤其是对于缺陷。因为这样，您可以在修复之前验证是否有案例失败，并在修复之后检查测试是否真正通过。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8b60" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">测试最佳实践</h1><p id="1002" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这些是编写单元测试的一般理论实践。他们有助于对测试过程有一个大致的了解。</p><p id="e0ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在这篇文章中，我想更深入地探讨一些可能使您的测试更好的实用要点。</p><h2 id="0994" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">写一个好的测试名</h2><p id="2886" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">它应该描述测试的内容、测试发生的条件以及测试结果的预期。</p><p id="0529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果给定的测试有一个测试用例，在测试Javadoc中提供一个到它的链接。<br/>如果测试名称变大，使用缩写。描述测试Javadoc中缩写的含义。</p><p id="5cc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个不好的测试名会降低它的可维护性。</p><h2 id="2761" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">测试公共接口</h2><p id="7a90" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">不公开的东西都不应该测试。</p><p id="f73c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要破坏封装(通过提供<code class="fe oa ob oc od b"><a class="ae ky" href="http://twitter.com/VisibleForTesting" rel="noopener ugc nofollow" target="_blank">@VisibleForTesting</a></code>或类似的东西)来测试功能。</p><p id="24ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有一个方法你想彻底地单独测试，这意味着它很可能是某个其他类的公共接口的一部分(或者实用方法，或者扩展)。</p><p id="0bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个被测试的类都应该有一个公共接口(以明确应该测试什么)。</p><p id="427b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试非公共的东西会降低测试的可维护性。打破封装破坏建筑。</p><h2 id="cec2" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">每次测试验证一个用例</h2><p id="e3fc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">测试应该检查一件事。特别是，这意味着每个测试应该只有一个断言。</p><p id="e79c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这里也有例外:如果你想检查一个测试的设置是否正确，那么你可以使用假设检查。</p><p id="a299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想验证在测试过程中调用了(或没有调用)模拟中的哪些方法，那么进行多次验证是很好的。<br/>尽管对于断言来说，每次测试只断言一次是很重要的。</p><p id="3ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个测试中测试多个东西并不允许你，当这样的测试失败时，清楚地说出失败的确切原因。</p><h2 id="5aa7" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">将测试主体分组为逻辑部分</h2><p id="eecb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于在返回值时断言的简单单元测试，应该有一个设置部分和一个断言部分。</p><p id="b8a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在复杂测试的情况下(更接近于集成测试)，应该有一个设置部分(给定)、一个触发部分(当)和一个结果部分(然后)。</p><p id="6caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有逻辑分组的测试更难阅读，因此更难维护。</p><h2 id="397b" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">使用依赖倒置</h2><p id="f2b9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在构造函数中或通过公共接口向测试中的类提供依赖关系。不要在类内部创建一些第三方依赖项。不要从类内部获取单例实例。</p><p id="c1f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用自己的接口包装一些系统/平台类，提供这些接口而不是真正的平台类作为依赖。这包括提供使用日历/时间的界面。</p><p id="64f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不使用DI会降低代码的可测试性。</p><h2 id="95ab" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">模拟与存根</h2><p id="5a64" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">尽可能使用真实的类。如果这是不可能的，那么提供一个存根。如果不可能提供存根，就提供一个mock。</p><p id="ea1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这通常意味着实体和值对象应该是真实的，一些第一方服务应该是真实的或存根，第三方服务应该是存根或模拟。</p><p id="2f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在测试中过度使用模拟可能会导致您测试模拟实现，而不是实际的实现。</p><h2 id="7954" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">实体/值对象默认生成器</h2><p id="5fef" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当使用实体或值对象的真实类时，用带有默认值的构建器来构建它们是很方便的。</p><p id="6fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，它是entity/value对象的默认实现，在这个实现中，用户可以更改对于给定测试很重要的属性。</p><p id="04ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有这样的构建器会导致代码重复，降低测试的可维护性。</p><h2 id="f1f2" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">组合成子类的组测试</h2><p id="7611" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用通用设置创建一个抽象的基本测试类，并使用测试特定部分功能的子类来扩展它。</p><p id="9af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把紧密耦合的测试用例集中在一个地方。这样，就有可能将部分测试名(重复部分)提取到一个封闭的类名中。</p><p id="56c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有测试放在一个类中会降低可读性。</p><h2 id="d4f3" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">测试的初始状态应该只通过被测试类的公共API及其依赖项来生成</h2><p id="b4db" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">不应该对类进行内部修改来进行测试设置。没有<code class="fe oa ob oc od b">@VisibleForTesting</code>与打破封装。</p><p id="7825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过非公共API改变内部状态可能会产生一种不可能的情况。此外，它打破了封装。</p><h2 id="7b4c" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">尽早设置测试</h2><p id="faab" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">编写几个涵盖基本功能的测试。随着时间的推移，当体系结构建立起来，了解到更多的信息时，添加更多的测试。</p><p id="5714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在早期编写大量测试需要技巧(如果使用TDD的话)。TDD很棒，但是如果没有足够的经验，当结构发生重大变化时，可能需要多次重写测试。</p><p id="1d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将编写测试推迟到开发结束可能会导致不可测试的代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4ecb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="de2c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">编写测试不是一件容易的事情。这需要纪律。</p><p id="8864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，测试也是代码，应该像编写一般产品代码一样小心编写。但是，当你在测试上投入时间，随着时间的推移，你会从中获得越来越多的价值。</p><p id="d68a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要害怕写测试。不要等待。从今天开始。继续做测试。</p><p id="dfac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>