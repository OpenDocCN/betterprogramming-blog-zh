<html>
<head>
<title>9 React Testing Library Tips and Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">9 React测试库提示和技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/9-react-testing-library-tips-and-tricks-5cce3e458282?source=collection_archive---------3-----------------------#2020-04-01">https://betterprogramming.pub/9-react-testing-library-tips-and-tricks-5cce3e458282?source=collection_archive---------3-----------------------#2020-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ce9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写测试很难。这些建议让事情变得简单了一些</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/696476c2678527a703395e88ab6d38b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7i4zgs4q9e13oS-j50abdg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">法尔扎德·纳兹菲在<a class="ae ky" href="https://unsplash.com/s/photos/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="6c5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几周前，我有幸参加了为期两天的工作培训课程，以提高我的<a class="ae ky" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank">反应测试库</a>知识和技能。</p><p id="e2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的工作中，我的团队非常依赖多种形式的自动化测试(单元、集成、端到端等)。)来帮助确保我们的应用程序的所有部分都正常工作。因此，当我参加课程时，我已经对如何使用React测试库(RTL)有了基本的了解，因为我们在几个月前就已经开始使用它，因为我们开始在我们的应用程序中编写更多基于React hooks的组件。我们之前的Jest和Enzyme的单元测试组合也不再满足我们的需求。</p><p id="06f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这次培训让我看到了一些我完全不知道的关于使用RTL的有用信息。我想分享我的9个最大收获，希望它们能帮助你使用这个测试库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f9a4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是React测试库？又为什么不一样？</h1><p id="91df" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">注意:这不是一篇“RTL入门”的文章。本文假设您已经很好地理解了如何使用测试框架。我的目的是向您展示一些额外的技巧，使编写(和调试)测试更容易。</p><p id="9e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，在深入本文之前，我将简要概述一下<a class="ae ky" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> React测试库</a>的原因和方法。</p><h2 id="e368" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">为什么</h2><p id="92ee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Kent C. Dodds 创建了React测试库来解决一个问题:其他测试库鼓励开发人员编写与他们正在测试的组件的实现细节过于紧密耦合的测试。Dodds认为测试应该只验证组件的最终结果(行为)。</p><p id="6e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想想也有道理吧？</p><p id="fb72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们不像编写端到端测试那样编写集成测试呢？关注用户视角的测试(组件在DOM中的外观和行为)。因为这是最终最重要的:当用户与组件交互时，组件做了它们应该做的事情吗？</p><p id="6b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不一定关心它是否在Redux存储中存储了什么，或者是否进行了特定的API调用来获取数据。用户不知道也不关心这些——他们关心的是屏幕上是否显示他们点击的信息，或者他们订购的商品是否正被运送给他们。作为开发商，RTL的立场是我们也应该关心这个问题。</p><p id="8fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，Dodds建议采用以下方式进行测试:</p><ul class=""><li id="dc19" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">避免依赖组件的实现细节。</li><li id="9b3f" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">使测试易于维护(例如，重构组件实现不会破坏测试)。</li><li id="5fe9" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">避免浅层安装，因为我们想测试组件集成解决用户问题(比如编辑表单中的数据)。</li></ul><p id="5377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我想到…</p><h2 id="990c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">怎么做</h2><p id="1141" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React测试库是一个非常轻量级的解决方案，用于测试React组件。它在<code class="fe nz oa ob oc b">react-dom</code>和<code class="fe nz oa ob oc b">react-dom/test-utils</code>之上提供了轻量级的实用函数，以鼓励更好的测试实践。</p><p id="9183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是React测试库的一些有趣方面:</p><ul class=""><li id="6b22" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">它侧重于验证实际的DOM节点，而不是验证呈现的React组件的实例。</li><li id="6aec" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">它提供了查询DOM的工具，与用户查询DOM的方式相同。</li><li id="a4f8" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">它通过标签文本查找元素(就像用户一样)。</li><li id="7d23" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">它从文本中找到链接和按钮(就像用户一样)。</li><li id="8238" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">它提供了一种通过<code class="fe nz oa ob oc b">data-testid</code>找到元素的方法，作为文本内容和标签没有意义或者不实用或不可用的元素的“出口”。</li></ul><p id="c69b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然这个问题已经解决了，让我们来看看好东西:热门提示。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="65d3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">技巧1:用屏幕代替组件</h1><p id="87cd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你有没有想过，“小子，老是写<code class="fe nz oa ob oc b">component.getByText...</code>或<code class="fe nz oa ob oc b">component.getByLabel...</code>真烦人。我希望有别的方法"？原来有:叫<code class="fe nz oa ob oc b"><a class="ae ky" href="https://testing-library.com/docs/dom-testing-library/api-queries#screen" rel="noopener ugc nofollow" target="_blank">screen</a></code>。</p><p id="eb3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DOM Testing Library导出的所有查询(RTL就是基于它构建的)都接受一个<code class="fe nz oa ob oc b">container</code>作为第一个参数。因为查询整个<code class="fe nz oa ob oc b">document.body</code>非常常见，所以DOM Testing Library还导出了一个<code class="fe nz oa ob oc b">screen</code>对象，其中包含预绑定到<code class="fe nz oa ob oc b">document.body</code>的每个查询(使用<code class="fe nz oa ob oc b"><a class="ae ky" href="https://testing-library.com/docs/dom-testing-library/api-helpers#within-and-getqueriesforelement-apis" rel="noopener ugc nofollow" target="_blank">within</a></code>功能)。</p><p id="a610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以这样使用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/7435a807efe954d2b170ab4280482f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*it_gC2pmIsWNN5_EYuGBHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">只需从“@testing-library/dom”导入screen，就可以开始使用它了。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="a5d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相信我:过一段时间，<code class="fe nz oa ob oc b">screen</code>将会变得越来越方便，因为您可以编写测试来检查在DOM中什么是可见的或启用的(或不启用的)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6320" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">提示#2: FindByText而不是waitForElement…getByText </strong></h1><p id="4822" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你以前用过RTL，你可能知道它有几个方便的异步函数，以<code class="fe nz oa ob oc b">waitFor</code>、<code class="fe nz oa ob oc b">waitForElement</code>或<code class="fe nz oa ob oc b">waitForElementToBeRemoved</code>开头。这对于等待某个元素响应某个动作而出现或消失非常有用。</p><p id="1ab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">典型地，<code class="fe nz oa ob oc b">waitFor</code>代码看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/83f91354d0ce5fdd2131c5693de78eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PiNHBI-SfCCF2ZHvM8GxA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RTL的一行程序一直在等待，直到订单按钮在DOM中可见。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8ef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的一行非常简洁明了，但是还有一种更简洁的方式:借助<code class="fe nz oa ob oc b">findBy...</code>。</p><p id="2b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/999a8ccfa040b04c441bb2489351d63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLzJQdeuwoSrZnjcoEm54A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一种更短、更简洁的异步等待元素在DOM中可用的方式。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="69b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用RTL提供的任何<code class="fe nz oa ob oc b">findBy</code>查询(<code class="fe nz oa ob oc b">findByText</code>、<code class="fe nz oa ob oc b">findByTestId</code>、<code class="fe nz oa ob oc b">findByPlaceholder</code>等)。)，它会自动将要搜索的元素包装在一个等待它被呈现的承诺中，使您不必自己编写包装器代码。</p><p id="1768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就其本身而言，这可能看起来不多，但是想象一下在您的应用程序中编写许多这种类型的测试。更精简的测试代码开始快速增加。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb95" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">技巧3:异步操作的UserEvent</h1><p id="b049" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">H/T to <a class="oi oj ep" href="https://medium.com/u/db72389e89d8?source=post_page-----5cce3e458282--------------------------------" rel="noopener" target="_blank"> Kent C. Dodds </a>让我知道像<code class="fe nz oa ob oc b">render()</code>和<code class="fe nz oa ob oc b">fireEvent()</code>这样的函数实际上不需要手动包装在<code class="fe nz oa ob oc b">act()</code>中——每个异步实用程序都是由RTS自动包装的。太棒了——这对你来说是更多的知识！😄</p><p id="dfb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我确实希望这是一篇9技巧的博文，所以我还是想分享一个库，让像<code class="fe nz oa ob oc b">click()</code>或<code class="fe nz oa ob oc b">select()</code>这样的异步动作更简单一点，这样你就知道它的存在了。</p><p id="0583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是RTL典型的异步事件代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/85251a2b4a2b3a032ec8a66ba367ab91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neJ9e9kN56VIs0XkQ-9pUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无论如何，要编写的代码量并不多，但还可以更好。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="23f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不是最糟糕的事情…但是考虑一下对于一个相当复杂的测试用例来说你有多少<code class="fe nz oa ob oc b">async / await</code>事件。并编写多个测试来测试一个组件。</p><p id="a6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/testing-library/user-event" rel="noopener ugc nofollow" target="_blank">用户事件</a>库“试图模拟用户与浏览器交互时会在浏览器中发生的真实事件。例如，<code class="fe nz oa ob oc b">userEvent.click(checkbox)</code>会改变复选框的状态。</p><p id="e7da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需将其导入到测试文件的顶部，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7031fdadb999f60a49835fc76f356756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwZLskLW0Ngy8iZiOirU9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的ES6导入。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这里是上面应用了<code class="fe nz oa ob oc b">userEvent</code>库的相同代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/ce3a5e0354ee8398fc80bd893f7157ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xiTRNuNCpqwZxs1CNv3UKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哇，这是非常简单的代码。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="bd5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这些代码是如何变得更加精简的！对我来说，当我了解到这一点时，这是一个游戏规则的改变，我现在绝对喜欢在我自己的测试中使用它。</p><p id="0354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:用户事件库还不完全支持RTL的所有异步动作。像<code class="fe nz oa ob oc b">change</code>和<code class="fe nz oa ob oc b">keyDown</code>这样的动作在用户事件中是不可用的，但是图书馆正在寻找人们来添加它，所以如果你愿意贡献，我相信他们会感谢帮助。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e0e1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">提示#4: PrettyDOM代替debug </strong></h1><p id="ee43" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">调试不工作的代码是痛苦的。调试不工作的测试可能更痛苦——尤其是当你在组件上运行RTL的<code class="fe nz oa ob oc b">component.<a class="ae ky" href="https://testing-library.com/docs/react-testing-library/api#debug" rel="noopener ugc nofollow" target="_blank">debug()</a></code>时，但是组件的DOM树太大了，以至于在控制台中呈现整个东西之前就被切断了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/26c4d2ef7b7751b11252aa8de1c2a8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1h9-c07BJy_DFjoEbeRFOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用React测试库进行调试的典型方式。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1d2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是典型的<code class="fe nz oa ob oc b">debug()</code>在RTL测试中运行时控制台显示的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/515f82f26647996f341fcc0b10eb62de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOPHSr3pyBAQAqrDxqFpPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注意到这张截图末尾的“…”了吗？这是控制台中DOM树的渲染结束的地方。</p></figure><p id="7dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这个烦恼有一个解决办法。它被称为<code class="fe nz oa ob oc b"><a class="ae ky" href="https://testing-library.com/docs/dom-testing-library/api-helpers#prettydom" rel="noopener ugc nofollow" target="_blank">prettyDOM</a>()</code>，RTL的<code class="fe nz oa ob oc b">debug()</code>方法实际上是建立在它的基础上的。<code class="fe nz oa ob oc b">prettyDOM</code>函数源于DOM测试库，除了指定要打印的组件或元素之外，它还允许额外的配置。它有一个可选的<code class="fe nz oa ob oc b">maxLength</code>参数来限制结果字符串的大小——或者，在我的例子中，打印出非常非常大的DOM树。</p><p id="5447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我如何使用<code class="fe nz oa ob oc b">prettyDOM</code>打印那些讨厌的超大DOM树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/db8f1411678903cc577b29c32e336b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HptoZAep09D9Vwr09-4ylA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">只需将prettyDOM中可选的maxLength参数设置为一个非常非常大的数字，就可以在控制台中看到整个组件的打印结果。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="99b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是用<code class="fe nz oa ob oc b">prettyDOM</code>渲染到控制台的DOM树的另一个片段。请注意，在RTL <code class="fe nz oa ob oc b">debug()</code>方法结束后，它会继续运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/abea2695191f78fd5406338c75ba0f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwnlB-bSM2Xd4N70gb10lQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DOM树的这种呈现持续了很长时间，但是您可以看到它一直在经过。ant-单选按钮-选中“span它之前切断的地方。</p></figure><p id="6467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，当我试图调试团队应用程序中一些特别棘手的组件时，<code class="fe nz oa ob oc b">prettyDOM</code>成了我的救命恩人。如果没有这个选项，我会花很长时间来找出测试的问题所在。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f521" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">技巧5:document . query选择检查组件的类</h1><p id="c16f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望你不要遇到这个问题——我真的希望——但是如果你在你的React应用程序中使用一个组件库，比如<a class="ae ky" href="https://ant.design/" rel="noopener ugc nofollow" target="_blank"> Ant Design </a>，你将很快学会测试一些更复杂的组件(例如，表格、单选按钮等)。)和RTL在一起会很痛苦。</p><p id="4ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为您用来标识和检查具有RTL的元素的许多典型方法在Ant组件上并不存在(或者过于通用)。在某些情况下，您需要检查Ant元素是被启用还是被禁用，但是与定制组件可能有一个目标<code class="fe nz oa ob oc b">data-testid</code>不同，Ant没有。它有一个额外的类添加到它的<code class="fe nz oa ob oc b">className</code>属性中。</p><p id="7b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是RTL没有提供检查组件类的选项。在这种情况下，我们必须求助于DOM的<code class="fe nz oa ob oc b">document</code>级别并使用<code class="fe nz oa ob oc b">document.querySelector</code>。</p><p id="75fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查一个Ant组件是否被隐藏，下面是我如何做的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/37148e42281694e99fcbf70e777d1b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8cOKFnG-f0pstuWKKwIw6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">是的，我在这个组件中寻找一个“隐藏的”类，以确保某些东西在这个测试中不可见。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="b0d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是特别优雅的代码，但在紧要关头也能工作。就像肯特·c·多兹说的把<code class="fe nz oa ob oc b">data-testid</code>当成一个“逃生出口”，以同样的方式考虑<code class="fe nz oa ob oc b">document.querySelector()</code>。请谨慎使用它，并且仅当您没有其他选择来将RTL中的元素作为目标时才使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ab1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">技巧6: ParentElement访问目标之上的元素</h1><p id="9a6d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是我上周才学会的一个鲜为人知的技巧——同样是因为用React测试库测试Ant组件很痛苦。</p><p id="9122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要在输入中输入文本，然后单击输入框末尾的加号(+)按钮将值保存到DOM中。然而，加号按钮碰巧是组件中input元素之上的一级，所以为了定位它，我学习了<code class="fe nz oa ob oc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/parentElement" rel="noopener ugc nofollow" target="_blank">parentElement</a></code>选择器，它实际上是浏览器的原生功能，而不是RTL特有的。我不能只在整个组件中搜索加号按钮，因为页面上有多个加号按钮用于多种输入。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c2f3fe1cea012423b40ed91c362af79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZe4umFz9FkbtVAZ9B9k7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标识输入，然后在其父元素中标识与之关联的图标。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="2f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面的例子中看到的，首先我创建了针对输入的变量<code class="fe nz oa ob oc b">input</code>，然后我创建了针对输入的父元素中的加号按钮的第二个变量<code class="fe nz oa ob oc b">enter</code>。</p><p id="91f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我单击正确的输入加号按钮，即使没有<code class="fe nz oa ob oc b">data-testid</code>或其他关于这个Ant输入的单独定义特征。最近它派上了用场。希望也能帮到你。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fbdd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">技巧7: PreviousSibling和nextSibling访问与目标一致的元素</h1><p id="ab68" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在一个非常类似的情况下，我还了解到了<code class="fe nz oa ob oc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/previousSibling" rel="noopener ugc nofollow" target="_blank">previousSibling</a></code>和<code class="fe nz oa ob oc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling" rel="noopener ugc nofollow" target="_blank">nextSibling</a></code>(也是浏览器原生属性)的选项，通过React测试库在DOM中选择特定元素周围的元素。</p><p id="b119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个场景中，我需要单击Ant表组件中的复选框来选择表中的一个选项。checkbox元素是选项名称的同级，是表的每一行中唯一唯一的元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/a9b3b78222823d2231aa8cf6bbd05742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEPsACh6XCurmS_hyKN6lA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我使用行名(“选择键”)定位到表中的一行，然后沿着DOM返回到它的前一个兄弟行，它包含复选框。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我使用行的惟一名称(<code class="fe nz oa ob oc b">'key to select'</code>)创建了一个变量(<code class="fe nz oa ob oc b">keyToSelect</code>)，目标是Ant表中的一行。然后我可以使用目标元素的<code class="fe nz oa ob oc b">previousSibling</code>来访问复选框并选择表中的行。</p><p id="b821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我承认这不是最简单的语法，但是它解决了我的问题。您也可以使用<code class="fe nz oa ob oc b">nextSibling</code>完成完全相同类型的元素定位。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="29b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">技巧8:对DOM中的模糊文本匹配使用{ exact: false }</h1><p id="5646" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，在RTL很难使用<code class="fe nz oa ob oc b">getByText</code>或<code class="fe nz oa ob oc b">findByText</code>类型的搜索，因为它默认为精确匹配。这意味着只有当字符串在DOM中完全相同时,<code class="fe nz oa ob oc b">getByText('Hi there')</code>才会起作用:完整字符串，区分大小写。如果在<code class="fe nz oa ob oc b">'Hi’</code>和<code class="fe nz oa ob oc b">'there'</code>之间有<code class="fe nz oa ob oc b">&lt;span&gt;</code>、换行符(<code class="fe nz oa ob oc b">\n</code>)或其他东西，这个<code class="fe nz oa ob oc b">getByText()</code>查询将无法找到文本。</p><p id="61de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进行不区分大小写的模糊匹配，并且包含子字符串，您可以添加<code class="fe nz oa ob oc b">{ exact: false }</code>。</p><p id="81cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面这个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/27b16feaccd96a92afcc9d8a3df9828d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4es_jrrYUmsSACB5QPOL9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过添加exact: false选项，这两个选项都将在RTL的DOM中定位div。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="666f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然如果需要匹配子串，更推荐使用正则表达式，但是对于DOM中更简单的文本选择，我认为这是一个很好的替代。我不知道你怎么想，但是我总是不得不在浏览器中测试regex来记住如何写它。我很少用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="91db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">技巧9:从命令行打开浏览器中的任何文件</h1><p id="6cc9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后一个技巧，这个技巧实际上并不是专门针对React测试库的，但是我也在这个课上学到了，我认为它很酷。</p><p id="547b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您选择使用VS代码作为JavaScript IDE，并且希望从VS代码内置的终端命令行在浏览器中打开一个文件，这很容易。</p><p id="a134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在命令行中，你所要做的就是输入<code class="fe nz oa ob oc b">open &lt;file path&gt;</code>，瞧:一个新窗口会在你的浏览器中弹出。</p><p id="15c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之所以在这里提到它，是因为当我向我们的应用程序添加新的测试时，它为我提供了一种快速简单的方法来检查我的代码覆盖率。我发现在浏览器版本的代码覆盖率中点击来查看哪些行被测试比在终端中使用小的打印输出要容易得多。</p><p id="4b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，为了打开我们项目的代码覆盖率，我会写:</p><pre class="kj kk kl km gt os oc ot ou aw ov bi"><span id="9b7c" class="mz md it oc b gy ow ox l oy oz">open coverage/lcov-report/index.html</span></pre><p id="d8c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它就在那里，准备接受详细检查。VS代码方便快捷的胜利。我认为这是一个有趣的事实，我希望你会发现它也很有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dbcc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="36d4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React测试库是一个强大的框架，它真正改变了我们对React应用进行集成测试的方式。我花了一分钟时间来理解RTL带来的变化，但我认为这对于应用程序在现实世界中应该如何工作更有意义。</p><p id="7690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我知道一些关于React测试库的事情，但是我学到了很多鲜为人知的技巧和诀窍，这些技巧和诀窍帮助我简化了我自己的测试。</p><p id="4269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过几周再来看看——我会写更多关于JavaScript、React、ES6或其他与web开发相关的东西。</p><p id="3deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望您学到了一些新东西，这将使您自己使用React测试库更加容易。如今，集成测试是任何优秀web应用程序的必要组成部分。我至少能做的是让你过得轻松一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="319f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考资料和更多资源</h1><ul class=""><li id="aea7" class="nl nm it lb b lc mu lf mv li pa lm pb lq pc lu nq nr ns nt bi translated">React测试库<a class="ae ky" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="bebd" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">React测试库<a class="ae ky" href="https://github.com/testing-library/react-testing-library" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a></li><li id="0b2a" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">RTL用户事件<a class="ae ky" href="https://github.com/testing-library/user-event" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li></ul></div></div>    
</body>
</html>