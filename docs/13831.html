<html>
<head>
<title>Glob Generators With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的Glob生成器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/glob-generators-with-python-be9ad86ca682?source=collection_archive---------12-----------------------#2022-09-30">https://betterprogramming.pub/glob-generators-with-python-be9ad86ca682?source=collection_archive---------12-----------------------#2022-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1cf8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python路径和Git忽略文件有什么共同点？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a729e418c71ba237c07ddb786be29ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhKS1ASFqlUw4bzc9NIGmQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">全局文件搜索</p></figure><p id="dbb5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个使用<a class="ae lr" href="https://en.wikipedia.org/wiki/Glob_(programming)" rel="noopener ugc nofollow" target="_blank"> glob </a>模式查找目录中所有图像文件的练习。我们将使用<code class="fe ls lt lu lv b">pathlib</code> Python <a class="ae lr" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank">模块</a>，它在<code class="fe ls lt lu lv b">Path</code>类中提供了<code class="fe ls lt lu lv b">glob</code>方法。</p><p id="153f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Glob模式也在<code class="fe ls lt lu lv b">.gitignore</code> <a class="ae lr" href="https://git-scm.com/docs/gitignore" rel="noopener ugc nofollow" target="_blank">文件</a>中使用，所以在这里工作的任何模式也可能在Git ignore文件中工作，反之亦然。</p><p id="35e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终代码<a class="ae lr" href="https://github.com/AlbertoV5/python-blog/blob/main/src/glob/get_imgs.py" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="194c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">选择模式</h1><p id="0485" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们将从这两种模式中的任何一种开始。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="66f5" class="mx lx iq lv b gy my mz l na nb">*.[jpJP][npNP][egEG]*</span><span id="286e" class="mx lx iq lv b gy nc mz l na nb">*.[jpJP]*[gG$]</span></pre><p id="5102" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的第一个模式意味着“文件扩展名以j/J或p/P开始，然后以n/N或p/P继续，然后以e/E或g/G继续，并以任何字符或无字符继续”。这将有效地匹配<code class="fe ls lt lu lv b">jpg</code>、<code class="fe ls lt lu lv b">jpeg</code>、<code class="fe ls lt lu lv b">png</code>以及它们的大写版本。不过这个也会配<code class="fe ls lt lu lv b">jpega</code>和<code class="fe ls lt lu lv b">pngx</code>之类的。</p><p id="79c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想确保不匹配非预期的文件，我们可以使用第二种模式，即“扩展名以j/J或p/P开头，以g/G结尾的文件”。这个也匹配<code class="fe ls lt lu lv b">jpg</code>、<code class="fe ls lt lu lv b">jpeg</code>和<code class="fe ls lt lu lv b">png</code>，不会匹配<code class="fe ls lt lu lv b">jpega</code>或<code class="fe ls lt lu lv b">pngx</code>，但是会匹配<code class="fe ls lt lu lv b">jag</code>或<code class="fe ls lt lu lv b">pxg</code>这样的图案。</p><p id="d488" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们将这两种模式结合起来，我们可以得到更严格的匹配，确保文件格式以g/G结尾，并且匹配所有三个目标扩展名。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="19e5" class="mx lx iq lv b gy my mz l na nb">*.[jpJP][npNP]*[gG$]</span></pre><h1 id="9529" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">Glob函数</h1><p id="fa14" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">一旦我们用<code class="fe ls lt lu lv b">pathlib</code>得到它们的路径，我们将使用<code class="fe ls lt lu lv b">PIL</code> <a class="ae lr" href="https://pillow.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">模块</a>来处理图像。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="29a4" class="mx lx iq lv b gy my mz l na nb">from pathlib import Path<br/>from PIL import Image</span></pre><p id="77b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将定义一个函数，并在编写代码之前指定我们想要做的事情。在我们的参数中，我们希望接收一个字符串和几个布尔值来修改函数的行为。</p><p id="007b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当遍历一个目录时，结果将是无序的，所以我们可能希望使用<code class="fe ls lt lu lv b">sorted</code>按字母顺序对它们进行排序。我们也可能想要递归地搜索所有目录，我们可以使用<code class="fe ls lt lu lv b">rglob</code>来实现。</p><p id="d926" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们想让它成为一个生成器函数，这样我们就可以在任何给定的迭代中停止这个过程，所以我们将对文件路径进行<code class="fe ls lt lu lv b">yield</code>。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="1b41" class="mx lx iq lv b gy my mz l na nb">def get_imgs(directory: str, sort: bool = True, recursive: bool = True):<br/>    """Yields all image files in given path.</span><span id="5161" class="mx lx iq lv b gy nc mz l na nb">    Args:</span><span id="6369" class="mx lx iq lv b gy nc mz l na nb">        directory (str): Relative directory name.<br/>        sort (bool, optional): If generator is sorted. Default True.<br/>        recursive (bool, optional): If glob is recursive. Default True.</span><span id="b8b0" class="mx lx iq lv b gy nc mz l na nb">    Yields:</span><span id="f50b" class="mx lx iq lv b gy nc mz l na nb">        (Path): File path.<br/>    """</span></pre><p id="574d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们开始检查给定的路径是否存在。我们将使用<code class="fe ls lt lu lv b">resolve</code>将任何相对路径转换为绝对路径，然后使用<code class="fe ls lt lu lv b">is_dir</code>检查目录是否存在。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="f416" class="mx lx iq lv b gy my mz l na nb">path = Path(directory).resolve()<br/>if not path.is_dir():<br/>    raise ValueError(f"'{path}' is not a directory.")</span></pre><p id="c19e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的<code class="fe ls lt lu lv b">pattern</code>变量将保存glob模式，如果我们希望我们的搜索是递归的，那么<code class="fe ls lt lu lv b">frec</code>将使用<code class="fe ls lt lu lv b">rglob</code>，如果我们希望对结果进行排序，那么<code class="fe ls lt lu lv b">fsort</code>将使用<code class="fe ls lt lu lv b">sorted</code>。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="80d9" class="mx lx iq lv b gy my mz l na nb">pattern = '*.[jpJP][npNP]*[gG$]'<br/>frec = lambda p, g: p.rglob(g) if recursive else p.glob(g)<br/>fsort = lambda x: sorted(x) if sort else x</span></pre><p id="759d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们将使用lambda函数和每个文件路径。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="8728" class="mx lx iq lv b gy my mz l na nb">for file in fsort(frec(path, pattern)):<br/>    yield file</span></pre><p id="7935" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们的功能，一旦我们把它放在一起。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="4b37" class="mx lx iq lv b gy my mz l na nb">from pathlib import Path<br/>from PIL import Image</span><span id="1956" class="mx lx iq lv b gy nc mz l na nb">def get_imgs(directory: str, sort: bool = True, recursive: bool = True):<br/>    """Yields all image files in given path.</span><span id="a3dd" class="mx lx iq lv b gy nc mz l na nb">    Args:</span><span id="ccd6" class="mx lx iq lv b gy nc mz l na nb">        directory (str): Relative directory name.<br/>        sort (bool, optional): If generator is sorted. Default True.<br/>        recursive (bool, optional): If glob is recursive. Default True.</span><span id="e6d9" class="mx lx iq lv b gy nc mz l na nb">    Yields:</span><span id="565c" class="mx lx iq lv b gy nc mz l na nb">        (Path): File path.<br/>    """<br/>    path = Path(directory).resolve()<br/>    if not path.is_dir():<br/>        raise ValueError(f"'{path}' is not a directory.")<br/>    pattern = '*.[jpJP][npNP]*[gG$]'<br/>    frec = lambda p, g: p.rglob(g) if recursive else p.glob(g)<br/>    fsort = lambda x: sorted(x) if sort else x<br/>    for file in fsort(frec(path, pattern)):<br/>        yield file</span></pre><p id="4bfc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在一个脚本中使用它，简单地打印相对于根目录的所有文件路径。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="9d1d" class="mx lx iq lv b gy my mz l na nb">root = Path("..").resolve()<br/>for f in get_imgs('../resources'):<br/>    print(f.relative_to(root))</span></pre><p id="afc1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="592b" class="mx lx iq lv b gy my mz l na nb">resources/data/Screen Shot 2022-09-05 at 12.41.33.png<br/>resources/data/Screen Shot 2022-09-05 at 12.41.45.png<br/>resources/final/007.jpeg<br/>resources/final2/000.jpeg<br/>resources/img/008.jpeg<br/>resources/img/009.jpg<br/>resources/img/Screen Shot 2022-09-29 at 13.20.27.png<br/>resources/img/Screen Shot 2022-09-29 at 20.07.04.png<br/>resources/img/Screen Shot 2022-09-29 at 20.08.21.png<br/>resources/old/002.jpeg<br/>resources/old/006.jpg</span></pre><p id="424f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们继续用<code class="fe ls lt lu lv b">PIL</code>处理文件。</p><h1 id="e398" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">处理文件</h1><p id="0a25" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们希望将所有的<code class="fe ls lt lu lv b">png</code>文件转换成<code class="fe ls lt lu lv b">jpeg</code>，并将<code class="fe ls lt lu lv b">jpg</code>重命名为<code class="fe ls lt lu lv b">jpeg</code>，然后调整它们的大小，使其具有给定的最大宽度。</p><p id="d3c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用<code class="fe ls lt lu lv b">PIL</code>中的<code class="fe ls lt lu lv b">ImageOps</code>模块来简化尺寸调整操作并保持纵横比。过程如下:我们以图像的形式打开文件，如果<code class="fe ls lt lu lv b">suffix</code>是<code class="fe ls lt lu lv b">png</code>就转换成<code class="fe ls lt lu lv b">'RGB'</code>，然后用<code class="fe ls lt lu lv b">ImageOps.contain</code>调整大小，用<code class="fe ls lt lu lv b">with_suffix</code>保存为<code class="fe ls lt lu lv b">jpeg</code>。</p><p id="fd46" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在编写我们的主进程之前，我们将创建一个函数来替换文件后缀<code class="fe ls lt lu lv b">jpeg</code>并改变它的父目录。我们还将为打印目的创建一个<code class="fe ls lt lu lv b">root</code>变量。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="f328" class="mx lx iq lv b gy my mz l na nb">from PIL import ImageOps</span><span id="bf3e" class="mx lx iq lv b gy nc mz l na nb">max_width = 1280<br/>with_path = lambda f: Path('../converted').resolve() / f.with_suffix('.jpeg').name<br/>root = Path("..").resolve()<br/>for f in get_imgs('../resources'):<br/>    with Image.open(f) as img:<br/>        if f.suffix == '.png':<br/>            img = img.convert('RGB')<br/>        if img.size[0] &gt; max_width:<br/>            img = ImageOps.contain(img, (max_width, max_width))<br/>        fout = with_path(f)<br/>        img.save(fout, quality=80)<br/>        print(fout.relative_to(root))</span></pre><p id="c657" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="e5f4" class="mx lx iq lv b gy my mz l na nb">converted/Screen Shot 2022-09-05 at 12.41.33.jpeg<br/>converted/Screen Shot 2022-09-05 at 12.41.45.jpeg<br/>converted/007.jpeg<br/>converted/000.jpeg<br/>converted/008.jpeg<br/>converted/009.jpeg<br/>converted/Screen Shot 2022-09-29 at 13.20.27.jpeg<br/>converted/Screen Shot 2022-09-29 at 20.07.04.jpeg<br/>converted/Screen Shot 2022-09-29 at 20.08.21.jpeg<br/>converted/002.jpeg<br/>converted/006.jpeg</span></pre><p id="26c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，我们将结果放在一个不同于我们用来搜索的父目录中，因为默认情况下我们是递归进行搜索的。这是因为我们不想在第二次运行脚本时将结果作为输入。</p><h1 id="2694" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="bcd9" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">Python中的生成器是处理数据最有用的工具之一。如果我们想在不使用bash脚本的情况下自动完成一些任务(不管出于什么原因)，我们可以从一个glob pattern函数开始，它在一个无序的目录中生成我们想要的文件类型。</p><p id="7c68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe ls lt lu lv b">glob</code>的好处是我们不必使用Python来检查每个文件后缀是否匹配一系列文件格式，因此我们可以更容易地扩展我们的过程。</p><p id="fd30" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，在下面的代码中，我们可以用第二个理解替换第一个理解。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="ec8c" class="mx lx iq lv b gy my mz l na nb">[f for f in path.iterdir() if f.suffix in ('.jpeg', '.jpg', '.png', 'JPG', 'JPEG', 'PNG')]</span><span id="adb2" class="mx lx iq lv b gy nc mz l na nb">[f for f in path.glob('*.[jpJP][npNP]*[gG$]')]</span></pre><p id="5aed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们也可以用<code class="fe ls lt lu lv b">rglob</code>递归地做这件事，或者把<code class="fe ls lt lu lv b">**/</code>加到我们模式的开头。缺点是，如果我们的模式不够好，我们可能会匹配非预期的文件，并且globs不如正则表达式强大。另外，我们可以在我们的。gitignore文件。</p><h1 id="2849" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">脚注</h1><p id="d20f" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated"><a class="ae lr" href="https://en.wikipedia.org/wiki/Glob_(programming)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Glob _(编程)</a></p><p id="1302" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/pathlib.html</a></p><p id="ba4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://git-scm.com/docs/gitignore#_pattern_format" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs/gitignore#_pattern_format</a></p><p id="55d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://pillow.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">https://pillow.readthedocs.io/en/stable/</a></p><p id="f92c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://unsplash.com/photos/2JIvboGLeho?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditShareLink" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/2JIvboGLeho?utm_source=unsplash&amp;UTM _ medium = referral&amp;UTM _ content = creditShareLink</a></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="ad14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nk">原载于</em><a class="ae lr" href="https://github.com/AlbertoV5/python-blog/blob/main/docs/blog.md" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://github.com</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>