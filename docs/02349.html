<html>
<head>
<title>Do You Even Try? — Functional Error Handling in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你试过吗？Kotlin中的功能错误处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/do-you-even-try-functional-error-handling-in-kotlin-ad562b3b394f?source=collection_archive---------5-----------------------#2019-11-25">https://betterprogramming.pub/do-you-even-try-functional-error-handling-in-kotlin-ad562b3b394f?source=collection_archive---------5-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b0cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何通过使用函数式编程中的概念来废除try-catch块并使您的代码更安全、更整洁</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49207f6c636294d7fa99e5568a196d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsMQ00CZ5Co2gctHK9shtg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rojekilian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莎拉·基利安</a>在<a class="ae ky" href="https://unsplash.com/s/photos/error?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我真的不喜欢try-catch块，也不喜欢许多面向对象编程语言中如何处理异常。</p><p id="f3ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，函数的调用者甚至不知道它可能会抛出异常，这种引用透明性的缺乏使得代码更加难以理解，并可能导致无法预见的错误和问题。</p><p id="e2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理异常，我们必须用try-catch块包围函数调用，这使代码变得混乱，通常只是为了执行日志记录或释放资源，然后重新抛出异常，甚至更糟，返回空值<em class="lv">。处理错误通常是一项麻烦的任务。</em></p><p id="a4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次尝试用Scala进行函数式编程时，我记得我最喜欢的是这种语言如何让你处理空值和错误。</p><p id="3c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管您可以在Scala中编写一个常规的try-catch块，但是您也可以选择不这样做，我从来没有这样做过。该语言的标准库中有几个<em class="lv">代数</em> <em class="lv">数据类型</em>，其中一个为命令式try-catch块提供了替代，恰当地命名为<code class="fe lw lx ly lz b">Try</code>。</p><p id="a72a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本的想法是，你包装一个你想执行的函数，但是这个函数可能会在一个<code class="fe lw lx ly lz b">Try</code>中抛出一个错误。<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>执行函数，捕捉任何发生的错误并创建其两个子类型之一，一个<code class="fe lw lx ly lz b">Success</code> <em class="lv"> </em>或一个<code class="fe lw lx ly lz b">Failure</code>。</p><p id="5859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们分别保存函数的结果值或可能产生的错误。</p><p id="e972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Kotlin对函数式编程范式有很好的支持，当我学习这门语言时，我做的第一件事就是试图模仿我从Scala学到的东西。</p><p id="f684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢Kotlins内置的带有特殊语法的<code class="fe lw lx ly lz b">null-type</code>，Java现在在标准库中也有了它的<code class="fe lw lx ly lz b">Optional</code> <em class="lv"> </em>类型，但是两者都缺少一个对等的错误处理。</p><p id="3746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，它实现起来非常简单，Kotlin及其语言特性非常适合这个概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/2970a03662cae25cca0e5fcde8224518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PtmrFFJ37RooMxGVz_70eg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Try包装一个可能失败的计算，并给出两种结果之一，成功或失败，包含结果或错误。除非您手动访问并重新引发异常，否则异常永远不会离开失败。</p></figure><p id="6226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个非常基本的例子，在Kotlin中实现了一个<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>。</p><p id="1697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，我们试图分配包装在一个<code class="fe lw lx ly lz b">Try</code>中的两个值，其中一个将因异常而失败。然而，分配<code class="fe lw lx ly lz b">resultB</code>时抛出的异常不会终止该功能，打印操作都将被执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将在控制台中看到的结果如下。不出所料，第一个是保存字符串值的<code class="fe lw lx ly lz b">Success</code> <em class="lv"> </em>，第二个是包含异常的<code class="fe lw lx ly lz b">Failure</code> <em class="lv"> </em>。要知道您处理的是哪一个，您可以执行类型检查。</p><pre class="kj kk kl km gt md lz me mf aw mg bi"><span id="ebe8" class="mh mi it lz b gy mj mk l ml mm">Success("Hello, World")<br/>Failure("Not Today!")</span></pre><p id="8baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为您提供了封装任何可能发生的错误并对潜在故障进行抽象的好处。</p><p id="ee48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>作为函数的返回类型时，它向调用者表明它可能会失败，结果可能是一个错误，因为，例如，通常为<code class="fe lw lx ly lz b">String</code>的返回类型现在变成了<code class="fe lw lx ly lz b">Try&lt;String&gt;</code>。</p><p id="76ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这还不是全部，<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>还提供了一组高阶函数，允许转换它包含的值。</p><p id="3d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的效果是，您可以继续使用<code class="fe lw lx ly lz b">Try</code>，传递它并处理其中的数据，而不必确定您是在处理一个<code class="fe lw lx ly lz b">Success</code> <em class="lv"> </em>还是一个<code class="fe lw lx ly lz b">Failure</code> <em class="lv"> </em>，直到最终需要最终结果的最后一刻，有点像薛定谔的值。</p><p id="6d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在看实现之前，让我们看一个稍微复杂一点的例子，在Kotlin中使用一个<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个简单的工作尝试的例子</p></figure><p id="519e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个典型的练习，我们想从一个CSV文件中读取可能抛出各种I/O异常的行，通常，我们要么用一个try-catch包围它，要么让任何潜在的异常飞出并终止程序，或者如果有任何异常的话，跳到堆栈中更高的下一个catch-block。</p><p id="1d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>封装了我们想要执行的操作并保存结果，<code class="fe lw lx ly lz b">List</code>包含文件中的行。</p><p id="d453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，您会希望对数据执行操作，在本例中，我们希望将文件中的每一行转换成一个<code class="fe lw lx ly lz b">Pet</code>对象，我们可以看到<code class="fe lw lx ly lz b">toPet</code>函数包含一些可能失败的操作。</p><p id="06f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">失败包括将字符串转换为整数以解析年龄，以及通过字符串查找枚举以获得<code class="fe lw lx ly lz b">PetType</code>。</p><p id="c7cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为参考，我在这个练习中使用的文件的内容是这样的，我们可以看到上面的代码的最后两行会引起问题，<code class="fe lw lx ly lz b">Rambo</code>没有年龄，<code class="fe lw lx ly lz b">Mike</code>不是有效的<code class="fe lw lx ly lz b">PetType</code>。</p><pre class="kj kk kl km gt md lz me mf aw mg bi"><span id="570b" class="mh mi it lz b gy mj mk l ml mm">Spot,7,Dog<br/>Alice,14,Cat<br/>Rambo,,Dog<br/>Mike,3,Raccoon</span></pre><p id="08ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为对<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>的<code class="fe lw lx ly lz b">map</code> <em class="lv"> </em>操作也能捕捉到任何可能发生的错误，所以不会真的出错。稍后，当我们想知道我们的操作是否成功时，我们执行类型检查，要么从<code class="fe lw lx ly lz b">Success</code>中提取结果值，要么从<code class="fe lw lx ly lz b">Failure</code>中提取错误。</p><p id="0caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印上述示例的结果将产生以下结果:请注意我们是如何收到发生的第一个错误的，这个错误发生在我们试图提取兰博的年龄时。在文件由于任何原因不可访问的情况下，<code class="fe lw lx ly lz b">Failure</code>将包含一些I/O异常的消息。</p><pre class="kj kk kl km gt md lz me mf aw mg bi"><span id="8ad4" class="mh mi it lz b gy mj mk l ml mm">Failure(For input string: "")</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3675" class="mu mi it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">第一次尝试</h1><p id="d042" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">如上所示的基本<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>很容易实现，让我们从最常见的情况开始，构造它，映射值，并将其与另一个<code class="fe lw lx ly lz b">Try</code>组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kotlin中Try的简单实现</p></figure><p id="387d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<em class="lv">数据类型</em>可以用Kotlin中的密封类实现，密封类是一个抽象类，只能在同一个文件中扩展。这保证了在其他地方不会有其他实现，因为一个<code class="fe lw lx ly lz b">Try</code>只有两个子类型<code class="fe lw lx ly lz b">Success</code> <em class="lv"> </em>和<code class="fe lw lx ly lz b">Failure</code>。</p><p id="1263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密封的类<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>有一个实现<code class="fe lw lx ly lz b">invoke</code>的伴随对象，它允许你调用<code class="fe lw lx ly lz b">Try</code>，就像你调用它的构造函数一样，如上面的例子所示，这不是必须的，但使它更有表现力。</p><p id="1241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">invoke</code>包含您必须编写的最后一个try-catch块，它执行您传递给它的函数，并返回<code class="fe lw lx ly lz b">Success</code> <em class="lv"> </em>或<code class="fe lw lx ly lz b">Failure</code>。</p><p id="3a76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">Try</code>还定义了<code class="fe lw lx ly lz b">map</code> <em class="lv"> </em>和<code class="fe lw lx ly lz b">flatMap</code> <em class="lv"> </em>操作的签名，这样无论我们最终使用哪种类型，我们都可以使用它们。</p><blockquote class="nq"><p id="c09a" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">“做或不做，没有尝试”——尤达</p></blockquote><p id="c8e1" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">对于<code class="fe lw lx ly lz b">Failure</code> <em class="lv"> </em>的情况，实现它非常简单，因为它只保留一个异常，否则，它现在不做任何事情，这两个操作只是再次返回<code class="fe lw lx ly lz b">Failure</code> <em class="lv"> </em>，因为我们没有值可操作。</p><p id="f85f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">Success</code> <em class="lv"> </em>保存实际值并可以操作它，<code class="fe lw lx ly lz b">map</code> <em class="lv"> </em>只是简单地接受您传递给它的函数并提取值，包装在新的<code class="fe lw lx ly lz b">Try</code>中，这也给了我们不变性。</p><p id="83de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">flatMap</code> <em class="lv"> </em>有点复杂，因为传入的函数也返回一个<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>，而你不想以一个<code class="fe lw lx ly lz b">Try&lt;Try&lt;T&gt;&gt;</code>结束，而是以一个<code class="fe lw lx ly lz b">Try&lt;T&gt;</code>结束，所以我们需要提取我们得到的运算结果，这允许将两个<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>合并成一个。</p><p id="2659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们将看到为什么这是一个重要的操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/644872535cdddf9c5c0ac3789c46b8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lqa5nlNFmKjevA8HBdXTxQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一次尝试的工作流程。如果成功，则执行操作；否则，不执行任何操作，并跳到结尾。</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a585" class="mu mi it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">没那么快！</h1><p id="0ac0" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">如果你开始采用这种编程风格，你可能就不会有像<code class="fe lw lx ly lz b">toPet</code>这样随机抛出异常<em class="lv"> </em>的函数了。</p><p id="ff7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟，这个构造的一个目的是实现更多的引用透明性，因此，<code class="fe lw lx ly lz b">toPet</code>函数可能会返回一个<code class="fe lw lx ly lz b">Try&lt;Pet&gt;</code>。</p><p id="ced9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，对<code class="fe lw lx ly lz b">PetType</code>的查找也将返回一个<code class="fe lw lx ly lz b">Try&lt;PetType&gt;</code>。这将使事情对调用者来说更清楚，使用起来更安全，但也使处理起来更复杂，因为我们现在有了所有这些包含我们数据的<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>，我们需要将它们组合起来。</p><p id="be4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这就是我们进行<code class="fe lw lx ly lz b">flatMap</code> <em class="lv"> </em>操作的原因。我们来看一个改编版的<code class="fe lw lx ly lz b">toPet</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="ed57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有对<code class="fe lw lx ly lz b">toPet</code>错误安全的每个调用有一个明显的优势，现在，如果出了问题，例如，你的文件中的一行没有工作，它不会终止你的计算，你也不会丢失所有其他的结果。相反，你有一个包含成功<em class="lv"> </em>和失败的列表。</p><p id="ca1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经意识到我们现在处理的是一个<code class="fe lw lx ly lz b">Try&lt;List&lt;Try&lt;Pet&gt;&gt;&gt;</code>，这的确很糟糕，像这样的嵌套类型会让你头疼，但这是我选择这个例子的主要原因，因为它是一个非常真实的场景。</p><p id="dd09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还开始说明，当处理依赖值而不是简单的操作链时，我们会很快变得难以理解上面这样的嵌套map语句，但我们可以处理所有这些。</p><p id="084d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出现在看起来像下面这样，我们看到尽管有错误，但我们很好地保存了结果和异常。</p><pre class="kj kk kl km gt md lz me mf aw mg bi"><span id="6592" class="mh mi it lz b gy mj mk l ml mm">[Success(Pet(name=Spot, age=7, type=Dog)), <br/>Success(Pet(name=Alice, age=14, type=Cat)), <br/>Failure(For input string: ""), <br/>Failure(No Pet Type: Raccoon)]</span></pre><p id="5b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你平时会怎么和<code class="fe lw lx ly lz b">toPet</code>打交道？您会用try-catch包围这些操作，抑制所有错误并返回一个空值吗？或者您会让它抛出一个异常吗？或者您会使用一个<code class="fe lw lx ly lz b">NullObject</code>模式吗？</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b934" class="mu mi it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">带Try的集合</h1><p id="a0cf" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">由于像<code class="fe lw lx ly lz b">Try</code>这样的集合和构造的组合可能会有点烦人，所以一个<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>在野外的实现通常比一个<code class="fe lw lx ly lz b">map</code> <em class="lv"> </em>和一个<code class="fe lw lx ly lz b">flatMap</code> <em class="lv"> </em>拥有更多的功能，而是一系列的实用程序，它们涵盖了你在使用这种构造时会遇到的许多用例。</p><p id="b118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，在处理集合时有一些方便的扩展，例如我们可以实现的<code class="fe lw lx ly lz b">traverse</code> <em class="lv"> </em>或<code class="fe lw lx ly lz b">partition</code> <em class="lv"> </em>，只是给你一个例子。</p><h2 id="3fb7" class="mh mi it bd mv og oh dn mz oi oj dp nd li ok ol nf lm om on nh lq oo op nj oq bi translated">遍历集合</h2><p id="8148" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated"><code class="fe lw lx ly lz b">Traverse</code></p><p id="6d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反过来，这意味着您将再次丢失所有成功的结果，但通常我们并不在乎，它允许我们无缝地使用一个函数返回一个集合类型的<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>和<em class="lv"> </em>。</p><p id="a768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以实现如下的<code class="fe lw lx ly lz b">traverse</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="365f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带有<code class="fe lw lx ly lz b">traverse</code> <em class="lv"> </em>的pet示例如下所示。</p><p id="0a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们如何用<code class="fe lw lx ly lz b">traverse</code> <em class="lv"> </em>操作替换列表映射，并使用<code class="fe lw lx ly lz b">flatMap</code> <em class="lv"> </em>将来自<code class="fe lw lx ly lz b">toPet</code>的内部<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>与来自读取文件的外部<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>组合成一个包含最终结果或错误的文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用traverse将文件中的线条映射到Pet对象。</p></figure><p id="6ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于第一个错误发生在获取兰博的年龄时，我们得到了与第一个例子相同的输出，但是，因此，我们得到了一个非常简洁的易于处理的<code class="fe lw lx ly lz b">Try&lt;List&lt;Pet&gt;&gt;</code>。</p><pre class="kj kk kl km gt md lz me mf aw mg bi"><span id="9d17" class="mh mi it lz b gy mj mk l ml mm">Failure(For input string: "")</span></pre><h2 id="02b1" class="mh mi it bd mv og oh dn mz oi oj dp nd li ok ol nf lm om on nh lq oo op nj oq bi translated">划分集合</h2><p id="2157" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">另一方面，一个<code class="fe lw lx ly lz b">partition</code> <em class="lv">，</em>会给你一个带有两个列表的<code class="fe lw lx ly lz b">Pair</code> <em class="lv"> </em>，一个带有所有成功的<em class="lv"> </em>和一个带有所有失败的<code class="fe lw lx ly lz b">Pair&lt;List&lt;Success&gt;, List&lt;Failure&gt;&gt;&gt;</code>，这样一个<code class="fe lw lx ly lz b">Pair&lt;List&lt;Success&gt;, List&lt;Failure&gt;&gt;&gt;</code>，它允许你保存结果和错误，并根据你的需要分别处理它们。</p><p id="b2cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们在下面的代码中是如何为列表对引入一个类型别名的，如果你想让函数接受或返回这个类型，我推荐你这样做，只是为了可读性。</p><p id="7109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然一开始看起来不必要的复杂，但是我们可以为这种类型创建更容易使用的扩展方法，例如，在成功列表中映射<em class="lv"> </em>值的函数。</p><p id="07b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以轻松有效地处理成功的结果，同时避免错误，而不必再想太多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用谓词对列表进行分区会将谓词为真的所有值放在左边，将谓词为假的所有值放在右边。</p></figure><p id="dbe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们现在再次考虑我们最初的pet例子时，我们可以使用<code class="fe lw lx ly lz b">partition</code>和<code class="fe lw lx ly lz b">type</code>别名。</p><p id="82fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们通过使用我们的<code class="fe lw lx ly lz b">ResultSet</code>类型的<code class="fe lw lx ly lz b">map</code>方法，将所有成功导入的宠物的名字转换成大写字母，这隐藏了我们在这里实际处理的嵌套类型的笨拙。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="0403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不可否认，当首先使用这个抽象级别时，会有许多用例需要发现。</p><p id="6bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然开始时它看起来有点像兔子洞，但它有一个终点，结果是，有希望保存更安全和更干净的代码。</p><p id="c444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上例所示，输出如下。我们可以看到，我们成功地转化了成功的<em class="lv"> </em>，同时也保留了所有的失败<em class="lv"> </em>。</p><pre class="kj kk kl km gt md lz me mf aw mg bi"><span id="8b2a" class="mh mi it lz b gy mj mk l ml mm">([Success(Pet(name=SPOT, age=7, type=Dog)), <br/>Success(Pet(name=ALICE, age=14, type=Cat))], <br/>[Failure(No Pet Type: Raccoon), <br/>Failure(For input string: "")])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/fd8966eccc8f11c9aa7c75bf06615286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6NBeul71rcG4_Sr5Dq0sg.jpeg"/></div></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e757" class="mu mi it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">是时候恢复了</h1><p id="2eb2" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">有时，一个错误并不是世界末日，在某些情况下，您可能不太在意，宁愿有一些默认值而不是错误消息，或者您可能发现异常产生的某个错误消息没有传达足够的信息。</p><p id="11ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与用于转换<code class="fe lw lx ly lz b">Success</code>中的值的<code class="fe lw lx ly lz b">map</code> <em class="lv"> </em>和<code class="fe lw lx ly lz b">flatMap</code> <em class="lv"> </em>类似，您可以添加等效的方法，有时称为<code class="fe lw lx ly lz b">recover</code> <em class="lv"> </em>和<code class="fe lw lx ly lz b">recoverWith</code>，来转换<code class="fe lw lx ly lz b">Failure</code>中的错误并执行一个动作来补偿错误。</p><p id="9e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">recover</code> <em class="lv"> </em>基本上允许您提供一个在异常情况下返回默认值的函数，而<code class="fe lw lx ly lz b">recoverWith</code> <em class="lv"> </em>允许您提供一个替代的<code class="fe lw lx ly lz b">Try</code> <em class="lv">。</em></p><p id="b972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的宠物例子，假设我们对解析年龄时得到的错误消息不满意，而且业务需求已经改变，现在我们应该导入一个无效类型的宠物，将它们标记为<code class="fe lw lx ly lz b">Invalid</code>。</p><p id="6de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用恢复来调整<code class="fe lw lx ly lz b">toPet</code>以适应这些需求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="ecd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了改变我们在年龄解析不成功时收到的错误消息，我们使用<code class="fe lw lx ly lz b">recoverWith</code> <em class="lv"> </em>并用另一个包含“更好”错误消息的<code class="fe lw lx ly lz b">Failure</code>替换<code class="fe lw lx ly lz b">Failure</code>。</p><p id="77d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了丢弃提取类型和使用<code class="fe lw lx ly lz b">Invalid</code>作为默认<code class="fe lw lx ly lz b">PetType</code>时出现的任何错误，我们简单地使用<code class="fe lw lx ly lz b">recover</code>。</p><p id="20b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当使用这个改编版本的<code class="fe lw lx ly lz b">toPet</code>运行最后一个示例时，我们得到了一个不同的输出。</p><p id="baf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所料，我们只有一个<code class="fe lw lx ly lz b">Failure</code>，现在告诉我们，我们无法提取年龄，其中<code class="fe lw lx ly lz b">Mike</code>现在被成功导入，并获得默认的宠物类型。</p><pre class="kj kk kl km gt md lz me mf aw mg bi"><span id="4e4d" class="mh mi it lz b gy mj mk l ml mm">[Success(Pet(name=Spot, age=7, type=Dog)), <br/>Success(Pet(name=Alice, age=14, type=Cat)), <br/>Failure(Cannot extract age!), <br/>Success(Pet(name=Mike, age=3, type=Invalid))]</span></pre><blockquote class="nq"><p id="b0f8" class="nr ns it bd nt nu or os ot ou ov lu dk translated">"程序是对计算机施的咒语，将输入转化为错误信息."—匿名</p></blockquote></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ff33" class="mu mi it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">一点糖</h1><p id="9271" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">我不喜欢上面版本的<code class="fe lw lx ly lz b">toPet</code>中嵌套的<code class="fe lw lx ly lz b">flatMap</code> <em class="lv"> </em>和<code class="fe lw lx ly lz b">map</code> <em class="lv"> </em>表达式，在Scala中，有一个特殊的<em class="lv"> for-expression </em>，你可以在每一个支持这两种运算的代数数据类型上使用，这使得它更具表现力。</p><p id="0115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Kotlin <em class="lv"> </em>没有对应的语言，但它是一种非常强大的语言，允许很多恶作剧。我从<a class="ae ky" href="https://arrow-kt.io/" rel="noopener ugc nofollow" target="_blank"> Arrow </a> <em class="lv"> </em>库中借鉴了这种方法的思想，该库中所有的代数数据类型都有相似的语法，我想在结束之前介绍一下。</p><p id="8dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其思想是，按顺序计算的相关值可以简单地按顺序解包，出现的任何错误都会中断序列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">以命令式方式处理依赖类型</p></figure><p id="0bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我很喜欢这个缩写，因为析构声明的括号也清楚地表明结果可能不会成功。</p><p id="e7ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现这一点相当简单，至少对于一个<code class="fe lw lx ly lz b">Try</code>来说是这样，利用接收器对象和作用域扩展方法。</p><p id="3042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于扩展方法只在<code class="fe lw lx ly lz b">TrySequence</code>对象中可用，我们只能在以它为接收类型的lambda表达式中使用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="c8fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，顺序操作和常规的<code class="fe lw lx ly lz b">invoke</code> <em class="lv"> </em>在<em class="lv"> </em> <code class="fe lw lx ly lz b">Try</code>上区别不大。我们可以给它一个函数来产生一个值，然后我们把这个值提取到一个<code class="fe lw lx ly lz b">Try</code>中。</p><p id="5e3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的区别是我们添加了扩展来析构一个<code class="fe lw lx ly lz b">Try</code>，它将返回一个值或者抛出一个异常。这个异常终止了lambda，但是被周围的<code class="fe lw lx ly lz b">Try</code>捕获。</p><p id="544d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它除了为我们提供更富表现力的处理方式之外，别无它用。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b3fa" class="mu mi it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">最后的想法</h1><p id="6a4b" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">无论函数式编程是否是您的难题，采用这种错误处理方式都有一些明显的优势。</p><p id="75b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向函数的调用者明确说明它可能会产生错误会给代码带来很大的好处。</p><p id="f18c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包含错误而不抛出异常会使事情变得更加稳定和可预测，也使您的程序更容易推理，因为异常不再是发生在代码之外的事情，相反，错误处理的整个概念只是成为一种新的类型，可以按照您喜欢的方式进行扩展和控制。</p><p id="5d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异常本质上是有问题的，因为它们的运行时开销。Java中的异常在创建时捕获其调用堆栈的快照，这是一个相当昂贵的操作，因此不建议使用异常和随后的<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>来控制程序流。</p><p id="476a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe lw lx ly lz b">Try</code>只与异常兼容，所以有一种更通用的代数数据类型，它以更通用的方式抽象了失败，因为它的错误情况并不局限于异常，例如，它允许您简单地使用字符串来传递错误消息，这种类型称为<code class="fe lw lx ly lz b">Either</code> <em class="lv"> </em>，其工作方式非常类似。</p><p id="8488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面的<code class="fe lw lx ly lz b">Try</code> <em class="lv"> </em>作为处理异常的机制肯定有它的位置，因为在很多情况下，您没有选择，只需要处理异常。</p><p id="6906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里开发和使用的<code class="fe lw lx ly lz b">Try</code>的最终代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="0660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程的世界充满了许多这样的代数数据类型，还有更多概念和模式有待探索。</p><p id="7632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到Kotlin，似乎有一个或多或少全面的库，我在本文中提到过几次，名为<em class="lv"> Arrow，</em>如果您有兴趣进一步了解这个<em class="lv">，可能值得一试。</em></p><div class="ow ox gp gr oy oz"><a href="https://github.com/arrow-kt/arrow" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">箭头-kt/箭头</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">rrow是Kotlin中用于类型化函数编程的库。Arrow的目标是提供一个界面和…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ks oz"/></div></div></a></div><p id="06ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细考虑你是要写你自己的代数数据类型库，还是修改现有的库。</p><p id="f492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果您开始使用这种结构，它将很快遍布您的代码库。</p><p id="99f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于您自己拙劣的实现或者因为您选择的库走了一条不同的路，并且刚刚否决了您最喜欢的数据类型，不得不进行重构，这肯定会令人头痛，但这是值得的。</p><p id="02ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的阅读！</p></div></div>    
</body>
</html>