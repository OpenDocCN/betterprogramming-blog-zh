<html>
<head>
<title>Step-By-Step Classification Modeling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逐步分类建模</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/step-by-step-classification-modeling-6d820c5bea2?source=collection_archive---------3-----------------------#2020-12-10">https://betterprogramming.pub/step-by-step-classification-modeling-6d820c5bea2?source=collection_archive---------3-----------------------#2020-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7f2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何创建任何分类模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18ad332e9052bbcecdf9c104891bbe23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxeMHxQafoKp69lcZG9ZPw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://www.aoe.com/en/blog/solving-problems-and-improving-customer-relationships-with-machine-learning-000718.html" rel="noopener ugc nofollow" target="_blank"> AOE </a>。</p></figure><p id="16f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是机器学习领域的初学者，并且正在为分类建模的机制而奋斗，那么这篇文章就是您分类冒险的路线图。</p><p id="0dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，知道你在寻找什么是很重要的。确定您的问题，并开始探索与您的问题相关的数据。这样可以省去你很多时间和困惑。</p><p id="b0d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于任何数据集，您首先要做的是清理数据集并进行探索性数据分析:</p><ul class=""><li id="5238" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">检查空值</li><li id="afae" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">占位符</li><li id="46e1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">检查异常值</li><li id="fc16" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">特征工程</li><li id="69be" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">绘制有意义的图形</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="38ed" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.训练测试数据集</h1><h2 id="8386" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">确定目标变量和预测值</h2><p id="0694" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在列车试运行前，确定目标变量<code class="fe nz oa ob oc b">y</code>和自变量<code class="fe nz oa ob oc b">X</code>。</p><p id="9380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="od">注意:如果你曾经想知道为什么一个目标变量用小写</em> <code class="fe nz oa ob oc b"><em class="od">y</em></code> <em class="od">定义，而预测变量用大写</em> <code class="fe nz oa ob oc b"><em class="od">X</em></code> <em class="od">定义，那是因为</em> <code class="fe nz oa ob oc b"><em class="od">X</em></code> <em class="od">是一个矩阵，矩阵用大写字母命名。</em></p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="d616" class="ni mr it oc b gy oi oj l ok ol">y = df['target']</span><span id="a5f6" class="ni mr it oc b gy om oj l ok ol">X = df.drop('target', axis=1)</span></pre><h2 id="fc5d" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">列车测试分离</h2><p id="18a9" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">训练测试分割是任何建模中最重要的步骤之一。这一步将允许您比较模型的性能。在训练集上训练该模型，然后将结果与测试集进行比较。训练测试分割有助于避免过度适应或适应不足。</p><p id="875b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Sklearn有一个内置的函数叫做<code class="fe nz oa ob oc b">train_test_split</code>。训练模型时，必须设置<code class="fe nz oa ob oc b">random_state</code>参数，以获得相同的训练和测试数据集。</p><p id="1321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个训练测试分割数据集，比率为80/20，并且<code class="fe nz oa ob oc b">random_state</code>设置为<code class="fe nz oa ob oc b">123</code>:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="9615" class="ni mr it oc b gy oi oj l ok ol">X_train, X_test, y_train, y_test = train_test_split(X, y,  test_size=.2, random_state=123)</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f558" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.预处理数据</h1><p id="ba2a" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">将预处理步骤分别应用于训练和测试数据集，以避免数据泄漏。</p><h2 id="5a02" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">OneHotEncoder()</h2><p id="0d01" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果用于分类模型的数据集包括分类和/或布尔类型的列，使用<code class="fe nz oa ob oc b">OneHotEncoder</code>将它们转换成数字数组。</p><p id="32bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，确定分类列并启动<code class="fe nz oa ob oc b">OneHotEncoder</code>:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="a7da" class="ni mr it oc b gy oi oj l ok ol">categorical_columns = df.select_dtypes(include=[‘object’,    ‘bool’]).columns</span><span id="714d" class="ni mr it oc b gy om oj l ok ol">ohe = OneHotEncoder(handle_unknown=’ignore’)</span></pre><h2 id="9637" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">数据标准化</h2><p id="8e50" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果数据集具有不同大小范围的数值要素，则应归一化数据以在相同比例下创建数据集。</p><p id="8dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">StandardScaler</code>和<code class="fe nz oa ob oc b">MinMaxScaler</code>是非常流行的数据归一化方法:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="881c" class="ni mr it oc b gy oi oj l ok ol">numerical_columns = df.select_dtypes(include=[‘int64’,             ‘float64’]).columns</span><span id="ddce" class="ni mr it oc b gy om oj l ok ol">scaler = StandardScaler()</span></pre><h2 id="6763" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">列变压器()</h2><p id="816d" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">这会将转换器应用于数组或pandas数据帧的列。</p><p id="947f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多信息参见<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="16b0" class="ni mr it oc b gy oi oj l ok ol">preprocessor = ColumnTransformer(<br/>               transformers =[<br/>                          ('num', 'scaler', 'numeric_columns),<br/>                          ('cat', 'ohe', 'categorical_columns')])</span></pre><h2 id="cabd" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">递归特征消除</h2><p id="3572" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">预测目标变量时，递归要素消除(简称RFE)可确定数据集中最重要的要素。</p><p id="c8f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，通过选择<em class="od"> n </em>个特征来演示RFE算法的启动:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="37b3" class="ni mr it oc b gy oi oj l ok ol">rfe = RFE(estimator = LogisticRegression(), <br/>          n_features_to_select = n)</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="009e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.建模</h1><h2 id="e4ec" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">实例化分类算法</h2><p id="0091" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">用合适的参数实例化你的分类算法。如果您的预测值不够好，您可以使用网格搜索来找到适合模型的最佳参数:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="91a8" class="ni mr it oc b gy oi oj l ok ol">model = LogisticRegression(fit_intercept = True,<br/>                           solver = 'liblinear',<br/>                           class_weight = 'balanced',<br/>                           random_state = 123)</span></pre><h2 id="9c36" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">创建管道</h2><p id="2393" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在实例化适当的分类算法之后，您需要创建一个管道。该管道将允许数据转换、特征选择和获取分类模型属性:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="ea72" class="ni mr it oc b gy oi oj l ok ol">pipeline = Pipeline(steps=[('preprocessor', preprocessor),<br/>                           ('s', rfe), <br/>                           ('m', model)])</span></pre><h2 id="2783" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">拟合模型</h2><p id="8268" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">记得在训练集上安装模型。使用测试数据集进行预测:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="2876" class="ni mr it oc b gy oi oj l ok ol">pipeline.fit(X_train, y_train)</span></pre><p id="d2a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nz oa ob oc b">.score</code>方法控制训练和测试数据集的分数。高训练和测试分数表明你的模型是好的。需要进一步评估以确定模型是否可信:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="24f4" class="ni mr it oc b gy oi oj l ok ol">Train Score: <br/>pipeline.score(X_train, y_train)</span><span id="7363" class="ni mr it oc b gy om oj l ok ol">Test Score:<br/>pipeline.score(X_test, y_test))</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9bc3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.模型检查</h1><h2 id="a963" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">模型预测和残差</h2><p id="f6e1" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated"><code class="fe nz oa ob oc b">.predict</code>方法将提供模型预测器:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="8935" class="ni mr it oc b gy oi oj l ok ol">y_hat_train = pipeline.predict(X_train)</span><span id="8713" class="ni mr it oc b gy om oj l ok ol">y_hat_test = pipeline.predict(X_test)</span></pre><p id="770f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">残差可以通过从原始值中减去预测值来计算，它们是<code class="fe nz oa ob oc b">y_train</code>和<code class="fe nz oa ob oc b">y_test</code>。</p><h2 id="ac63" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">混淆矩阵</h2><p id="0fc1" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">要绘制混淆矩阵，使用<code class="fe nz oa ob oc b">sklearn.metrics</code>中的<code class="fe nz oa ob oc b">plot_confusion_matrix</code>功能:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="df1a" class="ni mr it oc b gy oi oj l ok ol">plot_confusion_matrix(pipeline, X_test, y_test, cmap=plt.cm.Blues)</span></pre><p id="e631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可视化实际标注和预测标注的一种很好的方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/e081d8d9e88196d60d40e681a40e3295.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*NCdTz7BMvGaQYPoPz5TMZg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混淆矩阵</p></figure><p id="22fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，你可以看到一个混淆矩阵图。根据您的分类模型，y轴是真实标签，x轴是预测标签。目标在0类中有708 (673+35)个值，在1类中有126 (101+25)个值。</p><p id="cd10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左上角的框(673)表示由分类模型正确预测的0值。右上角的框(35)表示分类模型预测不正确的0值。你的目标是减少错误预测值的数量。</p><h2 id="d878" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">分类报告</h2><p id="4c35" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">使用<code class="fe nz oa ob oc b">sklearn.metrics</code> <em class="od"> </em>中的<code class="fe nz oa ob oc b">classification_report</code>功能创建评估指标表。下表显示了模型的质量:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="e96b" class="ni mr it oc b gy oi oj l ok ol">classification_report(y_test, y_test_pred)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/fab2b81a581c2906f1cfe0b6de993961.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*5SfNJt7-gXwYMbIy5p_W1w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分类矩阵</p></figure><p id="2095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">Precision</code>测量预测值的精确程度:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="b344" class="ni mr it oc b gy oi oj l ok ol">Precision = Number of True Positives / Number of Predicted Positives</span></pre><p id="40ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">Recall</code>表示模型捕获的类别百分比:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="8cb2" class="ni mr it oc b gy oi oj l ok ol">Recall = Number of True Positives / Number of Actual Total Positives</span></pre><p id="467d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">F1-Score</code>是<code class="fe nz oa ob oc b">Precision</code>和<code class="fe nz oa ob oc b">Recall</code>的加权平均值:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="feae" class="ni mr it oc b gy oi oj l ok ol">F1-Score = 2 * (Precision * Recall) / (Precision + Recall)</span></pre><p id="94be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查模型质量时，必须确定哪些评估指标对数据集更重要。</p><h2 id="4d1d" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">AUC评分和ROC曲线</h2><p id="ec2e" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">AUC得分和ROC曲线是提供模型质量信息的其他评估指标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="f475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的模型没有<code class="fe nz oa ob oc b">decision_function</code> <em class="od"> </em>属性，您可以尝试使用<code class="fe nz oa ob oc b">model.predict_proba</code>功能。</p><p id="673b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于完美的ROC曲线，曲线下面积应为1.0。AUC值在0.5到1之间，其中0.5表示差的分类器，1表示好的分类器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/0a5aa8fa48219ae83b702ad6aeaf52ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*kLtLvs96U8sRujoiPWQy7w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">受试者工作特征曲线</p></figure><p id="45d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图显示了分类模型的ROC曲线。很明显模型做的不是很好。目标是获得接近1的AUC分数和曲线下最大面积(1.0)的ROC曲线。大约0.5的AUC分数并不比预测随机掷硬币好多少。</p><h2 id="1188" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">特征重要性</h2><p id="4b0e" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">这将评估分类模型中功能的重要性:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="e0ee" class="ni mr it oc b gy oi oj l ok ol">pipeline.feature_importances_</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="300c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">5.模型调整</h1><p id="c1b6" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果分类模型结果不令人满意，下一步就是模型调整。每个问题都需要依赖于数据集和所选分类算法的解决方案。有时，该模型不适合为您拥有的数据集获得良好的预测。你可能需要一种新的数据处理方法。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ce8a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="da2d" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">恭喜你！您已经完成了您的分类模型。请参考我的<a class="ae ky" href="https://github.com/ulkuguneysu/Customer_Churn_Analysis" rel="noopener ugc nofollow" target="_blank">客户流失分析回购</a>看更详细的例子。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ee75" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><ul class=""><li id="23e7" class="lv lw it lb b lc nu lf nv li os lm ot lq ou lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/ulkuguneysu/Customer_Churn_Analysis" rel="noopener ugc nofollow" target="_blank">https://github.com/ulkuguneysu/Customer_Churn_Analysis</a></li><li id="ae0b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/</a></li><li id="445e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://machinelearningmastery.com/" rel="noopener ugc nofollow" target="_blank">machinelearningmastery.com</a></li></ul></div></div>    
</body>
</html>