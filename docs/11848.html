<html>
<head>
<title>6 Powerful Ramda Functions For JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的6个强大的Ramda函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-powerful-ramda-functions-for-javascript-7b0326c3f1d1?source=collection_archive---------8-----------------------#2022-04-21">https://betterprogramming.pub/6-powerful-ramda-functions-for-javascript-7b0326c3f1d1?source=collection_archive---------8-----------------------#2022-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bef0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个快速和功能强大的库，用于增强您的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/43b366ba02da186102bdc5c035f4c02e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TakuG8rQ0tNysii6u_Zk6g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2ce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你没有听说过用于JavaScript的Ramda库，那么你就错过了这种语言的一个漂亮的增强。这个库塞满了大量有用的函数和实用程序，它们不仅能解决常见问题，还能让JavaScript在函数式编程方面做得更好。</p><p id="bb64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ramda是作为一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">功能</a>库开发的，它提供了简洁、优雅但最重要的<em class="lv">功能</em>实用程序。这意味着许多包含的函数几乎没有副作用，被<a class="ae ky" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">处理</a>并提供灵活的管道接口。有了Ramda，你最终可以在JavaScript中实现函数式编程原则。</p><p id="0bbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索该库提供的几个我最喜欢的函数，并展示它们如何使您的代码更具功能性和减少重复性的示例。让我们开始吧。</p><h2 id="e296" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">1.<a class="ae ky" href="https://ramdajs.com/docs/#pathOr" rel="noopener ugc nofollow" target="_blank">病理</a></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/130a6acd8deabbf3ef2bb36c7d459c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsfQZd5asnmS7vIv34-7pw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://ramdajs.com/docs/#pathOr" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></figure><p id="0fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果说JavaScript中有一项任务一直在出现，那就是“挖掘”嵌套对象。想想有多少次你不得不从一个深度嵌套的对象中获取一个值。有多少次那个物体发生了轻微的变异或者丢失了一把钥匙？您真的应该手动检查链中每个中间密钥的存在吗？</p><p id="e07a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来很乏味。</p><p id="1f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请使用Ramda的<code class="fe mq mr ms mt b">pathOr</code>函数。这个函数可以代替少量的代码。看看这个:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="1437" class="lw lx it mt b gy my mz l na nb">const R = require('ramda');</span><span id="abf7" class="lw lx it mt b gy nc mz l na nb">let myObject = {<br/>  key1: {<br/>    key2: {<br/>      key3: { targetKey: 1234 }<br/>    }<br/>  }<br/>}</span><span id="aeca" class="lw lx it mt b gy nc mz l na nb">let path = ['key1', 'key2', 'key3', 'targetKey'];<br/>let result = R.pathOr(0, path, myObject);</span><span id="1826" class="lw lx it mt b gy nc mz l na nb">console.log(result);</span></pre><p id="5aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析一下这里发生了什么:</p><ul class=""><li id="39bc" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">首先，我们用一些数据设置一个简单的嵌套对象。我们的目标是拉出<code class="fe mq mr ms mt b">targetKey</code>值。</li><li id="b844" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">接下来，我们设置一个数组，其中包含我们将深入研究的有序键名。</li><li id="950c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">最后，我们应用<code class="fe mq mr ms mt b">pathOr</code>函数，传递一个默认值、路径和要键入的对象。</li></ul><p id="7539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe mq mr ms mt b">targetKey</code>不存在或者中间键之一丢失，那么<code class="fe mq mr ms mt b">pathOr</code>将返回第一个默认参数，即<code class="fe mq mr ms mt b">0</code>。</p><p id="e7ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次需要安全地挖掘嵌套对象时，只需使用<code class="fe mq mr ms mt b">pathOr</code>。</p><h2 id="9fa0" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">2.<a class="ae ky" href="https://ramdajs.com/docs/#clamp" rel="noopener ugc nofollow" target="_blank">夹钳</a></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/1372a3d4432c2d30968ac9afe7047ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vpkjRiSp9D-RDEAqZOh3SQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://ramdajs.com/docs/#clamp" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></figure><p id="c0be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的函数，但是非常方便。<code class="fe mq mr ms mt b">clamp</code>函数确保一个数字落在一个特定的范围内。这意味着，如果您传递一个过高或过低的数字，该函数会将该数字“箝位”到您提供的范围内最接近的可接受数字。</p><p id="d403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的例子:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="88fb" class="lw lx it mt b gy my mz l na nb">const R = require('ramda');</span><span id="7e51" class="lw lx it mt b gy nc mz l na nb">let result = R.clamp(10, 20, 5);</span><span id="f20a" class="lw lx it mt b gy nc mz l na nb">console.log(result);</span></pre><p id="3358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们将范围固定在10到20之间。当我们传入5时，这低于范围的底端，所以它改为固定到10。如果我们传入任何高于20的值，它会被固定到20。</p><p id="cb53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以将<code class="fe mq mr ms mt b">clamp</code>加入到它自己的自定义验证函数中，如下所示:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="df0d" class="lw lx it mt b gy my mz l na nb">let clampBetweenRange = R.clamp(10, 20);</span><span id="9be2" class="lw lx it mt b gy nc mz l na nb">let result = clampBetweenRange(5);</span><span id="8aea" class="lw lx it mt b gy nc mz l na nb">console.log(result)</span></pre><p id="dc2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特殊的功能有大量的应用。您可以将用户输入限制在特定的范围内，或者用它来防止来自其他处理管道的杂乱数据输出。</p><h2 id="5e60" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">3.<a class="ae ky" href="https://ramdajs.com/docs/#defaultTo" rel="noopener ugc nofollow" target="_blank">默认为</a></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/332e6b19b305a74b7755361f57babf39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6-aEa1pN0-qojSFvg2IUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://ramdajs.com/docs/#defaultTo" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></figure><p id="d63a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你被野生<code class="fe mq mr ms mt b">undefined</code>或<code class="fe mq mr ms mt b">null</code>烧伤过几次？有多少次你不得不回过头来为一个看似简单的功能构建一些复杂的<code class="fe mq mr ms mt b">try/catch</code>语句？</p><p id="fe56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mq mr ms mt b">defaultTo</code>功能，您可以避免这些麻烦。</p><p id="a59f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mq mr ms mt b">defaultTo</code>函数将接受默认值作为第一个参数，接受任何值作为第二个参数。如果第二个参数是<code class="fe mq mr ms mt b">null</code>、<code class="fe mq mr ms mt b">undefined</code>或<code class="fe mq mr ms mt b">NaN</code>，则返回第一个参数。这也可以加入到它自己的包装函数中，以获得可读性更强、更简洁的代码:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="6fa5" class="lw lx it mt b gy my mz l na nb">const R = require('ramda');</span><span id="1a0d" class="lw lx it mt b gy nc mz l na nb">let resultNotCurried = R.defaultTo('error', undefined);</span><span id="ce3c" class="lw lx it mt b gy nc mz l na nb">console.log(resultNotCurried);</span><span id="e80b" class="lw lx it mt b gy nc mz l na nb">let defaulted = R.defaultTo('error');<br/>let resultCurried = defaulted(undefined);</span><span id="705f" class="lw lx it mt b gy nc mz l na nb">console.log(resultCurried);</span></pre><p id="b706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，你所要做的就是将你的函数或数据包装在定制的<code class="fe mq mr ms mt b">defaulted</code>函数中，以避免错误的值。</p><h2 id="eb65" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">4.<a class="ae ky" href="https://ramdajs.com/docs/#has" rel="noopener ugc nofollow" target="_blank">有</a></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/1fe070f697100d04e8f4be585a794bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j58DSw9b9c4DshygXn07wA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://ramdajs.com/docs/#has" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></figure><p id="9235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这与JavaScript的内置<code class="fe mq mr ms mt b">hasOwnProperty</code>函数非常相似，但是有一个关键的区别。你可以咖喱这个功能，让它更优雅(很明显，<em class="lv">功能性</em>)。</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="0900" class="lw lx it mt b gy my mz l na nb">const R = require('ramda');</span><span id="d87c" class="lw lx it mt b gy nc mz l na nb">let hasAge = R.has('age');</span><span id="157b" class="lw lx it mt b gy nc mz l na nb">let myObject = { name: 'Bob', age: 24 }</span><span id="4a05" class="lw lx it mt b gy nc mz l na nb">console.log(hasAge(myObject));</span></pre><p id="2f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需将一个键名传递给<code class="fe mq mr ms mt b">has</code>就可以准备好这个定制的函数。现在，要检查键是否存在，您所要做的就是在新函数中包装对象。极致的便利。</p><p id="4ce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以使用一个<a class="ae ky" href="https://ramdajs.com/docs/#pipe" rel="noopener ugc nofollow" target="_blank"> Ramda管道</a>将它与前面的<code class="fe mq mr ms mt b">defaultTo</code>函数结合起来。这将创建一个可以轻松重用的健壮的数据验证管道。查看下一节的示例。</p><h2 id="954b" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">5.<a class="ae ky" href="https://ramdajs.com/docs/#tap" rel="noopener ugc nofollow" target="_blank">点击</a></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/bc0ef2080ce7c44327fb9dc120a1a027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WX1lCbyBkr2oRMby8dzxrA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://ramdajs.com/docs/#tap" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></figure><p id="c983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是否曾希望自己能进入管道的中间，看看在某一特定阶段发生了什么？通过<code class="fe mq mr ms mt b">tap</code>功能，你可以做到这一点。</p><p id="76ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将大量函数链接在一起时，中间的一些数据的状态可能会变得混乱。通过利用<code class="fe mq mr ms mt b">tap</code>，您可以记录一些输出或者将数据保存在其他地方以供查看。</p><p id="089f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个用Ramda“接入”管道中间的例子:</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="1764" class="lw lx it mt b gy my mz l na nb">const R = require('ramda');</span><span id="6302" class="lw lx it mt b gy nc mz l na nb">let logOutput = val =&gt; console.log(val);</span><span id="611b" class="lw lx it mt b gy nc mz l na nb">let pipeline = R.pipe(<br/>  R.inc,<br/>  R.tap(logOutput),<br/>  R.inc,<br/>  R.inc<br/>);</span><span id="35e4" class="lw lx it mt b gy nc mz l na nb">let result = pipeline(100);</span><span id="16a6" class="lw lx it mt b gy nc mz l na nb">console.log(result);</span></pre><p id="72a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是这些步骤的细目分类:</p><ul class=""><li id="463b" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">首先，我们设置一个函数来将我们的输出记录到控制台。这是一个简单的函数，它接受一个值并记录下来。</li><li id="d7d3" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">接下来，我们建立我们的管道。这是一个简单的Ramda管道，将逐渐增加一个数字。实际上，这可能是一个更复杂的处理数据的管道，但是对于这个例子，我们将保持它的简单。</li><li id="16b3" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">在我们的管道中间，我们插入了我们的<code class="fe mq mr ms mt b">tap</code>函数，并将我们的日志记录函数传递给它。</li><li id="19d4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">最后，我们调用管道并为其提供一个值。</li></ul><p id="c095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行上面的例子，您会看到控制台记录了两个值:<code class="fe mq mr ms mt b">101</code>和<code class="fe mq mr ms mt b">103</code>。</p><p id="41c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mq mr ms mt b">tap</code>和管道，我们可以很容易地调查步骤之间发生了什么，并减少检查复杂函数链的总工作量。</p><h2 id="1e64" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">6.<a class="ae ky" href="https://ramdajs.com/docs/#pluck" rel="noopener ugc nofollow" target="_blank">拔毛</a></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/6b1d1f652de11f523b7cadb5690ecb0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYdfBQvUiUmPzENFbaTV9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://ramdajs.com/docs/#pluck" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></figure><p id="c8da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数乍一看似乎很简单。JavaScript中的一个常见主题是处理对象列表。无论是从数据库返回的数据还是一些静态JSON对象，操作这些模型都是一项非常频繁的任务。</p><p id="591a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mq mr ms mt b">pluck</code>功能允许您通过从每个对象中“提取”数据来操作这些对象列表。通过指定要从每个对象中“提取”的关键点，可以从对象列表中生成新的值列表。</p><pre class="kj kk kl km gt mu mt mv mw aw mx bi"><span id="5249" class="lw lx it mt b gy my mz l na nb">const R = require('ramda');</span><span id="51dc" class="lw lx it mt b gy nc mz l na nb">let myObjects = [<br/>  { name: 'Bob', age: 22 },<br/>  { name: 'Sally', age: 32 }<br/>];</span><span id="a410" class="lw lx it mt b gy nc mz l na nb">let results = R.pluck('name', myObjects);</span><span id="fe8f" class="lw lx it mt b gy nc mz l na nb">console.log(results);</span></pre><p id="8bf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过指定要拾取的关键点并传入对象列表，您可以构建一个只包含这些关键点的新列表。</p><p id="9453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最棒的是,<code class="fe mq mr ms mt b">pluck</code>函数还可以处理不同类型的结构。你可以很容易地从列表和常规对象中选择。</p><h1 id="f8da" class="nv lx it bd ly nw nx ny mb nz oa ob me jz oc ka mh kc od kd mk kf oe kg mn of bi translated">结论</h1><p id="c9a3" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">函数式编程的世界可能非常庞大和复杂。Ramda库提供了一种清晰而简单的方式将这个世界带入JavaScript，而不会让开发人员不知所措。</p><p id="fd9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使你还没有喝函数式编程的Kool-Aid，对于更传统的开发风格，这个库中仍然有很多有用的函数。</p><p id="69b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要更深入地了解Ramda和函数式编程的基本原理，请查看由Marius Ibsen 撰写的<a class="ae ky" href="https://medium.com/compendium/ramda-your-javascript-e72bfaef01d5" rel="noopener"><em class="lv">Ramda your JavaScript</em></a>。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="63d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！如果你喜欢这篇文章，可以看看下面我写的其他一些JavaScript文章:</p><ul class=""><li id="e509" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/6-operating-system-emulators-written-entirely-in-javascript-5506a4df2d04"> <em class="lv"> 6个完全用JavaScript编写的操作系统模拟器</em> </a></li><li id="1ccf" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://medium.com/swlh/the-best-javascript-audio-libraries-for-manipulating-sound-6fe319e32d49" rel="noopener"> <em class="lv">操纵声音的最佳JavaScript音频库</em> </a></li></ul></div></div>    
</body>
</html>