<html>
<head>
<title>How to Write Conway’s “Game of Life” in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python写康威的《生命的游戏》</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-conwells-game-of-life-in-python-c6eca19c4676?source=collection_archive---------0-----------------------#2020-01-21">https://betterprogramming.pub/how-to-write-conwells-game-of-life-in-python-c6eca19c4676?source=collection_archive---------0-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="346e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个有趣的网格游戏的例子，为您建立</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c742b7c46ce6d263c1b197933f917d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hgLARSBS0BTnhMgB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@michael_schiffer_design?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克尔·希弗</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="ecb6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="b631" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这篇文章中，我将指导你编写约翰·何顿·康威在1970年发明的“生活游戏”。</p><p id="0688" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你是这个游戏的新手，你可以在这里了解更多:<a class="ae ky" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" rel="noopener ugc nofollow" target="_blank">维基百科——生活游戏</a></p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="bcd7" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">游戏的简要总结</h1><p id="763a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你有一个包含细胞的网格。它们可以生也可以死。</p><p id="36a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相邻细胞的状态决定了该细胞是死亡、繁殖还是存活到下一代。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b5347bb723091109456e520bd6e8f65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*qFxV4ZE9i_VxVbmv95ViqQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查单元格“E”。它有五个死去的邻居(A，B，C，H，I)和三个活着的邻居(D，F，G)</p></figure><p id="4285" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果一个单元是<strong class="lt iu">活的</strong>，它将:</p><ul class=""><li id="d1d5" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated">如果活着的邻居少于两个，就会死去。</li><li id="d0db" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">如果正好有两三个活着的邻居，继续生活。</li><li id="8fbe" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">如果有三个以上活着的邻居，就会死去。</li></ul><p id="a8be" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果细胞<strong class="lt iu">死亡</strong>，它将:</p><ul class=""><li id="a113" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated">如果正好有三个活着的邻居，复活。</li></ul><p id="c24e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上面的例子中，如果E死了，它会复活——因为它有三个活着的邻居——如果它活着，它会保持活着——因为它正好有两三个活着的邻居</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="7699" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">分解Python部分</h1><p id="6211" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个游戏最大的两个部分是<em class="nt">细胞</em>和<em class="nt">棋盘</em>。我们将为这些创建两个类:<code class="fe nu nv nw nx b">cell.py</code>和<code class="fe nu nv nw nx b">board.py</code>。</p><h2 id="8a49" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">单元格. py</h2><p id="97fc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">先说细胞。所有细胞最初都会死亡。我们将随机生成第一代的死亡或活着状态。对于下一代，上述规则适用。</p><p id="c199" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还需要检查细胞是否存活的能力，我们将创建一个方法函数，根据细胞状态告诉电路板打印什么。以下是方法:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="84f2" class="ny la it nx b gy oo op l oq or">#set status to dead<br/>def set_dead(self):</span><span id="e46a" class="ny la it nx b gy os op l oq or">#set status to alive<br/>def set_alive(self):</span><span id="27e2" class="ny la it nx b gy os op l oq or">#is the cell alive?<br/>def is_alive(self):</span><span id="3442" class="ny la it nx b gy os op l oq or">#what the board should print.<br/>def get_print_character(self):</span></pre><p id="10c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">细胞可能是最容易写的东西。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="12be" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">board.py</h2><p id="eb9c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个类更难写，有几个复杂的解决方案。</p><p id="88df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于主板，我们需要:</p><ul class=""><li id="a3de" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated">定义行和列来设置大小(构造函数将处理这一点)</li><li id="c070" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">一种画板的方法</li><li id="d161" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">检查所有单元的所有邻居的方法</li><li id="d265" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">一种基于邻居状态更新板的方法</li></ul><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="5352" class="ny la it nx b gy oo op l oq or">#initial generation based on randomness.<br/>def _generate_board(self):</span><span id="2fa2" class="ny la it nx b gy os op l oq or">#draw the board in the terminal<br/>def draw_board(self):</span><span id="8c66" class="ny la it nx b gy os op l oq or">#update for the next generation of cells<br/>def update_board(self):</span><span id="f35a" class="ny la it nx b gy os op l oq or">#find all the neighbours of a cell<br/>def find_neighbour(self,row,column):</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="2990" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">写网格</h1><p id="3111" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">构造函数负责创建我们需要的所有变量。它还根据用户需要的行数创建网格列表。请注意，构造函数还调用了generate方法来立即生成电路板。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="2001" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">生成_板(自己)</h2><p id="d765" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这种方法使每个细胞有33%的机会成为活细胞。<br/>幸运细胞将通过使用细胞方法<code class="fe nu nv nw nx b">.set_alive()</code>获得生存状态。</p><h2 id="cf9c" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">画板(自己)</h2><p id="849f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，它打印许多行，以确保我们打印一个干净的终端。根据您的设置，数量会有所不同。</p><p id="21d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后我们使用一个嵌套循环来检查我们必须为那个方块打印什么样的字符。我们通过使用单元方法<code class="fe nu nv nw nx b">.get_print_character()</code>来实现。</p><h2 id="3ed9" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">check _ neighbour(自身，check_row，check_column)</h2><p id="df09" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们真正解决这个问题之前，我们需要看看它是如何构建的，以及我们如何检查邻居。这些对游戏至关重要，我们<strong class="lt iu"> <em class="nt">必须</em> </strong>搞定他们！</p><p id="3c61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我将在<code class="fe nu nv nw nx b">table_check.py</code>中编写一个名为<code class="fe nu nv nw nx b">Tablecheck</code>的测试类和一个用于测试代码的<code class="fe nu nv nw nx b">main.py</code>。这样我们就可以一起研究这个理论了。实际的网格是用列表理解来制作的，因为它可以是用户想要的任何大小。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b5347bb723091109456e520bd6e8f65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*qFxV4ZE9i_VxVbmv95ViqQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用python构建这个网格</p></figure><p id="c478" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们分解网格，我们可以看到有行和列。如果我们把它转换成Python，你可以在列表中放置列表来模仿这种行为。a，B，C是第一个列表(自我。_grid[0])，D，E，F是第二个列表(self。_grid[1])和G，H，I是第三个列表(self。_grid[2])。</p><p id="680d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要访问这些列表中的字母，我们需要进入它们。语法应该是:</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="f830" class="ny la it nx b gy oo op l oq or">self._grid[X][Y]</span></pre><p id="a9c9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">a生活在自我中。_grid[0][0] <br/> E活在自我中。_grid[1][1] <br/> G活在自我中。_grid[2][0]</p><p id="3192" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">诸如此类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/7754a9bcfc66f56f304675e49a2f7047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*FQH0vm2pIsJOD9q8dlTyIA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蓝色代表行，橙色代表列</p></figure><p id="548e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以用Python编写这样的网格布局:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="e40b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nu nv nw nx b">self._grid</code>是一个列表，里面有三个列表，创建一个类似网格的模式。为了画这样的板，我把它添加到我的<code class="fe nu nv nw nx b">main.py</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="b065" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这会打印以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/61095f7cc0d7cd0af9ff061c774ef125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47axXnglMF0Y1yr90jMKxA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/6eae4629a922c6a59ac9c447925cd5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3HQOCiiy0OvIX_R4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ayahya09?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿里·叶海亚</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="ee33" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">check _ neighbours(自身，check_row，check_column)</h2><p id="3bde" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">好了，现在我认为这是整个代码中最棘手的部分:检查所有邻居。</p><p id="4013" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<code class="fe nu nv nw nx b">check_neighbours()</code>,我们必须传入我们想要检查的坐标，然后我们必须在我们的列表中遍历以检查所有周围的邻居。</p><p id="6824" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着我们必须跳回一行(-1)，检查我们自己的行(0)和下一行(1)。用Python的术语来说，这意味着遍历从-1到2的范围，range(-1，2)。我们必须对柱子做同样的事情。</p><p id="ac9b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我想忠实于我的作品，<a class="ae ky" href="https://medium.com/better-programming/document-your-python-code-without-writing-documentation-2d8bf3a42e1a" rel="noopener">记录您的Python代码而不写文档</a>，我必须将开始和结束范围设置为变量，并弄清楚它们会受到怎样的影响。</p><pre class="kj kk kl km gt ok nx ol om aw on bi"><span id="29d0" class="ny la it nx b gy oo op l oq or"># how deep I will search around the current square.<br/>search_min = -1<br/>search_max = 2</span></pre><p id="3f1c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在一个范围内骑自行车很容易，但你可能已经在想我们如何处理走出棋盘。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/3815ff4c95a7a5e758234304e01dec94.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*6J1lbH7jn4HmIW-VYi67aw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当我们检查“A”时，我们不想浪费时间检查棋盘之外的内容。其他角元素也是如此。</p></figure><p id="a8fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们在这里要做的是检查我们是否在任何角落或任何边缘工作。</p><p id="1e37" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于检查本身，我们需要根据程序输入到<code class="fe nu nv nw nx b">check_row</code>和<code class="fe nu nv nw nx b">check_column</code>(<code class="fe nu nv nw nx b">check_neighbour</code>的参数)的内容循环遍历列表。</p><p id="8d9e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将在设定的范围内循环，<code class="fe nu nv nw nx b">search_min —search_max</code>。因为范围从-1开始，通常我们加1，所以我们检查正确的行。我们想跳回1个单位，但我们还想在正确的索引上工作。Python中的列表从0开始</p><p id="b8ed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">循环中的条件是忽略棋盘外的方块和自身。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="75dd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是该函数中发生的情况:</p><ul class=""><li id="4bdb" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated"><code class="fe nu nv nw nx b">search depth</code>:我想向后跳一行，检查我自己的行，然后向前跳一行——就像我们已经讨论过的那样。</li><li id="36ad" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">我将创建一个空列表来放置所有的邻居。我们一次更新所有单元是很重要的，所以在检查完所有内容之前，我们不能更改任何单元的状态。这将是细胞的临时容器。</li><li id="37e9" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">我们进入行循环，并遍历行中的列。</li><li id="89d1" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><code class="fe nu nv nw nx b">neighbour_row</code>和<code class="fe nu nv nw nx b">neighbour_column</code>是确保我们在条件中检查正确的行和列的变量。</li><li id="b9f5" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><code class="fe nu nv nw nx b">valid_neighbour</code>默认为真。如果一个邻居在棋盘内而不是它自己，它是一个有效的邻居。这就是所有if语句的目的。</li><li id="9a3b" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">当我们完成检查时，我们返回有效邻居的列表。</li></ul><h2 id="d221" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">更新_板(自己)</h2><p id="f816" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">另一个硬功能是更新板功能。这将遍历所有的单元，检查邻居，并根据找到的活单元的数量，将当前检查的单元存储在死亡列表或生命列表中。</p><p id="a6b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，检查完所有单元格后，它们会改变状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><ul class=""><li id="4060" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated">首先，我们创建两个空列表来保存将要被杀死的细胞和将要存活或变得存活的细胞。</li><li id="7874" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">我们通过嵌套循环遍历网格</li><li id="c57d" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">我们在要检查的单元格上使用<code class="fe nu nv nw nx b">check_neighbour</code>函数</li><li id="9933" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">我们从支票中创建一个包含活细胞的列表。</li><li id="5c79" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">我们遍历函数返回的列表，看看有多少邻居还活着</li><li id="c4f6" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">根据游戏规则，当前单元格被放入要杀死的列表或要存活/变得存活的列表中。</li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/8efd4ed35b5afd94d4ede7208fd5e98c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ybqVy3QOkRSvqItg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@fwed?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗雷德·穆恩</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="3aec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">唷！最困难的部分已经过去——是时候把它们缝合在一起了。</strong></p><h2 id="64ac" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">main.py</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="e8d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们希望用户决定我们正在处理多少行和列。</p><ul class=""><li id="5a59" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated">进口委员会</li><li id="cbbc" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">请求行和列</li><li id="cbf0" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">创建一个以用户行和列作为参数的board对象。</li><li id="639b" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><code class="fe nu nv nw nx b">.draw_board()</code>在终端中绘制它</li><li id="27a2" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">创建一个菜单，用户可以按enter键创建另一个生成，或者按“q”键退出。</li></ul><p id="afdf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里是完整的Python文件。</p><h2 id="1e52" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">单元格. py</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="bf64" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">board.py</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="97c0" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">main.py</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/3efd3140b19da632de2bb2849f09ed28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/1*DLgMytzlcfH730SwLXCvmw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">行动中的计划</p></figure><p id="47ff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果有任何不清楚的地方，请让我知道——我总是努力提高自己。如果你读过我的其他Python文章，我使用了许多相同的技术。也许你会在其中找到一些答案。</p><p id="8096" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢阅读！</p></div></div>    
</body>
</html>