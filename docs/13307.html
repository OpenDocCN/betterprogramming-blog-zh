<html>
<head>
<title>Android Access Token Logic With Retrofit OkHttp Interceptors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android访问令牌逻辑和改进的OkHttp拦截器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-access-token-logic-with-retrofit-okhttp-interceptors-740ea48547a0?source=collection_archive---------2-----------------------#2022-08-16">https://betterprogramming.pub/android-access-token-logic-with-retrofit-okhttp-interceptors-740ea48547a0?source=collection_archive---------2-----------------------#2022-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="66ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用OkHttp拦截器的访问令牌头逻辑</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/239145d78c4af59727b8bb9346f85f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-FNY-1kndQOyAsU7OhHHg@2x.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">房间图片，来自<a class="ae kv" href="https://square.github.io/okhttp/features/interceptors/" rel="noopener ugc nofollow" target="_blank"> OkHttp拦截器文档</a></p></figure><p id="e816" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank">翻新</a>是一个强大的库，用于处理Android应用程序中的HTTP请求。</p><blockquote class="ls lt lu"><p id="dcd0" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">“Android和Java的类型安全HTTP客户端。”根据<a class="ae kv" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank">改装官方文档</a></p></blockquote><p id="bac0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有OkHttp库<a class="ae kv" href="https://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank">的话，这个改进就不会那么强大。<code class="fe lz ma mb mc b">OkHttp</code>是一个HTTP客户端，帮助你更快的加载资源，节省带宽。它还允许您拦截请求、监控它们并重写它们。</a></p><p id="cc9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我将向您展示我们如何使用<code class="fe lz ma mb mc b">OkHttp Interceptors</code>来减少样板代码。请求的某些部分是相同的，所以使用拦截器，您可以添加它们，而不必真正担心它们。本文的一个例子是添加和刷新<code class="fe lz ma mb mc b">Access Token</code>。</p><h1 id="bbc4" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">OAuth简介</h1><p id="88ab" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">OAuth是一种让用户在某些特定操作中验证自己身份的方法。大多数服务器使用这种类型的身份验证，最常见的实现是使用令牌。每个用户都会收到两种类型的令牌:</p><ul class=""><li id="f478" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">访问令牌(用于向服务器发送请求时进行身份验证)</li><li id="a326" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">刷新令牌(用于在访问令牌到期时刷新它)</li></ul><p id="661d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在每个请求中，您需要提供访问令牌来验证您自己，并被允许调用特定的API。访问令牌最多持续30分钟。要看执行。刷新令牌最长可持续200天，具体取决于实施情况。</p><p id="ac9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用拦截器，我们不需要为每个请求手动添加一个访问令牌；拦截器可以为我们做到这一点。此外，当访问令牌过期时，它可以刷新它，然后再次发送请求。在示例中，我们将看到如何做到这一点。</p><h1 id="e7a4" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">OkHttp拦截器</h1><p id="c8f8" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">拦截器有两种类型:</p><ul class=""><li id="c0ef" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">应用程序级拦截器(使用方法<code class="fe lz ma mb mc b">addInterceptor()</code>添加在应用程序代码和OkHttp核心库之间)</li><li id="e222" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">网络层拦截器(在OkHttpCore库和服务器之间添加，使用一种方法<code class="fe lz ma mb mc b">addNetworkInterceptor()</code>)</li></ul><p id="2b54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于访问令牌，包括和刷新，我们将使用应用程序级拦截器。首先，让我们添加一些依赖项:</p><pre class="kg kh ki kj gt no mc np nq aw nr bi"><span id="3f15" class="ns me iq mc b gy nt nu l nv nw">implementation "com.squareup.retrofit2:retrofit:2.9.0"<br/>implementation "com.squareup.okhttp3:okhttp:5.0.0-alpha.3"</span></pre><p id="fa4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>检查这些依赖项是否有更新的版本。</p><p id="f2b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们要通过实现<code class="fe lz ma mb mc b">Interceptor</code>接口来创建一个拦截器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="54c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>在这个例子中，我使用的是Dagger-Hilt，这超出了本文的范围。我选择这个是因为这是最常用的DI库。</p><p id="edd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们要像这样实现<code class="fe lz ma mb mc b">intercept</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5bb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过<code class="fe lz ma mb mc b">chain.request()</code>,我们获得当前请求，然后获得访问令牌。我们通过添加一个访问令牌作为头部来处理请求，并发送该请求。</p><p id="886e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果响应代码具有值<code class="fe lz ma mb mc b">HTTP_UNAUTHORIZED</code>或<code class="fe lz ma mb mc b">401</code>，这意味着访问令牌无效，因此我们尝试刷新访问令牌。但是首先，我们通过比较当前和共享首选项中保存的最后一个来检查其他线程是否获得了新的访问令牌。如果它们相同，我们刷新令牌并继续请求。</p><p id="418f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，当我们想要将它添加到OkHttpClient时，这是在添加到改型之后，我们这样做:</p><pre class="kg kh ki kj gt no mc np nq aw nr bi"><span id="cd23" class="ns me iq mc b gy nt nu l nv nw">OkHttpClient.Builder()<br/>    .addInterceptor(authInterceptor)<br/>    .build()</span></pre><p id="49f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是非常重要和相当简单的逻辑。希望你喜欢！<br/>你可以在<a class="ae kv" href="https://github.com/Giga99/MediumRepos" rel="noopener ugc nofollow" target="_blank">我的GitHub repo </a>中找到所有的源代码。</p><h1 id="aedf" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="7a34" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">有很多用例可以使用拦截器，不仅仅是为了刷新访问令牌。它们是一种方便的机制。例如，您可以使用它们进行错误处理，添加除访问令牌之外的其他头，gzip您的请求，等等。</p><pre class="kg kh ki kj gt no mc np nq aw nr bi"><span id="6933" class="ns me iq mc b gy nt nu l nv nw"><strong class="mc ir">Want to Connect?</strong></span><span id="901d" class="ns me iq mc b gy nz nu l nv nw">You can connect with me on:<br/><a class="ae kv" href="https://github.com/Giga99" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/><a class="ae kv" href="https://www.linkedin.com/in/igor-stevanovic/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae kv" href="https://twitter.com/igor_s1999" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae kv" href="https://giga99.github.io/portfolio-website/" rel="noopener ugc nofollow" target="_blank">Portfolio website</a></span></pre><p id="3b9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想了解更多关于Jetpack Compose的信息，请阅读以下文章:</p><div class="oa ob gp gr oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/implement-horizontal-and-vertical-viewpager-in-jetpack-compose-a7a91f2ac746"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">在Jetpack Compose中实现水平和垂直ViewPager</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">在Jetpack撰写中实现ViewPager</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">better编程. pub</p></div></div><div class="om l"><div class="on l oo op oq om or kp od"/></div></div></a></div><div class="oa ob gp gr oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/jetpack-compose-request-permissions-in-two-ways-fd81c4a702c"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">在Jetpack Compose中请求权限的两种方法</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">在Jetpack Compose中请求权限的最佳方式</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">better编程. pub</p></div></div><div class="om l"><div class="os l oo op oq om or kp od"/></div></div></a></div><h1 id="a03f" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">资源</strong></h1><div class="oa ob gp gr oc od"><a href="https://square.github.io/retrofit/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">加装</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">接口方法及其参数上的注释表明了如何处理请求。请求方法每隔…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">square.github.io</p></div></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://square.github.io/okhttp/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">概述- OkHttp</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">HTTP是现代应用程序联网的方式。这是我们交换数据和媒体的方式。高效做HTTP让你的东西…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">square.github.io</p></div></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://square.github.io/okhttp/features/interceptors/#choosing-between-application-and-network-interceptors" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">拦截器- OkHttp</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">拦截器是一种强大的机制，可以监控、重写和重试调用。这里有一个简单的拦截器，它记录…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">square.github.io</p></div></div><div class="om l"><div class="ot l oo op oq om or kp od"/></div></div></a></div></div></div>    
</body>
</html>