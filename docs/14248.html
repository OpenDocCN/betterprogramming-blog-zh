<html>
<head>
<title>How to Auto-Generate an API Gateway for Azure Kubernetes Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Azure Kubernetes服务自动生成API网关</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-auto-generate-an-api-gateway-for-azure-kubernetes-services-f20149253ed3?source=collection_archive---------14-----------------------#2022-11-21">https://betterprogramming.pub/how-to-auto-generate-an-api-gateway-for-azure-kubernetes-services-f20149253ed3?source=collection_archive---------14-----------------------#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f694" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们探索一种简洁的方式，用Azure管道和API管理来自动化部署过程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2d2b67a40a1cf7cfc03784d75eb158c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*heeSOF1oiPRwPDBhdJwXqA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae kv" href="https://azure.microsoft.com/en-us/services/api-management/#overview" rel="noopener ugc nofollow" target="_blank"> Azure API管理</a>徽标(由作者组合)。</p></figure><p id="829e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们正在使用Azure Kubernetes Service (AKS)向Kubernetes集群部署一组微服务。让我们进一步假设每个微服务都有自己的API，它有一个OpenAPI规范。</p><p id="3284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是我们不知道我们将部署多少这样的微服务。我们希望将每个API连接到同一个API网关。</p><p id="83a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些Kubernetes部署可能会变得非常复杂，但是基本思想非常简单。我们希望我们的微服务可以通过一个公共接口被下游消费者发现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/ea19a6253c046f1747026f1302ca3775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7L10CTxxKfGAq4zNzPf2Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基本思想。</p></figure><p id="fc59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，我们希望尽可能多地自动化部署流程，以避免繁琐且容易出错的手动部署。</p><p id="5dc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是Azure DevOps和API管理的用武之地。在本文中，我们将展示指定Azure管道的YAML文件的代码片段，而您的工作将是填充空白以满足您的特定需求。</p><h2 id="0983" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">先决条件</h2><ul class=""><li id="7e96" class="mm mn iq ky b kz mo lc mp lf mq lj mr ln ms lr mt mu mv mw bi translated">具有Dockerfile和OpenAPI规范的可部署服务</li><li id="dbad" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">Azure容器注册实例</li><li id="ae40" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">具有正在运行的集群的AKS实例</li><li id="b92b" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">Docker注册服务连接</li><li id="e796" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">Kubernetes服务连接</li><li id="ba31" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">API管理服务</li><li id="dae8" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">Azure DevOps组织</li></ul><p id="83a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以从Azure门户或通过Azure资源管理器(ARM)模板部署这些资源。我不会在这里讨论如何做到这一点。</p><h2 id="7430" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">设置管道</h2><p id="8c1b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">说够了。让我们展示一些代码。</p><p id="9b17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Azure DevOps管道依赖于上述所有先决条件，我们需要设置一些变量来确保不同的Azure服务可以安全地通信。</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="ae7c" class="nk lu iq ng b be nl nm l nn no">variables:  <br/>  environment: 'dev'<br/>  imagePullSecret: '{name your pull secret here}'<br/>  kubernetesManifestDirectory: '{directory with K8s manifest file}'<br/>  tag: '$(Build.SourceVersion)'<br/>  imageRepository: '{name of your docker image}'<br/>  serviceName: $(imageRepository)<br/>  dnsLabel: $(imageRepository)<br/>  dockerfilePath: '{path to dockerfile}'<br/>  resourceGroup: '{name of resource group to deploy to}'<br/>  location: '{azure region to deploy to}'<br/>  containerRegistryName: '{name of Azure container registry}'<br/>  dockerRegistryServiceConnection: '{name of connection}'<br/>  kubernetesServiceConnection: '{name of connection}'<br/>  apimWorkspace: '{name of APIM workspace}'</span></pre><p id="bed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们将部署到一个名为“dev”的环境中，但是使用环境并不是绝对必要的。</p><p id="b5dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe np nq nr ng b">tag</code>变量是git提交散列，将用于标记我们的容器图像。您可以使用任何您想要的标签，但是强烈建议为每个构建使用一个唯一的标签，以清楚地表明运行的是哪个版本的映像。</p><h2 id="72a5" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">建立码头工人形象</h2><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="d91d" class="nk lu iq ng b be nl nm l nn no">- stage: Build<br/>  displayName: Build<br/>  jobs:<br/>  - job: Build<br/>    displayName: Build and push image<br/>    pool:<br/>      vmImage: 'ubuntu-latest'<br/>    steps:   <br/><br/>    - task: Docker@2<br/>      inputs:<br/>        command: 'buildAndPush'<br/>        repository: $(imageRepository)<br/>        Dockerfile: $(dockerfilePath)<br/>        containerRegistry: $(containerRegistryName)<br/>        tags: $(tag)</span></pre><p id="69f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在管道的构建阶段，我们构建Docker映像并将其推送到Azure容器注册中心。</p><blockquote class="ns nt nu"><p id="a64f" class="kw kx nv ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:<code class="fe np nq nr ng b">buildAndPush</code>命令是一个方便的任务，在一个步骤中结合了“构建”和“推送”。然而，如果你想用参数构建你的图像，你必须分开使用这两个任务，因为<code class="fe np nq nr ng b">buildAndPush</code>不支持它。</p></blockquote><p id="75bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦容器映像在注册表中可用，我们就可以部署它了。</p><h2 id="cc9e" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">配置Kubernetes清单</h2><p id="23f1" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">Kubernetes清单文件相对简单。它有一个部署和一个服务。我们重用Docker注册中心的名称作为服务和应用程序标签的名称，并通过标准的<code class="fe np nq nr ng b">port 80</code>使用负载均衡器公开服务。</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="b8e3" class="nk lu iq ng b be nl nm l nn no">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: #{serviceName}#<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: #{serviceName}#<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: #{serviceName}#<br/>    spec:<br/>      nodeSelector:<br/>        "kubernetes.io/os": linux<br/>      containers:<br/>      - name: speech2text<br/>        image: #{containerRegistryName}#.azurecr.io/#{imageRepository}#:#{tag}#<br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: 80<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: #{serviceName}#<br/>  annotations:<br/>    service.beta.kubernetes.io/azure-dns-label-name: #{dnsLabel}#<br/>spec:<br/>  ports:<br/>  - port: 80<br/>    targetPort: 80<br/>  type: LoadBalancer<br/>  selector:<br/>    app: #{serviceName}#</span></pre><p id="c42f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的一点是，我们在第29行指定了一个DNS标签。这为服务提供了一个公共IP地址和一个DNS地址，<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/aks/static-ip" rel="noopener ugc nofollow" target="_blank">，如这里所描述的</a>。稍后请记住这一点，因为这在我们部署API时非常重要。</p><p id="94a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还会注意到清单中的许多属性是应该由变量替换的标记。为此，我们将使用一个名为<code class="fe np nq nr ng b">Replace Tokens</code>的自定义任务，它在Azure Marketplace 中可用<a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=qetza.replacetokens" rel="noopener ugc nofollow" target="_blank">。你当然可以使用一个更高级的工具，比如</a><a class="ae kv" href="https://v2.helm.sh/docs/chart_template_guide/#the-chart-template-developer-s-guide" rel="noopener ugc nofollow" target="_blank">舵图模板</a>，来实现同样的事情，但是我们现在保持简单。</p><p id="003b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该任务中的默认令牌模式是<code class="fe np nq nr ng b">#{…}#</code>。以下代码片段将用相应的管道变量替换清单文件中的所有标记:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="51aa" class="nk lu iq ng b be nl nm l nn no">- task: replacetokens@5<br/>  displayName: Replace tokens in manifest<br/>  inputs:<br/>    targetFiles: '$(kubernetesManifestDirectory)/*.yml'<br/>    encoding: 'auto'<br/>    tokenPattern: 'default'<br/>    writeBOM: true<br/>    actionOnMissing: 'warn'<br/>    keepToken: false<br/>    actionOnNoFiles: 'continue'<br/>    enableTransforms: false<br/>    enableRecursion: false<br/>    useLegacyPattern: false<br/>    enableTelemetry: true<br/><br/>- publish: $(kubernetesManifestDirectory)<br/>  displayName: Publish manifest artifact<br/>  artifact: $(kubernetesManifestDirectory)</span></pre><h1 id="ecbd" class="nz lu iq bd lv oa ob oc ly od oe of mb jw og jx me jz oh ka mh kc oi kd mk oj bi translated">部署Kubernetes服务</h1><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="3544" class="nk lu iq ng b be nl nm l nn no">jobs:<br/>  - deployment: DeployKubernetes<br/>    displayName: Deploy to Kubernetes<br/>    pool:<br/>      vmImage: 'ubuntu-latest'<br/>    environment: $(environment)<br/>    strategy:<br/>      runOnce:<br/>        deploy:<br/>          steps:<br/>          - task: KubernetesManifest@0<br/>            displayName: Create image pull secret<br/>            inputs:<br/>              action: createSecret<br/>              kubernetesServiceConnection: $(kubernetesServiceConnection)<br/>              secretName: '$(imagePullSecret)'<br/>              dockerRegistryEndpoint: $(dockerRegistryServiceConnection)<br/><br/>          - task: KubernetesManifest@0<br/>            displayName: Deploy to Kubernetes<br/>            inputs:<br/>              action: 'deploy'<br/>              kubernetesServiceConnection: $(kubernetesServiceConnection)<br/>              manifests: '$(Agent.BuildDirectory)/$(kubernetesManifestDirectory)/$(kubernetesManifestFile)'<br/>              containers: '$(containerRegistry)/$(imageRepository):$(tag)'<br/>              imagePullSecrets: '$(imagePullSecret)'</span></pre><p id="3e91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AKS需要一个pull secret来向容器注册表进行身份验证。使用服务连接，我们可以通过<code class="fe np nq nr ng b">KubernetesManifest</code>任务的<code class="fe np nq nr ng b">createSecret</code>动作动态地创建它。</p><p id="01ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了pull secret和我们的Kubernetes清单，我们可以使用同一个任务的<code class="fe np nq nr ng b">deploy</code>动作将新创建的映像部署到AKS集群。这在引擎盖下运行<code class="fe np nq nr ng b">kubectl apply</code>命令。</p><blockquote class="ns nt nu"><p id="e1ee" class="kw kx nv ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated"><strong class="ky ir">注</strong>:在写的时候，‘Ubuntu-latest’指向的是’<em class="iq">Ubuntu-20.04</em>的镜像。</p></blockquote><p id="c7e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe np nq nr ng b">KubernetesManifest</code>任务的好处是它检查部署对象的卷展状态，直到卷展完成才返回。通过让管道中的下一个作业依赖于Kubernetes部署，我们知道服务已经可供消费。</p><h1 id="5d32" class="nz lu iq bd lv oa ob oc ly od oe of mb jw og jx me jz oh ka mh kc oi kd mk oj bi translated">将API导入API管理</h1><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="a26e" class="nk lu iq ng b be nl nm l nn no">- job: CreateAPI<br/>  displayName: Create API<br/>  dependsOn: DeployKubernetes<br/>  pool:<br/>    vmImage: 'windows-2019'<br/>  steps:<br/><br/>  - task: AzureCLI@2<br/>    displayName: Create API<br/>    inputs:<br/>      azureSubscription: '$(azureSubscription)'<br/>      scriptType: 'batch'<br/>      scriptLocation: 'inlineScript'<br/>      inlineScript: 'az apim api import -g $(resourceGroup) --service-name $(apimWorkspace) --api-id $(serviceName) --path $(serviceName) --specification-format OpenApiJson --specification-url http://$(dnsLabel).$(location).cloudapp.azure.com/openapi.json --service-url http://$(dnsLabel).$(location).cloudapp.azure.com/ --display-name $(serviceName)'      <br/><br/>  - task: AzureCLI@2<br/>    displayName: Add API to Starter product<br/>    inputs:<br/>      azureSubscription: '$(azureSubscription)'<br/>      scriptType: 'batch'<br/>      scriptLocation: 'inlineScript'<br/>      inlineScript: 'az apim product api add --api-id $(serviceName) --product-id Starter --resource-group $(resourceGroup) --service-name $(apimWorkspace)'</span></pre><p id="9f90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们来了解一下这条管道的本质。还记得我们之前设置的DNS标签吗？我们现在可以使用该地址来查找OpenAPI规范文件，并使用一行代码将API导入API管理服务。</p><p id="8c45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们运行以下命令:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="b2a7" class="nk lu iq ng b be nl nm l nn no">az apim api import -g $(resourceGroup) --service-name $(apimWorkspace) --api-id $(serviceName) --path $(serviceName) --specification-format OpenApiJson --specification-url http://$(dnsLabel).$(location).cloudapp.azure.com/openapi.json --service-url http://$(dnsLabel).$(location).cloudapp.azure.com/ --display-name $(serviceName)</span></pre><p id="c407" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那是一长行代码，所以让我们把它拆开。通过将<code class="fe np nq nr ng b">OpenApiJson</code>设置为规范格式并将<code class="fe np nq nr ng b">specification-url </code>指向<code class="fe np nq nr ng b">openapi.json</code>文件的位置，API将自动生成。<code class="fe np nq nr ng b">service-url</code>参数是API的基本URL。我们还为API重用了Docker注册名，就像我们对Kubernetes服务所做的那样。</p><p id="265a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个任务不是绝对必要的，但是它将新创建的API添加到默认的<code class="fe np nq nr ng b">Starter</code>产品中，这允许API管理中该产品的订户开始使用该API。</p><blockquote class="ns nt nu"><p id="0201" class="kw kx nv ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:‘windows-2019’映像用于运行此作业，但它也应该与其他构建代理一起工作。</p></blockquote><p id="7711" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经正确地设置了所有的东西，那么您现在应该有一个正在运行的API，准备好供您的API管理订阅者使用！</p><p id="084d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于管道的最后一部分，要提到的一点是，如果已经存在同名的API，导入脚本将会失败。为了避免这种情况，您可以先用下面的命令删除API，然后再重新创建它(这会导致几秒钟的停机时间):</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="1440" class="nk lu iq ng b be nl nm l nn no">az apim api delete --api-id $(serviceName) --resource-group $(resourceGroup) --service-name $(apimWorkspace) -y</span></pre><h1 id="9a4e" class="nz lu iq bd lv oa ob oc ly od oe of mb jw og jx me jz oh ka mh kc oi kd mk oj bi translated">总结</h1><p id="d2af" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们用包含OpenAPI规范的微服务构建了一个Docker映像，并将其推送到Azure Container Registry。我们将图像拉至Azure Kubernetes服务，并使用静态DNS标签对其进行部署。使用DNS标签，我们可以获取OpenAPI规范并自动生成API，作为我们API管理产品的一部分。</p><p id="1b64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种设置的好处之一是可以重用它来部署不同的服务。如果您愿意，您甚至可以从多个代码库中同时触发同一个管道。</p><h2 id="a21e" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">放弃</h2><p id="3b35" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">本文不涉及部署的安全方面。为了保护您的服务，您应该将Kubernetes集群，最好是API管理实例，部署到虚拟网络(VNet)中。这超出了本文的范围，但是微软有一个很好的概念教程<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/api-management/api-management-kubernetes" rel="noopener ugc nofollow" target="_blank">来教你怎么做。</a></p></div></div>    
</body>
</html>