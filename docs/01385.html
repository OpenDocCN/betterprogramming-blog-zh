<html>
<head>
<title>Creating an Animoji-Style 3D Character to Use With TrueDepth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Animoji风格的3D角色以用于TrueDepth</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exporting-a-3d-character-from-blender-2-8-to-xcode-and-implement-like-animoji-using-arkit-scenekit-3d223aa6a29f?source=collection_archive---------2-----------------------#2019-09-05">https://betterprogramming.pub/exporting-a-3d-character-from-blender-2-8-to-xcode-and-implement-like-animoji-using-arkit-scenekit-3d223aa6a29f?source=collection_archive---------2-----------------------#2019-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1ca0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何从Blender 2.8导出到ARKit/SceneKit的Xcode</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/20898224ab4f870e99571c107c4b9971.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*s05xMsA3Y-xmlqtKnIYRSw.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">TrueDepth笑脸</p></figure><p id="6f45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最近，<a class="ae ln" href="https://apps.apple.com/app/id1521828825" rel="noopener ugc nofollow" target="_blank">我在做的一个项目(Smappy) </a>需要使用一个3D表情符号风格的角色，在iPhone X或更高版本中使用<a class="ae ln" href="https://developer.apple.com/documentation/avfoundation/avcapturedevice/devicetype/2933376-builtintruedepthcamera" rel="noopener ugc nofollow" target="_blank">原深感摄像头</a>来控制——很像苹果自己的<a class="ae ln" href="https://support.apple.com/en-us/HT208190" rel="noopener ugc nofollow" target="_blank"> Animoji </a>。我在尝试将3D角色从<a class="ae ln" href="https://www.blender.org/" rel="noopener ugc nofollow" target="_blank"> Blender </a>导出到<a class="ae ln" href="https://developer.apple.com/documentation/scenekit" rel="noopener ugc nofollow" target="_blank"> SceneKit </a>时发现了一些问题，因此本教程将概述我遇到的问题和我设法找到的解决方案，以及演示如何在您自己的项目中实现该角色。</p><p id="1999" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本教程将假设你已经用你需要的所有混合形状<a class="ae ln" href="https://developer.apple.com/documentation/arkit/arfaceanchor/blendshapelocation" rel="noopener ugc nofollow" target="_blank">创建了你的角色。这将涉及很多细节，因此一些对Blender或iOS开发经验很少的人也可以跟上。然而，我不会去如何创建自己的角色或混合形状的动画。</a></p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="cd77" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">导出您的角色用于ARKit</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/54b34a524ac716ea65a2463ef0d0c714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRPUX_L6Dl-yOIxUZU9KiQ.png"/></div></div></figure><p id="41c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开始之前:请记住，在开始之前做一个备份总是一个好主意，因为你不想丢失或弄乱任何工作！</p><p id="72d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">命名形状关键点时，我发现给它们起一个与相应的混合形状关键点相同的名字是个好主意。出于某种原因，苹果公司决定将一些键的名称与它们的对象名称稍有不同；下面是他们在ARFaceAnchor中的键名列表。</p><p id="7d22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，你要确保所有的修改器都被应用，否则，在将导出的<code class="fe ms mt mu mv b">.dae</code>文件导入到<a class="ae ln" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank"> Xcode </a>时，你肯定会遇到一些问题(就像我一样)。我的角色使用了两种不同的修饰语，<code class="fe ms mt mu mv b">Mirror</code>和<code class="fe ms mt mu mv b">subdivision</code>。不应用<code class="fe ms mt mu mv b">Mirror</code>修改器(用于眼睛)导致在导出的对象上只有一只眼睛可见。这很容易解决。简单地确保你在Blender上处于对象模式，点击<code class="fe ms mt mu mv b">Mirror</code>修改器并选择“应用”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mw"><img src="../Images/eca0e755adb374d16244a655d2bb5011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AwezQIDcSo2rn0U7T6ixBw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">应用镜像修改器</p></figure><p id="912b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://docs.blender.org/manual/en/latest/modeling/modifiers/generate/subdivision_surface.html" rel="noopener ugc nofollow" target="_blank"/><code class="fe ms mt mu mv b"><a class="ae ln" href="https://docs.blender.org/manual/en/latest/modeling/modifiers/generate/subdivision_surface.html" rel="noopener ugc nofollow" target="_blank">subdivision</a></code><a class="ae ln" href="https://docs.blender.org/manual/en/latest/modeling/modifiers/generate/subdivision_surface.html" rel="noopener ugc nofollow" target="_blank">修饰符</a>稍微复杂一些，需要Python脚本才能工作。应用这个修饰符很重要。否则，导出角色时将不会保留形状关键点，这意味着任何动画都将不起作用。经过大量的谷歌搜索，我发现了<a class="ae ln" href="https://forums.unrealengine.com/development-discussion/animation/1623830-blender-2-8-beta-morph-targets-and-modifiers" rel="noopener ugc nofollow" target="_blank">这个非常有用的线程</a>，它包含了我们所需要的脚本(非常感谢<a class="ae ln" href="https://forums.unrealengine.com/member/3323703-morphcider" rel="noopener ugc nofollow" target="_blank"> MorphCider </a>)。</p><p id="76e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，打开一个文本编辑器，在适当的位置保存下面的脚本，并将其命名为<code class="fe ms mt mu mv b">apply_with_shape_keys.py</code>:</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="f4b0" class="nb lw iq mv b gy nc nd l ne nf">import bpy<br/><br/>class ApplyWithShapeKeys(bpy.types.Operator):<br/>    """Tooltip"""<br/>    bl_idname = "object.applywithshapekeys"<br/>    bl_label = "Apply Modifiers With Shapekeys"<br/><br/>    def execute(self, context):<br/><br/>        selection = bpy.context.selected_objects<br/><br/>        for obj in selection:<br/>            if obj.type == "MESH":<br/><br/>                # lists store temporary objects created from shapekeys<br/>                shapeInstances = []<br/>                shapeValues = []<br/><br/>                # Deactivate any armature modifiers<br/>                for mod in obj.modifiers:<br/>                    if mod.type == 'ARMATURE':<br/>                        obj.modifiers[mod.name].show_viewport = False<br/><br/>                for shape_key in obj.data.shape_keys.key_blocks:<br/>                    # save old shapekey value to restore later. Will set to 0 temporarily<br/>                    shapeValues.append(shape_key.value)<br/>                    shape_key.value = 0.0<br/><br/>                i = 0<br/>                for shape_key in obj.data.shape_keys.key_blocks:<br/><br/>                    # ignore basis shapekey<br/>                    if i != 0:<br/>                        # make sure only relevant object is selected and active<br/>                        bpy.ops.Object.select_all(action="DESELECT")<br/>                        obj.select_set(state=True)<br/>                        context.view_layer.objects.active = obj<br/><br/>                        # make sure only this shape key is set to 1<br/>                        shape_key.value = 1.0<br/><br/>                        # duplicate object with only one shape key active. Blender does the rest<br/>                        bpy.ops.Object.duplicate(linked=False, mode="TRANSLATION")<br/>                        bpy.ops.Object.convert(target="MESH")<br/>                        shapeInstances.append(bpy.context.active_object)<br/><br/>                        bpy.context.object.name = shape_key.name<br/><br/>                        bpy.ops.Object.select_all(action="DESELECT")<br/>                        obj.select_set(state=True)<br/>                        context.view_layer.objects.active = obj<br/><br/>                        shape_key.value = 0.0<br/><br/>                    i = i + 1<br/><br/>                context.view_layer.objects.active = obj<br/><br/>                # create final object<br/>                bpy.ops.Object.duplicate(linked=False, mode="TRANSLATION")<br/>                newobj = bpy.context.active_object<br/>                newobj.name = obj.name + "_APPLIED"<br/><br/>                # clear all old shapekeys from new object<br/>                newobj.shape_key_clear()<br/><br/>                # apply all modifiers on new object<br/>                for mod in newobj.modifiers:<br/>                    if mod.name != "Armature":<br/>                        bpy.ops.object.modifier_apply(apply_as='DATA', modifier=mod.name)<br/><br/>                # iterate all temporary saved shapekey objects, select only that and the final object and join them<br/>                for shapeInstance in shapeInstances:<br/>                    bpy.ops.object.select_all(action="DESELECT")<br/>                    newobj.select_set(state=True)<br/>                    shapeInstance.select_set(state=True)<br/>                    context.view_layer.objects.active = newobj<br/><br/>                    result = bpy.ops.object.join_shapes()<br/><br/>                # reset old shape key values<br/>                i = 0<br/>                for shape_key in newobj.data.shape_keys.key_blocks:<br/>                    if i != 0:<br/>                        shape_key.value = shapeValues[i]<br/>                    i = i + 1<br/><br/>               # reset old shape key values<br/>                i = 0<br/>                for shape_key in obj.data.shape_keys.key_blocks:<br/>                    if i != 0:<br/>                        shape_key.value = shapeValues[i]<br/>                    i = i + 1<br/><br/>                # delete temporary objects    <br/>                bpy.ops.Object.select_all(action="DESELECT")<br/>                for shapeInstance in shapeInstances:<br/>                    shapeInstance.select_set(state=True)<br/><br/>                bpy.ops.object.delete(use_global=False)<br/><br/>                # redeactivate armature modifiers<br/>                for mod in obj.modifiers:<br/>                    if mod.type == 'ARMATURE':<br/>                        obj.modifiers[mod.name].show_viewport = True<br/><br/>                for mod in newobj.modifiers:<br/>                    if mod.type == 'ARMATURE':<br/>                        newobj.modifiers[mod.name].show_viewport = True<br/><br/>        return {"FINISHED"}<br/><br/>def register():<br/>    bpy.utils.register_class(ApplyWithShapeKeys)<br/><br/>def unregister():<br/>    bpy.utils.unregister_class(ApplyWithShapeKeys)<br/><br/>if __name__ == "__main__":<br/>    register()</span></pre><p id="7323" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开脚本工作区，点击“文本”&gt;“打开”，打开刚刚保存的脚本。现在点击“运行脚本”(位于右上角)，这会将脚本添加到项目中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ng"><img src="../Images/c48d43cc6b9123a175d22a18f6082741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wz4V8Nbm8nmr0vKZbN2BSg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">脚本工作区</p></figure><p id="384a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你现在需要返回到“布局”工作区(确保你仍然处于对象模式)，用<code class="fe ms mt mu mv b">subdivision</code>修改器选择你的对象。现在按“fn”+“F3”将会弹出一个搜索框。通过键入“使用Shapekeys应用修改器”来搜索您刚刚创建的函数，并单击相应的结果。Blender将在加载时等待几秒钟，然后创建一个名为<code class="fe ms mt mu mv b">(your object name)_APPLIED</code>的新对象。这个新对象现在应该已经应用了你的<code class="fe ms mt mu mv b">subdivision</code>修改器，所以你可以隐藏或者移除你的旧对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nh"><img src="../Images/96c1c57ae65fb5039730f676858816b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVI8rQcrXBWRcgvuNUa0-Q.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">运行应用修改器脚本</p></figure><p id="2831" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在准备将3D角色从Blender导出到一个<code class="fe ms mt mu mv b">.dae</code>文件中。首先，我们希望选择并突出显示所有希望导出的对象。在我的例子中，这是<code class="fe ms mt mu mv b">Smiley_APPLIED</code>和<code class="fe ms mt mu mv b">eyes</code>物体。现在点击【文件】&gt;【导出】&gt;【coll ada(默认)(。dae)”。在左侧，我们有一些设置，我选择了:</p><ul class=""><li id="2d3d" class="ni nj iq kt b ku kv kx ky la nk le nl li nm lm nn no np nq bi translated">"仅选择"</li><li id="753b" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">“包括儿童”</li><li id="88fd" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">"包括形状关键点"</li></ul><p id="e772" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其他设置没什么大不了的，但可能会根据你的角色而有所不同。现在，确保它被导出到一个适当的位置，并点击“导出”&gt;“COLLADA”</p><p id="d485" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，Blender不能导出带有正确的键和值的文件，而这些键和值是无缝导入Xcode所需要的。然而，幸运的是，<a class="ae ln" href="https://github.com/JonAllee" rel="noopener ugc nofollow" target="_blank"> JonAllee </a>创造了一个<a class="ae ln" href="https://github.com/JonAllee/ColladaMorphAdjuster" rel="noopener ugc nofollow" target="_blank">神奇的工具，可以自动为你映射正确的按键</a>。如果你用的是<a class="ae ln" href="https://github.com/apple/swift/releases/tag/swift-5.0.3-RELEASE" rel="noopener ugc nofollow" target="_blank"> Swift 5 </a>，我已经<a class="ae ln" href="https://github.com/JakeHoldom/ColladaMorphAdjuster" rel="noopener ugc nofollow" target="_blank">分叉这个回购，转换成Swift 5 </a>工作。</p><p id="482d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从GitHub下载这个工具，并在Xcode中打开它。选择“方案”&gt;“编辑方案”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nw"><img src="../Images/54f0ad74a1bb9a3b4313e37a53f2c141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7cFtZ74FGeU4WKStKn_8Ew.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">编辑方案</p></figure><p id="ffbf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在转到“运行”&gt;“参数”&gt;“启动时传递的参数”我们要传递三个参数:</p><ul class=""><li id="116b" class="ni nj iq kt b ku kv kx ky la nk le nl li nm lm nn no np nq bi translated">输入文件的路径</li><li id="eec2" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">"-o "</li><li id="f08d" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">输出文件的路径</li></ul><p id="2491" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你需要确保这些是正确的顺序。下面是我的一个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nx"><img src="../Images/254fa48f8421094da51f408e1e1bc636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Z-CI4cYcJDBW53kbv0mxA.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">ColladaMorphAdjuster的参数</p></figure><p id="7554" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关闭对话框，然后运行代码。</p><p id="e106" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一切顺利，您应该有一个输出日志，显示所有几何体(混合形状)的数量，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ny"><img src="../Images/f36d8b7c8b874c9f8ce52f51ca1fb496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hS3j54OTs8TUSYsI50CwFg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">ColladaMorphAdjuster成功输出</p></figure><p id="a995" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果脚本没有拾取几何体，您可能希望检查所有对象都已正确导出，并且所有修改器都已应用。您可以通过预览来检查<code class="fe ms mt mu mv b">.dae</code>文件，以确保没有明显的对象丢失。</p><p id="0d30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果剧本把他们接走了，太好了！您的3D角色即将完成。我们现在继续将字符导入Xcode。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="5fde" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">将您的角色导入Xcode</h1><p id="3579" class="pw-post-body-paragraph kr ks iq kt b ku nz jr kw kx oa ju kz la ob lc ld le oc lg lh li od lk ll lm ij bi translated">在Xcode中使用单视图应用程序创建新项目。我已经叫我的<code class="fe ms mt mu mv b">EmojiFace</code>。</p><p id="345c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">右键单击项目目录并选择“新建文件”这里您想向下滚动到参考资料部分，并创建一个名为<code class="fe ms mt mu mv b">Models.scnassets</code>的新的SceneKit目录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oe"><img src="../Images/1eb6da120a5587afafc5fbba55fba6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Az1KB7WugdCPdcRV4iMaLA.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">场景目录</p></figure><p id="d656" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，将上面的<code class="fe ms mt mu mv b">ColladaMorphAdjuster</code>生成的输出<code class="fe ms mt mu mv b">.dae</code>文件拖放到<code class="fe ms mt mu mv b">Models.scnassets</code>文件夹中。点击<code class="fe ms mt mu mv b">.dae</code>文件，你会看到你的3D角色。如果相机角度有点奇怪，点击左下方的相机图标，选择“正面”单击带有混合形状的对象，您应该会在右侧看到它们的列表，您可以拖动这些值来更改角色的面部:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi of"><img src="../Images/204c9e9ab1392369d7c127e40d5738fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4B10Ekb_1XBZ5nNECnLHUQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">XCode中的Smiley <code class="fe ms mt mu mv b">.dae</code>文件</p></figure><p id="ba5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能会注意到法线看起来有点奇怪，这使它在改变几何体变形值时看起来像一个低多边形，但是不要担心。稍后，当我们将对象导入到代码中时，我将向您展示如何以编程方式解决这个问题。</p><p id="b6e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您现在想要将<code class="fe ms mt mu mv b">.dae</code>导出为一个<code class="fe ms mt mu mv b">.scn</code>文件。这是通过点击“编辑器”&gt;“转换为SceneKit场景文件格式(。scn)。”然后会弹出一个窗口，说明<code class="fe ms mt mu mv b">.scn</code>文件与某些应用程序不兼容。我通常选择“复制”,因为这将保留<code class="fe ms mt mu mv b">.dae</code>文件，以防您希望在项目中出于其他原因使用它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi og"><img src="../Images/a9ebdc35f0543d2145300173db7cf079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*soq3raIPh2bipj0EJo0MFA.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">转换为。scn文件</p></figure><p id="fecc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，点击您的<code class="fe ms mt mu mv b">.scn</code>文件。</p><p id="3de8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我通常将我的角色组织到一个特定的节点结构中，以防我想要添加额外的节点，例如<a class="ae ln" href="https://developer.apple.com/documentation/scenekit/scncamera" rel="noopener ugc nofollow" target="_blank">相机节点</a>。您可以通过点击<code class="fe ms mt mu mv b">.scn</code>文件上场景图形底部的“+”来添加一个新的子节点。然后，我将子节点命名为<code class="fe ms mt mu mv b">model</code>，并在其中添加一个子节点，命名为<code class="fe ms mt mu mv b">puppet</code>，并将我的角色对象放入其中，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/19337603dc3ebfdc25f59c27e52197d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*ppO1p3tYRVg_rlzEoQzNNQ.png"/></div></figure><p id="acf2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能会发现某些颜色与您从Blender导出的字符不同。您可以在“材质检查器”中根据需要更改显示的颜色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oi"><img src="../Images/911e9946c5aedcde117ccf101fc4cc94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WineYX7BG9wMl0bDOd9T2g.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">材料检验员</p></figure><p id="206c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">恭喜你！你的3D角色应该可以开始了，我们终于可以开始写一些代码了！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="92db" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">将您的角色导入ARKit/SceneKit</h1><p id="2874" class="pw-post-body-paragraph kr ks iq kt b ku nz jr kw kx oa ju kz la ob lc ld le oc lg lh li od lk ll lm ij bi translated">打开<code class="fe ms mt mu mv b">Main.Storyboard</code>，从对象库中拖动一个<code class="fe ms mt mu mv b">SCNView</code>和一个<code class="fe ms mt mu mv b">ARSCNView</code>到视图控制器中。<code class="fe ms mt mu mv b">SCNView</code>是包含你的3D角色的视图，<code class="fe ms mt mu mv b">ARSCNView</code>是跟踪你的脸的视图。<code class="fe ms mt mu mv b">ARSCNView</code>实际上不会在屏幕上显示任何可见的东西，除非你想将其配置为显示相机的反馈。根据需要设置约束。以下是我的视图控制器的外观:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oj"><img src="../Images/43c479f7941d82acd605223b4bc990dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArT9wIupG6It9T8EEqi_uw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">视图控制器设置</p></figure><p id="e220" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将您的视图添加到<code class="fe ms mt mu mv b">ViewController.swift</code>文件中，并调用<code class="fe ms mt mu mv b">SCNView</code> <code class="fe ms mt mu mv b">faceView</code>和<code class="fe ms mt mu mv b">ARSCNView</code> <code class="fe ms mt mu mv b">trackingView</code>。我们还想创建这个类需要的以下实例变量:</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="f751" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">var</strong> contentNode: SCNReferenceNode? <em class="ok">// Reference to the .scn file</em></span><span id="5059" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">var</strong> cameraPosition = SCNVector3Make(0, 15, 50) <em class="ok">// Camera node to set position that the SceneKit is looking at the character</em></span><span id="bde2" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">let</strong> scene = SCNScene()</span><span id="7891" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">let</strong> cameraNode = SCNNode()</span><span id="660c" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">private</strong> <strong class="mv ir">lazy</strong> <strong class="mv ir">var</strong> model = contentNode!.childNode(withName: “model”, recursively: <strong class="mv ir">true</strong>)! <em class="ok">// Whole model including eyes</em></span><span id="e78d" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">private</strong> <strong class="mv ir">lazy</strong> <strong class="mv ir">var</strong> head = contentNode!.childNode(withName: “head”, recursively: <strong class="mv ir">true</strong>)! <em class="ok">// Face that contains blendshapes</em></span></pre><p id="1f2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模型和头部变量正好对应于上面场景图中显示的节点，重要的是它们完全相同。</p><p id="f00b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们将需要设置一个<code class="fe ms mt mu mv b">AVCaptureDevice</code>会话。为了做到这一点，我们首先要在<code class="fe ms mt mu mv b">.plist</code>文件中设置摄像机权限。因此，请转到<code class="fe ms mt mu mv b">Info.plist</code>，点击“+”按钮，选择“隐私—相机使用说明”，然后在文本框中键入如下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi om"><img src="../Images/54f575b51914e3307dfe8f1a06f8be8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*er_8XXhub78gZS3Bpxx9Og.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">向添加权限。plist</p></figure><p id="d0b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ms mt mu mv b">viewDidLoad</code>方法中初始化一个<code class="fe ms mt mu mv b"><a class="ae ln" href="https://developer.apple.com/documentation/avfoundation/avcapturedevice" rel="noopener ugc nofollow" target="_blank">AVCaptureDevice</a></code>请求:</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="82e2" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">override</strong> <strong class="mv ir">func</strong> viewDidLoad() {</span><span id="77e1" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">   super</strong>.viewDidLoad()<br/>   AVCaptureDevice.requestAccess(for: AVMediaType.video) { granted <strong class="mv ir">in<br/>        if</strong> (granted) {<br/>        } <strong class="mv ir">else</strong> {<br/>            <em class="ok">// If access is not granted, throw error and exit<br/>            </em>fatalError("This app needs Camera Access to function. You can grant access in Settings.")<br/>        }<br/>    }<br/>}</span></pre><p id="387e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们需要一个函数来初始化面部追踪器(注意:我们还没有将<code class="fe ms mt mu mv b">ViewController</code>变成<code class="fe ms mt mu mv b"><a class="ae ln" href="https://developer.apple.com/documentation/arkit/arscnviewdelegate" rel="noopener ugc nofollow" target="_blank">ARSCNViewDelegate</a></code>，所以在我们这样做之前，你会得到一个错误)。</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="6c7a" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">func</strong> setupFaceTracker() {<br/>    <em class="ok">// Configure and start face tracking session<br/>    </em><strong class="mv ir">let</strong> configuration = ARFaceTrackingConfiguration()<br/>    configuration.isLightEstimationEnabled = <strong class="mv ir">true<br/>    </strong><em class="ok">// Run ARSession and set delegate to self<br/>    </em><strong class="mv ir">self</strong>.trackingView.session.run(configuration)<br/>    <strong class="mv ir">self</strong>.trackingView.delegate = <strong class="mv ir">self<br/>    self</strong>.trackingView.isHidden = <strong class="mv ir">true </strong><em class="ok">// Remove if you want to see the camera feed</em><strong class="mv ir"><br/></strong>}</span></pre><p id="9445" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们要设置<a class="ae ln" href="https://developer.apple.com/documentation/scenekit/scnview" rel="noopener ugc nofollow" target="_blank"> SCNView </a>:</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="8c50" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">func</strong> sceneSetup() {<br/>    <strong class="mv ir">if</strong> <strong class="mv ir">let</strong> filePath = Bundle.main.path(forResource: "Smiley", ofType: "scn", inDirectory: "Models.scnassets") {<br/>        <strong class="mv ir">let</strong> referenceURL = URL(fileURLWithPath: filePath)<br/>        <strong class="mv ir">self</strong>.contentNode = SCNReferenceNode(url: referenceURL)<br/>        <strong class="mv ir">self</strong>.contentNode?.load()</span><span id="b821" class="nb lw iq mv b gy ol nd l ne nf">        <strong class="mv ir">self</strong>.head.morpher?.unifiesNormals = <strong class="mv ir">true</strong> <em class="ok">// ensures the normals are not morphed but are recomputed after morphing the vertex instead. Otherwise the node has a low poly look.<br/>        </em><strong class="mv ir">self</strong>.scene.rootNode.addChildNode(<strong class="mv ir">self</strong>.contentNode!)<br/>    }<br/>    <strong class="mv ir">self</strong>.faceView.autoenablesDefaultLighting = <strong class="mv ir">true</strong></span><span id="a804" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">    </strong><em class="ok">// set the scene to the view<br/>    </em><strong class="mv ir">self</strong>.faceView.scene = <strong class="mv ir">self</strong>.scene</span><span id="689b" class="nb lw iq mv b gy ol nd l ne nf"><em class="ok">    // allows the user to manipulate the camera<br/>    </em><strong class="mv ir">self</strong>.faceView.allowsCameraControl = <strong class="mv ir">false</strong></span><span id="ff3c" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">    self</strong>.faceView.backgroundColor = .clear<br/>}</span></pre><p id="781e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这部分:</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="c1ad" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">self</strong>.head.morpher?.unifiesNormals = <strong class="mv ir">true</strong></span></pre><p id="c721" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是代码的<a class="ae ln" href="https://developer.apple.com/documentation/scenekit/scnmorpher/2875540-unifiesnormals" rel="noopener ugc nofollow" target="_blank">位，它将修复我们之前看到的低聚合问题。</a><a class="ae ln" href="https://stackoverflow.com/a/49512592/3599895" rel="noopener ugc nofollow" target="_blank">这个答案</a>很好的描述了为什么会这样。</p><p id="3df0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们要设置相机节点，它将场景视图放置在前面，并从角色节点稍微抬高一点。</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="dfb8" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">func</strong> createCameraNode () {<br/>   <strong class="mv ir">self</strong>.cameraNode.camera = SCNCamera()<br/>   <strong class="mv ir">self</strong>.cameraNode.position = <strong class="mv ir">self</strong>.cameraPosition <br/>   <strong class="mv ir">self</strong>.scene.rootNode.addChildNode(<strong class="mv ir">self</strong>.cameraNode)<br/>   <strong class="mv ir">self</strong>.faceView.pointOfView = <strong class="mv ir">self</strong>.cameraNode<br/>}</span></pre><p id="1d0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些都是创建3D角色节点所需的函数，所以现在我们想把它们添加到<code class="fe ms mt mu mv b">viewDidLoad</code>:</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="c04a" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">override</strong> <strong class="mv ir">func</strong> viewDidLoad() {<br/>    <strong class="mv ir">super</strong>.viewDidLoad()</span><span id="115e" class="nb lw iq mv b gy ol nd l ne nf">    AVCaptureDevice.requestAccess(for: AVMediaType.video) { granted <strong class="mv ir">in<br/>        if</strong> (granted) {<br/>            <em class="ok">// If access is granted, setup the main view<br/>            </em>DispatchQueue.main.sync {<br/>                <strong class="mv ir">self</strong>.setupFaceTracker()]<br/>                <strong class="mv ir">self</strong>.sceneSetup()<br/>                <strong class="mv ir">self</strong>.createCameraNode()<br/>            }<br/>        } <strong class="mv ir">else</strong> {<br/>            <em class="ok">// If access is not granted, throw error and exit<br/>            </em>fatalError("This app needs Camera Access to function. You can grant access in Settings.")<br/>        }<br/>    }<br/>}</span></pre><p id="08c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您在这个阶段运行应用程序，您应该会看到您的3D角色正面看着相机，但还没有面部识别动画工作。如果角色太大或太小，可以通过编程方式或在节点检查器中设置缩放变量来更改其大小。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi on"><img src="../Images/ecae8adda33cd197bf32324e15b08c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gb8-Y7kjLa-hn2S2SS5naA.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">比例变量</p></figure><p id="b1c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以将面部混合形状映射到3D角色。</p><p id="b8b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我们想创建一个继承了<code class="fe ms mt mu mv b"><a class="ae ln" href="https://developer.apple.com/documentation/arkit/arscnviewdelegate" rel="noopener ugc nofollow" target="_blank">ARSCNViewDelegate</a></code>的<code class="fe ms mt mu mv b">ViewController</code>的扩展，并覆盖这个函数</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="2e56" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">func</strong> renderer(<strong class="mv ir">_</strong> renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor)</span></pre><p id="874a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您已经将混合变形键/几何变形器命名为与Apple 定义的<a class="ae ln" href="https://github.com/JakeHoldom/EmojiFace/blob/master/BlendShapeKeys.txt" rel="noopener ugc nofollow" target="_blank">键相同的名称，那么我们需要做的就是一个简单的<code class="fe ms mt mu mv b">for</code>循环来将它们映射在一起。</a></p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="bd7d" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">extension</strong> ViewController: ARSCNViewDelegate {<br/>    <strong class="mv ir">func</strong> renderer(<strong class="mv ir">_</strong> renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor) {<br/>        <strong class="mv ir">guard</strong> <strong class="mv ir">let</strong> faceAnchor = anchor <strong class="mv ir">as</strong>? ARFaceAnchor <strong class="mv ir">else</strong> { <strong class="mv ir">return</strong> }<br/>        DispatchQueue.main.async {<br/>            <strong class="mv ir">let</strong> blendShapes = faceAnchor.blendShapes<br/>            <em class="ok">// This will only work correctly if the shape keys are given the exact same name as the blendshape names</em></span><span id="e184" class="nb lw iq mv b gy ol nd l ne nf"><em class="ok">            </em><strong class="mv ir">for</strong> (key, value) <strong class="mv ir">in</strong> blendShapes {<br/>                <strong class="mv ir">if</strong> <strong class="mv ir">let</strong> fValue = value <strong class="mv ir">as</strong>? Float<br/>                    <strong class="mv ir">self</strong>.head.morpher?.setWeight(CGFloat(fValue), forTargetNamed: key.rawValue)<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="55e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你现在运行这个应用程序，你应该会看到你的面部运动正在被跟踪并显示在你的3D角色上。</p><p id="be3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是等等…你还想跟踪你的脸的偏转、俯仰和滚动，并相应地移动3D角色的头部。你所需要做的就是使用<code class="fe ms mt mu mv b">ARFaceAnchor</code>的变换，并将其分配给角色的头部节点。</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="8573" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">self</strong>.model.simdTransform = faceAnchor.transform</span></pre><p id="ed86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这并不能很好地工作，因为转换会受到相机位置的影响，这会产生奇怪的结果。所以我们将不得不用一些传统的数学方法来计算<code class="fe ms mt mu mv b"><a class="ae ln" href="https://developer.apple.com/documentation/scenekit/scnvector3" rel="noopener ugc nofollow" target="_blank">SCNVector3</a> </code>。</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="be9d" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">func</strong> calculateEulerAngles(<strong class="mv ir">_</strong> faceAnchor: ARFaceAnchor) -&gt; SCNVector3 {</span><span id="f669" class="nb lw iq mv b gy ol nd l ne nf"><em class="ok">    // Based on StackOverflow answer </em>https://stackoverflow.com/a/53434356/3599895</span><span id="e3e8" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">    let</strong> projectionMatrix = <strong class="mv ir">self</strong>.trackingView.session.currentFrame?.camera.projectionMatrix(for: .portrait, viewportSize: <strong class="mv ir">self</strong>.faceView.bounds.size, zNear: 0.001, zFar: 1000)<br/>    <strong class="mv ir">let</strong> viewMatrix = <strong class="mv ir">self</strong>.trackingView.session.currentFrame?.camera.viewMatrix(for: .portrait)<br/>    <strong class="mv ir">let</strong> projectionViewMatrix = simd_mul(projectionMatrix!, viewMatrix!)<br/>    <strong class="mv ir">let</strong> modelMatrix = faceAnchor.transform<br/>    <strong class="mv ir">let</strong> mvpMatrix = simd_mul(projectionViewMatrix, modelMatrix)</span><span id="a31e" class="nb lw iq mv b gy ol nd l ne nf">    <em class="ok">// This allows me to just get a .x .y .z rotation from the matrix, without having to do crazy calculations<br/>    </em><strong class="mv ir">let</strong> newFaceMatrix = SCNMatrix4.init(mvpMatrix)<br/>    <strong class="mv ir">let</strong> faceNode = SCNNode()<br/>    faceNode.transform = newFaceMatrix</span><span id="adf9" class="nb lw iq mv b gy ol nd l ne nf">    <strong class="mv ir">let</strong> rotation = vector_float3(faceNode.worldOrientation.x, faceNode.worldOrientation.y, faceNode.worldOrientation.z)</span><span id="f3b6" class="nb lw iq mv b gy ol nd l ne nf">    <strong class="mv ir">let</strong> yaw = (rotation.y*3)<br/>    <strong class="mv ir">let</strong> pitch = (rotation.x*3)<br/>    <strong class="mv ir">let</strong> roll = (rotation.z*1.5)</span><span id="831b" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">    return</strong> SCNVector3(pitch, yaw, roll)<br/>}</span></pre><p id="8869" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在将模型的欧拉角设置为在<code class="fe ms mt mu mv b">renderer</code>函数中创建的<code class="fe ms mt mu mv b">SCNVector3</code>:</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="eded" class="nb lw iq mv b gy nc nd l ne nf"><strong class="mv ir">extension</strong> ViewController: ARSCNViewDelegate {<br/>    <strong class="mv ir">func</strong> renderer(<strong class="mv ir">_</strong> renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor) {<br/>        <strong class="mv ir">guard</strong> <strong class="mv ir">let</strong> faceAnchor = anchor <strong class="mv ir">as</strong>? ARFaceAnchor <strong class="mv ir">else</strong> { <strong class="mv ir">return</strong> }<br/>        DispatchQueue.main.async {<br/>            <strong class="mv ir">let</strong> blendShapes = faceAnchor.blendShapes<br/>            <em class="ok">// This will only work correctly if the shape keys are given the exact same name as the blendshape names</em></span><span id="4553" class="nb lw iq mv b gy ol nd l ne nf"><strong class="mv ir">for</strong> (key, value) <strong class="mv ir">in</strong> blendShapes {<br/>                <strong class="mv ir">if</strong> <strong class="mv ir">let</strong> fValue = value <strong class="mv ir">as</strong>? Float<br/>                    <strong class="mv ir">self</strong>.head.morpher?.setWeight(CGFloat(fValue), forTargetNamed: key.rawValue)<br/>                }<br/>            }<br/>            <strong class="mv ir">self</strong>.model.eulerAngles = <strong class="mv ir">self</strong>.calculateEulerAngles(faceAnchor)</span><span id="90dc" class="nb lw iq mv b gy ol nd l ne nf">        }<br/>    }<br/>}</span></pre><p id="c48e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你现在可以走了；使用iPhone的真深度相机，你应该有一个完全动画的3D角色！</p><p id="bf7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你喜欢这个教程，并且和你的3D人物玩得开心。如果你想要源代码，那么你可以<a class="ae ln" href="https://github.com/JakeHoldom/EmojiFace" rel="noopener ugc nofollow" target="_blank">在我的GitHub这里</a>查看，但是请记住这不包括我在这个项目中使用的3D角色。如果你想在自己的设备上尝试这个角色，那么你可以<a class="ae ln" href="https://apps.apple.com/app/id1521828825" rel="noopener ugc nofollow" target="_blank">在这里</a>下载我的应用程序Smappy。</p><p id="1ae0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>