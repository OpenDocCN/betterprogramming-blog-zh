<html>
<head>
<title>How To Use Native SQL Functions in JPA Queries With Hibernate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Hibernate在JPA查询中使用原生SQL函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-native-sql-functions-in-jpa-queries-with-hibernate-d1f17d07a588?source=collection_archive---------4-----------------------#2021-09-15">https://betterprogramming.pub/how-to-use-native-sql-functions-in-jpa-queries-with-hibernate-d1f17d07a588?source=collection_archive---------4-----------------------#2021-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="788a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过注册本机函数来避免使用本机SQL查询</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de9c27b96b0f73b1c9b023f86aa3c3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcXc07xVJ5gIb_yo-f78sA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@douglasamarelo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">道格拉斯·洛佩斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="92d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Jakarta_Persistence" rel="noopener ugc nofollow" target="_blank"> JPA </a>原生支持native SQL。当您想要利用正在使用的数据库的独特功能时，这很有用。另一方面，原生SQL查询不是数据库不可知的，这可能会成为一个问题。</p><p id="e294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如从<a class="ae ky" href="https://www.mysql.com/it/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>切换到<a class="ae ky" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>或者相反的时候。如果您使用原生查询，转换将不会很简单，因为您必须主动翻译它们。这就是为什么只有在严格需要时才应该使用原生查询。</p><p id="f519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择原生SQL查询的一个主要原因是原生函数，比如MySQL的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://mariadb.com/kb/it/group_concat/" rel="noopener ugc nofollow" target="_blank">GROUP_CONCAT</a></code>。事实上，您可能认为使用原生查询是利用这些功能的唯一方法。其实这不是真的！事实上，<a class="ae ky" href="https://en.wikipedia.org/wiki/Jakarta_Persistence#JPA_2.1" rel="noopener ugc nofollow" target="_blank"> JPA 2.1 </a>引入了允许您在<a class="ae ky" href="https://en.wikipedia.org/wiki/Jakarta_Persistence_Query_Language" rel="noopener ugc nofollow" target="_blank"> JPQL </a>或<a class="ae ky" href="https://docs.jboss.org/hibernate/core/4.0/hem/en-US/html/querycriteria.html" rel="noopener ugc nofollow" target="_blank">标准查询</a>中调用任何本地函数的特性。</p><p id="00de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在Kotlin和Java中使用Hibernate在JPA查询中使用原生SQL函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0073" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">注册本机函数</h1><p id="56ff" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您想要使用的原生SQL函数必须在Hibernate <code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/Dialect.html" rel="noopener ugc nofollow" target="_blank">Dialect</a></code>实现类中注册，这取决于您的数据库。你可以在这里找到Hibernate <a class="ae ky" href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/package-summary.html" rel="noopener ugc nofollow" target="_blank">支持的所有方言的列表</a>。在本例中，您将看到<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/MySQL8Dialect.html" rel="noopener ugc nofollow" target="_blank">MySQL8Dialect</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/PostgreSQL9Dialect.html" rel="noopener ugc nofollow" target="_blank">PostgreSQL9Dialect</a></code>。</p><p id="0e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您需要创建一个扩展您特定的<code class="fe lv lw lx ly b">Dialect</code>实现类的类。在下面的例子中，这个类被放在<code class="fe lv lw lx ly b">com.yourapp.configs</code>包中。然后，使用它注册本机函数，如下所示:</p><p id="218f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Java </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="39a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">科特林</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="acae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，通过向<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/Dialect.html#registerFunction-java.lang.String-org.hibernate.dialect.function.SQLFunction-" rel="noopener ugc nofollow" target="_blank">registerFunction</a></code>方法传递一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/function/StandardSQLFunction.html" rel="noopener ugc nofollow" target="_blank">StandardSQLFunction</a></code>类，MySQL <code class="fe lv lw lx ly b">GROUP_CONCAT</code>函数被添加到了<code class="fe lv lw lx ly b">MySQL8Dialect</code>中。传递给该方法的第一个字符串表示用于在查询中调用本机函数的名称。请注意，许多其他本机SQL函数也可以类似地注册。</p><p id="7ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您需要使这个类成为默认的Hibernate方言。您可以通过将以下属性添加到您的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html" rel="noopener ugc nofollow" target="_blank">application.properties</a></code>文件中来实现这一点:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="af8b" class="nj mh it ly b gy nk nl l nm nn">spring.jpa.properties.hibernate.dialect = com.myapp.util.CustomSQLDialect</span></pre><p id="78f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊！您可以开始使用刚刚在JPA查询中注册的原生SQL函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3b31" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">运行中的本机函数</h1><p id="5e45" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们看一个刚刚注册的<code class="fe lv lw lx ly b">STRING_CONCAT</code>函数的例子:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="09b0" class="nj mh it ly b gy nk nl l nm nn">SELECT F, <!-- -->STRING_CONCAT<!-- -->(F.name) AS names<br/>FROM Foo F <br/>GROUP BY F.birthDate</span></pre><p id="fe1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设<a class="ae ky" href="https://medium.com/swlh/defining-jpa-hibernate-entities-in-kotlin-1ff8ee470805" rel="noopener"> JPA实体</a> Foo映射一个<code class="fe lv lw lx ly b">foo</code>表，该表具有列<code class="fe lv lw lx ly b">id</code>、<code class="fe lv lw lx ly b">name</code>、<code class="fe lv lw lx ly b">birthDate</code>。</p><div class="no np gp gr nq nr"><a href="https://medium.com/swlh/defining-jpa-hibernate-entities-in-kotlin-1ff8ee470805" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">在Kotlin中定义JPA/Hibernate实体</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">让我们看看如何在Kotlin中正确定义JPA/Hibernate实体</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><p id="a168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，这个JPQL查询将被翻译成下面的MySQL查询:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="bd72" class="nj mh it ly b gy nk nl l nm nn">SELECT F.id, F.name, F.surname, GROUP_CONCAT(F.name) AS names<br/>FROM foo F <br/>GROUP BY F.birthDate</span></pre><p id="42d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，MySQL <code class="fe lv lw lx ly b">GROUP_CONCAT</code>函数现在由<code class="fe lv lw lx ly b">STRING_CONCAT</code> JPA函数映射。这意味着MySQL原生函数现在可以在不使用不可移植的原生SQL查询的情况下使用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a8fa" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">迁移到不同的数据库</h1><p id="f354" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设您想从MySQL迁移到PostgreSQL。如果你注册的每一个原生MySQL函数在PostgreSQL中都有对应的函数，这就很容易了。另外，不需要修改任何JPA查询。</p><p id="3931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您唯一需要做的事情就是如下更改您的<code class="fe lv lw lx ly b">CustomSQLDialect</code>类:</p><p id="9f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Java </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fd4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">科特林</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="622c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于MYSQL <code class="fe lv lw lx ly b">GROUP_CONCAT</code>函数对应于PostgreSQL <code class="fe lv lw lx ly b">STRING_AGG</code>函数，所以不需要做其他的修改。您编写的每个JPA函数仍将按预期工作。请注意，在迁移到其他数据库时，可以应用相同的过程。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c2bb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">奖金</h1><p id="37ef" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可能也会对以下文章感兴趣:</p><div class="no np gp gr nq nr"><a href="https://medium.com/swlh/designing-a-multi-layered-architecture-for-building-restful-web-services-with-spring-boot-and-a12ef85b77c9" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">用Spring Boot和…设计一个多层架构来构建RESTful Web服务</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">设计超过五层的高级架构</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://codeburst.io/criteria-queries-and-jpa-metamodel-with-spring-boot-and-kotlin-9c82be54d626" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Spring Boot和科特林的标准查询和JPA元模型</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Kotlin中更干净、更简单、更强大的标准查询</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">codeburst.io</p></div></div><div class="oa l"><div class="oh l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://codeburst.io/avoiding-code-duplication-by-adding-an-api-layer-in-spring-boot-48ee3a949cb4" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">通过在Spring Boot中添加API层来避免代码重复</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">使用后端HTTP客户端构建高级API层</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">codeburst.io</p></div></div><div class="oa l"><div class="oi l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f92f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="29aa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">今天，我们研究了如何让Hibernate在JPQL或条件查询中支持原生SQL函数。这是避免采用原生查询的一个有用的变通方法，根据定义，原生查询是不可移植的。正如您刚才看到的，向Hibernate <code class="fe lv lw lx ly b">Dialect</code>类注册函数只需要几行代码。另一方面，它减少了使用原生查询的需要，使得迁移到不同的数据库更加容易。这是一个重要的目标，本文就是要展示如何实现它。</p><p id="be0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望这篇文章对你有所帮助。</p></div></div>    
</body>
</html>