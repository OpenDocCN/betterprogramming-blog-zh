<html>
<head>
<title>Build an Infinite List With SwiftUI and Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SwiftUI和Combine构建无限列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-an-infinite-list-with-swiftui-and-combine-f9ea1e83a4a7?source=collection_archive---------4-----------------------#2021-06-30">https://betterprogramming.pub/build-an-infinite-list-with-swiftui-and-combine-f9ea1e83a4a7?source=collection_archive---------4-----------------------#2021-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d1cc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Combine框架的简单整洁的iOS应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/63037f14bb76565d56470025a74b5ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bi378c0Jlc2RmMndEQWcqg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们将建造什么。图片由作者提供。</p></figure><p id="1a7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SwiftUI自从在WWDC2019上推出以来，名气越来越大。在过去的两年里，苹果对这个UI框架做了很多改进。今天，开发人员已经开始采用它，并慢慢地从UIKit迁移他们的项目。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="c333" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">我们将建造什么？</h1><p id="3d5b" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在本教程中，我们将制作一个简单的列表，具有无休止的滚动和分页(如标题图像所示)。我们将使用<a class="ae mv" href="https://docs.github.com/en/rest" rel="noopener ugc nofollow" target="_blank"> GitHub API </a>来获取一个<a class="ae mv" href="https://docs.github.com/en/rest/reference/users#list-users" rel="noopener ugc nofollow" target="_blank">用户列表</a>。它包含了GitHub成立以来的所有用户。在我们的最终产品中，我们将能够创建具有以下功能的应用程序:</p><ol class=""><li id="371e" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">能够根据给定的页面限制获取用户列表。</li><li id="1ffa" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">能够无休止地滚动带有分页的<a class="ae mv" href="https://developer.apple.com/documentation/swiftui/list" rel="noopener ugc nofollow" target="_blank"> SwiftUI列表</a>。</li><li id="3907" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">能够处理请求错误和重新加载。</li><li id="6194" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">将<a class="ae mv" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">组合</a>框架用于API请求和<code class="fe nk nl nm nn b">ViewModel</code>。</li></ol></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="6a2b" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">我们开始吧</h1><h2 id="f2f9" class="no lz iq bd ma np nq dn me nr ns dp mi le nt nu mk li nv nw mm lm nx ny mo nz bi translated">1.创建新的SwiftUI项目</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/fb7b73c646cbc5d7465884649fe65ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZVkDMG8airIANTZp7HOpg.png"/></div></div></figure><h2 id="16ed" class="no lz iq bd ma np nq dn me nr ns dp mi le nt nu mk li nv nw mm lm nx ny mo nz bi translated">2.创建可解码的用户模型</h2><p id="88bc" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">创建一个名为<code class="fe nk nl nm nn b">User.swift</code>的新Swift文件。我们只从JSON对象中解码出<code class="fe nk nl nm nn b">id</code>、<code class="fe nk nl nm nn b">name</code>和<code class="fe nk nl nm nn b">avatarUrl</code>。如上面的结果所示，在这个项目中，我们将只显示用户名作为一个简单的例子。您可以稍后增强它，以显示用户头像和个人资料的详细信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="805a" class="no lz iq bd ma np nq dn me nr ns dp mi le nt nu mk li nv nw mm lm nx ny mo nz bi translated">3.添加行视图</h2><p id="b4f3" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">由于我们使用的是<code class="fe nk nl nm nn b">List</code>，我们将首先创建行视图作为列表项。添加一个名为<code class="fe nk nl nm nn b">UserRow.swift</code>的新“SwiftUI视图”文件。然后，插入下面的代码。我们将使用带有<code class="fe nk nl nm nn b">Image</code>和<code class="fe nk nl nm nn b">Text</code>的简单<code class="fe nk nl nm nn b">HStack</code>。</p><p id="ad83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意这个<code class="fe nk nl nm nn b">UserRow</code>视图需要<code class="fe nk nl nm nn b">User</code>作为依赖模型，这意味着如果没有模型传递给这个视图，它就不能被初始化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="d064" class="no lz iq bd ma np nq dn me nr ns dp mi le nt nu mk li nv nw mm lm nx ny mo nz bi translated">4.主视图(内容视图)</h2><p id="9fb1" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated"><code class="fe nk nl nm nn b">ContentView</code>是我们默认的主视图。主视图在<code class="fe nk nl nm nn b">InfiniteListSwiftUIApp</code>文件(ProjectNameApp文件)中定义。</p><p id="4eb9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了。让我们包括一个<code class="fe nk nl nm nn b">NavigationView</code>和一个<code class="fe nk nl nm nn b">List</code>。然后，插入一些静态用户数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3aa2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果我们运行我们的项目，应用程序将类似于下图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/a78721f309eed9e1ca8e923e94b53611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsb_75TN-f5g0gEei0ePhw.png"/></div></div></figure><h2 id="5aa1" class="no lz iq bd ma np nq dn me nr ns dp mi le nt nu mk li nv nw mm lm nx ny mo nz bi translated">5.创建API服务</h2><p id="afc2" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在这一步，我们将创建一个API服务来从GitHub API获取用户数据。如下图所示，为了启用分页，我们需要发送<code class="fe nk nl nm nn b">since</code>和<code class="fe nk nl nm nn b">per_page</code>参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/fc6a554735f86e38a6e2769a16d25659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-FmIe771CCcvqEYfB-1kw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nk nl nm nn b">/users</code>来自<a class="ae mv" href="https://docs.github.com/en/rest/reference/users#list-users" rel="noopener ugc nofollow" target="_blank"> GitHub API文档</a>的端点详情。</p></figure><p id="98d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将以下代码添加到名为<code class="fe nk nl nm nn b">APIService.swift</code>的新文件中。由于我们使用的是SwiftUI，项目自动支持iOS13+。我们将在我们的<code class="fe nk nl nm nn b">URLSession</code>中使用<a class="ae mv" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">联合</a>框架。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ol class=""><li id="cde0" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">创建一个接受<code class="fe nk nl nm nn b">perPage</code>和<code class="fe nk nl nm nn b">sinceId</code>并返回一个带有<code class="fe nk nl nm nn b">[User]</code>的<code class="fe nk nl nm nn b">AnyPublisher</code>类型的函数。</li><li id="9bd7" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">用指定的参数构造一个URL。</li><li id="cb78" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">创建一个超时10秒的URL请求。</li><li id="5839" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">用<code class="fe nk nl nm nn b">dataTaskPublisher</code>发送请求。然后将结果映射到<code class="fe nk nl nm nn b">.data</code>(结果会返回<code class="fe nk nl nm nn b">Data</code>和<code class="fe nk nl nm nn b">Response</code>)。最后，将数据解码成<code class="fe nk nl nm nn b">[User]</code>。简单又干净，对吧？</li></ol><h2 id="351b" class="no lz iq bd ma np nq dn me nr ns dp mi le nt nu mk li nv nw mm lm nx ny mo nz bi translated">6.创建视图模型</h2><p id="20d1" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">添加一个名为<code class="fe nk nl nm nn b">UserViewModel</code>的新Swift文件作为<code class="fe nk nl nm nn b">ObservableObject</code>，并添加以下代码。通过子类化<code class="fe nk nl nm nn b"><a class="ae mv" href="https://developer.apple.com/documentation/combine/observableobject" rel="noopener ugc nofollow" target="_blank">ObservableObject</a></code>，我们的视图模型可以在SwiftUI视图中使用，并在发生任何重要变化时启用自动重新加载。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ol class=""><li id="340b" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">用<code class="fe nk nl nm nn b"><a class="ae mv" href="https://developer.apple.com/documentation/combine/published" rel="noopener ugc nofollow" target="_blank">Published</a></code>包装器创建<code class="fe nk nl nm nn b">users</code>和<code class="fe nk nl nm nn b">isRequested</code>变量，使任何SwiftUI视图都能接收更新。</li><li id="fbb9" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">添加一个常量<code class="fe nk nl nm nn b">pageLimit</code>来指定将从API返回的用户对象的数量。然后，添加<code class="fe nk nl nm nn b">currentLastId</code>来保存我们获取的<code class="fe nk nl nm nn b">users</code>数组中的最后一个用户ID。如前一步所述，它将用于分页参数请求。</li><li id="3218" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">从我们的服务舱呼叫<code class="fe nk nl nm nn b">getUsers()</code>。</li><li id="a439" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">当请求失败时，我们将把变量<code class="fe nk nl nm nn b">isRequestFailed</code>标记为<code class="fe nk nl nm nn b">true</code>,这样它将触发订阅者视图并进行适当的重新加载。</li><li id="ce98" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">如果请求成功，我们将获得收到的值(类型为<code class="fe nk nl nm nn b">[User]</code>)并将该值追加到<code class="fe nk nl nm nn b">users</code>变量中。同样，当<code class="fe nk nl nm nn b">users</code>变量发生变化时，它会立即触发视图重新加载其内容。然后，存储<code class="fe nk nl nm nn b">currentLastId</code>用于下一次读取。</li></ol><h2 id="702c" class="no lz iq bd ma np nq dn me nr ns dp mi le nt nu mk li nv nw mm lm nx ny mo nz bi translated">7.创建LoaderView</h2><p id="c949" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">现在我们想要创建一个<code class="fe nk nl nm nn b">LoaderView</code>，它将被放置在<code class="fe nk nl nm nn b">List</code>的底部。所以，无论何时出现，它都会调用获取数据函数。即使用户列表为空，<code class="fe nk nl nm nn b">LoaderView</code>仍会出现在顶部并显示加载文本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="3bb0" class="no lz iq bd ma np nq dn me nr ns dp mi le nt nu mk li nv nw mm lm nx ny mo nz bi translated">8.更新内容视图</h2><p id="4ba8" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">这是我们的最后一步，非常简单，因为我们已经在<code class="fe nk nl nm nn b">ViewModel</code>中分离了逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ol class=""><li id="a5d1" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">移除先前的<code class="fe nk nl nm nn b">users</code>静态变量，并使用来自<code class="fe nk nl nm nn b">ViewModel</code>的<code class="fe nk nl nm nn b">users</code>数据。创建一个<code class="fe nk nl nm nn b">userViewModel</code>实例，将<code class="fe nk nl nm nn b"><a class="ae mv" href="https://developer.apple.com/documentation/swiftui/observedobject" rel="noopener ugc nofollow" target="_blank">ObservedObject</a></code>作为<code class="fe nk nl nm nn b">UserViewModel</code>中变更的订阅者。它会在收到新的更新时使视图失效。</li><li id="2fac" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">和以前一样，除了现在我们使用来自<code class="fe nk nl nm nn b">ViewModel</code>的<code class="fe nk nl nm nn b">users</code>数组。</li><li id="8241" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">将我们之前创建的<code class="fe nk nl nm nn b">LoaderView</code>添加到底部的列表中。此外，它还有一个<code class="fe nk nl nm nn b">onAppear()</code>函数将调用<code class="fe nk nl nm nn b">fetchData</code>。添加<code class="fe nk nl nm nn b">onTapGesture()</code>以在请求失败时重新获取数据。</li><li id="dde9" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">在<code class="fe nk nl nm nn b">ViewModel</code>中调用<code class="fe nk nl nm nn b">getUsers</code>。</li><li id="d0ab" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">处理“点击重试”操作。</li></ol><h2 id="15e4" class="no lz iq bd ma np nq dn me nr ns dp mi le nt nu mk li nv nw mm lm nx ny mo nz bi translated">9.测试失败的请求</h2><p id="fd24" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我建议使用网络链接调节器工具来模拟一个失败的网络请求，如下图所示。因此，当我们滚动到末尾时，我们可能会到达<code class="fe nk nl nm nn b">LoaderView</code>，几秒钟后请求将会失败。详细内容你可以看我之前的<a class="ae mv" href="https://medium.com/codex/simulate-poor-network-conditions-in-ios-development-1c1912a33a51" rel="noopener">文章</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/65f624c351f3f3715a01a8ed669c5c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAVkzZj88-TBKp5uw1iBHg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当网络请求失败时，会显示“点击重试”。</p></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="ce35" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">项目已完成</h1><p id="3d64" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">恭喜你！我们已经完成了所有的步骤，代码运行良好。当我用Combine框架实现SwiftUI代码时，我从未想到它会如此干净。</p><p id="4b2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整的源代码可以从我的GitHub <a class="ae mv" href="https://github.com/xmhafiz/InfiniteListSwiftUI" rel="noopener ugc nofollow" target="_blank">库</a>下载。您可以尝试将其实现到您的项目中，并改进代码逻辑和UI。关于联合收割机框架和<code class="fe nk nl nm nn b">ObservableObject</code>协议的细节，你可以参考这个WWDC <a class="ae mv" href="https://developer.apple.com/videos/play/wwdc2019/226" rel="noopener ugc nofollow" target="_blank">视频</a>和这篇HackingWithSwift <a class="ae mv" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-observedobject-to-manage-state-from-external-objects" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="9651" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读和快乐编码！</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="d114" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">参考</h1><ul class=""><li id="8619" class="mw mx iq kx b ky mq lb mr le og li oh lm oi lq oj nc nd ne bi translated"><a class="ae mv" href="https://developer.apple.com/documentation/combine/fail/receive(on:options:)" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/combine/fail/receive(on:options:)</a></li><li id="ce9a" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq oj nc nd ne bi translated"><a class="ae mv" href="https://developer.apple.com/documentation/swiftui/list" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/documentation/swiftui/list</a></li><li id="47bb" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq oj nc nd ne bi translated"><a class="ae mv" href="https://developer.apple.com/documentation/combine/observableobject" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/combine/observable object</a></li><li id="c273" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq oj nc nd ne bi translated"><a class="ae mv" href="https://developer.apple.com/documentation/combine/published" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/documentation/combine/published</a></li><li id="f5fd" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq oj nc nd ne bi translated"><a class="ae mv" href="https://developer.apple.com/videos/play/wwdc2019/226" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/videos/play/wwdc2019/226</a></li><li id="2bd2" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq oj nc nd ne bi translated"><a class="ae mv" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-observedobject-to-manage-state-from-external-objects" rel="noopener ugc nofollow" target="_blank">https://www . hacking with swift . com/quick-start/swift ui/how-to-use-observed object-to-manage-state-from-external-objects</a></li><li id="1885" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq oj nc nd ne bi translated"><a class="ae mv" href="https://docs.github.com/en/rest/reference/users#list-users" rel="noopener ugc nofollow" target="_blank">https://docs.github.com/en/rest/reference/users#list-users</a></li></ul></div></div>    
</body>
</html>