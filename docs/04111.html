<html>
<head>
<title>How to Render Large Tree Data Structures in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中渲染大型树数据结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-render-large-tree-data-structures-in-angular-653bf6cf0bd0?source=collection_archive---------8-----------------------#2020-03-24">https://betterprogramming.pub/how-to-render-large-tree-data-structures-in-angular-653bf6cf0bd0?source=collection_archive---------8-----------------------#2020-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5302" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用虚拟滚动</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f84e1c1f7f68f4c670e1bcc0d03459f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tzs7riPdPlOQZKSH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@niko_photos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> niko photos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在客户端应用程序中显示很长的项目列表需要特别注意，因为众所周知，当试图呈现包含数百甚至数千个项目的列表时，应用程序的性能会迅速下降。</p><p id="9da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生这种情况是因为浏览器必须在显示给最终用户之前预先呈现整个页面和其中的所有数据，因此，在一个列表中呈现数千个项目会导致极大的挫败感。</p><p id="34ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们可以使用虚拟滚动技术来解决这个问题。</p><p id="c1f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从高级的角度来看，虚拟滚动允许客户端一次只呈现整个列表的一小部分，例如十个项目，并且当用户向上或向下滚动该列表时，仅呈现关于滚动位置应该在屏幕上显示的项目。</p><p id="67e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，除了缩短应用程序的加载时间之外，滚动列表也非常快。</p><p id="1875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将通过解决我最近遇到的一个问题来深入研究这种技术，同时尝试在Angular应用程序中可视化一个树数据结构。</p><p id="2b61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图清楚地描述了期望的最终结果:页面上应该呈现一个树形数据结构，在某些情况下可能包含数百甚至数千个条目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/2370cf3d4d49a138a3f8d0a5bce0dc14.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*rHfkfeiv3Q19mo6eBgeH2Q.png"/></div></figure><p id="7eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Angular Material提供了一个非常好的<a class="ae ky" href="https://material.angular.io/components/tree/overview" rel="noopener ugc nofollow" target="_blank">组件</a>来显示这样的数据结构，但是它没有提供所需的灵活性。</p><p id="b2b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我将在下面展示的，通过嵌套组件的递归呈现的一种天真的方法将会达到期望的结果，然而，由于必须呈现大量的项目，性能将会很糟糕。</p><p id="82c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更不用说这个表格视图的初始规范要求任何级别的项目都是可拖动/可放下的，并且它们的内容是可编辑的<em class="lw"> … </em></p><p id="0a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为了让这篇文章简单有趣，我只是将每一项的内容表示为一个字符串，没有任何拖放功能。</p><p id="2bd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从讨论呈现整个树结构的天真方法开始，然后我将继续进行一些修改以实现可伸缩的最终结果。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1e2d" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">呈现树形结构的简单方法</h1><p id="cfc1" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">最初，我创建了树条目数据结构<code class="fe nb nc nd ne b">TreeNode</code>，它将保存数据、对父条目的引用(稍后我们将看到为什么我们需要它)和一个子条目数组，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b2f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">Tree</code>数据结构如下所示。它由一个没有内容的根节点组成，该根节点包含将在列表中显示的第一级子节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="37c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了呈现这个数据结构，我创建了一个父组件<code class="fe nb nc nd ne b">TreeParentComponent</code>和一个子组件<code class="fe nb nc nd ne b">TreeChildComponent</code>。</p><p id="2dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">父组件将只呈现第一级项目，即<code class="fe nb nc nd ne b">Root</code>节点的子节点，子组件将以递归方式呈现各自的子组件，直到每个项目都被呈现。</p><p id="6a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有人可能会说父组件可能会令人困惑，或者可能是不需要的，但是我喜欢分离关注点，并且不干涉可以在承载<code class="fe nb nc nd ne b">Tree</code>视图的主组件中实现的逻辑。</p><p id="087a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的片段分别显示了<code class="fe nb nc nd ne b">TreeParentComponent</code>和<code class="fe nb nc nd ne b">TreeChildComponent</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="10e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我尝试渲染成千上万个项目，这个解决方案的性能会很好吗？</p><p id="688c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我试图拖动一个节点或简单地添加一个新节点时，我可以想象变化检测周期将我的笔记本电脑的风扇推到极限，这种实现立即成为问题。</p><p id="3a57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的演示应用程序展示了这种不可伸缩的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ng l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="fb2e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">渲染树结构的优化方法</h1><p id="10d8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">根据以前的经验，我知道虚拟滚动技术可以让我不至于抓狂。</p><p id="0f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种技术允许我定义一个固定大小的容器，在其中呈现<code class="fe nb nc nd ne b">Tree</code>结构，它将根据每个项目的高度，将当前在该容器中可见的一些元素附加到DOM。</p><p id="75ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，要实现虚拟滚动，我们需要为项目的高度指定一个固定的大小。这个解决方案不适用于上面显示的编码示例，因为子组件的高度不能相同，因为它们可能有不同数量的子组件。</p><p id="9830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提供具有固定大小项目的虚拟滚动，我将对不可伸缩代码进行一些调整。</p><p id="f7b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我需要在一个平面列表中表示整个树，使用<a class="ae ky" href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/" rel="noopener ugc nofollow" target="_blank"> DFS </a>算法根据需要可视化父子关系。下面给出了以这种方式展平树的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="21d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，子组件不会呈现任何内部子组件，相反，它们只会呈现节点数据。</p><p id="eb88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了用基于节点级别的精确缩进来可视化不同的级别，我实现了一个方法来检索树中节点的级别，从级别为0的根开始，并使用它向每个节点添加动态填充:</p><pre class="kj kk kl km gt ni ne nj nk aw nl bi"><span id="4f19" class="nm mf it ne b gy nn no l np nq">[style.padding-left.px]="levelDistance() * 20"</span></pre><p id="1682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要逻辑位于父组件中，其中展平的树呈现在可滚动列表中。让我们分解以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e8ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该使用viewport组件中的<code class="fe nb nc nd ne b">*cdkVirtualFor</code>迭代平面树项目，即<code class="fe nb nc nd ne b">cdk-virtual-scroll-viewport</code>。视口的主要必需属性是<code class="fe nb nc nd ne b">itemSize</code>，它以像素表示树节点的大小。</p><p id="5b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得更好的性能，我加入了一些可选属性，<code class="fe nb nc nd ne b">minBufferPx</code>和<code class="fe nb nc nd ne b">maxBufferPx</code>。它们控制需要缓冲的最小和最大空间。</p><p id="df83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在滚动列表时，如果当前渲染的剩余缓冲空间低于<code class="fe nb nc nd ne b">minBufferPx</code>，视口将渲染额外的空间，直到其缓冲了<code class="fe nb nc nd ne b">maxBufferPx</code>空间。这样，它确保了列表的平滑滚动。</p><p id="58f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，渲染性能的另一个改进是对<code class="fe nb nc nd ne b">templateCacheSize</code>属性的规范。</p><p id="fea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个，<code class="fe nb nc nd ne b">*cdkVirtualFor</code>将缓存最多20个以前销毁的项目，当再次需要它们时，<code class="fe nb nc nd ne b">*cdkVirtualFor</code>将从缓存中获取它们，而不是重新创建它们。</p><p id="58b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面给出了可扩展解决方案的完整实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ng l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="347d" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="b467" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">感谢您的宝贵时间，希望这个解决方案对您有用。我期待着听到你的建议，让这个解决方案更好，或者一个完全不同的方法。</p><p id="3018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保重。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="4a29" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">参考</h1><ul class=""><li id="fa59" class="nr ns it lb b lc mw lf mx li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ky" href="https://material.angular.io/cdk/scrolling/overview" rel="noopener ugc nofollow" target="_blank">滚动</a> —角状材料</li></ul></div></div>    
</body>
</html>