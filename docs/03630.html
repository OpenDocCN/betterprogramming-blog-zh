<html>
<head>
<title>Learn About Decorators in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解JavaScript中的装饰器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-about-decorators-in-javascript-d19c8795e8a?source=collection_archive---------4-----------------------#2020-02-24">https://betterprogramming.pub/learn-about-decorators-in-javascript-d19c8795e8a?source=collection_archive---------4-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="731e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用漂亮的增强装饰你的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20677d337d45f92c549f4295edbf3f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJi5Y2mzPPo8RUCEJxlLVg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">维多利亚·斯特鲁科夫斯卡娅在Unsplash<a class="ae ky" href="https://unsplash.com/s/photos/decorate?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="6985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在web开发中，JavaScript被认为是构建高度复杂的用户界面的最推荐语言，这些用户界面可能来自各种需求，尤其是来自业务需求。</p><p id="b709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论JavaScript中一种叫做<em class="lv"> decorators </em>的有用模式。</p><p id="4194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器是可以用来动态地向另一个对象<em class="lv">添加额外功能的对象<em class="lv">，而不必改变那个对象</em>的实现。只要理解了这个定义，我们就很有可能达成共识，它们会对我们的应用程序代码有用。</em></p><p id="762e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你和我一样，一开始可能会有点困惑，尤其是在TypeScript中，语法与众不同。</p><p id="c9c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用现代语法对类应用装饰器时，感觉不太像JavaScript。(目前在TypeScript和<a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>插件中支持。)</p><p id="9fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个使用中的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="68a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那些从未见过这种类型代码(特别是<code class="fe ly lz ma mb b">@filterMales</code>语法)的人，当意识到这是在应用装饰器时，可能会对装饰器感到有点害怕。</p><p id="83de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的装饰者只是语法糖。理解和实现一个装饰器可能比你想象的要容易。如果你已经用JavaScript开发了一段时间，你可能已经实现了一个装饰器，甚至没有注意到它。它们简单但功能强大。</p><p id="d9e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将看看JavaScript中装饰器的一些例子，并创建我们自己的装饰器，看看它如何对我们的代码有用。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="2d29" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">什么时候是使用装饰器的好时机？</h1><p id="1e9a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">幸运的是，装饰者可以在很多方面对我们有用。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="8640" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">向现有对象添加动态行为</h1><p id="f937" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如前所述，一个非常有用的场景是当您需要动态地向对象添加额外的逻辑，而不必处理一些替代方案(如子类化或继承)时。</p><p id="411e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这一点:装饰者可以<em class="lv">将东西</em>注入物体，而外界甚至不知道<em class="lv">他们将如何</em>做这件事。</p><p id="0ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有一个<code class="fe ly lz ma mb b">Frog</code>类，它将实现一个叫做<code class="fe ly lz ma mb b">lick</code>的方法。青蛙有牙齿，所以我们也将随机实现一个<code class="fe ly lz ma mb b">getTeeths</code>方法来返回它们拥有的牙齿数量。</p><p id="7fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="61d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，有不同的青蛙，比如蟾蜍。癞蛤蟆仍然是青蛙，但是青蛙不是癞蛤蟆，这意味着它们之间一定有一些不同的特征，不能和T21混为一谈。</p><p id="0f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为蟾蜍是一只青蛙，我们可以构建一个<code class="fe ly lz ma mb b">withToad</code>装饰器，如果需要的话，它会装饰一只青蛙的实例，这样它就可以代表蟾蜍。</p><p id="b9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，装饰者应该只扩展或添加额外的行为，而不是改变它的实现。</p><p id="b8fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解了这一点，<code class="fe ly lz ma mb b">withToad</code>装饰者实际上很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的装饰器<code class="fe ly lz ma mb b">withToad</code>重新实现了<code class="fe ly lz ma mb b">getTeeths</code>以便它返回<code class="fe ly lz ma mb b">0</code>，因为蟾蜍<em class="lv">没有牙齿</em>。当我们使用这个装饰器时，我们实际上是在无声地装饰(在本例中是转换)一只青蛙来表示一只蟾蜍青蛙。</p><p id="815c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用继承的子类化可以达到同样的目的，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="fb7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法的区别在于，通过使用decorators，您不必为蟾蜍创建类。</p><p id="fdd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的例子展示了装饰者是如何操纵一只青蛙，使其更符合蟾蜍的特征的。现在让我们看一个更好的例子，看看我们如何使用decorators来扩展功能。这就是事情开始变得有点有趣的地方。</p><p id="ee0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们正在构建一个支持各种自定义预定义主题的应用程序，供用户设计他们的控制面板。</p><p id="635c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用方法<code class="fe ly lz ma mb b">createStylesheet</code>实现一个<code class="fe ly lz ma mb b">Theme</code>来创建一个兼容的样式表，一个<code class="fe ly lz ma mb b">applyStyles</code>方法来解析这个样式表并将它应用到DOM，允许它自己调用<code class="fe ly lz ma mb b">applyStyle</code>来将它们应用到DOM:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事情看起来很好。我们现在已经定义了我们的<code class="fe ly lz ma mb b">Theme</code> API，现在我们可以创建一个样式表，如下所示:</p><pre class="kj kk kl km gt ng mb nh ni aw nj bi"><span id="0c33" class="nk mk it mb b gy nl nm l nn no">const theme = new Theme()<br/>const stylesheet = theme.createStylesheet()</span></pre><p id="9cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe ly lz ma mb b">stylesheet</code>目前的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="0a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以这样使用它，它将相应地装饰我们的网页:</p><pre class="kj kk kl km gt ng mb nh ni aw nj bi"><span id="2a62" class="nk mk it mb b gy nl nm l nn no">theme.applyStylesheet(stylesheet)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/2a8bf6fc5751a7476c924ee4d412e8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OlK03goRr673fYcs.jpg"/></div></div></figure><h2 id="3b1a" class="nk mk it bd ml nq nr dn mp ns nt dp mt li nu nv mv lm nw nx mx lq ny nz mz oa bi translated">继续记住这一点:提供开放的机会来支持插件开发</h2><p id="34d6" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当调用<code class="fe ly lz ma mb b">createStylesheet</code>时，我们如何让<code class="fe ly lz ma mb b">theme</code>返回给我们一个自定义主题，我们可以使用它来扩展，而不是使用默认主题？</p><p id="69f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是decorators可以派上用场的地方，因为它允许我们返回一个不同的、预定义的默认主题。</p><p id="43f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个装饰器，它将帮助我们应用一个装饰<code class="fe ly lz ma mb b">Theme</code>的<code class="fe ly lz ma mb b">blood</code>主题，这样它将生成一个默认样式表来表示<code class="fe ly lz ma mb b">blood</code>主题，而不是原来的主题。</p><p id="c0a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们称这个装饰者为<code class="fe ly lz ma mb b">bloodTheme</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="d322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们要做的就是用一行代码装饰一个<code class="fe ly lz ma mb b">theme</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主题现在为我们提供了一个默认的<code class="fe ly lz ma mb b">blood</code>样式表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="cc8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，<code class="fe ly lz ma mb b">theme</code>的代码/实现没有改变。应用自定义样式表也没有改变:</p><pre class="kj kk kl km gt ng mb nh ni aw nj bi"><span id="8cf0" class="nk mk it mb b gy nl nm l nn no">theme.applyStylesheet(stylesheet)</span></pre><p id="1553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的网页将应用<code class="fe ly lz ma mb b">blood</code>主题样式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0a5f2004b6be5c97ddf93a852da526f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NYruspMlj2y7m6n1.jpg"/></div></div></figure><p id="366d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建任意多的主题，并随时应用它们。这意味着我们的代码对插件开放，比如自定义主题。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="8a73" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">应用临时行为</h1><p id="2d21" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">使用decorators的另一个好时机是当我们想方设法临时将行为应用到对象上时，因为我们计划在将来移除它们。</p><p id="faff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果圣诞节即将来临，我们可以很容易地创建一个圣诞样式表<em class="lv"> </em>并将其作为装饰应用。这很好，因为当圣诞节结束时，我们可以很容易地从代码中删除它。</p><p id="cc6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，我们需要做的就是删除<code class="fe ly lz ma mb b">bloodTheme(theme)</code>行来转换回原来的样式表。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="1d2f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">子类化/继承</h1><p id="831a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">使用decorators的另一个好的用例是，当我们的代码变大时，创建子类开始变得难以管理。</p><p id="2658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，与Java等静态语言相比，这个问题在JavaScript中并不严重——除非您在JavaScript中大量使用类继承实现。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="c484" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">调试模式</h1><p id="9f8f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">另一个有用的用例是创建一个调试模式装饰器，当应用它时，它将记录控制台发生的所有事情。例如，这里有一个<code class="fe ly lz ma mb b">debugTheme</code>装饰器，它在开发模式下对我们很有用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c29e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们在<code class="fe ly lz ma mb b">development</code>模式下运行应用时，我们的控制台会提供有用的信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/b5a12d0195bed24724ad41e1b33ef161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2W70veRHQKZrxslvEFZPQ.jpeg"/></div></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9bda" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="f11c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这个帖子到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>