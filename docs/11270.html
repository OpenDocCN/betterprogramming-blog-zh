<html>
<head>
<title>Simultaneously Scrolling SwiftUI ScrollViews Using Introspect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用自省同时滚动SwiftUI ScrollViews</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simultaneously-scrolling-scrollviews-in-swiftui-2e8ef70ee993?source=collection_archive---------3-----------------------#2022-03-04">https://betterprogramming.pub/simultaneously-scrolling-scrollviews-in-swiftui-2e8ef70ee993?source=collection_archive---------3-----------------------#2022-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ef05" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建直观的用户界面</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/31b24cdf135454cc6fe6739c02c39b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*9B5C6B1eQII4x5sFrmPq1g.png"/></div></figure><p id="0d14" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">使用<code class="fe lq lr ls lt b">UIKit</code>的同时滚动<code class="fe lq lr ls lt b">UIScrollView</code>可以通过使用<code class="fe lq lr ls lt b">UIScrollViewDelegate</code>轻松实现。这个想法非常简单:观察一个<code class="fe lq lr ls lt b">UIScrollView</code>的<code class="fe lq lr ls lt b">contentOffset</code>，当值改变时将它应用到另一个。</p><p id="9d68" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">然而，<code class="fe lq lr ls lt b">SwiftUI</code>目前并没有提供一个API来实现同样的功能。</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><p id="27e7" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">至少<code class="fe lq lr ls lt b">iOS 14</code>有了一个新的API来做类似的事情，但这还不足以复制想要的用例:</p><div class="lu lv gp gr lw lx"><a href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-make-a-scroll-view-move-to-a-location-using-scrollviewreader" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">如何使用ScrollViewReader将滚动视图移动到某个位置</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">Paul Hudson @twostraws在iOS 14中为Xcode 13.2新更新如果你想以编程方式让SwiftUI的ScrollView…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">www.hackingwithswift.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks lx"/></div></div></a></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="7099" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">使能同时滚动<code class="fe lq lr ls lt b">SwiftUI</code>中的<code class="fe lq lr ls lt b">ScrollView</code></h1><p id="1fb8" class="pw-post-body-paragraph ku kv iq kw b kx ne jr kz la nf ju lc ld ng lf lg lh nh lj lk ll ni ln lo lp ij bi translated">由于没有API来实现这一点，我们需要访问底层的<code class="fe lq lr ls lt b">UIKit</code>元素并在那里设置<code class="fe lq lr ls lt b">contentOffset</code>。这就是通过提供对<code class="fe lq lr ls lt b">UIKit</code>元素的访问<a class="ae nj" href="https://github.com/siteline/SwiftUI-Introspect" rel="noopener ugc nofollow" target="_blank"> SwiftUI-Introspect </a>派上用场的地方。</p><div class="lu lv gp gr lw lx"><a href="https://github.com/siteline/SwiftUI-Introspect" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">GitHub-siteline/SwiftUI-Introspect:从swift ui检查底层UIKit组件</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">Introspect允许您获取SwiftUI视图的底层UIKit或AppKit元素。例如，用内省…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="nk l mi mj mk mg ml ks lx"/></div></div></a></div><p id="55ea" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">将<code class="fe lq lr ls lt b">Introspect</code>添加到您的项目后，您可以像这样访问<code class="fe lq lr ls lt b">UIKit</code>元素:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a0dc" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这样，我们现在可以实现一个组件来同时滚动<code class="fe lq lr ls lt b">UIScrollView</code> s。</p><p id="80f2" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为简单起见，我们称这个组件为<code class="fe lq lr ls lt b">SimultaneoulsyScrollViewHandler</code>。我们需要在这个组件中注册我们想要同步的所有<code class="fe lq lr ls lt b">UIScrollViews</code>，以便能够观察和调整它们的<code class="fe lq lr ls lt b">contentOffset</code>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="3605" class="ku kv nq kw b kx ky jr kz la lb ju lc nr le lf lg ns li lj lk nt lm ln lo lp ij bi translated">在这里找到一个现成的Swift包:<a class="ae nj" href="https://github.com/stonko1994/SimultaneouslyScrollView" rel="noopener ugc nofollow" target="_blank">同时滚动查看</a></p></blockquote><p id="d899" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们需要得到关于数组中<code class="fe lq lr ls lt b">UIScrollView</code>的<code class="fe lq lr ls lt b">contentOffset</code>变化的通知，并将其应用到所有其他注册的<code class="fe lq lr ls lt b">UIScrollView</code>中。</p><p id="7c4b" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们可以通过实施<code class="fe lq lr ls lt b">UIScrollViewDelegate</code>来实现这一点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e4db" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">有了这个新组件，我们现在可以回到我们的<code class="fe lq lr ls lt b">SwiftUI</code> <code class="fe lq lr ls lt b">View</code>并在<code class="fe lq lr ls lt b">introspectScrollView</code>中使用它，如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="5a8e" class="ku kv nq kw b kx ky jr kz la lb ju lc nr le lf lg ns li lj lk nt lm ln lo lp ij bi translated"><strong class="kw ir">看看它的作用:</strong></p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/243cb7fb1a1114b487c0fb071265bac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*OH6xsNaNrewepc-jFc7TeA.gif"/></div></figure><h1 id="71c7" class="mm mn iq bd mo mp nv mr ms mt nw mv mw jw nx jx my jz ny ka na kc nz kd nc nd bi translated">从这里去哪里？</h1><p id="fa4a" class="pw-post-body-paragraph ku kv iq kw b kx ne jr kz la nf ju lc ld ng lf lg lh nh lj lk ll ni ln lo lp ij bi translated">我建议将<code class="fe lq lr ls lt b">simultaneouslyScrollViewHandler</code>存储在某个视图模型中。例如<code class="fe lq lr ls lt b">@ObservedObject</code>或<code class="fe lq lr ls lt b">@StateObject</code>。</p><p id="1fc6" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="nq">上述实施包含一些问题。</em></p><p id="ad3e" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">一个是<code class="fe lq lr ls lt b">scrollViews</code> <code class="fe lq lr ls lt b">Array</code>永远不会被清除，并将保留所有<code class="fe lq lr ls lt b">UIScrollView</code>的所有<code class="fe lq lr ls lt b">SwiftUI</code>重绘。这可以通过使用某种弱引用存储来解决。</p><p id="53ad" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在我的GitHub概要文件的最终实现中可以找到这一改进和其他改进:</p><div class="lu lv gp gr lw lx"><a href="https://github.com/stonko1994/SimultaneouslyScrollView" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">GitHub-stonko 1994/simultaneous scroll view:用SwiftUI同时滚动滚动视图…</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">支持SwiftUI的同时滚动scroll views Swift Package Manager是一个管理发行版的工具…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="oa l mi mj mk mg ml ks lx"/></div></div></a></div></div></div>    
</body>
</html>