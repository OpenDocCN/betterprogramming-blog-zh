<html>
<head>
<title>Rendering Charts With Web Workers in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular中使用Web Workers呈现图表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rendering-charts-with-web-workers-in-angular-f7ac576e21d1?source=collection_archive---------1-----------------------#2022-12-06">https://betterprogramming.pub/rendering-charts-with-web-workers-in-angular-f7ac576e21d1?source=collection_archive---------1-----------------------#2022-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6031" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Angular | Web Workers | Chart.js</h2><div class=""/><div class=""><h2 id="8766" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何使用OffscreenCanvas在web worker中创建图表</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1d0232c5dd480b7970d2d98d84ec3a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9Zf_ZS0nYS_F-Ojbo18YQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用<a class="ae lh" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建的照片——来自<a class="ae lh" href="https://angular.io/presskit" rel="noopener ugc nofollow" target="_blank"> Angular新闻包</a>的Angular徽标</p></figure><p id="679a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的<a class="ae lh" href="https://medium.com/better-programming/exploring-web-workers-in-angular-84b9949a4fab" rel="noopener">上一篇文章</a>中，我们谈到了Angular中的web workers。我们介绍了使用这种方法的一些优点和缺点。我们也有机会在一个演示应用程序中看到它们的运行。</p><p id="2545" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将继续研究网络工作者。我们将使用<code class="fe me mf mg mh b">OffscreenCanvas</code> API通过web worker创建一个图表。在此过程中，我们将强调它们的一些局限性，以及我们如何解决它们。</p><p id="e999" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们开始吧！</p><blockquote class="mi mj mk"><p id="edf2" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated"><strong class="lk jd">免责声明:</strong>截至今天，OffscreenCanvas API <a class="ae lh" href="https://caniuse.com/offscreencanvas" rel="noopener ugc nofollow" target="_blank">尚未被所有浏览器支持</a>。</p></blockquote><h1 id="52b9" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">呈现图表</h1><p id="8770" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们将使用<a class="ae lh" href="https://www.chartjs.org/" rel="noopener ugc nofollow" target="_blank"> Chart.js </a>来渲染我们的图表。因此，我们需要通过在终端中运行以下命令来安装相应的包:</p><pre class="ks kt ku kv gt nm mh nn bn no np bi"><span id="666a" class="nq mq it mh b be nr ns l nt nu">npm install chart.js</span></pre><p id="ef9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在演示应用程序中添加了一个新页面。此页面基于通过范围输入元素选择的数字创建图表。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0e93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">分别地，我们有类文件。每当用户更改该值时，就会调用<code class="fe me mf mg mh b">modelChange</code>方法。这个方法将<code class="fe me mf mg mh b">newValue</code>传递给<code class="fe me mf mg mh b">DataService</code>的<code class="fe me mf mg mh b">updateDataLength</code>方法(第13行)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0215" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们没有真正的后端，所以<code class="fe me mf mg mh b">DataService</code>模拟数据生成和从API获取数据。每次调用<code class="fe me mf mg mh b">updateDataLength</code>时，服务都会生成新的数据。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="79fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">回到<code class="fe me mf mg mh b">ChartComponent</code>，我们订阅了这个服务的<code class="fe me mf mg mh b">data$</code> observable。我们在<code class="fe me mf mg mh b">ngAfterViewInit</code>生命周期挂钩方法中这样做。我们将使用生成的数据来做一些事情。</p><p id="c893" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们将看到的，这涉及到使用对DOM元素的引用<code class="fe me mf mg mh b">chartCanvas</code>。我们使用<code class="fe me mf mg mh b"><a class="ae lh" href="https://angular.io/api/core/ViewChild" rel="noopener ugc nofollow" target="_blank">ViewChild</a></code>装饰器查询视图中的元素。但是视图查询是在调用<code class="fe me mf mg mh b">ngAfterViewInit</code>之前设置的，因此是订阅的位置。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="edbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第15行，我们检查web workers是否受支持。如果不是，我们从主线程创建图表。</p><p id="35fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看这是什么样子的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/ecf3fcb79bb6a22134ca79e9de27d81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*k7M0xRPpkXgnIpUZD6MCjA.gif"/></div></div></figure><p id="fd56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">加载图表时，应用程序“冻结”(例如，用户无法导航离开)。网络工作者能对此有所帮助吗？</p><p id="8cd1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们再次回顾一下这个应用程序，这次使用一个web worker。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/1645386b3802918e7c569e35766ee5e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5RtIg0uV_1K1qaXCyA-Xpg.gif"/></div></div></figure><p id="1460" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">网络工作者完成了这项工作。但是现在又出现了一个问题。请注意，当鼠标悬停在图表上时，不再出现标签！</p><h1 id="26aa" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">限制</h1><p id="a317" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">web工作者的一个主要限制是他们不能访问DOM。此外，他们对<code class="fe me mf mg mh b">window</code>对象的方法和属性的访问是有限的。</p><p id="cb19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据他们的<a class="ae lh" href="https://www.chartjs.org/docs/latest/general/performance.html#parallel-rendering-with-web-workers-chromium-only" rel="noopener ugc nofollow" target="_blank">官方文档</a>，在web worker中使用Chart.js时:</p><blockquote class="mi mj mk"><p id="6686" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated">“[…]使用DOM的Chart.js插件(包括任何鼠标交互)可能无法工作。”</p></blockquote><p id="7b00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好消息是我们可以绕过这些限制…但是我们必须做所有的工作。</p><p id="341f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">哇，坏消息是什么？</p><p id="6649" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">坏消息是，所有与DOM相关的事件都不再工作了。调整大小也不行。所以我们必须为我们感兴趣的每一个事件工作。</p><p id="c62c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是首先要做的是！</p><h1 id="1267" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">尽管它们有局限性</h1><p id="ec00" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们如何在web worker内部创建图表呢？</p><p id="aa03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输入<code class="fe me mf mg mh b"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas" rel="noopener ugc nofollow" target="_blank">OffscreenCanvas</a></code>。</p><p id="eb81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们没有将画布本身传递给web worker，而是将画布的渲染控制转移给了<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen" rel="noopener ugc nofollow" target="_blank">。我们创建画布一次，然后使用它的<code class="fe me mf mg mh b">OffscreenCanvas</code> transferable在web worker中执行任何渲染。</a></p><p id="8578" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可以把可传输对象看作是可以传输到不同的JavaScript上下文的对象，比如另一个窗口或工作器。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="73a9" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated">在第16–21行，我们处理画布上的渲染。首先，我们初始化web worker(第17行)并第一次在画布上绘图(第18行)。然后，我们执行任何后续重绘(第20行)。</li><li id="0fcf" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">在第34-40行，第一次抽签发生了。我们创建屏幕外画布(第34行)并将其传递给web worker。我们还将屏幕外的画布作为可转移对象传递(第40行)。</li><li id="b869" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">在第44–46行，我们手动创建一个画布，将它附加到DOM，并返回它的<code class="fe me mf mg mh b">OffscreenCanvas</code>。</li><li id="c791" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">在第50行，我们使用<code class="fe me mf mg mh b">postMessage</code>发送新数据并执行重绘。</li></ul><h2 id="d03c" class="om mq it bd mr on oo dn mv op oq dp mz lr or os nb lv ot ou nd lz ov ow nf iz bi translated"><strong class="ak">工人的实现呢？</strong></h2><p id="ae45" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">到目前为止，web worker的实现如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fd51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们<a class="ae lh" href="https://stackoverflow.com/questions/63795576/using-chart-js-in-web-worker" rel="noopener ugc nofollow" target="_blank">使用</a> <code class="fe me mf mg mh b"><a class="ae lh" href="https://stackoverflow.com/questions/63795576/using-chart-js-in-web-worker" rel="noopener ugc nofollow" target="_blank">importScripts</a></code> <a class="ae lh" href="https://stackoverflow.com/questions/63795576/using-chart-js-in-web-worker" rel="noopener ugc nofollow" target="_blank">来导入chart.js </a>。如果我们试图用通常的语法导入它，我们会得到编译错误。原因是我们前面谈到的DOM限制。我们在之前的文章中也详细解释了这一点。</p><p id="3ee7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单地说，我们向web worker发送定制的事件，并声明一个函数来处理web worker内部的每个事件。</p><p id="1fac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在开始时发送一个<code class="fe me mf mg mh b">firstDraw</code>来初始化画布并创建图表。然后，我们发送<code class="fe me mf mg mh b">redraw</code>事件来销毁之前的图表，并在屏幕外的画布上绘制一个新的图表。</p><h1 id="3cb4" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">添加调整大小事件</h1><p id="aa55" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">在web worker中呈现图表会带来一些副作用。</p><p id="93b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中之一是图表不再响应。如果我们调整浏览器窗口的大小，图表不会随之调整，这可能会有问题。</p><p id="2c7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不要害怕！</p><p id="1822" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以代理resize事件并手动调整图表的大小。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="050b" class="ny nz it lk b ll lm lo lp lr oa lv ob lz oc md od oe of og bi translated">在第16行，我们注册了调整大小事件。</li><li id="f07e" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated">在第23行，我们在<code class="fe me mf mg mh b">window</code>对象上添加了一个事件监听器。每当调整浏览器大小时，我们将事件代理给web worker以相应地调整图表的大小。</li></ul><p id="1714" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的web worker必须能够处理resize事件。我们创建一个<code class="fe me mf mg mh b">resize</code>函数，并将其添加到处理程序中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="efa2" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">添加鼠标事件</h1><p id="0d82" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们之前观察到的另一个副作用是鼠标互动停止了。悬停在图表上时不显示标签。</p><p id="f43c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你知道该怎么做！</p><p id="6bab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以代理鼠标事件，并按照我们认为合适的方式处理它们。我们修改了<code class="fe me mf mg mh b">ChartComponent</code>，更具体地说，是它的<code class="fe me mf mg mh b">createCanvas</code>方法。我们为<code class="fe me mf mg mh b">mousemove</code>、<code class="fe me mf mg mh b">mouseenter</code>和<code class="fe me mf mg mh b">mouseleave</code>事件添加事件监听器。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="10ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在工人端，我们添加各自的处理函数。代码如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="cb11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第3-16行，我们处理<code class="fe me mf mg mh b">mousemove</code>事件。</p><p id="3ceb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们确定x轴上相对于鼠标当前位置最近的条。在我们的例子中，我们有两个数据集。我们<a class="ae lh" href="https://github.com/chartjs/Chart.js/issues/2447#issuecomment-216940741" rel="noopener ugc nofollow" target="_blank">从图表</a>中访问每个数据集的元数据(第7行和第8行)。</p><p id="5d1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我们检查鼠标是否接触到任何附近的条，并以编程方式显示(或隐藏)标签(第9–14行)。</p><p id="87a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<code class="fe me mf mg mh b">mouseenter</code>上，我们启用<code class="fe me mf mg mh b">mousemove</code>事件处理，而在<code class="fe me mf mg mh b">mouseleave</code>上，我们禁用它并关闭任何打开的标签。需要启用/禁用以确保没有标签将保持显示。</p><blockquote class="mi mj mk"><p id="0f20" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated"><strong class="lk jd">免责声明:</strong>这仅仅是我们的自定义实现，适用于本演示的垂直条形图。我们的重点是教你方法，而不是实现。希望你能明白！</p></blockquote><p id="4be5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们不会深入讨论特定于实现的助手函数的细节，比如<code class="fe me mf mg mh b">getNearestElementOfX</code>和<code class="fe me mf mg mh b">getNearestTouched</code>。</p><p id="11a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在GitHub库中找到完整的源代码。</p><p id="73f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">别忘了<a class="ae lh" href="https://vkagklis.medium.com/subscribe" rel="noopener">订阅我的时事通讯</a>来关注更多类似的内容！</p><h1 id="bd06" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">结论</h1><p id="2426" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">本文研究了如何使用web workers在Angular中呈现图表。</p><p id="5301" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在后台呈现图表是可能的，但是会带来一些副作用。这是因为web工作者对DOM的访问权限有限。<br/>我们演示了如何通过将事件代理给web worker来解决这些副作用。但是接下来必须做所有的工作，也就是用他们自己的定制实现来处理这些事件。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="5a80" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢您的阅读。我希望你喜欢这篇文章，并且你学到了一些新的东西。如果有，请考虑通过我的推荐链接注册Medium:</p><div class="pe pf gp gr pg ph"><a href="https://kagklis.medium.com/membership" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd jd gy z fp pm fr fs pn fu fw jc bi translated">通过我的推荐链接加入Medium—kakk lis Vasileios</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">阅读Kagklis Vasileios(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">kagklis.medium.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv lb ph"/></div></div></a></div></div></div>    
</body>
</html>