<html>
<head>
<title>Please Put TypeScript Down for a Moment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">请把打字稿放下一会儿</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/please-put-typescript-down-for-a-moment-103f15378d34?source=collection_archive---------1-----------------------#2020-03-09">https://betterprogramming.pub/please-put-typescript-down-for-a-moment-103f15378d34?source=collection_archive---------1-----------------------#2020-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="06ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在键入JavaScript的时代，有时我们需要后退一步，权衡利弊</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce7513a0cd5ca3ef3850fe84d97baf1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYhljEkzaXBfZUMTO7QlWw.jpeg"/></div></div></figure><p id="766f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我澄清一下:类型化的JavaScript棒极了。我用过Flow，现在和将来都会继续使用TypeScript。这是一个发展迅速的强大工具。</p><p id="c5e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这种力量的代价是什么呢？这些改变游戏规则的工具有什么缺点？</p><p id="f0f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时我们需要把我们的工具放在阳光下，这样我们就能看到它们好的和坏的一面<em class="lq"> </em>。</p><p id="5d2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，请暂时放下8位的火把和干草叉，让我们以开放的心态探索类型化JavaScript的负面影响！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ccf8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">代码很容易变得冗长</h1><p id="90ba" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">正如评论中提到的，我主要从React + Redux的角度来看这个问题。<em class="lq">您的体验在很大程度上取决于您使用的库！</em></p><p id="5738" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般来说，使用TypeScript和Flow的讽刺之处在于，手动键入是我们想要尽可能避免的事情！它会使代码更加冗长，容易出错，并且更难管理。</p><p id="0683" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在理想的情况下，我们让TypeScript从我们的库中以及语言中已经定义的库中推断类型。这样，我们就获得了类型安全的好处，同时只需管理自定义对象类型。</p><p id="a169" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，有时候冗长是无法避免的。让我们看一个用TypeScript编写的简单的基于类的React组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="252c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个普通的基于类的React组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d4b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript版本多了248%的代码。是的，道具和状态都有明确的定义，但是那<em class="lq">真的是我们现在所说的</em>可读吗？</p><p id="1858" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看这个处理redux动作的类型的<a class="ae mx" href="https://dev.to/pretaporter/typescript-and-redux-my-tips-5da9" rel="noopener ugc nofollow" target="_blank">例子。它非常聪明和有用——我强烈推荐阅读它——但是为什么它首先是必要的呢？</a></p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="84ae" class="nd lz it mz b gy ne nf l ng nh">type InferValueTypes&lt;T&gt; = T extends { [key: string]: infer U } ? U : never;<br/><br/>type Actions = ReturnType&lt;InferValueTypes&lt;typeof actions&gt;&gt;</span></pre><p id="1267" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我甚至不会去探究类型化带来的丑陋…</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="652a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">许多库没有类型</h1><p id="91aa" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">虽然类型化的生态系统在增长，但它远没有100%被覆盖。这意味着，在许多情况下，您是手动推出类型的。</p><p id="7485" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，每个大型项目最终都会推出一些邪恶的定制类型(或从GitHub版本中复制它们)来适应一些库或用例。</p><p id="852f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使是像Redux这样最受欢迎的库，管理动作、thunks等也是一个活地狱。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="85d1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">手动编写的类型容易出错</h1><p id="435f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们假设一个大型团队正在进行一个项目。约翰写了下面的类型定义:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="0a4d" class="nd lz it mz b gy ne nf l ng nh">type PropsA = { <br/> name: string, <br/> date: Date, <br/> url: string <br/>}</span></pre><p id="695d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当这个类型定义被创建时，Pablo没有意识到它的存在，所以他创建了一个类似的类型:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="33c5" class="nd lz it mz b gy ne nf l ng nh">type PropsB = { <br/> name: string, <br/> date: string, <br/> url: string <br/>}</span></pre><p id="65db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了多余的类型，更糟糕的是，<code class="fe ni nj nk mz b">PropsB</code>的定义略有不同。清晰类型定义的承诺已经成为过去式。</p><p id="f523" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这不是一个很少发生的假设场景。我在投入数百万美元的大型项目中看到过这种情况。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c51c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">它给人一种虚假的安全感</h1><p id="d055" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">虽然这可能不是最好的方法，但是假设您定义了一个redux操作，如下所示:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="69b1" class="nd lz it mz b gy ne nf l ng nh">export const MY_BASIC_ACTION: ‘MY_BASIC_ACTION’ = ‘MY_BASIC_ACTION’</span></pre><p id="2770" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">处理其中的几个就可以了，但是当您有30个动作类型时，在将旧动作作为新动作的模板进行复制时，很容易出现以下情况:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="e7ac" class="nd lz it mz b gy ne nf l ng nh">export const MY_NEW_ACTION: ‘MY_BASIC_ACTION’ = ‘MY_BASIC_ACTION’</span></pre><p id="8ad7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看到这里的问题了吗？我们刚刚定义了一个新的动作作为第一个动作。</p><p id="fb45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这很难跟踪，因为您将调度<code class="fe ni nj nk mz b">MY_NEW_ACTION</code>，但它实际上会调度<code class="fe ni nj nk mz b">MY_BASIC_ACTION</code>。</p><p id="1644" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Flow/TypeScript的怀抱中，你会感到如此安全和模糊，以至于你可能会用头撞墙几个小时才意识到这是…一个类型问题！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d9e7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">类型管理本身就是一种技能</h1><p id="bd4e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">JavaScript已经很难理解了。当您将类型添加到这样一种动态的、无忧无虑的语言中时，正确且高效地编写类型需要很高的技能。</p><p id="8b79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这并不是避免使用类型化JS的借口，但是对于时间紧迫或者有大量初级开发人员的真实项目来说，这是需要考虑的。</p><p id="32bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大多数时候，您可能正在键入组件属性、状态等。然而，总有一天你不得不做一些有点不靠谱的事情。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="14aa" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">需要管理更多配置</h1><p id="32fe" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">建立一个类型化的生态系统并不是那么简单。您将使用构建工具，管理配置文件，创建更多的依赖项，等等。</p><p id="3ff8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">曾经很容易集成的库现在会将你指向一个单独的部分<em class="lq"> </em>，只是为了让它与TypeScript一起工作。</p><p id="1230" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你将花费更多的时间在GitHub问题中寻找解决方案，试图让Library Z与Flow或TypeScript一起工作。</p><p id="9b8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这真的很让人头疼。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="05ee" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">一个坚固的IDE可能就是你所需要的</h1><p id="9043" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">VSCode中的IntelliSense与林挺工具相结合，提供了开发人员从TypeScript和Flow中寻求的许多好处。</p><p id="68d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">说真的，看看你在IDE的支持下能走多远。我敢打赌，你会惊讶于你对TypeScript的想念是如此之少(但你总是会想念它，至少一点点)。</p><p id="2865" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有类型安全的舒适性的编码给了你JavaScript的全部能力——毕竟，它被设计成松散的类型——并且让你格外注意你写的代码。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9ada" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="d3b5" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一个不用类型编写的项目仍然是可导航的和自文档化的，这是一个真正的成就。看起来我似乎非常讨厌TypeScript，但事实远非如此。我喜欢TypeScript，我知道它的好处。然而，围绕缺点展开对话也很重要。</p><p id="2b25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">毕竟，这是关于在工作中使用最好的工具，对吗？</p></div></div>    
</body>
</html>