<html>
<head>
<title>Demystifying the 0-1 Knapsack Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘0-1背包问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-the-0-1-knapsack-problem-56e7ac4dfcf7?source=collection_archive---------2-----------------------#2020-10-16">https://betterprogramming.pub/demystifying-the-0-1-knapsack-problem-56e7ac4dfcf7?source=collection_archive---------2-----------------------#2020-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0a19" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">顶级解决方案，解释</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/19e23d339cde1469b8d2a7d12399e4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3OBnVDmaPAk__W_7n0cDA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="d9cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在你参加的任何动态编程编码面试中，你都可能会遇到<em class="lr">背包问题。</em>由于解决方案的复杂性和问题变体的数量，这个问题经常让受访者感到焦虑。</p><p id="0e14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将通过探索两种流行的解决方案，让您熟悉多种语言的背包问题:递归解决方案<em class="lr">和自顶向下动态编程算法解决方案</em>和<em class="lr">。到本文结束时，您将拥有自信地解决背包问题所需的经验。</em></p><h2 id="7f61" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">这是我们今天要讲的内容</strong></h2><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="879e" class="ls lt iq mm b gy mq mr l ms mt">1. <a class="ae mu" href="#f51c" rel="noopener ugc nofollow">What's the knapsack problem?</a><br/>2. <a class="ae mu" href="#a374" rel="noopener ugc nofollow">Brute-force recursive solution</a><br/>3. <a class="ae mu" href="#bf21" rel="noopener ugc nofollow">Optimized dynamic programming solution</a><br/>4. <a class="ae mu" href="#88fc" rel="noopener ugc nofollow">What to learn next</a></span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="f51c" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">背包问题是什么？</h1><p id="2721" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">背包问题是计算机科学领域最热门的动态规划面试问题之一。</p><p id="d136" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">问题陈述是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/71c5fe8b9128af25e871f844fd4aa451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4b1qYRRYPnPvOhT5UIYP1g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="c398" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你是一名窃贼，带着一个总重量为<code class="fe nt nu nv mm b">capacity</code>的背包。您有一组项目(<code class="fe nt nu nv mm b">n</code>项目)，每个项目都有固定的重量容量和值。权重和值以整数数组表示。创建一个函数，<code class="fe nt nu nv mm b">knapsack()</code>，找到这些物品的一个子集或数量，使价值最大化，但其总重量不超过给定的数量<code class="fe nt nu nv mm b">capacity</code>。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="45ca" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">背包问题变体</h1><p id="d680" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">这个问题有两个主要的变体:<em class="lr">小数</em>或者<em class="lr"> 0-1。</em>分数变体允许您将物品分开，以最大化包装中的价值。0-1变体不允许您拆分项目。</p><p id="33f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个常见的变种是<em class="lr">约束</em>背包问题，它限制你的程序，所以你不能选择任何项目超过一次。当一个元素被选中时，程序必须决定是把它放入包中还是把它留下。</p><p id="a5c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在高层面试中，你会遇到将音量作为约束属性的变体。在这种情况下，每个物品也有固定的体积，背包有体积限制。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="d1b2" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">它考什么技能？</h1><p id="e2d9" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">这个问题之所以如此流行，是因为它同时测试了许多想要的技能，并且可以改变，让面试者失去平衡。换句话说，你必须真正理解问题和代码的逻辑。简单的记忆不会让你走得太远。</p><p id="2583" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">背包问题的最优解总是一个动态规划解。面试官可以用这个问题来测试你的动态编程技能，看看你是否在为一个优化的解决方案而工作。</p><p id="11b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">背包问题的另一个流行的解决方案是使用递归。如果面试官重视这两种技能，他们可能会要求你给出一个递归和动态的解决方案。这是一个受欢迎的选择，因为面试官可以看到你从递归到动态解决方案的转变有多好。</p><p id="414c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">背包问题也测试你如何处理组合优化问题。这在工作场所有许多实际应用，因为所有组合优化问题都在约束条件下寻求最大利益。</p><p id="32d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，组合优化用于以下解决方案:</p><ul class=""><li id="ada2" class="nw nx iq kx b ky kz lb lc le ny li nz lm oa lq ob oc od oe bi translated">确定在有限资源云系统上运行的最佳程序</li><li id="e0b9" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">优化固定管网中的水分配</li><li id="5c00" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">自动规划最佳包裹递送路线</li><li id="f080" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">优化公司的供应链</li></ul><p id="9b92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">任何管理或创建自动化优化软件的角色都会被问到这个问题。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="a374" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">强力递归解决方案</h1><p id="f677" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">这个问题最明显的解决方案是强力递归。这种解决方案是蛮力的，因为它评估所有可能子集的总权重和值，然后选择仍低于权重限制的具有最高值的子集。</p><p id="48f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这是一个有效的解决方案，但它不是最优的，因为时间复杂度是指数级的。如果要求您使用递归方法，请使用这个解决方案。它也可以是动态解决方案的良好起点。</p><p id="a29c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">时间复杂度:</strong>o(2^{n})<em class="lr">o</em>(2<em class="lr">n</em>)，由于子呼叫重叠的呼叫数量</p><p id="7dce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">辅助空间:</strong> O(1) <em class="lr"> O </em> (1)，不需要额外存储</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="4c7a" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">解决办法</h1><p id="7dc7" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">这是我们算法的可视化表示。</p><p id="27a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>所有红色项目子集超过我们包的容量；浅绿色在容量范围内，但不是最高值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/24d668c06d104e2e3b93d24c5613b89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvpCzvWCSHRRPdALmuXu0g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">背包暴力递归</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/8875007b5db27d0c4fa484ee6453da2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3g6sdkm2KnLWjtcqlMiIA.png"/></div></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="e51d" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">说明</h1><p id="cf7a" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">在第14行，我们从重量数组的开头开始，检查该物品是否在最大容量内。如果是，我们用这个项目递归调用<code class="fe nt nu nv mm b">knapsack()</code>函数，并将结果保存在<code class="fe nt nu nv mm b">profit1</code>中。</p><p id="1960" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们递归调用函数，排除该项，并将结果保存在<code class="fe nt nu nv mm b">profit2</code>变量中。在第21行，我们返回了<code class="fe nt nu nv mm b">profit1</code>和<code class="fe nt nu nv mm b">profit2</code>中较大的一个。</p><h2 id="fe78" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">伪代码</strong></h2><p id="4229" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">下面是这个程序如何运行的伪代码解释。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="0763" class="ls lt iq mm b gy mq mr l ms mt">for each item 'i' starting from the end<br/>  create a new set which INCLUDES item 'i' if the total weight does not exceed the capacity, and recursively process the remaining capacity and items<br/>  create a new set WITHOUT item 'i', and recursively process the remaining items <br/> <br/>return the set from the above two sets with higher profit</span></pre><p id="72f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个程序包含许多重叠的子问题，但是它们每次都被计算，而不是被存储。重复计算大大增加了运行时间。为了避免重新计算，我们可以使用动态编程来记忆子问题的解决方案以便重用。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="bf21" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">优化的动态规划解决方案</h1><p id="c094" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">现在，我们将通过添加自顶向下的动态编程来处理重叠的子问题，从而优化我们的递归解决方案。</p><p id="2af4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们的递归函数<code class="fe nt nu nv mm b">knapsackRecursive()</code>中有两个变化的值(<code class="fe nt nu nv mm b">capacity</code>和<code class="fe nt nu nv mm b">currentIndex</code>)，所以我们可以使用一个二维数组来存储所有已解决子问题的结果。如上所述，我们需要存储每个子数组(即，每个可能的索引<code class="fe nt nu nv mm b">i</code>)和每个可能的容量<code class="fe nt nu nv mm b">c</code>的结果。</p><p id="ea27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是背包问题在时间和空间复杂度上的最优解。</p><h2 id="4ee0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">时间复杂度</strong></h2><p id="a2bc" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">O(N * C)<em class="lr">O</em>(<em class="lr">N</em>∫<em class="lr">C</em>):我们的记忆表存储所有子问题的结果，最多有N * C<em class="lr">N</em>∫<em class="lr">C</em>个子问题。</p><h2 id="a34e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">辅助空间</strong></h2><p id="d965" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">O(N * C+N)<em class="lr">O</em>(<em class="lr">N</em>∫<em class="lr">C</em>+<em class="lr">N</em>)，O(N * C)<em class="lr">O</em>(<em class="lr">N</em>∫<em class="lr">C</em>)内存化表空间和O(N) <em class="lr"> O </em> ( <em class="lr"> N </em>)递归调用栈空间</p><p id="5540" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">小贴士:</strong>在面试中，确保和面试官谈谈你的思考过程，这样他们就能看到你解决问题的能力。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="24e9" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">解决办法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/ee22001e109414657ea00d721c26db4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUbDTle-uPoqvQZtDtGn9A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">记忆化动态规划的可视化</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/bee9b08ab24370f60a929694fcf9de02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBjOpWvtK59bXVXsB2T4Qw.png"/></div></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="1539" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">说明</h1><p id="d68b" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">实现动态编程，只需要改五行。</p><p id="e976" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第9行，我们创建了一个二维数组<code class="fe nt nu nv mm b">dp</code>，用来保存任何已解决子问题的结果。这允许我们以后使用这些记忆解决方案，而不是重新计算答案。</p><p id="cc79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第22行和第23行，我们创建了一个案例来检查<code class="fe nt nu nv mm b">dp</code>是否已经找到了当前子问题的解决方案。如果我们有了它，我们返回记忆解，然后继续下一个子问题。</p><p id="a72b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第38行，如果我们在<code class="fe nt nu nv mm b">profit1</code>中包含当前物品，我们将计算行李的最大可能价值，如果我们在<code class="fe nt nu nv mm b">profit2</code>中排除当前物品，我们将计算行李的最大价值。然后，我们将其中较高的值保存在我们的二维数组中，<code class="fe nt nu nv mm b">dp</code>。</p><p id="d951" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第39行，我们返回背包值最高的物品。这是在下一个递归调用开始之前结束一个递归调用的部分结果。一旦所有可能的组合都出现这种情况，第一次调用将返回实际结果。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="88fc" class="nc lt iq bd lu nd ne nf lx ng nh ni ma jw nj jx md jz nk ka mg kc nl kd mj nm bi translated">接下来学什么</h1><p id="3331" class="pw-post-body-paragraph kv kw iq kx b ky nn jr la lb no ju ld le np lg lh li nq lk ll lm nr lo lp lq ij bi translated">感谢您完成对0-1背包问题的深入研究。对动态编程编码面试问题的信心来自实践和对流行问题变体的接触。</p><p id="4f57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当你准备下一次编码面试时，这里有一些你想研究的DP问题:</p><ul class=""><li id="e031" class="nw nx iq kx b ky kz lb lc le ny li nz lm oa lq ob oc od oe bi translated">最长公共子串问题</li><li id="5563" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">回文子序列问题</li><li id="ffeb" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">斐波那契数问题</li><li id="29a8" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">楼梯问题</li><li id="563c" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">硬币兑换问题</li></ul><p id="3438" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">面试愉快！</p></div></div>    
</body>
</html>