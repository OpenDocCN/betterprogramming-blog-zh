<html>
<head>
<title>How to and When to Use Pattern Matching in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以及何时在Ruby中使用模式匹配</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-and-when-to-use-pattern-matching-in-ruby-a13553b28559?source=collection_archive---------19-----------------------#2022-01-26">https://betterprogramming.pub/how-to-and-when-to-use-pattern-matching-in-ruby-a13553b28559?source=collection_archive---------19-----------------------#2022-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="454a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">模式匹配让我们编写易于维护和推理的声明性代码。让我们看看如何在Ruby中使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/492e22d3a1ec018956217050d6cd5cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dKAJdRi-wKJoT2U8.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jjying?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae ky" href="https://unsplash.com/s/photos/pattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ruby最近增加的一个重要特性是模式匹配。Ruby 2.7中已经添加了模式匹配功能，并在此后得到了改进。</p><p id="88af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多人都在谈论Ruby的新版本，但却没有太多关于模式匹配的内容，这在我看来是一个遗憾，因为这为我们的选择增加了如此之多。所以，让我们改变这一点。</p><p id="c871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博文中，我们将讨论<em class="lv">什么是</em>模式匹配，<em class="lv">何时可以使用</em>，并且我们还将做一个小的基准测试，将它与类似的<code class="fe lw lx ly lz b">if</code>语句进行比较。</p><h1 id="a159" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">什么是模式匹配</h1><p id="e794" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在维基百科中，模式匹配被解释为“检查一个给定的记号序列是否存在某种模式的组成部分的行为”。对我来说，这并不能解释很多，所以让我们看一个实际的例子。</p><p id="17f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于包括我在内的许多Rubyist来说，模式匹配是随着<a class="ae ky" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank">药剂</a>的出现而为人所知的。借助这一功能，Elixir能够重载函数。</p><p id="476c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，一个函数非常小，只能处理另一个函数处理另一个输入参数的情况。它还使得编写可读性很强的代码来处理错误情况成为可能。这看起来怎么样？让我们来看一个重载函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="77a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe lw lx ly lz b">valid_password?</code>的参数被解构并进行模式匹配。BEAM(运行Elixir的VM)检查参数的形式，然后调用正确的函数。所以，如果自变量是一个映射，并且有键<code class="fe lw lx ly lz b">hashed_password</code>，那么第一个函数被调用，否则调用另一个。</p><p id="62d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elxir中的错误处理看起来如何？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a6a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，函数<code class="fe lw lx ly lz b">update_company</code>返回一个元组，第一个条目是一个<code class="fe lw lx ly lz b">:ok</code>或<code class="fe lw lx ly lz b">:error</code>原子。根据这一点，运行时将执行case语句的分支。这使得编写只关心一件事情而另一个分支关心其他事情的代码变得容易。</p><p id="ded3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些例子清楚地说明了什么是模式匹配，并展示了代码质量如何从中受益。那么，Ruby中的模式匹配是什么样子的呢？</p><h1 id="bb25" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">Ruby中的模式匹配</h1><p id="724a" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">首先，让我们看看Ruby中模式匹配的一般语法是怎样的:</p><pre class="kj kk kl km gt mz lz na nb aw nc bi"><span id="dd27" class="nd mb it lz b gy ne nf l ng nh">case &lt;expression&gt;<br/>  in &lt;pattern1&gt; <br/>    ... <br/>  in &lt;pattern2&gt; <br/>    ... <br/>  in &lt;pattern3&gt; <br/>    ... <br/>  else <br/>    ... <br/>end</span></pre><p id="2ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以对任何表达式进行模式匹配，在Ruby中很多都是这样。所以，我们可以调用一个方法，写一个<code class="fe lw lx ly lz b">if</code>语句或者只是放入一个变量。<br/>现在让我们做一点实验，看看我们能做些什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用模式匹配而不是一个<code class="fe lw lx ly lz b">if</code>语句，我们并没有赢很多。让我们做一些更有用的事情，从数据结构中提取一个值，并将其放入一个变量中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="401a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们不必指定散列中的所有键，而只指定我们感兴趣的键。同样，通过<code class="fe lw lx ly lz b">*</code>,我们告诉Ruby数组中可能有更多的对象，但是我们真的不关心它们。</p><p id="ad9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用If语句将这个值提取到一个变量中并处理一个错误，代码看起来会更混乱:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b05b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模式匹配版本不仅节省了我们编写几行代码的时间，而且可读性更好，因此更易于维护。</p><p id="af67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这真的很棒，向我们展示了一个很好的用例:从数据结构中提取一些东西，例如，解构一个对象。但是模式匹配可以做得更多！</p><p id="8571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，我们评估的第一个表达式也可以是方法调用。这样我们<em class="lv">就可以</em>实现一个错误处理，就像我们在Elixir中所做的那样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e4be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们可以用这种方式实现错误处理，但这不是惯用的Ruby。因此，标准库以不同的方式处理错误，我们必须自己对重要的类/方法进行包装。</p><p id="2137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，处理我们的业务逻辑中的错误可能是一个好的选择，这必须由个人决定。但是说实话，我会使用其他的东西，比如<code class="fe lw lx ly lz b">dry-rb</code>单子——它在模式匹配方面做得很好。关于如何用单子实现错误处理的一个很棒的帖子可以在<a class="ae ky" href="https://hanamimastery.com/episodes/7-untangle-your-app-with-dry-monads" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="18b6" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">野外模式匹配</h1><p id="f781" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">有一个gem套件广泛使用模式匹配，即<a class="ae ky" href="https://dry-rb.org" rel="noopener ugc nofollow" target="_blank"> dry-rb </a> gems。</p><p id="814d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe lw lx ly lz b">dry-validation</code> gem可以在成功验证时进行模式匹配，如下所示(直接取自文档):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用一个<code class="fe lw lx ly lz b">if</code>语句作为模式匹配的表达式。当你看一看<code class="fe lw lx ly lz b">dry-rb</code>文档时，你会发现使用这个优秀库的模式匹配的其他方法。</p><h1 id="9313" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">基准模式匹配与if语句</h1><p id="c5d7" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">与命令式搜索相比，这种模式匹配有多快？让我们来了解一下！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><pre class="kj kk kl km gt mz lz na nb aw nc bi"><span id="5fe7" class="nd mb it lz b gy ne nf l ng nh">Warming up --------------------------------------<br/>   pattern matching:    99.516k i/100ms<br/>  imperative search:   134.871k i/100ms<br/>Calculating -------------------------------------<br/>   pattern matching:    969.440k (± 0.9%) i/s -      9.753M in  10.060889s<br/>  imperative search:      1.319M (± 1.0%) i/s -     13.217M in  10.024136s</span><span id="72e9" class="nd mb it lz b gy ni nf l ng nh">Comparison: <br/>  imperative search::  1318684.6 i/s<br/>   pattern matching::   969439.8 i/s - 1.36x  (± 0.00) slower</span></pre><p id="a0b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，模式匹配仍然比强制搜索慢得多。但是我们不应该使用这个伟大的功能吗？绝对不行！</p><p id="88a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们只在一个不是紧循环的地方使用这个，不反复运行的时候，区别对我们来说就不重要了。但是可维护的仍然存在，所以我们应该在那时使用它。</p><h1 id="c6d7" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">Ruby模式匹配的未来</h1><p id="4f7e" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">Ruby中模式匹配的故事还没有结束。最近，我看到了来自Koichi Sasada 的<a class="ae ky" href="https://twitter.com/_ko1/status/1458614945608732677?t=7arc8NSzL0fL-lNOd4Z85g&amp;s=09" rel="noopener ugc nofollow" target="_blank">推文，其中他暗示了一种可能的模式匹配重载方法。没有证实会发生这种情况，但它在我看来真的很有趣！</a></p><p id="f5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，模式匹配是我们工具箱中一个非常强大的工具。我们可以编写非常具有声明性的可维护代码。性能很好，但是也许不应该在紧密循环中使用，因为<em class="lv">需要付出一点点性能代价。</em></p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="843b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">不是中等会员？</em> <a class="ae ky" href="https://grnt-grdwhl.medium.com/membership" rel="noopener"> <em class="lv">在这里报名</em> </a> <em class="lv">并支持我的写作过程！</em></p></div></div>    
</body>
</html>