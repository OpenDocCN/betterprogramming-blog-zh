<html>
<head>
<title>Multi-threaded Application With Simple Apache Kafka Consumers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有简单Apache Kafka消费者的多线程应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/multi-threaded-application-with-simple-apache-kafka-consumers-3d331998cec4?source=collection_archive---------1-----------------------#2022-02-03">https://betterprogramming.pub/multi-threaded-application-with-simple-apache-kafka-consumers-3d331998cec4?source=collection_archive---------1-----------------------#2022-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a045" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Kotlin中的代码示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/92a2991fcdbbaca11ff345cef59286f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0a-jFDVcXKI3VQRh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弗朗西斯科·德·诺瓦在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="242c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何Kafka的新工程师第一次尝试做比简单的快速阅读过程-编写更复杂的事情时，他们不可避免地需要解决这样一个事实，即<em class="ls"> KafkaConsumer </em>不是线程安全的(参见<a class="ae kv" href="https://kafka.apache.org/31/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html" rel="noopener ugc nofollow" target="_blank"> doc </a>)。</p><p id="708a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kafka的架构方式自然会迫使你通过在一个群体中增加更多的消费者来进行横向扩展。在Kafka中，一个主题中的所有记录都被分组到分区中，分区可以独立地写入和读取，而不会影响数据的质量。</p><p id="6536" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们想要更高的处理能力，我们需要更多的分区，并且一个组中至少有同样多的消费者订阅该主题，其中每个消费者是一个单独的线程。(消费者的数量可以大于或等于分区的数量，任何多余的消费者将只是袖手旁观，以防其他消费者中的一个崩溃。)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/16ef5a7f040e21a43b48b4600ae1f1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKZmAlTFtK7Q4ahqxqUomA.png"/></div></div></figure><p id="fe3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过这不是我们将要讨论的多线程。每消费者线程模型是比较容易的。然而，它是基于这样的假设，即大多数用例在记录被消费后会涉及一个简单而快速的处理步骤。在现实生活中，有时我们需要做的不仅仅是给消息添加一两个字段，我们可能需要做一些I/O操作、复杂的计算、调用第三方API，或者与应用程序的其他部分协调。</p><p id="3257" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们需要定制一些东西来解决库的限制。像任何其他工程问题一样，我们想到的第一个方法不是我们想要最终得到什么，而是让我们从它开始，遵循自然的进程。</p><h1 id="b11a" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">方法1 —只使用标志(废话..)</h1><p id="5adc" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">假设我们有一个消费者需要在结束交易时得到通知。当然，我们添加一个简单的标志并在循环中检查它，对吗？</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="8afb" class="mw lv iq ms b gy mx my l mz na">...<br/>private final closed = new AtomicBoolean(false);<br/>...</span><span id="362f" class="mw lv iq ms b gy nb my l mz na">// this runs in a separate thread than the main <br/>try {<br/>   consumer.subscribe(Arrays.asList("topic"));<br/>   while (!closed.get()) {<br/>      val records = consumer.poll(Duration.ofSeconds(1));<br/>      // processing..<br/>   }<br/>} catch (e: Exception) {<br/>   // Ignore exception if closing<br/>   if (!closed.get()) throw e;<br/>} finally {<br/>   consumer.close();<br/>}</span></pre><p id="343b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，假设我们使用的应用程序需要在提交前成功完成处理，因此我们关闭了自动提交，并手动控制它。</p><p id="ff0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，最重要的是，我们需要使用来自另一个主题的数据来处理来自一个主题的数据，或者将这些数据发送给第三方API进行转换，然后我们需要等待结果返回。</p><p id="bcad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们手上的任务很重，我们继续…自然地添加更多的旗帜。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="7215" class="mw lv iq ms b gy mx my l mz na">...<br/>private final closed = new AtomicBoolean(false);<br/>private final readyToCommit = new AtomicBoolean(false);<br/>...</span><span id="7e74" class="mw lv iq ms b gy nb my l mz na">try {<br/>   consumer.subscribe(Arrays.asList("topic"));<br/>   while (!closed.get()) {<br/>      val records = consumer.poll(Duration.ofSeconds(1));<br/>      // start processing in another thread - call API, stitch data from this topic with another etc..<br/>     while (!readyToCommit.get()) {<br/>      // idle loop?,  maybe add Thread.sleep() or delay()<br/>     }<br/>     <br/>   }<br/>} catch (e: Exception) {<br/>   // Ignore exception if closing<br/>   if (!closed.get()) throw e;<br/>} finally {<br/>   consumer.close();<br/>}</span></pre><p id="7ed6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那看起来不太好，是吗？如果我们和其他线程有更多的接触点呢？如果有一个事件需要暂停，将<strong class="ky ir"/><strong class="ky ir"/>状态或间歇状态写入一个文件，或者甚至可能关闭消费者但不停止线程以允许它稍后重新加入另一个事件，该怎么办？这将意味着更多的旗帜，更多的错误空间。</p><p id="3550" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想我们都同意使用普通的布尔值来导航这不是最佳的和可伸缩的。让我们进入下一个选项。</p><h1 id="5c35" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">方法2 —将标志转变为状态机</h1><p id="e2eb" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">那样会更好吗？如果操作得当，这将为您提供单点控制、访问和故障。这将使代码更易读，错误处理更容易，调试更容易忍受(多线程永远不会)。</p><p id="0587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将考虑以下状态:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="5505" class="mw lv iq ms b gy mx my l mz na">enum class State {<br/>   SUBSCRIBING,<br/>   CONSUMING<br/>   PAUSING,<br/>   PAUSED,<br/>   RESUMING,<br/>   CLOSING<br/>   CLOSED,<br/>   TERMINATING,<br/>   IN_ERROR;</span><span id="0290" class="mw lv iq ms b gy nb my l mz na">   fun isHealthy(): Boolean {<br/>      return this != IN_ERROR<br/>   }  </span><span id="5254" class="mw lv iq ms b gy nb my l mz na">   fun shouldRun(): Boolean {<br/>      return this != TERMINATING<br/>   }     <br/>}</span></pre><p id="5e9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义清晰而严密的规则是很重要的，比如什么转换是有效的，什么在多线程的情况下可能发生但可以接受，什么是问题的标志，即什么是正常的流程，什么会被认为是警告，以及什么会引发警报。</p><p id="4f25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于上述状态，我们可以同意以下流程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b320aba52a32b3680eb4555f161f95f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*oOj8KMK9SsD4Gm1lDIitFg.png"/></div></figure><p id="c789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以转化为状态机本身的一组规则，类似于:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="3b68" class="mw lv iq ms b gy mx my l mz na">class StateMachine {<br/>    companion object {<br/>       private val rules = mapOf(<br/>          <strong class="ms ir">SUBSCRIBING</strong> to Predicate&lt;State&gt; { it == RESUMING || it == CLOSED },<br/>          <strong class="ms ir">CONSUMING</strong> to Predicate&lt;State&gt; { it == SUBSCRIBING },<br/>          <strong class="ms ir">PAUSING </strong>to Predicate&lt;State&gt; { it == CONSUMING },<br/>          <strong class="ms ir">PAUSED</strong> to Predicate&lt;State&gt; { it == PAUSING },<br/>          <strong class="ms ir">RESUMING </strong>to Predicate&lt;State&gt; { it == PAUSED },<br/>          <strong class="ms ir">CLOSING </strong>to Predicate&lt;State&gt; { it == CONSUMING },<br/>          <strong class="ms ir">CLOSED </strong>to Predicate&lt;State&gt; { it == CLOSING },<br/>          <strong class="ms ir">TERMINATING </strong>to Predicate&lt;State&gt; { it == SUBSCRIBING ||<br/>   it == CONSUMING || it == PAUSING || it == PAUSED || it == RESUMING || it == CLOSING || it == CLOSED || it == IN_ERROR }<br/>          <strong class="ms ir">IN_ERROR </strong>to Predicate&lt;State&gt; { it == SUBSCRIBING ||<br/>   it == CONSUMING || it == PAUSING || it == PAUSED || it == RESUMING || it == CLOSING || it == CLOSED }  <br/>        )</span><span id="bc53" class="mw lv iq ms b gy nb my l mz na">        fun transitionRuleFor(state: State) {<br/>           return rules[state]|| <br/>       }<br/>    }</span><span id="9cee" class="mw lv iq ms b gy nb my l mz na">    private val state = AtomicReference(State.CLOSED)</span><span id="0761" class="mw lv iq ms b gy nb my l mz na">    fun transitionTo(newState: State){<br/>         state.getAndUpdate{<br/>            if(transitionRuleFor(newState).test(oldState)) {<br/>               newState <br/>            } else {<br/>               // handle invalid transitions...<br/>             }<br/>         }<br/>    } </span><span id="6a0c" class="mw lv iq ms b gy nb my l mz na">}</span></pre><p id="9459" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用上述方法，使用者线程的while循环可以修改如下:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1265" class="mw lv iq ms b gy mx my l mz na">...<br/>val state = AtomicReference&lt;StateMachine&gt;(StateMachine())<br/>...</span><span id="28a4" class="mw lv iq ms b gy nb my l mz na">while (state.get().shouldRun()) {<br/>   when(state.get()) {<br/>     SUBSCRIBING -&gt; subscribe()<br/>     CONSUMING -&gt; processRecords()<br/>     PAUSING -&gt; pause()<br/>     PAUSED -&gt; doNothing() //well almost, will discuss later <br/>     RESUMING -&gt; resume()<br/>     CLOSING -&gt; close()<br/>     CLOSED -&gt; doNothing() //maybe add delays if right for the app<br/>     IN_ERROR - &gt; logAndAlert() // any other error handling and either break or attempt a recovery<br/>   }<br/>}</span><span id="727a" class="mw lv iq ms b gy nb my l mz na">// handle successful termination like app TERM on deploy or else</span></pre><p id="50fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">when表达式中调用的各个方法应该处理可能的异常和到下一个状态的转换。</p><p id="c679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码应该位于一个包装实际KafkaConsumer实例的类中，并作为一个单独的协程启动。对于一个有一个或多个消费者的群体来说，这同样适用。</p><h1 id="1844" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">方法3——使用参与者..在状态机的顶部</h1><p id="c018" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">如果使用者类仅从一个其他线程获得事件通知，或者管理器使用发送并忘记策略向多个使用者类发送通知，方法2就足够了。</p><p id="53ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果多线程可以作为需要顺序处理的通知的来源，或者消费者需要向经理发送反馈，那么我们需要卷起袖子，使用更复杂的东西。根据我们处理的是第一种还是第二种情况，我们可能需要仅在管理者端或消费者端实现。</p><p id="949f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，除了State类之外，我们还需要创建一个将通过通道发送的消息类的层次结构。我们可以有一个由管理器使用的<em class="ls"> ControlMessage </em>类来控制消费者类的工作流，还有一个由消费者类使用的<em class="ls"> FeedbackMessage </em>类来通知管理器所请求的操作已经完成或者发生了错误。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="cf51" class="mw lv iq ms b gy mx my l mz na">sealed class Message {<br/>   sealed class ControlMessage: Message() {<br/>      class SubscribeMessage(topics: List&lt;String&gt;): ControlMessage()<br/>      object CloseMessage: ControlMessage()<br/>      object PauseMessage: ControlMessage()<br/>      object ResumeMessage: ControlMessage()<br/>      object TerminateMessage: ControlMessage()<br/>   }</span><span id="c8cb" class="mw lv iq ms b gy nb my l mz na">sealed class FeedbackMessage(consumer: Consumer): Message() {<br/>      class SubscribedMessage(c: Consumer): FeedbackMessage(c)<br/>      class ClosedMessage(c: Consumer): FeedbackMessage(c)<br/>      class PausedMessage(c: Consumer): FeedbackMessage(c)<br/>      class ConsumingMessage(c: Consumer): FeedbackMessage(c)<br/>      class TerminatedMessage(c: Consumer): FeedbackMessage(c)<br/>      class InErrorMessage(c: Consumer, e: Exception): FeedbackMessage(c)<br/>   }<br/>}</span></pre><p id="7b10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们需要不止一个实现，如上所述，最好有一个创建通道的工厂。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="58a2" class="mw lv iq ms b gy mx my l mz na">class ChannelFactory {<br/>   fun createChannel(consumer: Consumer&lt;Message&gt;): SendChannel&lt;Message&gt; {<br/>      return object: CoroutineScope {<br/>         override val coroutineContext = Dispatchers.Unconfined + Job()<br/>         val channel = actor&lt;Message&gt; {<br/>            for(message in channel) {<br/>                consumer.accept(message)<br/>            }<br/>         }<br/>       }.channel<br/>   }<br/>}</span></pre><p id="621a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于消费者类，通道中的消息处理将如下所示(类似于经理类，但具有FeedbackMessage层次结构)。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="6d65" class="mw lv iq ms b gy mx my l mz na">val consumer = Consumer&lt;Message&gt; { message -&gt;<br/>   when (message) {<br/>       is SubscribeMessage -&gt; subscribe(message.topics)<br/>       is CloseMessage -&gt; close()<br/>       is PauseMessage -&gt; pause()<br/>       is ResumeMessage -&gt; resume()<br/>       is TerminateMessage -&gt; terminate()<br/>    }<br/>}</span><span id="fb57" class="mw lv iq ms b gy nb my l mz na">val channel = channelFactory.createChannel(consumer)</span></pre><p id="6b40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里棘手的一点是在发送任何消息之前对其进行初始化，因为消费者类需要访问管理器的通道来发送反馈，反之亦然——管理器需要访问消费者类的通道。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="3b0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你关注了我们讨论的场景，你可能已经有一些问题了。其中一个可能是——你如何防止消费者在长时间没有提交并且心跳发送到卡夫卡的情况下被踢出群体？</p><p id="547a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在解决这个问题之前，我们需要了解三种kafka消费者配置:</p><ul class=""><li id="cf5e" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated"><code class="fe nt nu nv ms b">session.timeout.ms</code> —定义代理在认为客户端不活动之前等待的最长时间。之后，客户端从组中删除，并触发重新平衡。<strong class="ky ir">默认值为45s </strong>，但是任何值都应该在<code class="fe nt nu nv ms b">group.min.session.timeout.ms</code> <em class="ls"> </em>和<code class="fe nt nu nv ms b">group.max.session.timeout.ms</code> <em class="ls">、</em>之间，这些都是代理端的配置。</li><li id="503d" class="nk nl iq ky b kz nw lc nx lf ny lj nz ln oa lr np nq nr ns bi translated"><code class="fe nt nu nv ms b">heartbeat.inteval.ms</code>—定义预期发送心跳的频率。默认值为3s <strong class="ky ir"> </strong>，但任何值都应低于<code class="fe nt nu nv ms b">session.timeout.ms</code>且不高于其1/3。</li><li id="ec69" class="nk nl iq ky b kz nw lc nx lf ny lj nz ln oa lr np nq nr ns bi translated"><code class="fe nt nu nv ms b">max.poll.interval.ms</code>—定义调用<code class="fe nt nu nv ms b">poll()</code>之间的最大延迟。如果在这段时间后没有轮询到新记录，则认为消费者失败，并触发重新平衡，以便将分区重新分配给组中的另一个成员。默认值为5分钟。对于使用非空的<code class="fe nt nu nv ms b">group.instance.id</code>的用户，当超时到达时，分区不会立即被重新分配，而是在<code class="fe nt nu nv ms b">session.timeout.ms</code>到期后才被重新分配。这反映了已经关闭的静态消费者的行为。</li></ul><p id="6923" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，基本上心跳必须每隔<code class="fe nt nu nv ms b">heartbeat.interval.ms </code>发送一次，否则在<code class="fe nt nu nv ms b">session.timeout.ms</code>之后，代理认为客户端已经死亡，并将其踢出，重新平衡，然后继续前进。</p><p id="3841" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了Java库，有一个线程在后台为您处理这个问题，但是只有当您在<code class="fe nt nu nv ms b">max.poll.interval.ms</code>中轮询时，也就是说，只要处理速度很快，新记录轮询的频率足够高，心跳根本就不用担心。</p><p id="56fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，上面的场景假设长时间运行的复杂处理可能会超过5分钟的超时时间。</p><p id="9966" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一些显而易见的解决方案，比如优化代码或增加配置时间。然而，前者可能是不可能的或不够的，而后者是相当危险的，因为它会阻止我们足够快地发现故障。</p><p id="ba63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，我们还说过，在提交之前，我们需要确保处理已经成功完成。所以，我们需要另一种选择。</p><p id="d002" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好消息是，我们已经完成了一半——我们有一个暂停状态和/或暂停消息。解决方案是在一个单独的线程中执行长时间运行的处理任务时暂停。暂停时，在消费者线程中，保持安全轮询(并保持发送心跳),实际上不会返回任何记录。是的，这增加了一个线程，但它是值得的。</p><p id="d44e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们的第二种状态机方法的结果是:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="ad7a" class="mw lv iq ms b gy mx my l mz na">...<br/>while (state.get().shouldRun()) {<br/>   when(state.get()) {<br/>     ...<br/>     CONSUMING -&gt; pollStartThreadToProcessAndSetToPausing()<br/>     PAUSING -&gt; pause()<br/>     PAUSED -&gt; keepPollingAndVerifyNothingPolled()  <br/>     ...<br/>   }<br/>}<br/>...</span></pre><p id="a6c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，记录可以被缓冲，直到管理器暂停以开始长时间运行的处理。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="4931" class="mw lv iq ms b gy mx my l mz na">...<br/>while (state.get().shouldRun()) {<br/>   when(state.get()) {<br/>     ...<br/>     CONSUMING -&gt; pollAndBufferRawOrTransformedRecords()<br/>     PAUSING -&gt; pauseAndStartThreadForProcessing() <br/>     PAUSED -&gt; keepPollingAndVerifyNothingPolled()  <br/>     ...<br/>   }<br/>}<br/>...</span></pre><p id="aade" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在它的上面有actor层，对它的改变是容易的，因为繁重的负载是由状态机部分完成的，我们只需要通知消费者类它需要移动到的状态(注意，这只适用于缓冲的情况)。</p><p id="06bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这不是很有趣吗？让我知道你是否尝试过，以及你觉得有多容易或多难。你遇到了什么问题？</p><p id="5f0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p></div></div>    
</body>
</html>