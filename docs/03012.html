<html>
<head>
<title>Kotlin Coroutines, From the Basic to the Advanced</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林协程，从基础到高级</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006?source=collection_archive---------2-----------------------#2020-01-15">https://betterprogramming.pub/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006?source=collection_archive---------2-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee22" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">是时候了:协程在这里</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/191b5b51b805b4f662a4c2a96fd199cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viCg1oZ9qxlpL4CQxWaVfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:Siva Ganesh Kantamani</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="078c" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">1.为什么我们需要协程？</h1><p id="2b93" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">假设您必须从服务器的列表中获取一批客户。您必须进行服务调用来获取数据并在<code class="fe mt mu mv mw b">RecyclerView</code>中显示它们。</p><p id="8883" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">假设您有一个从服务器获取数据的函数<code class="fe mt mu mv mw b">fetchCustomers()</code> <strong class="lz iu"> </strong>，如下所示。</p><pre class="kj kk kl km gt nc mw nd ne aw nf bi"><span id="9d49" class="ng lg it mw b gy nh ni l nj nk">fun fetchCustomers(){<br/>     val array = <strong class="mw iu">api.fetchCustomersList</strong>()<br/>     updateUI(array)<br/>}</span></pre><p id="f124" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">如果你这样做，当你在主线程上操作时，你的应用程序将会崩溃。您可能会找到一种替代方法，通过在线程中包装来调用它。下一个问题是生命周期管理。所以您将切换到带有订阅和取消的回调来解决这个问题。很快你就会像下面这样结束。</p><pre class="kj kk kl km gt nc mw nd ne aw nf bi"><span id="f517" class="ng lg it mw b gy nh ni l nj nk">fun onDestroy(){<br/>    <strong class="mw iu">subscription1</strong>.cancel()<br/>    <strong class="mw iu">subscription2</strong>.cancel()<br/>    <strong class="mw iu">subscription3</strong>.cancel()<br/>    <strong class="mw iu">subscription4</strong>.cancel()<br/>}</span></pre><p id="b048" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">协程将帮助你逃离这个回调的地狱。您可能会在RxJava 中使用一次性工具来解决这个问题，但是这可能会使事情变得复杂。RxJava既有用又让人头疼。</p><p id="2407" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">那么解决办法是什么呢？接下来是协程，简单而全面。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="a131" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">2.协程的基础</h1><p id="ccaa" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">协程不过是轻量级线程，我们可以在其上根据您选择的上下文执行与后台或UI更改相关的任务。</p><p id="ece1" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">让我们用一个Kotlin协程来写上面的<code class="fe mt mu mv mw b">fetchCustomers()</code>。</p><pre class="kj kk kl km gt nc mw nd ne aw nf bi"><span id="b68c" class="ng lg it mw b gy nh ni l nj nk"><strong class="mw iu">suspend </strong>fun fetchCustomers(){<br/>     val array = <strong class="mw iu">api.fetchCustomersList</strong>()<br/>     updateUI(array)<br/>}</span></pre><p id="28b1" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">为了展示这个函数在协程上运行，我们使用了一个<code class="fe mt mu mv mw b">suspend</code>修饰符。它的工作方式类似于回调方式，但是在没有订阅的情况下使用较少的代码。就这样，它很容易实现，也很容易使用。你不需要学习任何新的执行风格。协同程序以顺序的<strong class="lz iu"> </strong>方式提供<code class="fe mt mu mv mw b">async</code> <strong class="lz iu"> </strong>执行。</p><p id="8ba9" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">它的作用是，当你开始执行一个协程时，它暂停执行，当它得到响应时，它从暂停的地方继续执行。这就是<code class="fe mt mu mv mw b">suspend</code>和<code class="fe mt mu mv mw b">resume</code>如何取代回调。</p><p id="fe00" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">协程的美妙之处在于它在许多高级库中都得到了很好的确立，比如<a class="ae nl" href="https://github.com/square/retrofit" rel="noopener ugc nofollow" target="_blank">翻新</a>、<a class="ae nl" href="https://developer.android.com/training/data-storage/room/index.html" rel="noopener ugc nofollow" target="_blank">房间</a>等等。现在，您可以在您的Android项目中使用协程，并通过使用retreate 2.6及更高版本来简化所有网络调用，如上所示。</p><p id="2b0e" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">回归基础。我们只能从另一个<code class="fe mt mu mv mw b">suspend</code>函数中调用一个<code class="fe mt mu mv mw b">suspend</code>函数。这是否意味着您需要将项目中的每个函数都写成一个<code class="fe mt mu mv mw b">suspend</code>函数？不，没必要。</p><p id="a7f3" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">我们可以使用<code class="fe mt mu mv mw b">withContext</code> <strong class="lz iu"> </strong>生成器启动一个新的协程，并使用常规函数中的<code class="fe mt mu mv mw b">Dispatchers</code>指定协程应该在哪个线程上执行，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="7cd2" class="ng lg it bd lh no np dn ll nq nr dp lp mg ns nt lr mk nu nv lt mo nw nx lv ny bi translated">调度员</h2><p id="9f2f" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated"><code class="fe mt mu mv mw b">Dispatchers</code>只不过是一串关键字，用来告诉协程应该在哪个线程上运行。Kotlin提供了三种类型的调度程序:</p><p id="0612" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated"><strong class="lz iu">默认:</strong>任何在主线程上运行时间过长的东西都应该在默认的调度程序上运行，比如执行<code class="fe mt mu mv mw b">DiffUtil</code>。</p><p id="3d33" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated"><strong class="lz iu"> IO: </strong>像写文件或进行API调用这样的任务应该发生在IO dispatcher上，它阻塞了UI。</p><p id="5a41" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated"><strong class="lz iu"> Main: </strong>这是主线程，Android中的所有任务通常都在这里执行。默认情况下，您可以在这个线程上启动，并在任何需要的地方更改调度程序。</p><p id="0a78" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">使用<code class="fe mt mu mv mw b">withContext</code>是一个主要的安全调用。现在你可以使用<code class="fe mt mu mv mw b">withContext</code>在Android的任何地方编写<code class="fe mt mu mv mw b">async</code> work，通过使用<code class="fe mt mu mv mw b">Dispatchers</code>，你可以控制它应该在哪个线程上运行。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="88db" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">3.术语</h1><p id="42b1" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">当然，当我们开始学习一项新技术时，我们应该了解一些术语:协程没有什么不同。这里有一些术语，我认为每个开始使用协程的人都应该知道。</p><p id="53bf" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated"><code class="fe mt mu mv mw b"><strong class="lz iu">CoroutineScope</strong></code> <strong class="lz iu"> : </strong>定义新协程的范围</p><p id="5bb8" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated"><code class="fe mt mu mv mw b"><strong class="lz iu">Job</strong></code> <strong class="lz iu"> : </strong>可以父子层次结构安排的后台作业。任何父作业的取消都会导致其所有子作业<strong class="lz iu"> </strong>立即被取消，除<code class="fe mt mu mv mw b">CancellationException</code> <strong class="lz iu"> <em class="nz"> </em> </strong>之外的任何子作业的失败或取消都会导致其父作业<em class="nz">被取消。</em></p><p id="765e" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated"><code class="fe mt mu mv mw b"><strong class="lz iu">SupervisorJob</strong></code> : <strong class="lz iu"> </strong>管理程序作业只是一个作业，但是它的子作业可以独立失败，而不需要关闭它的父作业。</p><p id="2bfc" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated"><code class="fe mt mu mv mw b"><strong class="lz iu">Suspend</strong></code> : <code class="fe mt mu mv mw b">Suspend</code>是一个修饰符，用在函数上，表示这是一个协程函数。</p><p id="bf5f" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated"><code class="fe mt mu mv mw b"><strong class="lz iu">Launch</strong></code> : <strong class="lz iu"> </strong> <code class="fe mt mu mv mw b">Launch</code>是<code class="fe mt mu mv mw b">CoroutineScope</code>中的一个方法，它在不阻塞当前线程的情况下启动一个协程，并返回一个对协程的引用作为<code class="fe mt mu mv mw b">Job</code>(可以取消T5来停止那个协程的执行)。</p><p id="fd6c" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated"><code class="fe mt mu mv mw b"><strong class="lz iu">Async</strong></code> : <code class="fe mt mu mv mw b">Async</code>是<code class="fe mt mu mv mw b">CoroutineScope</code>中的一个方法，它启动一个协程并返回其未来结果作为<code class="fe mt mu mv mw b">[Deferred]</code>的实现。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="8fb6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">4.用协程简化复杂的任务</h1><p id="fdc4" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">因为协程实现起来更简单，也更容易理解，所以许多高级库，如Retrofit，Room，<a class="ae nl" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank"> WorkManager </a>已经在支持它们了。</p><h2 id="0ab1" class="ng lg it bd lh no np dn ll nq nr dp lp mg ns nt lr mk nu nv lt mo nw nx lv ny bi translated">加装</h2><p id="7282" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">retrieval是一个著名的使用<code class="fe mt mu mv mw b">OkHttp</code>客户端进行网络调用的库。让我们看看如何使用coroutines的翻新，并比较我们可以减少的工作，如果我们实现它与其他库，如RxJava。</p><p id="0935" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">您所需要做的就是将您的回购服务函数更改为<code class="fe mt mu mv mw b">suspend</code>并从<code class="fe mt mu mv mw b">withContext</code>调用它们。</p><p id="ae35" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">首先，将您的改装<code class="fe mt mu mv mw b">annotate</code>服务呼叫功能更改为<code class="fe mt mu mv mw b">suspend</code>功能，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ca5f" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">现在从<code class="fe mt mu mv mw b">ViewModel</code>调用它，从服务器获取数据。这里我们可以使用两种模式。一种是将<code class="fe mt mu mv mw b">ViewModel</code>中的函数标记为<code class="fe mt mu mv mw b">suspend</code> <strong class="lz iu">、</strong>，另一种是使用<code class="fe mt mu mv mw b">withContext</code>启动协程，如上所示。</p><p id="2469" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">我将用<code class="fe mt mu mv mw b">withContext</code> <strong class="lz iu"> </strong>来解释，因为用<code class="fe mt mu mv mw b">suspend</code> <strong class="lz iu"> </strong>来标记一个函数是最简单的，但是在某些地方我们必须使用<code class="fe mt mu mv mw b">withContext</code> <strong class="lz iu"> </strong>来从一个普通函数开始一个协程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d282" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">这就是在Android中使用协程进行服务调用是多么简单。现在让我们将相同的服务与RxJava进行比较，看看我们在协程方面取得了多大的进步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6bda" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">您使用RxJava编写的行数更多，但这还不是全部。要实现RxJava你得知道更多，比如<code class="fe mt mu mv mw b">observeOn</code>和<code class="fe mt mu mv mw b">SubscribeOn</code>是什么。你还必须了解<code class="fe mt mu mv mw b">disposables</code>:它们为什么被使用，当我们忘记处理时会发生什么，以及一百多种其他事情。</p><p id="b97a" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">但是使用协程，你只需要知道<code class="fe mt mu mv mw b">Dispatchers</code>和<code class="fe mt mu mv mw b">scope</code>是什么。剩下的事情会处理好的。</p><h2 id="2b6e" class="ng lg it bd lh no np dn ll nq nr dp lp mg ns nt lr mk nu nv lt mo nw nx lv ny bi translated">房间</h2><p id="ddcc" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">Room是一个Jetpack库，能够在没有样板代码的情况下执行SQLite复杂操作。它充当SQLite的抽象层，节省了编写所有样板代码的时间。</p><p id="a9df" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">让我们看看如何通过协同例程使使用Room和RxJava的SQL查询更加简单。</p><p id="4413" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">与使用改型类似，您需要将您的<code class="fe mt mu mv mw b">Dao</code> <strong class="lz iu"> </strong>函数标记为<code class="fe mt mu mv mw b">suspend</code>函数，并通过使用<code class="fe mt mu mv mw b">suspend</code>函数或启动协程作用域在<code class="fe mt mu mv mw b">viewModel</code>中使用它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="122b" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">现在让我们从<code class="fe mt mu mv mw b">viewModel</code>中调用它</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ae2f" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">这就是你需要做的。现在你的应用程序有了网络和本地数据库的协程支持。</p><h2 id="c0f7" class="ng lg it bd lh no np dn ll nq nr dp lp mg ns nt lr mk nu nv lt mo nw nx lv ny bi translated">工作管理器</h2><p id="f3b6" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">您也可以在WorkManager中使用协程。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="b491" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">5.取消政策</h1><p id="dcd2" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">取消协程非常重要，因为取消会因为不必要的套接字连接或昂贵的操作(如读取文件)而耗尽用户资源。</p><p id="5ac8" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">在学习如何取消一个协程之前，重要的是要知道一个协程将如何执行，以及如果我们取消一个请求，它将经历哪些阶段。</p><p id="f94d" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">首先，让我们看看协程的生命周期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/024ba3a3c260abdf24a35c143f2c1845.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*-rnlxpz3v0zmQiafh9Udkw.png"/></div></figure><p id="e6cd" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">一般来说，一个协程将从一个活动的<strong class="lz iu"> </strong>状态开始，而新的<strong class="lz iu"> </strong>状态只有在你开始一个协程懒惰的<strong class="lz iu"> </strong>状态，然后在你启动或加入协程时转移到活动的<strong class="lz iu"> </strong>状态时才会出现。一旦一个协程开始执行，它将处于完成<strong class="lz iu"> </strong>状态。</p><p id="9d38" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">现在，你说的完成<strong class="lz iu"> </strong>状态是什么意思？在上面的例子中，我已经向您展示了下面的代码来创建一个协程作用域，我们在其中进行网络和数据库操作。</p><pre class="kj kk kl km gt nc mw nd ne aw nf bi"><span id="04e1" class="ng lg it mw b gy nh ni l nj nk">val viewModelJob = <strong class="mw iu">SupervisorJob</strong>()                       <br/>val viewmodelCoroutineScope = <strong class="mw iu">CoroutineScope</strong>(Dispatchers.IO + viewModelJob)</span></pre><p id="a4ec" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">每次你调用<code class="fe mt mu mv mw b">viewmodelCoroutineScope</code>上的<code class="fe mt mu mv mw b">launch</code>函数，它都会返回一个任务。这就像父作业和子作业一样:这里的<code class="fe mt mu mv mw b">viewModelJob</code>是父作业，调用<code class="fe mt mu mv mw b">launch</code>时创建的作业是子作业。</p><p id="4ce6" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">在所有子进程完成之前，协程将处于完成<strong class="lz iu"> </strong>状态。一旦协程中的所有作业都完成了，它将进入一个完成的<strong class="lz iu"> </strong>状态。</p><p id="c1e2" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">这里我们有三个标志来验证协程的状态:</p><ul class=""><li id="b5d8" class="ob oc it lz b ma mx md my mg od mk oe mo of ms og oh oi oj bi translated"><code class="fe mt mu mv mw b"><strong class="lz iu">isActive</strong></code> <strong class="lz iu"> </strong> —在协程的活动和完成状态下都成立。</li><li id="2ee9" class="ob oc it lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><code class="fe mt mu mv mw b"><strong class="lz iu">isCompleted</strong></code> —这是默认的<code class="fe mt mu mv mw b">false</code>。一旦所有父作业和子作业完成，该值变为<code class="fe mt mu mv mw b">true</code>。</li><li id="1c48" class="ob oc it lz b ma ok md ol mg om mk on mo oo ms og oh oi oj bi translated"><code class="fe mt mu mv mw b"><strong class="lz iu">isCancelled</strong></code> —这是默认的<code class="fe mt mu mv mw b">false</code>。如果出现任何异常或您取消了协程，该值将更改为<code class="fe mt mu mv mw b">true</code>。</li></ul><p id="44ff" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">到目前为止，您已经看到了成功执行的协程的生命周期，没有任何异常或取消。是时候看看如果一个协程被取消会经历什么阶段了，不管是因为异常还是因为你故意取消了它。</p><p id="704c" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">只有当协程进入活动或完成状态时，才能取消协程。当这种情况发生时，协程将进入取消状态，一旦所有的作业被取消，它将进入取消状态。看一看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/2915b213c8f3f5ce1b7245dbbdc8446e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZtPygHf7Lmmpb3YpzqcQA.png"/></div></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="c022" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">6.协程的有效使用</h1><p id="708a" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">当用户导航离开一个地方时，会有一些作业需要取消。继续那些不必要的任务只会耗尽用户的资源，例如带宽、电池、CPU使用率。</p><p id="702f" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">让我们看看如何在不必要的时候取消一个任务或一系列任务。</p><p id="c470" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">正如我在上面几节中已经说过的，当您在协程作用域上调用<code class="fe mt mu mv mw b">launch</code>时，将会返回一个作业，如果我们想要结束那个特定的任务，我们可以在那个作业上调用cancel。</p><p id="e460" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">我们知道如何取消特定的任务。是时候了解一下<code class="fe mt mu mv mw b">Job<strong class="lz iu"> </strong></code>和<code class="fe mt mu mv mw b">SupervisorJob</code> <strong class="lz iu">的区别了。</strong></p><p id="5466" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">作业和主管作业之间的唯一区别是，当在主管作业下取消子作业时，父作业或其他子作业不会受到影响。另一方面，当一个孩子在<code class="fe mt mu mv mw b">Job</code>下被取消时，父孩子和所有的孩子都将被取消。</p><pre class="kj kk kl km gt nc mw nd ne aw nf bi"><span id="2c02" class="ng lg it mw b gy nh ni l nj nk">val scope = CoroutineScope(parentJob)<br/>val job1 = scope.launch{ ... }<br/>val job2 = scope.launch{ ... }</span></pre><p id="dd00" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">我们可以在不需要的时候单独取消任务。如果<code class="fe mt mu mv mw b">parentJob</code>是主管作业，那么只有特定的<code class="fe mt mu mv mw b">Job</code>会被取消。否则，所有作业都将被取消。</p><p id="6520" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">通过上面的示例，我们学习了如何取消特定的作业。如果我不想取消某个特定的工作怎么办？或者我不想跟踪所有的作业，而只是在需要时取消所有的作业？您可以在协程作用域上调用<code class="fe mt mu mv mw b">cancel</code>函数，以便取消该作用域下的所有子作用域。</p><pre class="kj kk kl km gt nc mw nd ne aw nf bi"><span id="2c21" class="ng lg it mw b gy nh ni l nj nk">scope.cancel()<br/>or<br/>scope.coroutineContext.cancelChildren()</span></pre></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="bf31" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">7.错误和异常处理</h1><p id="4dfd" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">我们在上述章节中留下的一件事是错误和异常处理。这是网络和数据库事务期间的基本任务之一。与RxJava不同，Kotlin协程有一种非常干净的方式来处理它们。</p><h2 id="f8df" class="ng lg it bd lh no np dn ll nq nr dp lp mg ns nt lr mk nu nv lt mo nw nx lv ny bi translated">合作取消</h2><p id="65d6" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">检查作业中的<code class="fe mt mu mv mw b">isActive</code>或<code class="fe mt mu mv mw b">ensureActive</code> <strong class="lz iu"> </strong>以确保当前作业不会因异常或故意取消。</p><pre class="kj kk kl km gt nc mw nd ne aw nf bi"><span id="2cc2" class="ng lg it mw b gy nh ni l nj nk">viewmodelCoroutineScope.launch <strong class="mw iu">{<br/>     ensureActive()<br/>         or<br/>     if(isActive){ ... }<br/>}</strong></span></pre><p id="3a82" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">如果作业被取消，那么它不会通过这些条件。</p><p id="4990" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">如果你不习惯在每个作业<strong class="lz iu">、</strong>中使用<code class="fe mt mu mv mw b">isActive</code>，那么你可以用<code class="fe mt mu mv mw b">try</code> / <code class="fe mt mu mv mw b">catch</code>将代码括起来，在最后一个块中，你可以做任何你需要做的工作，比如当一个协程被取消时进行清理。</p><h2 id="bc9b" class="ng lg it bd lh no np dn ll nq nr dp lp mg ns nt lr mk nu nv lt mo nw nx lv ny bi translated">取消的协同作用域</h2><p id="66b1" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">如果一个<code class="fe mt mu mv mw b">CoroutineScope</code>用<code class="fe mt mu mv mw b">Job</code>创建，并且它的一个子作业被取消，那么它的所有子作业也被取消，包括父作业。与此同时，<code class="fe mt mu mv mw b">CoroutineScope</code>也将被取消，这意味着您不能用那个作用域启动一个新的协程。</p><p id="42a1" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">为了克服这一点，我们可以使用<code class="fe mt mu mv mw b">SupervisorJob</code>创建一个<code class="fe mt mu mv mw b">CoroutineScope</code>，它不会在取消任何子作业时影响父作业或范围。</p><h2 id="7564" class="ng lg it bd lh no np dn ll nq nr dp lp mg ns nt lr mk nu nv lt mo nw nx lv ny bi translated">用协程程序尝试/捕捉</h2><p id="a365" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">与RxJava不同，我们可以通过用<code class="fe mt mu mv mw b">try</code> / <code class="fe mt mu mv mw b">catch</code>块包围代码来处理错误和异常。不需要像在RxJava中那样分别实现错误块和成功块。</p><h2 id="aca5" class="ng lg it bd lh no np dn ll nq nr dp lp mg ns nt lr mk nu nv lt mo nw nx lv ny bi translated">奔跑捕捉</h2><p id="bcc1" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">除了传统的<code class="fe mt mu mv mw b">try</code> / <code class="fe mt mu mv mw b">catch</code>，Kotlin还提供了<code class="fe mt mu mv mw b">runCatching</code> <strong class="lz iu">，</strong>，它返回一个结果，该结果包含输出信息以及执行状态，就像<code class="fe mt mu mv mw b">isSucess</code>一样。如果是失败的情况，在结果<strong class="lz iu"> </strong> <code class="fe mt mu mv mw b">exceptionOrNull</code>中有一个属性，通过这个属性我们可以获得关于异常的详细信息。在我看来，它更灵活，提供了更干净的接口来处理异常和错误。看一看。</p><pre class="kj kk kl km gt nc mw nd ne aw nf bi"><span id="6e26" class="ng lg it mw b gy nh ni l nj nk">viewmodelCoroutineScope.launch <strong class="mw iu">{<br/>    </strong>val result = kotlin.<strong class="mw iu">runCatching {<br/>        </strong>repository.getData(inputs)<br/>    <strong class="mw iu">}<br/>}</strong></span></pre></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="3379" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">8.有用的链接</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq nn l"/></div></figure><p id="1c0a" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">如果您想了解更多关于Kotlin高级开发的内容，请阅读以下文章:</p><div class="or os gp gr ot ou"><a href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">使用Kotlin进行高级Android编程</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">kot Lin-您应该使用的独有功能</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://medium.com/@sgkantamani/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">使用Kotlin进行高级Android编程-第2部分</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">kot Lin-您应该使用的独有功能</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><p id="3a71" class="pw-post-body-paragraph lx ly it lz b ma mx ju mc md my jx mf mg mz mi mj mk na mm mn mo nb mq mr ms im bi translated">感谢您阅读我的文章。</p></div></div>    
</body>
</html>