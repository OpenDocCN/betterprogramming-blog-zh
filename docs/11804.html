<html>
<head>
<title>Rancher K3s: Kubernetes on Proxmox Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">牧场主K3s:prox MOX集装箱上的Kubernetes</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rancher-k3s-kubernetes-on-proxmox-containers-2228100e2d13?source=collection_archive---------0-----------------------#2022-04-19">https://betterprogramming.pub/rancher-k3s-kubernetes-on-proxmox-containers-2228100e2d13?source=collection_archive---------0-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6a25" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用LXC容器和K3s启动带有NGINX入口控制器的K8s集群</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/bcfedacc0e0e659c578aaec939346d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*O8XrSbK06wCRIiXdAalTPQ.png"/></div></figure><p id="2454" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">很长一段时间以来，我一直自己托管我的大多数在线服务，如日历、联系人、电子邮件、云文件存储、我的网站等。我的设置的当前迭代依赖于一系列可翻译的行动手册，这些手册安装所有各种应用程序并配置它们以供使用。</p><p id="ebee" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这真的很稳定，对我来说效果很好。我将应用程序部署到<a class="ae lj" href="https://www.proxmox.com/en/" rel="noopener ugc nofollow" target="_blank"> Proxmox </a>上的一组LXC容器(读作:<a class="ae lj" href="https://linuxcontainers.org/lxd/" rel="noopener ugc nofollow" target="_blank">轻量级Linux虚拟机</a>)中，这是一个免费的开源管理程序，具有出色的管理界面。</p><p id="76f8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然而，最近我一直在重新学习Docker和使用容器部署应用程序的好处。一些大的例子是:</p><ul class=""><li id="6541" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li lp lq lr ls bi translated">有保证的可复制环境。应用程序附带了它的依赖项，随时可以运行。</li><li id="d2d2" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated">便携性。假设您的环境支持容器运行时，它也支持应用程序。</li><li id="7e38" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated">基础设施即代码。与Ansible playbooks非常相似，Docker非常适合使用代码来管理容器环境，代码可以被跟踪和版本化。</li></ul><p id="4fed" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，我决定开始将我的裸机Linux Ansible playbooks转换为一组Kubernetes部署的旅程。</p><p id="5162" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是，Proxmox还是有一些我喜欢的地方我不舍得放弃。首先，能够虚拟化无法轻松容器化的物理机(如我的路由器或接入点管理门户)。当我需要在主机上进行维护时，能够在服务器之间迁移“物理”操作系统安装非常有用。</p><p id="a825" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，我将在Proxmox上安装Kubernetes，我想在LXC容器上这样做。</p><h1 id="be9d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">我们正在构建的内容和理念</h1><p id="49e0" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">我将使用<a class="ae lj" href="https://rancher.com/docs/k3s/latest/en/" rel="noopener ugc nofollow" target="_blank"> Rancher的K3s </a>发行版在LXC容器上部署一个Kubernetes集群。</p><p id="f764" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">K3s是一个轻量级的生产级Kubernetes发行版，它预先配置了DNS、网络和其他开箱即用的工具，从而简化了设置过程。K3s还使得将新员工加入集群变得相当容易。这一点，再加上我的部署规模相对较小，使它成为一个相当容易的选择。</p><p id="efce" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">另一方面，LXC集装箱可能看起来有点奇怪。我发现的几乎所有在Proxmox上部署K8s的文章都是使用全脂虚拟机，而不是容器。这当然是一条摩擦较小的路线，因为它在程序上与在物理主机上安装它是一样的。我选择LXC集装箱有两个主要原因:</p><ol class=""><li id="28b3" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li mv lq lr ls bi translated"><strong class="kp ir"> LXC集装箱<em class="mw">快</em>。几乎和裸机一样快。</strong>由于LXC容器是在内核级虚拟化的，因此比传统虚拟机要轻得多。因此，它们几乎可以立即启动，以与主机内核几乎相同的速度运行，并且更容易动态地重新配置更多的RAM/磁盘空间/CPU内核。</li><li id="9404" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li mv lq lr ls bi translated">LXC的集装箱更小。因为容器运行在主机的内核上，所以它们需要包含更小的一组包。这使得它们需要的开箱即用的磁盘空间少得多(因此，使它们更容易迁移)。</li></ol><p id="07ee" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，首先，我将创建两个容器:一个控制节点和一个工作节点。</p><h1 id="325b" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">先决条件</h1><p id="34fb" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">我将假设您(1)有一个启动并运行的Proxmox服务器，(2)在Proxmox上有一个可用的<a class="ae lj" href="https://us.lxd.images.canonical.com/images/rockylinux/8/amd64/default/" rel="noopener ugc nofollow" target="_blank">容器模板</a>，以及(3)有某种NFS文件服务器。</p><p id="7c87" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后一点很重要，因为我们将给容器一个相对较小的磁盘空间。因此，Kubernetes pods需要的任何卷都可以创建为<a class="ae lj" href="https://kubernetes.io/docs/concepts/storage/volumes/#nfs" rel="noopener ugc nofollow" target="_blank"> NFS挂载</a>。</p><p id="5c70" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您还需要在本地机器上设置<code class="fe mx my mz na b">kubectl</code>和<code class="fe mx my mz na b">helm</code>工具。</p><h1 id="b065" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">创建LXC容器</h1><p id="05f9" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">因为我们的LXC容器需要能够自己运行Docker容器，所以我们需要做一些开箱即用的额外配置来给它们适当的权限。</p><p id="f694" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">设置这两个容器的过程几乎是相同的，所以我将只介绍一次。</p><p id="898d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在Proxmox用户界面中，单击“创建联系类型”确保选中显示高级设置的复选框。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/2646393bed6899f9d792f07d05c8467a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hDOQuERmu5-dxVBf.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">确保取消选中“无特权容器”</p></figure><p id="d98f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">填写容器的详细信息。确保取消选中“无特权容器”复选框。在下一个屏幕上，选择您选择的模板。我用的是<a class="ae lj" href="https://us.lxd.images.canonical.com/images/rockylinux/8/amd64/default/" rel="noopener ugc nofollow" target="_blank"> Rocky Linux 8镜像</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nk"><img src="../Images/abf2c334c83b96afe4e82b1adb5e5f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q8BAo8GsYpiL2jgu.png"/></div></div></figure><p id="51ad" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我选择给每个容器一个16 GiB的根磁盘大小，只要我们不在磁盘上放置任何卷，这对OS和K3s的运行来说是绰绰有余的。</p><p id="7ce2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">CPU和内存值实际上取决于主机上的可用资源，以及您打算在K8s集群上运行的工作负载。对于我的，我给了每个容器4个vCPU核心和4 GiB的RAM。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nl"><img src="../Images/f55274b9ba4104faccbd22758bad485d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BXo2Slx0QR3VBOkq.png"/></div></div></figure><p id="b9ec" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于网络配置，请确保为每个节点设置一个静态IP地址。此外，如果您使用特定的内部DNS服务器(我强烈推荐！)，您应该在下一页进行配置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nm"><img src="../Images/6d908c5b55a04424ccca4a74dca48990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W7D47KxXk22kcqxK.png"/></div></div></figure><p id="7fb7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后，在最后一页，确保取消选中“创建后启动”复选框，然后单击“完成”。Proxmox将创建容器。</p><h1 id="b09a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">附加配置</h1><p id="66e2" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">现在，我们需要调整一些底层的东西来给我们的容器适当的权限。您需要以<code class="fe mx my mz na b">root</code>用户的身份SSH到您的Proxmox主机来运行这些命令。</p><p id="e372" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<code class="fe mx my mz na b">/etc/pve/lxc</code>目录中，您会发现名为<code class="fe mx my mz na b">XXX.conf</code>的文件，其中<code class="fe mx my mz na b">XXX</code>是我们刚刚创建的容器的ID号。使用您选择的文本编辑器，编辑我们创建的容器的文件，添加以下行:</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="7f12" class="nr lz iq na b gy ns nt l nu nv">lxc.apparmor.profile: unconfined<br/>lxc.cgroup.devices.allow: a<br/>lxc.cap.drop:<br/>lxc.mount.auto: "proc:rw sys:rw"</span></pre><blockquote class="nw nx ny"><p id="6369" class="kn ko mw kp b kq kr jr ks kt ku ju kv nz kx ky kz oa lb lc ld ob lf lg lh li ij bi translated"><em class="iq">注意:当你试图编辑文件时，容器必须停止，否则Proxmox的网络文件系统会阻止你保存它。</em></p></blockquote><p id="c614" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">按顺序，这些选项(1)禁用<a class="ae lj" href="https://www.apparmor.net/" rel="noopener ugc nofollow" target="_blank"> AppArmor </a> , (2)允许容器的cgroup访问所有设备，(3)防止丢弃容器的任何功能，以及(4)在容器中以读写方式挂载<code class="fe mx my mz na b">/proc</code>和<code class="fe mx my mz na b">/sys</code>。</p><p id="2e46" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我们需要将内核引导配置发布到容器中。通常，容器不需要这样做，因为它使用主机的内核运行，但是Kubelet使用配置来确定运行时的各种设置，所以我们需要将其复制到容器中。为此，首先使用Proxmox web UI启动容器，然后在Proxmox主机上运行以下命令:</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="6d3d" class="nr lz iq na b gy ns nt l nu nv">pct push &lt;container id&gt; /boot/config-$(uname -r) /boot/config-$(uname -r)</span></pre><p id="d101" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后，<strong class="kp ir">在每个容器</strong>中，我们需要确保<code class="fe mx my mz na b">/dev/kmsg</code>存在。Kubelet将它用于一些日志功能，默认情况下它不存在于容器中。出于我们的目的，我们将它命名为<code class="fe mx my mz na b">/dev/console</code>。在每个容器中，创建包含以下内容的文件<code class="fe mx my mz na b">/usr/local/bin/conf-kmsg.sh</code>:</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="37f9" class="nr lz iq na b gy ns nt l nu nv">#!/bin/sh -e<br/>if [ ! -e /dev/kmsg ]; then<br/>	ln -s /dev/console /dev/kmsg<br/>fi</span><span id="eff7" class="nr lz iq na b gy oc nt l nu nv">mount --make-rshared /</span></pre><p id="9896" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果<code class="fe mx my mz na b">/dev/kmsg</code>不存在，这个脚本将<code class="fe mx my mz na b">/dev/console</code>符号化为<code class="fe mx my mz na b">/dev/kmsg</code>。最后，我们将配置它在容器启动SystemD一次性服务时运行。创建包含以下内容的文件<code class="fe mx my mz na b">/etc/systemd/system/conf-kmsg.service</code>:</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="424f" class="nr lz iq na b gy ns nt l nu nv">[Unit]<br/>Description=Make sure /dev/kmsg exists</span><span id="edf1" class="nr lz iq na b gy oc nt l nu nv">[Service]<br/>Type=simple<br/>RemainAfterExit=yes<br/>ExecStart=/usr/local/bin/conf-kmsg.sh<br/>TimeoutStartSec=0</span><span id="93fc" class="nr lz iq na b gy oc nt l nu nv">[Install]<br/>WantedBy=default.target</span></pre><p id="698d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后，通过运行以下命令来启用该服务:</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="5cba" class="nr lz iq na b gy ns nt l nu nv">chmod +x /usr/local/bin/conf-kmsg.sh<br/>systemctl daemon-reload<br/>systemctl enable --now conf-kmsg</span></pre><h1 id="4742" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">设置容器操作系统和K3s</h1><p id="5f7d" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">现在我们已经设置好了容器，我们将在上面设置牧场主K3s。幸运的是，Rancher有意让这变得非常容易。</p><h1 id="2427" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">设置控制节点</h1><p id="4bda" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated"><strong class="kp ir">从控制节点</strong>开始，我们将运行以下命令来设置K3s:</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="13b3" class="nr lz iq na b gy ns nt l nu nv">curl -fsL <a class="ae lj" href="https://get.k3s.io" rel="noopener ugc nofollow" target="_blank">https://get.k3s.io</a> | sh -s - --disable traefik --node-name control.k8s</span></pre><p id="131a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里有一些注意事项:</p><ul class=""><li id="9004" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li lp lq lr ls bi translated">默认情况下，K3s配有一个<a class="ae lj" href="https://rancher.com/docs/k3s/latest/en/networking/#traefik-ingress-controller" rel="noopener ugc nofollow" target="_blank"> Traefik入口控制器</a>。这很好，但我更喜欢使用行业标准的<a class="ae lj" href="https://kubernetes.github.io/ingress-nginx/" rel="noopener ugc nofollow" target="_blank"> NGINX入口控制器</a>，所以我们将手动设置它。</li><li id="e3dc" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated">我已经使用<code class="fe mx my mz na b">--node-name</code>标志手动指定了节点名。这可能不是必要的，但我过去在K3s从IP地址反向查找主机名时遇到过问题，导致在集群重启之间出现不同的节点名称。明确指定名称可以避免这个问题。</li></ul><p id="247c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果一切顺利，您应该会看到类似如下的输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi od"><img src="../Images/50f509042cbc608536af7a2e6ac1558d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9C13vZDJ2t0AUAkL.png"/></div></div></figure><p id="e51b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一旦完成，您就可以在您的本地机器上将<code class="fe mx my mz na b">/etc/rancher/k3s/k3s.yaml</code>复制为<code class="fe mx my mz na b">~/.kube/config</code>，并且您应该能够使用<code class="fe mx my mz na b">kubectl get nodes</code>看到您的新(公认的单节点)集群！</p><blockquote class="nw nx ny"><p id="bd93" class="kn ko mw kp b kq kr jr ks kt ku ju kv nz kx ky kz oa lb lc ld ob lf lg lh li ij bi translated"><em class="iq">注意:您可能需要将配置文件中的集群地址从</em> <code class="fe mx my mz na b"><em class="iq">127.0.0.1</em></code> <em class="iq">调整为控制节点的实际IP/域名。</em></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c7569d06f019ebe595037e335894e4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*X8R1nu8nJZwdTotp.png"/></div></figure><h1 id="d3bc" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">设置工作节点</h1><p id="c2ef" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">现在，我们需要将我们的工作节点加入K3s集群。这也很简单，但是您需要集群令牌来加入节点。</p><p id="838f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以通过在控制节点上运行以下命令<strong class="kp ir">来发现这一点:</strong></p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="2058" class="nr lz iq na b gy ns nt l nu nv">cat /var/lib/rancher/k3s/server/node-token</span></pre><p id="e8f0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，在工作节点上<strong class="kp ir">运行以下命令来设置K3s并加入现有集群:</strong></p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="dd16" class="nr lz iq na b gy ns nt l nu nv">curl -fsL <a class="ae lj" href="https://get.k3s.io" rel="noopener ugc nofollow" target="_blank">https://get.k3s.io</a> | K3S_URL=https://&lt;control node ip&gt;:6443 K3S_TOKEN=&lt;cluster token&gt; sh -s - --node-name worker-1.k8s</span></pre><p id="23a9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">再次注意，我们明确指定了节点名。一旦这个过程完成，您现在应该看到worker节点出现在<code class="fe mx my mz na b">kubectl get nodes</code>中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/6d37e296caea4cddb15a75da13e5ccb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/0*PeeSJsT3dHe_ywzS.png"/></div></figure><p id="e61e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以对将来要加入集群的任何其他工作节点重复此过程。</p><p id="9a96" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">此时，我们有了一个功能正常的Kubernetes集群，但是因为我们禁用了Traefik，所以它没有入口控制器。那么，让我们现在就开始吧。</p><h1 id="68b2" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">设置NGINX入口控制器</h1><p id="d7f0" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">我使用了<code class="fe mx my mz na b">ingress-nginx/ingress-nginx</code>舵图来设置NGINX入口控制器。为此，我们将添加回购，加载回购的元数据，然后安装图表:</p><pre class="kg kh ki kj gt nn na no np aw nq bi"><span id="caab" class="nr lz iq na b gy ns nt l nu nv">helm repo add ingress-nginx <a class="ae lj" href="https://kubernetes.github.io/ingress-nginx" rel="noopener ugc nofollow" target="_blank">https://kubernetes.github.io/ingress-nginx</a><br/>helm repo update<br/>helm install nginx-ingress ingress-nginx/ingress-nginx --set controller.publishService.enabled=true</span></pre><p id="864c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里，<code class="fe mx my mz na b">controller.publishService.enabled</code>设置告诉控制器向入口资源发布入口服务IP地址。</p><p id="238f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">图表完成后，您应该看到各种资源出现在<code class="fe mx my mz na b">kubectl get all</code>输出中。(请注意，控制器可能需要几分钟时间才能联机并将IP地址分配给负载平衡器。)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi of"><img src="../Images/3e95b5f1b0fefb0b254926ca3d64e05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GuNgc6DyNfsYyDFh.png"/></div></div></figure><p id="f687" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们可以通过在web浏览器中导航到任何节点地址来测试控制器是否启动并运行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi og"><img src="../Images/2ef969f797b5d42a0e3eff78593e5163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L15QFR0cHM0K39QB.png"/></div></div></figure><p id="a1a6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这种情况下，我们希望看到404，因为我们还没有配置任何通过NGINX进入的服务。重要的是我们得到了NGINX提供的页面。</p><h1 id="8dcd" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="cd15" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">现在，我们有了一个全功能的Rancher K3s Kubernetes集群，并且NGINX入口控制器已经配置好，随时可以使用。</p><p id="c29b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我发现这个集群非常容易维护和扩展。如果您需要添加更多节点，只需启动另一个LXC容器(可能在另一个物理主机上，也可能不在)，然后重复该部分，将worker加入集群。</p><p id="0cd6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我计划再写几篇文章，记录我学习和过渡到Kubernetes的旅程，请继续关注更多类似的文章。这个过程的下一步是配置<a class="ae lj" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> cert-manager </a>来自动生成Let's Encrypt SSL证书，并将一个简单的应用程序部署到我们的集群中。</p><blockquote class="nw nx ny"><p id="430d" class="kn ko mw kp b kq kr jr ks kt ku ju kv nz kx ky kz oa lb lc ld ob lf lg lh li ij bi translated">这篇文章最初出现在我的博客<a class="ae lj" href="https://garrettmills.dev/blog/2022/04/18/Rancher-K3s-Kubernetes-on-Proxmox-Container/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote></div></div>    
</body>
</html>