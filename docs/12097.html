<html>
<head>
<title>3 Pitfalls of AWS Step Functions and How You Can Avoid Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS阶跃函数的3个陷阱以及如何避免它们</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-reasons-you-should-stay-away-from-aws-step-functions-43bdd97b75a?source=collection_archive---------9-----------------------#2022-05-11">https://betterprogramming.pub/3-reasons-you-should-stay-away-from-aws-step-functions-43bdd97b75a?source=collection_archive---------9-----------------------#2022-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3821" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Step Functions是AWS提供的一项令人难以置信的工作流服务。但是如果你不小心的话，你可能会不知所措，发现自己在努力做日常维护。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5265ddf58600ddf8ee9a9d2442714620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VxDwt4TZgSA420xy6r0z1A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Breana Panaguiton 在<a class="ae ky" href="https://unsplash.com/s/photos/warning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，我接到一个电话，请求帮助解决生产中的一个严重问题。</p><p id="7a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个bug处理数据的规模超出了开发团队的预期。他们使用[Step Functions](https://AWS . Amazon . com/Step-Functions/)来编排一个工作流，该工作流接受一组对象，对它们进行处理，并将转换后的对象放入DynamoDB。</p><p id="76cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从表面上看，这听起来像是一个非常标准的工作流程——字面意思就是Step函数的设计目的。但是经过更仔细的检查，我们意识到我们遇到了256KB的[最大请求大小限制](https://docs . AWS . Amazon . com/step-functions/latest/DG/limits-overview . html # service-limits-task-executions)，因为数组太大了。</p><p id="06e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调试这个问题花费了比预期长得多的时间，因为我们必须不断地触发一个工作流并等待它完成。由于要处理的项目太多，每次运行需要15分钟以上。</p><p id="4de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我和开发团队一起工作了一段时间，找出了替代方案，我们最终找到了一个解决方案，将数组分解成更小的批，并通过Lambda函数运行多个状态机执行。</p><p id="8f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我真的不喜欢那个解决方案。限制是有原因的。我觉得我们解决这个问题的方式很卑鄙。所以很自然地，我上了推特，看看你们都在做什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="311b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我收到了几个可靠的答案，这让我思考“阶跃函数<em class="lx">不</em>擅长什么？”</p><p id="ee56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">老实说，这是一个很短的列表。但是陷阱确实适用于一系列用例。所以让我们深入讨论一下什么时候使用Lambda函数比使用阶跃函数更好。</p><p id="9b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，我想添加一个免责声明——如果你足够努力，你几乎总能找到一个变通办法。使用阶跃函数，下面问题的解决方法实际上是可行的解决方案。</p><p id="be3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，可行性将根据您对服务的满意程度而有所不同。一些高级模式可以绕过陷阱，但是在某些情况下可能太难维护。</p><p id="c1ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的每个场景都标有<em class="lx">初级</em>、<em class="lx">中级</em>和<em class="lx">高级</em>技能等级。在本文中，这些技能水平被定义为:</p><ul class=""><li id="91d7" class="ly lz it lb b lc ld lf lg li ma lm mb lq mc lu md me mf mg bi translated"><strong class="lb iu">初学者</strong> —你刚刚开始使用阶跃函数。你有过没有服务器的经历，但是你想知道这一切是怎么回事。</li><li id="86d1" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu md me mf mg bi translated"><strong class="lb iu">中级</strong> —您了解状态机是如何构建的，并且熟悉生产就绪的最佳实践。你知道如何有效地使用类似于<em class="lx">映射</em>和<em class="lx">的并行</em>状态，并且能够保持对状态机执行状态大小和形状的控制。</li><li id="4e24" class="ly lz it lb b lc mh lf mi li mj lm mk lq ml lu md me mf mg bi translated"><strong class="lb iu">高级</strong> —您精通事件驱动架构，知道如何以及何时使用快速和标准工作流。您知道并使用高级功能，如等待任务令牌和执行子工作流。您总是尽可能使用直接的SDK集成。</li></ul><p id="de9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这一点，我们来讨论一些具有阶跃函数的非平凡场景，以及基于您的舒适度应该做些什么。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="27ff" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">你的有效载荷很大</h1><h2 id="812b" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">问题</strong></h2><p id="123f" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">阶跃函数的最大请求大小限制为256KB。这意味着您加载到状态机中并通过转换传递的所有数据必须始终小于256KB。如果在此过程中加载了过多的数据，将会出现异常，执行将会中止。</p><h2 id="cffb" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">初学者</strong></h2><p id="c20d" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">这是一个通常会悄悄出现在你面前的问题，是一个很难解决的问题。一切都很好，直到它不行。管理执行大小限制的最简单的方法是将状态调整为<em class="lx">只包含</em>绝对必要的内容。</p><p id="efc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<a class="ae ky" href="https://aws.amazon.com/blogs/compute/modeling-workflow-input-output-path-processing-with-data-flow-simulator/" rel="noopener ugc nofollow" target="_blank">数据流模拟器</a>来帮助重塑您的数据，以包含尽可能少的内容。这涉及到大量使用状态的<code class="fe oc od oe of b">ResultSelector</code>、<code class="fe oc od oe of b">ResultPath</code>和<code class="fe oc od oe of b">OutputPath</code>属性。</p><p id="bdb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的问题是，如果你不能缩小数据集，它<em class="lx">不能解决问题。如果你对阶跃函数不太满意，那么Lambda函数可能是一个更合适的解决方案。</em></p><h2 id="4dcf" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">中级</strong></h2><p id="072b" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">AWS的官方建议是<a class="ae ky" href="https://docs.aws.amazon.com/step-functions/latest/dg/avoid-exec-failures.html" rel="noopener ugc nofollow" target="_blank">将数据保存在S3 </a>并在状态间传递对象arn。这意味着当您的有效负载可能超过256KB限制时，您必须首先将其保存到S3。当执行状态机时，传递对象键和桶，这样所有Lambda函数都可以加载数据。</p><p id="2c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一个主要缺点是它使得使用<a class="ae ky" href="https://docs.aws.amazon.com/step-functions/latest/dg/supported-services-awssdk.html" rel="noopener ugc nofollow" target="_blank">直接SDK集成</a>更加困难。这些集成直接使用执行状态之外的数据，因此您将无法将必要的信息传递给API调用，因为这些信息存储在S3中。</p><p id="2938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个有趣问题的简单解决方案，但是您实际上消除了阶跃函数的一个主要优点。更不用说性能会受到影响，因为无论何时需要访问有效载荷，都要从S3加载对象。</p><h2 id="22be" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">进阶</strong></h2><p id="d21f" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">对于超过执行状态限制的有效负载，您必须通过Lambda函数触发您的工作流。考虑到这一点，您可能能够将您的数据和工作流分成多个部分。如果您有一组需要在数据子集上执行的活动，您可以创建一个只执行这些任务的状态机。</p><p id="7173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以创建另一个状态机，对数据的不同子集执行任务，依此类推。这将创建小的、“域驱动的”状态机，具有狭窄的焦点。</p><p id="8294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的执行Lambda函数将负责将数据解析成适当的片段，并使用适当的数据执行每个状态机。在运行所有的状态机之后，如果有必要的话，它会把数据拼凑起来，并返回结果。</p><p id="b5b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法带来了使用直接SDK集成的能力，但它确实增加了您的解决方案的复杂性。通过管理更多的状态机，您可能很难在将来维护解决方案。</p><p id="8c2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法时要小心，不要让Lambda函数等待所有状态机的执行完成。那会累积一大笔账单。相反，你可以尝试使用<a class="ae ky" href="https://async-messaging.workshop.aws/scatter-gather.html" rel="noopener ugc nofollow" target="_blank">分散/聚集模式</a>在完成时触发响应。</p><p id="560d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lx">注意——这可能是最快/最高效的解决方案，但在实践中，中间方法是更安全的选择。</em></p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="655d" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">你并行处理大量数据</h1><h2 id="8e98" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">问题</strong></h2><p id="92a3" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">阶跃函数的最大历史事件数为25，000。这意味着，如果您的数据集包含数千个条目，您可能会超出状态转换的限制。对于如此大的数据集，您也可能会遇到数据大小限制。</p><p id="1f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要并发处理的大型数据集听起来非常适合使用阶跃函数。但是，如果您通过一个<em class="lx"> Map </em>状态进行并行处理，最大并发限制是40。这意味着您将以40个为一批来处理数据。所以你的并行处理可能没有你想象的那么快。</p><h2 id="7b5c" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">初学者</strong></h2><p id="824a" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">如果您的工作流是异步运行的，那么最好接受40个并发的<em class="lx"> Map </em>执行，并等待它完成。在接近25，000个事件历史限制之前，这种方法没有任何问题。</p><p id="d6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的状态机开始出现这种情况时，您可能需要开始做一些数学计算，并计算出您的最大项目数是多少。一旦确定了最大项目数，就可以并行批处理运行工作流。类似于我为解决前面提到的生产bug所做的。</p><p id="a146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理大数组带来的大数据量，您需要采用与上面列出的相同的方法，其中有效负载被保存到一个S3对象中，并通过状态机开头的Lambda函数进行加载、解析和拆分。</p><h2 id="3f88" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">中级</strong></h2><p id="ddf4" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">中级方法的解决方案类似于初学者，但是它包含更多的自动化。如果您正在处理的数组位于像DynamoDB这样的数据库中，那么您可以从状态机中加载要处理的数据子集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/d4db373cc4f412f5c189c98675e9252b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/0*4IIngy-WjImQ-A5U.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oh">从数据库加载并跟踪状态计数的状态机图</em></p></figure><p id="e6bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态机使用限制属性加载数据<a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-request-Limit" rel="noopener ugc nofollow" target="_blank">的子集。然后，它遍历返回的处于<code class="fe oc od oe of b">Map</code>状态的项目。</a></p><p id="3804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦项目处理完毕，它将加载执行历史，并查看最后一个项目的<code class="fe oc od oe of b">Id</code>属性，以获取已发生事件的数量。如果还剩下足够的事件而没有太接近25，000的限制，则从头开始。如果接近极限，状态机将启动自己的另一个实例，重新开始计数，并从停止的地方继续处理。</p><p id="a854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程会让你走得很远。但就执行速度而言，可能会更快。这种方法在40个一批的连续批次中有效。因此，您的大型数据集可能需要大量时间来处理。</p><h2 id="332f" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">高级</strong></h2><p id="6c2e" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><a class="ae ky" href="https://twitter.com/justincallison" rel="noopener ugc nofollow" target="_blank">Step Functions的高级经理Justin Callison </a>向我们介绍了一种实现超高速并行处理的高级方法，即<a class="ae ky" href="https://aws.amazon.com/blogs/compute/accelerating-workloads-using-parallelism-in-aws-step-functions/" rel="noopener ugc nofollow" target="_blank">将状态机构建为协调器和运行器</a>。</p><p id="0bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">orchestrator将您的数据集解析为多个批处理，并将单个批处理传递给运行器。跑腿的拿走一批货，加工产品。如果一个批处理中有40个以上的项目，它会将数据拆分成40个以上的批处理，并递归调用自身以扇出并并行处理更多的项目。状态机将继续分裂和扇出，直到每批中的项目少于40个。</p><p id="b59a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章非常详细，甚至在GitHub 中提供了一个<a class="ae ky" href="https://github.com/aws-samples/aws-stepfunctions-examples/tree/main/sam/app-decompose-for-parallelism" rel="noopener ugc nofollow" target="_blank">工作示例。</a></p><p id="4855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法完全解决了并行问题，但却是目前最先进的方法。在走这条路之前，请确保您已经熟悉了阶跃函数。与任何递归一样，一个小错误可能会让你陷入无限循环，并导致一笔巨额账单。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="7761" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">你跨越了服务界限</h1><h2 id="b043" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">问题</strong></h2><p id="aff0" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在构建工作流时，有时需要在多个<a class="ae ky" href="https://aws.amazon.com/microservices/" rel="noopener ugc nofollow" target="_blank">微服务</a>中操作数据。微服务是AWS资源的逻辑分离，这些资源可能在同一帐户中，也可能不在同一帐户中。每个微服务应该是独立的，只使用自己的资源，而不是其他服务的资源。</p><p id="d7b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接使用来自其他微服务的资源会产生<em class="lx">紧耦合</em>，这是无服务器和微服务设计中的反模式。如果您将多个微服务部署到同一个AWS帐户中，Step Functions可以轻松跨越这些服务界限。当您构建您的状态机时，您需要保持警惕。</p><h2 id="e215" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">初学者</strong></h2><p id="d490" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><em class="lx">注意——我要建议的是反模式，我不建议在生产中使用！</em></p><p id="f819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当开始使用阶跃函数时，完全可以使用Lambda函数、SQS队列、SNS主题等，而不考虑它们属于哪个微服务。<a class="ae ky" href="https://docs.aws.amazon.com/step-functions/latest/dg/workflow-studio.html" rel="noopener ugc nofollow" target="_blank"> workflow studio </a>让您只需从下拉列表中选择一个Lambda函数。您可以使用的功能没有限制，因为微服务是一种逻辑结构。</p><p id="8823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用<a class="ae ky" href="https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/infrastructure-as-code.html" rel="noopener ugc nofollow" target="_blank">基础设施作为代码(IaC) </a>这是一个导出资源的arn并将其导入另一个服务的模板的问题。稍微难一点，但还是比较容易的。</p><p id="5f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有什么可以阻止你使用微服务，它可以完成工作。因此，虽然不推荐，但这通常是解决跨服务边界的最简单的方法。</p><h2 id="e5d6" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">中级</strong></h2><p id="9753" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">虽然直接调用资源可能是一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Anti-pattern" rel="noopener ugc nofollow" target="_blank">反模式</a>，但调用跨服务API却不是。如果您有内部API背后的资源，调用它是绝对可以接受的。调用API提供了<em class="lx">松耦合</em>，这在无服务器和微服务环境中更容易被接受。</p><p id="6fb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Step函数目前不支持本地调用外部API，因此您有两种选择来将这种方法合并到您的工作流中。</p><p id="0ce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lambda函数可以根据您的需要简单或复杂。如果您想在将响应返回到状态机之前对其进行转换，请执行此操作。如果你想直接通过，这也是一个选择。这种方法的目标是使用类似于<a class="ae ky" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>或<a class="ae ky" href="https://pypi.org/project/requests/" rel="noopener ugc nofollow" target="_blank">请求</a>的东西来调用API。</p><p id="f410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTTP集成实质上是从微服务中的API网关创建一个代理来调用外部端点。当走这条路线时，您可以调用<em class="lx"> API网关调用</em> SDK集成来直接进行调用。这提供了比Lambda函数更高性能的解决方案。</p><h2 id="d27f" class="nl mu it bd mv nm nn dn mz no np dp nd li nq nr nf lm ns nt nh lq nu nv nj nw bi translated"><strong class="ak">高级</strong></h2><p id="ea8b" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">如果您需要进行的跨服务调用是一个长时间运行或多步骤的过程，那么您不需要上面列出的同步解决方案。相反，您需要暂停执行并等待响应才能继续。<a class="ae ky" href="https://twitter.com/sheenbrisals" rel="noopener ugc nofollow" target="_blank"> Sheen Brisals </a>向我们展示了如何<a class="ae ky" href="https://medium.com/lego-engineering/how-to-build-better-orchestrations-with-aws-step-functions-task-tokens-and-amazon-eventbridge-19a68eeda461" rel="noopener">使用EventBridge做到这一点</a>。</p><p id="97c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">EventBridge集成将触发一个事件，暂停状态机的执行，等待另一个服务处理一个事件，然后在另一个服务触发事件时恢复工作流。这被称为<a class="ae ky" href="https://docs.aws.amazon.com/step-functions/latest/dg/callback-task-sample-sqs.html" rel="noopener ugc nofollow" target="_blank">回调模式</a>。</p><p id="e099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回调模式是在微服务之间提供松散耦合的另一种方式。它确实增加了解决方案的复杂性，但是提供了最大的灵活性和最高的可靠性。只要确保您配置了<a class="ae ky" href="https://docs.aws.amazon.com/step-functions/latest/dg/sfn-stuck-execution.html" rel="noopener ugc nofollow" target="_blank">状态机heartbeat </a>以便在另一个微服务出错时中止执行。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="177a" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">结论</h1><p id="8cca" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在一些情况下，Step函数可能不是创建工作流时使用的最佳AWS服务。如何处理大型有效负载、高容量阵列或跨服务边界取决于您的舒适程度。</p><p id="a35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你追求超出舒适水平的选择，请记住，正确的解决方案不是可行的，而是可行的<em class="lx">和你能够有效保持</em>的方案。这意味着如果有一个缺陷，你必须知道如何解决一个问题并深入跟踪。</p><blockquote class="oi"><p id="e46d" class="oj ok it bd ol om on oo op oq or lu dk translated"><em class="oh">有时候跟着Lambda走会更好。</em></p></blockquote><p id="ee4a" class="pw-post-body-paragraph kz la it lb b lc os ju le lf ot jx lh li ou lk ll lm ov lo lp lq ow ls lt lu im bi translated">基于你的工程团队的技能，选择更简单的方法并不是一件坏事。我们都在不断努力提高技能。通过新的云特性、新的架构模式或全新的服务来提高我们的舒适度是在云中工作的一部分。我们喜欢它。</p><p id="f8ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多用例中，阶跃函数是Lambda函数的一个令人惊奇的替代品。它们在异步工作流中提供了<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-better-serverless-apis-by-going-storage-first-597784f8f399">高度的可追溯性</a>，并且在某些情况下<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/lambda-vs-step-functions-the-battle-of-cost-and-performance-5f008045e2ab">比Lambda函数</a>运行起来更便宜。甚至有办法消除臭名昭著的无服务器可以从直接将API Gateway集成到一个express状态机开始。</p><p id="a038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阶跃函数被证明是无服务器世界的瑞士军刀。它使消费者能够快速方便地做许多事情。它并不总是对初学者最友好的。</p><p id="5fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还没有尝试过Step函数，我强烈建议您尝试一下。优点远大于缺点，并且它们提供了对服务器端操作的高度可见性。您可以<a class="ae ky" href="https://github.com/allenheltondev" rel="noopener ugc nofollow" target="_blank">访问我的GitHub页面</a>查看各种示例。</p><p id="a52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>