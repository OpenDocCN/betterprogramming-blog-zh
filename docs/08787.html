<html>
<head>
<title>How To Pass Data Between Fragments Using Jetpack’s Navigation Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Jetpack的导航组件在片段之间传递数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-pass-data-between-fragments-using-jetpacks-navigation-component-55a2d663cd66?source=collection_archive---------3-----------------------#2021-06-11">https://betterprogramming.pub/how-to-pass-data-between-fragments-using-jetpacks-navigation-component-55a2d663cd66?source=collection_archive---------3-----------------------#2021-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="568d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带通信的向前和向后Android导航</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbc4e65580e2cf9433a4070ddef8b8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VL7HRY8kdir4ZTlo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@benchaccounting?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">钳工</a>对<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">去毛刺</a>拍照。</p></figure><p id="4ac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将学习如何在向前和向后导航中在<code class="fe lv lw lx ly b">Fragments</code>之间传递数据。您将了解到<code class="fe lv lw lx ly b">navArgs</code>的概念以及如何将<code class="fe lv lw lx ly b">LiveData</code>与<code class="fe lv lw lx ly b">Navigation</code>组件中的一个键一起使用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d76b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">先决条件</h1><p id="ae1c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这篇文章讲述了如何使用Jetpack <code class="fe lv lw lx ly b">Navigation</code>组件在目的地之间传递数据，因此需要了解<code class="fe lv lw lx ly b">Navigation</code>组件的基本知识以及如何使用它。如果您不熟悉<code class="fe lv lw lx ly b">Navigation</code>组件，请查看以下链接:</p><ul class=""><li id="e8ac" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/jitpack-navigation-component-in-android-944165c35f54">Android中的JetPack导航组件</a></li><li id="849c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/exploring-real-time-use-cases-of-jetpack-navigation-component-e58dd8dfba5">探索Jetpack导航组件的实时用例</a></li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="507c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">概观</h1><p id="d030" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">屏幕之间的导航是任何Android应用的基本功能之一。我们通常通过<code class="fe lv lw lx ly b">Intents</code>或<code class="fe lv lw lx ly b">Fragment</code>交易来完成。尽管如此，传统的导航系统并没有为现代Android应用程序开发进行优化。</p><p id="8562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要手动维护后台堆栈并处理好一切。即使在这种情况下，我们也没有像iOS应用程序开发中那样的花哨的故事板来代表用户的流动。这使得Android开发有点过时，给开发人员带来了很多负担。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3196" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">介绍</h1><p id="608a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">组件是Android应用开发<em class="nr">中所有导航相关问题的一站式解决方案。</em> It <em class="nr"> </em>为应用内导航提供了一个健壮的导航框架。</p><p id="61e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jetpack的<code class="fe lv lw lx ly b">Navigation</code>组件带来了一种新的导航模式，导航图代表了用户的导航流程(就像iOS中的故事板)。它还会处理<code class="fe lv lw lx ly b">Fragment</code>事务、动画、后台堆栈等等。</p><p id="5bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是第一次接触<code class="fe lv lw lx ly b">Navigation</code>组件，我建议您浏览一下前面提到的文章。</p><p id="0d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们马上进入正题吧。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6cc6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用导航系统向前导航</h1><p id="37c6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在组件之间发送数据和导航一样重要。在<code class="fe lv lw lx ly b">Navigation</code>组件出现之前，Android开发者通过与<code class="fe lv lw lx ly b">Activity Intent</code>的附加组件和与<code class="fe lv lw lx ly b">Fragments</code>的争论来实现。它是我们内部用来发送数据的包。</p><p id="45dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">bundle只不过是一个支持原始数据类型的键值对数组(类似于hashmap)。包的优势之一是我们可以通过可打包和序列化技术发送用户定义的对象。</p><p id="1d77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在有了<code class="fe lv lw lx ly b">Navigation</code>组件，我们有了安全的参数。这是一个Gradle插件，用于在目的地之间传递数据，使用类型安全的默认值，并在编译时执行一些运行时操作。</p><h2 id="ec6a" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">综合</h2><p id="d199" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在顶层gradle文件中的dependency节点下添加以下行:</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="9458" class="ns mh it ly b gy oi oj l ok ol">ext.nav_version = "2.3.5"<br/>classpath "android.arch.navigation:navigation-safe-args-gradle-plugin:$nav_version"</span></pre><p id="f27a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后通过添加以下行将插件导入模块级Gradle文件:</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="aa09" class="ns mh it ly b gy oi oj l ok ol">apply plugin: 'androidx.navigation.safeargs'</span></pre><p id="4362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，要生成只适合Kotlin模块的Kotlin代码，请添加:</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="972a" class="ns mh it ly b gy oi oj l ok ol">apply plugin: "androidx.navigation.safeargs.kotlin"</span></pre><p id="3fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。我们完成了整合。</p><h2 id="f202" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">使用</h2><p id="0d1c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们从定义导航图中的目的地所需的参数开始。首先，看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单明了的实现，不需要任何解释。我们可以根据需要向任何目的地添加任意数量的参数。这将生成基于导航图中给定参数的函数。</p><p id="8bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们完成了参数的声明，我们就可以在<code class="fe lv lw lx ly b">Navigation</code>组件动作中使用它们来传递实际的参数。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="6099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在目的端，我们可以利用Kotlin的安全Args插件和委托特性来轻松检索数据。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7525" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">与SavedStateHandle的反向通信</h1><p id="b160" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在<code class="fe lv lw lx ly b">Navigation</code> 2.3.0-alpha02及更高版本中，我们可以从<code class="fe lv lw lx ly b">NavBackStackEntry</code>访问<code class="fe lv lw lx ly b">SavedStateHandle</code>。就像bundle一样，<code class="fe lv lw lx ly b">SavedStateHandle </code>是一个发送和检索数据的键值对。主要优点是它可以经受住配置更改和进程死亡。</p><p id="59a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SavedStateHandle </code>的一个主要优点是，当当前数据从堆栈中弹出时，我们可以用它将数据发送到源目的地(就像我们在Android <code class="fe lv lw lx ly b">Activities</code>中使用<code class="fe lv lw lx ly b">setResult</code>一样)。</p><h2 id="66c4" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">使用</h2><p id="f686" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了更好地理解它，让我们看一个简单的用例，用户从<code class="fe lv lw lx ly b">Fragment A</code>导航到<code class="fe lv lw lx ly b">Fragment B</code>。现在从<code class="fe lv lw lx ly b">Fragment B</code>开始，我们需要向<code class="fe lv lw lx ly b">Fragment A</code>发送数据。</p><p id="2abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将数据发送回<code class="fe lv lw lx ly b">Fragment A</code>，首先，我们需要在<code class="fe lv lw lx ly b">Fragment A</code>中用一个唯一的键注册<code class="fe lv lw lx ly b">SavedStateHandle</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在片段A中注册监听器</p></figure><p id="04c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">Fragment B</code>中，我们可以使用<code class="fe lv lw lx ly b">previousBackStackEntry</code>发送数据。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。反向通信完成。当我们使用<code class="fe lv lw lx ly b">LiveData</code>进行反向通信时，我们需要意识到发布的数据会被任何新的观察者观察到。如果您只想处理一次数据，那么您需要调用<code class="fe lv lw lx ly b">SavedStateHandle</code>上的<code class="fe lv lw lx ly b">remove()</code>来清除结果。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f534" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="f08e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Jetpack的<code class="fe lv lw lx ly b">Navigation</code>组件是在Android应用中实现导航的下一代工具。同时，在Android应用程序中，在组件之间传递数据以执行特定操作或者将某种标志传递回源以刷新屏幕是一项常见的任务。这两种情况在本文中称为前向和后向通信。不要通过变通方法来实现这些基本任务。您应该使用本文中提到的推荐方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7239" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">奖金</h1><p id="415f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我最近看到了由<a class="ae ky" href="https://medium.com/u/d255c4fc9d76?source=post_page-----4c9f44d04e68--------------------------------" rel="noopener"> Satya Pavan Kantamani </a>发表的这篇关于Jetpack Compose的优秀文章:</p><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/jetpack-compose-androids-modern-toolkit-for-building-ui-82e67d384c26"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">Jetpack Compose简介:Android的未来UI工具包</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">告别XML布局，采用现代技术</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">better编程. pub</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><p id="6a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>