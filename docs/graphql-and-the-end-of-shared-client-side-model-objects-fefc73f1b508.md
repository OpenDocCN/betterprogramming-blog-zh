# GraphQL 和共享客户端模型对象的结束

> 原文：<https://betterprogramming.pub/graphql-and-the-end-of-shared-client-side-model-objects-fefc73f1b508>

## 如何使用 GraphQL、React 和 Swift 来准确获取您的应用程序所需的内容

![](img/00568b713f9164c9d41244c4a7cc32ec.png)

在传统的客户机-服务器开发中，客户机端模型通常与服务器端模型没有太大的不同。

他们应该吗？

标准的 RESTful API 可能会序列化服务器端用户模型，如下所示:

同一用户模型类型的实例可以通过多种途径出售，例如:

1.  `/me` —返回当前认证用户的路由
2.  `/friends` —返回当前用户好友的路线

RESTful APIs 本质上不是类型安全的，所以前端开发人员通常会通过查看 API 文档(并希望它是准确的)，或者通过观察 HTTP 流量本身来了解这些路由都返回相同的`User`类型的对象。

认识到这一点后，可以将类似下面的类型定义手动添加到客户端应用程序中，当解析来自这两种途径之一的响应体时，可以填充它的实例:

这个共享的、规范的`User`模型可以被前端应用程序中需要用户属性子集的任何部分使用。您可以很容易地在客户端键值存储或关系数据库中缓存这些`User`实例。

假设您的应用程序包括以下功能(并且复杂性在不断增加):

1.  呈现用户配置文件(需要所有用户属性)
2.  查看朋友列表(仅需要用户名和头像)
3.  在导航中显示当前用户的头像(只需要头像)

您的服务器最初将从所有这些要素的路径返回相同的用户有效负载，但这不会扩展得特别好。具有大量属性的模型对于渲染完整的简档是必要的，但是在渲染一长串用户的名字和头像时会有问题。当用户的大部分属性被忽略时，序列化一个完整的用户是不必要的，甚至是一个性能瓶颈。

也许您的 API 开发人员改变了您的服务器，只从`/friends`路径返回用户属性的子集。接下来是对 API 文档的更改，希望您的前端工程师会注意到，这时他们会向客户端代码库添加一个新的类型。也许这种新类型看起来像:

此时，您的前端需要:

1.在处理 HTTP 响应
2 时，跟踪哪些路由出售`User`实例与`SimpleUser`实例。更新其缓存逻辑以支持这两种不同的类型

`User` vs. `SimpleUser`无可否认是一个粗糙而肤浅的区别。如果我们在混合物中加入第三种口味，我们会合理地给它起什么名字？

不叫`SimpleUser`，我们可以把这种新型号叫做`FriendListUser`，以它所提供的功能命名。为每个用例建立单独的用户模型是一种更具可扩展性的方法——我们可能会有很多不同的版本，它们的名字都比“简单”更准确地传达了意图:

*   `FriendListUser`
*   `EditAccountUser`
*   `ProfileUser`
*   `LoggedOutProfileUser`

这里的风险是，在跟踪哪些路线出售哪些模型，以及在建模前端持久层时如何理解所有这些不同的变量方面，我们可能会产生大量的开销。

通过将我们的客户端类型定义更紧密地耦合到我们的 API 规范来减少这种开销将是朝着正确方向迈出的一大步。 [GraphQL](https://graphql.org) 就是一个帮助实现这一点的工具。

## GraphQL

GraphQL 有很多令人喜欢的地方——如果你想要一个全面的概述，我建议你查看一下官方文档。

相对于传统 RESTful 接口的一个优势是 GraphQL 服务器提供强类型模式。这些模式可以通过编程方式进行自省，使您的 API 通过 default⁴.实现自文档化但是这是一篇关于客户端模型的文章，而不是避免陈旧的文档。

更高的模型特异性带来了更高的清晰度和效率，主要的缺点是维护大量模型所涉及的额外工作。让我们更深入地探讨代码生成如何减轻这种负面影响。

通过内省两者:

1.  我们后端 API 的强类型模式
2.  我们前端应用的数据需求

我们可以轻松地为每个单独的用例生成定制的客户端模型。

首先，我们必须了解 GraphQL 查询是如何工作的。在传统的 RESTful API 服务器中，相同的路由总是出售相同的模型。假设我们的 GraphQL 服务器公开了以下两个查询:

1.  `me: User`
2.  `friends: [User]`

虽然两个查询公开了相同的服务器端`User`模型，但是客户机指定了它感兴趣的属性子集，并且只返回这些属性。我们的前端可能会进行以下查询:

服务器将只返回上面指定的属性，即使服务器端用户模型包含的属性比实际请求的多得多。

类似地，该查询将返回不同的子集:

代码生成工具可以自省这些客户端查询以及 API 模式定义，以便:

1.  确保只查询有效的属性(甚至直接在 IDE 中，在编译时验证 API 调用)
2.  生成特定于每个不同查询的客户端模型

在这种情况下，生成的模型将如下所示:

我们的应用程序的每个组件现在都可以提供一个完全适合他们需求的模型，而不需要我们自己维护所有这些类型变化的开销。

## 组件树、查询树

像 [React](https://reactjs.org) 和 [UIKit](https://developer.apple.com/documentation/uikit) 这样的用户界面库允许将封装的组件组合成一个复杂的层次结构。每个组件都有自己的状态需求，其他组件在理想情况下不需要关心这些需求。

这与传统的 RESTful API 开发不一致，在传统的 RESTful API 开发中，单个路由通常会返回大量数据，用于填充组件树的整个分支，而不仅仅是单个节点。

GraphQL 查询片段更好地促进了组件*和*的协同定位，它们的数据需求:

这就产生了一个“查询层次结构”,它与我们的组件层次结构更加一致。

正如 UI 渲染层将遍历组件树以布局我们的完整接口层次结构一样，GraphQL 网络层将把查询和片段聚合到一个单一的、合并的有效负载中，以便从我们的服务器请求。

## 异构缓存变得简单

GraphQL 是一种高级查询语言；虽然您可以使用它来查询 GraphQL *服务器*，但是客户端库，如 [Apollo](https://www.apollographql.com) 和 [Relay](https://facebook.github.io/relay/) 可以充当网络和可选本地 cache⁵.之上的抽象层

(此外，Apollo 和 Relay 还处理代码生成和前面章节中概述的查询片段统一💫)

传统的客户端-服务器应用程序通常以如下所示的逻辑结束:

在本例中，我们通过两种不同的机制查询同一个用户:针对本地数据库的 SQL 和针对远程服务器的 URL 编码的查询字符串。

Apollo 和类似的库允许我们以一种统一的方式更明确地指定我们需要的数据。这一级别的抽象让我们可以委派繁重的工作——检查我们的请求是否可以完全从缓存中完成，如果不能，就增加额外的远程数据。

继续我们的例子:如果您首先进行一个`friends`查询，那么您的缓存用户将只包含`firstName`、`lastName`和`avatar.thumbnail`属性。对这些相同用户之一的后续`me`查询将访问服务器，以便“填充”附加属性— `location`和`avatar.large`。从这一点开始，后续的`friends`或`me`查询可以避免网络往返 altogether⁵.

只要两个用户模型具有相同的惟一标识符，那么它们的属性的哪个子集以什么顺序被获取并不重要。阿波罗会帮我们把它们正常化。

听起来很神奇？不管是好是坏，当然可以。像所有高层次的抽象一样，当它工作时令人惊奇，当它不工作时令人恼火。

但这就是 GraphQL 的承诺；**当一个类型化的模式定义是建立在其上的基础的时候，天空就是工具的极限**。这种性质的工具可以建立一个前提，否则这个前提看起来会非常笨拙——为每一个微小的用例变化建立一个不同的客户端模型类型——不仅可以实现，而且是理想的。

[1]:如果它是使用类似于 [Swagger](https://swagger.io) 的东西生成的，可能性更大；如果您的 API 工程师手动尽最大努力使它保持最新，可能性更小。

[2]:例如，想象一下一个脸书用户包含多少属性。

[3]:更不用说，不尊重你的用户的时间*和*蜂窝数据计划。

[4]:像 [GraphiQL](https://github.com/graphql/graphiql) 这样的工具可以让你准确地看到每个 GraphiQL 查询所提供的服务器端模型。

[5]:当然，这取决于您的缓存策略。