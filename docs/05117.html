<html>
<head>
<title>SwiftUI Tips and Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI提示和技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-tips-and-tricks-c7840d8eb01b?source=collection_archive---------5-----------------------#2020-06-10">https://betterprogramming.pub/swiftui-tips-and-tricks-c7840d8eb01b?source=collection_archive---------5-----------------------#2020-06-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="510f" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">提升SwiftUI技能的鲜为人知的功能</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/a6b382bc17c954f3835c3f8e2d8bb9d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gnqSTcmtBDaaUVnk"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">汤米·范·凯塞尔的照片🤙 on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>。</p></figure><p id="7687" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI改变了我们在iOS应用程序中构建用户界面的方式。声明性的状态驱动框架简明易懂，这主要归功于支持DSL语言的函数构建器。</p><p id="d5a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">自从它首次亮相以来，已经出现了大量的功能，跟踪一些很酷的技巧可能会成为一个挑战。谢天谢地，这篇文章正是您在这种情况下需要的备忘单。</p><p id="ab74" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的部分中，我整理了一个提示和技巧列表，应该可以帮助您轻松构建SwiftUI应用程序。让我们开始吧。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="99ca" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">当您有不同类型时，将视图包装在任意视图或组中</h1><p id="2d28" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><code class="fe na nb nc nd b">some</code>关键字是在Swift 5.1中引入的，用于定义不透明类型。它允许编译器根据返回值决定函数的具体类型。</p><p id="541b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然这对于单分支代码或者视图类型相似的情况来说都很好，但是当多分支代码具有不同的视图时，这将导致编译器错误。</p><p id="ee90" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">具体来说，SwiftUI接口不能确定单一的不透明类型。我们可以通过将视图集包装在一个<code class="fe na nb nc nd b">Group</code>或<code class="fe na nb nc nd b">AnyView</code>中来解决这个问题。</p><p id="f098" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">AnyView</code>确保有一个单一的不透明返回类型，但确保不要太频繁地使用它。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/40cf0b0c9507a091dab1057feee58279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zjho_IHsuGfVvSFEvvpTKg.png"/></div></div></figure><p id="2369" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当在SwiftUI主体中使用switch语句时，上面的提示也很有用。但是，在这种情况下，更好的替代方法是在单独的函数中提取switch语句。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4d88" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">通过解耦独立视图，防止在状态更改时重新加载整个SwiftUI主体</h1><p id="bd0e" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">作为一个状态驱动的框架，每当状态改变时，SwiftUI主体中的所有视图都会刷新——包括没有绑定到该状态的视图。</p><p id="9a35" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有时候，你可能希望有一种方法来避免刷新整个身体。幸运的是，您可以通过分离不依赖于状态的视图来做到这一点，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/b383c309aeb476209b24b62c8fa413fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p76lUipYk5UWbfa8BIdj7A.png"/></div></div></figure><p id="517c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，<code class="fe na nb nc nd b">RandomText</code>不再在底部的工作表被显示或关闭时刷新文本。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="a730" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">保持自定义视图的初始化代码块简短</h1><p id="7e92" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">值得注意的是，每次超级视图刷新时，都会调用SwiftUI主体中自定义视图的构造函数。然而，这并不意味着整个定制视图得到了重建。</p><p id="1eb9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，一个定制的SwiftUI camera视图每次都会调用它的<code class="fe na nb nc nd b">init</code>块，但不会每次都重建<code class="fe na nb nc nd b">AVFoundation</code>捕获会话(除非您正在传递一个触发其变化的状态属性包装器)。</p><p id="c04b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，确保<code class="fe na nb nc nd b">init</code>街区不会太重是个好主意。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9818" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">高效使用SwiftUI图像</h1><p id="85f1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">除了SwiftUI，iOS 13还引入了SF符号，它拥有一系列图像。我们可以在SwiftUI图像中使用类似<code class="fe na nb nc nd b">font</code>的修改器轻松定制它们，这些修改器的应用方式与SwiftUI <code class="fe na nb nc nd b">Text</code>相同。</p><h2 id="3af7" class="nf me iu bd mf ng nh dn mj ni nj dp mn lj nk nl mp ln nm nn mr lr no np mt nq bi translated">杠杆插值</h2><p id="4b92" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">通常，您的图像资产需要将内容拉伸到超出其大小。您可能会得到模糊的图像，因为默认情况下起作用的插值会混合像素。</p><p id="9c4a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过将<code class="fe na nb nc nd b">interpolation</code>修改器设置为<code class="fe na nb nc nd b">none</code>，可以确保混合不会发生，像素化图像是平滑的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nr"><img src="../Images/04ecdc878315d8ba26f5cd81671b4de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tiH2Z1D5f_d74jBd--4wkQ.png"/></div></div></figure><h2 id="1364" class="nf me iu bd mf ng nh dn mj ni nj dp mn lj nk nl mp ln nm nn mr lr no np mt nq bi translated">在导航视图中处理图像</h2><p id="496c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">SwiftUI图像的另一个关键场景是当它们嵌入到<code class="fe na nb nc nd b">NavigationLink</code>中时。默认情况下，图像会被淡色(放置在<code class="fe na nb nc nd b">NavigationView</code>中时为蓝色)遮盖。为了避免这种重叠，我们需要在<code class="fe na nb nc nd b">NavigationLink</code>上设置<code class="fe na nb nc nd b">.buttonStyle(PlainButtonStyle())</code>，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ns"><img src="../Images/07b00cfb1611bc407178a6928ee9eb24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-goy_bQkJBwWxKlMijg29g.png"/></div></div></figure><p id="67e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是在<code class="fe na nb nc nd b">NavigationLink</code>上设置和不设置<code class="fe na nb nc nd b">PlainButtonStyle</code>时的输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nt"><img src="../Images/19f58784819204526312b2e8844a3ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*7VwNVGDJCtTLAI0Q0uK8Dw.png"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="162a" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">处理多个预览</h1><p id="1a6f" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们知道SwiftUI为我们提供了实时预览，但更有趣的是它能够显示多个预览——无论是黑暗模式还是不同的设备型号。</p><p id="abec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个例子，展示了在明暗模式下相同的SwiftUI视图。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/0bc0fd38be02db29f1168909a3baa3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CMcM2mgO5fwWI15SrLPdA.png"/></div></div></figure><p id="9feb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认情况下，预览中的黑暗模式是半工作的。不要像上面那样设置系统背景色，你可以参考<a class="ae kz" href="https://stackoverflow.com/questions/56591669/not-able-to-achieve-dark-mode-using-swiftui" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出帖子</a>来使用视图修改器扩展作为修复。</p><p id="27f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还可以<code class="fe na nb nc nd b">Group</code>内容预览或使用<code class="fe na nb nc nd b">ForEach</code>循环在不同的设备中显示UI，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/ad92d76011a547cb183952f71eb76bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNtcfIgMwg6tQWSJ1uKW6A.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2066" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">利用框架修改器填充视图</h1><p id="5bd0" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">默认情况下，视图在屏幕上占据最小的空间。例如，下面的TextView会自我包装:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/9fcb369f288c91a7a62034b635baf78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOwIOV0-0tsgxwqAWlLVjg.png"/></div></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nw"><img src="../Images/4f3500631c38cf997b65f4efcd717e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*hOYmKQZdcGNVhaXLBWH86g.png"/></div></figure><p id="b671" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了扩展视图以填充超级视图空间，我们可以利用<code class="fe na nb nc nd b">frame</code>修改器并将其中的<code class="fe na nb nc nd b">maxWidth</code>和<code class="fe na nb nc nd b">maxHeight</code>属性设置为<code class="fe na nb nc nd b">infinity</code>，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nx"><img src="../Images/64f65a4ad09ac5603a33497cac40e16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgLjNBiCOYglD79_Ny1xsw.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="41cf" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">使用自定义修饰符和扩展</h1><p id="4f65" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">通过使用视图扩展，我们可以扩展内置功能，从而简化代码并提高可读性。例如，将视图包装在一个<code class="fe na nb nc nd b">AnyView</code>中或者嵌入到一个<code class="fe na nb nc nd b">NavigationView</code>中是一种相当常见的做法。我们可以像这样为它们创建扩展:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/77b1c78bc31cba1bf638caac83b8a154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z56Fw82-M7-gsuN70pblVA.png"/></div></div></figure><p id="c184" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">受此启发，您也可以为SwiftUI图像创建一个扩展，并设置一个默认的占位符图像。</p><p id="46be" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI为我们提供了一系列视图修改器，可以作为构建模块链接在一起。但是有时，您最终会得到一组相同的修改器——特别是在定制视图时。这可能会产生样板代码，可以通过使用自定义视图修饰符来避免。</p><p id="4933" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的代码显示了一个创建自定义样式的视图修改器:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/dee4bf0167a5acef6ddbc92da5d1bbc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCcGBNXLOoLfKUFQUoHoUQ.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="aefb" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">额外小费</h1><p id="8d39" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们在SwiftUI中探索了许多技巧和诀窍，我希望它们能帮助您进一步开发。</p><p id="348f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，在SwiftUI中编写代码时出错会停止预览，我们需要再次按下“恢复”按钮。由于这种情况经常发生，您可以使用Option + Cmd + P快捷键来快速恢复。</p><p id="72b0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>