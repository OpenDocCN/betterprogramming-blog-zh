<html>
<head>
<title>Use Custom Debug Descriptions to Make Debugging Easier in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用自定义调试描述使Swift中的调试更加容易</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-custom-debug-descriptions-to-make-debugging-easier-in-swift-7762ccf140e4?source=collection_archive---------8-----------------------#2020-05-05">https://betterprogramming.pub/use-custom-debug-descriptions-to-make-debugging-easier-in-swift-7762ccf140e4?source=collection_archive---------8-----------------------#2020-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b091" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过为您的自定义类型实现单一协议来改进“po对象”描述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b77fabd084714dc63309d155d10f429b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dnFchOUd7ikAJ-aT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯托弗·伯恩斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义调试说明可以帮助您调试自己的自定义对象、结构、错误和其他类型。每当你打印出一个对象，你可能会得到一些基本信息，但这些信息并不能真正帮助你解决问题。打印出的结构显示了所有的值，而在大多数情况下，您可能只对其中的一个属性感兴趣。</p><p id="7b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift为任何带有<code class="fe lv lw lx ly b">String(reflecting:)</code>初始值设定项的类型提供了默认的调试文本表示。<code class="fe lv lw lx ly b">debugPrint(_:)</code>方法用于不提供自身表示的类型。尽管这在大多数情况下已经很好地工作了，但是通过为您经常交互的类型实现您自己的自定义表示，您可以受益更多并加快调试。</p><p id="03db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用<code class="fe lv lw lx ly b">print</code>和<code class="fe lv lw lx ly b">debugPrint</code>方法，稍后将对它们进行更详细的描述。注意，在LLDB调试会话中使用<code class="fe lv lw lx ly b">po object</code>与在代码中使用<code class="fe lv lw lx ly b">debugPrint</code>是一致的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8574" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Swift中提供的默认文本表示</h1><p id="edd7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们开始添加改进之前，最好了解一下Swift默认为我们提供了什么。为此，我们将回顾一些常用的类型，并使用<code class="fe lv lw lx ly b">print()</code>和<code class="fe lv lw lx ly b">debugPrint</code>方法。这两种打印方法几乎相同，但是<code class="fe lv lw lx ly b">debugPrint</code>方法允许您有选择地打印出更详细的信息。我们稍后会复习几个例子。</p><p id="78a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从下面定义为类的<code class="fe lv lw lx ly b">BlogPost</code>实体开始例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们将它打印出来，我们会得到以下结果:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="b628" class="nj mh it ly b gy nk nl l nm nn">let blogPost = BlogPost(title: "Improved debugging", body: "Help yourself in those hard times.")<br/>print(blogPost) <br/>// Prints: BlogPost<br/>debugPrint(blogPost) <br/>// Prints: BlogPost</span></pre><p id="7e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将它更改为struct已经改进了print语句:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在大多数情况下可能就足够了。</p><p id="0cb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不包括打印出的<code class="fe lv lw lx ly b">NSObject</code>的实例，比如继承自该类型的<code class="fe lv lw lx ly b">UIViewController</code>。它通常会产生无用的信息:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="c394" class="nj mh it ly b gy nk nl l nm nn">final class BlogPostViewController: UIViewController { }<br/>let viewController = BlogPostViewController()<br/>print(viewController) <br/>// Prints: &lt;BlogPostViewController: 0x7ff77ac0c720&gt;<br/>debugPrint(viewController) <br/>// Prints: &lt;BlogPostViewController: 0x7ff77ac0c720&gt;</span></pre><p id="42e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到这里还有改进的空间，因为我们不知道这个视图控制器代表什么。默认的定制调试描述并不能帮助我们改进调试。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="71e3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">使用CustomDebugStringConvertible改进调试打印</strong></h1><p id="6f86" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">CustomDebugStringConvertible</code>协议的出现是为了改进定制对象的调试日志。它由<code class="fe lv lw lx ly b">print</code>和<code class="fe lv lw lx ly b">debugPrint</code>方法使用，除非使用了<code class="fe lv lw lx ly b">CustomStringConvertible</code>协议。为了解释这一点，我们为视图控制器实例添加了对两个协议的一致性。</p><p id="55be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先定义视图控制器，并用一个<code class="fe lv lw lx ly b">BlogPost</code>实例初始化它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印此实例会产生以下日志:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="52bb" class="nj mh it ly b gy nk nl l nm nn">print(viewController) <br/>// Prints: &lt;BlogPostViewController: 0x7fb390c127f0&gt;<br/>debugPrint(viewController) <br/>// Prints: &lt;BlogPostViewController: 0x7fb390c127f0&gt;</span></pre><p id="2602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先通过返回博客文章的标题和正文来添加对<code class="fe lv lw lx ly b">CustomDebugStringConvertible</code>协议的一致性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bb22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用此代码示例将导致以下错误:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="8a47" class="nj mh it ly b gy nk nl l nm nn">Redundant conformance of ‘BlogPostViewController’ to protocol ‘CustomDebugStringConvertible’</span></pre><p id="7a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<code class="fe lv lw lx ly b">NSObject</code>实例已经符合<code class="fe lv lw lx ly b">CustomDebugStringConvertible</code>协议。因此，我们可以省去协议定义，只需覆盖<code class="fe lv lw lx ly b">debugDescription</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fbaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次打印出相同的实例将为我们提供更好的信息:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="1da0" class="nj mh it ly b gy nk nl l nm nn">print(viewController) <br/>// Prints: &lt;BlogPostViewController: 0x7fa013406810&gt; represents the post with title "Improved debugging" and body "Help yourself in those hard times."<br/>debugPrint(viewController) <br/>// Prints: &lt;BlogPostViewController: 0x7fa013406810&gt; represents the post with title "Improved debugging" and body "Help yourself in those hard times."</span></pre><p id="dcd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向<code class="fe lv lw lx ly b">NSObject</code>的实例添加定制的调试描述是额外有价值的，因为默认的表示通常根本没有用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="38ad" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在非调试打印中隐藏敏感数据</h1><p id="6819" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时，您只想在调试会话期间打印出某些数据。如果你的应用程序支持的话，常规的打印语句可能会在用户可见的日志中结束。例如，我们正在使用<a class="ae ky" href="https://github.com/WeTransfer/Diagnostics" rel="noopener ugc nofollow" target="_blank">诊断框架</a>来帮助我们调试用户会话，在这些会话中，我们的所有日志都可能被阅读该报告的用户看到。</p><p id="1a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以利用<code class="fe lv lw lx ly b">CustomStringConvertible</code>来添加日志之间的区别。例如，我们可能希望在常规打印过程中隐藏文章正文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们没有直接添加协议继承，因为这已经由<code class="fe lv lw lx ly b">NSObject</code>再次完成了。再次打印出相同的实例向我们展示了对<code class="fe lv lw lx ly b">print</code>和<code class="fe lv lw lx ly b">debugPrint</code>的两种不同描述:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="9d69" class="nj mh it ly b gy nk nl l nm nn">print(viewController) <br/>// Prints: &lt;BlogPostViewController: 0x7fa42fe09bf0&gt; represents the post with title "Improved debugging"<br/>debugPrint(viewController) <br/>// Prints: &lt;BlogPostViewController: 0x7fa42fe09bf0&gt; represents the post with title "Improved debugging" and body "Help yourself in those hard times."</span></pre><p id="a53d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe lv lw lx ly b">print</code>方法使用了<code class="fe lv lw lx ly b">description</code>属性，而<code class="fe lv lw lx ly b">debugPrint</code>使用了<code class="fe lv lw lx ly b">debugDescription</code>属性。在使用这些协议创建定制调试描述时，了解这一区别既重要又有用。</p><p id="90d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用<code class="fe lv lw lx ly b">super.description</code>，因为使用<code class="fe lv lw lx ly b">self</code>会导致使用反射API，而反射API使用<code class="fe lv lw lx ly b">description</code>，反射API使用我们的自定义描述，这是一个无限循环。打印出实例仍然很有用，这样你就可以知道对象的类型和内存地址。</p><p id="58b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子可以通过重用<code class="fe lv lw lx ly b">description</code>值得到更好的改进:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="de04" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">改进了Swift中错误类型的记录</h1><p id="9930" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">相同的协议可用于Swift中的任何类型，如错误。我们可以为自定义错误类型添加改进的日志记录支持，并显示解释失败的更详细的描述:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d559" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">向结构类型添加改进的日志记录</strong></h1><p id="d707" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">尽管结构在默认情况下有很好的表示，但我们可能还是想通过添加自定义的调试描述来改进这些表示，以便以更有意义的方式打印出值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3d24" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="a3b0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在大多数情况下，调试已经很耗时了。任何可以帮助我们更快、更容易地解决问题的东西都有很大的价值。我们可以区分调试打印和常规打印，以便只打印出对阅读我们日志的用户不敏感的数据。这样做是非常有价值的，因为LLDB会话中的<code class="fe lv lw lx ly b">po object</code>使用了相同的<code class="fe lv lw lx ly b">debugDescription</code>。</p><p id="0fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>