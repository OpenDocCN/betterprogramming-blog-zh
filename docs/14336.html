<html>
<head>
<title>Factory: Multiple Module Registration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂:多模块注册</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/factory-multiple-module-registration-f9d19721a31d?source=collection_archive---------2-----------------------#2022-11-30">https://betterprogramming.pub/factory-multiple-module-registration-f9d19721a31d?source=collection_archive---------2-----------------------#2022-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c224" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在初始化任何东西之前初始化所有东西？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8a0e74a6f221badbfea4f958e1aa4c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7Bd2ARqF9P_ggCLSboF5w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">苏珊·霍尔特·辛普森在<a class="ae ky" href="https://unsplash.com/s/photos/blocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="c400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您想要使用一个依赖注入系统，比如具有多个模块的Factory，您经常会遇到“谁先来”的困境。</p><p id="3308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设ModuleP指定了一个抽象的<code class="fe lv lw lx ly b">AccountLoading</code>协议。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="5801" class="md me it ly b be mf mg l mh mi">// ModuleP<br/>public protocol AccountLoading {<br/>    func load() -&gt; [Account]<br/>}</span></pre><p id="0089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们有一个会计模块ModuleA，它显示我们的帐户，但是需要其中一个加载器来加载它们。</p><p id="65f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们还有一个模块，我们称之为ModuleB，它知道如何构建我们需要的任何类型的加载程序。</p><p id="b7ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意ModuleA和ModuleB是独立的。双方都不了解对方，但都直接依赖于我们的模型和协议大师ModuleP。</p><p id="2e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种典型的模块化合同模式。</p><p id="19a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们要开发一个应用程序。那么，当ModuleA对ModuleB一无所知时，它如何获得帐户加载器的实例呢？</p><p id="bc46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，这篇<em class="mj">是</em>一篇关于依赖注入的文章，所以让我们开始吧。</p><h2 id="fc75" class="mk me it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">分解器</h2><p id="2058" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在我早期的依赖注入系统<a class="ae ky" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank"> Resolver </a>中，这真的不是问题。两个模块都将导入Resolver，ModuleA中的某些东西在需要时会简单地向它请求一个<code class="fe lv lw lx ly b">AccountLoading</code>的实例。</p><p id="fcef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个注入属性包装器的例子。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="2d8f" class="md me it ly b be mf mg l mh mi">public class ViewModel: ObservableObject {<br/>    @Injected var loader: AccountLoading<br/>    @Published var accounts: [Account] = []<br/>    func load() {<br/>        accounts = loader.load()<br/>    }<br/>}</span></pre><p id="ffee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们很好。嗯，我的意思是，只要<em class="mj">某人</em>在这个视图模型被实例化之前和<em class="mj">在</em>注入的属性包装器请求它需要的实例之前已经注册了一个<code class="fe lv lw lx ly b">AccountLoading</code>的实例，我们就很好。</p><p id="15f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果他们没有…嗯…我们就要坠毁了。这当然是一个缺点，但是一般来说，在第一次尝试运行和测试代码时，忘记注册是很明显的。</p><p id="24e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我想做得更好，所以我创建了<a class="ae ky" href="https://github.com/hmlongco/Factory" rel="noopener ugc nofollow" target="_blank">工厂</a>。</p><h2 id="a680" class="mk me it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">编译时安全的</h2><p id="08ea" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">工厂承诺编译时安全。</p><p id="eebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怎么会？嗯，工厂通过确保工厂的存在来提供您正在寻找的东西来实现这一点。要做到这一点，你需要将适当的工厂对象添加到一个容器中……这个容器又必须有一个工厂闭包，当被请求时，它会提供这个对象的一个实例。</p><p id="a16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在正常的应用程序中，工厂注册通常是这样的。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="aa96" class="md me it ly b be mf mg l mh mi">extension Container {<br/>    public static let accountLoader = Factory&lt;AccountLoading&gt; { AccountLoader() }<br/>}</span></pre><p id="2134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器存在。类型为<code class="fe lv lw lx ly b">AccountLoading</code>的工厂存在。并且提供该类型实例的clousure是存在的。因此，我们保证编译时和运行时都是安全的。否则代码根本无法编译。</p><p id="8dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果模块既定义了我们的协议<em class="mj">又实现了协议</em>，那么这种类型的注册也可以在模块化应用中工作。协议类型和工厂都是公共的，而实现类型<code class="fe lv lw lx ly b">AccountLoader</code>被定义为模块内部的，所以它被安全地隐藏起来。</p><p id="df9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们的跨模块应用中，我们不能这样做。</p><p id="3e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该协议在ModuleP中定义。具体类型<code class="fe lv lw lx ly b">AccountLoader</code>存在于ModuleB…但是ModuleA不知道。这件事<em class="mj">不可能</em>知道。</p><p id="9d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是ModuleA中的代码需要能够看到工厂才能解决这个问题。而且那个工厂<em class="mj">必须</em>有个定义。</p><p id="7526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谁在一垒？</p><h2 id="6f74" class="mk me it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">可选注册</h2><p id="2f6b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在工厂中，解决这些问题的一般方法是让我们的工厂提供一种可选的类型。所以在ModuleA中我们会指定这个。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="31fd" class="md me it ly b be mf mg l mh mi">extension Container {<br/>    public static let accountLoader = Factory&lt;AccountLoading?&gt; { nil }<br/>}</span></pre><p id="04a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是该模块中的代码用来请求帐户加载程序的实例。这意味着我们基于工厂的视图模型代码现在看起来像这样。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="2bd5" class="md me it ly b be mf mg l mh mi">class ViewModel: ObservableObject {<br/>    @Injected(Container.accountLoader) var loader<br/>    @Published var accounts: [Account] = []<br/>    func load() {<br/>        guard let loader else { return }<br/>        accounts = loader.load()<br/>    }<br/>}</span></pre><p id="1de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意load函数中的额外保护，确保我们实际上拥有我们需要的加载程序。更重要的是，可选类型的使用确保了我们的应用程序仍然是编译时安全的。如果，不知何故，有些人忘记注册一些东西，而我们最终什么都没有，我们的应用程序可能无法正常运行…但至少它不会崩溃。</p><p id="1e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何让事情运转起来呢？再说一次，ModelA拥有工厂。但是ModuleB包含了我们的网络代码，它知道如何创建一个帐户加载器。</p><p id="f2fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案相对简单。在主应用程序的某个地方，我们只需要写一点点代码来将我们的两个模块连接在一起。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="13ba" class="md me it ly b be mf mg l mh mi">import ModuleA<br/>import ModuleB<br/><br/>extension Container {<br/>    static func setupModules() {<br/>        accountLoader.register { AccountLoader() }<br/>    }<br/>}</span></pre><p id="2a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在<code class="fe lv lw lx ly b">accountLoader</code>上注册一个新的工厂关闭，我们现在已经确保当被请求时，它现在将返回我们刚刚注册的新服务，而不是原始的零值。</p><p id="1edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们快到家了。现在唯一要做的就是确保我们的应用程序调用我们的函数，在一切开始之前设置我们的注册。也许像这样。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="db8a" class="md me it ly b be mf mg l mh mi">@main<br/>struct AccountingApp: App {<br/>    init() {<br/>        Container.setupModules()<br/>    }<br/>    var body: some Scene {<br/>        WindowGroup {<br/>            NavigationView {<br/>                ContentView()<br/>            }<br/>            .navigationViewStyle(StackNavigationViewStyle())<br/>        }<br/>    }<br/>}</span></pre><p id="b012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完事了。</p><p id="d47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">但是首先附带说明:我只知道一些聪明的人会决定避免可选处理并显式打开加载器，或者显式打开工厂定义本身，但是请不要做这些事情。它基本上首先破坏了工厂背后的整个基本原理。</em></p><h2 id="574a" class="mk me it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">更多问题</h2><p id="e749" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我是说，我们结束了？对吗？</p><p id="cc67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不完全是。我们仍然有一些潜在的问题。</p><p id="42d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一，我们必须记住调用我们的设置函数。有问题，是的，但就其本身而言，它不是一个交易破坏者。</p><p id="8f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是第二个更阴险一点。考虑一下这个。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="e099" class="md me it ly b be mf mg l mh mi">@main<br/>struct AccountingApp: App {<br/>    let viewModel = ModuleA.ViewModel()<br/>    init() {<br/>        Container.setupModules()<br/>    }<br/>    var body: some Scene {<br/>        WindowGroup {<br/>            NavigationView {<br/>                ContentView()<br/>            }<br/>            .environmentObject(ViewModel)<br/>            .navigationViewStyle(StackNavigationViewStyle())<br/>        }<br/>    }<br/>}</span></pre><p id="21fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们需要将ModuleA的视图模型放入环境中，为此，我们只需创建一个视图模型作为属性。</p><p id="f936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是问题所在。</p><p id="a61f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，当系统试图创建一个<code class="fe lv lw lx ly b">AccountingApp</code>的实例时，该结构上的<em class="mj">属性</em>将首先被初始化，<em class="mj">先于</em>初始化器。这意味着<code class="fe lv lw lx ly b">ViewModel</code>将被创建，<em class="mj">的</em>注入属性包装器将向其工厂请求一个帐户加载器…所有这些都在我们的设置函数被调用之前。</p><p id="fc15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们最终一无所获。字面上。</p><p id="6186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子有点做作，但是在多模块环境中，它实际上比我们想象的要经常出现。</p><h2 id="a2f9" class="mk me it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">自动注册</h2><p id="7b09" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Resolver通过在第一次解析发生之前自动调用设置函数解决了这个问题，而碰巧的是，我只是将相同方法的一个版本添加到了Factory中。</p><p id="53e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们修改后的设置功能。请注意，函数的名称已经更改为<code class="fe lv lw lx ly b">registerAllServices</code>，我们的扩展现在符合<code class="fe lv lw lx ly b">AutoRegistering</code>。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="840e" class="md me it ly b be mf mg l mh mi">import ModuleA<br/>import ModuleB<br/><br/>extension Container: AutoRegistering {<br/>    static func registerAllServices {<br/>        accountLoader.register { AccountLoader() }<br/>    }<br/>}</span></pre><p id="eab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样我们就完全不需要初始化器了。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="5605" class="md me it ly b be mf mg l mh mi">@main<br/>struct AccountingApp: App {<br/>    let viewModel = ModuleA.ViewModel()<br/>    var body: some Scene {<br/>        WindowGroup {<br/>            NavigationView {<br/>                ContentView()<br/>            }<br/>            .environmentObject(ViewModel)<br/>            .navigationViewStyle(StackNavigationViewStyle())<br/>        }<br/>    }<br/>}</span></pre><p id="908d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂现在将自动为我们呼叫<code class="fe lv lw lx ly b">registerAllServices</code>，在第一个工厂决议之前一次(并且只有一次)。</p><h2 id="3cf9" class="mk me it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">内部构件</h2><p id="5a14" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如果你是一个极客(如果你一直读到这里，你很可能是)，这是如何实现的内部是相当有趣的。</p><p id="2dd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该协议非常简单。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="46d2" class="md me it ly b be mf mg l mh mi">public protocol AutoRegistering {<br/>    static func registerAllServices()<br/>}</span></pre><p id="9d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之前也看到了如何使用它。但是我们如何检查容器<em class="mj">类</em>是否符合那个协议？我们如何确保我们的函数只被调用一次？</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="7822" class="md me it ly b be mf mg l mh mi">extension Container {<br/>    fileprivate static var autoRegistrationCheck: Void = {<br/>        (Container.self as? AutoRegistering.Type)?.registerAllServices()<br/>    }()<br/>}</span></pre><p id="25b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先解决这个一次性的问题。在过去，我们会使用<code class="fe lv lw lx ly b">dispatch_once</code>，但是Swift告诉我们函数已经过时了，我们应该考虑使用静态变量。</p><p id="fee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">于是我们做了，创造了<code class="fe lv lw lx ly b">autoRegistrationCheck</code>。正如承诺的那样，Swift本身确保我们的静态变量初始化器只被调用一次。</p><p id="4bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数内部，<code class="fe lv lw lx ly b">(Container.self as? AutoRegistering.Type)</code>代码看起来有点奇怪，但基本上它只是检查是否有人扩展了<code class="fe lv lw lx ly b">Container</code>类型以符合<code class="fe lv lw lx ly b">AutoRegistering</code>类型。</p><p id="247a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果转换类型不为零，我们在类类型上调用<code class="fe lv lw lx ly b">registerAllServices</code>。简单。</p><p id="8442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂中唯一剩下的事情就是在第一个决议之前调用它。</p><pre class="kj kk kl km gt lz ly ma bn mb mc bi"><span id="f29e" class="md me it ly b be mf mg l mh mi">func resolve(_ params: P) -&gt; T {<br/>     let _ = Container.autoRegistrationCheck<br/>     // remaining code<br/>}</span></pre><p id="49cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果容器符合<code class="fe lv lw lx ly b">AutoRegistering</code>，那么<code class="fe lv lw lx ly b">registerAllServices</code>作为副作用被调用，返回的<code class="fe lv lw lx ly b">Void</code>被丢弃。在随后的调用中，我们向静态变量请求一个<code class="fe lv lw lx ly b">Void</code>,无论如何我们都要丢弃它……这导致执行的代码非常少。(这上面的SIL代码很有意思。)</p><p id="e993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Resolver做同样事情的内部检查要比这简单得多，但是如果您愿意，欢迎您检查这些代码。</p><h2 id="b9c7" class="mk me it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">完成块</h2><p id="7356" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">就是这样。一些与Factory一起使用的多模块注册和解析策略，以及魔术如何发生的幕后简要介绍。</p><p id="52fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道该怎么做。在下面的部分提出你的问题和评论，如果你想看更多，请按住“喜欢”按钮一会儿。有帮助。</p><p id="69b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到下次。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="8c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">本文是</em> <a class="ae ky" href="https://medium.com/p/365ce5038ef7/edit" rel="noopener"> <em class="mj">雨燕依赖注入系列</em> </a> <em class="mj">的一部分。</em></p></div></div>    
</body>
</html>