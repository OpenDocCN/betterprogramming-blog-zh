<html>
<head>
<title>Introducing Assert — My Wrapper Framework Around XCTest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Assert——我的XCTest包装框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/assert-my-wrapper-framework-around-xctest-7d6bea2d05f9?source=collection_archive---------10-----------------------#2022-11-01">https://betterprogramming.pub/assert-my-wrapper-framework-around-xctest-7d6bea2d05f9?source=collection_archive---------10-----------------------#2022-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="da88" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在iOS中编写健壮的测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/33bfe9340b11977638a3feec88f071f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHg2Gm26JrD6Q7CwSPQs1A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae kv" href="https://unsplash.com/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4fbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">XCTest感觉像是从未清理过的Swift迁移的一部分，甚至不清楚我们应该以什么顺序将变量传递到像<code class="fe ls lt lu lv b">XCTAssertEqual</code>这样的东西中，这常常取决于谁编写了测试:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e88f" class="ma mb iq lv b gy mc md l me mf">XCTAssertEqual(actual, expected)<br/>XCTAssertEqual(expected, actual)</span></pre><p id="b180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住这一点，让我们通过在我们想要断言的东西周围创建一个包装器来拆分断言。然后我们将编写一个简单的函数来返回我们的<code class="fe ls lt lu lv b">Assert</code>对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="cc35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了包装器，我们可以添加一些扩展，这里我将主要依靠<code class="fe ls lt lu lv b">XCAssert</code>函数，但是你也可以很容易地依靠<code class="fe ls lt lu lv b">throws</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4e40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单，此时我们可以将上面的<code class="fe ls lt lu lv b">XCTAssertEqual</code>替换为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="13ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很好，还有一点我们可以清理，让我们介绍一个运营商。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="053a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上你可以停下来，但是当我们想要处理更复杂的类型时呢？让我们添加一些对闭包和<code class="fe ls lt lu lv b">@dynamicMemberLookup</code>的支持。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2cb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许我们做什么？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了闭包，我们可以更容易地断言一个对象上的值，而不必在每个字段上执行<code class="fe ls lt lu lv b">assert</code>，我们返回一个<code class="fe ls lt lu lv b">Assert&lt;User&gt;</code>，并且可以使用<code class="fe ls lt lu lv b">@dynamicMemberLookup</code>对用户的所有字段进行操作。</p><p id="e0e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个断言失败了，我们仍然会看到由于<code class="fe ls lt lu lv b">file: StaticString = #file</code>和<code class="fe ls lt lu lv b">line: UInt = #line</code>它在哪一行失败。</p><p id="dc10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您对这种方法感兴趣，我已经创建了一个Swift包，其中包含了额外的操作符<code class="fe ls lt lu lv b">!=</code>、<code class="fe ls lt lu lv b">&lt;=</code>、<code class="fe ls lt lu lv b">&lt;</code>、<code class="fe ls lt lu lv b">&gt;</code>、<code class="fe ls lt lu lv b">&gt;=</code>、<code class="fe ls lt lu lv b">!==</code>、<code class="fe ls lt lu lv b">===</code>等。如果您愿意，它还提供文本表示(即<code class="fe ls lt lu lv b">greaterThanOrEqual(to: ...)</code>)。命名遵循<code class="fe ls lt lu lv b">XCTAssert</code>命名。</p><p id="ce35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift套餐/更多信息:<a class="ae kv" href="https://github.com/cjnevin/Assert" rel="noopener ugc nofollow" target="_blank">https://github.com/cjnevin/Assert</a></p></div></div>    
</body>
</html>