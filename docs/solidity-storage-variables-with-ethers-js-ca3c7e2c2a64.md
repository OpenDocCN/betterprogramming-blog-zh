# Ethers.js 的实度存储变量

> 原文：<https://betterprogramming.pub/solidity-storage-variables-with-ethers-js-ca3c7e2c2a64>

## 使用 Ethers.js 库访问字符串、动态数组、映射、结构和字节打包变量

![](img/61d726286b1a0bc825d08bb62c096970.png)

[滕玉红](https://unsplash.com/@live_for_photo?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

**滚动到 Ethers.js 代码示例文章的后半部分，或者访问此* [*GitHub 库*](https://github.com/hking2/solidity-storage-access) *查看完整的代码和测试文件。*

# 以太坊和智能契约状态

以太坊虚拟机(EVM)上的数据使用改进的 Merkle Patricia Trie 数据结构进行组织。区块链上的每个块引用四个尝试:[全局]状态 trie、存储 trie、事务 trie 和接收 trie。状态 trie 包含 EOA(外部拥有的帐户)数据，作为地址到 ETH 余额的映射，而智能合同数据存储在指向状态 trie 的存储 trie 中。

存储 trie 中的智能合约数据表示合约的持久状态，并且可以随着更新全局状态的事务而改变。在 solidity smart contract 中，动态变量存储在**存储器**中，这是持久的。在**存储器**中初始化的任何变量都是临时的，在执行下一个外部函数调用之前将被擦除。此外，不可修改的常量变量不占用存储空间，因此使用的气体更少。

# 智能合同存储布局

以太坊虚拟机(EVM)中的每个智能合约都有自己的永久存储空间，在键-值对的映射中包含 32 字节的槽(键和值都是 32 字节)。

## **32 字节的固定大小变量**

固定大小的 32 字节变量(如字符串、uint256 和 int256)按照它们在智能协定中列出的顺序被分配到单独的存储槽。在 *StorageLayoutOne* 契约中，常量变量 **hello** 没有存储槽，因为它不能被修改。变量 **numOne** 、 **goodbye** 、和 **num** 分别使用存储槽 0x0、0x1 和 0x2。

```
contract StorageLayoutOne {​ ​ ​​string constant hello = "hello world"; // no storage
​ ​ ​​uint256 numOne = 1; // slot 0x0
​ ​ ​​string goodbye = "goodbye world"; // slot 0x1
​ ​ ​​int256 num; // slot 0x2}
```

## **固定大小变量< 32 字节**

少于 32 字节的固定大小变量将尽可能按字节打包到单个存储槽中。在 *StorageLayoutTwo* 契约中，变量 **lock** 、 **byteX** 、 **bytesY** 和 **bytesZ** 都将被打包到槽 0x0 (1+1+4+16 = 22 字节)中。下一个变量 **bytesA** 存储在槽 0x1 中，因为它不能放入前一个。最后，变量 **bytesB** 和 **bytesC** 被打包到槽 0x2 中。

```
contract StorageLayoutTwo {​ ​ ​​bool lock; // slot 0x0
 ​ ​​byte byteX; // slot 0x0
​ ​ ​​bytes4 bytesY; // slot 0x0
​ ​ ​​bytes16 bytesZ; // slot 0x0​​​ ​ ​​bytes28 bytesA; // slot 0x1​​​ ​ ​​bytes16 bytesB; // slot 0x2
​​​ ​ ​​bytes16 bytesC; // slot 0x2}
```

需要注意的是，EVM 对 32 字节进行操作，因此使用小于 32 字节的变量可能会由于额外的转换操作而导致更高的气体成本。然而，字节打包通过允许 EVM 编译器在同一个存储槽内组合对变量的多个读写操作来弥补这一点。因此，以最有效的方式将少于 32 字节的变量分组在一起以降低总的气体成本是很重要的。

## **动态调整大小的变量**

可能超过 32 字节的动态大小的变量(如动态数组和映射)使用 keccak-256 哈希算法哈希到防冲突存储位置，该算法伪随机地选择 2 个⁵⁶存储槽范围内的位置。如果你想知道，2 ⁵⁶ =

115792089237316195423570985008687907853269984665640564039457584007913129639936

由于这种广阔的存储空间(比已知宇宙中的恒星更多的可用插槽)，EVM 可以分配存储位置而无需分配存储，因为每个键的分配距离其他任何键都以光年计。EVM 不跟踪未分配的槽，查询一个槽将简单地返回零。

动态数组从由槽的散列确定的存储位置开始。后续数组项与前一项相邻。当数组项为 16 字节或更少时，应用字节打包规则。

与数组相反，映射通过首先将映射键与存储槽连接起来，然后将其散列到一个唯一的槽来分散数据。

在 StorageLayoutThree 协定中， **arrayOfNums** ，槽 0x0(填充为 32 字节)被散列以找到第一项 arrayOfNums[0]的存储位置。对于 **userBalances** ，用户的地址与槽 0x1 连接，并被散列以提供值的位置。

```
contract StorageLayoutThree { ​​ ​ uint[] public arrayOfNums; // slot 0x0 => keccak256(0x0)​ ​ ​​mapping(address => uint256) public userBalances;
 ​ // slot 0x1 => keccak256(key + 0x1)}
```

此外，映射通常嵌套在其他映射中，并且可能包含结构。同样，数组可以嵌套在其他数组中，也可以在数组中嵌套映射。当处理嵌套的数据结构时，可以用嵌套的 keccak-256 散列找到数据位置。本文下面的编码教程中提供了这样的例子。

## **非存储变量**

常数、枚举、结构定义、事件和用户定义的错误不使用存储空间。

# Ether.js 代码教程

Ethers-JavaScript 库提供了许多有用的工具来与以太坊区块链上的智能合约进行交互，包括直接访问存储变量的实用程序，下面将通过代码示例进行解释。完整的代码可以在这个 [**GitHub 库**](https://github.com/hking2/solidity-storage-access) 找到，包括一个智能合约示例和单元测试文件。

要安装 Ether.js，请在项目根目录的终端中键入以下命令:

```
npm install ethers
```

## 定义可重复使用的 Ethers.js 常量

这里有一些常量定义可以添加到我们的 JavaScript 文件的顶部，这将有助于编写更干净的代码:

## 用线串

一个 32 字节的存储槽最多可以容纳 32 个字符的字符串，因此，如果要访问的字符串超过 32 个字符，就需要从多个连续的槽中读取数据。对于不超过 32 个字符的字符串，使用 **getShortStr** 函数，对于超过 32 个字符的字符串，使用 **getLongStr** 函数。

## 数字

256 位数字占据了整个存储槽，因此它们不需要任何位移位，除非字节打包有优势，否则应该用作默认的整数类型。

下面的映射函数中将使用 **getUint256** 函数。

## 映射

与只需要存储槽和约定地址参数的字符串和数字不同，映射需要一个附加的键参数。键加上存储槽被散列以找到对应于该键的值的位置。

例如,[EOA]地址到[uint256]余额的映射将采用参数:存储槽、合同地址和 EOA 地址。该槽被 2 分割以移除“0x”，因为该键已经包含指示十六进制数的“0x”。

## 结构映射

初始化的结构存储数据的方式类似于数组存储数据的方式；感染和字节包装(如果适用的话)。因此，在找到 slot +键的散列之后，必须确定类型，因为结构通常保存各种类型的数据。对于这个函数，我将类型限制为字符串、字节或数字。最后，我们需要在结构中选择一个属性，它就像数组中的一个元素。项目编号将对应于结构属性的顺序。

请注意，此函数不处理字节打包的结构，而是假设结构属性占用全部存储槽。

## 到结构中嵌套映射的映射

最后一个映射函数处理映射中结构内部的映射。与前面的示例相比，“type”已被替换为“nestedKey”。我们不需要类型，因为映射将一种类型映射到另一种类型，这意味着最终值将是一种类型。在这种情况下，最终值被假定为 Uint256。

新参数 nestedKey 引用另一个映射中的结构内的映射的键。

## 字节打包槽

当少于 32 字节的连续变量被打包到单个槽中时，发生字节打包。以最有效的字节打包方式在 smart contract 的顶部一起定义所有少于 32 字节的变量是一种很好的做法，这样可以最大化存储空间并节省汽油。

只要你会做基本的数学运算，写一份可靠的智能合同是很容易的。然而，访问字节打包的变量有点棘手，因为它需要通过存储槽移位来找到一个特定的变量。

JavaScript 很难处理大数，这就是为什么对于大于 6 字节的字节大小递归调用这个函数，并返回完整变量的连接结果。

下面的动态数组函数中会用到 **getBytePackedVar** 函数。

## 动态数组

数组被散列到一个存储位置，在这个位置上所有的项都是连续的。一旦定位了数组的头，就可以通过槽或位移位来找到后面的项。如果项目是 16 字节或更少，存储槽将被字节打包。

# 结论

理解 solidity 智能契约存储对于编写高效、安全和数据优化的代码非常重要。Ethers.js 提供了许多有用的方法，可用于访问智能合约持久状态中的存储变量。在您自己部署的智能合约上使用或修改上面提供的代码示例将有助于您更好地理解 EVM 的存储级别。