<html>
<head>
<title>Implement the Strategy Design Pattern in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5中实施策略设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-the-strategy-design-pattern-in-swift-5d9c3f221277?source=collection_archive---------14-----------------------#2020-02-17">https://betterprogramming.pub/implement-the-strategy-design-pattern-in-swift-5d9c3f221277?source=collection_archive---------14-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df41" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">只需一行代码就可以在领域和核心数据之间切换</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/57b8fd8d817be2d1bc962e4332efc610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xLs7XavLAiWKjxNu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@o12?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> O12 </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="137d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将学习如何实现一个有用的设计模式— <code class="fe lv lw lx ly b">Strategy</code>。</p><p id="2342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Strategy</code>提供运行时在可互换对象之间切换的功能。当我们想要实现核心数据和领域数据库时，这非常方便，使我们能够在iOS应用程序中轻松地在它们之间切换。</p><p id="ad5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在GitHub上下载项目的<a class="ae ky" href="https://github.com/zafarivaev/Swift-Strategy-DesignPattern" rel="noopener ugc nofollow" target="_blank">源代码。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/8ce11b83effd828d30c32272e0297e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agZalKeyMlo43u20d7DpWg.jpeg"/></div></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9186" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">我们开始吧</h1><p id="6586" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">看看我们的项目结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c3cace8edcd87400992d256d7bc65b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*o4GlL1TK8uXi0iniVT_aMw.png"/></div></figure><p id="187f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Strategy</code>文件夹中有<code class="fe lv lw lx ly b">CoreDataStrategy</code>和<code class="fe lv lw lx ly b">RealmStrategy</code>将符合的<code class="fe lv lw lx ly b">PersistenceStrategy</code>协议。在<code class="fe lv lw lx ly b">Model</code>文件夹中，我们有一个普通的<code class="fe lv lw lx ly b">Item</code>，我们在<code class="fe lv lw lx ly b">ItemsViewController</code>中使用它来表示持久化的项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看<code class="fe lv lw lx ly b">CoreDataModel.xcdatamodeld</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/04d6b380711c2b1fd38c1aec447c31af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSMBkAFc2porABDubGnWPw.png"/></div></div></figure><p id="6e22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到有一个<code class="fe lv lw lx ly b">CoreDataItem</code>实体，它具有以下属性(attribute):<code class="fe lv lw lx ly b">id</code>和<code class="fe lv lw lx ly b">title</code>，两者都是<code class="fe lv lw lx ly b">String</code>的类型。当用它执行CRUD操作时，我们将把这个<code class="fe lv lw lx ly b">CoreDataItem</code>对象转换成控制器的普通<code class="fe lv lw lx ly b">Item</code>。</p><p id="517f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">RealmItem</code>描述了<code class="fe lv lw lx ly b">Realm</code>的持久化对象，我们也将把它转换成<code class="fe lv lw lx ly b">Item</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="002e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们已经讨论了MVC应用程序的<code class="fe lv lw lx ly b">Model</code>,现在我们可以直接开始创建我们的<code class="fe lv lw lx ly b">Strategy</code>实现。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2a75" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">定义持久性策略</h1><p id="6321" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在我们的应用程序中，我们希望检索、添加、编辑和删除项目。因此，我们的协议中有以下一组规则:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="543e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了<code class="fe lv lw lx ly b">title</code>属性来为将来的<code class="fe lv lw lx ly b">UITableView</code>设置一个头。</p><p id="0ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们添加这个协议的核心数据和领域实现。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5c4b" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">核心数据持久性策略</h1><p id="a533" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们需要创建一个<code class="fe lv lw lx ly b">CoreDataStrategy</code>类并符合<code class="fe lv lw lx ly b">PersistenceStrategy</code>。</p><h2 id="b91b" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">CoreDataStrategy.swift</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经用核心数据实现了所有需要的方法。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b3f9" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">领域持续策略</h1><p id="4b41" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在我们将定义<code class="fe lv lw lx ly b">PersistenceStrategy</code>协议的特定领域实现:</p><h2 id="175a" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">RealmStrategy.swift</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe lv lw lx ly b">Strategy</code>设计模式允许我们将实际的数据库实现隐藏在幕后。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="3f05" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">ItemsViewController</h1><p id="68b6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在<code class="fe lv lw lx ly b">ItemsViewController</code>将不会知道我们在应用程序中使用了什么特定的数据库。它将简单地调用<code class="fe lv lw lx ly b">PersistenceStrategy</code>协议的方法。</p><h2 id="15bc" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">ItemsViewController.swift</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="29a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，我们有非特定类<code class="fe lv lw lx ly b">PersistenceStrategy</code>的<code class="fe lv lw lx ly b">persistenceStrategy</code>属性和保存一组<code class="fe lv lw lx ly b">Item</code>对象的<code class="fe lv lw lx ly b">items</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d85b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看如何调用<code class="fe lv lw lx ly b">PersistenceStrategy</code>协议方法。</p><h2 id="539d" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">添加项目</h2><p id="ea2d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在用户点击<code class="fe lv lw lx ly b">UIBarButtonItem</code>，在<code class="fe lv lw lx ly b">UITextField</code>中键入一些内容，然后按“add”之后，我们向数据库添加一个项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="f95f" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">获取项目</h2><p id="6505" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">viewDidLoad</code>方法中检索所有项目，并将它们分配给<code class="fe lv lw lx ly b">items</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="7ac0" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">编辑项目</h2><p id="e867" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">要编辑一个项目，我们选择<code class="fe lv lw lx ly b">tableView</code>的特定行，并在<code class="fe lv lw lx ly b">UITextField</code>中键入一个新标题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="1933" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">删除项目</h2><p id="4da3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">要删除一个项目，我们必须将实现添加到<code class="fe lv lw lx ly b">tableView(_:commit:forRowAt:)</code>方法中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是最有趣的部分:我们如何在领域和核心数据之间切换？为此，我们在<code class="fe lv lw lx ly b">UINavigationBar</code>上有一个<code class="fe lv lw lx ly b">UISegmentedControl</code>，选择它时，我们触发此代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们在数据库之间切换所需要做的就是分配一个相应的<code class="fe lv lw lx ly b">Strategy</code>给<code class="fe lv lw lx ly b">persistenceStrategy</code>属性。整洁！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="77c2" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">包扎</h1><p id="b940" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在很容易看出我们的<code class="fe lv lw lx ly b">ItemsViewController</code>与数据库无关。例如，如果我们以后想添加一个SQLite实现，我们只需要创建一个符合<code class="fe lv lw lx ly b">PersistenceStrategy</code>协议的类，在所需的方法中提供特定于SQLite的实现——<code class="fe lv lw lx ly b">ItemsViewController</code>只需要在<code class="fe lv lw lx ly b">persistenceTypeChanged</code>方法中包含这个类。</p><p id="344b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以看到，当与其他设计模式一起使用时，MVC架构看起来和感觉上都要好得多。</p><p id="8923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对设计模式感兴趣并想了解更多，请随意查看我的其他相关文章:</p><div class="nu nv gp gr nw nx"><a href="https://medium.com/better-programming/this-is-how-you-implement-mvc-architecture-in-2020-b39d65b4212f" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">新MVC:单一责任原则和委托</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">苹果的模型视图控制器，终于做对了</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/better-programming/implement-a-model-view-presenter-architecture-in-swift-5-dfa21bbb8e0b" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">在Swift 5中实施模型-视图-演示者架构</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用领域数据库作为业务逻辑层</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/better-programming/reactive-mvvm-and-the-coordinator-pattern-done-right-88248baf8ca5" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">反应式MVVM和协调模式做对了</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用Swift 5、RxSwift和RxDataSources</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/better-programming/how-to-implement-viper-architecture-in-your-ios-app-rest-api-and-kingfisher-f494a0891c43" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">如何使用Swift 5在您的iOS应用中实现VIPER架构</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用方便的Xcode模板和参考报告</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="oo l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/better-programming/implement-a-service-oriented-architecture-in-swift-5-fc70b8117616" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">在Swift 5中实施面向服务的架构</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">为什么只用MVC/MVVM/蝰蛇还不够</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="op l oi oj ok og ol ks nx"/></div></div></a></div><p id="6bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的阅读！</p></div></div>    
</body>
</html>