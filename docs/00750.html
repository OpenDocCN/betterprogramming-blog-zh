<html>
<head>
<title>Let’s Learn React Hooks and Context API by Building a Recipe Search App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们通过构建一个食谱搜索应用程序来学习React钩子和上下文API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lets-learn-react-hooks-and-context-api-by-building-a-recipe-search-app-2eb0b2d2cb85?source=collection_archive---------8-----------------------#2019-07-09">https://betterprogramming.pub/lets-learn-react-hooks-and-context-api-by-building-a-recipe-search-app-2eb0b2d2cb85?source=collection_archive---------8-----------------------#2019-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a52b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第二部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1e6c2c5efaaacc2b57147fa3d680349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0HZjRbl8xLvHG-8MJ3qvg.png"/></div></div></figure><h1 id="f902" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">概观</h1><p id="a74c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是学习React Hook <strong class="lo iu"> s </strong>和<strong class="lo iu"> </strong>上下文API系列的第二部分。在<a class="ae mi" href="https://medium.com/better-programming/lets-learn-react-hooks-and-context-api-by-building-a-recipe-search-app-63be9d9e1801" rel="noopener">第一部分</a>中，我们学习了<code class="fe mj mk ml mm b">useState</code>的基础知识，并构建了食谱搜索应用程序的第一部分。完整代码可以在<a class="ae mi" href="https://github.com/olajohn-ajiboye/Blog-React-Hook-Tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="726c" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在这一部分，我们将更多地使用状态，以便完全理解这个概念。我们来解释一下<code class="fe mj mk ml mm b">useEffect</code>。我们先构建<code class="fe mj mk ml mm b">RecipeSearch</code> <strong class="lo iu"> <em class="ms"> </em> </strong>组件。然后，我们将重构我们的状态管理策略，以利用上下文API <code class="fe mj mk ml mm b">useContext</code>。激动人心吧？</p><p id="3ef9" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">从现在开始，我们不会与经典组件做太多的比较。相反，我们将更加注重学习钩子的基本原理。</p><p id="4322" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">从上一篇文章中，我已经将<strong class="lo iu"> </strong> <code class="fe mj mk ml mm b">RecipeDetails</code>提取成了自己的组件。这有两个原因。第一，这样做是对的。这是基于组件的框架的要点，它允许代码重用。第二，它给了我们充分的机会来了解传递道具所产生的问题(<em class="ms">道具训练</em>)以及上下文API如何帮助我们。</p><p id="6ad9" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">稍后将详细介绍这一点！先来刺一下<code class="fe mj mk ml mm b">useEffect</code> <em class="ms">。</em></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="1800" class="ku kv it bd kw kx na kz la lb nb ld le jz nc ka lg kc nd kd li kf ne kg lk ll bi translated"><strong class="ak">快速入门<em class="nf"/></strong><code class="fe mj mk ml mm b">useEffect</code><strong class="ak"><em class="nf">H</em>ook</strong></h1><p id="5908" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在第一部分中，我们提到并使用了<code class="fe mj mk ml mm b">useEffect</code> <em class="ms"> </em>钩子但是没有给出任何详细的解释。我确信只有少数人意识到我们在第一部分中使用<code class="fe mj mk ml mm b">useEffect</code>钩子的方式的问题。</p><p id="96b9" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">还记得我们不得不创建自己单独的JSON响应，以便不进行太多的API调用吗？我们只是像以前一样使用<code class="fe mj mk ml mm b">useEffect</code>，这是非常错误的。我稍后会深入探讨这个问题。</p><p id="81a0" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">但是首先，这个<code class="fe mj mk ml mm b">useEffect</code>钩子是什么？顾名思义，它肯定跟<em class="ms">特效</em>、<em class="ms">T42有关系吧？如果你是这么猜的，那你绝对是对的。但是什么样的影响呢？</em></p><p id="5fd5" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">根据React <a class="ae mi" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>，<em class="ms">效果</em>是与获取数据、设置订阅以及手动更改React组件中的DOM相关的操作。(有人称之为<em class="ms">副作用。</em>别人就叫它<em class="ms">特效</em>。我们指的是同一件事。)如果你熟悉React类生命周期方法，你可以把<code class="fe mj mk ml mm b">useEffect</code> Hook看作是<code class="fe mj mk ml mm b">componentDidMount</code>、<code class="fe mj mk ml mm b">componentDidUpdate</code>和<code class="fe mj mk ml mm b">componentWillUnmount</code>的组合。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="db27" class="ku kv it bd kw kx na kz la lb nb ld le jz nc ka lg kc nd kd li kf ne kg lk ll bi translated"><strong class="ak">正确使用</strong><code class="fe mj mk ml mm b">useEffect</code><strong class="ak"><em class="nf">H</em>ook</strong></h1><p id="f9dd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们将这些信息与我们的应用程序联系起来。在<code class="fe mj mk ml mm b">app.js</code>中，我们从<a class="ae mi" href="https://www.food2fork.com/" rel="noopener ugc nofollow" target="_blank"> Food2Fork </a> API函数中获取数据，然后在<code class="fe mj mk ml mm b">useEffect</code> <em class="ms"> </em>函数中调用该函数。这相当于在<code class="fe mj mk ml mm b">componentDidMount</code> <em class="ms"> </em>函数内部调用它。让我们仔细看看。</p><p id="43ba" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">但是想一想。<code class="fe mj mk ml mm b">componentDidMount</code>的预期用途是什么？答案就在名字里！当组件被<em class="ms">安装</em>时，你只需要运行该函数中的任何函数。让我们慢慢地检查那个信息。在挂载<em class="ms">，</em>时，组件被创建(通过你的代码和React的内部)，然后被插入到DOM中。</p><p id="43e2" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">但是如果你有一个函数在一个<code class="fe mj mk ml mm b">componentDidMount</code> <em class="ms"> </em>中引起了重复的效果，你的组件将不断地重新渲染，除非你找到一种方法来清理它。这通常在<code class="fe mj mk ml mm b">componentWillUnmount</code> <em class="ms"> </em>生命周期内完成。</p><p id="ca41" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">那么<code class="fe mj mk ml mm b">useEffect</code>如何在一个功能中取代<code class="fe mj mk ml mm b">componentDidMount</code>和<code class="fe mj mk ml mm b">componentWillUnmount</code>？让我们回顾一下我们对<code class="fe mj mk ml mm b">useEffect</code>的错误使用，以便更好地理解这一点。当我们如下调用<code class="fe mj mk ml mm b">useEffect</code>时，组件不断重新渲染，因为它不知道如何<em class="ms">卸载</em>。这是一个可怕的性能瓶颈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/f7e747ffef90ba677a926d2f5119f441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*0vITcnVtv2vzeWOzPxtfzQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">useEffect的使用不正确！</p></figure><p id="b280" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">让我们做一个事后分析来看看问题在起作用。在<code class="fe mj mk ml mm b">fetchRecipe()</code> <strong class="lo iu"> <em class="ms"> </em> </strong>里面的<code class="fe mj mk ml mm b">app.js</code> <strong class="lo iu"> <em class="ms">，</em> </strong>试着在组件被渲染的时候控制台记录一些东西来指示。我们也可以只检查浏览器中的网络选项卡。但是，有时控制台日志记录并观察它的运行会更快地让您明白这一点。</p><p id="0788" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在<code class="fe mj mk ml mm b">3/hook-in-app.js</code> <em class="ms"> </em>分支的回购编辑<code class="fe mj mk ml mm b">app.js</code><strong class="lo iu"><em class="ms"/></strong>中添加<code class="fe mj mk ml mm b">console.log</code>，弹出打开你的控制台。你这个小实验在<code class="fe mj mk ml mm b">app.js</code> <em class="ms"> </em>里应该有类似下面的东西。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="97fb" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">你会得到下面的恐怖。到底发生了什么事？这是不可接受的行为。由于我创建的JSON响应，我们侥幸逃脱了。我们可以无限制地进行API <strong class="lo iu"> </strong>调用，而不会出现问题。显然，这不可能是生产中正确的做事方式。</p><p id="d384" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">那么问题出在哪里？解决方法是什么？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/ab95fb0f805842d9c41fafc0a5a746a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/1*J6nL139DSafV1LHMDXxtvA.gif"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">useEffect使用错误，无限循环！</p></figure><p id="6f5b" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">显而易见的是,<code class="fe mj mk ml mm b">fetchRecipe</code>不断尝试从API获取响应，并且每次都被<code class="fe mj mk ml mm b">useEffect </code>重新呈现——即使什么都没有改变。我们自然需要在一个类组件中通过取消订阅另一个<code class="fe mj mk ml mm b">componentWillUnmount</code> <em class="ms">中的API调用来清理这个问题。</em></p><p id="8da6" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们来看看<code class="fe mj mk ml mm b">useEffect</code>是如何处理这个问题的。既然我们已经认识到了这个问题，让我们来考虑一下解决办法。停顿片刻。我们打算实现什么？在我们的例子中，我们希望<code class="fe mj mk ml mm b">fetchRecipe</code>函数只在组件装载时运行一次——也就是说，获取一次数据并显示它，或者当任何事情对函数的结果有影响时。在这一点上，没有什么影响结果。那么，我们如何克服这个问题呢？很简单，事实证明。</p><p id="873c" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在<code class="fe mj mk ml mm b">useEffect</code>函数中，我们简单地传递一个空数组作为第二个参数。因此，我们指示<code class="fe mj mk ml mm b">useEffect</code>不要更新，除非组件第一次被安装，因为我们不希望任何事情导致<code class="fe mj mk ml mm b">fetchRecipe</code>更新(见下文)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/37df90899bcbedd28be2f9cf55b15d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*zFaOfTtm2v9nd5nE2LNTNQ.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated"><code class="fe mj mk ml mm b">useEffect</code>的正确使用</p></figure><p id="7199" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">如果您返回到<code class="fe mj mk ml mm b">app.js</code>并运行console.log，您会发现<code class="fe mj mk ml mm b">fetchRecipe</code> <em class="ms"> </em>只运行一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/7628f03e7de6fed5b99c9352fcc6f0b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*j286Be-cs3JYQ8VFr1kQIQ.gif"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">每次更新都不重新渲染</p></figure><p id="90e2" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">这很棒，对我们的情况很有用。但是如果我们想在某些事情导致<code class="fe mj mk ml mm b">fetchRecipe</code>改变后更新和重新渲染呢？你可能会问这是什么？假设我们有一个状态，它改变了获取数据的URL。这意味着来自<code class="fe mj mk ml mm b">fetchRecipe</code> <em class="ms"> </em>的数据依赖于URL <strong class="lo iu">。</strong>我们只是简单地将数组中的参数传递给<code class="fe mj mk ml mm b">useEffect</code>。我们可以根据需要向数组中传递任意多的参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/f40f7064c46dde8fc3b4e9e0a172f14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*rNJFIaKu3YNgMrCvNpk0bw.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">将更新道具传递给useEffect</p></figure><p id="3cd5" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">你用人类的语言对<code class="fe mj mk ml mm b">useEffect</code>说的是:只有当URL参数或查询参数改变时才更新。</p><p id="daf4" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">如果你还不明白，我推荐<a class="ae mi" href="https://www.robinwieruch.de/react-hooks-fetch-data/" rel="noopener ugc nofollow" target="_blank"> RobinWieruch的</a>教程中的更多例子。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="8c23" class="ku kv it bd kw kx na kz la lb nb ld le jz nc ka lg kc nd kd li kf ne kg lk ll bi translated"><strong class="ak">让我们构建</strong> <code class="fe mj mk ml mm b">RecipeSearch</code> <strong class="ak">组件</strong></h1><p id="29a1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有了如何安全获取数据的知识，我们现在将切换到使用Food2Fork的API键。我们将在<code class="fe mj mk ml mm b">app.js</code>中做一些重构。我们还将介绍让一个<em class="ms"> try catch </em>块在异步函数中捕捉任何错误的最佳实践。</p><p id="d17e" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">接下来，克隆回购的<code class="fe mj mk ml mm b">4/feature/implemented-search</code>分支。</p><p id="cae0" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">首先，让我们考虑一下我们希望搜索组件实现什么，然后考虑如何实现这一点。</p><p id="70cd" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们希望输入一个搜索，然后，当我们单击submit或按enter时，我们希望将页面内容更改为新的搜索结果。我们还希望能够返回到前30个食谱，从而清除搜索(或者返回到前30个结果，取决于您如何考虑)。你可以在下面看到我的意思。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/b56e22369092ded90fa4bea1eb0945f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*J68uo7Zmkuj3Q5p16NlKqA.gif"/></div></figure><p id="ce79" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在我们心中有了目标，我们如何用钩子写代码呢？请注意，我试图使这个尽可能基本，所以即使有非常基本的反应知识，你仍然可以建立这个。因此，并不是所有的东西都是特定于钩子的。</p><p id="94d2" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">显而易见，我们确实需要一些州来管理所有这些变化。首先，我们获取与我们的搜索查询相关的另一组30个食谱。这是一个州。我们还必须决定<strong class="lo iu"> <em class="ms"> </em> </strong>按钮何时应该出现或消失。你猜对了:那是另一种状态。最后，也可能是最重要的，是保存我们搜索参数的州。</p><p id="cb43" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">如前所述，让我们看看<code class="fe mj mk ml mm b">app.js</code>中的代码是什么样子，然后逐行解释。你可以在GitHub上找到搜索功能的完整代码<a class="ae mi" href="https://github.com/olajohn-ajiboye/Blog-React-Hook-Tutorial/blob/feature/implemented-search/src/App.js" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3054" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">请注意我们是如何改变一些事情的。首先，我们现在安全地直接发出API请求。从现在开始，我们使用真正的API键。为什么我们不能继续使用我的JSON将变得很明显。</p><p id="215f" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">让我们一行一行来。</p><p id="bfbe" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们已经为URL设置了一个变量。我们从Food2Fork <a class="ae mi" href="https://www.food2fork.com/about/api" rel="noopener ugc nofollow" target="_blank">文档</a>中知道URL端点是什么样子的。接下来我们为<code class="fe mj mk ml mm b">showHomeButton</code>设置一个状态来处理Home按钮的可见性。我们将初始值设为<em class="ms">假</em>。这是因为，最初当我们在主页上时，没有必要显示主页按钮。接下来的两个状态已经很熟悉了。然后我们有了搜索状态，我们将原始值设置为一个空字符串。这是因为当我们第一次访问主页时，我们还没有搜索任何内容。</p><p id="7621" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">接下来，我们必须管理如何响应用户输入的搜索查询。我们已经设置了<strong class="lo iu"> <em class="ms"> </em> </strong> <code class="fe mj mk ml mm b">handleSearchChange</code>函数来处理这个问题。我们使用<code class="fe mj mk ml mm b">handleSubmit</code>按钮来更新列表中的数据，以匹配搜索结果。最后，我们有<code class="fe mj mk ml mm b">handleReturnHome</code> <strong class="lo iu"> <em class="ms"> </em> </strong>功能来——你猜对了——帮助我们带着30个顶级食谱安全回家。</p><p id="da35" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">让我们检查一下每个功能是如何履行其职责的。</p><p id="2e72" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">首先我们来看<code class="fe mj mk ml mm b">handleSearchChange</code>。它的目的是捕获用户输入，然后将搜索状态更新为等于用户输入。这很简单:函数体只有一行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c2205fa16f6dc00156c8d20f4a63950c.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*YW-G_DxiYwF--G8DX4EJOg.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">handleSearchChange</p></figure><p id="9a78" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">它是这样工作的。因为我们正在响应用户输入，所以我们可以从事件对象访问<code class="fe mj mk ml mm b">onChange</code> <strong class="lo iu"> <em class="ms"> </em> </strong>属性。我们简单地从<code class="fe mj mk ml mm b">event.target.value</code>中获取值，并使用<code class="fe mj mk ml mm b">setSearch</code>钩子用这个值更新搜索状态。然后我们需要将它们作为道具一直传递到<code class="fe mj mk ml mm b">RecipeSearch</code>组件，如下所示。这是上下文API要解决的事情之一。</p><p id="f243" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">接下来让我们检查一下<code class="fe mj mk ml mm b">App.js</code>中最有趣的函数<code class="fe mj mk ml mm b">handleSubmit</code>。它是做什么的？先看代码再解释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fcd5d19aacc396e97b3de435dffd30ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*-2GPII1wWTG6kh2gkdZV2A.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">handleSubmit方法。</p></figure><p id="1ea9" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">由于这将在提交时触发，我们必须访问事件<em class="ms"> </em>对象。首先我们需要防止<code class="fe mj mk ml mm b">onSubmit</code>的默认行为，即重新加载页面。因此我们有了<code class="fe mj mk ml mm b">e.preventDefault()</code>。我们将加载状态设置为<em class="ms">真</em>，其中<code class="fe mj mk ml mm b">setLoading(true)</code>表示我们仍在获取数据。</p><p id="b9e4" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">然后我们获取当前的搜索状态，它现在等于用户的输入。我们用它来创建一个新的API点，它基于我们从Food2Fork获得的文档。然后基于这个搜索查询获取新数据。然后，它用<code class="fe mj mk ml mm b">setRecipe</code> <strong class="lo iu"> <em class="ms"> </em> </strong>更新当前配方状态，以匹配来自搜索查询的新数据。现在我们有了数据，我们使用<code class="fe mj mk ml mm b">setLoading(false)</code>将<em class="ms"> </em>加载状态设置为<em class="ms">假</em>。</p><p id="e46a" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">既然新的菜谱列表是基于搜索查询的，那么我们需要一种返回的方法。因此，我们使用<code class="fe mj mk ml mm b">setShowHomeButton</code>将<code class="fe mj mk ml mm b">showHomeButton</code>设置为<em class="ms">真</em>。</p><p id="ca55" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">最后我们有<code class="fe mj mk ml mm b">handleReturnHome</code>函数，它的工作是让我们带着前30个食谱列表回家。我们只是像最初一样获取配方。这将配方状态设置回原来的状态。然后我们将<code class="fe mj mk ml mm b">showHomeButton</code> <em class="ms"> </em>设置回<em class="ms">假</em>，使得按钮在我们在主页上时消失。然后，我们简单地将所有需要的状态作为道具传递给我们要使用它们的子组件。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="2eae" class="ku kv it bd kw kx na kz la lb nb ld le jz nc ka lg kc nd kd li kf ne kg lk ll bi translated">上下文API</h1><p id="f5f7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">React上下文API本质上是一种创建全局状态的方法，可以在应用程序中的任何地方使用。这是把道具从爷爷奶奶传给孩子等等的一种替代方式。它被吹捧为Redux的更轻便的替代品。以我的经验，我会说它更像Vue的VueX，在那里你有一个真实的单一来源，可以在全球范围内访问那个状态。</p><p id="5209" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">让我们检查一下我们的应用程序中道具钻孔的情况。你可以想象在一个如此简单的应用程序中，我们已经必须将道具从<strong class="lo iu"> <em class="ms"> </em> </strong> <code class="fe mj mk ml mm b">app.js</code>传递到<code class="fe mj mk ml mm b">RecipeList</code>，然后传递到<em class="ms"> </em> <code class="fe mj mk ml mm b">RecipeSearch</code>。即使<code class="fe mj mk ml mm b">RecipeList</code> <em class="ms"> </em>组件不需要<code class="fe mj mk ml mm b">handlesSubmit</code>和<code class="fe mj mk ml mm b">handlesSearchChange</code>道具，我们仍然需要通过它们，因为它是<code class="fe mj mk ml mm b">RecipeSearch</code> <em class="ms">的父组件。</em></p><p id="0a96" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">如果你想象更深嵌套的组件树，你会看到混乱。像Redux这样的库有助于解决这个问题，但是Context是一个简单的轻量级版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/22e7662b61a963086314c75d3088cea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*xrldtTGQsIIWbxK8IekgRQ.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">道具钻的视觉呈现！</p></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="ff6c" class="ku kv it bd kw kx na kz la lb nb ld le jz nc ka lg kc nd kd li kf ne kg lk ll bi translated">使用上下文H<strong class="ak">look to Rescue</strong></h1><p id="2cf5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果我们可以在组件树中更高的位置访问我们想要的任何状态，并且只在需要的地方使用它们，会怎么样？这就是我们接下来要用<code class="fe mj mk ml mm b">useContext</code> <strong class="lo iu"> <em class="ms"> </em> </strong>钩子做的事情。</p><p id="d19c" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">关于上下文API，有几件事情需要理解。</p><ul class=""><li id="ae96" class="nu nv it lo b lp mn ls mo lv nw lz nx md ny mh nz oa ob oc bi translated">上下文旨在共享数据，这些数据对于React组件树来说是全局的。</li><li id="8b0d" class="nu nv it lo b lp od ls oe lv of lz og md oh mh nz oa ob oc bi translated">当不同嵌套层次的许多组件需要访问某些数据时，主要使用上下文。</li></ul><p id="48c0" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">让我们讨论一下上下文给我们的API。</p><p id="fd7f" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">首先我们有<code class="fe mj mk ml mm b">React.createContex</code>，它创建了一个上下文对象。当React呈现订阅该上下文对象的组件时，它从树中它上面最匹配的<em class="ms">提供者</em>读取当前上下文值。</p><p id="d99b" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">接下来还有<strong class="lo iu"> </strong> <code class="fe mj mk ml mm b"><strong class="lo iu">Context.Provide</strong></code> <strong class="lo iu">。</strong>每个上下文对象都带有一个<em class="ms"> Provider </em> React组件，它允许消费组件订阅上下文变化。</p><p id="c218" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">最后还有<code class="fe mj mk ml mm b">Context.Consumer</code>，一个订阅上下文变化的React组件。这允许您订阅功能组件中的上下文。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="e995" class="ku kv it bd kw kx na kz la lb nb ld le jz nc ka lg kc nd kd li kf ne kg lk ll bi translated">在我们的例子中如何使用上下文挂钩</h1><p id="5541" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，让我们创建一个上下文文件夹或一个包含<code class="fe mj mk ml mm b">index.js</code>文件的文件。在<code class="fe mj mk ml mm b">index.js</code> <em class="ms"> </em>中，我们需要创建一个<em class="ms">提供者</em>，它接受并向其中的所有子组件提供数据。首先，让我们将所有数据提取逻辑从<code class="fe mj mk ml mm b">app.js</code>移到上下文文件中。你应该留下一个几乎空的<code class="fe mj mk ml mm b">app.js</code> <em class="ms"> </em>像下面这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6510fcda17e5700207ecbc0a24d318e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*J3QQjeZw8KzZ_t2oRxlBIw.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">app.js</p></figure><p id="d95f" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">还有<code class="fe mj mk ml mm b">index.js</code> <strong class="lo iu"> <em class="ms"> </em> </strong> …</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9fe7" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">让我们仔细拆开上面的代码，试着理解一下。</p><p id="4613" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们只是将所有的数据获取逻辑从我们的<code class="fe mj mk ml mm b">app.js</code>转移到了<code class="fe mj mk ml mm b">index.js</code>中，使其在全球范围内可用。我们已经知道程序了。我们和以前一样有数据和状态。</p><p id="a627" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在，到有趣的部分，在第二行。我们从<code class="fe mj mk ml mm b">React.createContext()</code> <strong class="lo iu"> <em class="ms"> </em> </strong>的方法中创造了<code class="fe mj mk ml mm b">RecipeContext</code> <strong class="lo iu"> <em class="ms"> </em> </strong>。(<code class="fe mj mk ml mm b">RecipeContext</code>只是一个变量。名字无关紧要。给它起一个与其功能相近的名字是一个很好的做法。)</p><p id="1d20" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">当我们创建<code class="fe mj mk ml mm b">RecipeContext,</code>时，它让我们可以访问另外两个属性，即<em class="ms">提供者</em>和<em class="ms">消费者</em>。<em class="ms">提供者</em> <strong class="lo iu"> <em class="ms"> </em> </strong>为我们提供了一种方法，将所有数据和状态作为道具从React树的最顶端传递到我们想要使用的任何地方。因此，我们创建了<code class="fe mj mk ml mm b">RecipeContext.Provider </code>，并将所有状态和数据作为一个名为<em class="ms">值</em>的道具传递下去。然后我们导出这些值来使用，如下所示。当我们开始使用它们时，情况会变得更清楚。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/0b889d0f77d91d894684a8b998e0cf8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*9N3M0Od1yt6sOYBB4u3lug.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">RecipeContext.provider</p></figure><p id="d6c0" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">接下来，我们必须定位组件层次结构中的最高树，以将<em class="ms">值</em> <strong class="lo iu"> <em class="ms"> </em> </strong>属性传递给。只有通过这种方式，它才能传递给所有的孩子。这就是我们根中的<code class="fe mj mk ml mm b">index.js</code>。这是<code class="fe mj mk ml mm b">App</code>组件所在的位置。<code class="fe mj mk ml mm b">App</code>组件能够将任何数据或状态作为道具传递到任何需要它们的地方。在应用程序根目录下的<code class="fe mj mk ml mm b">index.js</code>中，你应该将<code class="fe mj mk ml mm b">RecipeProvider</code> <em class="ms"> </em>包裹在<code class="fe mj mk ml mm b">App</code>周围，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a5d46d6647ed177d939ebbc66838fe24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*kgVgU3wOBtFbluduFuzLIw.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">索引. js</p></figure><p id="cbb4" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">从这里开始，所有的道具都在我们的上下文文件中传递，并且对于<code class="fe mj mk ml mm b">App</code>组件的所有子组件都是可用的，这实质上是每个组件。</p><p id="0433" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">令人兴奋的是我们将如何使用它。我们将以<code class="fe mj mk ml mm b">RecipeList</code>和<code class="fe mj mk ml mm b">RecipeSearch</code>组件为例。你的<code class="fe mj mk ml mm b">RecipeList</code> <em class="ms"> </em>组件应该如下图所示。</p><p id="1263" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们现在已经从文件中导入了<code class="fe mj mk ml mm b">RecipeContext</code> <em class="ms"> </em>，并从React中导入了<code class="fe mj mk ml mm b">useContext</code>。在我们的函数中，我们创建了一个变量来保存<code class="fe mj mk ml mm b">RecipeContext</code>的值。然后我们只在<code class="fe mj mk ml mm b">RecipeList</code> <strong class="lo iu">中获取我们需要的值。</strong></p><p id="9fdd" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">这在两个方面是干净的。首先，我们从需要这些州和数据的地方直接去了<code class="fe mj mk ml mm b">RecipeList</code>。我们不必把道具从父母传给孩子。第二，我们只提取了组件中需要的道具。我们不需要给<code class="fe mj mk ml mm b">RecipeList</code> <em class="ms"> </em>一些它除了传递给它的孩子之外不需要的道具。如果子组件需要数据，我们就直接去找它。</p><p id="1c15" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">让我们检查一下<code class="fe mj mk ml mm b">RecipeSearch</code>组件。再一次，让我们看看代码，然后解释它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="09b2" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">如在<code class="fe mj mk ml mm b">RecipeList</code>中，我们导入了<code class="fe mj mk ml mm b">useContext</code>和<code class="fe mj mk ml mm b">RecipeContext</code>。我们创造了变量。看看这有多简洁明了。我们不必从<code class="fe mj mk ml mm b">RecipeList</code>中获取<code class="fe mj mk ml mm b">handleSubmit</code> <em class="ms"> </em>和<code class="fe mj mk ml mm b">handleSearchChange</code>。我们只是简单地从上下文中抓取它们。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="383b" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">仅此而已。我们已经介绍了三种主要类型的钩子:<code class="fe mj mk ml mm b">useState</code>、<code class="fe mj mk ml mm b">useEffect</code>和<code class="fe mj mk ml mm b">useContext</code>、<em class="ms">。我相信这些是理解使用React钩子的更高级和更好的方法所必需的基础。我相信它们更干净，更容易消化。</em></p><p id="695a" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">接下来，如果您想获得更深入的理解，您可以重构<code class="fe mj mk ml mm b">Recipe</code> <em class="ms"> </em>组件以使用<code class="fe mj mk ml mm b">useContext</code>。拿一个带有类组件的老项目，用钩子把它转换成功能组件。如果你想要更有挑战性的东西，学习一下<code class="fe mj mk ml mm b">useReducer</code>钩子以及如何在我们的<code class="fe mj mk ml mm b">context</code>文件中重构多个状态来利用<code class="fe mj mk ml mm b">useReducer</code>。</p><p id="464d" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">谢谢大家！完整代码可以在<a class="ae mi" href="https://github.com/olajohn-ajiboye/Blog-React-Hook-Tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>