<html>
<head>
<title>Framer-Motion: The New And Underestimated Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帧运动:新的和被低估的功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/framer-motion-new-and-underestimated-features-364a6fdfcb57?source=collection_archive---------4-----------------------#2022-08-23">https://betterprogramming.pub/framer-motion-new-and-underestimated-features-364a6fdfcb57?source=collection_archive---------4-----------------------#2022-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a7bc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">动画有趣又刺激</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/edc63c1286046d7a2842fc2e0230337b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jU_J2qPMjIACJONKLZhN1Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者声明:Reijo Palmiste，</p></figure><h1 id="5182" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="1714" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp ir"> Framer-motion </strong>是一个motion库，允许你创建声明性动画、布局转换和手势，同时保持HTML和SVG元素语义。</p><p id="90ef" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">⚛️注意了，framer-motion是一个React-only库。</p><p id="87c9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><em class="mo">如果这对你来说是个问题，请查看一下</em><a class="ae mp" href="https://shakuro.com/blog/greensock-tutorial-for-beginners-web-animation-library" rel="noopener ugc nofollow" target="_blank"><em class="mo">green sock(框架不可知动画库)教程。</em> </a></p><p id="d703" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你可能熟悉我们之前关于这个主题的文章(<a class="ae mp" href="https://shakuro.com/blog/framer-motion-tutorials-make-more-advanced-animations" rel="noopener ugc nofollow" target="_blank">帧运动教程:制作更高级的动画</a>)。它在这个库的几个版本之前首次出现，所以在本文中我们想:</p><ul class=""><li id="a668" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated">介绍以前被忽视的和最近的功能。</li><li id="6556" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">移除样式化组件，使演示变得简单一些，并降低入门门槛</li><li id="b24a" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">涵盖如何使用<a class="ae mp" href="https://www.framer.com/docs/" rel="noopener ugc nofollow" target="_blank">框架-运动</a>，并考虑可及性(首选-减少运动)和捆尺寸。</li></ul><h1 id="210b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated"><strong class="ak">内容</strong></h1><ul class=""><li id="a88c" class="mq mr iq lp b lq lr lt lu lw ne ma nf me ng mi mv mw mx my bi translated">设置</li><li id="fdaa" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">关键帧</li><li id="9926" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">手势动画</li><li id="458d" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">易接近</li><li id="8880" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">运动配置和简化运动</li><li id="4eca" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">useReducedMotion</li><li id="f25c" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">如何在普通CSS和JavaScript中使用偏好减少动作</li><li id="57bd" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">滚动触发动画(whileInView)</li><li id="bf58" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">滚动链接动画(useViewportScroll，useTransform)</li><li id="0ad7" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">非定制方法</li><li id="ebd7" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">自定义useElementViewportPosition挂钩</li><li id="0e53" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">使用LazyMotion减小包的大小</li><li id="2c0b" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">同步加载</li><li id="77fe" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">异步加载</li><li id="41c3" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">束尺寸测试</li><li id="cd8c" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">布局动画</li><li id="2e1c" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">共享布局动画</li><li id="588c" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">结论</li></ul><h1 id="ebe3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">设置</h1><p id="65f1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">您可以通过两个简单的步骤从帧运动开始:</p><ul class=""><li id="9af5" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated">将包添加到项目中:运行<code class="fe nh ni nj nk b">npm install framer-motion</code>或<code class="fe nh ni nj nk b">yarn add framer-motion</code>。</li><li id="90b2" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">进口<code class="fe nh ni nj nk b">motion</code>组件。</li><li id="9018" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">用<code class="fe nh ni nj nk b">motion</code>组件开始动画制作(用<code class="fe nh ni nj nk b">motion</code>前缀重命名任何HTML标签，例如<code class="fe nh ni nj nk b">motion.div</code>、<code class="fe nh ni nj nk b">motion.p</code>、<code class="fe nh ni nj nk b">motion.rect</code>)，并用非常简单的<code class="fe nh ni nj nk b">animate</code>道具配置动画。</li></ul><p id="3790" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">魔法已经触手可及！</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="2e4e" class="np kw iq nk b gy nq nr l ns nt">import { motion } from 'framer-motion';<br/> <br/>export const MotionBox = ({ isAnimating }: { isAnimating: boolean }) =&gt; {<br/> return (<br/>  &lt;motion.div animate={{ opacity: isAnimating ? 1 : 0 }} /&gt;;<br/>};</span></pre><h1 id="6bfd" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">关键帧</h1><p id="b065" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe nh ni nj nk b">animate</code>中的值不仅可以接受单个值(查看前面的例子⬆️),还可以接受一个值数组，这与CSS关键帧非常相似。</p><p id="8163" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">默认情况下，<a class="ae mp" href="https://www.framer.com/docs/animation/%23%2523keyframes" rel="noopener ugc nofollow" target="_blank">关键帧</a>动画将从数组的第一个值开始。可以使用<code class="fe nh ni nj nk b">null</code>占位符设置当前值，以便在值已经动画化的情况下创建无缝过渡。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="9327" class="np kw iq nk b gy nq nr l ns nt">&lt;motion.div <br/> style={{ transform: 'scale(1.2)' }} <br/> animate={{ scale: [null, 0.5, 1, 0] }}<br/>/&gt;</span></pre><p id="69ab" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">默认情况下，关键帧数组中的每个值在整个动画中均匀分布。要覆盖它并为每个关键帧步骤定义定时，请通过<em class="mo">乘以</em>(一个介于0和1之间的值数组。它应该具有与关键帧动画数组相同的长度)到<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/transition/" rel="noopener ugc nofollow" target="_blank">transition</a></code>道具。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="2fb4" class="np kw iq nk b gy nq nr l ns nt">&lt;motion.div<br/>     animate={{ opacity: [0, 0.2, 0.8, 1] }}<br/>     transition={{ ease: 'easeInOut', duration: 3, times: [0, 0.5, 0.6, 1] }}<br/>   /&gt;</span></pre><p id="0d03" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们制作一些SVG动画。要创建一个基本的旋转装载机，我们需要:</p><ol class=""><li id="54bc" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi nu mw mx my bi translated"><code class="fe nh ni nj nk b">rotate</code>:360°动画和根svg元素上的<code class="fe nh ni nj nk b">transform-origin: center</code> ( <code class="fe nh ni nj nk b">originX</code>和<code class="fe nh ni nj nk b">originY</code>)。</li><li id="40cc" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi nu mw mx my bi translated">CSS属性的关键帧数组:</li><li id="c28c" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi nu mw mx my bi translated"><code class="fe nh ni nj nk b"><a class="ae mp" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray" rel="noopener ugc nofollow" target="_blank">stroke-dasharray</a></code>(形状轮廓的虚线和间隙图案)。</li><li id="2a93" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi nu mw mx my bi translated"><code class="fe nh ni nj nk b"><a class="ae mp" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dashoffset" rel="noopener ugc nofollow" target="_blank">stroke-dashoffset</a></code>(虚线数组渲染上的偏移)。</li></ol><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="ef8b" class="np kw iq nk b gy nq nr l ns nt">&lt;motion.svg<br/>     {...irrelevantStyleProps}<br/>     animate={{ rotate: 360 }}<br/>     transition={{ ease: 'linear', repeat: Infinity, duration: 4 }}<br/>     style={{ originX: 'center', originY: 'center' }}<br/>   &gt;<br/>     &lt;circle    {...irrelevantProps} /&gt;<br/>     &lt;motion.circle<br/>       {...irrelevantStyleProps}<br/>       animate={{<br/>         strokeDasharray: ['1, 150', '90, 150', '90, 150'],<br/>         strokeDashoffset: [0, -35, -125],<br/>       }}<br/>       transition={{ ease: 'easeInOut', repeat: Infinity, duration: 2 }}<br/>     /&gt;<br/>   &lt;/motion.svg&gt;</span></pre><p id="b3de" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您可以在下面的演示中将CSS关键帧与<code class="fe nh ni nj nk b">framer-motion</code>关键帧动画进行比较。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ece8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我个人认为这两种实现的难度没有区别。</p><p id="4af6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">大概是个人喜好或者项目特殊性的问题吧。在任何情况下，我觉得CSS关键帧应该是这种类型动画的首选解决方案，特别是如果不需要任何复杂的计算或性能问题(交付较少的JavaScript通常更好)，并且如果project还没有将<strong class="lp ir"> framer-motion </strong>用于其他明显的事情。</p><h1 id="74fd" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">手势动画</h1><p id="17c9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><em class="mo">运动</em>组件允许我们用<code class="fe nh ni nj nk b">whileHover</code>、<code class="fe nh ni nj nk b">whileTap</code>、<code class="fe nh ni nj nk b">whileDrag</code>和<code class="fe nh ni nj nk b">whileFocus</code>道具来制作交互元素的动画。</p><p id="02f1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">就像任何其他类型的动画一样，我们可以将动画直接传递到道具中:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="a806" class="np kw iq nk b gy nq nr l ns nt">&lt;motion.button whileHover={{ scale: 1.2 }}&gt;Submit&lt;/motion.button&gt;</span></pre><p id="5f1f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">或者使用<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/examples/%23variants" rel="noopener ugc nofollow" target="_blank">variants</a></code>进行更复杂的定制:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="8137" class="np kw iq nk b gy nq nr l ns nt">import { motion, Variants } from 'framer-motion';<br/> <br/>const variants: Variants = { variants: { tap: { scale: 0.9 } } };<br/> <br/>export const Component = () =&gt; {<br/> return (<br/>   &lt;motion.button variants={variants} whileTap="tap"&gt;<br/>     Send<br/>   &lt;/motion.button&gt;<br/> );<br/>};</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4e33" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">与<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.notion.so/Framer-motion-overlooked-and-new-features-better-title-4cd6798ded494b51ac0905ee7db037b8" rel="noopener ugc nofollow" target="_blank">keyframes</a></code>类似，在不需要复杂计算或过渡的情况下，那些道具(除了<code class="fe nh ni nj nk b">whileDrag</code>之外)大部分都可以轻松替换成CSS动画。</p><h1 id="d945" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">易接近</h1><h1 id="01f7" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">运动配置和简化运动</h1><p id="3660" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">网页上的动画可以用来吸引对某些元素的注意，或者使用户界面/UX体验更加流畅和愉快。但是视差效果、淡入淡出弹出窗口或者基本上任何移动或闪烁的元素可能会导致晕动病，或者以任何其他方式对用户来说可能不方便或不舒服。</p><p id="907b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">因此，为了<a class="ae mp" href="https://www.framer.com/docs/guide-accessibility/" rel="noopener ugc nofollow" target="_blank">可访问性</a>和性能原因，我们需要给出一个<a class="ae mp" href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion%23user_preferences" rel="noopener ugc nofollow" target="_blank">选项来限制甚至禁用页面上的任何动作</a>，并且，作为开发人员，要尊重这个选择并确保它被实现。</p><p id="4535" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nh ni nj nk b"><a class="ae mp" href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion" rel="noopener ugc nofollow" target="_blank">prefers-reduced-motion</a></code>是一个CSS媒体功能，用于检测用户是否在其系统设置中被指示减少不必要的动作。</p><p id="383e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">关于该主题的更多信息:</strong></p><ul class=""><li id="7f74" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated"><a class="ae mp" href="https://css-tricks.com/introduction-reduced-motion-media-query/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">【约简运动】媒体查询</strong> </a>作者<a class="ae mp" href="https://ericwbailey.design/" rel="noopener ugc nofollow" target="_blank"> <em class="mo">埃里克·贝利</em></a>T22、<em class="mo">2017年2月10日</em></li><li id="12b1" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated"><a class="ae mp" href="https://www.smashingmagazine.com/2021/10/respecting-users-motion-preferences/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">尊重用户的运动偏好</strong> </a>作者<a class="ae mp" href="https://css-irl.info/" rel="noopener ugc nofollow" target="_blank"> <em class="mo">米歇尔巴克</em></a><em class="mo"/><em class="mo">2021年10月21日</em></li></ul><p id="8f14" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了用<code class="fe nh ni nj nk b">framer-motion</code><strong class="lp ir"/>正确实现<code class="fe nh ni nj nk b">prefers-reduced-motion</code>，我们可以使用<code class="fe nh ni nj nk b">MotionConfig</code>——一个允许我们为所有子<em class="mo">运动</em>组件设置默认选项的组件。</p><p id="8347" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">目前in只带2个道具:<code class="fe nh ni nj nk b">transition</code>和<code class="fe nh ni nj nk b">reducedMotion</code>。</p><p id="a15c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/motion-config/%23reducedmotion" rel="noopener ugc nofollow" target="_blank">reducedMotion</a></code>让我们设定一个处理减速运动的策略:</p><ul class=""><li id="f3a4" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated"><code class="fe nh ni nj nk b">user</code> —尊重用户的设备设置；</li><li id="e753" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated"><code class="fe nh ni nj nk b">always</code> —强制减少运动；</li><li id="37df" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated"><code class="fe nh ni nj nk b">never </code> —不要减少运动。</li></ul><p id="626a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在减少运动的情况下，<code class="fe nh ni nj nk b">transform</code>和<code class="fe nh ni nj nk b">layout</code>动画将被禁用，而不透明度或<code class="fe nh ni nj nk b">backgroundColor</code>等动画将保持启用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4e4c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在这个特别的演示中，我在动态改变<code class="fe nh ni nj nk b">reduceMotion</code>值时遇到了麻烦。不是换内<code class="fe nh ni nj nk b">Context.Provider</code>道具，除非我过了<code class="fe nh ni nj nk b">key={reducedMotion}</code>。这是一个非常有问题的临时解决方案，只是为了让它工作，但同时它会触发重新渲染，这离完美的解决方案还很远，而且肯定不是生产就绪的解决方案。</p><h1 id="b8cc" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">useReducedMotion</h1><p id="496d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对于更加定制和复杂的解决方案，或者对于库范围之外的任何任务(例如，禁用视频自动播放)，我们可以使用<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/utilities/%23usereducedmotion" rel="noopener ugc nofollow" target="_blank">useReducedMotion</a></code>钩子:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="77c5" class="np kw iq nk b gy nq nr l ns nt">import { useReducedMotion, motion } from 'framer-motion';</span><span id="20b7" class="np kw iq nk b gy nx nr l ns nt">export const Component = () =&gt; {<br/> const shouldReduceMotion = useReducedMotion();<br/> return(<br/>   &lt;motion.div<br/>    animate={shouldReduceMotion ? { opacity: 1 } : { x: 100 }} <br/>    /&gt;<br/>);<br/>}</span></pre><p id="efd9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">无论作为用户还是开发者，我都很高兴看到<strong class="lp ir"> framer-motion </strong>非常认真地对待<a class="ae mp" href="https://www.framer.com/docs/guide-accessibility/" rel="noopener ugc nofollow" target="_blank">可访问性</a>，并为我们提供适当的工具来满足任何用户的需求。即使我们有合适的JavaScript和CSS解决方案来做同样的事情。</p><h1 id="0c1f" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">如何在普通CSS和JavaScript中使用偏好减少动作</h1><p id="5472" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">您也可以通过使用<a class="ae mp" href="https://web.dev/prefers-reduced-motion/%23working-with-the-media-query" rel="noopener ugc nofollow" target="_blank"><em class="mo">prefers-reduced-motion</em>media-query with CSS</a>来实现相同的目的:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="40a6" class="np kw iq nk b gy nq nr l ns nt">@media (prefers-reduced-motion: reduce) {<br/> button {<br/>   animation: none;<br/> }<br/>}<br/> <br/>@media (prefers-reduced-motion: no-preference) {<br/> button {<br/>   /* `scale-up-and-down` keyframes are defined elsewhere */<br/>   animation: scale-up-and-down 0.3s ease-in-out infinite both;<br/> }<br/>}</span></pre><p id="1f92" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">或者<a class="ae mp" href="https://web.dev/prefers-reduced-motion/%23:~:text=motion:%2520no-preference)%2522%253E-,To%2520illustrate%2520how%2520to%2520work%2520with%2520prefers-reduced-motion%2520with,window.matchMedia('(prefers-reduced-motion:%2520reduce)'),-Demo%2520%2523" rel="noopener ugc nofollow" target="_blank"><em class="mo">window . match media()</em>带JavaScript </a>:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="d0f9" class="np kw iq nk b gy nq nr l ns nt">const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');<br/> <br/>mediaQuery.addEventListener('change', () =&gt; {<br/> const isPrefersReducedMotion = mediaQuery.matches;<br/> console.log({ isPrefersReducedMotion });<br/> <br/> if (isPrefersReducedMotion === true) {<br/>   // disable animation<br/> }<br/>});</span></pre><h1 id="cc96" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">滚动触发动画(whileInView)</h1><p id="5c68" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">滚动触发动画是一种很好的方式来吸引用户的注意力，并使元素更加动态。</p><p id="8e09" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了创建带有帧运动的<a class="ae mp" href="https://www.framer.com/docs/examples/%23scroll-triggered-animations" rel="noopener ugc nofollow" target="_blank">滚动触发动画</a>，让我们使用<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/gestures/%23%2523%2523whileinview" rel="noopener ugc nofollow" target="_blank">whileInView</a></code>道具。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="9920" class="np kw iq nk b gy nq nr l ns nt">&lt;motion.div<br/> initial={{ opacity: 0, y: -100 }} <br/> whileInView={{ opacity: 1, y: 0 }} <br/>/&gt;</span></pre><p id="287e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们也可以使用返回<code class="fe nh ni nj nk b"><a class="ae mp" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry" rel="noopener ugc nofollow" target="_blank">IntersectionObserverEntry</a></code>的<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/gestures/%23%2523%2523onviewportenter" rel="noopener ugc nofollow" target="_blank">onViewportEnter</a></code>和<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/gestures/%23%2523%2523onviewportleave" rel="noopener ugc nofollow" target="_blank">onViewportLeave</a></code>回调。</p><p id="645f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们使用<em class="mo">变体</em> ⬇️，这使得定义更复杂的动画变得容易一些。</p><p id="d20a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">还有一种方法是用<a class="ae mp" href="https://www.framer.com/docs/gestures/%23%2523viewport-options" rel="noopener ugc nofollow" target="_blank"> <em class="mo">视口</em> </a>设置配置道具，有些选项我们可以使用:</p><ul class=""><li id="9f35" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated"><code class="fe nh ni nj nk b">once</code> <em class="mo">:布尔型</em> —如果为真，<code class="fe nh ni nj nk b">whileInView</code>动画仅触发一次。</li><li id="fd3a" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated"><code class="fe nh ni nj nk b">amount</code> <em class="mo">:'部分' | '全部' |号</em> —默认:<code class="fe nh ni nj nk b">some</code>。描述元素为了在视图中被考虑而必须与视口相交的量；<code class="fe nh ni nj nk b">number</code>值可以是0到1之间的任何值。</li></ul><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="7858" class="np kw iq nk b gy nq nr l ns nt">import { motion, Variants } from 'framer-motion';<br/> <br/>const variants: Variants = {<br/> hidden: { opacity: 0 },<br/> visible: { opacity: 1 },<br/> slideStart: { clipPath: 'inset(0 100% 0 0 round 8px)' },<br/> slideEnd: { clipPath: 'inset(0 0% 0 0 round 8px)' },<br/>};<br/> <br/>export const Component = () =&gt; {<br/> return (<br/>   &lt;motion.div<br/>     variants={variants}<br/>     initial={['hidden', 'slideStart']}<br/>     whileInView={['visible', 'slideEnd']}<br/>     exit={['hidden', 'slideStart']}<br/>     viewport={{ amount: 0.4, once: true }}<br/>   /&gt;<br/> );<br/>};</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1c3c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">一个不幸的限制是<em class="mo">while view</em>不能和<code class="fe nh ni nj nk b">transition: { repeat: Infinity }</code>一起工作。因此，没有简单的方法来无限重复动画，只在用户视口中播放。<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/gestures/%23%2523%2523onviewportenter" rel="noopener ugc nofollow" target="_blank">onViewportEnter</a></code>和<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/gestures/%23%2523%2523onviewportleave" rel="noopener ugc nofollow" target="_blank">onViewportLeave</a></code>回调(用⚛️ React的钩子<code class="fe nh ni nj nk b">useState</code>和<code class="fe nh ni nj nk b">useCallback</code>)大概是最好的办法。</p><h1 id="cfd9" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">滚动链接动画(useViewportScroll，<a class="ae mp" href="https://www.framer.com/docs/motionvalue/%23%2523usetransform" rel="noopener ugc nofollow" target="_blank"> useTransform </a></h1><p id="f7a8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了更进一步，我们来谈谈<a class="ae mp" href="https://www.framer.com/docs/examples/%23scroll-linked-animations" rel="noopener ugc nofollow" target="_blank">滚动链接动画</a>，它有点类似于滚动触发动画，但更有趣！✨</p><p id="385e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/motionvalue/%23%2523useviewportscroll" rel="noopener ugc nofollow" target="_blank">useViewportScroll</a></code>和<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/motionvalue/%23%2523usetransform" rel="noopener ugc nofollow" target="_blank">useTransform</a></code>是绑定到滚动和滚动位置的动画。滚动触发动画给用户带来了更刺激的浏览体验。它可以用来抓住用户的注意力，是一个很好的创造性讲故事的工具。</p><p id="33b5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">大概滚动链接动画最流行的选择是<a class="ae mp" href="https://greensock.com/scrolltrigger/" rel="noopener ugc nofollow" target="_blank">格林斯托克的ScrollTrigger </a>(就像我们演示的)。</p><p id="c89a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">不幸的是，与GreenSock相比，带有<code class="fe nh ni nj nk b">framer-motion</code>的滚动链接动画将需要更多的自定义解决方案，并且需要更多的时间来实现。让我们找出原因，一步步想出办法。</p><h1 id="0d2e" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">非定制方法</h1><p id="ce84" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对于带有<strong class="lp ir">帧运动的滚动链接动画，</strong>我们需要:</p><ol class=""><li id="3e7f" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi nu mw mx my bi translated"><code class="fe nh ni nj nk b">useViewportScroll</code>钩子，返回4个不同的<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/motionvalue/%23%2523%2523useviewportscroll" rel="noopener ugc nofollow" target="_blank">MotionValues</a></code>，我们将只使用其中的一个——<code class="fe nh ni nj nk b">scrollYProgress</code>(在<em class="mo"> 0 </em>和<em class="mo"> 1 </em>之间垂直滚动进度)。</li><li id="cbee" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi nu mw mx my bi translated"><code class="fe nh ni nj nk b">useTransform</code> — hook，它创建一个<code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/motionvalue/" rel="noopener ugc nofollow" target="_blank">MotionValue</a></code>，通过将另一个<code class="fe nh ni nj nk b">MotionValue</code>的输出从一个值范围映射到另一个值范围来转换它。在本演示中，我们将使用下一组道具传递给挂钩:</li></ol><p id="26be" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">a) <code class="fe nh ni nj nk b">scrollYProgress</code>将垂直页面滚动与动画同步；</p><p id="8dfd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">b) <code class="fe nh ni nj nk b">[0, 1]</code> —动画播放时<code class="fe nh ni nj nk b">scrollYProggress</code>的范围；</p><p id="3df5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">c) <code class="fe nh ni nj nk b">[“0%”, “-100%”]</code> —垂直滚动变化时x的变换范围。</p><p id="ee91" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">长话短说，钩子变换<em class="mo">运动</em>组件的<em class="mo"> x </em>(水平变换值)，而<code class="fe nh ni nj nk b">scrollYProgress</code>在从<em class="mo"> 0% </em>到–<em class="mo">100%</em>的0和1(从页面开始到最底部)之间的范围内。</p><p id="5dd4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">它并没有完全解释钩子是如何工作的，以及它可以使用什么样的道具。查看useTransform的完整文档。</p><p id="60e5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">3.为了以某种方式复制GreenSock的<code class="fe nh ni nj nk b">ScrollTrigger</code>——在制作动画时将<em class="mo">运动</em>组件固定在视口中，我们需要将其包装到两个包装器中，外层包装器必须具有<em class="mo">高度</em> &gt;视口高度，内层包装器必须具有<em class="mo"> </em> <code class="fe nh ni nj nk b">position: sticky</code>和<code class="fe nh ni nj nk b">top: 0</code>；<code class="fe nh ni nj nk b">position: fixed</code>，根据动画的不同，或许也能奏效。</p><p id="cb75" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在⬇️下面或者在<a class="ae mp" href="https://codesandbox.io/s/framer-motion-scroll-linked-animation-useviewportscroll-usetransform-yfdo29?from-embed=&amp;file=/src/styles.css:490-508" rel="noopener ugc nofollow" target="_blank">沙盒演示</a>中查看完整的造型。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="12f6" class="np kw iq nk b gy nq nr l ns nt">import { motion, useTransform, useViewportScroll } from 'framer-motion';<br/> <br/>export const Component = () =&gt; {<br/> const { scrollYProgress } = useViewportScroll();<br/> <br/> const x = useTransform(scrollYProgress, [0, 1], ['0%', '-100%']);<br/> <br/> return (<br/>   &lt;div style={{ height: '300vh' }}&gt;<br/>     &lt;div<br/>       style={{<br/>         position: 'sticky',<br/>         top: 0,<br/>         height: '100vh',<br/>         width: '100%',<br/>         overflow: 'hidden',<br/>       }}<br/>     &gt;<br/>       &lt;motion.p style={{ x }}&gt;<br/>         Rainbow Rainbow Rainbow<br/>       &lt;/motion.p&gt;<br/>     &lt;/div&gt;<br/>   &lt;/div&gt;<br/> );<br/>};</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7281" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你可能已经注意到了这种滚动触发动画的主要问题。首先，动画通过整个页面的滚动播放，而不是它的一部分。第二个问题是，动画化<em class="mo"> x </em>从<em class="mo"> 0% </em>到<em class="mo"> -100% </em>使得<em class="mo">运动</em>组件在页面滚动结束前从视窗中滚动出来(部分或全部，取决于视窗宽度)。</p><p id="c602" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们在下一章⬇️中通过使用自定义钩子来解决这些问题。</p><h1 id="94fd" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">自定义useElementViewportPosition挂钩</h1><p id="11e7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了解决上一章⬆️中描述的问题，让我们创建一个自定义钩子，它将允许我们计算元素可见的视口范围。</p><p id="8b2c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">自定义<code class="fe nh ni nj nk b">useElementViewportPosition</code>返回<code class="fe nh ni nj nk b">position</code>—<code class="fe nh ni nj nk b">useTransform</code>钩子的第二个属性的值——范围在0和1之间(例如，<code class="fe nh ni nj nk b">position = [0.2, 0.95]</code>表示该范围在视口的20%到95%之间)。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="e875" class="np kw iq nk b gy nq nr l ns nt">// * based on: <a class="ae mp" href="https://gist.github.com/coleturner/34396fb826c12fbd88d6591173d178c2" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/coleturner/34396fb826c12fbd88d6591173d178c2</a><br/>function useElementViewportPosition(ref: React.RefObject&lt;HTMLElement&gt;) {<br/> const [position, setPosition] = useState&lt;[number, number]&gt;([0, 0]);<br/> <br/> useEffect(() =&gt; {<br/>   if (!ref || !ref.current) return;<br/> <br/>   const pageHeight = document.body.scrollHeight;<br/>   const start = ref.current.offsetTop;<br/>   const end = start + ref.current.offsetHeight;<br/> <br/>   setPosition([start / pageHeight, end / pageHeight]);<br/>   // eslint-disable-next-line react-hooks/exhaustive-deps<br/> }, []);<br/> <br/> return { position };<br/>}</span></pre><p id="b509" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了找出<code class="fe nh ni nj nk b">useTransform</code>的第三个支柱，我们需要计算<code class="fe nh ni nj nk b">carouselEndPosition</code> —要转换到的最终值。它基本上是用<code class="fe nh ni nj nk b">motion</code>组件的宽度减去窗口的宽度。查看<a class="ae mp" href="https://codesandbox.io/s/framer-motion-scroll-linked-animation-useviewportscroll-usetransform-and-custom-useelementviewportposition-hook-p25mx9?file=/src/App.tsx:1442-2226" rel="noopener ugc nofollow" target="_blank">沙盒演示</a>中的详细计算。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="ae3b" class="np kw iq nk b gy nq nr l ns nt">import { motion, useTransform, useViewportScroll } from 'framer-motion';<br/> <br/>export const Component = () =&gt; {<br/> const ref = useRef&lt;HTMLDivElement&gt;(null);<br/> const carouselRef = useRef&lt;HTMLDivElement&gt;(null);<br/> const { position } = useElementViewportPosition(ref);<br/> const [carouselEndPosition, setCarouselEndPosition] = useState(0);<br/> const { scrollYProgress } = useViewportScroll();<br/> const x = useTransform(scrollYProgress, position, [0, carouselEndPosition]);<br/> <br/>  useEffect(() =&gt; {<br/>   // calculate carouselEndPosition<br/> }, []);<br/> <br/> return (<br/>   &lt;div&gt;<br/>     {/* content */}<br/>     &lt;section ref={ref}&gt;<br/>       &lt;div className="container" style={{ height: "300vh" }}&gt;<br/>         &lt;div className="sticky-wrapper"&gt;<br/>           &lt;motion.div ref={carouselRef} className="carousel" style={{ x }}&gt;<br/>             {[0, 1, 2, 3, 4].map((i) =&gt; (<br/>               &lt;div key={i} className="carousel__slide"&gt;<br/>                 {i + 1}<br/>               &lt;/div&gt;<br/>             ))}<br/>           &lt;/motion.div&gt;<br/>         &lt;/div&gt;<br/>       &lt;/div&gt;<br/>     &lt;/section&gt;<br/>     {/* content */}<br/>   &lt;/div&gt;<br/> );<br/>};</span></pre><p id="7aeb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在动画的开始和结束点，以及转换值，使演示看起来更有意图和深思熟虑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c633" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我不完全确定这是处理这种动画的最好方法，但这是我目前能想到的最好方法。我很好奇别人是怎么解决这个的。例如，CodeSandbox项目非常有趣<a class="ae mp" href="https://projects.codesandbox.io/" rel="noopener ugc nofollow" target="_blank">滚动链接动画登陆</a>，看起来它可能是用framer-motion构建的。</p><h1 id="34b0" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">使用LazyMotion减小包的大小</h1><p id="eb1d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">可能每个React ⚛️开发人员在他们职业生涯的某个时候都不得不面对膨胀的包大小问题。少发布一些JavaScript可能会解决这个问题。</p><p id="a44c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了弄清楚您的项目的包大小以及哪些可以改进，我推荐<a class="ae mp" href="https://www.npmjs.com/package/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank"> webpack-bundle-analyzer </a>。在分析你的包之后，你会发现你有一个巨大的包，它的唯一目的是做一些无关紧要的改变，这些改变可以很容易地被某种普通的解决方案所取代。</p><p id="2c41" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">同样的担心可能与动画库有关，它通常有相当大的尺寸。如果您的项目不严重依赖复杂的动画和/或有包大小或性能问题，您可以考虑部分或全部转移到CSS动画，甚至完全摆脱动画。弄清楚你的优先事项:真的值得使用沉重的令人瞠目结舌的动画，使大多数低泪和中泪设备滞后，过载或过热吗？它可能会也可能不会，这取决于项目、它的目的和受众。</p><p id="2f3f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">幸运的是，framer-motion覆盖了我们！</p><p id="a3db" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mp" href="https://www.framer.com/docs/lazy-motion/" rel="noopener ugc nofollow" target="_blank"> <em class="mo"> LazyMotion </em> </a>是一个非常方便的组件，可以帮助我们<a class="ae mp" href="https://www.framer.com/docs/lazy-motion/" rel="noopener ugc nofollow" target="_blank">减少包的大小</a>。它同步或异步加载部分或全部<em class="mo">运动</em>组件的特征。</p><p id="a643" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">文档指出，默认情况下使用<em class="mo"> motion </em>组件会增加大约25kb的包大小，而对于<em class="mo"> LazyMotion </em>和<em class="mo"> m </em>组件则不到5kb。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="1425" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">同步加载</h1><p id="09d2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们如何才能实现高达5倍的捆绑包尺寸缩减？与<a class="ae mp" href="https://www.framer.com/docs/guide-reduce-bundle-size/%23synchronous-loading" rel="noopener ugc nofollow" target="_blank">同步加载</a>。通过用<code class="fe nh ni nj nk b">LazyMotion</code>包装动画组件并将需要的特性(<code class="fe nh ni nj nk b">domAnimation</code>或<code class="fe nh ni nj nk b">domMax</code>)传递给特性道具。最后一步是将常规运动分量替换为其较小的孪生分量— <em class="mo"> m </em>。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="18d2" class="np kw iq nk b gy nq nr l ns nt">import { LazyMotion, domAnimation, m } from 'framer-motion';<br/> <br/>export const MotionBox = ({ isAnimating }: { isAnimating: booolean }) =&gt; (<br/> &lt;LazyMotion features={domAnimation}&gt;<br/>   &lt;m.div animate={isAnimating ? { x: 100 } : { x: 0 }} /&gt;<br/> &lt;/LazyMotion&gt;<br/>);</span></pre><h1 id="e349" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">异步加载</h1><p id="15d6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们可以通过使用<em class="mo"> LazyMotion </em> <em class="mo">特性</em>的<a class="ae mp" href="https://www.framer.com/docs/guide-reduce-bundle-size/%23async-loading" rel="noopener ugc nofollow" target="_blank">异步加载</a>来为用户节省几个KB。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/a33d554a75eaa13bde01716d89f5677f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*YiM78nSlWUyRB2o7.gif"/></div></figure><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="2fa5" class="np kw iq nk b gy nq nr l ns nt">// dom-max.ts<br/> <br/>export { domMax } from 'framer-motion';<br/> <br/>// modal.tsx<br/> <br/>import { LazyMotion, m } from 'framer-motion';<br/> <br/>const loadDomMaxFeatures = () =&gt;<br/> import('./dom-max').then(res =&gt; res.domMax);<br/> <br/>export const Modal = ({ isOpen }: { isOpen: booolean}) =&gt; (<br/> &lt;AnimatePresence exitBeforeEnter initial={false}&gt;<br/>   {isOpen &amp;&amp; (<br/>     &lt;LazyMotion features={loadDomMaxFeatures} strict&gt;<br/>       &lt;m.div<br/>         variants={ { open: { opacity: 1 }, collapsed: { opacity: 0 } } }<br/>         initial="collapsed"<br/>         animate="open"<br/>         exit="collapse"<br/>       &gt;<br/>         // modal content<br/>       &lt;m.div&gt;<br/>     &lt;/LazyMotion&gt;<br/>   }<br/> &lt;/AnimatePresence&gt;<br/>);</span></pre><p id="a4c6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nh ni nj nk b"><a class="ae mp" href="https://www.framer.com/docs/animate-presence/" rel="noopener ugc nofollow" target="_blank">AnimatePresence</a></code>在这种情况下，组件不是必需的，但是对于组件卸载时的任何动画来说，它是必不可少的。<a class="ae mp" href="https://shakuro.com/blog/framer-motion-tutorials-make-more-advanced-animations" rel="noopener ugc nofollow" target="_blank">你可以在这里</a>了解更多 <code class="fe nh ni nj nk b"><a class="ae mp" href="https://shakuro.com/blog/framer-motion-tutorials-make-more-advanced-animations" rel="noopener ugc nofollow" target="_blank">AnimatePresence</a></code> <a class="ae mp" href="https://shakuro.com/blog/framer-motion-tutorials-make-more-advanced-animations" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="fdfc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">模态、手风琴、旋转木马和几乎所有其他需要用户交互的动画都可以从中受益。</p><h1 id="9444" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">束尺寸测试</h1><p id="9b61" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我测试了LazyMotion可以在多大程度上减少我们的实时项目的包大小(同步加载特性):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/fbc6849e038a24f5351a00ef9505c505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PLbe0Xc-qfmK1ZJGoltFw.png"/></div></div></figure><p id="6514" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">虽然不多，但我对结果很满意。考虑到实现起来如此轻松，包大小减少5-10KB是非常重要的。</p><h1 id="066a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">布局动画</h1><p id="867c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通过<em class="mo">布局</em>道具自动制作运动组件<code class="fe nh ni nj nk b">layout</code>的动画。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="34c7" class="np kw iq nk b gy nq nr l ns nt">&lt;motion.div layout /&gt;</span></pre><p id="8263" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">哪个CSS属性会导致布局变化(宽度、高度、伸缩方向等)并不重要<strong class="lp ir"> framer-motion </strong>将使用transform对其进行动画处理，以确保最佳性能。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="cff7" class="np kw iq nk b gy nq nr l ns nt">import { useCallback, useState } from 'react';<br/>import { motion } from 'framer-motion';<br/> <br/>const flexDirectionValues = ['column', 'row'];<br/> <br/>export const LayoutAnimationComponent = () =&gt; {<br/> const [flexDirection, setFlexDirection] = useState(flexDirectionValues[0]);<br/> <br/> const handleFlexDirection = useCallback(({ target }) =&gt; {<br/>   setFlexDirection(target.value);<br/> },[]);<br/> <br/> return (<br/>   &lt;div&gt;<br/>     {flexDirectionValues.map((value) =&gt; (<br/>       &lt;button<br/>         key={value}<br/>         value={value}<br/>         onClick={handleFlexDirection}<br/>       &gt;<br/>         {value}<br/>       &lt;/button&gt;<br/>     ))}<br/>     &lt;div style={{ display: 'flex', flexDirection }}&gt;<br/>       {[1, 2, 3].map((item) =&gt; (<br/>         &lt;motion.div layout key={item} transition={{ type: 'spring' }} /&gt;<br/>       ))}<br/>     &lt;/div&gt;<br/>   &lt;/div&gt;<br/> );<br/>};</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f6f7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">起初，我并没有意识到<a class="ae mp" href="https://www.framer.com/docs/examples/%23layout-animations" rel="noopener ugc nofollow" target="_blank"> <em class="mo">布局</em> </a>动画是多么容易、有用和多功能，但这真的很少见！</p><h1 id="088f" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">共享布局动画</h1><p id="7e1f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">类似于布局动画，<a class="ae mp" href="http://framer.com/docs/examples/%23shared-layout-animations" rel="noopener ugc nofollow" target="_blank">共享布局动画</a>让我们有机会在彼此之间自动制作<em class="mo">运动</em>组件的动画。为此，只需给多个<em class="mo">运动</em>组件相同的<code class="fe nh ni nj nk b">layoutId</code>道具。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="fdf7" class="np kw iq nk b gy nq nr l ns nt">import { motion } from 'framer-motion';<br/> <br/>const bullets = [1, 2, 3];<br/> <br/>export const Bullets = ({ currentIndex }: { currentIndex: number }) =&gt; {<br/> return (<br/>   &lt;div className="bullets"&gt;<br/>     {bullets.map((bullet, index) =&gt; (<br/>       &lt;div key={index} className="bullet"&gt;<br/>         &lt;button&gt;{bullet}&lt;/button&gt;<br/>         {index === currentIndex &amp;&amp; &lt;motion.div layoutId="indicator" className="indicator" /&gt;<br/>          )}<br/>       &lt;/div&gt;<br/>     ))}<br/>   &lt;/div&gt;<br/> );<br/>};</span></pre><p id="b22c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">看一看滑块的导航/项目符号按钮下的蓝绿色圆点，并尝试导航。当一个点从一个项目符号平滑地移动到另一个项目符号时，它看起来像是同一个元素，但实际上不是！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4b3d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">考虑到我们感兴趣的只是一个小点，这个特别的演示可能看起来有点过分。但是它也使用<a class="ae mp" href="https://www.framer.com/docs/animate-presence/" rel="noopener ugc nofollow" target="_blank"><em class="mo">animate presence</em></a>组件在组件卸载之前执行退出动画，这在许多不同的用例中可能非常有用。<a class="ae mp" href="https://codesandbox.io/s/framer-motion-shared-layout-animations-sw9huv" rel="noopener ugc nofollow" target="_blank">查看沙盒演示，了解如何使用AnimatePresence </a>。</p><h1 id="8614" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="095d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">自从我第一次使用framer-motion(2019年12月)以来，它一直在增长和发展，现在这个库让我们有机会轻松地将几乎任何动画带入生活。</p><p id="5940" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我觉得动画很容易把好的用户界面/UX体验弄糟，如果不是所有方面的话。但是<strong class="lp ir">成帧运动</strong>前来救援:</p><ul class=""><li id="e035" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated">维护HTML和SVG语义</li><li id="e2d8" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">声明性动画和关键帧动画</li><li id="a289" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">对可访问性的考虑(<code class="fe nh ni nj nk b">MotionConfig</code> + <code class="fe nh ni nj nk b">reducedMotion</code>)</li><li id="e983" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">束尺寸减小(<code class="fe nh ni nj nk b">LazyMotion</code> + <em class="mo"> m </em>)</li><li id="f229" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">布局转换(<code class="fe nh ni nj nk b">layout</code>和<code class="fe nh ni nj nk b">layoutId</code>)</li><li id="a2da" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">滚动触发(<code class="fe nh ni nj nk b">whileInView</code>)和滚动链接动画(<code class="fe nh ni nj nk b">useViewportScroll</code>)。</li></ul><p id="f00e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">从一个web开发者的角度来看，使用framer-motion是非常愉快和有趣的。对你来说可能是，也可能是一样的，你自己试试看，幸运的是，这很容易开始。</p><p id="d6e0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在这篇文章的最后，我想给你最后一个友好的提醒:动画是有趣和令人兴奋的，但它不是一个伟大的用户体验的关键元素，而且——如果不是有意和适度地使用——可能会使它变得更糟。您可以使用简单的CSS过渡或关键帧，但仍然可以获得出色的效果，而不会对最终产品造成太大影响。</p><p id="9d5a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><em class="mo">茱莉亚·史卡诺娃和玛丽·摩尔撰写</em></p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="9069" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">【https://shakuro.com】最初发表于<a class="ae mp" href="https://shakuro.com/blog/framer-motion-new-and-underestimated-features" rel="noopener ugc nofollow" target="_blank"><em class="mo"/></a><em class="mo">。</em></p></div></div>    
</body>
</html>