<html>
<head>
<title>Why Should We Stop Using Objects As Maps in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们应该停止在JavaScript中使用对象作为地图？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-should-we-stop-using-objects-as-maps-in-javascript-19c0275da72f?source=collection_archive---------5-----------------------#2019-12-09">https://betterprogramming.pub/why-should-we-stop-using-objects-as-maps-in-javascript-19c0275da72f?source=collection_archive---------5-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d8b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">是时候使用映射而不是常规对象来存储键值数据了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e22756ba9c9f4504cec48f5b3220e815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KFT56K5J9gE7t0LZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迪伦·穆林斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES6之前，为了制作字典或地图，我们经常使用对象来存储键和值。这有一些问题可以用地图来避免。</p><p id="84a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象让我们将字符串映射到值。然而，有了JavaScript对象的缺陷和<code class="fe lv lw lx ly b">Map</code>构造函数的存在，我们终于可以停止使用对象作为地图或字典了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="94fc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">继承和读取属性</h1><p id="5029" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通常，如果没有显式设置原型，JavaScript中的对象继承自<code class="fe lv lw lx ly b">Object</code>对象。这意味着我们有对象原型中的方法。</p><p id="ce0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查属性是在对象中还是在它的原型中，我们必须使用对象的<code class="fe lv lw lx ly b">hasOwnProperty</code>。这是一种痛苦，我们很容易忘记这一点。</p><p id="092e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可能会意外地获取和设置实际上不在我们定义的对象中的属性。例如，如果我们定义一个空对象:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6aae" class="nh mh it ly b gy ni nj l nk nl">let obj = {}</span></pre><p id="6d2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们写下:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0c2d" class="nh mh it ly b gy ni nj l nk nl">'toLocaleString' in obj;</span></pre><p id="5fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到返回的<code class="fe lv lw lx ly b">true</code>的值。这是因为<code class="fe lv lw lx ly b">in</code>操作符将对象原型中的属性指定为对象的一部分，这对于字典或地图来说并不是我们真正想要的。</p><p id="dece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个没有原型的纯对象，我们必须写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="72b3" class="nh mh it ly b gy ni nj l nk nl">let obj = Object.create(null);</span></pre><p id="e427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">create</code>方法将它创建的对象的原型对象作为参数，所以我们将得到一个不从任何原型继承的对象。像<code class="fe lv lw lx ly b">toString</code>或<code class="fe lv lw lx ly b">toLocaleString</code>这样的内置方法，它们是不可枚举的，所以它们不会包含在<code class="fe lv lw lx ly b">for...in</code>循环中。</p><p id="10ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们像下面的代码那样创建一个具有可枚举属性的对象:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3b0c" class="nh mh it ly b gy ni nj l nk nl">let obj = Object.create({<br/>  a: 1<br/>});</span><span id="456b" class="nh mh it ly b gy nm nj l nk nl">for (const prop in obj) {<br/>  console.log(prop);<br/>}</span></pre><p id="6ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们在上面的<code class="fe lv lw lx ly b">for...in</code>中记录了<code class="fe lv lw lx ly b">a</code>属性，它循环遍历一个对象的所有拥有和继承的属性。</p><p id="7c8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要忽略继承的属性，我们可以使用对象的<code class="fe lv lw lx ly b">hasOwnProperty</code>方法。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e46b" class="nh mh it ly b gy ni nj l nk nl">let obj = Object.create({<br/>  a: 1<br/>});</span><span id="0135" class="nh mh it ly b gy nm nj l nk nl">for (const prop in obj) {<br/>  if (obj.hasOwnProperty(prop)) {<br/>    console.log(prop);<br/>  }<br/>}</span></pre><p id="0e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们不会记录任何东西。</p><p id="6d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，用属性键访问值对于常规的JavaScript对象来说是很棘手的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bb3d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">覆盖属性值</h1><p id="9631" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用普通对象，我们可以很容易地覆盖和删除现有的属性。任何可写属性的值都可以被覆盖或删除。</p><p id="a17a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以给对象中的任何属性赋值。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e3b4" class="nh mh it ly b gy ni nj l nk nl">let obj = {};<br/>obj.toString = null;</span></pre><p id="fe29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们运行时:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="10d5" class="nh mh it ly b gy ni nj l nk nl">obj.toString();</span></pre><p id="254c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到错误<code class="fe lv lw lx ly b">Uncaught TypeError: obj.toString is not a function</code>。</p><p id="f05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个大问题，因为我们可以很容易地改变对象的任何原始或继承属性的值。正如我们所见，我们只用一次赋值操作就用<code class="fe lv lw lx ly b">null</code>覆盖了内置的<code class="fe lv lw lx ly b">toString</code>方法。</p><p id="d54d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着使用对象作为字典或地图是有风险的，因为我们很容易意外地这样做。除了检查可能是内置方法名称的值之外，没有其他方法可以防止这种情况。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b360" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">对象的原型</h1><p id="53ed" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对象的原型可以通过它的<code class="fe lv lw lx ly b">__proto__</code>属性来访问。这是一种我们既能获得又能设定的属性。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e033" class="nh mh it ly b gy ni nj l nk nl">let obj = Object.create({<br/>  a: 1<br/>});</span><span id="c66f" class="nh mh it ly b gy nm nj l nk nl">obj.__proto__ = {<br/>  b: 1<br/>};</span></pre><p id="d128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们对象的原型就是<code class="fe lv lw lx ly b">{ b: 1 }</code>。这意味着我们把原来是<code class="fe lv lw lx ly b">{ a: 1 }</code>的<code class="fe lv lw lx ly b">obj</code>原型改成了<code class="fe lv lw lx ly b">{ b: 1 }</code>，只需要设置<code class="fe lv lw lx ly b">obj</code>的<code class="fe lv lw lx ly b">__proto__</code>属性。</p><p id="c67f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们像下面这样用<code class="fe lv lw lx ly b">for...in</code>循环遍历<code class="fe lv lw lx ly b">obj</code>对象时:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b7c6" class="nh mh it ly b gy ni nj l nk nl">for (const prop in obj) {<br/>  console.log(prop);<br/>}</span></pre><p id="b40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们记录了<code class="fe lv lw lx ly b">b</code>。</p><p id="d85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着当我们试图访问我们用于字典或地图的对象时，我们必须避免访问<code class="fe lv lw lx ly b">__proto__</code>属性。我们所拥有的是另一个陷阱，当使用对象作为地图或字典时，它可能会使我们陷入困境。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="aa46" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">获取自己的可枚举属性以避免陷阱</h1><p id="7d60" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了避免获取从其他对象继承的属性的陷阱，我们可以使用<code class="fe lv lw lx ly b">Object.keys</code>来获取对象自己的属性名。它返回一个包含我们定义的对象的键的数组，并忽略任何继承的属性名。</p><p id="54ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="52df" class="nh mh it ly b gy ni nj l nk nl">let obj = Object.create({<br/>  a: 1<br/>});<br/>console.log(Object.keys(obj));</span></pre><p id="67ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们记录一个空数组。</p><p id="fb09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，<code class="fe lv lw lx ly b">Object.entries</code>接受一个对象作为参数，并返回一个数组，该数组的第一个元素是键，第二个元素是键的值。</p><p id="a98e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4c10" class="nh mh it ly b gy ni nj l nk nl">let obj = Object.create({<br/>  a: 1<br/>});<br/>console.log(Object.entries(obj));</span></pre><p id="71a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们还会记录一个空数组。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7408" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">ES6地图</h1><p id="e90c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">更好的是，我们应该使用ES6 <code class="fe lv lw lx ly b">Map</code>对象，它是地图或字典的实际实现。</p><p id="c843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Map</code>对象有<code class="fe lv lw lx ly b">set</code>方法，让我们添加键和值，它们分别是方法接受的第一个和第二个参数。</p><p id="11b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像在下面的代码中那样定义地图:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c633" class="nh mh it ly b gy ni nj l nk nl">let objMap = new Map();<br/>objMap.set('foo', 'bar');<br/>objMap.set('a', 1);<br/>objMap.set('b', 2);</span></pre><p id="dac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了使用<code class="fe lv lw lx ly b">set</code>方法添加键和值，我们还可以传递一个嵌套数组，其中数组的每个条目都将键作为第一个元素，将值作为第二个元素。</p><p id="fe73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象的一个好处是我们可以使用非字符串键。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6907" class="nh mh it ly b gy ni nj l nk nl">let objMap = new Map();<br/>objMap.set(1, 'a');</span></pre><p id="480d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用嵌套数组来定义一个<code class="fe lv lw lx ly b">Map</code>。例如，代替多次使用<code class="fe lv lw lx ly b">set</code>方法，我们可以编写以下代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b6d6" class="nh mh it ly b gy ni nj l nk nl">const arrayOfKeysAndValues = [<br/>  ['foo', 'bar'],<br/>  ['a', 1],<br/>  ['b', 2]<br/>]<br/>let objMap = new Map(arrayOfKeysAndValues);<br/>console.log(objMap)</span></pre><p id="efa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一些专门的方法可以通过键获取条目、获取所有条目、遍历每个条目以及删除条目。我们可以使用<code class="fe lv lw lx ly b">get</code>方法通过它的键获得一个条目:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8523" class="nh mh it ly b gy ni nj l nk nl">objMap.get('foo'); // 'bar'</span></pre><p id="f979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与对象不同，我们也可以从非字符串键中获取值。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7042" class="nh mh it ly b gy ni nj l nk nl">let objMap = new Map();<br/>objMap.set(true, 'a');</span></pre><p id="8427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe lv lw lx ly b">console.log(objMap.get(true));</code>会给我们<code class="fe lv lw lx ly b">'a'</code>。</p><p id="02f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe lv lw lx ly b">clear</code>方法清除<code class="fe lv lw lx ly b">Map</code>对象的所有条目。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="52c6" class="nh mh it ly b gy ni nj l nk nl">objMap.clear();</span></pre><p id="835d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe lv lw lx ly b">objMap.entries</code>方法得到所有的条目，我们也可以使用<code class="fe lv lw lx ly b">for...of</code>循环遍历条目，因为它有一个迭代器。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1b82" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="9a55" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们现在应该停止使用物体作为字典。有太多的陷阱，因为默认情况下对象继承自<code class="fe lv lw lx ly b">Object</code>对象，当我们设置它们时继承自其他对象。</p><p id="ffb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还让我们覆盖像<code class="fe lv lw lx ly b">toString</code>这样的方法的值，这不是我们大多数时候想要的结果。</p><p id="6624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这些问题，我们应该使用ES6中引入的<code class="fe lv lw lx ly b">Map</code>对象。它有特殊的方法来获取和设置条目，我们可以用<code class="fe lv lw lx ly b">for...of</code>循环遍历它们或将对象转换成数组。</p></div></div>    
</body>
</html>