<html>
<head>
<title>10 Decision Points for a Micro-Frontend Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端方法的10个决策点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-decision-points-for-micro-frontends-approach-4ebb4b59f40?source=collection_archive---------3-----------------------#2020-03-30">https://betterprogramming.pub/10-decision-points-for-micro-frontends-approach-4ebb4b59f40?source=collection_archive---------3-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你如何决定微前端是否适合你的项目，如果是，你如何进行？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/61a8a3046a02919221d40764ad4b67ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-knwOkTVzw7DeQ77OeqJQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@burst?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上的</a>爆裂<a class="ae ky" href="https://unsplash.com/s/photos/decision?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">未爆裂</a></p></figure><p id="3b8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个某些JavaScript框架以闪电般的速度变得不受欢迎的时代，前端开发人员一直忙于使用新的、新兴的方法重写应用程序。</p><p id="1a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不顾一切地寻找跳到最新最棒的东西上的可能性，而不用担心遗留代码的包袱。简单地说，我们希望组件解耦。这个吸引人的想法叫做<em class="lv">微前端</em>。</p><p id="2d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么是微前端方法？术语<em class="lv">微前端</em>最早出现在2016年11月的<a class="ae ky" href="https://www.thoughtworks.com/radar/techniques/micro-frontends" rel="noopener ugc nofollow" target="_blank"> ThoughtWorks技术雷达</a>中。它将微服务的概念扩展到前端开发。</p><p id="2881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法是通过分解整个应用程序，将基于浏览器的代码拆分成微前端。子应用程序可能由从后端到前端的垂直团队实现。这确保了每个子应用程序都是独立开发、测试和部署的。</p><p id="4914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在项目中采用了<a class="ae ky" href="https://camjackson.net/" rel="noopener ugc nofollow" target="_blank"> Cam Jackson </a>的<a class="ae ky" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">微前端方法</a>。基于我们的第一手经验，我们想分享微前端的十个决策点。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="26ee" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.你会根据受欢迎程度做决定吗？</h1><p id="3aec" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">微前端方法很受欢迎。如果在GitHub中搜索“微前端”，有788个相关的库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/01afbfa3260ba06c5b8c2a2b8fbe93c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9A4tpGOsZ-9pvU5-Qm3xA.png"/></div></div></figure><p id="a2d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在GitHub中搜索“微应用”，微前端的另一个术语，有167个相关的存储库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/c2324e253412303de3d66728f4efde4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKsLfAhwtlmnP7u5_ygwhw.png"/></div></div></figure><p id="68e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总共有大约1000个存储库，有各种各样的方法。人气就是需求。这也意味着在这个问题上还没有结论。这是一个难题，但却是一个非常值得期待的解决方案。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="deaf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">2.你的用例适合微前端吗？</h1><p id="cc2e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">微前端有五个主要用例:</p><h2 id="16b6" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">2.1.微前端方法以大规模软件为目标</h2><p id="7a59" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">它将一个整体问题分解成几个更容易处理的部分。</p><p id="2dc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，一个超市太大而无法发展。拥有一个应用程序容器是有意义的，并且每次当一个单独的存储(软件)准备好时添加一个存储。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/dc43a6d0e7d544a919c70a77325fcca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpYND6eh3Nr8XDuxV04d8A.png"/></div></div></figure><h2 id="bd50" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">2.2.微前端方法在遗留代码中非常流行</h2><p id="839e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">每天都有新的、酷的、强大的前端技术出现。处理过时但运行良好的现有代码是一件令人头痛的事情。用微前端包起来，运过去。那么不带包袱开始一项新技术是非常非常有诱惑力的。这个模式被Angular.js和Angular 2+反复采用。</p><h2 id="190c" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">2.3.微前端方法满足了组织独立性的需要</h2><p id="a4bb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">每个团队都有选择自己方式的自主权。在语言兼容性方面，本质上可以自由选择JavaScript或TypeScript。</p><p id="9992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个团队可以选择自己的存储库、第三方工具、公共库、CSS技术等等。该模型基于团队规模和风格。</p><h2 id="af78" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">2.4.可以选择对软件控制较少的微前端方法</h2><p id="55ab" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这个软件可能来自另一个组织，甚至是另一个公司。</p><p id="accf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管它可能是一个很小的组件，但不管出于什么原因，都不能以正常的方式来托管它。将这种类型的软件作为微前端插入应用程序容器是一种简单的方法。</p><h2 id="1702" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">2.5.微前端方法可能是个人偏好</h2><p id="127c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一个人可能仅仅因为热爱这项技术而选择这项技术。他们愿意尝试这项技术，并尽一切努力让它发挥作用。</p><p id="d50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于下面的情况，不管是否有许多已被证明的方法，比如React的组合模式，它仍然可以使用微前端方法来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/ff7d410385c05ec5572c7ac1a244f0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMutahZVFSewyx3YhamIWw.png"/></div></div></figure><p id="1d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的用例符合这些场景吗？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5a21" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">3.需要微前端的好处吗？</h1><p id="3324" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">微前端有什么好处？</p><ul class=""><li id="9545" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">每个微前端的代码库变得更小。这种组件方法使得每个微前端的代码更加连贯。从而达到解耦的软件开发目标。</li><li id="e4d3" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">每个微前端可以有自己的技术和框架选择。它可以独立实现、测试、升级、更新和部署。它为团队提供了灵活性。</li><li id="2616" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">微前端鼓励在整个应用程序的基础上构建垂直团队。垂直团队通常包括功能所有者、UX设计师、产品经理、后端开发人员、前端开发人员和质量保证工程师。</li></ul><p id="e595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些好处对你来说重要吗？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="33b8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">4.你能忍受从微前端继承的缺点吗？</h1><p id="4230" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">微前端有哪些弊端？</p><ul class=""><li id="1216" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">微前端设计用于去耦或松耦合元件。如果你试图在它们之间放置太多的依赖项，可能会导致调试的噩梦。</li><li id="a560" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">启用微前端的管道是复杂的。渲染外来的未知组件增加了复杂性。它需要技术专家来解决外部加载问题，并且调试过程可能很耗时。此外，您可能会面临单点登录(SSO)、全局CSS等问题。</li><li id="b186" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">每个微前端可能具有重复的代码或功能。例如，React库可以包含在每个微前端中。这增加了包的大小和内存消耗。</li><li id="2ad5" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">在运行时，动态或延迟加载微前端需要额外的时间。</li><li id="0028" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">由于用户界面是由多个团队设计的，UX设计可能在微前端之间不一致。</li></ul><p id="eff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能忍受这些缺点吗？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6e8c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">5.你会选择什么类型的微前端方法？</h1><p id="a314" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在可以合理地称为微前端的许多方法中，Cam Jackson列出了五种类型:</p><h2 id="6877" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">5.1.服务器端模板合成</h2><p id="38ab" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这种方法基于URL在服务器端呈现HTML。<a class="ae ky" href="https://github.com/Pyrolistical/microapps" rel="noopener ugc nofollow" target="_blank"> Microapps </a>展示了一个由六个微前端组成的demo:<code class="fe od oe of og b">Root</code>、<code class="fe od oe of og b">Angular 1</code>、<code class="fe od oe of og b">Hyperapp 0</code>、<code class="fe od oe of og b">React 15</code>、<code class="fe od oe of og b">Surplus 0</code>和<code class="fe od oe of og b">Vue 2</code>。</p><p id="1af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的方法来说明这个概念。以下设置是<a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>服务器配置的一部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="2de2" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">5.2.构建时集成</h2><p id="0179" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这种方法将每个微前端发布为一个包，然后让应用程序容器将它们构建为库依赖项。</p><p id="77a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是基于Cam Jackon的<a class="ae ky" href="https://github.com/micro-frontends-demo" rel="noopener ugc nofollow" target="_blank">微前端演示</a>的<code class="fe od oe of og b">package.json</code>示例:</p><pre class="kj kk kl km gt oj og ok ol aw om bi"><span id="71f8" class="nb me it og b gy on oo l op oq">{<br/>  "name": "@feed-me/container",<br/>  "version": "1.0.0",<br/>  "description": "A food delivery web app",<br/>  "dependencies": {<br/>    "@feed-me/browse-restaurants": "^1.2.3",<br/>    "@feed-me/order-food": "^4.5.6",<br/>    "@feed-me/user-profile": "^7.8.9"<br/>  }<br/>}</span></pre><h2 id="a4ab" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">5.3.通过iframes的运行时集成</h2><p id="e0cd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">代表一个嵌套的浏览上下文，嵌入在另一个HTML页面中。这是将应用程序与良好的样式和全局变量隔离结合在一起的最简单的方法。</p><p id="0a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从HTML5开始，<code class="fe od oe of og b">iframe</code>可以在一定程度上安全地被沙箱化。然而，<code class="fe od oe of og b">iframe</code>往往会搞乱路由、历史和深层链接。</p><p id="f5cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一项古老的技术，<code class="fe od oe of og b">iframe</code>简单而强大，但也容易被滥用。</p><h2 id="8cd6" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">5.4.通过JavaScript的运行时集成</h2><p id="95aa" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这是我们采用的方法，从Cam Jackson的算法改进而来的<a class="ae ky" href="https://medium.com/better-programming/you-dont-have-to-lose-optimization-for-micro-frontends-60a63d5f94fe" rel="noopener">。这是一种灵活的JavaScript方法。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="c045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于渐进式加载的块计数，使用多个<code class="fe od oe of og b">&lt;script&gt;</code>标签将每个微前端包含在页面上。一旦加载了最后一个块，就调用一个全局入口点来呈现微前端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/3c9539dfb426c782826cabd38978f701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tx87q4eXAdXbD6HE3DDezA.png"/></div></div></figure><h2 id="e141" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">5.5.通过Web组件进行运行时集成</h2><p id="a485" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Web组件是一套不同的技术，允许你创建可重用的定制元素。它由三种主要技术组成:定制元素、影子DOM和HTML模板。</p><p id="15ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是一种特殊类型的“通过JavaScript的运行时集成”。唯一的区别是您更喜欢使用Web组件的方式。Cam Jackson提供了一个Web组件微前端的例子:</p><pre class="kj kk kl km gt oj og ok ol aw om bi"><span id="3371" class="nb me it og b gy on oo l op oq">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Feed me!&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt;Welcome to Feed me!&lt;/h1&gt;<br/><br/>    <em class="lv">&lt;!-- These scripts don't render anything immediately --&gt;</em><br/>    <em class="lv">&lt;!-- Instead they each define a custom element type --&gt;</em><br/>    &lt;script src="https://browse.example.com/bundle.js"&gt;&lt;/script&gt;<br/>    &lt;script src="https://order.example.com/bundle.js"&gt;&lt;/script&gt;<br/>    &lt;script src="https://profile.example.com/bundle.js"&gt;&lt;/script&gt;<br/><br/>    &lt;div id="micro-frontend-root"&gt;&lt;/div&gt;<br/><br/>    &lt;script type="text/javascript"&gt;<br/>      <em class="lv">// These element types are defined by the above scripts</em><br/>      <strong class="og iu">const</strong> webComponentsByRoute = {<br/>        '/': 'micro-frontend-browse-restaurants',<br/>        '/order-food': 'micro-frontend-order-food',<br/>        '/user-profile': 'micro-frontend-user-profile',<br/>      };<br/>      <strong class="og iu">const</strong> webComponentType = webComponentsByRoute[window.location.pathname];<br/><br/>      <em class="lv">// Having determined the right web component custom element type,</em><br/>      <em class="lv">// we now create an instance of it and attach it to the document</em><br/>      <strong class="og iu">const</strong> root = document.getElementById('micro-frontend-root');<br/>      <strong class="og iu">const</strong> webComponent = document.createElement(webComponentType);<br/>      root.appendChild(webComponent);<br/>    &lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="26c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这些选择中，您会选择哪种类型的微前端方法？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7bfd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">6.你会选择现有的微前端方法吗？</h1><p id="77e7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你可以像我们一样采用Cam Jackson的微前端方法。你可以想出你自己的、本土的解决方案，或者你可以选择一些其他的方法。</p><p id="4157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是<a class="ae ky" href="https://github.com/ChristianUlbrich/awesome-microfrontends" rel="noopener ugc nofollow" target="_blank">牛逼微前端</a>中描述的方法:</p><ul class=""><li id="0a71" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><a class="ae ky" href="https://www.mosaic9.org/" rel="noopener ugc nofollow" target="_blank">Mosaic</a>——Project Mosaic是Zalando在微前端方面的成果，是一个完整的框架。</li><li id="0080" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank">单温泉</a> : Canopy的微前端方法是关于组成多个温泉。</li><li id="8717" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">这是一个开源的“包含电池”的微前端框架。</li><li id="b177" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://www.polymer-project.org/" rel="noopener ugc nofollow" target="_blank">聚合物项目</a>:这是谷歌对构建Web组件的尝试，这些组件仍然有一些不错的工具。</li><li id="d1f3" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://www.polymer-project.org/" rel="noopener ugc nofollow" target="_blank">坚果</a>:这是一个为微前端而生的框架，网易内部使用。目前支持Vue、React等。</li><li id="1bfd" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://podium-lib.io/" rel="noopener ugc nofollow" target="_blank">讲台</a>:这是一个微前端的服务器端构成。</li><li id="584d" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://piral.io/" rel="noopener ugc nofollow" target="_blank"> Piral </a>:这是一个使用React构建的微前端的下一代门户应用的开源框架。</li></ul><p id="da6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前还没有主流的微前端方法。您总是可以从现有的解决方案开始。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="62cf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">7.你会有几个微前端？</h1><p id="b0d0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">微前端为您如何执行前端开发带来了另一个维度。</p><p id="0a64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从光谱的一端，我们看到了将应用程序分解成两部分的用例:遗留代码和新开发的代码。另一个极端，我们也看到了做很多小微前端的方法，包括全局类型，时间服务，i18n服务等。</p><p id="2012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于哪种方式是正确的，没有严格的标准。它完全基于您的用例以及您团队的动态。设计微前端时，您可能需要考虑以下因素:</p><ul class=""><li id="cefb" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">是否要在同一个视图中组合多个微前端？</li><li id="fbbb" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">要不要把多条路由合并成一个微前端？</li><li id="2a0f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">你想在微前端之间共享数据和/或状态吗？</li><li id="3d3e" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">您希望在运行时保留微前端还是在构建时将它们捆绑到一个应用程序中？</li><li id="536c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">你的微前端服务可以跨域运行吗？</li><li id="5acf" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">您的微前端服务将部署到云中、内部部署，还是两者都部署？</li></ul><p id="1903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些事实将影响您如何设计微前端，以及如何选择微前端框架。</p><p id="e6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您正确地构建了模块，那么您拥有的微前端越多，最终得到的耦合就越少。然而，管理每个微前端也是一种开销。</p><p id="bc28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">微前端的数量需要仔细设计。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9298" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">8.你如何构建微前端仓库？</h1><p id="9b78" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于微前端项目，微前端可以保存在单独的存储库中，或者monorepo，这是一种源代码控制模式，其中所有的源代码都保存在单个存储库中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d004a64c4889538694f71a06cb7d67f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBZOQfXG9NoWZCNCZiDs3Q.png"/></div></div></figure><p id="8392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有另一种选择:两者结合。</p><p id="8f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经使用了所有类型的存储库。每一种都有利弊。</p><h2 id="3933" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">应用程序容器以及每个微前端都保存在自己的存储库中</h2><p id="37ef" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于这个微前端系列，我们使用了两个存储库— <a class="ae ky" href="https://github.com/JenniferFuBook/app-container" rel="noopener ugc nofollow" target="_blank">一个用于应用程序容器</a>，而<a class="ae ky" href="https://github.com/JenniferFuBook/micro-frontend" rel="noopener ugc nofollow" target="_blank">一个用于微前端</a>。不同的分支用于不同的目的。</p><p id="10f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个存储库是独立管理的，相互独立。然而，一些分支是相互连接的，需要小心管理，以便在运行时正确匹配。</p><p id="1e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，分块的微前端需要由我们改进版本的应用程序容器启动。对于我们所有的工作，<code class="fe od oe of og b"><a class="ae ky" href="https://github.com/kimmobrunfeldt/concurrently" rel="noopener ugc nofollow" target="_blank">concurrently</a></code>提供了很好的协助。</p><p id="e49a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它帮助我们在一个命令中启动多个可执行文件。此外，保存在Bash概要文件中的别名有助于跟踪哪个测试床对应哪个存储库。</p><h2 id="627f" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">应用程序容器和所有微前端都保存在一个monorepo中，比如<a class="ae ky" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank"> lerna </a></h2><p id="a953" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">集中的位置有助于识别一个存储库中的所有内容。一个包的变化不需要<code class="fe od oe of og b">npm link</code>就可以反映给其他人。许多流行的开源项目都采用了这种模式，比如Babel、React、Parcel等等。</p><p id="8700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，建立单一回购协议需要额外的努力。随着每个软件包的增长和软件包数量的增加，维护开销也会增加。搜索某样东西并不有趣，最终会有一个巨大的列表。</p><p id="0d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，我编辑了一个错误的<code class="fe od oe of og b">package.json</code>，因为存在多个<code class="fe od oe of og b">package.json</code>文件。有点讽刺的是，我们使用微前端使一个单一的任务变得可管理，但同时，我们创建了一个单一的报告。</p><p id="805c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，支持monorepo的工具可能有限。比如VS代码调试只在顶层起作用。我们必须转到每个包才能使用这个内置特性。</p><h2 id="206a" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">多个储存库和单一储存库的组合</h2><p id="55e6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们有多个项目采用monorepos。我们也有多个项目存在于单个存储库中。</p><p id="f35f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整个公司范围内聚合用户界面的性质使我们处于利用多个存储库和monorepos的情况。到目前为止一切顺利，我们能够成功地管理微前端与组合。</p><p id="b682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的选择是什么？如果您从头开始构建，那么您更喜欢哪个，多个存储库还是单个存储库？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0361" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">9.你想用多少框架？</h1><p id="4093" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">严格来说，React是一个库，而不是一个框架。为了简单起见，我们在这里不严格地使用术语<em class="lv">框架</em>。</p><p id="6732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据说微前端架构支持启动用各种框架构建的应用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/83a7da2167c31456c8563ae3a74264ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G5oTtClqASf-7ZSD.png"/></div></div></figure><p id="1ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种正确的说法，但应该尽量避免。将多个框架放在一起意味着更大的占用空间、更少的优化、更多的升级问题和更多的集成问题。</p><p id="f170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用微前端方法来组合多个应用程序(框架)始终是业务需求，以便在团队之间聚合遗留代码以及不同的产品。</p><p id="d299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你还能做些什么来加速交货？大多数组织不能花费大量的时间使用更新更好的技术来重写新的用户界面。</p><p id="5a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多时候，我们别无选择，只能接受部分或全部现有产品。我们已经看到了许多案例，例如在迁移到Angular 2+时保留Angular.js遗留代码，在迁移到React时保留<a class="ae ky" href="https://backbonejs.org/" rel="noopener ugc nofollow" target="_blank"> Backbone.js </a>遗留代码。</p><p id="3408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你从零开始，尽可能坚持一个选定的框架。框架中包含了许多架构上的考虑。</p><p id="c462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该是模型-视图-控制器(MVC)，模型-视图-展示者(MVP)，还是模型-视图-视图-模型(MVVM)？React只是MVC中的视图吗？Angular是MVC还是MVVM？</p><p id="7b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这仅仅是开始。还有更多关于依赖管理、DOM操作、测试、部署、实用程序等问题。</p><p id="ba36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常需要一个强大的团队、大型社区和多年的改进来构建一个坚实的框架。经验法则是首先探索所选框架的功能。</p><p id="c348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可以选择，你想用多少框架？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1a92" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">10.你能承担多少实验工作？</h1><p id="eca0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">所有框架无缝协作一直是前端开发人员的梦想。</p><p id="7830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有一个聚合的用户界面，用最少的工作量将所有的软件组合在一起，这一直是企业的愿景。</p><p id="204c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们选择了Cam Jackson的算法，因为其他解决方案不适用于我们现有的软件。我们必须用半自己动手的方式来做这件事。此外，他的工作在我们社区很受欢迎。到目前为止，效果还不错。</p><p id="739e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是，您正在考虑使用微前端方法，因为您已经到达这篇长文章的末尾。</p><p id="ace5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你从这里去哪里？</p><p id="117d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以选择一个现有的解决方案，并让它为您的用例工作，或者您可以更进一步，开拓一些新的解决方案。有了时间和专业知识，软件工程师可以做出惊人的事情。</p><p id="ab2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能承担多少实验工作？下一件大事可能就是从这个开始的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0962" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="2a6e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">软件行业一直在寻找一种简单而强大的用户界面开发解决方案。微前端方法是一个有前途的选择。探索愉快！</p><p id="d896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这项工作的一部分是由乔纳森马贡献。</p><p id="40e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f227" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">系列</h1><p id="c8ee" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这是一个关于微前端的系列。以下是其他文章的列表:</p><ul class=""><li id="b9df" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">"<a class="ae ky" href="https://medium.com/better-programming/5-steps-to-turn-a-random-react-application-into-a-micro-frontend-946718c147e7" rel="noopener">将随机React应用程序转变为微前端的5个步骤</a>"</li><li id="1927" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">"<a class="ae ky" href="https://medium.com/better-programming/3-steps-to-turn-a-random-react-application-into-a-micro-frontend-container-a80e33b6a066" rel="noopener">将随机React应用程序转变为微前端容器的3个步骤</a>"</li><li id="42bf" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">"<a class="ae ky" href="https://medium.com/better-programming/build-your-own-micro-frontend-ecosystem-a05128c74f99" rel="noopener">打造自己的微前端生态</a>"</li><li id="a2ed" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">"<a class="ae ky" href="https://medium.com/better-programming/you-dont-have-to-lose-optimization-for-micro-frontends-60a63d5f94fe" rel="noopener">你不必失去对微前端的优化</a>"</li><li id="9334" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">"<a class="ae ky" href="https://medium.com/better-programming/6-steps-to-create-a-multi-version-react-application-1c3e5b5df7e9" rel="noopener">创建多版本React应用程序的6个步骤</a>"</li><li id="de5f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">"<a class="ae ky" href="https://medium.com/better-programming/micro-frontends-using-webpack-5-module-federation-3b97ffb22a0d" rel="noopener">使用Webpack 5模块联盟的微前端</a>"</li></ul></div></div>    
</body>
</html>