<html>
<head>
<title>Navigating the World of Distributed C++ Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览分布式C++代码的世界</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/navigating-the-world-of-distributed-c-code-e439406f3e42?source=collection_archive---------9-----------------------#2019-09-04">https://betterprogramming.pub/navigating-the-world-of-distributed-c-code-e439406f3e42?source=collection_archive---------9-----------------------#2019-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2227" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">减少担心如何下载、编译和链接外部库的时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c0af19500aa66438aab4867c8da9cded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dNWZj2X1B22PZ6_75z77A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@shanerounce?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">沙恩·朗斯</a>在<a class="ae ky" href="https://unsplash.com/search/photos/distribute?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇<a class="ae ky" href="https://medium.com/better-programming/learn-how-to-compile-a-c-program-382c4c690bdc" rel="noopener">文章</a><strong class="lb iu"/>中，我讨论了在我们自己的C++程序中尝试使用第三方库所带来的一些困难。许多这些困难是由于缺乏对一些与C++开发相关的简单概念的理解。</p><p id="c1cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我首先查看了编译C++程序的每个阶段，并展示了如何使用MSVC工具集编译C++程序。</p><p id="1cc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想看看如何在分布式C++代码的世界中导航。</p><p id="4293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在互联网上发布代码的一种常见方式是使用库。一个库可以有多种形式:<em class="lv">仅头文件</em>、<em class="lv">静态</em>或<em class="lv">动态</em>，可以是预编译的，也可以不是。</p><p id="3839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">共享库的一种常见方法是使用<em class="lv"> tarball </em>或<em class="lv"> TAR文件</em>，这可能不是您可以识别的文件格式。正如你所看到的，有许多方法来分发C++代码，这种变化会使在你的游戏中使用库变得困难。</p><p id="465f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我希望解释上面描述的所有分发方法，这样你就可以把你的时间花在制作游戏上，而不用担心如何下载、编译和链接外部库。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2bae" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">在开始之前</h1><p id="5582" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了充分利用本文，我建议您至少在熟悉C++程序是如何编译的之前，不要开始阅读本文。</p><p id="f10a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目标读者是那些正在努力在自己的代码中使用第三方库的人，或者只是对C++在互联网上的构建和发布方式感兴趣的人。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="386a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是TAR文件？</h1><p id="edff" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">TAR文件或tarball是一种文件格式，它将文件集合存储在自身中，将这些文件视为单个文件，这样更易于共享，因为只需要下载一个文件。</p><p id="c7e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎有点令人困惑，因为我们看起来像是在压缩文件，但创建一个集合(存档)和压缩(减小大小)文件是有区别的。</p><p id="4ee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建TAR文件后，可以使用gzip之类的工具压缩这个文件，这样会产生一个<code class="fe na nb nc nd b">.tar.gz</code>文件。这是一个存档的文件集合，存储在一个使用gzip压缩的<code class="fe na nb nc nd b">.tar</code>文件中。</p><p id="9ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我提到gzip是因为你经常会看到库或源代码以<code class="fe na nb nc nd b">.tar.gz</code>文件的形式发布。</p><p id="db9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TAR文件只是共享文件的另一种方式，当压缩时，它类似于共享一个<code class="fe na nb nc nd b">.zip</code>文件，尽管选择一个而不是另一个是有原因的，我不会在这里深入讨论。</p><p id="a925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你只需要知道代码可以作为一个<code class="fe na nb nc nd b">.tar.gz</code>文件共享，这是一个压缩的文件集合。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1e0f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">C++库</h1><p id="5405" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">术语库描述了代码的集合。库的主要目的是在多个项目中重用常用代码。</p><p id="9903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可能有一个数学库，里面有帮助我们解决矩阵和向量问题的类和函数，这对任何游戏项目都很有用。<br/> <br/>有三种类型的库:仅头文件库、静态库和动态库，您可以在本文<a class="ae ky" href="https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/" rel="noopener ugc nofollow" target="_blank">的</a>中找到关于这些差异的更多细节。</p><p id="3ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在链接和编译库时所关心的是能够识别静态库和动态库之间的区别，这可以基于它们的扩展来完成。</p><p id="4af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">windows上的静态库有<code class="fe na nb nc nd b">.lib</code>扩展名，动态库有<code class="fe na nb nc nd b">.dll</code>。</p><p id="9258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当将一个库包含到我们的项目中时，我们需要为库文件本身和与该文件相关联的头文件提供一个路径。头文件向我们的程序公开了库的功能。</p><p id="ab93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，一个只有头文件的库，比如数学库<a class="ae ky" href="https://glm.g-truc.net/0.9.9/index.html" rel="noopener ugc nofollow" target="_blank"> GLM </a>，是一个不需要编译的库。相反，这个库是和我们自己的一起编译的，这通常会增加编译时间和代码膨胀，正如这篇维基百科文章所描述的。</p><p id="febf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个优点是它们更容易使用，因为我们只需要将我们的程序指向头文件的位置，而不是像通常情况那样必须构建和链接一个库。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="740c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">预编译与非预编译</h1><p id="d3c3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们的库有可能是我们正在使用的操作系统的预编译包。</p><p id="e052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预编译一个库意味着它只能在某个平台上工作，比如说Windows，我们只需要包含库文件的位置(。lib或者。dll)和关联的头文件。</p><p id="9f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如在上一篇文章中所讨论的，编译库是这样一种库，其中构建并链接该库的源代码，以生成包含特定平台的机器代码的文件。</p><p id="8741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预编译库的一个问题是，我们可能会被无法在我们想要开发的平台上运行的代码所困扰。</p><p id="ab46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，拥有源代码和自己编译代码的能力是有益的，但是在我们开始使用这个库之前，这增加了额外的工作。</p><p id="3856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译源代码的方法有很多种，但常见的是将代码与一个<em class="lv"> Makefile </em>捆绑在一起，这个Makefile 与一个名为<a class="ae ky" href="https://www.gnu.org/software/make/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Make </em> </a>的工具一起使用。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e787" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">了解Make和Makefiles</h1><p id="bdb3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">要理解Make背后的原因，我们需要理解Make和Makefiles解决的问题。</p><p id="b774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你回顾上一篇<a class="ae ky" href="https://medium.com/better-programming/learn-how-to-compile-a-c-program-382c4c690bdc" rel="noopener">文章</a>，在那里我们学习了如何使用MSVC工具集编译一个简单的C++程序，你可能已经注意到构建我们的程序既不困难也不耗时。</p><p id="548c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，随着程序大小和复杂性的增加，包含1000个文件，并链接到许多外部库，我们程序的复杂性和编译时间也会增加。</p><p id="1b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">减少程序编译时间的一个方法是不编译没有改变的代码。没有改变的代码不需要编译，因为我们已经有了以前构建的源文件的目标文件。</p><p id="3b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们的某个代码文件发生了变化，那么该文件以及依赖于它的任何文件都必须重新编译。如果我们有一个大的代码库，并且一个特定的文件，比如一个vector类，最终会在很多文件中使用，这肯定会变得复杂。</p><p id="f344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们不仅要为一个大的代码库编译一个程序，而且如果我们想让我们的程序尽可能快地编译，我们现在还必须跟踪我们已经改变的任何文件的所有依赖关系。</p><p id="de3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您可能已经猜到了，<a class="ae ky" href="https://www.gnu.org/software/make/" rel="noopener ugc nofollow" target="_blank"> Make </a>和Makefiles解决了所描述的问题。</p><p id="33df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Make是一个构建生成工具，它使用Makefile来编译和链接源代码，以生成可执行文件或库。Makefile是一个包含指令的文件，它告诉Make我们希望如何构建代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="83f5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">为什么使用Make</h1><p id="7264" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">正如您所看到的，Makefiles使开发人员能够以最少的工作量和更短的编译时间更容易地构建和重新编译他们的代码。正是由于这个原因，许多开发人员在分发他们的代码时都附带了Makefile。</p><p id="17fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们不需要理解代码是如何编译和链接的。相反，我们所要做的就是在指定的Makefile上调用Make命令，让Make完成剩下的工作。</p><p id="4d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们编译了代码，它仍然需要通过链接库和头文件来链接到我们的项目。</p><p id="6a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你坐在那里想知道为什么你不能在互联网上发布你的Visual Studio项目，让任何想用它的人加载项目并点击build…</p><p id="6e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，是因为不是所有人都用Visual Studio。人们喜欢使用不同的ide，在Windows之外，Visual Studio是不存在的。嗯，现在macOS上有，但是不支持C++。</p><p id="ab33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着软件新版本的发布，Visual Studio项目和基于其他ide的项目可能会过时。例如，您的Visual Studio 2013项目甚至可能无法在Visual Studio 2017中打开。</p><p id="5ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">C++代码本身可能会变得“过时”，因为随着新标准的发布，该语言会不断发展，但这不会阻止C++编译器理解您的代码，即使它必须编译用该语言的旧版本编写的代码。</p><p id="4d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，将C++程序作为源代码与Makefiles一起分发不仅使用户更容易构建代码，而且还使用户不再需要在特定的IDE(如Visual Studio)中运行代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a87b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">使用Make的示例</h1><p id="1002" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在上一篇<a class="ae ky" href="https://medium.com/better-programming/learn-how-to-compile-a-c-program-382c4c690bdc" rel="noopener">文章</a>的例子中，我们从命令行使用MSVC工具集来构建我们的程序。</p><p id="ae18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在知道这并不理想，因为如果我们想要避免重新编译我们代码库中的每个文件，不管它是否已经改变，它需要我们跟踪所有改变的文件。</p><p id="5a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，让我们看看如何使用NMAKE(相当于Windows的MAKE)和开发人员命令提示符来构建基于Makefile的程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/ff3b54482f928a2b0bcb1f124413ca1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O2ixF5CuNmyulmCh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nf">添加了Makefile的目录的当前状态</em></p></figure><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="2e58" class="nk me it nd b gy nl nm l nn no">main.obj: main.cpp HelloWorld.h<br/>    cl -c main.cpp</span><span id="951d" class="nk me it nd b gy np nm l nn no">helloworld.obj: HelloWorld.cpp HelloWorld.h<br/>    cl -c HelloWorld.cpp</span><span id="0ec9" class="nk me it nd b gy np nm l nn no">test.exe: main.obj HelloWorld.obj<br/>    link /out:test.exe main.obj HelloWorld.obj</span></pre><p id="d373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码显示了一个简单的Makefile。Makefile通过创建三个描述块来工作，每个描述块包括:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="8d77" class="nk me it nd b gy nl nm l nn no">target : dependents<br/>   Commands</span></pre><p id="2c8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅是一个文件或一组命令，在我们的例子中，就是文件。</p><p id="fe47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">Dependents</code>目标文件所依赖创建的文件。例如，一个目标文件依赖于一个<code class="fe na nb nc nd b">.cpp</code>和该文件包含的头文件。</p><p id="a880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe na nb nc nd b">commands</code>指的是我们希望对目标文件执行的命令，在我们的例子中，我们试图编译一个C++程序，所以我们希望编译生成目标文件，然后使用微软的C++编译器链接这些目标文件以生成可执行文件。</p><p id="1d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的Makefile示例中，顶部的描述块指定了依赖于<code class="fe na nb nc nd b">main.cpp</code>和<code class="fe na nb nc nd b">HelloWorld.h</code>的目标文件<code class="fe na nb nc nd b">main.obj</code>的创建，其中运行<code class="fe na nb nc nd b">cl -c</code>命令来编译目标文件，而无需链接。</p><p id="33e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个描述块指定了依赖于<code class="fe na nb nc nd b">HelloWorld.cpp</code>和<code class="fe na nb nc nd b">HelloWorld.h</code>的目标文件<code class="fe na nb nc nd b">helloworld.obj</code>的创建，其中运行<code class="fe na nb nc nd b">cl -c </code>命令来编译目标文件而无需链接。</p><p id="522c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，第三个描述块指定了目标文件，一个可执行文件<code class="fe na nb nc nd b">test.exe</code>，它依赖于<code class="fe na nb nc nd b">main.obj</code>和<code class="fe na nb nc nd b">helloworld.obj</code>，其中link <code class="fe na nb nc nd b">/out</code>命令用于链接目标文件以生成可执行文件，同时也允许我们用<code class="fe na nb nc nd b">/out</code>指定生成的可执行文件的名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/cf1f266037f669bdeb4aff2e78eb5159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pQFYz-r_CRdCKWIg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nf">运行NMAKE test.exe时开发者命令提示符的输出</em></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/f613c5127a3240e22c5792e1e6c2114d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CYC0Rvz_zgnGJQiN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nf">在开发人员命令提示符下运行test.exe的示例</em></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/16778a3052a2ac2c74851b555e3d4a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UEKsn4lhfwq8-VQJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行NMAKE命令后HelloWorld文件夹的状态</p></figure><p id="ce32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，除了调用NMAKE之外，在开发人员命令提示符中不执行任何命令。</p><p id="a7b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们通常使用的命令嵌入在Makefile中。</p><p id="509a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们指定了要创建的文件以及这些文件的依赖项，因此，如果我们试图在不更改代码的情况下再次运行NMAKE，NMAKE不会尝试重新编译我们的代码，因为没有必要。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0bd9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">关于CMake的一句话</h1><p id="8f09" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">本文中我想讨论的最后一件事是软件工具<a class="ae ky" href="https://cmake.org/" rel="noopener ugc nofollow" target="_blank"> CMake </a>，因为您可能在某个时候遇到过它，或者您可能已经遇到过它。</p><p id="8727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CMake代表跨平台Make，考虑到它的名字，你可能会认为它是某种扩展，但它比这要复杂一些。</p><p id="aa0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CMake和Make一样，可以在指令文件的帮助下从源代码构建可执行文件或库。对于CMake来说，这是一个<code class="fe na nb nc nd b">CMakeList</code>。</p><p id="c372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Make不同，CMake不仅仅是一个构建自动化工具。CMake可以生成用于在不同平台上进行本机构建的文件。它可以使用Make从Makefiles生成并构建可执行文件，或者为其他构建系统生成文件，如<a class="ae ky" href="https://ninja-build.org/manual.html" rel="noopener ugc nofollow" target="_blank"> Ninja </a>。</p><p id="afa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还可以在Windows和macOS上创建原生Visual Studio或Xcode项目。它可以以独立于编译器的方式构建程序。</p><p id="c707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实质上，CMake让您可以自由地编写代码，并在各种不同的平台上构建和运行代码。</p><p id="5030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习CMake和类似的工具通常是比学习Make这样的工具更好的选择，因为使用该工具可以获得额外的好处，例如能够生成可以在多种平台上构建的代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="295f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><p id="01de" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">总的来说，我们已经看到了在互联网上浏览分布式C++代码的世界。开发人员通常将代码作为一个库来共享，这个库可以是只有头文件的、静态的或动态的，通常作为一个称为TAR文件或tarball的压缩文件存档来共享。</p><p id="25a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">库可以针对我们工作的平台进行预编译，所以我们只需要告诉我们的程序库和相关头文件的位置，就可以让它们在我们的代码中工作。</p><p id="6f6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果库不是预编译的，我们可以用源代码和指令文件(如Makefile)来编译它们。</p><p id="7f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，源代码与CMake列表共享，CMake列表与名为CMake的工具一起工作，允许我们生成Makefiles之类的构建文件和Visual Studio之类的本地项目。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="62eb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">参考</h1><ul class=""><li id="c919" class="nr ns it lb b lc mv lf mw li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.howtogeek.com/362203/what-is-a-tar.gz-file-and-how-do-i-open-it/" rel="noopener ugc nofollow" target="_blank">https://www . how togeek . com/362203/what-is-a-tar . gz-file-and-how-do-I-open-it/</a></li><li id="de7d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.toptal.com/c-plus-plus/c-plus-plus-understanding-compilation" rel="noopener ugc nofollow" target="_blank">https://www . top tal . com/c-plus-plus/c-plus-plus-understanding-compilation</a></li><li id="a83d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives?view=vs-2019" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/CPP/preprocessor/preprocessor-directives？view=vs-2019 </a></li><li id="0951" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.cs.bu.edu/teaching/cpp/writing-makefiles/" rel="noopener ugc nofollow" target="_blank">https://www.cs.bu.edu/teaching/cpp/writing-makefiles/</a></li><li id="dfec" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.quora.com/What-is-the-difference-between-CMake-and-make" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/What-is-the-difference-CMake-and-make</a></li></ul></div></div>    
</body>
</html>