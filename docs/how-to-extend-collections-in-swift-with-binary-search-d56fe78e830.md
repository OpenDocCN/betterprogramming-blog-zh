# 如何使用二分搜索法扩展 Swift 中的托收

> 原文：<https://betterprogramming.pub/how-to-extend-collections-in-swift-with-binary-search-d56fe78e830>

## 让我们为基础类型添加新功能

![](img/9353f4b2673410b62d2aedf6eedc3a07.png)

安妮·斯普拉特在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

我们很多人在大学或学院都学过算法。我们中没有多少人真正实现过这些算法。

标准库(或 Swift 的`Foundation`)提供了实现这些算法的现成方法和函数。我们中很少有人实现过`quicksort`，但是我们每天都使用类似于调用`sort`的方法。

并不是我们研究的所有算法都可以在`Foundation`框架中得到。今天，我想和你们一起实现这些算法中的一个，我想向你们展示如何在一个单一的镜头中把它添加到每个集合中。在您的应用程序中随时使用它！

注意:了解这些算法以及它们是如何工作的对任何软件工程师来说都是有用的。即使我们不必实现它们，它们也可以提供关于如何解决类似问题的想法。

# 二进位检索

我们将要实现的基本算法是二分搜索法。

二分搜索法是这样工作的:给定一个排序的集合和一个要查找的元素(我们称之为`target`，选择中间的元素。如果中间的元素是`target`，返回它的索引。如果`target`小于中间的元素，则在数组的左半部分搜索。否则，在右半部分搜索。

这个算法有一个很强的要求:集合**必须排序**。这可能是它没有在`Foundation`库中实现的原因。然而，在现实生活中，我们会在几种情况下使用排序数据:在历史数据集中搜索特定日期时，在搜索提交时，以及在排序列表中搜索人员时。

实现二分搜索法算法有两种可能的方法:**递归**和**迭代**。我将从递归方法开始，因为它更优雅，更容易阅读。

首先，我们先从一个骨架和一个全局函数开始。后来，我们将其一般化，并将其移入正确的扩展中。代码如下:

这段代码代表了函数的公共接口(`API`)及其结构。public `API`接受一个数字数组，称为`nums`和`target`元素。如果存在，它返回被搜索元素的索引；否则，`nil`。在内部，我们使用正确的起始和结束索引调用递归函数来引导搜索过程。

小心索引。我们将使用它们来访问数组，这就是为什么我们要传递`count-1`值作为结束索引。

## 该算法

当编写递归算法时，首先要考虑的是基本情况:递归何时以及如何结束。在我们的例子中，递归继续，直到开始索引变得大于结束索引。当这种情况发生时，我们返回`nil`:目标不能在这个范围内，因为没有有效的范围。代码如下:

一旦我们定义了基本情况，我们就继续逻辑。这里有三个步骤:

1.  提取中间索引及其值。
2.  将中间值与目标值进行比较。
3.  决定我们是找到了目标还是必须继续搜寻。如果我们必须继续，决定下一步在哪里搜索。

再次强调，对索引要非常小心。当在数组的两半中的一个中搜索时，我们排除了中间值，因为我们已经检查了它。在左子数组中搜索时，我们传递`middleIndex-1`作为结束索引；在右子数组中搜索时，我们将`middleIndex+1` 作为起始索引。

## 概括搜索

我们现在有了一个有效的二分搜索法算法。但是，它只对整数有效。如果我们要二分搜索法一个替身名单呢？如果类型是日期或任何已排序的自定义类型会怎样？

当然，我们不想为所有可能的数据类型重新实现这个算法。我们可以利用泛型来编写一次，让它适用于所有类型。

在这些情况下，我们需要问自己，泛型类型必须满足哪些属性才能正确应用算法。如果我们观察所有需要的操作，我们比较值来确定中间的元素是被搜索的元素还是目标小于中间的元素。

Swift 提供了一个名为`Comparable`的协议，保证所有符合的类型都可以进行比较。我们可以加入这个协议一致性来实现我们的通用二分搜索法算法。代码如下:

上述算法与上一个相同。唯一的区别是数组和目标在`T`中是泛型，`T`符合`Comparable`协议。通过毫不费力的修改，我们获得了一个可以在每一个`Comparable`类型数组上运行的算法！

## 赋能系列

有几个小问题我们可以改进。首先，我们依赖于一个全局函数。

要使用这种算法，我们必须编写如下所示的代码:

虽然这没有什么错，但是这段代码看起来不够快。目标是获得类似于`array.binarySearch(target)`的语法。

为了实现这一点，我们可以扩展集合协议，允许通过索引访问集合。提供这种能力的协议是`[RandomAccessCollection](https://developer.apple.com/documentation/swift/randomaccesscollection)`协议。除了定义一个`Index`类型，它还定义了实现二分搜索法所需的下标方法。

改进的第二个方面是确保满足排序的前提条件。

我们可以通过实现一个简单的`private`属性`isSorted`来实现。该属性检查所有元素是否小于它们的下一个元素，代码如下所示:

这个版本的算法可以用语法`collection.recursiveBinarySearch(target:)`调用。`collection`是任何符合`RandomAccessCollection`协议并持有某种`Comparable`类型的东西。

第 15 行的`assert`用于确保集合被分类。该检查仅在应用程序使用*调试*配置构建时启用。这种检查确保了当我们测试应用程序时，集合是有序的(如果不满足前提条件，则崩溃它)，但是在*发布*配置中，它总是评估为`true`。

如果找到元素，该函数返回从`startIndex`开始的偏移量。当使用`RandomAccessCollection`时，我们必须对索引做一些手脚，而不是仅仅使用`Int`值。尽管这看起来很麻烦，但它实际上更加类型安全，并允许我们在索引不是`Int`的集合上运行二分搜索法。我们免费得到的另一个概括。

## 复杂性

在实现一个算法的时候，问自己它的时间和空间复杂度是多少是很重要的。这些是在给定一定大小的输入的情况下，运行算法需要多长时间的度量，以及除了输入之外，算法需要多少内存。这种分析被称为[大 O 分析。](https://en.wikipedia.org/wiki/Big_O_notation)

给定一个`n`元素的输入，我们在每次递归时将数组一分为二。这意味着在第二次迭代中，我们有一个输入`n/2`和第三次迭代中的`n/4`。在随后的递归中，输入减少到`n/8`、`n/16`，依此类推。

最终的结果是我们需要执行`log2(n)`操作。用大 O 记法，时间复杂度是`O(logN)`。对于一个算法来说，这是一个相当好的运行时间；它比任何线性搜索都要快。

从空间复杂度来看，我们需要使用一些变量来存储一些索引。第一个猜测可能是我们的空间是恒定的——或者`O(1)`。然而，我们不能忘记我们的算法是递归的。每次进入递归时，我们都会为函数的调用堆栈使用一些内存地址。假设我们使用了`logN`递归，二分搜索法占用了`O(logN)`内存。

# 迭代方法

幸运的是，递归方法不是我们可以使用的唯一方法。每个递归算法都可以用迭代的方式编写，反之亦然。

迭代方法有时更难阅读和编码，而递归通常非常优雅和易读。当时间和空间复杂度相当时，选择更简单、更易读的方法。在其他情况下，努力提高效率。

以下算法是二分搜索法的迭代计算:

代码和递归方法一样简单。以下是三个步骤:

*   我们检查数组是否不为空。
*   当起始索引小于或等于结束索引时，我们进行迭代。
*   我们基于我们想要在下一次迭代中探索数组的哪一半来更新开始和结束索引。

我决定向你们展示迭代方法的全球版本。用泛型(即`Comparable`协议)将其一般化，并将其移入`RandomAccessCollection`是一个很好的练习。

## 复杂性

该算法与递归算法获得相同的结果，但它是一种不同的算法。我们需要运行与递归方法相同的大 O 分析。

对于时间复杂性，什么都没有改变。我们在每次迭代中分析数组的一半。时间复杂度依旧`O(logN)`。

相反，空间的复杂性发生了变化。我们使用一些简单的变量作为索引，`while`循环不使用任何额外的内存。因此空间复杂度是恒定的，`O(1)`。

# 结论

今天我们探索了我最喜欢的算法之一:二分搜索法。我们使用递归实现了它，然后我们探索了如何将它一般化并引入 Swift 领域。

我们讨论了大 O 符号，这是每个软件工程师的一个重要话题，我们分析了二分搜索法的两个不同版本。

我希望你喜欢这篇文章。这种知识让我们从优秀的软件工程师成长为杰出的软件工程师。脸书、亚马逊、苹果、网飞和谷歌等公司在面试中询问复杂性和算法，这并不奇怪。