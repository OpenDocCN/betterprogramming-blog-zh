<html>
<head>
<title>Event-Based Routing for Angular Micro Frontends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于事件的角度微前端布线</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/event-based-routing-for-angular-micro-frontends-3bf2c9597ac1?source=collection_archive---------7-----------------------#2020-10-07">https://betterprogramming.pub/event-based-routing-for-angular-micro-frontends-3bf2c9597ac1?source=collection_archive---------7-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b5d7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在同一个窗口中运行的多个Angular应用程序之间进行路由</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/818d1c42e9d92977588637351bb4de1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_pU1ZX4bM--eOmP3"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@mooo3721?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> R莫</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="75f8" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">介绍</h1><p id="ffd9" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在我之前的一篇<a class="ae kv" href="https://itnext.io/how-to-run-separate-angular-apps-in-one-spa-shell-5250e0fc6155" rel="noopener ugc nofollow" target="_blank">文章</a>中，我描述了如何在一个<code class="fe mr ms mt mu b">window</code>上下文中运行两个Angular应用程序。我们这样做的原因可能是我们正在采用微前端架构。显然，微前端架构是一件大事，我们必须有信心能够面对所有的挑战。微前端的挑战之一是特定微应用程序之间的路由。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="0488" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">外壳应用程序中的路由</h1><p id="7f5c" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">老实说，在微前端架构中，我们需要处理两种类型的路由:</p><ul class=""><li id="6389" class="mv mw iq lx b ly mx mb my me mz mi na mm nb mq nc nd ne nf bi translated">特定微应用内部的内部路由</li><li id="6d59" class="mv mw iq lx b ly ng mb nh me ni mi nj mm nk mq nc nd ne nf bi translated">不同微应用之间外壳层的外部路由</li></ul><p id="0ea9" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">只要内部路由完全没有问题，因为它通常由我们选择作为微应用基础的框架开箱即用地处理，外部路由就可能是一个挑战。</p><h2 id="11f2" class="no le iq bd lf np nq dn lj nr ns dp ln me nt nu lp mi nv nw lr mm nx ny lt nz bi translated">为什么它实际上可能是一个挑战，以及我们想要实现什么</h2><p id="f9f6" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">最终用户不关心我们的架构，也不关心我们在架构下有什么技术解决方案。用户希望在使用应用程序时拥有完美的体验。用户习惯于SPA体验，如果他们在应用程序的不同部分(不同的微应用程序片段)之间移动，应该不会影响他们的统一感。</p><p id="5ad3" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">有一个结论:改变单个微应用程序之间的路由不应该重新加载页面，而是应该让每个微应用程序知道路由责任被委派给了它们。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="976a" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">现实生活中的例子</h1><p id="46eb" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在我之前的文章中，我提到我准备了一些基于@angular/elements结合React(包装为web组件)的微前端解决方案的例子，并在我自己的微前端解决方案中推出。您可以在这个库中查看这个例子:<a class="ae kv" href="https://github.com/marcinmilewicz/microfrontendly" rel="noopener ugc nofollow" target="_blank">https://github.com/marcinmilewicz/microfrontendly</a></p><p id="f4c8" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">当您运行上面的示例时，您将看到一个包含四条路线的简单页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/128b36adcfedec188bb7221e1889665a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*KIreJlm8zUaVf0rpE3fFWw.png"/></div></figure><p id="5a8d" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">事实上，我们在一个视图中观察到了上述两个角度应用程序:Foo MicroApp和Bar MicroApp。这些应用程序中的每一个都有两个延迟加载的模块:第一个和第二个，除了它是延迟加载的，没有编译时绑定。在单个Angular应用中，这种情况下的路由是微不足道的，但是如果我们同时在一个<code class="fe mr ms mt mu b">window</code>中有两个Angular应用会怎么样呢？</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="d9da" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">基于事件的方法</h1><p id="446e" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">显然，我意识到我可以为这些应用程序等编写一个相当复杂的定位策略，但我更愿意保持对解决方案的不可知论。因为如果我们添加第三个应用程序，比如Vue，会怎么样？当然解决方法会不一样，但是概念本身应该是一样的。事实上，我选择的并且已经在大型实际应用中得到证明的概念是基于事件的方法。</p><p id="2f6d" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">假设独立的和不可知的应用程序之间的路由变化是由一个事件触发的，我们可以知道此刻我们真正要显示的是什么，并且我们不需要用这个信息来保持状态(到处去无状态！).</p><p id="c9a9" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">坦率地说，我们可以根据自己的需要和最方便的方式来设计我们的事件。对于我的例子，方便的形式如下:</p><pre class="kg kh ki kj gt ob mu oc od aw oe bi"><span id="382e" class="no le iq mu b gy of og l oh oi">export type RouteChangedEvent&lt;RouteData = never&gt; = {<br/>  route: {<br/>    path: string;<br/>    app: string;<br/>    data?: RouteData;<br/>  };<br/>};</span></pre><p id="8863" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">这里的<code class="fe mr ms mt mu b">path</code>是我们的URL路径，<code class="fe mr ms mt mu b">app</code>是特定的微应用程序名称，数据可以是任何东西。</p><p id="1afb" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">shell应用程序或其他微应用程序(在我的例子中，我准备了<a class="ae kv" href="https://github.com/marcinmilewicz/microfrontendly/blob/master/microfrontend-example/header-app/src/Header.jsx" rel="noopener ugc nofollow" target="_blank"> React header </a>，它可以触发这个事件)可以将这种类型的事件作为<code class="fe mr ms mt mu b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent" rel="noopener ugc nofollow" target="_blank">CustomEvent</a></code>发送，这是一个众所周知的标准。</p><h2 id="30e7" class="no le iq bd lf np nq dn lj nr ns dp ln me nt nu lp mi nv nw lr mm nx ny lt nz bi translated">基于角度的微应用解决方案</h2><p id="e305" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">一旦我们决定我们的架构采用基于事件的形式，并且我们用Angular编写的微应用程序应该反映这些假设，我们就应该准备一些方便的方法来集成外部shell路由和Angular。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7567a62d3e55775ec5aa089170342478.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*dAEofPMxPEVokHHy.png"/></div></figure><p id="fdbf" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">我们可以编写一个能够收集适当事件的调度程序，检查事件是否针对这个特定的应用程序，并为内部角度路由器调度适当的操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="ba5f" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">为了使上述服务工作，它必须有适当的<code class="fe mr ms mt mu b">InjectionTokens</code>设置，并在应用程序开始时启动(实际上，在角度路由初始化时)。所以我们可以准备这个模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a007" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">然后我们可以在特定的角度应用中使用它。正如最佳实践所说，我们应该有<code class="fe mr ms mt mu b">app-routing.module.ts</code>来放置代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b381" class="pw-post-body-paragraph lv lw iq lx b ly mx jr ma mb my ju md me nl mg mh mi nm mk ml mm nn mo mp mq ij bi translated">瞧，一切都像预期的那样工作。此外，我已经将负责上述路由部分的一段代码分离为一个小库<a class="ae kv" href="https://www.npmjs.com/package/@microfrontendly/angular-element-routing" rel="noopener ugc nofollow" target="_blank">@ microfrontendly/angular-element-routing</a>。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ccb0" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">摘要</h1><ul class=""><li id="0349" class="mv mw iq lx b ly lz mb mc me om mi on mm oo mq nc nd ne nf bi translated">当我们开发微前端架构时，我们面临两种路由:外壳中的外部路由和特定应用程序中的内部路由。</li><li id="6e88" class="mv mw iq lx b ly ng mb nh me ni mi nj mm nk mq nc nd ne nf bi translated">一个有效的解决方案是基于事件的方法。</li><li id="2e1c" class="mv mw iq lx b ly ng mb nh me ni mi nj mm nk mq nc nd ne nf bi translated">我用两个独立的Angular应用程序准备了一个微前端架构的工作示例，一个React应用程序和一个不可知的shell。https://github.com/marcinmilewicz/microfrontendly<a class="ae kv" href="https://github.com/marcinmilewicz/microfrontendly" rel="noopener ugc nofollow" target="_blank"/></li><li id="bc59" class="mv mw iq lx b ly ng mb nh me ni mi nj mm nk mq nc nd ne nf bi translated">我准备了一个在基于Angular的微应用中处理外部路由的解决方案:<a class="ae kv" href="https://www.npmjs.com/package/@microfrontendly/angular-element-routing" rel="noopener ugc nofollow" target="_blank">https://www . npmjs . com/package/@ microfrontendly/Angular-element-routing</a></li></ul></div></div>    
</body>
</html>