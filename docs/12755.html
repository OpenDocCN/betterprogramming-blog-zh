<html>
<head>
<title>Create the Classic Space Invaders Game with JavaScript and HTML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript和HTML创建经典的太空入侵者游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-the-classic-space-invaders-game-af087786d63b?source=collection_archive---------3-----------------------#2022-06-29">https://betterprogramming.pub/create-the-classic-space-invaders-game-af087786d63b?source=collection_archive---------3-----------------------#2022-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b2c7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用HTML和JavaScript重现太空入侵者的教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/f3307515d516bb49d77c5593be36ad54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*vcPgmIFzmnUXAvZNALjONg.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">展示文章中创建的游戏的GIF。</p></figure><p id="d4a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你想在你的网站上添加一个简单的2D游戏吗？或者你想学习制作2D游戏的基础知识吗？这篇文章解释了如何只用HTML和JavaScript为大多数现代浏览器重新创建经典的太空入侵者游戏。</p><h1 id="6ace" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">游戏规格</h1><p id="183f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在开始开发之前指定一个游戏的基本特性是一个很好的主意，这样可以对需要完成的工作有一个大致的了解。</p><h2 id="5454" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">游戏的规格可以定义如下:</h2><ul class=""><li id="f210" class="mw mx iq kt b ku mf kx mg la my le mz li na lm nb nc nd ne bi translated">这个游戏需要一个可以移动的物体，可以被绘制到画布表面，并提供碰撞检查。</li><li id="ace9" class="mw mx iq kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated">敌人和玩家对象应该能够互相发射子弹。</li><li id="10b2" class="mw mx iq kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated">子弹对象应该只能向一个方向移动。</li><li id="5a84" class="mw mx iq kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated">玩家对象应该只能在画布边界内的x轴上左右移动。</li><li id="a58f" class="mw mx iq kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated">小行星应该由几个可摧毁的部分组成。</li><li id="d738" class="mw mx iq kt b ku nf kx ng la nh le ni li nj lm nb nc nd ne bi translated">如果所有的敌人都被消灭，或者如果其中一个敌人到达y轴上玩家的位置，游戏应该重新开始。</li></ul><h2 id="8144" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">游戏的对象</h2><p id="a84e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">图1中的类图显示了游戏的不同类及其关系的概述。例如，可以看到所有的可视对象都是由基类GameObject创建的，或者玩家类继承了飞船和GameObject类的属性和行为。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/52605c1de8f7520189f94700b879d129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*WQ4O34FOSJXAXI-O15Otnw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图1:显示了游戏的UML类图。</p></figure><h1 id="4c05" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">游戏区</h1><p id="e2b9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">第一步是设置带有canvas元素的HTML文档(参见图2)。HTML画布提供了绘制各种2D图形的能力。</p><p id="a7cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，可以在画布中绘制简单的形状或图像(Mozilla，2022b)。图2中第9行的canvas元素是用<code class="fe np nq nr ns b">id</code>、<code class="fe np nq nr ns b">width</code>和<code class="fe np nq nr ns b">height</code>属性定义的。</p><p id="6e8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe np nq nr ns b">id</code>属性用于引用JavaScript中的canvas元素，<code class="fe np nq nr ns b">width</code>和<code class="fe np nq nr ns b">height</code>属性只是指定画布的尺寸。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图2:显示了一个带有canvas元素的普通HTML文档。</p></figure><p id="dfd6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步是建立一个JavaScript对象，可以用来保存不同的属性和行为(Mozilla，2022d)。图3第12行显示了Javascript对象的实现，称为<code class="fe np nq nr ns b">game</code>。</p><p id="4dee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中使用JavaScript对象来保存属性和行为的想法是为了避免游戏的逻辑作为大量的全局变量和函数。</p><h2 id="e433" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">常规属性</h2><p id="3acb" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在图3的第15–19行，三个属性被添加到<code class="fe np nq nr ns b">game</code>对象中。<code class="fe np nq nr ns b">canvas</code>属性指的是HTML canvas元素，<code class="fe np nq nr ns b">ctx</code>指的是可用于在画布表面绘图的界面(Mozilla，2022e)，而<code class="fe np nq nr ns b">backgroundColor</code>指的是画布的背景颜色。</p><h2 id="25a5" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">一般行为</h2><p id="72a3" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">五个方法被添加到第22–43行的<code class="fe np nq nr ns b">game</code>对象中，如图3所示。<code class="fe np nq nr ns b">update()</code>定义了游戏的连续行为，比如画图元素，移动元素等。<code class="fe np nq nr ns b">update()</code>方法中的前两行(第24–25行，图3)将画布的背景设置为<code class="fe np nq nr ns b">backgroundColor</code>属性的值。</p><p id="09d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次调用<code class="fe np nq nr ns b">update()</code>时重绘背景确保移动的对象将在新位置绘制，而不是在新旧位置绘制。<code class="fe np nq nr ns b">keydown()</code>定义如果键盘上的某个键被按下会发生什么。<code class="fe np nq nr ns b">init()</code>定义开始游戏循环的游戏初始化。<code class="fe np nq nr ns b">stop()</code>定义如何停止游戏循环，<code class="fe np nq nr ns b">restart()</code>定义如何重启游戏。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图3:显示了用于处理游戏初始化和运行时行为的JavaScript对象的实现。</p></figure><h1 id="f214" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">游戏对象</h1><p id="8c5a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">添加了一个名为GameObject的类来定义游戏中使用的对象的一般行为。一般的游戏对象包含五个属性。<code class="fe np nq nr ns b">x</code>和<code class="fe np nq nr ns b">y</code>定义了游戏对象的位置。<code class="fe np nq nr ns b">width</code>和<code class="fe np nq nr ns b">height</code>定义游戏对象矩形的大小，<code class="fe np nq nr ns b">color</code>定义矩形的颜色。</p><p id="b55c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GameObject类也包含三个方法。<code class="fe np nq nr ns b">draw()</code>用于在画布内绘制游戏对象。<code class="fe np nq nr ns b">update(dx, dy)</code>向任意给定方向移动游戏对象，如果给定游戏对象与游戏对象重叠，<code class="fe np nq nr ns b">collidesWith(obj)</code>返回true。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图4:显示了一个通用游戏对象类的实现，它可以绘制一个矩形，更新其位置，并检测与其他游戏对象的冲突。</p></figure><h1 id="a481" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">子弹</h1><p id="a363" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">添加GameObject类后，可以添加一个简单的Bullet类，它继承了GameObject类的属性和行为。</p><p id="fcd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Bullet类包含一个名为<code class="fe np nq nr ns b">dy</code>的附加属性，用于定义项目符号在y轴上的移动方向。从GameObject类继承的<code class="fe np nq nr ns b">update(dx, dy)</code>方法在bullet类中被覆盖(参见第22–25行，图5 ),以定义它总是应该向给定的开始方向移动。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图5:显示了Bullet类的实现。</p></figure><h1 id="e192" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">宇宙飞船</h1><p id="b4d8" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">添加了一个名为SpaceShip的类来定义玩家和敌人对象的一般属性和行为。飞船类也是GameObject类的子类。</p><p id="afe8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">飞船类有五个额外的属性。<code class="fe np nq nr ns b">canvasHeight</code>用于指定宇宙飞船发射的子弹的界限。<code class="fe np nq nr ns b">bulletWidth</code>和<code class="fe np nq nr ns b">bulletHeight</code>定义了子弹的尺寸。<code class="fe np nq nr ns b">bulletColor</code>定义了子弹的颜色，<code class="fe np nq nr ns b">bullets</code>是一个数组，用来指定飞船产生的子弹。</p><p id="6676" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SpaceShip类被设计为覆盖从GameObject类继承的<code class="fe np nq nr ns b">draw(ctx)</code>方法，以实现移除屏幕外的项目符号的检查，并实现循环绘制和移动项目符号。</p><p id="fc6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SpaceShip类还包括一个叫做<code class="fe np nq nr ns b">shoot(dy)</code>的额外方法，用于生成在y轴上向给定方向移动的子弹。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图6:显示了SpaceShip类的实现。</p></figure><h1 id="a7af" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">运动员</h1><p id="a702" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">添加一个player类作为SpaceShip类的子类，以实现特定于Player对象的属性和行为。</p><p id="3851" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Player类有一个名为<code class="fe np nq nr ns b">canvasWidth</code>的附加属性，用于定义游戏画布的宽度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/277e5150391f02b536bbf313a77bacfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/1*2ciXhXCLM37Mszqcr7nb-g.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图7:绿线代表玩家可以移动的路径。</p></figure><p id="2894" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">属性用于检查玩家是否在x轴上的屏幕之外。通过重写从父类继承的<code class="fe np nq nr ns b">update(dy, dx)</code>方法，并添加一些额外的代码行，将x轴上的播放器位置移动到零或画布宽度减去播放器宽度，来实现检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图8:显示了Player类的实现。</p></figure><h1 id="4c8f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">小行星</h1><p id="1042" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">最后需要的类是小行星类。这个类不是game object类的子类，但是，该类与game object类紧密相连，因为它包含一个名为<code class="fe np nq nr ns b">parts</code>的属性，该属性是游戏对象的数组。</p><p id="e0fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种设计允许游戏中的一颗小行星被一部分一部分地摧毁(见图9)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/95652faa4aaf939a3a6e5f7be22b191b.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/1*exy48yA6rBdaXQdQa9uPbA.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图9:显示了一个玩家射击小行星的例子。</p></figure><p id="cdac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">小行星类也包含三种方法。<code class="fe np nq nr ns b">draw(ctx)</code>用于绘制小行星的游戏对象。如果小行星的一个游戏对象与给定的游戏对象冲突，则<code class="fe np nq nr ns b">collidesWith(obj)</code>返回true，如果小行星的一个游戏对象与给定的游戏对象冲突，则<code class="fe np nq nr ns b">removeOnCollide(obj)</code>移除小行星的一个游戏对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图10:显示了Asteroid类的实现。</p></figure><h1 id="5868" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">为小行星和敌人添加参数</h1><p id="7156" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">图11，第24–45行显示了小行星和敌人所需的额外游戏属性的实现。</p><h2 id="f631" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">其他小行星属性</h2><p id="db3c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated"><code class="fe np nq nr ns b">asteroidsParts</code>定义小行星组成的游戏对象数量，<code class="fe np nq nr ns b">noOfAsteroids</code>用于定义游戏应该包含的小行星数量，<code class="fe np nq nr ns b">asteroidsSpace</code>定义每个小行星之间的间距。</p><h2 id="7dfd" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">额外的敌人属性</h2><p id="e8f1" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">定义每条线上应该繁殖的敌人数量。<code class="fe np nq nr ns b">enemyLines</code>定义敌人的行数。<code class="fe np nq nr ns b">enemySpace</code>定义每个敌人之间的空间。<code class="fe np nq nr ns b">enemyFireRate</code>定义了敌人应该多长时间发射一次子弹，而<code class="fe np nq nr ns b">enemyFireTimer</code>是一个变量，用于记录自上次发射以来的时间。<code class="fe np nq nr ns b">enemyDirection</code>定义敌人应该向左还是向右移动(left = -1，right = 1)，而<code class="fe np nq nr ns b">enemyStep</code>定义敌人到达画布左侧或右侧时应该在y轴上移动多少。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图11:显示了小行星和敌人的附加游戏属性。</p></figure><h1 id="240a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">初始化对象</h1><p id="63cf" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在可以完成<code class="fe np nq nr ns b">game</code>对象的<code class="fe np nq nr ns b">init()</code>方法了(参见第27–62行，图12)。该方法应该包括一些额外的代码行，定义如何在开始位置创建玩家、敌人和小行星。</p><p id="92b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个设计允许使用<code class="fe np nq nr ns b">game</code>对象的<code class="fe np nq nr ns b">restart()</code>方法，将游戏重置到初始状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图12:显示了游戏初始化行为的实现。</p></figure><h1 id="965b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">检测键盘事件</h1><p id="9448" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">每当用户按下键盘上的一个键时，就会调用<code class="fe np nq nr ns b">game</code>对象的<code class="fe np nq nr ns b">keydown()</code>方法(参见第23–36行，图13)。通过读取参数<code class="fe np nq nr ns b">e</code>的属性<code class="fe np nq nr ns b">keyCode</code>，可以从参数<code class="fe np nq nr ns b">e</code>中读取特定按键的数字。</p><p id="ca44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">比如数字<code class="fe np nq nr ns b">37</code>定义左箭头键，数字<code class="fe np nq nr ns b">39</code>定义右箭头键。<code class="fe np nq nr ns b">keydown()</code>方法被设计用来检查用户是否按下了一个箭头键，或者A键和D键，从而使玩家向左或向右移动。它还包括一个额外的检查，以检测用户何时按下空格键，从而在玩家的位置产生一颗子弹。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图13:显示了游戏键盘检测行为的实现。</p></figure><h1 id="1cc3" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">更新游戏</h1><p id="a184" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">游戏中需要修改的最后一个方法是<code class="fe np nq nr ns b">game</code>对象的<code class="fe np nq nr ns b">update()</code>方法(见图14第23-154行)。</p><h2 id="1bbd" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">绘制玩家、小行星和敌人</h2><p id="bb82" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">图14的第29–38行，简单地调用不同对象的<code class="fe np nq nr ns b">draw(ctx)</code>方法来确保它们被绘制在画布中。图14中的第39行，在绘制敌人的同一个循环中，将敌人向<code class="fe np nq nr ns b">enemyDirection</code>属性中指定的方向移动。</p><h2 id="5e04" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">敌人数量检查</h2><p id="e6a0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">图14第43–46行检查<code class="fe np nq nr ns b">game</code>对象的<code class="fe np nq nr ns b">enemies</code>数组是否为空，如果检查结果为真，则重新开始游戏。这个检查可能包括一些额外的代码，减少玩家的<code class="fe np nq nr ns b">life</code>属性，直到它达到零，然后重新开始游戏。</p><h2 id="bdf8" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">敌人运动</h2><p id="bbae" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">第49–91行，图14，检查<code class="fe np nq nr ns b">enemyDirection</code>属性是1还是-1。如果该属性为1，则该方法找到最靠近屏幕右侧的敌人，如果该敌人到达右侧，则该方法将<code class="fe np nq nr ns b">enemyDirection</code>设置为-1，并将所有敌人下移<code class="fe np nq nr ns b">enemyStep</code>的值。如果<code class="fe np nq nr ns b">enemyDirection</code>的值为-1，则会发生相反的情况。</p><h2 id="f401" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">敌人随机射击</h2><p id="168d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">图14第94-99行增加了<code class="fe np nq nr ns b">enemyTimer</code>属性，直到随机选择一个敌人向玩家开枪。</p><h2 id="9a04" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">子弹碰撞检查</h2><p id="22f9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">图14中的第102–154行显示了四个行为几乎相同的循环。例如，第一个循环，第101–110行，图14，遍历所有玩家的子弹并检查它们是否与astroids的游戏对象之一发生碰撞。第三个循环，第125-134行，图14，遍历所有玩家的子弹并检查是否有一颗子弹与一个敌人相撞。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图14:显示了游戏连续行为的实现。</p></figure><p id="62aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的代码可以在<a class="ae nx" href="https://gist.github.com/niiicolai/325c1f4f113569a3857f2ece01f5ba65" rel="noopener ugc nofollow" target="_blank">这个链接中找到。</a></p><h1 id="280f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">文献学</h1><p id="012b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Mozilla。2022a。画布API。<br/><a class="ae nx" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API</a>。访问日期:2022年6月28日</p><p id="e685" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Mozilla。2022b。使用图像。<br/><a class="ae nx" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Using_images" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Canvas _ API/Tutorial/Using _ images</a>。访问日期:2022年6月28日</p><p id="32b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Mozilla。2022c。用画布画形状。<br/><a class="ae nx" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Canvas _ API/Tutorial/Drawing _ shapes</a>。访问日期:2022年6月28日</p><p id="a453" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Mozilla。2022d。使用对象。<br/>T13】https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Working _ with _ Objects。访问日期:2022年6月28日</p><p id="da99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Mozilla。2022e。CanvasRenderingContext2D。<br/>T17】https://developer . Mozilla . org/en-US/docs/Web/API/canvasrenderingcontext 2d。访问日期:2022年6月28日</p></div></div>    
</body>
</html>