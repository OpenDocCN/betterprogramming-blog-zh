<html>
<head>
<title>How to Use Alignments in SwiftUI — The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中使用对齐—基础知识</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introducing-alignments-in-swiftui-10d4f4ba252?source=collection_archive---------5-----------------------#2022-01-22">https://betterprogramming.pub/introducing-alignments-in-swiftui-10d4f4ba252?source=collection_archive---------5-----------------------#2022-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7b36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设置基本和自定义对齐</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e9ffd2ceba4184dc1a4d5cc19ebf8a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2jdq6v3BgD3UXbuClqiZQ.png"/></div></div></figure><p id="ee6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是<em class="lq">‘swift ui布局系统’</em>系列的第三部分，在这个系列中，我们将学习你需要知道的关于对齐的一切。像Stacks一样，理解alignments如何工作将为您的工具箱提供另一个强大的工具，用于在SwiftUI中构建优秀的布局。</p><h1 id="1921" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">SwiftUI布局系统</h1><ul class=""><li id="6523" class="mj mk it kw b kx ml la mm ld mn lh mo ll mp lp mq mr ms mt bi translated"><a class="ae mu" href="https://medium.com/@crystalminds/introducing-the-swiftui-layout-system-part-i-the-basics-42083aaaa5c7" rel="noopener">如何使用SwiftUI布局系统</a></li><li id="b673" class="mj mk it kw b kx mv la mw ld mx lh my ll mz lp mq mr ms mt bi translated"><a class="ae mu" href="https://crystalminds.medium.com/introducing-stacks-in-swiftui-b616681c502a" rel="noopener">如何在SwiftUI中使用堆栈</a></li><li id="c88a" class="mj mk it kw b kx mv la mw ld mx lh my ll mz lp mq mr ms mt bi translated"><em class="lq">如何在SwiftUI中使用对齐<br/></em>–<em class="lq">基础知识</em><br/>–<a class="ae mu" href="https://crystalminds.medium.com/introduction-to-alignments-the-alignment-process-1fc087a3f263" rel="noopener">对齐过程</a><br/>–<a class="ae mu" href="https://medium.com/@crystalminds/how-to-use-alignments-in-swiftui-part-iii-custom-alignments-80da9305a4bd" rel="noopener">自定义对齐</a><br/>–<a class="ae mu" href="https://crystalminds.medium.com/how-to-use-alignments-in-swiftui-part-iv-container-expansion-using-alignments-3e9a88d1275e" rel="noopener">容器扩展使用对齐</a><br/>–<a class="ae mu" href="https://crystalminds.medium.com/how-to-use-alignments-in-swiftui-part-v-z-stack-alignment-478b4209d02d" rel="noopener">Z堆栈对齐</a></li></ul><p id="fc60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">(更多来……)</em></p><h1 id="46e4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">基础知识</h1><p id="ab63" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们将使用Stacks教程中的吉祥物海豚Flippy来演示对齐的基础知识。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/d5066caa5708238d98b95570a49bc3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iO63UOBBAKxexv57ywvLhA.png"/></div></div></figure><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3838" class="nj ls it nf b gy nk nl l nm nn">HStack {<br/>    Text("Flippy")<br/>    Image("54x60_dolphin")<br/>    Text("the Dolphin")<br/>}</span></pre><p id="7a5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在早期的故事中，我们走过了布局系统的步骤。视图的对齐将发生在该过程的第三步，在<em class="lq">“父元素将子元素放置在父元素的坐标空间”</em>中。</p><p id="f612" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">中心对齐是堆栈的默认设置，所以如果我们显式设置它，它不会改变任何视觉效果，因为它已经在父视图的中心对齐了视图。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="e0e6" class="nj ls it nf b gy nk nl l nm nn">HStack(<strong class="nf iu">alignment: .center</strong>) {<br/>    Text(“Flippy”)<br/>    Image(“54x60_dolphin”)<br/>    Text(“the Dolphin”)<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/8093e4db01a695a150f95c3749740b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwlqSL6YnNqsG1RpmWbcVg.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">在HStack上居中对齐。</p></figure><p id="47c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您将值从<code class="fe ns nt nu nf b">.center</code>更改为<code class="fe ns nt nu nf b">.bottom</code>，那么所有视图都将整齐地与父视图的底部对齐，这一点您不会感到惊讶。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="bb65" class="nj ls it nf b gy nk nl l nm nn">HStack(alignment: <strong class="nf iu">.bottom</strong>) {<br/>    Text(“Flippy”)<br/>    Image(“54x60_dolphin”)<br/>    Text(“the Dolphin”)<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/68b027baf59ebebd0687f00c92254a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkOFkCl3hhEMr_RTqNaPEw.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">HStack上的底部对齐。</p></figure><p id="948c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这很简单，看起来很体面。当我们把文本<code class="fe ns nt nu nf b">Flippy</code>的字体大小从<code class="fe ns nt nu nf b">.body</code>改成<code class="fe ns nt nu nf b">.caption</code>的时候，事情就不一样了。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="9b92" class="nj ls it nf b gy nk nl l nm nn">HStack(alignment: .bottom) {<br/>    Text(“Flippy”)<strong class="nf iu">.font(.caption)</strong><br/>    Image(“54x60_dolphin”)<br/>    Text(“the Dolphin”)<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/f0da6bca742d64f59eb3656e2ece63ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4aeVoHh3iA5CENpGrX-JQ.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">各种基线。</p></figure><p id="b04c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你在上面的图片中看到的。所有的视图都是底部对齐的，但是视觉对齐都是乱的。</p><p id="c5c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你得到了较小文本的基线<code class="fe ns nt nu nf b">Flippy</code>，你得到了图像的底线，你得到了文本的基线<code class="fe ns nt nu nf b">The Dolphin</code>，但它们都没有对齐。</p><p id="7ba0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，SwiftUI覆盖了我们，我们可以简单地使用<code class="fe ns nt nu nf b">.lastTextBaseline</code>对齐来解决这个问题。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3eca" class="nj ls it nf b gy nk nl l nm nn">HStack(alignment: <strong class="nf iu">.lastTextBaseline</strong>) {<br/>    Text(“Flippy”).font(.caption)<br/>    Image(“54x60_dolphin”)<br/>    Text(“the Dolphin”)<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/3325a9b2f88e8f7bee03bcfaaa5625cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9b7aSrUszr71lD5PkwhcQ.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">HStack上的最后一个文本基线对齐</p></figure><p id="7358" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是图像呢？请注意，图像中没有文本，但每个对齐都有默认值，最后一个文本基线的默认值就在视图的底部边缘。</p><p id="902f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你可以说，在图像上有一个视觉基线，从顶部起50% (0.5)，就在他的鼻子周围。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/399f3b973ea7d395bb7f37ca2fc91274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jt0024saUKN4bWT0eqvfkw.png"/></div></div></figure><p id="d5d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过告诉SwiftUI如何使用对齐指南根据图像的其他对齐方式计算图像的最后一个文本基线来处理这个问题。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="e129" class="nj ls it nf b gy nk nl l nm nn">HStack(alignment: .lastTextBaseline) {<br/>    Text(“Flippy”).font(.caption)<br/>    Image(“54x60_dolphin”)<br/><strong class="nf iu">        .alignmentGuide(.lastTextBaseline) { d in<br/>            d[.bottom] * 0.5<br/>        }</strong><br/>    Text(“the Dolphin”)<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/3180de011f1e6d3a518fff2f6af7bf19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjuXpvuJ44ATiXL6i8E4gQ.png"/></div></div></figure><p id="a0bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的，所有的视图现在整齐排列。</p><h1 id="e374" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">自定义对齐</h1><p id="3ffb" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">让我们回到来自“<a class="ae mu" href="https://crystalminds.medium.com/introducing-stacks-in-swiftui-b616681c502a" rel="noopener">如何在SwiftUI </a>中使用堆栈”的组合堆栈示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/9b669fcc5fa2e506d24ce6e114ce0a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNooQXQiaf-YZC7s9NljQg.png"/></div></div></figure><p id="8f23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，视图现在是垂直居中的，但是如果我们想要将心脏(在一个<code class="fe ns nt nu nf b">VStack</code>中的视图)与标题<em class="lq">“海豚鳍”</em>(在另一个<code class="fe ns nt nu nf b">VStack</code>中的视图)对齐呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/51946b8bec3084cb486a5fc816db7622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vx9CUFAGl8iM2G_BfroDcg.png"/></div></div></figure><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d35a" class="nj ls it nf b gy nk nl l nm nn">HStack {<br/>    VStack {<br/>        Text("❤❤❤❤❤")<br/>        Text("5 hearts")<br/>    }    <br/>    VStack {<br/>        HStack {<br/>            Text("Flippy the Dolphin")<br/>            Spacer()<br/>            Image("26x30_dolphin")<br/>        }        <br/>        Text("A highly intelligent and playful sea creature")<br/>    }<br/>}</span></pre><p id="f30a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要一条线来标记心脏的中心。因此，要做到这一点，我们需要定义我们自己的(自定义)对齐。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="cd98" class="nj ls it nf b gy nk nl l nm nn"><strong class="nf iu">extension</strong> VerticalAlignment {<br/>    <strong class="nf iu">private</strong> <strong class="nf iu">enum</strong> MidHeartsAndTitle : AlignmentID {<br/>        <strong class="nf iu">static</strong> <strong class="nf iu">func</strong> defaultValue(in d: ViewDimensions) -&gt; CGFloat {<br/>            <strong class="nf iu">return</strong> d[.bottom]<br/>        }<br/>    }</span><span id="64d3" class="nj ls it nf b gy nw nl l nm nn"><strong class="nf iu">    static</strong> <strong class="nf iu">let</strong> midHeartsAndTitle =  <br/>        VerticalAlignment(MidHeartsAndTitle.<strong class="nf iu">self</strong>)<br/>}</span></pre><p id="0b00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用一个符合<code class="fe ns nt nu nf b">AlignmentID</code>的枚举来扩展<code class="fe ns nt nu nf b">VerticalAlignment</code>。它有一个要求，告诉SwiftUI如何计算默认值。我们简单地选择尺寸的<code class="fe ns nt nu nf b">.bottom</code>作为缺省值，没有特别的原因。您可以将其设置为您喜欢的任何默认值。</p><p id="2f39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们定义了一个静态实例<code class="fe ns nt nu nf b">VerticalAlignment</code>，它将枚举类型作为它的参数。</p><p id="576c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以使用它来对齐堆栈，明确地将它设置为红心和标题的中心。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6e2d" class="nj ls it nf b gy nk nl l nm nn">HStack(<strong class="nf iu">alignment: .midHeartsAndTitle</strong>) {<br/>    VStack {<br/>        Text("❤❤❤❤❤")<br/><strong class="nf iu">            .alignmentGuide(.midHeartsAndTitle) { <br/>                d in d[.bottom] / 2 <br/>            }<br/>        </strong>Text("5 hearts")<br/>    }    <br/>    VStack {<br/>        HStack {<br/>            Text("Flippy the Dolphin")<br/><strong class="nf iu">                .alignmentGuide(.midHeartsAndTitle) { <br/>                    d in d[.bottom] / 2 <br/>                }<br/>            </strong>Spacer()<br/>            Image("26x30_dolphin")<br/>        }        <br/>        Text("A highly intelligent and playful sea creature")<br/>    }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/90099327ade7011884a3bc405220be9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rh1dBfoBJyG1KSTtkZxrFw.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">在指定自定义对齐之前。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/536718fddb9404cc69b67aa29f62c2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukAkT7-NID0s5khldl_oEw.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">指定自定义对齐后。</p></figure><p id="f43e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一部分<a class="ae mu" href="https://crystalminds.medium.com/introduction-to-alignments-the-alignment-process-1fc087a3f263" rel="noopener">中，我们将详细讨论SwiftUI调整视图的步骤。</a></p></div></div>    
</body>
</html>