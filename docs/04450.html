<html>
<head>
<title>How to Secure Kubernetes the Hard Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何艰难地保护库伯内特</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-secure-kubernetes-the-hard-way-9b421b36aba4?source=collection_archive---------6-----------------------#2020-04-14">https://betterprogramming.pub/how-to-secure-kubernetes-the-hard-way-9b421b36aba4?source=collection_archive---------6-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ff7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改编自Kelsey Hightower的“Kubernetes the Hard Way ”,使用Terraform在运行Docker的CentOS上创建强化集群</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9ee65637e9f43197ab30c320f1afd80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yP7eqmpv4z-v6codS3skSg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">埃里克·麦克林在<a class="ae ky" href="https://unsplash.com/s/photos/knot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="fb81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes是开源的、健壮的，是市场上最流行的容器编排平台之一。然而，由于它的复杂性，并不是每个人都能适当地保护它。</p><p id="4e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验丰富的系统管理员也很难处理它的多个移动部件和众多设置(他们内置这些以提供灵活性)。</p><p id="4029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这可能是你最终陷入灾难的原因。由于Kubernetes的流行，许多供应商都提供托管的Kubernetes服务，这些服务都有一定程度的安全性，您不必太担心Kubernetes的架构，但是如果您没有这种选择呢？</p><p id="02b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用自动化工具在任何环境下创建集群，例如<a class="ae ky" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" rel="noopener ugc nofollow" target="_blank"> kubeadm </a>，然而，大多数使用kubeadm的管理员很难理解Kubernetes是如何在幕后工作的，因为kubeadm会为你设置集群。</p><p id="0402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要知道，最好的方法是艰难地引导您的Kubernetes集群。这个故事改编自凯尔西·海托华的《苦日子》然而，与最初的指南不同，这份指南更关注构建一个更安全、生产就绪的Kubernetes集群。</p><p id="3243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个故事是一个高级主题，假设您已经有了一些管理Kubernetes集群的经验。阅读“<a class="ae ky" href="https://medium.com/@bharatmicrosystems/how-to-secure-kubernetes-the-easy-way-f37052139280?source=friends_link&amp;sk=869004b4fd8383333efa0eb8186206da" rel="noopener">如何以简单的方式保护Kubernetes</a>”以获得更多自动化设置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="946f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">集群架构</h1><p id="5e2e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最初的指南仅用于教育目的，因此没有考虑集群的弹性和安全性。它具有以下配置:</p><ul class=""><li id="9b50" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">三个控制平面(主)节点。</li><li id="47f5" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">三个工作节点。</li><li id="8a3e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">一个谷歌云网络负载平衡器。</li><li id="330e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">NGINX实例为API服务器提供健康检查。</li><li id="e921" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">运行堆叠的<a class="ae ky" href="https://etcd.io/" rel="noopener ugc nofollow" target="_blank"> etcd </a>集群(这意味着etcd服务在控制平面节点内运行)。</li><li id="d2d1" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">通过外部IP将所有节点暴露给互联网。</li><li id="57b6" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">没有防火墙规则来限制流量。</li><li id="5c6d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">没有内置的灾难恢复，因为所有节点都在同一个区域中运行。</li></ul><p id="d7c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们在构建时考虑到了安全性和灵活性，因此我将对其进行修改，以包括以下群集体系结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/382273c737cb74860a02ce71d5dd14f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oh4UlSyxD11zX7qtJT2PvA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">集群架构</p></figure><ul class=""><li id="c099" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">我们将运行一个区域性的Kubernetes集群。这意味着我们的集群将能够应对区域中断，但不能应对区域性中断。</li><li id="76af" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">三个主节点(<code class="fe no np nq nr b">master01</code>、<code class="fe no np nq nr b">master02</code>和<code class="fe no np nq nr b">master03</code>)运行在三个不同的区域中。</li><li id="55ff" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">三个etcd节点(<code class="fe no np nq nr b">etcd01</code>、<code class="fe no np nq nr b">etcd02</code>和<code class="fe no np nq nr b">etcd03</code>)运行在三个不同的区域。</li><li id="d122" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">两个工作节点(<code class="fe no np nq nr b">node01</code>和<code class="fe no np nq nr b">node02</code>)在两个不同的区域中运行。</li><li id="19fd" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">两个NGINX负载平衡器(<code class="fe no np nq nr b">masterlb</code>和<code class="fe no np nq nr b">masterlb-dr</code>)以活动-备用配置运行在两个不同的区域。我将利用一个外部静态IP和一个带别名的内部静态IP，以确保在任何给定时间，所有节点都与绑定到活动负载平衡器节点的静态IP通信。</li><li id="8cf7" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">一个堡垒主机运行在一个区域中(我们可以在区域中断的情况下创建另一个堡垒主机)。</li><li id="e76f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">除了堡垒主机和负载平衡器之外，所有的服务器都是内部的。他们没有附加外部IP。</li><li id="02ee" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">由于节点需要有出站互联网连接，我利用了一个云NAT网关来处理来自内部服务器的出口流量。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b282" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">防火墙规则</h1><p id="9aa0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Kubernetes集群运行一个平面网络，因此所有节点都位于同一个子网中。但是，我将应用一个限制性策略，只允许所需的流量通过所需的端口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">防火墙规则</p></figure><p id="dc51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将确保如果有人未经授权访问我们的任何服务器，损害将仅限于该服务器，他们将无法访问其他节点。</p><p id="4cd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了bastion主机之外，任何节点之间都没有打开的SSH访问。防火墙保护堡垒主机，只允许可信客户端通过IP白名单进行访问。</p><p id="60d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切就绪！让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f391" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Terraform加快基础设施建设</h1><p id="e8f9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>(而不是最初指南使用的<a class="ae ky" href="https://cloud.google.com/sdk/gcloud" rel="noopener ugc nofollow" target="_blank"> gcloud commands </a>)来旋转基础设施，因为它是声明性的，更现代。从我们开始的地方清理和恢复会更容易。</p><h2 id="b7ea" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">设置IAM和管理员</h2><p id="7d9a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您现在需要配置Google云环境，以允许Terraform远程管理基础设施。</p><p id="875f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要首先创建一个服务帐户，并向该服务帐户提供足够的权限，以便它可以管理所需的基础结构。</p><p id="b9f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经为服务帐户分配了“项目编辑”角色，但是您可以根据组织策略的需要考虑更严格的访问权限。</p><p id="900d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<em class="og"> IAM和管理</em> - &gt; <em class="og">服务账户</em>。</p><p id="f83b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<em class="og"> Terraform </em>的服务帐户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/1b8636f6771ea19d33e814bdc0d3f10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s5aiXn6NKVkNPxT9.png"/></div></div></figure><p id="4ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向服务帐户授予项目编辑器角色，以便它可以旋转资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/4b4694e9e552457745d3fe909ae9fc7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k9w300lv-V_2oLPQ.png"/></div></div></figure><p id="f20c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">授予服务帐户“服务帐户用户”访问权限，并为Terraform生成一个JSON密钥，以作为服务帐户使用Google Cloud APIs进行身份验证。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/55a01b66003a1e81660ec19713ac08d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6gLZzJabzxaRix2T.png"/></div></div></figure><h2 id="8642" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">安装Terraform</h2><p id="1eb0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Terraform CLI是一个二进制文件，易于设置和使用。转到Terraform的<a class="ae ky" href="https://www.terraform.io/downloads.html" rel="noopener ugc nofollow" target="_blank">网站</a>并根据您的环境下载合适的软件包。</p><p id="c693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解压缩软件包，然后设置指向Terraform二进制文件的路径，或者将Terraform二进制文件移动到您的bin目录。</p><h2 id="5fc7" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">加快基础设施建设</h2><p id="40bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对Terraform运行以下命令来加速基础架构。这将为您创建带有防火墙规则和静态IP地址的整个基础架构。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="b96f" class="nu md it nr b gy oo op l oq or">git clone <a class="ae ky" href="https://github.com/bharatmicrosystems/kthw-terraform.git" rel="noopener ugc nofollow" target="_blank">https://github.com/bharatmicrosystems/kthw-terraform.git</a><br/>cd kthw-terraform/<br/>cp terraform.tfvars.example terraform.tfvars</span></pre><p id="49e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修改<code class="fe no np nq nr b">terraform.tfvars</code>文件，用<code class="fe no np nq nr b">project</code>、<code class="fe no np nq nr b">region</code>和<code class="fe no np nq nr b">source_ranges</code>的相关值替换变量。来源范围应该包含您的机器的IP地址，以便您可以从您的系统连接到您的堡垒主机。</p><p id="6bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将你下载的JSON key复制到<code class="fe no np nq nr b">kthw-terraform/</code>中，重命名为<code class="fe no np nq nr b">credentials.json</code>。</p><p id="abbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初始化、规划和应用Google云平台的配置。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="7d85" class="nu md it nr b gy oo op l oq or">terraform init<br/>terraform plan<br/>terraform apply</span></pre><p id="de3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<em class="og"> Google Compute Engine </em>部分，您会看到Terraform已经创建了一个bastion、三个masters、三个etcd节点、两个负载平衡器和两个worker节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/cb1c2436a7119ae6f4504531fad41e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ipXv35zKSxpN-q6z-9HZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GCE实例</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e8eb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">艰难地建立Kubernetes</h1><p id="bb40" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">原始指南使用etcd的API服务器证书，因为它使用堆叠的etcd配置。我将为etcd生成单独的证书和密钥，因为我们正在运行外部etcd设置。</p><p id="0599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把etcd集群放在一个负载平衡器的后面，这给我们带来了多重优势。</p><ul class=""><li id="b56d" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">etcd节点可以具有短暂的IP。</li><li id="981c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">您可以根据需要添加和删除etcd节点。</li><li id="a057" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">NGINX提供了对其后端成员的自动健康检查，它不会向不健康的etcd实例发送流量，从而避免运行时问题。</li><li id="f6eb" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">如果您对etcd集群进行了更改(如添加或删除etcd节点)，则不需要更新控制面板配置。</li></ul><p id="fbb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将只允许所需的流量，并阻止其余的流量。这是保护我们的集群免受未经授权的访问所必需的。我们将按照原始指南中的建议对etcd集群上的静态机密进行加密。</p><p id="1f1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Docker而不是<a class="ae ky" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank"> containerd </a>作为容器运行时。我们将在CentOS 7而不是Ubuntu 16.04.6 LTS上创建我们的环境。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="86a9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">登录到堡垒主机</h1><p id="f297" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过运行<code class="fe no np nq nr b">gcloud compute ssh</code>命令从本地系统SSH到bastion主机。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="7798" class="nu md it nr b gy oo op l oq or">gcloud compute ssh bastion --zone europe-west2-a</span></pre><p id="9f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该打开一个与bastion主机的SSH会话。在bastion主机中，克隆<code class="fe no np nq nr b">kthw-terraform</code>存储库。</p><p id="9e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该存储库包含已经为您编写并在Google云平台上测试过的脚本。为了获得更好的理解，请随意打开并研究这些脚本。我将只阐述脚本的内容，如果它不同于原始指南。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="5358" class="nu md it nr b gy oo op l oq or">git clone <a class="ae ky" href="https://github.com/bharatmicrosystems/kthw-terraform.git" rel="noopener ugc nofollow" target="_blank">https://github.com/bharatmicrosystems/kthw-terraform.git</a><br/>cd kthw-terraform/<br/>cp -a scripts/ exec/<br/>cd exec/<br/>masters=master01,master02,master03<br/>workers=node01,node02<br/>loadbalancers=masterlb,masterlb-dr<br/>etcds=etcd01,etcd02,etcd03<br/>internal_vip=masterlb-internal-vip<br/>external_vip=masterlb-external-vip</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fa69" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置CA</h1><p id="1531" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种设置与原始指南非常相似。运行以下命令:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="0daf" class="nu md it nr b gy oo op l oq or">sh -x setup-ca.sh</span></pre><p id="b45a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="c654" class="nu md it nr b gy oo op l oq or">ca-key.pem<br/>ca.pem</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cd58" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">生成客户端和服务器证书</h1><p id="5950" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该设置与原始指南相同，唯一的区别是我们将生成一个单独的etcd集群证书和密钥对，并且我们将为API服务器指向一个静态内部IP，而不是外部IP。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="1f9a" class="nu md it nr b gy oo op l oq or">sh -x setup-certs.sh $masters $workers $internal_vip $etcds</span></pre><p id="ebcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="8931" class="nu md it nr b gy oo op l oq or">admin-key.pem<br/>admin.pem<br/>node01-key.pem<br/>node01.pem<br/>node02-key.pem<br/>node02.pem<br/>kube-controller-manager-key.pem<br/>kube-controller-manager.pem<br/>kube-proxy-key.pem<br/>kube-proxy.pem<br/>kube-scheduler-key.pem<br/>kube-scheduler.pem<br/>kubernetes-key.pem<br/>kubernetes.pem<br/>etcd-key.pem<br/>etcd.pem<br/>service-account-key.pem<br/>service-account.pem</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="acb7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为身份验证生成Kubernetes配置文件</h1><p id="ff0c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在将生成kubeconfigs，以便Kubernetes组件可以与API服务器进行连接、认证和授权。</p><p id="8ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与最初的指南不同，在这种配置中，所有组件都通过负载平衡器与API服务器通信。这种配置的优势类似于将etcd集群置于负载均衡器之后的优势。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="23c0" class="nu md it nr b gy oo op l oq or">sh -x generate-kubeconfig.sh $workers $internal_vip</span></pre><p id="9d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="aebb" class="nu md it nr b gy oo op l oq or">node01.kubeconfig<br/>node02.kubeconfig<br/>kube-proxy.kubeconfig<br/>kube-controller-manager.kubeconfig<br/>kube-scheduler.kubeconfig<br/>admin.kubeconfig</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c5f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">引导负载平衡器</h1><p id="aa93" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于我们使用NGINX作为负载平衡器，而不是Google Cloud network负载平衡器，我们将配置NGINX向API服务器和etcd节点发送流量。</p><p id="ad4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NGINX配置如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用脚本运行来引导NGINX集群:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="324e" class="nu md it nr b gy oo op l oq or">sh -x setup-nginx.sh $loadbalancers $masters $etcds $internal_vip $external_vip</span></pre><p id="f0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将VIP作为第一个负载平衡器的别名，并运行一个保持活动的守护进程，以确保VIP作为备用负载平衡器的别名，以防主负载平衡器出现故障。</p><p id="4c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">keep-alive实用程序(在本例中称为“【T2”)将作为守护进程运行，并将VIP自动映射到活动实例。</p><p id="9ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">备用实例将继续轮询VIP是否可用，如果VIP由于某种原因被释放(例如在主负载平衡器崩溃的情况下)，备用实例将接管它并将VIP分配给它自己。</p><p id="f01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下。</p><p id="537e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NGINX应该同时在<code class="fe no np nq nr b">masterlb</code>和<code class="fe no np nq nr b">masterlb-dr</code>节点上运行。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="f63a" class="nu md it nr b gy oo op l oq or">+ sudo systemctl status nginx<br/>● nginx.service - nginx - high performance web server<br/>   Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled)<br/>   Active: active (running) since Sun 2020-04-12 23:14:32 UTC; 77ms ago<br/>     Docs: <a class="ae ky" href="http://nginx.org/en/docs/" rel="noopener ugc nofollow" target="_blank">http://nginx.org/en/docs/</a><br/>  Process: 1763 ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf (code=exited, status=0/SUCCESS)<br/> Main PID: 1764 (nginx)<br/>   CGroup: /system.slice/nginx.service<br/>           ├─1764 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf<br/>           └─1765 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c30e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分发证书和Kubeconfigs</h1><p id="6c97" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">然后，我们需要将证书、密钥和kubeconfigs分发到服务器。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="0036" class="nu md it nr b gy oo op l oq or">sh -x distribute-certs.sh $masters $workers $etcds<br/>sh -x distribute-kubeconfig.sh $masters $workers</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8add" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">生成数据加密配置和密钥</h1><p id="1c33" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">像最初的指南一样，我们将生成一个数据加密配置和密钥。这将允许Kubernetes在etcd上以加密文本的形式存储秘密。</p><p id="d063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是非常重要的，这样如果有人访问你的etcd集群，他们就不能通过十六进制转储你的秘密来查看你的秘密。</p><p id="9a8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下命令将生成并复制生成的<code class="fe no np nq nr b">encryption-config.yaml</code>到所有主节点。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="e37c" class="nu md it nr b gy oo op l oq or">sh -x generate-data-enc.config.sh $masters</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="81e4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">引导etcd集群</h1><p id="fe8c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">etcd集群用于存储Kubernetes集群的状态，因此是一个重要的组件。</p><p id="7d2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有人获得了对您的etcd集群的访问权限，就相当于给了他们对您的集群的root访问权限。因此，我们保持etcd集群完全独立，并阻止除端口2379上运行的etcd API之外的所有流量，只有主节点可以通过etcd负载平衡器访问该端口。</p><p id="a797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">etcd集群将通告静态负载平衡器IP，而不是通告本地客户端IP，因为API服务器将通过负载平衡器连接到etcd。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="8365" class="nu md it nr b gy oo op l oq or">sh -x setup-etcd.sh $etcds $internal_vip</span></pre><p id="1e49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过在任何etcd节点中运行以下命令来检查etcd集群的健康状况。但是，上面的命令会自动为您运行。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="159a" class="nu md it nr b gy oo op l oq or">sudo ETCDCTL_API=3 /usr/local/bin/etcdctl member list \<br/>  --endpoints=<a class="ae ky" href="https://127.0.0.1:2379" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:2379</a> \<br/>  --cacert=/etc/etcd/ca.pem \<br/>  --cert=/etc/etcd/etcd.pem \<br/>  --key=/etc/etcd/etcd-key.pem</span></pre><p id="29a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="e209" class="nu md it nr b gy oo op l oq or">17a5143233735134, started, etcd02, <a class="ae ky" href="https://etcd02:2380" rel="noopener ugc nofollow" target="_blank">https://etcd02:2380</a>, <a class="ae ky" href="https://10.154.15.236:2379" rel="noopener ugc nofollow" target="_blank">https://10.154.15.236:2379</a>, false<br/>92ad41089af8c0f8, started, etcd01, <a class="ae ky" href="https://etcd01:2380" rel="noopener ugc nofollow" target="_blank">https://etcd01:2380</a>, <a class="ae ky" href="https://10.154.15.236:2379" rel="noopener ugc nofollow" target="_blank">https://10.154.15.236:2379</a>, false<br/>cfc65b5eb6a19652, started, etcd03, <a class="ae ky" href="https://etcd03:2380" rel="noopener ugc nofollow" target="_blank">https://etcd03:2380</a>, <a class="ae ky" href="https://10.154.15.236:2379" rel="noopener ugc nofollow" target="_blank">https://10.154.15.236:2379</a>, false</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3dca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">引导Kubernetes控制平面</h1><p id="a53b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Kubernetes控制平面负责管理您的Kubernetes集群。我们将在控制平面节点中安装<a class="ae ky" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" rel="noopener ugc nofollow" target="_blank"> Kube API服务器</a>、<a class="ae ky" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" rel="noopener ugc nofollow" target="_blank"> Kube控制器管理器</a>和<a class="ae ky" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/" rel="noopener ugc nofollow" target="_blank"> Kube调度器</a>。</p><p id="7d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置控制平面的过程与原始指南非常相似。</p><p id="7248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，与原始指南不同，Kube API服务器会公布负载平衡器的浮动VIP，而不是其内部IP，并使用etcd证书而不是API服务器证书来验证etcd服务器。</p><p id="8146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API服务器还将使用etcd集群的单个负载平衡端点，而不是用逗号分隔的etcd URLs列表。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="6b6d" class="nu md it nr b gy oo op l oq or">/usr/local/bin/kube-apiserver \\<br/>  <strong class="nr iu">--advertise-address=${LOAD_BALANCER_VIP} \\</strong><br/>  --allow-privileged=true \\<br/>  --apiserver-count=3 \\<br/>  --audit-log-maxage=30 \\<br/>  --audit-log-maxbackup=3 \\<br/>  --audit-log-maxsize=100 \\<br/>  --audit-log-path=/var/log/audit.log \\<br/>  --authorization-mode=Node,RBAC \\<br/>  --bind-address=0.0.0.0 \\<br/>  --client-ca-file=/var/lib/kubernetes/ca.pem \\<br/>  --enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \\<br/>  --etcd-cafile=/var/lib/kubernetes/ca.pem \\<br/><strong class="nr iu">  --etcd-certfile=/var/lib/kubernetes/etcd.pem \\<br/>  --etcd-keyfile=/var/lib/kubernetes/etcd-key.pem \\</strong><br/>  <strong class="nr iu">--etcd-servers=</strong><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/${LOAD_BALANCER}:2379"><strong class="nr iu">https://${LOAD_BALANCER_VIP}:2379</strong></a><strong class="nr iu"> \\</strong><br/>  --event-ttl=1h \\<br/>  --encryption-provider-config=/var/lib/kubernetes/encryption-config.yaml \\<br/>  --kubelet-certificate-authority=/var/lib/kubernetes/ca.pem \\<br/>  --kubelet-client-certificate=/var/lib/kubernetes/kubernetes.pem \\<br/>  --kubelet-client-key=/var/lib/kubernetes/kubernetes-key.pem \\<br/>  --kubelet-https=true \\<br/>  --runtime-config=api/all \\<br/>  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\<br/>  --service-cluster-ip-range=10.32.0.0/24 \\<br/>  --service-node-port-range=30000-32767 \\<br/>  --tls-cert-file=/var/lib/kubernetes/kubernetes.pem \\<br/>  --tls-private-key-file=/var/lib/kubernetes/kubernetes-key.pem \\<br/>  --v=2</span></pre><p id="83d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要引导您的控制面板，请运行:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="52b0" class="nu md it nr b gy oo op l oq or">sh -x setup-master.sh $masters $internal_vip</span></pre><p id="b732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查控制平面的状态，请在控制平面的所有节点上运行以下命令。上面的命令会自动为您运行它，因此如果您正在观察您的输出，您可以知道它何时运行。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="b16c" class="nu md it nr b gy oo op l oq or">kubectl get componentstatuses --kubeconfig admin.kubeconfig</span></pre><p id="ed7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="354d" class="nu md it nr b gy oo op l oq or">NAME                 STATUS    MESSAGE             ERROR<br/>controller-manager   Healthy   ok<br/>scheduler            Healthy   ok<br/>etcd-0               Healthy   {"health":"true"}</span></pre><p id="a48e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看到这里，etcd节点的数量只是一个而不是三个。</p><p id="b9ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是etcd集群位于负载均衡器之后，Kubernetes不知道有多个etcd节点。这很好，因为我们已经将负载平衡功能卸载到我们的负载平衡器，而不是API服务器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b66b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在控制平面和Kubelet之间设置RBAC</h1><p id="2534" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">控制平面需要与<a class="ae ky" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank"> kubelet API </a>通信来管理集群。Kubelet是Kubernetes和容器运行时之间的接口。</p><p id="6aa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了像最初的指南一样允许控制平面和kubelet之间的安全通信，我将<code class="fe no np nq nr b">-authorization-mode</code>标志设置为<code class="fe no np nq nr b">Webhook</code>。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="76fc" class="nu md it nr b gy oo op l oq or">sh -x setup-rbac.sh $masters</span></pre><p id="9df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="9e69" class="nu md it nr b gy oo op l oq or">clusterrole.rbac.authorization.k8s.io/system:kube-apiserver-to-kubelet created<br/>clusterrolebinding.rbac.authorization.k8s.io/system:kube-apiserver created</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d9d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">引导工作节点</h1><p id="e83c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">工作者节点是Kubernetes集群的发电站。容器工作负载在工作节点上运行，因此，集群中可能有许多工作节点。</p><p id="b913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个故事中，我将只引导两个工作节点。但是，您可以拥有任意数量的工作节点。与最初的指南不同，我们将在worker节点中安装Docker，而不是Containerd，下面的kubelet配置反映了这一点。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="6ad9" class="nu md it nr b gy oo op l oq or">/usr/local/bin/kubelet \\<br/>  --config=/var/lib/kubelet/kubelet-config.yaml \\<br/><strong class="nr iu">  --docker=unix:///var/run/docker.sock \\<br/>  --docker-endpoint=unix:///var/run/docker.sock \\</strong><br/>  --image-pull-progress-deadline=2m \\<br/>  --kubeconfig=/var/lib/kubelet/kubeconfig \\<br/>  --network-plugin=cni \\<br/>  --register-node=true \\<br/>  --cgroup-driver=systemd \\<br/>  --v=2</span></pre><p id="6f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要引导Kubernetes工作节点，运行:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="59b6" class="nu md it nr b gy oo op l oq or">sh -x setup-worker.sh $workers</span></pre><p id="6ea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查安装是否成功，请运行:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="8568" class="nu md it nr b gy oo op l oq or">gcloud compute ssh master01 --internal-ip \<br/>  --command "kubectl get nodes --kubeconfig admin.kubeconfig"</span></pre><p id="e660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="bf8b" class="nu md it nr b gy oo op l oq or">NAME     STATUS     ROLES    AGE   VERSION<br/>node01   NotReady   &lt;none&gt;   98s   v1.15.3<br/>node02   NotReady   &lt;none&gt;   34s   v1.15.3</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="65b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">配置编织网和DNS插件</h1><p id="02af" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能已经注意到节点还没有准备好。这是因为该集群没有在路由表中定义正确的路由。</p><p id="65f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与最初的指南不同，在最初的指南中，Kelsey Hightower创建了手动路由，并将集群IP范围与节点IP范围进行了映射，我们将利用Kubernetes的<a class="ae ky" href="https://www.weave.works/docs/net/latest/install/" rel="noopener ugc nofollow" target="_blank"> Weave Net CNI插件</a>。</p><p id="e48d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将有助于我们自动进行映射，还将为我们提供其他功能，如pod安全策略、Kubernetes网络策略等。我们还将安装DNS插件，以便pods可以通过服务名称而不是服务IP来发现其他pods。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="af05" class="nu md it nr b gy oo op l oq or">sh -x setup-networking.sh $masters</span></pre><p id="9258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次运行<code class="fe no np nq nr b">kubectl get nodes</code>，看看他们是否准备好了。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="d058" class="nu md it nr b gy oo op l oq or">gcloud compute ssh master01 --internal-ip \<br/>  --command "kubectl get nodes --kubeconfig admin.kubeconfig"</span></pre><p id="489f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="e8b4" class="nu md it nr b gy oo op l oq or">NAME     STATUS   ROLES    AGE   VERSION<br/>node01   Ready    &lt;none&gt;   11m   v1.15.3<br/>node02   Ready    &lt;none&gt;   10m   v1.15.3</span></pre><p id="e94e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，他们现在准备好了！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="779a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">烟气试验</h1><p id="75a6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，我们已经艰难地配置了一个安全的、高度可用的、生产就绪的Kubernetes集群，是时候进行一些冒烟测试了。</p><h2 id="b2a6" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated"><strong class="ak">测试kube-proxy </strong></h2><p id="2e66" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将部署一个NGINX容器，然后在控制平面上运行一个端口转发。如果您正确设置了kube-proxy，我们将能够通过本地主机上的转发端口访问NGINX。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="9799" class="nu md it nr b gy oo op l oq or">ZONE=`gcloud compute instances list --filter="name=master01"| grep master01 | awk '{ print $2 }'`<br/>gcloud compute ssh --zone=$ZONE --internal-ip master01<br/>#Setup NGINX on a container<br/>kubectl run nginx --image=nginx<br/>kubectl get pods -l run=nginx<br/>POD_NAME=$(kubectl get pods -l run=nginx -o jsonpath="{.items[0].metadata.name}")<br/>kubectl port-forward $POD_NAME 8081:80</span></pre><p id="b190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从堡垒主机的另一个实例中，运行:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="580d" class="nu md it nr b gy oo op l oq or">ZONE=`gcloud compute instances list --filter="name=master01"| grep master01 | awk '{ print $2 }'`<br/>gcloud compute ssh --zone=$ZONE --internal-ip master01<br/>curl --head <a class="ae ky" href="http://127.0.0.1:8081" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8081</a></span></pre><p id="6b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="6300" class="nu md it nr b gy oo op l oq or">HTTP/1.1 200 OK<br/>Server: nginx/1.17.9<br/>Date: Sun, 12 Apr 2020 23:58:08 GMT<br/>Content-Type: text/html<br/>Content-Length: 612<br/>Last-Modified: Tue, 03 Mar 2020 14:32:47 GMT<br/>Connection: keep-alive<br/>ETag: "5e5e6a8f-264"<br/>Accept-Ranges: bytes</span></pre><h2 id="7345" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated"><strong class="ak">执行测试</strong></h2><p id="eac1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">测试我们是否可以在运行的容器中执行命令。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="ee5a" class="nu md it nr b gy oo op l oq or">POD_NAME=$(kubectl get pods -l run=nginx -o jsonpath="{.items[0].metadata.name}")<br/>kubectl exec -ti $POD_NAME -- nginx -v</span></pre><p id="d9da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="1610" class="nu md it nr b gy oo op l oq or">nginx version: nginx/1.17.9</span></pre><h2 id="5d1e" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated"><strong class="ak">节点端口测试</strong></h2><p id="2f7f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">测试<code class="fe no np nq nr b">NodePort</code>是否正常运行。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="2b07" class="nu md it nr b gy oo op l oq or">kubectl expose deployment nginx --port 80 --type NodePort<br/>NODEPORT=$(kubectl get svc nginx -o jsonpath="{.spec.ports[0].nodePort}")<br/>curl -I node01:$NODEPORT<br/>curl -I node02:$NODEPORT</span></pre><p id="4d71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="33a3" class="nu md it nr b gy oo op l oq or">+ curl -I node01:32403<br/>HTTP/1.1 200 OK<br/>Server: nginx/1.17.9<br/>Date: Sun, 12 Apr 2020 23:58:06 GMT<br/>Content-Type: text/html<br/>Content-Length: 612<br/>Last-Modified: Tue, 03 Mar 2020 14:32:47 GMT<br/>Connection: keep-alive<br/>ETag: "5e5e6a8f-264"<br/>Accept-Ranges: bytes</span><span id="b6a4" class="nu md it nr b gy ot op l oq or">+ curl -I node02:32403<br/>HTTP/1.1 200 OK<br/>Server: nginx/1.17.9<br/>Date: Sun, 12 Apr 2020 23:58:08 GMT<br/>Content-Type: text/html<br/>Content-Length: 612<br/>Last-Modified: Tue, 03 Mar 2020 14:32:47 GMT<br/>Connection: keep-alive<br/>ETag: "5e5e6a8f-264"<br/>Accept-Ranges: bytes</span></pre><h2 id="ae38" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated"><strong class="ak">测试日志</strong></h2><p id="7ab1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">测试我们是否可以从容器中浏览日志。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="db72" class="nu md it nr b gy oo op l oq or">kubectl logs $POD_NAME</span></pre><p id="af0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="3dd7" class="nu md it nr b gy oo op l oq or">10.200.192.0 - - [12/Apr/2020:23:58:06 +0000] "HEAD / HTTP/1.1" 200 0 "-" "curl/7.29.0" "-"<br/>10.200.0.1 - - [12/Apr/2020:23:58:08 +0000] "HEAD / HTTP/1.1" 200 0 "-" "curl/7.29.0" "-"</span></pre><h2 id="b936" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated"><strong class="ak">核心域名测试</strong></h2><p id="e94f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">测试我们是否可以在节点内成功运行<code class="fe no np nq nr b">nslookup</code>。为此，我们将发射一个<code class="fe no np nq nr b">busybox</code>吊舱，从那里我们将尝试<code class="fe no np nq nr b">nslookup</code> Kubernetes。如果您正确安装了<a class="ae ky" href="https://coredns.io/" rel="noopener ugc nofollow" target="_blank"> CoreDNS </a>，那么Kubernetes就是默认创建的服务。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="e751" class="nu md it nr b gy oo op l oq or">kubectl run busybox --image=busybox:1.28 --command -- sleep 3600<br/>kubectl get pods<br/>POD_NAME=$(kubectl get pods -l run=busybox -o jsonpath="{.items[0].metadata.name}")<br/>sleep 10<br/>kubectl exec -ti $POD_NAME -- nslookup kubernetes</span></pre><p id="3c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="1f1a" class="nu md it nr b gy oo op l oq or">Server:    10.32.0.10<br/>Address 1: 10.32.0.10 kube-dns.kube-system.svc.cluster.local</span><span id="3a58" class="nu md it nr b gy ot op l oq or">Name:      kubernetes<br/>Address 1: 10.32.0.1 kubernetes.default.svc.cluster.local</span></pre><h2 id="2822" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated"><strong class="ak">静态秘密加密测试</strong></h2><p id="edb0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将测试Kubernetes是否加密静态秘密。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="d74f" class="nu md it nr b gy oo op l oq or">kubectl create secret generic kubernetes-the-hard-way --from-literal="mykey=mydata"</span></pre><p id="dda0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在登录到一个etcd节点，对秘密进行十六进制转储。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="eca0" class="nu md it nr b gy oo op l oq or">ZONE=`gcloud compute instances list --filter="name=etcd01"| grep master01 | awk '{ print $2 }'`<br/>gcloud compute ssh --zone=$ZONE --internal-ip etcd01<br/>sudo ETCDCTL_API=3 /usr/local/bin/etcdctl get \<br/>  --endpoints=<a class="ae ky" href="https://127.0.0.1:2379" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:2379</a> \<br/>  --cacert=/etc/etcd/ca.pem \<br/>  --cert=/etc/etcd/etcd.pem \<br/>  --key=/etc/etcd/etcd-key.pem\<br/>  /registry/secrets/default/kubernetes-the-hard-way | hexdump -C</span></pre><p id="22f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="cb92" class="nu md it nr b gy oo op l oq or">00000000  2f 72 65 67 69 73 74 72  79 2f 73 65 63 72 65 74  |/registry/secret|<br/>00000010  73 2f 64 65 66 61 75 6c  74 2f 6b 75 62 65 72 6e  |s/default/kubern|<br/>00000020  65 74 65 73 2d 74 68 65  2d 68 61 72 64 2d 77 61  |etes-the-hard-wa|<br/>00000030  79 0a 6b 38 73 3a 65 6e  63 3a 61 65 73 63 62 63  |y.k8s:enc:aescbc|<br/>00000040  3a 76 31 3a 6b 65 79 31  3a 37 8e ba c4 45 8b 58  |:v1:key1:7...E.X|<br/>00000050  36 6d 23 a9 3f 3a 4d 3e  36 45 bd 37 be 23 85 52  |6m#.?:M&gt;6E.7.#.R|<br/>00000060  01 75 e9 df de 5a 66 9d  d0 26 04 d2 98 92 a8 ab  |.u...Zf..&amp;......|<br/>00000070  80 cb f2 fe a5 c5 16 9c  d5 14 1d c6 de 92 5b 1a  |..............[.|<br/>00000080  6e 93 0c 91 17 ed d9 40  74 80 16 b1 36 45 7c cb  |n......<a class="ae ky" href="http://twitter.com/t" rel="noopener ugc nofollow" target="_blank">@t</a>...6E|.|<br/>00000090  5e 1a 24 05 9f 2f 58 c0  b2 83 f7 2d b8 2d ca b6  |^.$../X....-.-..|<br/>000000a0  1d 09 f8 3b 18 23 7c eb  1a 35 35 25 68 2f 6a 55  |...;.#|..55%h/jU|<br/>000000b0  2f f2 53 f0 8a 04 53 dc  f0 56 4b a5 23 f1 fe 4a  |/.S...S..VK.#..J|<br/>000000c0  bc 4d 0d a9 d8 03 2c 4b  1b 9e cd 12 ee 41 df ed  |.M....,K.....A..|<br/>000000d0  4a f8 e5 19 a3 4c ed 06  74 08 07 d3 7e 1c 03 f2  |J....L..t...~...|<br/>000000e0  a5 21 a4 0e 6a 91 86 93  5f 0a                    |.!..j..._.|<br/>000000ea</span></pre><p id="26de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这个秘密被加密了！</p><h2 id="092f" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated"><strong class="ak">烟尘测试清理</strong></h2><p id="80a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">清理我们为测试创建的资源。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="695b" class="nu md it nr b gy oo op l oq or">kubectl delete secret kubernetes-the-hard-way<br/>kubectl delete svc nginx<br/>kubectl delete deployment nginx<br/>kubectl delete deployment busybox</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6493" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">清理</h1><p id="b9db" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你是为了学习而创建集群的，那么在你完成之后销毁基础设施以避免巨额账单是有意义的。</p><pre class="kj kk kl km gt ok nr ol om aw on bi"><span id="13e6" class="nu md it nr b gy oo op l oq or">terraform destroy</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="619c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8bfb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢阅读，我希望你喜欢这篇文章。故事的范围以按照最初的指南引导集群结束。</p><p id="a692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使您的集群更加安全，您还可以做更多的事情，我将在以后的文章中介绍这些内容。要获得更高层次的理解，请阅读“<a class="ae ky" href="https://medium.com/better-programming/how-to-harden-your-kubernetes-cluster-for-production-7e47990efc2a" rel="noopener">如何为生产强化您的Kubernetes集群</a>”请继续关注空间，了解更多信息！</p></div></div>    
</body>
</html>