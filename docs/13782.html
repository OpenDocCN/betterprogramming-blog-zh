<html>
<head>
<title>Create Your First Swift Package Command Plugin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建您的首个Swift包命令插件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-your-first-swift-package-command-plugin-3f918e2e8b8e?source=collection_archive---------3-----------------------#2022-09-27">https://betterprogramming.pub/create-your-first-swift-package-command-plugin-3f918e2e8b8e?source=collection_archive---------3-----------------------#2022-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f95c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何编写和调试Swift包命令插件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e320859be00c6a85196139ff1676da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0OQ7lv4opjGGqPlp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰斯·贝利在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e6ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今年，苹果发布了Swift Package Manager的新功能:Swift Package Plugins。我们现在可以编写两种自动与Xcode集成的插件:</p><ul class=""><li id="c884" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">构建(和预构建)插件。</li><li id="d95b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">命令插件。</li></ul><p id="9cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经在两篇文章中谈到了构建插件:“<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/implement-your-first-swift-package-build-plugin-9835a7aded0b">实现您的第一个Swift包构建插件</a>”和“<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-xcode-plugins-in-your-ios-app-13574261f210">如何在您的iOS应用</a>中使用Xcode插件”。</p><p id="2ad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我想和你分享创建一个命令插件需要哪些步骤。这些插件的开发者体验并不好，所以我想分享一个调试它们的技巧。</p><blockquote class="mj mk ml"><p id="a392" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">你可以在这些WWDC22视频中找到更多关于Swift包插件的信息:<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2022/110359/" rel="noopener ugc nofollow" target="_blank">认识Swift包插件</a>，<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2022/110401/" rel="noopener ugc nofollow" target="_blank">创建Swift包插件</a></p></blockquote><h1 id="f608" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">插件</h1><p id="d464" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，您将创建一个命令插件，从JSON规范中生成一些Swift代码。</p><p id="37dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个命令插件，您需要各种组件:</p><ul class=""><li id="77b9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一个<code class="fe nn no np nq b">Package.swift</code>文件来定义插件的结构。</li><li id="f134" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">适当的文件夹结构。</li><li id="b8bf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">符合<code class="fe nn no np nq b">CommandPlugin</code>协议的Swift <code class="fe nn no np nq b">struct</code>。</li><li id="9f4e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">实现插件的业务逻辑。</li><li id="46f9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">可选地，一个额外的包来测试插件。</li></ul><h2 id="b801" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">包裹，斯威夫特</h2><p id="39e3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Swift包插件被定义为Swift包。你需要为你的插件创建一个新的包。</p><p id="8dba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令插件的典型包结构如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="221b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的重要细节是:</p><ul class=""><li id="f666" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">1号线的<code class="fe nn no np nq b">swift-tool-version</code>必须至少为<code class="fe nn no np nq b">5.7</code>。</li><li id="94a4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">target</code>是具有<code class="fe nn no np nq b">.command</code>能力的<code class="fe nn no np nq b">.plugin</code>类型。</li></ul><p id="9ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完整地定义一个命令插件，我们需要添加几个属性:一个<code class="fe nn no np nq b">intent</code>和一组<code class="fe nn no np nq b">permissions</code>。</p><p id="dc62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">intent</code>是插件存在的原因。它由一个<code class="fe nn no np nq b">verb</code>和一个描述构成。</p><ul class=""><li id="9aaf" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">命令插件也可以通过<code class="fe nn no np nq b">swift package </code>命令行工具调用。<code class="fe nn no np nq b">verb</code>属性是我们可以在命令行中用来调用这个命令插件的参数。语法如下:</li></ul><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="a3e6" class="nr mr it nq b gy oj ok l ol om">swift package plugin &lt;verb&gt; [args...]</span></pre><ul class=""><li id="b889" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b">description</code>属性是插件的可读描述。</li></ul><p id="10fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这组<code class="fe nn no np nq b">permissions</code>来自于在包API 中定义的<a class="ae ky" href="https://developer.apple.com/documentation/packagedescription/pluginpermission" rel="noopener ugc nofollow" target="_blank">枚举。enum没有显式的cases，但是它提供了一个静态函数:<code class="fe nn no np nq b">writeToPackageDirectory</code>。这告诉Xcode你的插件需要写权限，IDE会在命令被调用时提示用户一条消息。提示符将显示<code class="fe nn no np nq b">reason</code>字符串:一个人类可读的描述，向您的用户解释插件将用这个权限做什么。</a></p><h2 id="4c56" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">文件夹结构</h2><p id="0928" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">像所有的Swift包一样，插件需要遵循一个合适的文件夹结构来正确构建。您可以使用<code class="fe nn no np nq b">path</code>属性定制<code class="fe nn no np nq b">Package.swift</code>中的结构，但是默认的文件夹结构是这样的:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="0035" class="nr mr it nq b gy oj ok l ol om">CodeGeneratorPlugin<br/>├── Package.swift<br/>└── Plugins<br/>    └── CodeGenerator<br/>        └── CodeGenerator.swift</span></pre><p id="4caf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">CodeGeneratorPlugin</code>是包含当前包的文件夹。<code class="fe nn no np nq b">Plugins</code>文件夹是<code class="fe nn no np nq b">Package.swift</code>中定义的所有插件的主目录。每个插件的代码必须位于与插件同名的文件夹中，在本例中为<code class="fe nn no np nq b">CodeGenerator</code>。</p><p id="4a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">CodeGenerator.swift</code>文件是插件的入口点，它将包含其业务逻辑。与其他文件夹不同，没有必要将其命名为<code class="fe nn no np nq b">CodeGenerator</code>:Swift文件可以有任何名称。</p><h2 id="4e4c" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">代码生成器. swift</h2><p id="5326" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这个<code class="fe nn no np nq b">struct</code>是插件的入口点。基本结构是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的片段是:</p><ol class=""><li id="3761" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu on mb mc md bi translated"><code class="fe nn no np nq b">import PackagePlugin</code>语句。它为插件导入了带有所有新API的框架。</li><li id="d41e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated"><code class="fe nn no np nq b">@main</code>标注。它定义了插件的入口点。</li><li id="ccb4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated">符合<code class="fe nn no np nq b">CommandPlugin</code>。它将该结构标记为正确的命令插件，并强制实现其方法。</li><li id="0156" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated"><code class="fe nn no np nq b">performCommand</code>方法。它包含插件的逻辑。</li></ol><p id="f7e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">performCommand</code>有两个参数:T1和T2。<code class="fe nn no np nq b">context</code>可以用来从包中读取信息，比如它的路径。<code class="fe nn no np nq b">arguments</code>是一个参数列表，可以从Xcode或命令行传递给命令。</p><h2 id="1e19" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">生成代码的逻辑</h2><p id="625e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是创建插件的最后一步。您需要从JSON规范开始编写生成Swift代码的代码。为了实现这一点，您可能需要一些助手类和一些函数。</p><p id="2d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">JSON规范</strong></p><p id="6b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是定义表示JSON实体的数据。在这个例子中，您想要生成一些Swift结构。这些数据结构非常简单:它们只有<code class="fe nn no np nq b">let</code>属性。</p><p id="abe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您想要解析的JSON具有以下结构:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="95c7" class="nr mr it nq b gy oj ok l ol om">{<br/>  "fields": [{<br/>    "label": "&lt;variable name&gt;",<br/>    "type": "&lt;variable type&gt;",<br/>    ["subtype": "&lt;variable type&gt;"]<br/>  }]<br/>}</span></pre><p id="400c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个表示单个结构的JSON对象。它有一个<code class="fe nn no np nq b">fields</code>属性，该属性包含另一个完全定义Swift属性的对象。<code class="fe nn no np nq b">label</code>是结构中属性的名称；<code class="fe nn no np nq b">type</code>是属性的主要类型。在泛型的情况下，需要一个<code class="fe nn no np nq b">subtype</code>来指定泛型的类型。</p><p id="ab7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结构的名称将是文件的名称。因此，有效的JSON应该是下面的<code class="fe nn no np nq b">Person.json</code>文件:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="26a8" class="nr mr it nq b gy oj ok l ol om">{<br/>  "fields": [<br/>    {<br/>      "label": "name",<br/>      "type": "String",<br/>    },<br/>    {<br/>      "label": "surname",<br/>      "type": "String",<br/>    },<br/>    {<br/>      "label": "age",<br/>      "type": "Int",<br/>    },<br/>    {<br/>      "label": "family",<br/>      "type": "Array",<br/>      "subtype": "Person"<br/>    }<br/>  ]<br/>}</span></pre><p id="7e49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe nn no np nq b">Person</code>类型有名字，有姓氏，有年龄，有家庭，是其他<code class="fe nn no np nq b">Person</code>类型的列表。在执行插件之后，您期望获得以下swift结构:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="a4ce" class="nr mr it nq b gy oj ok l ol om">struct Person {<br/>  let name: String,<br/>  let surname: String,<br/>  let age: Int<br/>  let family: [Person]<br/>} </span></pre><p id="3be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据模型</strong></p><p id="2c1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在插件逻辑中正确地处理这个JSON，您需要正确地对它建模，以便能够对它进行解码。</p><p id="ad6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，您需要这两个结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="236c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个<code class="fe nn no np nq b">struct</code>是包含字段列表的包装器。它代表顶级JSON对象。</p><p id="9ea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">Field</code>结构是定义内部对象的数据模型。它有一个用于<code class="fe nn no np nq b">label</code>的属性，一个用于<code class="fe nn no np nq b">type</code>的属性，以及一个用于<code class="fe nn no np nq b">subtype</code>的可选属性，以防您必须处理泛型。</p><p id="4a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">逻辑</strong></p><p id="57ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以实现逻辑。你可以在插件中把它分成不同的功能来简化它。</p><p id="66b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个函数是<code class="fe nn no np nq b">performCommand</code>，插件的入口点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="10cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以把它看作是插件的<a class="ae ky" href="https://blog.ploeh.dk/2011/07/28/CompositionRoot/" rel="noopener ugc nofollow" target="_blank">组合根</a>:你可以从上下文中获取所有相关数据，实例化依赖关系，并把它们传递给代码的其余部分。</p><p id="d3a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">performCommand</code>调用<code class="fe nn no np nq b">executeCommand</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="ea24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法通过使用<code class="fe nn no np nq b">drillDown</code>方法提取所有需要生成的结构。如果没有结构，它将返回。</p><p id="cd51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，它将结构写到一个名为<code class="fe nn no np nq b">Struct.swift</code>的文件中:为了简单起见，所有的结构都包含在一个文件中。</p><p id="89f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">drillDown</code>方法负责爬行包的文件夹结构，以递归的方式寻找JSON规范:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="38ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子假设所有的<code class="fe nn no np nq b">JSON</code>规格都位于一个名为<code class="fe nn no np nq b">Definitions</code>的文件夹中。</p><p id="f042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">drillDown</code>方法从获取<code class="fe nn no np nq b">directory</code>属性的内容开始，默认情况下，该属性是包的主文件夹。然后，如果<code class="fe nn no np nq b">directory</code>的最后一个路径组件是<code class="fe nn no np nq b">Definitions</code>，它检索文件夹中包含的每个项目的完整路径，并为每个项目调用<code class="fe nn no np nq b">createSwiftStruct</code>函数。</p><p id="4067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，它继续在树上爬行:对于当前文件夹中的每个项目，它检查它是否是一个文件夹。如果它是一个文件夹，它会尝试<code class="fe nn no np nq b">drillDown</code>进入其中，并将结果累积到一个变量中，该变量将在递归结束时返回。</p><p id="739f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一种方法是<code class="fe nn no np nq b">createSwiftStructure</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="fbb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法读取作为参数传递的文件内容。然后，它尝试使用上面定义的数据模型对其进行解码。</p><p id="9f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，它从文件名中提取出<code class="fe nn no np nq b">struct</code>名，并创建字段列表。</p><p id="9aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，它返回一个有效Swift <code class="fe nn no np nq b">struct</code>的<code class="fe nn no np nq b">String</code>。</p><h2 id="fa65" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated"><strong class="ak">如何使用</strong></h2><p id="1a54" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在，是时候在另一个包中尝试你的命令插件了。</p><p id="43bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，在<code class="fe nn no np nq b">Package.swift</code>中创建一个新包。为此，您只需在<code class="fe nn no np nq b">Package.swift</code>文件中添加一个<code class="fe nn no np nq b">.target</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="421f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该包还需要适当文件夹结构。应该是这样的:</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="ea61" class="nr mr it nq b gy oj ok l ol om">CodeGeneratorPlugin<br/>├── Package.swift<br/>└── Plugins<br/>│   └── CodeGenerator<br/>│       └── CodeGenerator.swift<br/>└── Sources<br/>    └── MyCode<br/>        └── HelloWorld.swift</span></pre><p id="a41a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">HelloWorld.swift</code>只是一个空的Swift文件:每个Swift包的文件夹中必须至少有一个Swift文件。</p><p id="13ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，如果您右键单击<code class="fe nn no np nq b">CodeGeneratorPlugin</code>项目，您已经可以看到Xcode在上下文菜单中显示了您的<code class="fe nn no np nq b">CodeGenerator</code>自定义插件！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/2d45da7760670261d49ff9f82cc8d9fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWwefmJ-0BYywhfXQ_sSPw.png"/></div></div></figure><p id="59af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是添加一个包含我们上面描述的<code class="fe nn no np nq b">Person.json</code>文件的<code class="fe nn no np nq b">Definitions</code>文件夹。</p><p id="91c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，点击上下文菜单中的<code class="fe nn no np nq b">CodeGenerator</code>菜单项，Xcode会显示一个对话框让你:</p><ol class=""><li id="8314" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu on mb mc md bi translated">选择插件应该在哪个目标上运行。</li><li id="c70c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated">如果需要，传递附加参数。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/4ca43b55dc93c4ae5c5cf70fa797b5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BwS_Gk_3IPw3vpVX4BzopA.png"/></div></div></figure><p id="0466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们不需要任何额外的参数，我们可以安全地单击<code class="fe nn no np nq b">Run</code>。</p><p id="5bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，Xcode会询问是否允许运行该命令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/d99bd3f4897062338ed852cbae0e1f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*vEyRbBKdtZL8H3vDZGF9QQ.png"/></div></figure><p id="c96e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该对话框中以<code class="fe nn no np nq b">From the author</code>开头的行显示了在本文第一步中您在<code class="fe nn no np nq b">Package.swift</code>中为您的插件设置的<code class="fe nn no np nq b">reason</code>。</p><p id="43e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过点击<code class="fe nn no np nq b">Allow Command to Change Files</code>，Xcode将执行该命令。几秒钟后，您应该会看到一个<code class="fe nn no np nq b">Structs.swift</code>文件出现在<code class="fe nn no np nq b">HelloWorld.swift</code>下面。</p><p id="5cc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新文件应该包含以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="c9a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！您创建了第一个命令插件，并使用Xcode将它应用到另一个目标上。</p><h1 id="8ba9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">调试插件</h1><p id="ebac" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">不幸的是，没有人能够不经过一点尝试和错误就写出完美的代码。在开发这个插件时，我经常运行它，看看它是否工作正常，但是开发人员的体验非常令人沮丧:</p><ol class=""><li id="5f83" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu on mb mc md bi translated">开始时，插件没有产生任何输出，因为它失败了。</li><li id="ce3b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated">Xcode没有发出任何我可以处理的错误。</li><li id="f12e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated">不可能连接调试器来查看发生了什么。</li><li id="ceba" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated">Swift <code class="fe nn no np nq b">print</code>函数没有在任何地方写任何东西。</li></ol><p id="5fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我调试这个插件的解决方案是将每一步都写入一个日志文件。为此，我遵循了以下步骤:</p><ol class=""><li id="f0e8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu on mb mc md bi translated">我创建了一个全局<code class="fe nn no np nq b">var log: [String]</code>变量。每次运行该命令时都会重新创建它，因此不存在进程间共享内存的问题。</li><li id="9fca" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated">我创建了一个<code class="fe nn no np nq b">log(_ message: String)</code>函数来将消息追加到<code class="fe nn no np nq b">log</code>变量中。</li><li id="89b0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated">我创建了一个<code class="fe nn no np nq b">printLog()</code>函数来<code class="fe nn no np nq b">join</code>所有的日志，并把它们写到一个<code class="fe nn no np nq b">logs</code>文件中，我可以在执行后检查它。</li><li id="a2e9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated">最后，我用对<code class="fe nn no np nq b">log(_:)</code>函数的调用来测试我的代码，看看发生了什么。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><blockquote class="mj mk ml"><p id="4881" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这是一种快速实现，但效率不高。它每次都重新创建文件，重写整个内容。更好的解决方案是将新日志附加到现有文件中。</p></blockquote><p id="771b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个技巧，我能够记录我遇到的各种错误，并成功地实现这个插件。</p><h1 id="8d82" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="01f1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在今天的文章中，您学习了如何为Swift 5.7配置命令插件。</p><p id="7998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您学习了如何构建包以及实现它的基本概念。您还学习了如何在Xcode中运行它。由于开发人员经验不足，您学习了如何创建一个基本的logger解决方案来查看各种执行步骤。</p><p id="a791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令插件非常有用，但是当从命令行使用时，它们会更加有用:例如，我们将能够在我们的持续集成环境中集成定制命令。</p><p id="8b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很期待看到社区会用这些新的强大工具创造出什么！</p></div></div>    
</body>
</html>