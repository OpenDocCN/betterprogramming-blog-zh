<html>
<head>
<title>Troubleshooting in Kubernetes: A Strategic Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes故障排除:战略指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/troubleshooting-in-kubernetes-a-strategic-guide-ceec28db0043?source=collection_archive---------2-----------------------#2020-11-02">https://betterprogramming.pub/troubleshooting-in-kubernetes-a-strategic-guide-ceec28db0043?source=collection_archive---------2-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb17" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当出现问题时，如何在Kubernetes中调试问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f9ef221ac7c672292fb749c7930bcac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uUceRe6L3gUgQYgi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Tobias Tullius 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="954a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes可能是一个棘手的平台，尤其是在调试和故障排除问题时。这种困难大部分来自于缺乏详细的错误消息和系统的复杂性。此外，容器编排流程中移动部分的绝对数量——以及表示该流程的少数几个状态——增加了挑战。例如，正如你将看到的，至少有六个合理的原因可以解释为什么<code class="fe lv lw lx ly b">Pod</code>会停留在<code class="fe lv lw lx ly b">ContainerCreating</code>或<code class="fe lv lw lx ly b">CrashLoppBackOff</code>状态。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="c420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/better-programming/3-years-of-kubernetes-in-production-heres-what-we-learned-44e77e1749c8" rel="noopener">在严格使用Kubernetes三年多之后</a>，我们遇到了一长串同样微妙和复杂的问题，尽管其中大多数主要属于以下三种情况:</p><ol class=""><li id="3401" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">吊舱卡在<code class="fe lv lw lx ly b">ContainerCreating</code>状态</li><li id="3aa8" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">CrashLoopBackOff</code>和周期性重启</li><li id="075f" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">网络连接问题</li></ol><p id="6c7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会发现，每一个问题的背后都有许多原因，这篇文章将帮助你理解这些原因以及背后的<em class="mu">为什么</em>。我们的目标不是给你一个命令或工具的列表(只能解决一组<em class="mu"/><em class="mu"/>)，而是提升你的理解，帮助你建立一种直觉，当Kubernetes中出现问题时，这种直觉可以帮助你解决任何问题<em class="mu"> </em>。</p><p id="2eeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大多数K8s问题，首先要查看的是事件日志(<code class="fe lv lw lx ly b">kubectl get events -n &lt;NAMESPACE&gt;</code>):它捕获了Kubernetes编排中每个步骤的细节，这些细节对于任何诊断都是关键的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b20d" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">1.荚卡在<code class="fe lv lw lx ly b">ContainerCreating State</code></h1><p id="8e8f" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">理解<code class="fe lv lw lx ly b">ContainerCreating</code>——或任何pod状态的主要概念是敏锐地知道它在k8s编排管道中的位置。这些信息将帮助我们识别和排除堆栈中的其他组件。例如，<code class="fe lv lw lx ly b">ContainerCreating</code>意味着<code class="fe lv lw lx ly b">kube-scheduler</code>已经为容器分配了一个工作节点，并指示<code class="fe lv lw lx ly b">Docker</code>守护进程启动工作负载。但是，请注意，在此阶段并未调配网络，也就是说，工作负载没有IP地址。</p><p id="3dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看你的<code class="fe lv lw lx ly b">Pod</code>可能会陷入<code class="fe lv lw lx ly b">ContainerCreating</code>阶段的一些常见原因:</p><h2 id="40d4" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">1.1 IP地址分配失败</h2><p id="92ce" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">KubeControlPlane</code>从CNI(比如说Calico)请求IP，当它不能分配IP时，<code class="fe lv lw lx ly b">ControlPlane</code>将只是无休止地等待一个IP，表面上没有日志跟踪或错误——从您的<code class="fe lv lw lx ly b">kubectl</code>终端也看不到任何东西。不过，这只是<code class="fe lv lw lx ly b">kubelet</code><strong class="lb iu">/<code class="fe lv lw lx ly b">system</code><strong class="lb iu"/>日志中捕获的<em class="mu"> </em>。</strong></p><p id="80db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">原因:</strong></p><ol class=""><li id="f36d" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">在您的<code class="fe lv lw lx ly b">CNI</code>中配置的<code class="fe lv lw lx ly b">IPPool</code>中缺少IPs</li><li id="f1b0" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">kubelet</code>和您的<code class="fe lv lw lx ly b">CNI</code>之间的通信错误</li><li id="4b88" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">CNI</code>中的配置错误</li></ol><h2 id="befa" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">1.2安装配置映射失败</h2><p id="9b34" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Configmaps</code>包含在运行时挂载到容器的(虚拟化)文件系统上的文件。业务流程中的这一阶段记录在事件日志中。</p><p id="626d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">原因:</strong></p><ol class=""><li id="cf94" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">节点上的<code class="fe lv lw lx ly b">/var/lib/docker</code>填满:这将阻止节点上的<code class="fe lv lw lx ly b">Docker</code>守护进程正常运行。</li><li id="eaa7" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">从吊舱部署引用时<code class="fe lv lw lx ly b">Configmap</code>的名称中的错误/错别字。</li></ol><h2 id="a48a" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">1.3未能申请PVs</h2><p id="5e94" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">依赖于状态信息的容器——如数据库或消息平台——如果无法通过<code class="fe lv lw lx ly b">PersistentVolumeClaim</code>挂载它们的<code class="fe lv lw lx ly b">PersistentVolume</code>,也会在<code class="fe lv lw lx ly b">ContainerCreating</code>阶段被卡住。这可以从事件日志中看出，更详细的信息可以在系统日志中找到。</p><p id="23d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">原因:</strong></p><ol class=""><li id="6e40" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">Kubernetes的<code class="fe lv lw lx ly b">CSI</code>插件与云提供商(Vsphere、AWS EBS等)之间的通信出错。)</li><li id="a784" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">当工作负载在集群中的节点间移动时，<code class="fe lv lw lx ly b">ControlPlane</code>执行<code class="fe lv lw lx ly b">attach</code>和<code class="fe lv lw lx ly b">detach</code>例程来移动磁盘——由于装载和卸载操作超时，此过程有时会花费更长时间。</li></ol></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4532" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated"><code class="fe lv lw lx ly b">2. CrashLoopBackOff &amp; Periodic Restarts</code></h1><p id="150f" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">CrashLoopBackOff</code>主要归因于容器代码或软件本身的故障。当容器中的<code class="fe lv lw lx ly b">entrypoint</code>命令被触发后错误退出时，就会出现这种情况。这种故障可能有多种原因，但通常可以归结为以下原因:</p><h2 id="bc44" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">2.1启动脚本或InitContainers中的错误</h2><p id="7af6" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">除了容器本身的软件错误之外，注入环境变量、挂载配置、机密或引用其他K8s对象的外部故障也可能导致启动失败，从而导致<code class="fe lv lw lx ly b">CrashLoopBackOff</code>。</p><h2 id="df43" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">2.2超出内存限制</h2><p id="8f56" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果容器在启动时——或者在其生命周期的后期——超过了<code class="fe lv lw lx ly b">Pod</code>设置的内存限制，Kubernetes将向正在运行的进程发出一个中断信号。如果这种情况经常发生，您可能会看到<code class="fe lv lw lx ly b">Pod</code>重启计数逐渐增加。</p><h2 id="a9c4" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">2.3磁盘/存储空间故障</h2><p id="746c" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">节点上的容器可能会因为两个区域缺少存储空间而出现故障:</p><ol class=""><li id="7acc" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">Pod</code>的<code class="fe lv lw lx ly b">PersistentVolume</code>本身，它可以影响容器进程</li><li id="cf75" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">调度<code class="fe lv lw lx ly b">Pod</code>的worker节点上的<code class="fe lv lw lx ly b">/var/lib/docker</code> (Docker的<code class="fe lv lw lx ly b">OverlayFS</code>)</li></ol><h2 id="e673" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">2.4活动性探测</h2><p id="0b80" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">Kubernetes中的活动性探测机制允许<code class="fe lv lw lx ly b">ControlPlane</code>自动重启失败的容器以获得弹性。但是，与此同时，如果配置过于激进，或者只是错误配置而没有考虑延迟恢复启动，这些探测器可能会影响稳定性:</p><ol class=""><li id="3258" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated"><strong class="lb iu">咄咄逼人的</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">Liveliness</strong></code> <strong class="lb iu">探测器</strong>会迫使Kubernetes执行频繁的检查。但是如果容器正在进行一个关键的GC事件(对于Java来说)，那么活动性检查很可能会失败——最终会重启容器。</li><li id="ed90" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><strong class="lb iu">变更/延迟恢复启动:</strong>有时，您的容器的启动可能会因为试图修复崩溃故障而延长。这经常出现在有状态的应用程序中，这些应用程序可能会运行恢复例程来处理诸如文件系统损坏之类的不利情况。因此，如果您的活动性探测设置中没有足够的余地来考虑这一点，您的容器可能会陷入无休止的重启循环中。</li></ol></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="323e" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">4.网络连接问题</h1><p id="74ff" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">Kubernetes的软件定义网络非常复杂，在调试连接问题时可能会特别令人生畏。例如，一个组件的故障，尤其是在网络堆栈中，可能会加剧集群中的连接问题。最后，它会让你关注多个地方，因此一个好的方法是从战略性地关注关键地方开始，缩小你的目标。</p><p id="f8d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到调试内部Kubernetes网络问题时，以下是需要磨练的基本领域。</p><h2 id="86b8" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">4.1 Kube-代理和IP表</h2><p id="bfac" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">kube-proxy</code>的主要职责是促进<code class="fe lv lw lx ly b">Service IP</code>与其后端(<code class="fe lv lw lx ly b">Pod IP</code>)端点之间的通信。因此，如果您的<code class="fe lv lw lx ly b">Pod</code>位于一个难以连接到服务IP的节点上——出现连接超时或连接被拒绝的错误消息——那么简单地重启<code class="fe lv lw lx ly b">kube-proxy</code>在大多数情况下可以解决问题，因为就像任何其他工作负载一样，您的<code class="fe lv lw lx ly b">kube-proxy</code>容器可能在该节点上崩溃或失败。</p><p id="5f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内核<code class="fe lv lw lx ly b">IP table</code>是服务和后端pod之间路由流量的核心组件，包括通过<code class="fe lv lw lx ly b">node-ports</code>的通信。<code class="fe lv lw lx ly b">Kube-proxy</code>使用IP表来设置规则，以促进负载平衡和伪装，因此，当您的<code class="fe lv lw lx ly b">Pod</code>可以到达其他<code class="fe lv lw lx ly b">Pod</code>IP而不能到达<code class="fe lv lw lx ly b">Service</code>IP时，IP表是需要查看的关键区域之一。</p><h2 id="ba84" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">4.2 Kube-DNS</h2><p id="e93b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在名称解析失败的情况下，首先要查看K8s集群中设置的内部DNS(默认DNS服务是<code class="fe lv lw lx ly b">kubedns</code>)——并确保该服务可以通过其<code class="fe lv lw lx ly b">Cluster</code>或<code class="fe lv lw lx ly b">Pod</code> IP到达。</p><p id="69c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，确保您的pod和worker节点中的<code class="fe lv lw lx ly b">resolv.conf</code>包含必要的DNS域和用于查找的名称服务器。</p><h2 id="7611" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">4.3 Conntrack</h2><p id="5e31" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Conntrack</code>中的问题会导致连接中断和网络流量不一致。简而言之，<code class="fe lv lw lx ly b">conntrack</code>是Linux内核维护系统中连接状态和逻辑流的方式。也就是说，如果您的应用程序公开了一个外部IP，并且有数百万个连接到这个IP，那么这些连接和逻辑流的状态将在内核的<code class="fe lv lw lx ly b">conntrack</code>表中被跟踪。足够合理的是，这些<code class="fe lv lw lx ly b">conntrack</code>表带有硬限制，当这些限制被突破时，网络就会出错。</p><p id="0d38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在RHEL上，<code class="fe lv lw lx ly b">conntrack</code>连接限制可以这样检查:</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="e86f" class="ns mw it ly b gy oi oj l ok ol">$  sysctl net.netfilter.nf_conntrack_count net.netfilter.nf_conntrack_maxnet.netfilter.nf_conntrack_count = 167012<br/>net.netfilter.nf_conntrack_max = 262144</span></pre><h2 id="2a70" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">4.5 CNI(容器网络接口)和路由表</h2><p id="1d4c" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">当您的CNI <code class="fe lv lw lx ly b">daemonset</code>(比如说<code class="fe lv lw lx ly b">calico</code>)在任何节点崩溃时，它会中断K8s集群中的路由和网络连接，通常局限于受影响的节点。</p><p id="2167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">kube-proxy</code>类似，重启该节点上的<code class="fe lv lw lx ly b">calico</code>容器或<code class="fe lv lw lx ly b">calico</code>控制器可以解决问题。就像集群中的任何其他工作负载一样，CNI <code class="fe lv lw lx ly b">Pods</code>也容易受到中断的影响。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="94eb" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">摘要</h1><p id="d27e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">Kubernetes是一个复杂的平台，调试一个问题绝非易事。例如，我们已经看到，像<code class="fe lv lw lx ly b">ContainerCreating</code>这样的一个冻结状态是如何与几种不同的原因联系在一起的——从IP分配失败到磁盘装载问题。它主要源于平台中大量的移动部件，以及它们在事物的大计划中是如何相互连接的。</p><p id="c63a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们研究了以下三个类别，以及众多问题是如何归因于它们的:</p><ol class=""><li id="b604" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">pod卡在<code class="fe lv lw lx ly b">ContainerCreating</code>状态</li><li id="7e0d" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">CrashLoopBackOff</code>周期性重启</li><li id="1a2f" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">网络连接问题</li></ol><p id="b3b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它让我们对内部工作有了深入的了解，并帮助我们建立直觉，知道当事情出错时该去哪里找；在库伯内特人的世界里，他们经常这样做。</p></div></div>    
</body>
</html>