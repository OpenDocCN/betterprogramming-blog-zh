<html>
<head>
<title>Combine, Publishers, and Core Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">联合收割机、出版商和核心数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/combine-publishers-and-core-data-424b68fe9473?source=collection_archive---------4-----------------------#2020-02-28">https://betterprogramming.pub/combine-publishers-and-core-data-424b68fe9473?source=collection_archive---------4-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e13a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建从核心数据到用户界面的连续信息流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/938792881f059ceee2c0941014e13c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pS-99Go_6l55MvuyBxcT0w.png"/></div></div></figure><p id="d7aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的上一篇文章<a class="ae lq" href="https://medium.com/better-programming/rxswift-observable-and-core-data-55ab87fc02ea" rel="noopener"> RxSwift、Observables和核心数据</a>中，我介绍了一种直接从核心数据缓存中获取可观察数据的方法。但是有些已经在用苹果的<a class="ae lq" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> Combine框架</a>，所以我为Combine准备了完全一样的解决方案。</p><p id="04ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总体思路是以发布者的形式获取核心数据实体的流，并在每次更新、插入或删除给定FetchRequest的核心数据实体时发送新值。</p><p id="414b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不会详细讨论如何使用这个流。更多信息可以在我之前的文章中找到。</p><p id="4811" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将需要<code class="fe lr ls lt lu b">NSFetchRequest</code>和一个<code class="fe lr ls lt lu b">NSManagedObjectContext</code>来初始化下面的发布者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">CDPublisher.swift</p></figure><p id="67f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次核心数据更新时，<code class="fe lr ls lt lu b">CDPublisher</code>都会向其订户发送新值。</p><p id="5c7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我建议不要直接使用核心数据实体，而是将其转换成域结构并使用。</p><p id="240b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是客户实体的一个示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/31d2a594a0211e323d7534216ec7733b.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*JxXqiWKXN9Fe3OIFTWsFIg.png"/></div></figure><p id="922c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将创建以下结构:</p><pre class="kj kk kl km gt mc lu md me aw mf bi"><span id="b4a7" class="mg mh it lu b gy mi mj l mk ml">struct DCustomer {<br/>  let id: Int<br/>  let name: String<br/>  let phone: String<br/>}</span></pre><p id="85ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并将<code class="fe lr ls lt lu b">CDPublisher</code>的结果映射到:</p><pre class="kj kk kl km gt mc lu md me aw mf bi"><span id="9cb8" class="mg mh it lu b gy mi mj l mk ml">CDPublisher(request: Customer.fetchRequest(), context: database.viewContext)<br/>.map { $0.map { DCustomer(id: $0.id, name: $0.name, phone $0.phone) } }</span></pre></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="b219" class="mt mh it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">从这里做什么</h1><p id="d418" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">如果你使用SwiftUI，你可以更新你的视图模型的<code class="fe lr ls lt lu b">Published</code>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="97cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住以下几点:</p><ul class=""><li id="c6c3" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">当分配给一个<code class="fe lr ls lt lu b">Published</code>属性时，接收主线程中的值。</li><li id="e537" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">不要使用<code class="fe lr ls lt lu b">.assign(to: \.customers, on: <strong class="kw iu">self</strong>)</code>,因为它会导致对self的自引用，并且MyViewModel永远不会被释放。</li><li id="3f5f" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">在<code class="fe lr ls lt lu b">.sink</code>闭合中使用<code class="fe lr ls lt lu b">[weak self]</code>。</li><li id="7412" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">更好的解决方案存在，可以取代这个丑陋的<code class="fe lr ls lt lu b">.map().recieve().sink().store()</code>，但这将是另一篇文章的主题。</li></ul><p id="93eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一如既往，快乐编码。</p></div></div>    
</body>
</html>