<html>
<head>
<title>Understanding the Abstract Factory Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解抽象工厂设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-abstract-method-design-patterns-bc416aaaf076?source=collection_archive---------3-----------------------#2021-01-15">https://betterprogramming.pub/understanding-the-abstract-method-design-patterns-bc416aaaf076?source=collection_archive---------3-----------------------#2021-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e370" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建遵循可靠原则的对象族</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e01ca4c54f127c42216704cd738b644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xmzm0tpbHPidsTWY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@alschim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexander Schimmeck </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ea73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原著<a class="ae ky" href="https://bookshop.org/books/design-patterns-elements-of-reusable-object-oriented-software/9780201633610" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素</a>中描述了23种经典设计模式。这些模式为软件开发中经常出现的特定问题提供了解决方案。</p><p id="2ac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将描述<strong class="lb iu">抽象工厂模式</strong>是如何工作的，以及何时应该应用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5666" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">抽象工厂:基本思想</h1><p id="1dfd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">维基百科为我们提供了如下定义:</p><blockquote class="mz na nb"><p id="3d5c" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">"<strong class="lb iu">抽象工厂</strong> <a class="ae ky" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">模式</strong> </a>提供了一种封装一组单独的<a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_object" rel="noopener ugc nofollow" target="_blank">工厂</a>的方法，这些工厂具有共同的主题，而无需指定它们的具体类。"— <a class="ae ky" href="https://en.wikipedia.org/wiki/Abstract_factory_pattern#:~:text=The%20abstract%20factory%20pattern%20provides,without%20specifying%20their%20concrete%20classes" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="d630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，原书提供的定义如下:</p><blockquote class="mz na nb"><p id="1c10" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">"提供一个接口，用于创建相关或依赖对象的系列，而无需指定它们的具体类."—设计模式:可重用面向对象软件的元素</p></blockquote><p id="0319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多情况下，我们需要从可能的对象列表中创建不同类型的对象，这些对象在创建过程中与这些对象相关。自然的趋势是创建一个<code class="fe ng nh ni nj b">factoryManager</code>类，允许我们基于参数获得不同类型的对象。然而，这种解决方案有两个严重的缺点，我们将在本文中描述:</p><ul class=""><li id="fbf1" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">它打破了<a class="ae ky" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank"> <em class="nc">的开闭原则</em> </a>，<em class="nc"> </em>在软件伸缩时给出的代码不干净，不容易维护。</li><li id="9530" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe ng nh ni nj b">factoryManager</code>类被附加到您想要构建的所有类型的对象上，创建的代码被称为<em class="nc">意大利面条代码</em>。</li></ul><p id="1f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题及其解决方案已经在介绍工厂方法设计模式的章节中讨论过，当对象的创建很简单并且它们彼此不相关时，工厂方法设计模式允许解决这个问题。因此，建议您先阅读本文，以便稍后解决这个抽象工厂模式。</p><p id="e618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抽象工厂模式允许更清晰的代码，因为它避免了前面提到的问题。这个模式的UML图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/b092f70002632fe2bca7a08b7d3a07bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hq1dVINI67d-_IQjco5-Sw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UML图(图像源—设计模式:可重用面向对象软件的元素)</p></figure><p id="9b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组成该模式的类如下:</p><ul class=""><li id="1259" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><code class="fe ng nh ni nj b"><strong class="lb iu">AbstractProductA</strong></code>和<code class="fe ng nh ni nj b"><strong class="lb iu">AbstractProductB</strong></code>是同一类型但不同系列的一组产品的接口。换句话说，所有实现<code class="fe ng nh ni nj b">AbstractProductA</code>类的产品都属于相同的产品类型，尽管它们将被组织到不同的系列中。这种类型的对象将在下面的具体例子中得到更好的理解。</li><li id="a546" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe ng nh ni nj b"><strong class="lb iu">ProductA1</strong></code>、<code class="fe ng nh ni nj b"><strong class="lb iu">ProductA2</strong></code>、<code class="fe ng nh ni nj b"><strong class="lb iu">ProductB1</strong></code>、<code class="fe ng nh ni nj b"><strong class="lb iu">ProductB</strong></code>是每种<code class="fe ng nh ni nj b">AbstractProduct</code>的具体实现。</li><li id="19cb" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe ng nh ni nj b"><strong class="lb iu">AbstractFactory</strong></code>是为每个具体工厂(<code class="fe ng nh ni nj b">ConcreteFactory1</code>和<code class="fe ng nh ni nj b">AbstractFactory</code>)声明一组创建方法的接口。</li><li id="a9be" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe ng nh ni nj b"><strong class="lb iu">ConcreteFactory1</strong></code>和<code class="fe ng nh ni nj b"><strong class="lb iu">ConcreteFactory2</strong></code>为每个产品系列实现<code class="fe ng nh ni nj b">AbstractFactory</code>类的创建方法。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c00b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">抽象工厂模式:何时使用</h1><p id="9614" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在以下情况下使用抽象工厂模式:</p><ul class=""><li id="69d8" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">抽象工厂解决的问题类似于工厂方法模式解决的问题，但是在需要创建的对象类型上有更大的抽象性。因此，在抽象工厂的情况下，要求与几个彼此相关的产品族一起工作，而不是在一组产品中工作。</li><li id="587a" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">客户必须使用的对象系列事先并不知道。相反，这种知识直接依赖于另一个用户与系统的交互(最终用户或系统)。</li><li id="0a0f" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">如果有必要扩展内部组件(创建的系列和对象的数量)，而不必耦合代码，而是具有接口和抽象，允许轻松扩展工厂和特定产品。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0892" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">抽象工厂模式:优点和缺点</h1><p id="849c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">抽象工厂模式有许多优点，可以总结为以下几点:</p><ul class=""><li id="e25f" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">由同一工厂类创建的产品之间的兼容性是有保证的。</li><li id="cbc1" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">清理代码</strong>因为<strong class="lb iu"> </strong>由于可以在不破坏现有代码的情况下引入新产品系列，因此开闭原则得到了保证。</li><li id="42c9" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu"> Cleaner code </strong>因为遵守了单一责任原则(SRP ),因为创建具体产品的责任被转移到具体的创建者类，而不是具有此责任的客户类。</li></ul><p id="ee7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，与大多数设计模式一样，抽象工厂模式的主要缺点是增加了代码的复杂性和代码所需的类的数量。然而，当应用设计模式时，这个缺点是众所周知的，因为这是在代码中获得抽象的代价。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c6e4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">抽象工厂模式示例</h1><p id="809f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来我们将举例说明应用抽象工厂模式的两个例子:</p><ul class=""><li id="a029" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><strong class="lb iu">抽象工厂模式的基本结构</strong>。在这个例子中，我们将把理论上的UML图转换成类型脚本代码，以识别模式中涉及的每个类。</li><li id="51ef" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">在视频游戏中创造角色</strong>。让我们想想经典的WoW(魔兽世界),其中玩家可以根据自己选择的种族拥有一组对象。例如，我们会有种族:人类，兽人，法师，魔术师，他们会有不同的武器和盔甲(产品)，这取决于种族(物品家族)。</li></ul><p id="fd04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例将展示使用TypeScript实现这种模式。我们选择了TypeScript而不是JavaScript来实现这个实现——后者缺少接口或抽象类，因此实现接口和抽象类的责任将落在开发人员身上。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f97" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">例1。抽象工厂模式的基本结构</h1><p id="115b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在第一个例子中，我们将把理论上的UML图转换成TypeScript来测试这种模式的潜力。这是要实现的图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/a718eb65445f2c63861d739295a163f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kc8r8jedSbJ6JDo1vkI4g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">抽象工厂模式基本结构的类图</p></figure><p id="b2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将定义接口(<code class="fe ng nh ni nj b">AbstractProductA</code>和<code class="fe ng nh ni nj b">AbstractProductB</code>)，这些接口定义了我们想要为不同系列创建的具体产品的类型。在我们的具体例子中，为了尽可能简化对模式的理解，只为每个接口定义了一个方法:分别是<code class="fe ng nh ni nj b">usefulFunctionA</code>和<code class="fe ng nh ni nj b">usefulFunctionB</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AbstractProductA。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AbstractProductB。</p></figure><p id="0229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是定义实现这些接口的具体产品。在我们的例子中，将为每个抽象类实现两个具体的对象。对于第一个接口(<code class="fe ng nh ni nj b">AbstractProductA</code>)，实现了类<code class="fe ng nh ni nj b">ConcreteProductA1</code>和<code class="fe ng nh ni nj b">ConcreteProductA2</code>，而对于第二个接口(<code class="fe ng nh ni nj b">AbstractProductB</code>)，实现了类<code class="fe ng nh ni nj b">ConcreteProductB1</code>和<code class="fe ng nh ni nj b">ConcreteProductB2</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土产品1。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土制品2。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土制品B1。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土制品b</p></figure><p id="7859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦定义了与产品创建相关的类的结构，我们就开始定义与负责创建这些对象的工厂的创建相关的类的结构。因此，首先定义了抽象类<code class="fe ng nh ni nj b">AbstractFactory</code>，其中定义了具体工厂负责创建具体对象的方法。然而，注意这些方法从每个<code class="fe ng nh ni nj b">AbstractProductA</code>和<code class="fe ng nh ni nj b">AbstractProductB</code>产品中返回抽象类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">抽象工厂。</p></figure><p id="b0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，有必要定义实例化具体类的具体工厂。在第一个例子中，<code class="fe ng nh ni nj b">ConcreteFactory1</code>工厂将负责实例化家族1的具体对象(<code class="fe ng nh ni nj b">ConcreteProductA1</code>和<code class="fe ng nh ni nj b">ConcreteProductB1</code>)，而<code class="fe ng nh ni nj b">ConcreteFactory2</code>工厂将负责实例化家族2的具体对象(<code class="fe ng nh ni nj b">ConcreteProductA2</code>和<code class="fe ng nh ni nj b">ConcreteProductB2</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土工厂1。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土工厂2。</p></figure><p id="e009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这不是模式的直接组成部分，但是有必要通过<code class="fe ng nh ni nj b">Client</code> / <code class="fe ng nh ni nj b">Context</code>类来查看模式的执行。在这种情况下，<code class="fe ng nh ni nj b">ClientCode</code>方法不需要知道创建产品的具体工厂，但是接收一个<code class="fe ng nh ni nj b">AbstractFactory</code>类的对象作为参数就足以执行<code class="fe ng nh ni nj b">CreateProductA</code>和<code class="fe ng nh ni nj b">CreateProductB</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户代码。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d6c6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">例2。为视频游戏创建英雄装备</h1><p id="f13b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经看到了该模式的理论示例，所以您已经理解了该模式中每个类的职责。现在我们将举例说明一个真实的例子，在这个例子中我们将识别这个设计模式的每一个类。</p><p id="67cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的问题包括视频游戏中不同英雄或角色的装备的表示。我们将重点介绍经典视频游戏WoW(魔兽世界)，其中的英雄分为三个种族:人类、兽人和魔术师。这些英雄中的每一个都有不同的<code class="fe ng nh ni nj b">armor</code>和<code class="fe ng nh ni nj b">weapon</code>,这取决于不同的种族。因此，我们已经可以确定要制造的产品将是不同类型的盔甲和武器，产品系列是人类、兽人和巫师的产品系列。</p><p id="ed94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，遵循与我们在前面的例子中所展示的方法相同的方法，我们将从查看UML图开始，它将帮助我们识别这个模式的每个部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/05b01d741cd7006b955f8c8775d17c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bsCUIHyKdpbarsKMWtF4w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类图:视频游戏</p></figure><p id="3ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先验的，这个问题的类设计可能令人印象深刻，但是如果我们已经理解了这个模式的基本结构的例子，我们就会完美地理解这个例子。</p><p id="8793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从创建每种特定的产品类型开始。也就是说，首先定义的是模拟a <code class="fe ng nh ni nj b">weapon</code>的接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">武器。</p></figure><p id="8861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化示例，只为每个<code class="fe ng nh ni nj b">weapon</code>定义了一个方法<code class="fe ng nh ni nj b">usefulFunction</code>，因此，定义的具体武器为<code class="fe ng nh ni nj b">sword</code>、<code class="fe ng nh ni nj b">axe</code>和<code class="fe ng nh ni nj b">mage-fireball</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">剑。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斧头。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">法师火球。</p></figure><p id="882e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以与定义<code class="fe ng nh ni nj b">weapon</code>相同的方式，定义不同的<code class="fe ng nh ni nj b">armor</code>。在这个具体的例子中，我们通过一个叫做<code class="fe ng nh ni nj b">usefulFunctionWithWeapon</code>的方法在<code class="fe ng nh ni nj b">armor</code>和<code class="fe ng nh ni nj b">weapon</code>之间创建了一个协作，来说明对象可以相互关联。需要注意的最重要的事情是，<code class="fe ng nh ni nj b">collaborator</code>参数是抽象类<code class="fe ng nh ni nj b">Weapon</code>的，而不是使用具体的类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">盔甲。</p></figure><p id="a404" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这个问题需要的具体盔甲是<code class="fe ng nh ni nj b">BodyArmor</code>、<code class="fe ng nh ni nj b">OrcArmor</code>和<code class="fe ng nh ni nj b">Cloak</code>。这些将由每个对象族根据英雄的种族来创建。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">防弹衣。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">兽人盔甲。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斗蓬</p></figure><p id="94c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们想要在电子游戏中创建的具体产品已经确定，但创建规则尚未建立。具体的工厂将负责根据英雄的种族制造具体的产品。要定义的第一个类是抽象类<code class="fe ng nh ni nj b">AbstractFactory</code>，它定义了负责创建抽象<code class="fe ng nh ni nj b">Weapon</code>和<code class="fe ng nh ni nj b">Armor</code>产品的<code class="fe ng nh ni nj b">createWeapon</code>和<code class="fe ng nh ni nj b">createArmor</code>方法。请注意，到目前为止，所有代码都使用了抽象类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">抽象工厂。</p></figure><p id="dc03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时候我们要实现具体的工厂<code class="fe ng nh ni nj b">HumanFactory</code>、<code class="fe ng nh ni nj b">OrcFactory</code>、<code class="fe ng nh ni nj b">MageFactory</code>，其中的创造者方法是用具体的产品实现的，基于英雄的种族。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">战争工厂。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OrcFactory。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">磁性工厂。</p></figure><p id="5d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为创建英雄装备的例子的总结，我们将实现<code class="fe ng nh ni nj b">Client</code> / <code class="fe ng nh ni nj b">Context</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f2ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我创建了两个<code class="fe ng nh ni nj b">npm scripts</code>，通过它们可以执行本文中的代码:</p><pre class="kj kk kl km gt od nj oe of aw og bi"><span id="3108" class="oh md it nj b gy oi oj l ok ol">npm run example1<br/>npm run example2</span></pre><p id="3592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub回购可用<a class="ae ky" href="https://github.com/Caballerog/blog/tree/master/abstract-factory-pattern" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="184e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="21a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">抽象工厂是一种设计模式，它允许我们尊重开闭原则，并使用多态性将创建对象的责任委托给特定的类(具体工厂)。这允许我们有更干净和更可伸缩的代码。</p><p id="79d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式解决了当需要创建不同类型的对象时出现的问题，这些对象依赖于客户机与系统的交互，而事先并不知道客户机将创建哪个对象。此外，这些对象通过对象族相关联，这种方式允许在使用不同的工厂时通过上下文或对象类型将它们分开。</p><p id="ee28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式的另一个优点是，系统不耦合到一组具体的类，但是客户端只与抽象类通信，当软件扩展时，允许更多的可维护代码。</p><p id="56e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这种模式最重要的不是它的具体实现，而是能够认识到这种模式可以解决的问题以及何时可以应用它。具体的实现是最不重要的，因为它将根据所使用的编程语言而变化。</p></div></div>    
</body>
</html>