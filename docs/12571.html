<html>
<head>
<title>Code Ownership in the Post Continuous-deployment Era</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后持续部署时代的代码所有权</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/code-ownership-in-the-post-continuous-deployment-era-411643bf1835?source=collection_archive---------10-----------------------#2022-06-14">https://betterprogramming.pub/code-ownership-in-the-post-continuous-deployment-era-411643bf1835?source=collection_archive---------10-----------------------#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="68dc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">持续部署与持续交付。以下是一些不迷失最终目标的方法:持续改进</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/8bce0d4f7a8acfa946e9a1dcfe826291.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*pxEsfQum8yCpLANIXQwD1w.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="bafb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从加速发布到持续部署，也就是说，更频繁地发布，从来都不是简单的速度或速率的问题。对于不太懂技术或更有商业头脑的利益相关者来说，这些仅仅是证明投资这些现代实践的伟大卖点。</p><p id="77ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">毕竟，上市时间是在技术过程中投资有价值的工程努力的好方法。甚至这种推销也变得越来越不必要了。今天，大多数组织都将投资开发管道的必要性内在化了，并且由于今天的部署工具和更成熟的最佳实践，所需的投资并不是那么大。</p><p id="82ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">能够经常部署有很多好处。留在开发分支中的代码，塞在远离现实、用户和真实世界反馈的抽屉里，将会溃烂。</p><p id="b70d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于用户想要什么，他们如何使用系统，以及代码将如何执行的假设开始堆积，进行错误的进化转向，并最终导致失望、缺乏牵引力或数月的技术债务。更快地部署代码并不能从本质上解决这些问题。在最坏的情况下，这仅仅意味着你在不断地抛出新特性。</p><h1 id="b082" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">两个开发者的故事</h1><p id="0195" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Jim是一名出色的开发人员。事实上，他是现代全才的典范。他能流利地说五种编程/脚本语言；他非常熟悉与DevOps以及如何自动化代码部署相关的事务，他也是敏捷、测试等工作的大力倡导者。</p><p id="0975" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他正在使用最新的微服务技术编写代码，并使用大量策略持续部署到Kubernetes集群。每当有人脱口而出哪怕是很小的代码更改时，GitHub就会启动一些操作，APMs的精华就是用来监控生产环境的。</p><p id="7aff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有这些都是值得称赞的，表明了我们作为一个行业已经发展和成熟了多少。然而，在Jim的另一部杰作《将代码无缝转移到产品的流水线》中，有一样东西没有包括在内:学习。</p><p id="40cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管所有正确的系统都已到位，除非发生灾难性的事情，否则反馈回路是最小的。Jim和他的团队关注的是沿着管道向下移动下一段代码所需的步骤，以及下一段。他们针对带宽、速度和部署速度进行了优化。他们甚至设法保持管道稳定，并大幅减少停机时间。</p><p id="1399" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">他们最大化了他们发布的节奏，并且在每次迭代中推出更多的特性，但是他们没有为持续改进而优化。</p><p id="30d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">人们很容易专注于一个KPI——速度，并以更高的速度交付错误的代码。反馈最终会到来，伴随着技术债务检查</p><p id="5f0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的另一个虚构的开发者是Jullian。他不如吉姆流利；他试图自动化整个发布管道，但仍然有一些技术障碍需要解决。然而，Jullian在Jim尚未考虑的两个主题上投入了大量时间:当他将某个东西投入生产时，他想度量什么？他是如何在开发过程中包含度量的，这样它就不会隐藏在一个要求人们记得检查它的死仪表盘后面？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/e64a54ab4c9595c31cfdb21a84006336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H4GYNayYyUbGcBh3Fx8lnA.jpeg"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="dfed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Jim和Jullian都签入他们的变更，合并他们的PRs，并在经过各种测试和验证之后将他们的代码部署到生产中。然而，当Jim完成合并他的代码时，他会继续处理backlog中的下一个特性(他甚至会因此获得分数；<a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/youre-never-done-by-definition-c04ac77c616b">这就是组织正在衡量的</a>。除非灾难性的失败已经发生，否则他不会考虑已经犯下的错误。</p><p id="881c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Jullian也开始了他的backlog中的下一个项目，但是几分钟后，Slack bot通知他，他的代码第一次被一些alpha/canary用户用于生产。随着使用量的增加，他得到了更新:他的新查询影响了整体性能吗？它如何随着并发使用而扩展？他还了解到自从合并他的代码后，死锁的数量有所增加。看着这种趋势，他意识到需要做更多的工作来分离操作的读/写属性并提高查询带宽。</p><h1 id="2f86" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">流程将完成优化后的目标</h1><p id="8594" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我想起了吉尔·特纳最近看的一个<a class="ae mq" href="https://www.youtube.com/watch?v=nS0QgxgUYSA&amp;ab_channel=SkillsMatter%28IncorporatingYOW%21Conferences%29" rel="noopener ugc nofollow" target="_blank">视频</a>，视频中他讨论了性能测试中“99%的伟大谎言”。基本上，他想知道为什么总是到了第99个百分位数，系统的性能或多或少地得到了可预测的扩展，之后性能开始呈指数级下降。数字9有什么重要的？</p><p id="a402" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">答案是——这正是工程师们优化的目的！他们被要求对第99个百分点进行优化，因此，系统可以处理超过该点的任何可能的滞后请求，即使1%的用户会等待很长时间。</p><p id="89c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想起了这个例子，因为在我们的开发过程中，思考我们想要优化什么是很重要的。与上面的例子类似，如果我们优化的只是速度和短期稳定性，我们就不会创建随着时间的推移与使用相一致的系统，并且发现我们自己积累了技术债务，错过了真正享受持续部署的好处的机会。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mr"><img src="../Images/b8acbddd69f3eadb4cd924ef3ff484cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-bjYAycq4I1_Bd_m"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图片:Reddit</p></figure><p id="a445" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">吉姆呢。在这个例子中，他签入的代码从未在现实生活中使用过。没有人注意到任何问题，但是也没有人费心检查生产中是否调用了基础代码更改。其实不是，而且是几个月后才被发现的。</p><h1 id="b5e9" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">你能做些什么来确保持续的反馈和学习？</h1><p id="ee47" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">诚然，这是一个有些人为的例子。Jim在自动化部署和测试方面的远见将使他从可能降临到Jullian身上的麻烦中解脱出来。然而，我们也需要着眼于长期的比赛。这就是优化规模的地方，不仅在复杂性或使用方面，而且在支持开发人员将合作多年的代码库方面，这将不可避免地有我们需要注意的问题、错误和失调。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/620bc22177f8e1727b4fb2164148094a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YaovQOqZvBLgoPhp"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">来源:Reddit</p></figure><p id="270d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，我们如何改进开发过程并确保代码持续改进呢？</p><ol class=""><li id="25cd" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated"><strong class="kt ir">可观察性</strong> —如果你观察不到它，你就无法测量它，你也肯定无法修复它。看看<a class="ae mq" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">open telemetry</strong></a><strong class="kt ir"/>和不同的生态系统工具，让它与开发相关。我在这里<a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/the-observant-developer-part-1-1939d53fd5a4">写了更多，在<a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/improving-code-design-with-opentelemetry-a-practical-guide-a08e6440c24d">后续</a>文章中</a>用了一些具体的例子。</li><li id="9857" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">调整流程以适应<strong class="kt ir">反馈</strong> —开发人员应该在主要功能发布后定期召开会议，讨论和评估反馈。数字可以赢得关于建筑和设计的争论。代码是如何使用的？我们还应该寻找什么来验证它？</li><li id="b5ee" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir">小心仪表板</strong>。它可以是你最好的朋友，但也是你最大的偏见。仪表板确切地代表了它要测量的东西，就像一大堆绿色CI测试一样，它会导致一种虚假的自信感。我见过一些公司过于强调特定的指标，而完全忽略了其他指标。为什么？因为它们不在仪表板上。</li><li id="cf65" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">分配时间<strong class="kt ir">探索数据。</strong>任何数据科学家都会告诉你，他们需要沙盒中的数据来开始调整他们的见解。就像探索性测试一样，您会对您将发现的洞察力类型感到惊讶。专注于重点领域，如使用、性能或错误。</li></ol><p id="78b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很久以前，神话般的人月提出了这样一个命题:给一个延迟的项目增加人员并不会使一个延迟的项目提前交付。打破多年的管理教条。我要补充的是，“快”或“早发货”只是等式的一部分。</p><p id="4048" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使增加更多的工具、更多的开发人员和更多的技术会使项目更快——最终结果也会更好吗？“快”是一个重要的指标，因为它能让我们更早地获得反馈，但是如果我们不收集反馈呢？如果项目提前两个星期发布，但它没有按预期工作，会发生什么？谁说‘起跑’就是终点线？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="8f08" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">未来是什么样子的？</h1><p id="5645" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">可观察性和反馈工具的未来看起来很光明。从技术角度来看，OpenTelemetry正在为可观测性数据带来民主化，从而允许生态系统和开源工具的出现，满足开发人员在设计中包含此类反馈的需求。</p><p id="ea88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发人员对更多的管道承担了更多的责任，因此愿意接受更多的度量和信息来支持这种所有权并改进他们的代码。</p><p id="c680" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">连续部署、特性标记工具和从代码到产品的流水线自动化是收集有意义的反馈的第一步。尽管如此，许多组织已经在考虑下一步——自动化相反方向的信息流，从产品到代码。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="cf92" class="no lo iq nk b gy np nq l nr ns"><strong class="nk ir">Want to Connect? </strong></span><span id="24b6" class="no lo iq nk b gy nt nq l nr ns">You can reach me, Roni Dover, on Twitter at @doppleware.</span><span id="b85b" class="no lo iq nk b gy nt nq l nr ns">Follow my open source project for continuous feedback at <a class="ae mq" href="https://github.com/digma-ai/digma" rel="noopener ugc nofollow" target="_blank">https://github.com/digma-ai/digma</a>.</span></pre></div></div>    
</body>
</html>