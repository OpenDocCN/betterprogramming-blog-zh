<html>
<head>
<title>Structuring Rust Projects for Testability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为可测试性构建Rust项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/structuring-rust-project-for-testability-18207b5d0243?source=collection_archive---------4-----------------------#2020-11-03">https://betterprogramming.pub/structuring-rust-project-for-testability-18207b5d0243?source=collection_archive---------4-----------------------#2020-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ae41" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">写得更好，更易测试Rust</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7d6cc3e7df04f5573e26100dc5be8a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwYQOGc0iUZqAJpAl5T8gA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@the_roaming_platypus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> timJ </a>在<a class="ae kv" href="https://unsplash.com/s/photos/modular?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4dbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将看到如何构建一个Rust项目，使其易于测试。我们将构建一个简单的身份验证模块，该模块在将数据存储到PostgreSQL和Redis时通过REST API公开。我们将使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://actix.rs/" rel="noopener ugc nofollow" target="_blank">actix-web</a></code>来处理REST API部分，<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/launchbadge/sqlx" rel="noopener ugc nofollow" target="_blank">sqlx</a></code>用于与PostgreSQL交互，<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/mitsuhiko/redis-rs" rel="noopener ugc nofollow" target="_blank">redis-rs</a></code>用于与Redis交互。我们将看到如何将应用程序分解成可测试的更小的组件。最终的应用源代码可以从<a class="ae kv" href="https://github.com/eckyputrady/testable-rust-web-project" rel="noopener ugc nofollow" target="_blank"> GitHub </a>访问。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="da2d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">背景</h1><p id="08e7" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">众所周知，在软件项目中加入自动化测试会产生更好的软件。自动化测试有助于确保软件的正确性，同时也提高了软件的可维护性。因此，在你的软件项目中进行自动化测试是一个很好的实践。</p><p id="1aae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，合并自动化测试并不是一件简单的事情。你需要考虑如何组织你的项目，使其易于测试。一般来说，你需要做的是将你的软件内部模块化成可以独立测试的解耦组件。</p><p id="bec9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在做一个Rust web项目时遇到了这个问题。我试着从一些开源项目中寻找灵感。然而，他们的测试水平并不符合我的喜好。他们要么没有集成测试，要么只是跳过单元测试进行集成测试。</p><p id="371b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的目的是与您分享上述问题的解决方案，希望您(或未来的我)会觉得有用。除此之外，我很乐意收到任何关于你如何构建你的Rust项目的反馈，这样我的Rust“工具箱”就可以扩展了。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="962e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">端口和适配器模式</h1><p id="0e6d" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">除了基于web的软件项目之外，我的经验有限，所以对这一部分有所保留。</p><p id="3e4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数软件都可以用<a class="ae kv" href="http://www.dossier-andreas.net/software_architecture/ports_and_adapters.html" rel="noopener ugc nofollow" target="_blank">端口和适配器模式</a>来构建。在此模式中，您将项目组织成以下组件类型:</p><ol class=""><li id="8a60" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><strong class="ky ir">域</strong>:这些组件执行特定于域的逻辑。例如，如果您的领域是银行业，那么领域组件具有执行特定于银行业的功能的逻辑，比如在账户之间转移资金。</li><li id="2aa1" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><strong class="ky ir">端口</strong>:外部系统与您的域交互的“契约”，无论是从外向内还是从内向外。</li><li id="90f4" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><strong class="ky ir">适配器</strong>:这些组件使外部系统“适应”您的端口。例如，适配器组件将HTTP请求转换成由端口提供的操作。另一个例子是通过SQL将端口转换成数据库调用的组件。</li><li id="f9d3" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><strong class="ky ir">应用</strong>:该组件是组装所有其他组件的组件。端口和适配器模式的一个优点是，同一个端口可以有许多适配器。例如，您可以通过REST APIs或命令行与您的域进行交互，为每一个提供不同的适配器。当应用程序组件将所有组件组装在一起时，它决定使用哪个适配器。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/3945fed31e4c79e929818924022b938c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INGMNkT8or6cinPpr-4etg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">端口和适配器模式图</p></figure><p id="b7ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过根据上面的类型构建组件，然后我们想要在一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Test_double" rel="noopener ugc nofollow" target="_blank">测试双</a>的帮助下独立测试每个组件。例如，您想要测试您的域与端口的交互是否会触发特定的逻辑并返回预期的值。另一个例子是测试HTTP适配器，看HTTP请求是否会正确触发特定端口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/3936a3b2b0b07480ef08d67e36e3b24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_N88SNNBPU_qwiXeba379g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试端口和适配器模式中每个组件的策略</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8482" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">铁锈的例子</h1><p id="519a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">现在我们有了我们想要实现的基本概念，让我们将它应用到一个Rust项目中。我通过学习工作实例学习得最好。因此，让我们为我们的案例创建一个。</p><h2 id="f9db" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">应用程序描述</h2><p id="d717" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们想要构建的应用程序是一个简单的身份验证模块。该模块具有以下功能:</p><ol class=""><li id="187d" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><strong class="ky ir">注册</strong>:新用户可以注册到应用中。</li><li id="bde9" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><strong class="ky ir">登录</strong>:注册用户可以通过提供凭证登录，作为回报，他们将收到一个可用于身份验证的令牌。</li><li id="2a3a" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><strong class="ky ir">认证</strong>:将给定的令牌解析为用户。</li></ol><p id="de43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望该应用程序可以从网上访问。我们还想使用PostgreSQL来存储我们的用户数据。除此之外，我们希望将令牌存储在Redis中，以便快速检索。听起来很典型吧？</p><h2 id="06e5" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">体系结构</h2><p id="5bcc" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">根据端口和适配器模式，组件如下:</p><p id="4e9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">端口</strong>:</p><ol class=""><li id="bdd7" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><strong class="ky ir"> AuthService </strong>:我们公开域功能的端口</li><li id="ad5e" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><strong class="ky ir">令牌报告</strong>:我们的域与令牌存储交互的端口</li><li id="814b" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><strong class="ky ir"> CredentialRepo </strong>:我们的域与凭证存储交互的端口。</li></ol><p id="5f11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">域:</strong></p><ol class=""><li id="94a1" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><strong class="ky ir"> AuthServiceImpl </strong>:实现AuthService端口时容纳特定于auth的逻辑的组件</li></ol><p id="7bc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">适配器:</strong></p><ol class=""><li id="662b" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><strong class="ky ir"> RedisTokenRepo </strong>:通过将令牌报告端口转换为Redis操作来与Redis交互的组件</li><li id="388b" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><strong class="ky ir"> PostgresCredentialRepo </strong>:通过将CredentialRepo端口转换为PostgreSQL操作来与PostgreSQL交互的组件</li><li id="a649" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><strong class="ky ir"> RestAuthController </strong>:通过将HTTP请求转换成对AuthService端口的调用来与AuthService端口交互的组件</li></ol><p id="636a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">应用</strong></p><ol class=""><li id="9cfe" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><strong class="ky ir"> Main </strong>:将组件组装在一起，使它们作为应用程序正常工作</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/4abd7b7f360d558eed5a57215ac44582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWcW4vCkZhCiJYeM-Xqyag.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用端口和适配器模式的应用程序结构</p></figure><h2 id="31bb" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">Rust实现</h2><p id="f680" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">现在，上一节中的架构如何转化为Rust？一般的经验法则是将端口实现为<code class="fe ls lt lu lv b">trait</code> s，而将其他端口实现为<code class="fe ls lt lu lv b">struct</code>、<code class="fe ls lt lu lv b">impl</code>或<code class="fe ls lt lu lv b">module</code> s。让我们跟随实现，以便您有一个更清晰的画面。</p><p id="7070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们看看源文件是如何构造的。下面的清单向您展示了这一点。</p><pre class="kg kh ki kj gt oc lv od oe aw of bi"><span id="4d59" class="nq me iq lv b gy og oh l oi oj">.<br/>├── Cargo.toml<br/>├── migrations<br/>│ └── 000000_init.sql<br/>├── src<br/>│ ├── auth<br/>│ │ ├── auth_service_impl.rs<br/>│ │ ├── mod.rs<br/>│ │ ├── ports.rs<br/>│ │ ├── postgres_credential_repo.rs<br/>│ │ ├── redis_token_repo.rs<br/>│ │ └── rest_auth_controller.rs<br/>│ ├── infrastructure<br/>│ │ ├── mod.rs<br/>│ │ ├── postgresql.rs<br/>│ │ └── redis.rs<br/>│ └── main.rs<br/>└── test-stack.yml</span></pre><h2 id="872f" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">Rust中的端口实现</h2><p id="9f7a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">端口在<code class="fe ls lt lu lv b">auth/ports.rs</code>中定义。您可以看到，我们为每个端口设置了一个<code class="fe ls lt lu lv b">trait</code>,为每个与端口交互的特殊数据结构设置了一个<code class="fe ls lt lu lv b">struct</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="64a4" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">Rust中的域实现</h2><p id="d852" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">领域组件，碰巧只有<code class="fe ls lt lu lv b">AuthServiceImpl</code>在一个名为<code class="fe ls lt lu lv b">auth/auth_service_impl.rs</code>的单独文件中实现。如您所见，我们有一个<code class="fe ls lt lu lv b">struct</code>来保存对<code class="fe ls lt lu lv b">TokenRepo</code>端口和<code class="fe ls lt lu lv b">CredentialRepo</code>端口的引用。我们需要这个引用，因为<code class="fe ls lt lu lv b">AuthServiceImpl</code>的实现需要与这些端口进行交互。</p><p id="9f5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还会发现在<code class="fe ls lt lu lv b">login</code>功能中有一个稍微有趣的交互，其中我们在执行一些分支逻辑的同时与<code class="fe ls lt lu lv b">TokenRepo</code>和<code class="fe ls lt lu lv b">CredentialRepo</code>对话。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9b4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于测试部分，我们只测试<code class="fe ls lt lu lv b">login</code>的功能，因为其他功能都很琐碎。我们使用模拟作为<code class="fe ls lt lu lv b">TokenRepo</code>和<code class="fe ls lt lu lv b">CredentialRepo</code>的双重测试。这些模拟允许我们模拟来自这些端口的各种响应，我们可以用它来验证登录功能。模拟是使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/asomers/mockall" rel="noopener ugc nofollow" target="_blank">mockall</a></code>库生成的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="1389" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">Rust中的适配器实现</h2><p id="e294" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">适配器在三个独立的文件中实现:<code class="fe ls lt lu lv b">auth/redis_token_repo.rs</code>、<code class="fe ls lt lu lv b">auth/postgres_credential_repo.rs</code>和<code class="fe ls lt lu lv b">auth/rest_auth_controller</code>。让我们一个一个的来看看。</p><p id="7d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">RedisTokenRepo</code>实现了<code class="fe ls lt lu lv b">TokenRepo</code> <code class="fe ls lt lu lv b">trait</code>。它包含一个Redis客户端库的引用，用于与Redis交互。为了进行测试，我们用真实的东西进行测试:运行在本地主机上的Redis实例。我们通过docker提供了一个Redis实例，以便于设置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，<code class="fe ls lt lu lv b">PostgresCredentialRepo</code>实现了<code class="fe ls lt lu lv b">CredentialRepo</code> <code class="fe ls lt lu lv b">trait</code>，并保存了对<code class="fe ls lt lu lv b">sqlx</code>提供的PostgreSQL连接池的引用。真正的PostgreSQL数据库也通过Docker进行测试。在每次测试运行时，我们都会重新创建一个专门针对该测试的数据库，以确保测试隔离。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a459" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"> RestAuthController</code>适配器与其他适配器略有不同。这个适配器驱动与域的交互，而其他适配器由域驱动。这个适配器将<code class="fe ls lt lu lv b">actix-web</code>连接到我们的域。实现可以在<code class="fe ls lt lu lv b">auth/rest_auth_controller.rs</code>中找到。对于测试，我们使用<code class="fe ls lt lu lv b">actix-web</code>提供的测试功能。我们想要测试的主要内容是给定的HTTP请求是否会正确触发端口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="c2ab" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">应用</h2><p id="952e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">最后，我们在上面定义的组件在<code class="fe ls lt lu lv b">main.rs</code>中组装。如您所见，它设置了到PostgreSQL和Redis的连接。然后，它创建应用程序中使用的实际组件，并将它们组装在一起。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9414" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将PostgreSQL和Redis分离到它自己的文件中，因为它有自己的初始化逻辑。这只是为了更好的可读性。如上所述，这两个组件引用自<code class="fe ls lt lu lv b">main.rs</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="be94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，我们也有这个级别的集成测试。也就是说，运行实际的应用程序并验证功能是否正确。然而，这超出了本文的范围。如果你想了解更多，一个很好的起点是<a class="ae kv" href="https://doc.rust-lang.org/rust-by-example/testing/integration_testing.html" rel="noopener ugc nofollow" target="_blank">锈博士们自己</a>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a389" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="72dd" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在本文中，我们看到了一个Rust项目结构，它有助于测试性。总体思路是用端口和适配器模式构建项目，对端口使用<code class="fe ls lt lu lv b">trait</code> s，对组件的依赖项使用test double，这样每个组件都可以被独立测试。</p><p id="417d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文中项目的完整源代码上传在<a class="ae kv" href="https://github.com/eckyputrady/testable-rust-web-project" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p></div></div>    
</body>
</html>