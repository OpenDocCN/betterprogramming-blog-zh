# 幸存的 RxSwift

> 原文：<https://betterprogramming.pub/surviving-rxswift-d6bfe562fb22>

## 最佳实践以及如何理解 Swift 中的反应式编程

![](img/f76ffe3dac6fb7e98aa8f919f9d8a023.png)

来自[爆裂](https://burst.shopify.com/laptop?utm_campaign=photo_credit&amp;utm_content=Browse+Free+HD+Images+of+Shocked+Bitcoin+Investor+On+Laptop&amp;utm_medium=referral&amp;utm_source=credit)的[莎拉·普弗卢格](https://burst.shopify.com/@sarahpflugphoto?utm_campaign=photo_credit&amp;utm_content=Browse+Free+HD+Images+of+Shocked+Bitcoin+Investor+On+Laptop&amp;utm_medium=referral&amp;utm_source=credit)的照片

在我开始之前，我需要提到这些是我个人用来最大限度地利用 RxSwift 并避免许多常见陷阱的一组最佳实践。它们绝不是一套适用于所有人的硬性规定，但我鼓励你去尝试一下。

# 为什么要用 Rx？

如果这么多人纠结 Rx，那到底为什么还要用？这是一个完全合理的问题。

在我们的职业中，有很多方法可以解决问题，Rx 也不例外。Rx 有一个陡峭的学习曲线，通常不清楚解决问题的一种方法是否比另一种更好。弄清楚其中的微妙之处需要时间，但是当你做到的时候是非常值得的。

我使用 Rx 的原因在于它最大的优势:能够从许多来源获取输入，驯服组合它们所需的通常复杂的逻辑，并留给您随时更新输入的输出。

这意味着，如果你遵循 SRP 之类的原则，你通常不需要对单个的、较低层次的组件进行 Rx。然而，它的力量在更高层次上变得非常明显。

记住这一点，让我们开始吧。

# 谨慎使用

我工作过的、听到人们抱怨的最有问题的 Rx 代码库是那些使*每个部分*都反应的代码库。你用的 Rx 越多，你的堆栈痕迹就越大越可怕。穿过一个长的反应链是很难的，操作者只能帮你做到这一步。

正如我前面提到的，我的解决方案是*仅*在更高层次的组件中使用 Rx，比如视图模型和视图控制器。

但是…我们如何让所有这些非 Rx 的东西在 Rx 中工作呢？

# 在 Rx 中包装组件

我们可以构建组件，比如 API 层，使用更广泛理解的范例，比如闭包，来异步交付东西。例如:

为了让 Rx 很好地工作，我们只需要几行代码:

有了它，我们的`APIClient`现在可以轻松用于 Rx 链。那么这样做的好处是什么呢？

调试现在容易多了，我们可以在非 Rx 代码中设置断点，并且在没有 Rx 添加到堆栈跟踪中的所有额外噪声的情况下单步执行。我们也可以使用标准的 XCTest 框架编写测试。最后，我们有了一个更加可移植的组件——现在没有什么可以阻止我们在其他可能不使用 Rx 的应用程序中使用相同的 API 层。

# 你不需要大多数特质

RxSwift 提供了广泛的[特质](https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md)。特征是标准`Observable`的包装，提供额外的语义/行为。这听起来可能很棒——毕竟我们想利用 Swifts 的类型系统，对吗？对于上面的 API 层例子，使用`Single`而不是`Observable`的代码是很常见的。

这些不同特征的问题是它们并不总是很好地组合在一起。有许多自定义扩展可以帮助它们之间的转换。只要坚持使用标准的`Observable`，你就可以避免跳过所有这些关卡。回避特质没有坏处。

眼尖的读者会发现标题中的“最多”。这个有一个例外！当你为你的视图公开要消费的值时，你 100%应该使用像`Driver`这样的 RxCocoa 特征，以及当你使用像`UIButton.rx.tap`这样的属性时遇到的`ControlEvent`或`ControlProperty`。这是因为这些特征是专门为与用户界面交互而设计的。它们将确保共享值，并且所有事情都发生在主线程上。

# 回避主题

在学习 Rx 时，你需要改变对数据的看法。其中最大的一个挑战是学习构造流，使得从流中输出的值是组合和/或转换在流中发送的值的结果。一种简单的思考流的方式就像一个映射函数`(A) -> B`或`(A, B) -> C`

通常，当这种转变还没有发生时，你会看到代码依赖于主题来弥补差距。主题是 Rx 中既是输入*又是输出*的对象。可以订阅它们，也可以向它们发送传入的值。

让我们看一个用于执行搜索的视图模型的例子:

就其本身而言，这看起来非常简单。收到一些文本，我们用它来进行搜索。由此，我们可以定义另外两个流，一个用于结果列表，一个用于显示计数的字符串。

然而，因为`searchText`既是输入*又是输出*，我们意外地在视图模型中引入了一个额外的输出。我们没有办法阻止其他东西订阅`searchText`并执行其他代码。如果这是您需要做的事情，那么您应该:

*   直接订阅底层输入源(即文本字段)；或者
*   为此行为创建另一个显式输出

由于没有在输入和输出之间建立明确的界限，调试值可能来自哪里变得更加困难。也很难推断系统的输入和输出实际上是什么。

现在，让我们看看如何重构同一个视图模型来删除主题的使用:

这里的变化非常微妙。我们要求输入通过构造函数传递。这种变化对输入和输出的内容提供了更细粒度的控制。我们现在有一个单一的起点来搜索与文本输入和搜索结果输出相关的错误。

> *值得注意的是，当然，还有其他方法可以移除/封装主题。*

同样，这也有例外，但我不打算在这里深入讨论…如果你真的觉得你需要使用主题，至少要确保你把它们封装起来，这样它们就不会公开暴露给任何随机代码与之交互。然而，我鼓励你尽可能地避免它们！

# 将 DisposeBags 限制为查看控制器

在我提到的转变发生之前，你会看到的另一个问题是`DisposeBag`在它们不属于的地方。一个`DisposeBag`是持有订阅的东西。订阅是你使用`subscribe`、`drive`或`bind`等功能时得到的。这些订阅也是你的应用程序副作用被包含的地方。

这些订阅应该仅限于您的视图控制器。像视图模型这样的其他组件不应该包含订阅，因为它们不应该包含副作用。

有趣的是，如上所述，这个问题经常出现在主语被误用的时候。经常看到订阅直接调用`onNext`这样的函数。这表明您的流输出没有被建模为它们输入的转换。

和其他的一样，这个也有罕见的例外。如果由于某种原因，流没有输出，您可能需要一个单独的私有订阅来确保流被启用。但是，与其他例外情况一样，尽最大努力避免这种情况。

# 摘要

所以快速总结一下:

*   将 Rx 限制到更高级别的组件，如视图模型和视图控制器。
*   构建不带 Rx 的低级组件，然后添加 Rx 包装扩展。
*   把自己限制在`Observable`和`Driver`。
*   写你的 Rx 尽量不带主语。
*   `DisposeBag` s 真的只属于视野控制者。

我强烈建议任何刚接触 Rx 或者正被它弄得不知所措的人，用这些技巧来简化你的使用。随着你对 Rx 越来越熟悉，你会开始意识到这些技巧何时、如何适用，以及何时不适用。