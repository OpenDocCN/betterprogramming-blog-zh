<html>
<head>
<title>What Is Dynamic Programming and Why Is It So Important?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是动态编程，为什么它如此重要？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-programming-series-1-what-is-it-and-why-is-it-so-important-64675b9f6049?source=collection_archive---------5-----------------------#2020-06-18">https://betterprogramming.pub/dynamic-programming-series-1-what-is-it-and-why-is-it-so-important-64675b9f6049?source=collection_archive---------5-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4809" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们深入研究动态编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98472b61b077fe81b37d958b45294e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AS9TLyHgxgSPWPQe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯里德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="4279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能在某个地方听说过动态编程这个术语，并想知道它是什么意思。在动态编程系列的第一篇文章中，我将试图解释它到底是什么以及为什么它如此重要。我肯定需要更多的练习，这就是为什么我开始这个系列，以便我们可以一起学习和掌握它！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c7b9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">那么什么是动态编程呢？</h1><p id="bd63" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">简单地说，动态编程是一种将问题分解成子问题，解决这些子问题<em class="mz">一次</em>，并存储其解决方案的技术。你可能会问，“为什么我们需要存储这些解决方案？”嗯，在计算机科学中，我们把速度快、占用内存少的东西定义为高效。通过存储这些解决方案，如果同样的问题再次出现，我们能够简单地查找它们。这节省了大量的计算时间，因为不需要重新计算解。</p><p id="0369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等等！效率由时间和空间复杂性组成，所以如果我们减少解决问题的时间只是为了增加使用的空间，这又有什么关系呢？这就是为什么理解这一点很重要，在动态编程中，我们最终希望实现的是一个显著更快的<em class="mz"> </em>计算时间，代价是使用空间的适度增加。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7eae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法</h1><p id="c3a4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">基本上有两种方法可以存储问题的解决方案:</p><ol class=""><li id="2253" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">记忆化(自上而下的方法)</li><li id="e146" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">制表(自下而上的方法)</li></ol><p id="1e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在自顶向下的方法中，一般的代码结构如下所示:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="8367" class="nt md it np b gy nu nv l nw nx">def top-down(n):<br/>if memo[n] is not initialized:<br/>    # the epsilon below represents some computation that you do which is stored in memo<br/>    # usually the computation will involve some recursive call that approaches the base case<br/>    memo[n] = ... <br/>return memo[n]</span></pre><p id="884b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这种方法涉及到通过追溯到基础案例来解决子问题，所以它被称为自顶向下的方法。当我们想要找到第n个问题的解决方案时，我们搜索第<em class="mz"> n-1个</em>、<em class="mz"> n-2个</em>问题的答案，以此类推，直到基础案例。</p><p id="d00d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在自下而上的方法中，情况正好相反。我们首先计算所有可能的基本情况的解决方案，然后从那里逐步得出我们想要的解决方案。制表方法的一般代码结构如下所示:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="726d" class="nt md it np b gy nu nv l nw nx">def bottom-up(n):<br/>    for i = 1 to i = n:<br/>        table[i] = ... # computing and storing the solution<br/>    return table[n] # simply looking up the solution and return it</span></pre><p id="7840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经知道了两种DP方法，您应该使用哪种方法呢？就像几乎任何事情一样，这要视情况而定。通常，如果不是所有子问题的解决方案都需要计算，您会希望使用自顶向下的方法。这将节省使用自底向上方法时所需的不必要的计算时间。相反，如果无论如何都需要计算所有子问题的解决方案，您应该使用自底向上的方法，因为它可以防止递归调用开销，而递归调用开销几乎总是会使自底向上的方法更快。</p><p id="227b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我相信您已经对动态编程有了足够的了解，可以在本系列的下一章解决我们的第一个问题。感谢您的阅读，在此之前！</p></div></div>    
</body>
</html>