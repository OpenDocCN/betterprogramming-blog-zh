<html>
<head>
<title>Using Swifts KeyPaths in Higher-Order Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在高阶函数中使用Swifts关键路径</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-swifts-keypaths-in-higher-order-functions-3f3eeb8cfd8e?source=collection_archive---------6-----------------------#2020-02-02">https://betterprogramming.pub/using-swifts-keypaths-in-higher-order-functions-3f3eeb8cfd8e?source=collection_archive---------6-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7289" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关键路径如何改进贴图、压缩贴图、平面贴图和过滤器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/93fd35a19a3bbff88f31e8d2e9c69302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SYPOK-kq7Da2g2QKfRRBfQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历山大·博古斯瓦夫斯卡在<a class="ae ky" href="https://unsplash.com/s/photos/path?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b7ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理像数组或集合这样的集合时，我们可以使用所谓的高阶函数，比如<code class="fe lv lw lx ly b">map</code>来转换集合中的每个元素，或者使用<code class="fe lv lw lx ly b">filter</code>来获得集合元素的子集。</p><p id="66b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高阶函数是接受或返回其他函数的函数。如果你对他们不熟悉，网站Use Your Loaf会给你一个很好的概述。</p><p id="b5be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨一种使用Swift关键路径的新方法。</p><p id="1688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将探索关键路径，看看它们是什么以及如何使用它们。稍后，我们将查看函数<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">compactMap</code>、<code class="fe lv lw lx ly b">flatMap</code>和<code class="fe lv lw lx ly b">filter</code>的新实现，它们使用关键路径，允许我们将高阶函数的功能与关键路径的方便使用结合起来。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5d5a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是关键路径？</h1><p id="7143" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">简而言之，KeyPath是一个函数，它通过使用特殊的符号来提供对类或结构的属性的访问。</p><p id="ed5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个简短的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">关键路径介绍。</p></figure><p id="c933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —这里，我们定义了一个名为<code class="fe lv lw lx ly b">User</code>的小型结构，它只有一个属性<code class="fe lv lw lx ly b">name</code>，并创建了一个名为<em class="nf"> Max </em>的新用户。</p><p id="221a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —访问属性<code class="fe lv lw lx ly b">name</code>的值的正常方式是使用<code class="fe lv lw lx ly b">.name</code>。</p><p id="b7d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —但是我们也可以使用KeyPath，它由一个反斜杠和我们想要访问的类型和属性名组成，例如<code class="fe lv lw lx ly b">\User.name</code>。</p><p id="2799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code>—我们现在可以通过使用这个关键路径来访问<code class="fe lv lw lx ly b">name</code>的值。由于编译器知道<code class="fe lv lw lx ly b">user</code>的类型是<code class="fe lv lw lx ly b">User</code>，我们可以使用更短的形式，省略结构或类的名称，例如，在本例中，用<code class="fe lv lw lx ly b">\.name</code>代替<code class="fe lv lw lx ly b">\User.name</code>。我们可以使用KeyPath来读取和写入一个值。</p><p id="f2ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经了解了什么是关键路径以及如何使用它，让我们看看如何将它们与高阶函数结合起来！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7d2b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在地图中使用关键路径</h1><p id="704f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于下面的例子，我们将使用一个<code class="fe lv lw lx ly b">User</code>对象的数组，但是我们将使用一个与上面略有不同的结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用KeyPaths演示map、compactMap、flatMap和filter的结构。</p></figure><p id="a492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —这一次，用户有了名字、昵称、他们正在关注的其他用户的列表，他可以在线也可以离线。这些属性涵盖了我们新方法的所有情况:一个用于<code class="fe lv lw lx ly b">compactMap</code>的可选字符串，一个用于<code class="fe lv lw lx ly b">flatMap</code>的数组，以及一个用于<code class="fe lv lw lx ly b">filter</code>的布尔值。</p><p id="b166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —我们创建两个示例用户的数组，<em class="nf"> Jeff </em>和<em class="nf"> Tom </em>。</p><p id="621d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经有了要操作的东西，让我们看看如何实现<code class="fe lv lw lx ly b">map</code>来使用关键路径:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现映射以使用关键路径。</p></figure><p id="3b04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —为了使我们的新<code class="fe lv lw lx ly b">map</code>与标准<code class="fe lv lw lx ly b">map</code>一样可用，我们将把它作为<code class="fe lv lw lx ly b">Sequence</code>的扩展添加进来。这个协议在元素列表上定义了各种方法，比如<code class="fe lv lw lx ly b">forEach</code>、<code class="fe lv lw lx ly b">prefix</code>，当然还有<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">compactMap</code>、<code class="fe lv lw lx ly b">flatMap</code>和<code class="fe lv lw lx ly b">filter</code>。</p><p id="c0f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中，它由数组、字典和集合实现，因此可用于这些类型的集合。</p><p id="5ee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —由于我们使用了两个泛型类型参数，函数签名一开始可能看起来有点混乱，但是如果我们仔细观察，就很容易理解了。</p><p id="f57e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Element</code>表示序列中元素的类型，也是KeyPath的根类型。另一个泛型类型参数<code class="fe lv lw lx ly b">T</code>表示<code class="fe lv lw lx ly b">map</code>将这些元素转换成的类型。</p><p id="ed7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想通过提取用户的名字将一个用户数组转换成一个字符串数组，<code class="fe lv lw lx ly b">Element</code>将会是<code class="fe lv lw lx ly b">User</code>，而<code class="fe lv lw lx ly b">T</code>将会是<code class="fe lv lw lx ly b">String</code>。参数<code class="fe lv lw lx ly b">keyPath</code>是访问<code class="fe lv lw lx ly b">Element</code>类型的类或结构中<code class="fe lv lw lx ly b">T</code>类型的属性的关键路径，在本例中为<code class="fe lv lw lx ly b">\User.name</code>。</p><p id="817f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —我们现在可以通过使用标准的<code class="fe lv lw lx ly b">map</code>并将给定的关键路径应用到集合的每个元素来实现这个新版本的<code class="fe lv lw lx ly b">map</code>。</p><p id="eec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —为了使用新的<code class="fe lv lw lx ly b">map</code>，我们现在可以向它传递一个关键路径。这里，我们将用户列表转换为包含他们姓名的字符串列表。与我们使用标准<code class="fe lv lw lx ly b">map</code>的方式相比，我们的新版本看起来更干净，更好读。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4e8f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在compactMap和flatMap中使用关键路径</h1><p id="e3f6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">协议<code class="fe lv lw lx ly b">Sequence</code>定义了另外两种<code class="fe lv lw lx ly b">map</code>:<code class="fe lv lw lx ly b">compactMap</code>和<code class="fe lv lw lx ly b">flatMap</code>。</p><p id="bfa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都将一个元素序列转换为一个新的元素序列，但是第一个元素序列会丢弃转换产生的任何nil值，第二个元素序列会展平嵌套数组。</p><p id="892a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多信息，你可以在SwiftLee 上阅读<a class="ae ky" href="https://www.avanderlee.com/swift/compactmap-flatmap-differences-explained/" rel="noopener ugc nofollow" target="_blank">这个比较。</a></p><p id="58ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们还可以重新创建<code class="fe lv lw lx ly b">compactMap</code>和<code class="fe lv lw lx ly b">flatMap</code>来使用关键路径:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="79a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —同样，我们扩展了协议<code class="fe lv lw lx ly b">Sequence</code>，使它们可以用于数组、字典和集合。</p><p id="c635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code>—<code class="fe lv lw lx ly b">compactMap</code>的签名看起来与<code class="fe lv lw lx ly b">map</code>的前一个签名几乎相同，唯一的区别是参数<code class="fe lv lw lx ly b">keyPath</code>的泛型值类型。它不再是<code class="fe lv lw lx ly b">T</code>而是<code class="fe lv lw lx ly b">T?</code>，因此使用给定的KeyPath可以得到零值。</p><p id="8c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —就像<code class="fe lv lw lx ly b">map</code>一样，我们使用标准的<code class="fe lv lw lx ly b">compactMap</code>并传递关键路径。从KeyPath接收的任何nil值将被<code class="fe lv lw lx ly b">compactMap</code>删除，产生一个只包含非零值的新数组。</p><p id="072f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —我们可以用类似的方式实现<code class="fe lv lw lx ly b">flatMap</code>。同样，签名的不同之处在于给定的KeyPath的值类型，这次是<code class="fe lv lw lx ly b">[T]</code>。这允许我们访问结构或类中的数组。</p><p id="74c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 5</code> —与我们实现<code class="fe lv lw lx ly b">map</code>和<code class="fe lv lw lx ly b">compactMap</code>的方式相同，我们可以使用标准的<code class="fe lv lw lx ly b">flatMap</code>作为基础，并在闭包内应用关键路径。</p><p id="af3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 6</code> —当使用KeyPaths和标准函数比较这两个版本时，它看起来又好了很多。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="edcb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用<code class="fe lv lw lx ly b">filter</code>中的关键路径</h1><p id="ecd0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后，让我们看看如何让<code class="fe lv lw lx ly b">filter</code>与关键路径一起工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="15a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —因为<code class="fe lv lw lx ly b">filter</code>期望一个返回布尔值的函数，我们需要约束KeyPath只返回<code class="fe lv lw lx ly b">true</code>或<code class="fe lv lw lx ly b">false</code>。因此，我们不需要前面例子中需要的额外的泛型类型参数<code class="fe lv lw lx ly b">T</code>。</p><p id="09b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —如上所述，我们从标准<code class="fe lv lw lx ly b">filter</code>开始，使用给定的关键路径来确定当前元素是否应该包含在新序列中。</p><p id="2eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —这允许我们将一个布尔值的关键路径传递给<code class="fe lv lw lx ly b">filter</code>，从而消除了通过<code class="fe lv lw lx ly b">$0</code>访问当前元素的需要。</p><p id="6641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —但是当将多个高阶函数链接在一起时，最大的区别是明显的。例如，通过使用我们的新版本，<code class="fe lv lw lx ly b">filter</code>、<code class="fe lv lw lx ly b">flatMap</code>和<code class="fe lv lw lx ly b">map</code>的组合来获取当前在线用户所关注的所有用户的名称，这是简短、易于理解和易于书写的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6f15" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="4be6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">关键路径是Swift中访问结构或类属性的一个很酷的特性。</p><p id="240a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过编写我们自己的<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">compactMap</code>、<code class="fe lv lw lx ly b">flatMap</code>和<code class="fe lv lw lx ly b">filter</code>，我们可以将键路径的易用性与高阶函数的强大功能结合起来，以减少代码中的噪声，并使其看起来更好。</p><p id="32ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是当组合多个高阶函数时，例如<code class="fe lv lw lx ly b">filter</code>，然后是<code class="fe lv lw lx ly b">flatMap</code>，最后是最后一个例子中的<code class="fe lv lw lx ly b">map</code>，关键路径可以大大提高代码的可读性。</p><p id="c1ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这种方法，序列上有更多的高阶函数可以使用关键路径重新创建，例如<code class="fe lv lw lx ly b">first(where:)</code>、<code class="fe lv lw lx ly b">drop(while:)</code>、<code class="fe lv lw lx ly b">contains(where:)</code>或<code class="fe lv lw lx ly b">sorted(by:)</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ea5d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">资源</h1><div class="ng nh gp gr ni nj"><a href="https://useyourloaf.com/blog/swift-guide-to-map-filter-reduce/" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">地图过滤器简化快速指南</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用map、filter或reduce对Swift集合类型(如数组或字典)进行操作可能需要…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">useyourloaf.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://www.avanderlee.com/swift/compactmap-flatmap-differences-explained/" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">CompactMap vs flatMap:解释差异- SwiftLee</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">CompactMap和flatMap，有什么区别，分别在什么时候使用？Swift 4.1引入了这一新方法，并提供了…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">www.avanderlee.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://developer.apple.com/documentation/swift/swift_standard_library/collections/sequence_and_collection_protocols" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">序列和收集方案</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">编写适用于任何集合的通用代码，或者构建您自己的集合类型。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">developer.apple.com</p></div></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://developer.apple.com/documentation/swift/keypath" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">关键路径</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">从具体的根类型到任何结果值类型的部分类型擦除的键路径。一个类型擦除的键路径，来自…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">developer.apple.com</p></div></div></div></a></div></div></div>    
</body>
</html>