<html>
<head>
<title>How to Add Authentication to Your Fastify REST API Using Auth0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Auth0向Fastify REST API添加身份验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-add-authentication-to-your-fastify-rest-api-using-auth0-cddc7eacc90?source=collection_archive---------6-----------------------#2020-01-31">https://betterprogramming.pub/how-to-add-authentication-to-your-fastify-rest-api-using-auth0-cddc7eacc90?source=collection_archive---------6-----------------------#2020-01-31</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="dd6e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用Node.js、Fastify和Auth0通过OAuth 2.0保护您的REST API</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/24090011997488b57c2a9f4ce402b823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGnPo3j04Mx2ZtzVjEfdrQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">克里斯·帕纳斯在<a class="ae kz" href="https://unsplash.com/s/photos/security?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8cd0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我身边的项目<a class="ae kz" href="https://itnext.io/mini-video-encoder-implementation-part-1-1fce5fb081c1" rel="noopener ugc nofollow" target="_blank">迷你视频编码器</a>的核心部分是工作流引擎。工作流引擎是使用Node.js、<a class="ae kz" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> Fastify </a>和MongoDB实现的REST API。我没有保护好工作流引擎的API。目前，客户可以匿名拨打电话。你会同意我的观点，每个在线API都需要安全性。所以我想在REST API中加入身份验证。</p><p id="659f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">向Fastify REST API添加身份验证有很多选择。如果可能的话，我更喜欢使用基于开放标准的方法。因此，我将使用OAuth 2.0来保护API。OAuth 2.0是用于授权的行业标准协议。如果您打算将OAuth 2.0用于您的API，您必须安装一个OAuth 2.0提供程序。我将使用<a class="ae kz" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>，这是一个提供认证和授权服务的平台。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj lw"><img src="../Images/234ecafa2e19523ecc4e805d1c0c8fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZs_p9GOjxNLKGucNxaerA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用Auth0的OAuth 2.0身份验证</p></figure><p id="1c1e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于身份验证，调用API必须遵循以下步骤:</p><ol class=""><li id="2c5e" class="lx ly iu lc b ld le lg lh lj lz ln ma lr mb lv mc md me mf bi translated">在工作流客户端能够访问工作流引擎的API之前，它必须具有访问令牌。如果Auth0对工作流客户端进行身份验证，它将生成并返回一个访问令牌。</li><li id="20e2" class="lx ly iu lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">工作流客户端调用工作流引擎API并传递访问令牌。工作流客户端将访问令牌添加到HTTP授权头中。</li><li id="f194" class="lx ly iu lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">工作流引擎验证所呈现的访问令牌。如果验证正确，它将执行请求的API方法。工作流引擎将结果返回给工作流客户端。</li></ol><p id="5290" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">OAuth 2.0支持几种不同的方法来检索访问令牌。这些方式中的每一种——或者说<a class="ae kz" href="https://auth0.com/docs/flows" rel="noopener ugc nofollow" target="_blank">流</a>——都有一个特定的用例。OAuth 2.0从示例中调用流，即<a class="ae kz" href="https://auth0.com/docs/flows/concepts/client-credentials" rel="noopener ugc nofollow" target="_blank">客户端凭证流</a>。工作流客户端使用客户端ID和客户端密码来请求访问令牌。</p><p id="f58d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于接下来的请求，工作流客户端不必请求访问令牌。它可以重用现有的访问令牌。对于访问令牌，我们将使用JSON Web令牌(JWT)。JWT是创建基于JSON的访问令牌的标准方法。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="0715" class="ms mt iu bd mu mv mw mx my mz na nb nc ka nd kb ne kd nf ke ng kg nh kh ni nj bi translated">在工作流引擎中使用Auth0实现OAuth 2.0</h1><p id="e6ca" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">为了能够在工作流引擎中添加身份验证，我们需要以下内容:</p><ul class=""><li id="270c" class="lx ly iu lc b ld le lg lh lj lz ln ma lr mb lv np md me mf bi translated">一个Auth0帐户——他们有一个免费计划，最多可容纳7000名活跃用户</li><li id="12d6" class="lx ly iu lc b ld mg lg mh lj mi ln mj lr mk lv np md me mf bi translated">具有Auth0的已注册应用程序</li><li id="0b34" class="lx ly iu lc b ld mg lg mh lj mi ln mj lr mk lv np md me mf bi translated">npm包<a class="ae kz" href="https://github.com/nearform/fastify-auth0-verify" rel="noopener ugc nofollow" target="_blank"> fastify-auth0-verify </a>，一个用于验证auth0发布的JSON Web令牌的fastify插件。</li></ul><h2 id="fc46" class="nq mt iu bd mu nr ns dn my nt nu dp nc lj nv nw ne ln nx ny ng lr nz oa ni ob bi translated">创建Auth0帐户</h2><p id="ff5d" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">要使用Auth0，您必须创建一个帐户和应用程序，以便将身份验证集成到API中。在这里，你可以注册一个免费账户。如果您已经添加了帐户，您可以通过点击“+创建应用程序”来添加应用程序</p><p id="041e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，您必须输入您的应用程序的名称。然后，选择“机器对机器应用程序”作为应用程序类型。应用程序类型定义了您可以使用哪个流来检索访问令牌。通过选择“机器对机器”,我们可以使用客户端凭据流。</p><h2 id="cdb9" class="nq mt iu bd mu nr ns dn my nt nu dp nc lj nv nw ne ln nx ny ng lr nz oa ni ob bi translated">检索域和客户端机密</h2><p id="3320" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">您需要域和客户端密码来配置<code class="fe oc od oe of b"><a class="ae kz" href="https://github.com/nearform/fastify-auth0-verify" rel="noopener ugc nofollow" target="_blank">fastify-auth0-verify</a></code>插件。您可以在应用程序的设置选项卡上找到域和客户端密码。见下文。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/7c28898988c44995c364b49b7ef99e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ZuJI2RETzJieGHOOGQjVg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从Auth0应用程序页面检索域和客户端机密</p></figure><h2 id="7b55" class="nq mt iu bd mu nr ns dn my nt nu dp nc lj nv nw ne ln nx ny ng lr nz oa ni ob bi translated">安装和配置fastify-auth0-verify</h2><p id="c26c" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">在工作流引擎内部，我使用标准的npm命令安装了<code class="fe oc od oe of b">fastify-auth0-verify</code>:</p><p id="777f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe oc od oe of b">npm i fastify-auth0-verify</code></p><p id="f201" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后在<code class="fe oc od oe of b">server.js</code>中，添加以下内容来注册插件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">注册fastify-auth0-verify</p></figure><h2 id="cbf3" class="nq mt iu bd mu nr ns dn my nt nu dp nc lj nv nw ne ln nx ny ng lr nz oa ni ob bi translated">不要将敏感信息放在源代码控制中</h2><p id="0ca4" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">域和秘密是敏感信息，不应该放在源代码控制中。相反，您应该从环境中检索这些信息。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">创建从环境中读取信息的配置对象</p></figure><p id="41a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我更喜欢拥有一个包含所有设置的配置对象，而不是在我的源代码中到处引用<code class="fe oc od oe of b">process.env.*</code>。</p><p id="b2bc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用中央配置对象使得管理设置更容易维护。configuration对象还提供了应用程序所有配置设置的概述。</p><h2 id="842b" class="nq mt iu bd mu nr ns dn my nt nu dp nc lj nv nw ne ln nx ny ng lr nz oa ni ob bi translated">将设置放入您的环境中</h2><p id="f19e" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">在环境变量中配置大量设置会变得很麻烦。库<a class="ae kz" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>通过从一个<code class="fe oc od oe of b">.env</code>文件中读取环境变量使它变得更容易。该库将文件中的变量存储在<code class="fe oc od oe of b">process.env</code>中。</p><p id="8234" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">安装完<code class="fe oc od oe of b">dotenv</code> npm模块后，下面的命令从<code class="fe oc od oe of b">.env</code>文件中读取环境变量，并将它们存储在<code class="fe oc od oe of b">process.env</code>中。确保在Node.js应用程序中尽快执行这个命令。</p><pre class="kk kl km kn gu oj of ok ol aw om bi"><span id="f5d0" class="nq mt iu of b gz on oo l op oq">require('dotenv').config()</span></pre></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="113f" class="ms mt iu bd mu mv mw mx my mz na nb nc ka nd kb ne kd nf ke ng kg nh kh ni nj bi translated">使用Postman测试认证</h1><p id="bb5d" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">注册插件<code class="fe oc od oe of b">fastify-auth0-verify</code>并填充域和密码后，我们就可以测试认证了。我们将使用<a class="ae kz" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>进行测试，而不是使用工作流客户端。</p><h2 id="349f" class="nq mt iu bd mu nr ns dn my nt nu dp nc lj nv nw ne ln nx ny ng lr nz oa ni ob bi translated">发送未经授权的请求</h2><p id="e264" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">首先，为了验证健康端点是安全的，我对健康端点执行一个HTTP GET请求(<code class="fe oc od oe of b"><a class="ae kz" href="http://localhost:8181/api/health" rel="noopener ugc nofollow" target="_blank">http://localhost:8181/api/health</a>)</code>)。单击Send后，工作流引擎会响应一个HTTP响应:<code class="fe oc od oe of b">401 Unauthorized</code>。401表示API无法访问。所以我们的认证成功了。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj or"><img src="../Images/6b37c0d8fd9064f2caf295c464e80a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqkqVUhj0Fgwt1-U09XmeQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">针对工作流引擎执行未经身份验证的请求</p></figure><h2 id="25cc" class="nq mt iu bd mu nr ns dn my nt nu dp nc lj nv nw ne ln nx ny ng lr nz oa ni ob bi translated">发送授权请求</h2><p id="3aac" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">要执行授权请求，我们首先必须从Auth0请求一个访问令牌。</p><p id="df26" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们通过向Auth0子域的令牌端点发送HTTP POST来请求访问令牌。您的请求体应该包含一个带有<code class="fe oc od oe of b">client_id</code>、<code class="fe oc od oe of b">client_secret</code>、<code class="fe oc od oe of b">audience</code>和<code class="fe oc od oe of b">grant_type</code>的JSON对象。您可以在应用程序页面的设置选项卡上找到此信息。通过<code class="fe oc od oe of b">"grant_type": "client credentials”</code>，我们向Auth0声明我们想要使用客户端凭证流。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj os"><img src="../Images/54ea3a20da4f0f9aee2d4d51c7bac315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVJ_vXI3cJalBnSFp6t3uw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从Auth0请求访问令牌</p></figure><p id="039f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果输入了所有信息，Auth0将返回一个JSON对象作为响应，其中包含访问令牌。这是我们需要能够调用工作流引擎的API的访问令牌。复制不带双引号的<code class="fe oc od oe of b">access_token</code>的值。</p><p id="8258" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们回到Postman中最初的请求。转到工作流引擎的健康端点，并使用访问令牌。您需要点击Postman中的授权选项卡，并选择<code class="fe oc od oe of b">Bearer Token</code>作为类型。将您从上一个请求中获得的访问令牌粘贴到令牌字段中。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/d8079e02bdf35f6d19ffb87da1412a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5bbmAsaoXUFbBWtMX8HtA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用访问令牌来执行认证请求</p></figure><p id="d3fc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您单击Send时，您将看到您可以调用健康端点。健康API返回一个HTTP状态<code class="fe oc od oe of b">200 OK</code>。响应的主体包含当前的日期和时间，表明API正在工作。</p><p id="ba6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您一直坚持下去，您会同意在使用外部身份验证提供者(如Auth0)时，向API添加身份验证是很容易的。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="95bd" class="ms mt iu bd mu mv mw mx my mz na nb nc ka nd kb ne kd nf ke ng kg nh kh ni nj bi translated">我不想使用外部身份验证提供商！</h1><p id="ae95" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">并不是每个人都可以或者想要使用像Auth0这样的外部认证提供者。相反，他们希望使用本地身份认证提供商。</p><p id="e6a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">幸运的是，还有其他几个选择，比如<a class="ae kz" href="https://www.npmjs.com/package/oidc-provider" rel="noopener ugc nofollow" target="_blank"> oidc-provider </a>。oidc-provider是一个兼容OAuth 2.0的Node.js授权服务器。关于安装和配置，我建议您参考<a class="ae kz" href="https://github.com/panva/node-oidc-provider#get-started" rel="noopener ugc nofollow" target="_blank">文档页面</a>。因为我们使用开放标准，所以用这个授权服务器替换Auth0很简单。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="5962" class="ms mt iu bd mu mv mw mx my mz na nb nc ka nd kb ne kd nf ke ng kg nh kh ni nj bi translated">结论</h1><p id="7d2d" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">感谢您的阅读。我希望这有助于您在自己的Fastify REST API中添加身份验证。</p></div></div>    
</body>
</html>