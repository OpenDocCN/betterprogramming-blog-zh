<html>
<head>
<title>Building a Computer Algebra System in Go, Part 1: Multivariate Expressions and Differentiation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建计算机代数系统，第1部分:多元表达式和微分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-computer-algebra-system-in-go-part-1-multivariate-expressions-and-differentiation-291d948aa0e4?source=collection_archive---------6-----------------------#2022-08-05">https://betterprogramming.pub/building-a-computer-algebra-system-in-go-part-1-multivariate-expressions-and-differentiation-291d948aa0e4?source=collection_archive---------6-----------------------#2022-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e38" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索计算机代数系统的内部运作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b8be802b8605eefa0a99799456c31ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*moawcQlRFs9jXFpz"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的<a class="ae kv" href="https://unsplash.com/@surface?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">面</a>拍下</a></p></figure><p id="edbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">刚开始编程的时候，觉得纸笔数学和计算机数学的距离很大。</p><p id="3a5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论导数在纸上计算有多简单，我在计算机上最多只能近似计算。当我遇到像Mathematica和Maple这样专门从事符号计算的语言时，这一切都改变了。从那以后，我就迷上了不同编程语言中符号功能的实现。</p><p id="e2b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是我探索计算机代数系统内部工作的系列文章的第一篇。</p><p id="e9c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的探索将通过在Go中实现自己的计算机代数系统来完成。有时，我还会深入研究我的系统的一些理论方面。</p><p id="2108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将做到以下几点:</p><ul class=""><li id="01d0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">讨论语法和语义之间的差异，</li><li id="0d92" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">实现可以表示多元代数表达式的抽象语法树，</li><li id="897b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建一个可以区分这些表达式的函数，</li><li id="f0e3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">构造一个评估函数，该函数采用表达式的语法表示并将其转换成其语义对应物，</li><li id="1b41" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">讨论这个评价函数的一些数学性质。</li></ul><p id="186a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些文章将只包含要点来表达我的观点，但完整的代码可以在这个<a class="ae kv" href="https://github.com/victorbrun/gosymbol" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。此外，这种努力基本上是我充实了一种用于代数表达式的基于语法树的特定领域语言，这是我已经写了一篇初学者友好文章的内容。因此，如果你以前从未听说过<a class="ae kv" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a> (ASTs)或<a class="ae kv" href="https://en.wikipedia.org/wiki/Domain-specific_language" rel="noopener ugc nofollow" target="_blank">特定领域语言</a>(DSL)，我强烈建议你在继续之前阅读那篇文章。</p><h1 id="e8a7" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">语法与语义</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/ff356f16f2d8c1418531eb73cb1c4213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFS28dMnvAPybt6nOUyknQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:语法和语义域的可视化，以及Eval函数是如何在它们之间映射的。</p></figure><p id="7918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">符号计算的世界是建立在语法和语义的概念之上的，但是它们是什么呢？让我们以一句简单的“Hello World！”程序为例。在没有进一步通知的情况下，你可以用几种语言来实现它。这种知道特定语言中的字母如何组合在一起创建程序的能力是一个语法问题。你记得足够多的一些编程语言可能非常不同的语法，以至于终端吐出“Hello World！”。语法决定你是否使用花括号，是否需要一个<code class="fe mz na nb nc b">main</code>函数，等等。</p><p id="17a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，我们不同程序的语义基本上是相同的。这是因为语义解决了我们程序的含义，在我们的例子中是产生一个“Hello World！”在终点站。更具体地说，计算机程序的语义是计算机在执行它时遵循的指令，对于我们的简单程序来说，不管语言是什么，语义都是非常相似的。如果你对计算机程序的语义感兴趣，可以在这里阅读更多<a class="ae kv" href="https://en.wikipedia.org/wiki/Semantics_(computer_science)" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="fea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从图1中可以看出，语法和语义是两件不同的事情，这是我们将从中受益匪浅的事情。因此，需要在它们之间进行转换，这可以通过同一图中的<code class="fe mz na nb nc b">Eval</code>功能来实现。在我们的“你好世界！”例如，编译器或解释器做这种翻译。</p><p id="40f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们不是在构建一个编译器或解释器，我们是在构建一个计算机代数系统。因此，我们正在区分代数表达式的语法和语义表示。</p><h1 id="a51a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">语法领域</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/9c8f2f81f2b7faf3e213ae1a0a3f1417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*5wq2bufZk-dMmCAB-nYlFA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:代数表达式4+6x表示为抽象语法树。</p></figure><p id="9f20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了语法、语义及其区别的概念，我们开始开发一种从语法上表示代数表达式的方法。代数表达式是非常递归的结构，如果你不相信我；尝试将<code class="fe mz na nb nc b">4 + 6x</code>中的<code class="fe mz na nb nc b">x</code>替换为<code class="fe mz na nb nc b">4 + 6x</code>，然后对结果表达式做同样的操作，然后一次又一次，以此类推。如果您没有收集任何术语，您将为每个替换添加另一层，而<a class="ae kv" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a> (ASTs)非常适合对这种行为进行建模。</p><p id="887f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，ast是基于树的数据结构。从图2中，我们认识到节点由运算符组成，例如<code class="fe mz na nb nc b">+</code>、<code class="fe mz na nb nc b">*</code>，或者由常量和变量组成。操作符节点也有代表其参数的子节点，而常量和变量节点是AST中的叶节点，因为它们没有子节点。从递归的角度来看，这意味着表示常量和变量的节点是基本情况。</p><p id="160c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在Go中建模这种树形结构，我们将使用<a class="ae kv" href="https://go101.org/article/type-embedding.html" rel="noopener ugc nofollow" target="_blank">类型嵌入</a>，简单来说，这可以看作是Go的继承。为了做到这一点，我们利用了这样一个事实，即树中的每个节点，无论是独立的还是相连的，无论是运算符、常数还是变量，都可以被视为一个代数表达式。因此，我们定义了接口<code class="fe mz na nb nc b">Expr</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="75fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">利用这种相似性，我们可以将不同的节点:<code class="fe mz na nb nc b">constant</code>、<code class="fe mz na nb nc b">variable</code>、<code class="fe mz na nb nc b">add</code>、<code class="fe mz na nb nc b">mul</code>、<code class="fe mz na nb nc b">pow</code>定义为它们自己的数据类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c75f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有几件有趣的事情值得指出。首先，所有节点类型定义中的未命名字段类型<code class="fe mz na nb nc b">Expr</code>就是我所说的类型嵌入。这意味着该类型实现了<code class="fe mz na nb nc b">Expr</code>-接口，并且由于<code class="fe mz na nb nc b">add</code>、<code class="fe mz na nb nc b">mul</code>和<code class="fe mz na nb nc b">pow</code>的参数属于类型<code class="fe mz na nb nc b">Expr</code>，因此可以用多种方式组合这些操作来创建树结构。其次，<code class="fe mz na nb nc b">add</code>和<code class="fe mz na nb nc b">mul</code>都有切片作为操作数，意味着它们是n元运算符，需要实现它们的操作数。这是可能的，因为乘法和加法是相联的。</p><p id="7a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，为了使我们的生活更容易，我们为不同的知名企业创建了一些简单的工厂。请注意，上述五种节点类型也足以实现求反、减法和除法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="1b64" class="ng mh iq bd mi nh ni dn mm nj nk dp mq lf nl nm ms lj nn no mu ln np nq mw nr bi translated">分化:语法树的转换</h2><p id="aacb" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">在我们转到语义之前，我们将看看语法域内部的操作，特别是微分。如果你要寻找一个没有语法表示的函数的导数，例如一个lambda函数，最好的方法是一个数值近似值。在我们的例子中，我们能够象征性地操作我们的表达式，就像你可以用笔和纸一样，来得到导数的代数表达式。</p><p id="9f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像在学习如何用笔和纸进行区分的时候，我们需要纠正我们的区分规则，但也仅此而已。通过为每个运算符类型定义微分规则，例如，<code class="fe mz na nb nc b">mul</code>成为乘积规则，然后递归调用每个操作数上的微分函数，我们可以很容易地使用我们定义的运算符来区分每个可能的表达式。</p><p id="bb03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在实践中实现这一点，我们需要重新定义<code class="fe mz na nb nc b">Expr</code>来包含<code class="fe mz na nb nc b">D</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这迫使我们为每个节点类型定义一个<code class="fe mz na nb nc b">D</code>-函数，即<code class="fe mz na nb nc b">const</code>、<code class="fe mz na nb nc b">variable</code>、<code class="fe mz na nb nc b">add</code>、<code class="fe mz na nb nc b">mul</code>和<code class="fe mz na nb nc b">pow</code>各一个，它捕捉了每个特定类型的区分规则。在代码中，区分规则如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="df71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种将语法树转换成用笔和纸就能轻松完成的东西的概念首先让我对这个领域感到兴奋。因此，在本系列的稍后部分，我将花时间添加更多的符号变换，如拉普拉斯和傅立叶变换。</p><h1 id="2146" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">语义领域</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/d0ccc3e2523f66ccc14b5a3ef1f019e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VYTY1Ey0gUiwMGDBkoHgqQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:语义域如何包含几个不同的依赖于上下文的子域的可视化。</p></figure><p id="10c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对语法领域有了一些了解后，我们可以转到语义领域。如上所述，语义是我们抽象语法表示的底层含义，那么一个代数表达式的底层含义是什么呢？代数表达式由运算符、符号和常数组成，在我们的例子中，符号由<code class="fe mz na nb nc b">variable</code>表示。</p><p id="9a2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用笔和纸时，这些变量可以用从整数到向量等任何东西来代替。，当在表达式中执行所有不同的运算时，我们只剩下一些量，从整数到向量，等等。对我来说，接受一个输入(变量的值)并产生一些输出量听起来很像一个函数。</p><p id="9c10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，代数表达式的语义或潜在含义可以被认为是将某种类型的输入映射到某种类型的输出的函数。图3展示了这一点，其中的<code class="fe mz na nb nc b">Eval</code>函数将语法域带到了语义域。但是在同一个图中，也可以看出语义域是由几个依赖于上下文的子域组成的。</p><p id="e1ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一些上下文中，表达式的语义对应部分可以将整数作为输入和输出整数，而在一些其他上下文中，相同的表达式可以将实数作为输入和输出实数，等等。</p><h1 id="fe05" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">评估:将语法域映射到语义域</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/9d7cecf69739001ccb20c045bb35efa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*4qJx7jo_xIN6wDYtI8liQA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4:语法域如何映射到几个不同的语义域的可视化。</p></figure><p id="5ccf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，从语法到语义的评估是依赖于上下文的。为了实现这一点，我们需要一种方法来决定我们所处的上下文，或者等价地，我们想要将我们的表达式映射到哪个语义子域。简单的方法，也是我们将使用的方法，是在评估过程中明确指定上下文。这可以在图4中看到。</p><p id="29b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使这种评估成为可能，我们再次需要扩展我们对<code class="fe mz na nb nc b">Expr</code>接口的定义。我们将限制不同上下文的实现，只包括实值函数(返回浮点数的函数)和字符串的计算。这是通过让<code class="fe mz na nb nc b">Expr</code>接口实现<code class="fe mz na nb nc b">String</code>和<code class="fe mz na nb nc b">EvalToRealFunc</code>来实现的，如下所示。</p><p id="c8a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，在这种情况下，<code class="fe mz na nb nc b">String</code>对应于图4中的<code class="fe mz na nb nc b">EvalToString</code>，因为它允许我们在表达式中使用大量的<code class="fe mz na nb nc b">fmt</code>包。此外，我们在下面定义了一些类型，帮助我们保持代码的描述性，比如<code class="fe mz na nb nc b">VarName</code>、<code class="fe mz na nb nc b">Arguments</code>，它们存储变量值(这有时被称为“赋值函数”或“查找表”)，以及<code class="fe mz na nb nc b">RealFunc</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的<code class="fe mz na nb nc b">Expr</code>接口包括了所有的必需品，剩下的唯一事情就是实现评估。为了做到这一点，我们将像微分实现一样，利用表达式的递归性质。如果我们让<code class="fe mz na nb nc b">e1</code>和<code class="fe mz na nb nc b">e2</code>是两个表达式，那么<code class="fe mz na nb nc b">Add(e1, e2)</code>的评估模式可以在下面的图5中看到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/af9236ffbbf7f6a3edc27a51ba838f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/0*pErEk1HsvIjrAv3z"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5:两个表达式相加的求值模式示例。</p></figure><p id="14b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，这种模式意味着我们的语法表示法<code class="fe mz na nb nc b">add</code>被语义表示法<code class="fe mz na nb nc b">+</code>所取代，并且语法操作数也被递归地评估。当然，这需要对我们的评估函数的递归调用停止的基本情况。这自然发生在表达式的叶节点，因为它们没有任何进一步的子节点(表达式基本情况没有进一步的参数)。</p><p id="728c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个操作符翻译的实现，让<code class="fe mz na nb nc b">add</code>映射到<code class="fe mz na nb nc b">+</code>，<code class="fe mz na nb nc b">mul</code>映射到<code class="fe mz na nb nc b">*</code>等等。其中，<code class="fe mz na nb nc b">constant</code>的基本情况只是映射到它的值，而<code class="fe mz na nb nc b">variable</code>映射到您指定的值，这是在下面的代码中完成的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2682" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">String</code>的实现如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="6723" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">从数学角度看评估和语法转换</h1><h2 id="4a4e" class="ng mh iq bd mi nh ni dn mm nj nk dp mq lf nl nm ms lj nn no mu ln np nq mw nr bi translated">同态，一个例子</h2><p id="2f7e" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">作为一个数学书呆子，我不会让你轻易脱身的。这里有相当多的数学机制在起作用，我将借此机会谈谈它。但是不要担心，我会尽力省去尽可能多的技术细节，并尽可能简单地解释这一切！</p><p id="d146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在幕后，一个叫做<a class="ae kv" href="https://en.wikipedia.org/wiki/Homomorphism" rel="noopener ugc nofollow" target="_blank">同态</a>的东西一直在努力工作。同态是映射的一个特征。更准确地说，对于我们的意图和目的来说，它是两个集合之间的结构保持映射，每个集合都有一个关联的操作符。</p><p id="953e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种集合和运算符的一个例子是1。被加的实数<code class="fe mz na nb nc b">(R,+)</code>，和2。乘法运算中的正实数<code class="fe mz na nb nc b">(R_+,*) </code>(感兴趣的读者可以注意到，这些结构被称为<a class="ae kv" href="https://en.wikipedia.org/wiki/Group_(mathematics)" rel="noopener ugc nofollow" target="_blank">群</a>)。因此，这两个集合之间的同态是保持它们各自结构的函数<code class="fe mz na nb nc b">h</code>。</p><p id="c7c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这实际上意味着对于实数中的每个<code class="fe mz na nb nc b">a</code>和<code class="fe mz na nb nc b">b</code>，<code class="fe mz na nb nc b">R</code>；<code class="fe mz na nb nc b">h(a)</code>和<code class="fe mz na nb nc b">h(b)</code>都是正实数，<code class="fe mz na nb nc b">R_+</code>和<code class="fe mz na nb nc b">h(a + b) = h(a) * h(b)</code>。最后一部分是结构保持属性，查看这种关系的一种方式是<code class="fe mz na nb nc b">h</code>分布在总和上，并将加法转换为乘法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/49b1a9d014ee2577f64f597783e69836.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/0*w9-PpZpBoqtcMdO2"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6:结构保持属性。</p></figure><p id="0c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了找到从<code class="fe mz na nb nc b">(R,+)</code>到<code class="fe mz na nb nc b">(R_+,*)</code>的同态，我们仔细看看图6中呈现的结构保持属性。这看起来就像幂之间相乘的指数法则。因此，通过让，例如，<code class="fe mz na nb nc b">h(x) = exp(x)</code>我们有1。对于<code class="fe mz na nb nc b">R</code>中的<code class="fe mz na nb nc b">x</code>，图像<code class="fe mz na nb nc b">exp(x)</code>位于<code class="fe mz na nb nc b">R_+</code>，2 .那个<code class="fe mz na nb nc b">exp(a + b) = exp(a) * exp(b)</code>。因此我们知道指数函数是从<code class="fe mz na nb nc b">(R,+)</code>到<code class="fe mz na nb nc b">(R_+,*)</code>的同态。</p><h2 id="be0a" class="ng mh iq bd mi nh ni dn mm nj nk dp mq lf nl nm ms lj nn no mu ln np nq mw nr bi translated">同态，如何适用于我们？</h2><p id="928c" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">现在，为了让您相信同态对我们起着核心作用，我们可以观察到图5中呈现的评估模式与图6中呈现的结构保持属性具有相同的形式，但是用<code class="fe mz na nb nc b">Add</code>代替了<code class="fe mz na nb nc b">+</code>，用<code class="fe mz na nb nc b">+</code>代替了<code class="fe mz na nb nc b">*</code>。这意味着当计算一个表达式时，我们只是使用不同的集合和操作符，但是同态的结构保持特性仍然存在。在<code class="fe mz na nb nc b">Eval</code>函数的情况下，我们的集合是语法和语义域，而运算符是我们定义的运算符，即<code class="fe mz na nb nc b">add</code>、<code class="fe mz na nb nc b">mul</code>、<code class="fe mz na nb nc b">pow</code>及其语义对应项，例如<code class="fe mz na nb nc b">+</code>、<code class="fe mz na nb nc b">*</code>、<code class="fe mz na nb nc b">math.Pow</code>。</p><p id="5826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好，所以我们希望我们的<code class="fe mz na nb nc b">Eval</code>函数，对于每个语法操作符，是从语法域到语义域的同态，以符合我们的求值模式。但是如果不是呢？我们已经讨论了一个完美的例子，即微分。</p><p id="7121" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们在上面定义我们的微分函数<code class="fe mz na nb nc b">D</code>时，我们称之为语法转换，但我们也可以将其视为评估过程。但是，它不是将语法域映射到语义域，而是将语法域映射到自身，这样的映射也可以是同态的。然而，对于我们的微分函数来说，情况并非如此。<code class="fe mz na nb nc b">D</code>不是同态。让我告诉你为什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/30c21dbab69d4729e72db5eb926a8287.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*NxoQxHdblPeHFaTZyu2LFg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图7:产品的微分成为同态所需的评估模式，其中f和g是表达式。注意，不能仅用导数的信息来构造MulD。它还需要原始函数的信息，因为(f*g)' = f'*g + f*g '</p></figure><p id="9f59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">观察我们的语法操作符<code class="fe mz na nb nc b">mul</code>的区别就足够了。在图7中，我们可以看到<code class="fe mz na nb nc b">D</code>需要的评估模式是<code class="fe mz na nb nc b">mul</code>的同态。现在，根据实现细节，我们可以将<code class="fe mz na nb nc b">MulD</code>视为一个独立的语法元素，或者我们可以尝试将其定义为一个函数，给定<code class="fe mz na nb nc b">D(f)</code>和<code class="fe mz na nb nc b">D(g)</code>，返回<code class="fe mz na nb nc b">Mul(f,g)</code>导数的表达式。</p><p id="d889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论哪种方式，问题都变成了是否有可能只使用<code class="fe mz na nb nc b">D(f)</code>和<code class="fe mz na nb nc b">D(g)</code>来表示两个表达式之间乘积的导数，因为当我们遵循图7中的模式时，这是唯一可访问的信息。答案当然是否定的，我们试图做的是用仅仅<code class="fe mz na nb nc b">f'</code>和<code class="fe mz na nb nc b">g'</code>来表示乘积法则<code class="fe mz na nb nc b">(f*g) = f'*g + f*g'</code>，这是不可能的。</p><p id="3ac4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当试图只使用每个表达式的导数来表示乘积规则时，问题是我们没有足够的信息。我们也需要表达本身。当无法构造同态时，这是一种常见的模式；映射的目标域不包含足够的信息。</p><p id="e974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这方面的另一个例子(我要偷的)可以在领域特定的数学语言中找到，扬松等人，2022年(可在本报告中找到)。</p><p id="72d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们考虑一个语法域，在这个语法域中我们可以表示表达式，但是这一次没有变量，使我们的生活更容易。此外，为了减少混淆，我将把计算表达式的过程调用到数字语义域来计算表达式，例如，计算<code class="fe mz na nb nc b">4*8 — 10</code>将导致<code class="fe mz na nb nc b">26</code>。</p><p id="d478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在考虑函数<code class="fe mz na nb nc b">IsPrime</code>。如果表达式计算出一个质数，该函数返回<code class="fe mz na nb nc b">true</code>，否则返回<code class="fe mz na nb nc b">false</code>。这样，语义域就变成了只包含<code class="fe mz na nb nc b">true</code>和<code class="fe mz na nb nc b">false</code>的集合。</p><p id="d667" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现这一点的幼稚方法是首先计算表达式，然后检查它是否是质数，但这不是我们想要的。我们想直接根据是否是素数的语义来评估语法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/432c5b57fe9a885d8cac3f2905f2d7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*fdLuvkF97BgLyV2Y"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图IsPrime的评估模式。Add语法被替换为IsPrimeAdd，它的参数被递归计算。</p></figure><p id="983d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图8所示的<code class="fe mz na nb nc b">IsPrime</code>的评估模式与图5所示的<code class="fe mz na nb nc b">Eval</code>相同。但是由于<code class="fe mz na nb nc b">IsPrime</code>评估为一个不同的语义子域，我们用<code class="fe mz na nb nc b">IsPrimeAdd</code>代替了<code class="fe mz na nb nc b">+</code>，如图5所示。<code class="fe mz na nb nc b">IsPrimeAdd</code>是一个语义函数，有两个布尔输入和一个布尔输出，我们需要自己定义。</p><p id="688b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们可以构造这个函数<code class="fe mz na nb nc b">IsPrimeAdd</code>吗？从图8中，我们可以看到它需要获取两个数是否为质数的布尔信息，并计算它们的和是否为质数。换句话说，如果我们知道<code class="fe mz na nb nc b">x</code>和<code class="fe mz na nb nc b">y</code>是否是质数，那么在不知道数字实际值的情况下，我们能否判断出<code class="fe mz na nb nc b">x + y</code>是否是质数？</p><p id="e271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题的答案是否定的；这个证明在图9中以矛盾证明的形式给出。该证明利用了以下事实:在步骤3-5中，<code class="fe mz na nb nc b">IsPrime</code>丢弃了可以用<code class="fe mz na nb nc b">3</code>替换<code class="fe mz na nb nc b">2</code>的信息，因此表明对于使用可用信息的<code class="fe mz na nb nc b">IsPrimeAdd</code>，必须使<code class="fe mz na nb nc b">false</code>等于<code class="fe mz na nb nc b">true</code>，这是不可能的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/bac0ab0af516e564712db65f92b54b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*u7y9YuGJ_NvqAcx6I68Nuw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图9:用反证法证明IsPrime不是Add到IsPrimeAdd的同态，因为true不能等于false。</p></figure><p id="e029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如<code class="fe mz na nb nc b">D</code>一样，<code class="fe mz na nb nc b">IsPrime</code>映射到的域不包含足够的信息使评估模式有效，即评估是同态的。有时可以扩展域使映射成为同态，但这是我不会在本文中讨论的(但可能在将来)。</p><h2 id="dc8a" class="ng mh iq bd mi nh ni dn mm nj nk dp mq lf nl nm ms lj nn no mu ln np nq mw nr bi translated">同态，我们为什么要在意？</h2><p id="b015" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">在写这篇文章的时候，我很兴奋地解释了我们如何在评估模式中利用同态。但是当我悬停在发布按钮上时，我意识到我没有回答这个问题:为什么需要同态？它们是很酷的数学对象，但它们真的有必要吗？毕竟，我们的微分函数<code class="fe mz na nb nc b">D</code>工作起来就像一个魔术，使用了与<code class="fe mz na nb nc b">Eval</code>相同的递归计算技巧，但它不是同态。</p><p id="48b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这花了我一段时间，但我对此的回答是，从语法域到语义域的评估不需要同态，但它们允许进一步的抽象。从语法域到语义域的每一个映射都有相同的评估模式，这将允许我们创建一个叫做<a class="ae kv" href="https://en.wikipedia.org/wiki/Catamorphism" rel="noopener ugc nofollow" target="_blank">变形</a>的东西。</p><p id="218e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会详细解释这个概念，主要是因为我还不理解它，但它可能对我们稍后尝试扩展我们可以映射到的语义子域的数量有用，例如图4中的<code class="fe mz na nb nc b">EvalToVecFunc</code>。如果你对这个抽象感兴趣，我在这里找到了一篇关于它的有趣文章<a class="ae kv" href="https://medium.com/@olxc/catamorphisms-and-f-algebras-b4e91380d134" rel="noopener">。</a></p><h1 id="ec89" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="1fc9" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">我们现在已经看到区分语法和语义是多么有用。它是计算机代数系统的构建模块，允许我们拥有代数表达式的符号表示，我们可以通过例如微分来操纵它。我们还看到了如何使用抽象语法树在Go中实现所有这些。</p><p id="a70e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个重要的焦点是从语法到语义的映射或评估。我们已经彻底地检查了它，讨论了它是如何依赖于上下文的，并且确定了如果评估模式是同态的，它在进一步的抽象中是有帮助的。尽管如此，它对评估过程并不重要。</p><p id="492a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经走了这么远，谢谢你！这是一篇很长，但我认为很有趣的文章(至少对于写作来说)。在下一篇文章中，我将实现一个表达式简化器，敬请关注！</p></div></div>    
</body>
</html>