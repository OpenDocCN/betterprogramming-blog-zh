<html>
<head>
<title>Use Big O Notation to Design Better Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用大O符号来设计更好的算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-big-o-notation-to-design-better-algorithms-9e5769c2e47b?source=collection_archive---------6-----------------------#2020-01-30">https://betterprogramming.pub/use-big-o-notation-to-design-better-algorithms-9e5769c2e47b?source=collection_archive---------6-----------------------#2020-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="06b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用代码做大多数事情有多种方式，但有些方式明显比其他方式好</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7da7b339d77f6a6051beb0a6cd23a0a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3C21WioGGRD3Al0g"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克洛伊·本科·普里尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是上午9:00，你五分钟前就到了办公室，刚好有时间去喝一天中的第一杯咖啡。</p><p id="a6ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">突然，你的老板过来告诉你他有多饿。你问他你能帮上什么忙。他要和其他饥饿的人开会，他希望你在上午11点前做好苹果派</p><p id="d30a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你访问Recipe Overflow来寻找苹果派的配方，最后在一个帖子上与人们讨论最佳配方。</p><p id="3d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道做苹果派有不同的方法。一些食谱看起来很容易烹饪，只有三四个步骤和很少的配料，但用户投票否决它们，因为他们说它们不好吃。</p><p id="08f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个食谱有很好的评分，更多的步骤，但人们说这是他们吃过的最好的。你不想让你的老板失望，你挑了那个超级好吃的。</p><p id="8905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为有多种方法来烹饪苹果派，所以有多种方法来解决编码问题。一个糟糕的算法会让你的程序变慢。我们如何衡量呢？</p><p id="3119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码不能浅尝辄止，这就是<strong class="lb iu"> </strong>大O的用武之地。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="34e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">大O批注，是为了什么？</h1><blockquote class="mu"><p id="bf2b" class="mv mw it bd mx my mz na nb nc nd lu dk translated">大O符号用于根据算法的运行时间或空间需求如何随着输入大小的增长而增长，通过表示其增长率的上限来对算法进行分类— <a class="ae ky" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="d5ff" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">简而言之，它有助于判断一种算法是否足以有效地处理大量数据。</p><ul class=""><li id="bc47" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">对于处理少量数据的小型应用程序，可能没有必要使用Big O，除非代码非常糟糕，否则好的算法和不太差的算法之间的运行时差异对应用程序的影响很小。</li><li id="f34d" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">但是，对于大型应用程序来说，处理大量数据，在编写算法的同时进行这种分析可以使应用程序运行得更快(并使用更少的内存)。</li></ul><p id="8795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是说，理解大O是如何工作的是绝对值得的，即使是对于小项目。当你的应用规模扩大时，你会感谢自己的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b76" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们为什么不用时间来衡量效率？</h1><p id="a6fe" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">尽管时间通常与复杂性密切相关，但两者不一定完全相同。在具有不同硬件、操作系统和编程语言的不同计算机上处理操作可能会影响结果时间。</p><p id="1a66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，时间比数学更难分析。大O符号用于查看算法如何扩展。比较两种不同算法的曲线比结果测试时间更容易、更快。</p><p id="0736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，大O符号抽象了算法和它处理的数据。它近似于算法在最坏情况下的执行效率。</p><p id="3e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，如果你在一个有100，000个条目的列表中进行搜索，最糟糕的情况是什么也找不到。仅用时间和真实数据来衡量算法的效率更难，也不相关。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a837" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">它是如何工作的？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f619b01b41d2496d92fc229049a03fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8caPZ689Pp0mCYdk3hIIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Big-O复杂度图—<strong class="bd od"/>【https://www.bigocheatsheet.com/ T2】</p></figure><p id="ca04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此图表显示了算法需要处理的运算量，具体取决于输入的大小(元素)。它被分为五个部分，从最高效、<em class="oe">优秀、</em>到最低效、<em class="oe">糟糕。</em></p><p id="4f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记数法是这样写的:<em class="oe"> O(效率)</em>任何算法都可以用这个公式来记。不用说，你的算法越绿色越好。红色部分是不惜一切代价要避开的区域！红区的算法扩展性很差。</p><p id="c7a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这些曲线可以对应哪种算法…</p><h2 id="f614" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">恒定时间复杂度— O(1)</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/a092abbfef48aaa70cbb3b5df0e5abb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-zejaMAC_k8dIb-21J0W7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(1)时间复杂度</p></figure><p id="973f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管输入的大小，它总是只做一个操作。</p><h2 id="45e9" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">对数时间复杂度— O(log n)</h2><p id="75f0" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">这表示一个函数，其复杂度随着输入大小的增加以对数方式增加。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/74435d3addc9b2677f39c4677e86f982.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*xegY7pqbzpDyQHX5nwxW7w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对数函数的示例</p></figure><p id="4421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是对数函数的典型形状。</p><p id="18aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">横坐标和纵坐标在这里并不重要，注意曲线本身。当输入的大小为<em class="oe"> x </em>时，我们可以看到它的伸缩性非常好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/ada6945ab645bd8153beb0e46be01ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlSHd7I9gphk5r6k16H9rA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(log n)时间复杂度</p></figure><p id="0c41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是一个<a class="ae ky" href="https://guide.freecodecamp.org/algorithms/search-algorithms/binary-search/" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>的代码，一个<em class="oe"> O(log n) </em>复杂度的算法。</p><p id="b946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">二分搜索法算法通过重复地将搜索间隔一分为二来定位排序数组中的项目。</p><p id="d2b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们在二分搜索法的每一步中处理搜索用例的一部分，而在另一半上执行搜索操作，这导致最坏情况下的时间复杂度为<em class="oe"> O(log n) </em>。</p><h2 id="04e2" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">线性时间复杂度— O(n)</h2><p id="dbd7" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">它表示算法的复杂度，该复杂度与输入大小成正比地线性增加。</p><p id="aeee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的一个例子是在列表中搜索一个项目。就像我们刚才做的那样，但不是最佳的方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/a7a1eaf7bc2073e35ad361a2a84e61ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVrXEqaUONMBNJWWOIliNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(n)时间复杂度</p></figure><p id="5b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，该函数是一个循环。最坏的情况是:它一直循环到列表的末尾。</p><p id="b11f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行时间直接取决于输入的大小，这导致了一个<em class="oe"> O(n) </em>。</p><h2 id="e5fd" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">对数线性时间复杂度— O(n log n)</h2><p id="86a8" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><a class="ae ky" href="https://guide.freecodecamp.org/algorithms/sorting-algorithms/merge-sort/" rel="noopener ugc nofollow" target="_blank">归并排序</a>、<a class="ae ky" href="https://guide.freecodecamp.org/algorithms/sorting-algorithms/heap-sort/" rel="noopener ugc nofollow" target="_blank">堆排序</a>、<a class="ae ky" href="https://guide.freecodecamp.org/algorithms/sorting-algorithms/quick-sort/" rel="noopener ugc nofollow" target="_blank">快速排序</a>是时间复杂度为<em class="oe"> O(n log n) </em>的算法。它们以对数线性方式扩展。</p><p id="4488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个合并排序的例子，一个<a class="ae ky" href="https://guide.freecodecamp.org/algorithms/divide-and-conquer-algorithms/" rel="noopener ugc nofollow" target="_blank">分治</a>排序算法。它将数组分成两半，递归排序，最后合并排序后的两半。</p><p id="af0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/visualize/" rel="noopener ugc nofollow" target="_blank">这里有一个很棒的可视化工具</a>让你亲眼看看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/a7b8fdca7696b507b1e099693692e872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1zSHfe1fFWKDKgJCCNNTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(n log n)时间复杂度</p></figure><p id="3111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来解释一下时间复杂度。</p><ul class=""><li id="a60d" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><em class="oe">O(n</em><strong class="lb iu"><em class="oe">log n</em></strong><em class="oe">)</em>:递归地将给定数组分成两半，直到大小变为1。这是<code class="fe ot ou ov ow b">mergeSort</code>功能。</li><li id="0d85" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><em class="oe">O(</em><strong class="lb iu"><em class="oe">n</em></strong><em class="oe">log n)</em>:合并两个排序切片的任务以线性时间运行。这就是<code class="fe ot ou ov ow b">merge</code>功能。</li></ul><h2 id="c481" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">二次时间复杂度— O(n)</h2><p id="21a4" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><em class="oe"> O(n ) </em>表示一种算法，其复杂度与输入大小的平方成正比。</p><p id="1ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个无用的例子，但很容易理解:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/5ed6aab2742438a47c02c85953e32a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BS_5XUH0D48EVpqVIMrMtA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(n)时间复杂度</p></figure><p id="32f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环具有<em class="oe"> O(n) </em>复杂度，因此，循环中的循环具有<em class="oe"> O(n) * O(n) </em>复杂度，即<em class="oe"> O(n ) </em>。</p><p id="7bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://guide.freecodecamp.org/algorithms/sorting-algorithms/bubble-sort/" rel="noopener ugc nofollow" target="_blank">冒泡排序</a>、<a class="ae ky" href="https://guide.freecodecamp.org/algorithms/sorting-algorithms/insertion-sort/" rel="noopener ugc nofollow" target="_blank">插入排序</a>和<a class="ae ky" href="https://guide.freecodecamp.org/algorithms/sorting-algorithms/selection-sort/" rel="noopener ugc nofollow" target="_blank">选择排序</a>是<em class="oe"> O(n ) </em>排序算法的例子。</p><h2 id="bed5" class="of md it bd me og oh dn mi oi oj dp mm li ok ol mo lm om on mq lq oo op ms oq bi translated">指数时间复杂度— O(2ᴺ)</h2><p id="9497" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><em class="oe"> O(2ᴺ) </em>是一个有指数增长的算法。输入数据集每增加一项，运算量就会增加一倍。</p><p id="a011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现的一个例子是斐波那契数的递归计算。对于那些不知道的人来说，在<a class="ae ky" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波纳契数列</a>中，每个数字后面都是前两个数字的总和。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/cd5220aff936d81fb95c96fff8aaf127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Cr7YpljY_OTAA_PAc5F4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(2ᴺ)时间复杂度</p></figure><p id="0e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要在实际项目中使用上面的代码，这种计算可以用较低的时间复杂度来实现。这只是一个例子。</p><p id="031b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，对于每个输入数字，函数递归地调用自己两次，直到数字小于或等于1。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d22c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">时间复杂度与空间复杂度</h1><p id="0f83" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">到目前为止，我们用大O来衡量一个算法的时间复杂度。</p><p id="0cfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大O也用来衡量<em class="oe">空间复杂度</em>。空间复杂度是在最坏的情况下，算法需要的工作存储(内存)量的度量。</p><p id="1b96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">空间复杂度和时间复杂度一样重要。事实上，在某些情况下，您可能需要优先考虑一个而不是另一个(速度或内存)。…</p><p id="d0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与我们之前看到的逻辑相同，下面是一个小例子…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/14e35e5affbf36d6aa005346c2522b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPCzCwEeAej_xh4wnB-5eg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(n)空间复杂度</p></figure><p id="ae4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到该函数的最坏情况(所有单词都以字母A开始)，<code class="fe ot ou ov ow b">words</code> <code class="fe ot ou ov ow b">const</code>将包含<em class="oe"> n </em>个单词。因此，空间复杂度将是<em class="oe"> O(n) </em>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f798" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="51da" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">大O帮助我们理解算法如何根据输入的大小进行扩展。</p><p id="892f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以用来衡量时间和空间的复杂性，两者都同样重要。</p><p id="3a50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大O是程序员工具箱里的必备工具。</p><p id="f973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>