<html>
<head>
<title>Thoughts on Remix: How It Might Change the Approach to Full Stack Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于混音的思考:它将如何改变全栈工程的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/thoughts-on-remix-how-it-might-change-the-approach-to-fullstack-engineering-15ccb2fcfa63?source=collection_archive---------4-----------------------#2022-07-09">https://betterprogramming.pub/thoughts-on-remix-how-it-might-change-the-approach-to-fullstack-engineering-15ccb2fcfa63?source=collection_archive---------4-----------------------#2022-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c6fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">端到端思考</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1bb4c0ac468f618fd38597e7638e92de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7i76-AVGjDZkjqriy5mFUw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Remix，React的全栈SSR框架</p></figure><p id="5483" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">软件工程可能是世界上变化最大(如果不是最大的话)的领域之一:每天都有越来越多的解决方案和技术从聪明的头脑中涌现出来，令人惊讶的框架/库正在被发布，并且不断受到限制以达到性能、可伸缩性和开发体验之间的最佳平衡。随着我们任务的发展和变得更加艰难，我们克服它们的方法也随之而来。</p><p id="2de0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种几乎混乱的无尽洪流中，由于我在初创公司的一项任务，我遇到了一个相对较新的React框架:<strong class="kx ir"> Remix </strong>。JavaScript几乎是臭名昭著的，因为永无止境的框架和库版本，是的，但这一次，我想我遇到了一个明显的科洛桑创新。</p><p id="25b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在最基本的层面上，我们知道现代web应用程序基本上由三个主要结构组成:</p><ul class=""><li id="35df" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">在后面，有一个数据库，比如MongoDB或PostgreSQL，用来存储所有的持久数据和托管模型，</li><li id="5fc2" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">在浏览器端，SPA框架(如React、Vue)创建高度高级的界面，提供流畅的用户交互，</li><li id="329f" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">最后，一个位于浏览器和数据库之间的RESTful API不断地监听请求，并按照一定的逻辑在这两端之间导航工作流。</li></ul><p id="ecf7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们通过考虑我们可以用MERN堆栈做的最简单的CRUD应用来使它变得更加清楚。想象一个简单的面板，我们在其中管理系统中的用户:您已经用React编写了这个页面。当您填写所需的信息并单击“Create new User”按钮时，您很可能会向与Express server一起运行的API中的/user路由发送一个POST请求。</p><p id="1735" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">控制器充当MongoDB和用户请求之间的交通警察，检查和验证从前端发送的数据，并将其添加到数据库中的用户集合中。</p><p id="0547" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在另一个页面上，当您想要访问系统上的所有用户时，您可能会向同一个/user路由发出GET请求，控制器将再次满足您的请求；分析一下，如果请求能通过必要的检查，这一次控制器从数据库中取出所有用户的数据，带回前端，供你使用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/5beea369c6df3139f2330d1098e32331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ha4VPfRlabvtdGPo.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MERN是如何运作的</p></figure><p id="a6be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于将前端直接连接到数据库而不使用任何后端控制器被认为是一个主要的安全弱点(由于凭证的暴露)，在这个系统中，我们习惯于在完全独立的repos中编写前端代码和后端代码，您在它们之间安装一个API层来执行甚至最简单的操作。</p><p id="86e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于在其职业生涯中一直使用这种方案的前端开发人员来说，基本上，相同的循环会重复:</p><p id="73f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.最有可能的是，准备模拟数据，</p><p id="fb3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.编写页面外观、动画和功能的代码，</p><p id="f597" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.如果后端准备好了，向相关的端点发送必要的请求，以获取您将使用的数据(或者发布、修补、上传等。修改现有数据)</p><p id="01d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.编辑您的代码以处理真实数据。</p><p id="0974" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，您几乎不会深入研究PostgreSQL或MongoDB:您关注的是正确使用现成的东西。</p><p id="86bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么<strong class="kx ir"> Remix </strong>改变了什么呢？</p><p id="0810" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Remix允许你编写后端代码，并在你熟悉的React代码旁边直接查询你的数据库，你可以指定你的页面如何出现在浏览器端。它允许你用Mongoose或Prisma这样的ORM工具编写Node.js代码，就像你在后端repo中一样！</p><p id="8839" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了实现这种全栈环境，它使用了两种结构:“Action”和“Loader”函数。loader函数是从外部数据源获取数据的函数。这可以是对另一个API的请求，但是更有趣的是，正如我所说的，您也可以通过连接到您的数据库本身来使用ORM。此外，Remix还提供了出色的支持，让我们能够及时了解这些请求的进展情况。在最原始的情况下，当使用外部API时，我们会手动定义和管理像<em class="mg">正在加载</em>或<em class="mg"> isError </em>这样的状态。Tanner Linsley编写的<strong class="kx ir"> React Query </strong>库在这方面也提供了很大的便利；它还成功地保持请求的状态，并提供高效的缓存。根据我们的经验，由于RQ足以管理所有服务器状态，我们甚至不需要使用Redux，因为这种应用程序范围的缓存机制:除了少数客户端状态，所有的重量都在RQ的肩上。现在，混音可以更进一步。虽然它提供了与RQ类似的状态支持，但这也意味着您可以直接连接到数据库并编写后端。在代码的前端部分，您获取通过useLoaderData()返回的数据，并像平常一样使用它:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="bfc2" class="mm mn iq mi b gy mo mp l mq mr">export const <strong class="mi ir">loader</strong>: LoaderFunction = async ({ params}) =&gt; {</span><span id="c0c7" class="mm mn iq mi b gy ms mp l mq mr">return json(                                <strong class="mi ir"> // query your db here</strong></span><span id="1563" class="mm mn iq mi b gy ms mp l mq mr">await db.product.findMany({</span><span id="dba9" class="mm mn iq mi b gy ms mp l mq mr">where: { categoryId: params.categoryId }}));</span><span id="01c6" class="mm mn iq mi b gy ms mp l mq mr">};</span><span id="8222" class="mm mn iq mi b gy ms mp l mq mr">export default function ProductCategory() {</span><span id="9f45" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">const products = useLoaderData();            // get the result</strong></span><span id="a6c3" class="mm mn iq mi b gy ms mp l mq mr">return (</span><span id="7ed2" class="mm mn iq mi b gy ms mp l mq mr">&lt;div&gt;</span><span id="5789" class="mm mn iq mi b gy ms mp l mq mr">&lt;p&gt;{products.length} Products&lt;/p&gt;            <strong class="mi ir">// use it</strong></span><span id="ac53" class="mm mn iq mi b gy ms mp l mq mr">&lt;/div&gt;</span><span id="bc9e" class="mm mn iq mi b gy ms mp l mq mr">);</span><span id="ead0" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><p id="8e32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你要在某个地方写数据而不是获取数据，这次你使用<strong class="kx ir">动作</strong>。检查通过表单传输的数据是如何写入数据库的:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="7758" class="mm mn iq mi b gy mo mp l mq mr">export action: ActionFunction = async ({request}) =&gt; {<br/><br/>  const formData = await request.formData()  <strong class="mi ir">// catch the sent data</strong><br/>  const amount = Number(formData.get('amount')) <strong class="mi ir">// get the fields</strong><br/>  .<br/>  . <strong class="mi ir">// use them however you like with or ORM or sth</strong></span><span id="d08d" class="mm mn iq mi b gy ms mp l mq mr">  return json({ amount})<br/>}</span><span id="069f" class="mm mn iq mi b gy ms mp l mq mr">&lt;Form method="post"&gt;<br/>      &lt;input type="number" name="amount"/&gt;<br/>      &lt;button&gt;Create Cart&lt;/button&gt;<br/>&lt;/Form&gt;</span></pre><p id="5b63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，在代码太长的情况下，你可以打开单独的文件，用后缀<em class="mg"> .server.js </em>命名，只用于后端代码，而不是将所有内容都写在同一个文件中。</p><p id="efa6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Remix是由React路由器团队开发的，它在各个方面都有许多令人兴奋的创新/功能。本文的目的不是教Remix，而是指出它如何改变软件开发过程。因为在这种情况下，没有一个前端人员严格地从后面请求和使用数据，也没有一个后端人员只编写API。Remix推动你成为全栈。在同一个文件中，用Prisma查询PostgreSQL，并用下面的framer-motion制作动画。:)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/8664dcd5075b3f3f59e13758dbe747d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZtgwstYMYH2pC3op.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Remix在数据获取方面的创新防止了瀑布</p></figure><p id="7b27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我问自己:如果我完全接受Remix，我不会再使用任何纯后端API吗？此时，我想到了其他现代技术，如Golang和gRPC。</p><p id="b62e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在一个屋檐下，我完全可以在全栈混音中处理我通常的CRUD操作。除此之外，对于我的特定服务，应该为非常高的计算效率而定制，然后可能我可以使用不同的和专门的后端解决方案。当我观察高科技公司如何使用Go时，我看到了类似的关键任务。优步的GPU-power分析引擎设置，Twitch的低延迟系统……在任何其他场景下，我相信用Remix编写后端对于处理开发者舒适度和开发速度是重中之重的情况来说都绰绰有余。</p><p id="4d42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与Next.js相比，Remix是一个更新的解决方案，它被比作SSR。随着时间的推移会有更新，改进将随着反馈的增加而进行。然而，无论如何，习惯这种全栈框架意味着摆脱更单调的例行程序，能够进行端到端的思考。</p><p id="94ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这方面，我相信看一眼Remix对任何一个软件工程师都是有提升的。</p></div></div>    
</body>
</html>