<html>
<head>
<title>Do-It-Yourself JSON Encoding in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的自助JSON编码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-step-by-step-guide-to-working-with-json-in-swift-without-dependencies-398fd25c4fe8?source=collection_archive---------3-----------------------#2019-08-18">https://betterprogramming.pub/a-step-by-step-guide-to-working-with-json-in-swift-without-dependencies-398fd25c4fe8?source=collection_archive---------3-----------------------#2019-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="67c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">忘记Alamofire吧，你可以在Swift中处理JSON而不依赖它。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1d1449e61055165b668702d4b56e390f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZr4qu5_Th6eK5qNVW_WWQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@franki?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰基·查马基</a>在<a class="ae kv" href="https://unsplash.com/search/photos/data-exchange?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="267a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在当今的移动应用生态系统中，由于这样或那样的原因，几乎每个应用都需要与后端服务器通信。不可避免地，这种交流将涉及到使用JSON数据。</p><p id="f62f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了强调这一点，有几个开源项目提供了在Swift中将JSON数据解析成更容易理解的数据模型的便捷途径。其中最受欢迎的可以说是<a class="ae kv" href="https://github.com/SwiftyJSON/SwiftyJSON" rel="noopener ugc nofollow" target="_blank"> SwiftyJSON </a>。</p><p id="45df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这些项目没有错，除了它们成为你的应用程序不可或缺的一个依赖源。</p><p id="23f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://research.swtch.com/deps" rel="noopener ugc nofollow" target="_blank">减少对外部项目的依赖是一个值得认真考虑的目标</a>，因此，今天，我们将看看如何在没有依赖的情况下在Swift中处理JSON数据。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="96c6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">项目</strong></h1><p id="fc41" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我相信在实践中学习，但我不想陷入构建UI的困境，所以我们将建立一个操场。</p><p id="96c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将研究如何从服务器获取JSON数据并将其解码成易于使用的数据模型，以及如何对更改进行编码并将其发送回服务器。</p><p id="983a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，打开Xcode并创建一个新的空白游乐场。将其命名为<code class="fe mw mx my mz b">JSON.playground</code>并保存在适当的地方。</p><p id="1ad2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将创建几个文件来组织我们的工作，所以一旦游乐场开放，通过按下<code class="fe mw mx my mz b">⌘1</code>或点击菜单<code class="fe mw mx my mz b">View -&gt; Navigators -&gt; Show Project Navigator</code>来显示项目导航器。</p><p id="0431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您应该可以看到主playground文件以及sources和resources文件夹。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/4743c3e83df877cc16f70bda1c72519b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tn-SKHy4O7GwqA2Iy0eEVw.png"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c39b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">数据</strong></h1><p id="ec18" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在编写任何代码之前，让我们看看我们将使用的数据。<a class="ae kv" href="https://github.com/public-apis/public-apis" rel="noopener ugc nofollow" target="_blank">有很多免费、开放的JSON数据端点可供我们学习使用。</a></p><p id="b266" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的最爱之一是<a class="ae kv" href="http://jsonplaceholder.typicode.com" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>，它已经存在了很多年，而且不太可能很快消失。它们提供了一些不同的端点来模仿相册、待办事项列表等。</p><p id="db16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<code class="fe mw mx my mz b">users</code>端点，因为它包含嵌套的JSON，如果您是使用JSON的新手，这会带来一些困难，但这是非常常见的，也是在Swift中使用JSON的开源框架如此受欢迎的原因之一。</p><p id="b76a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们今天研究的技术使得使用JSON和嵌套JSON变得简单，就像使用开源框架一样，没有额外的依赖性。</p><p id="f391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将处理的数据是一组用户对象，如下所示:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="18ae" class="nf ma iq mz b gy ng nh l ni nj">[{<br/>   “id”: 1,<br/>   “name”: “Leanne Graham”,<br/>   “username”: “Bret”,<br/>   “email”: “Sincere@april.biz”,<br/>   “address”: {<br/>      “street”: “Kulas Light”,<br/>      “suite”: “Apt. 556”,<br/>      “city”: “Gwenborough”,<br/>      “zipcode”: “92998–3874”,<br/>      “geo”: {<br/>         “lat”: “-37.3159”,<br/>         “lng”: “81.1496”<br/>      }<br/>   },<br/>   “phone”: “1–770–736–8031 x56442”,<br/>   “website”: “hildegard.org”,<br/>   “company”: {<br/>      “name”: “Romaguera-Crona”,<br/>      “catchPhrase”: “Multi-layered client-server neural-net”,<br/>      “bs”: “harness real-time e-markets”<br/>   }<br/>},<br/>…<br/>]</span></pre><p id="2a72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有十个这样的用户对象，但是我们的代码可以处理任何数量。</p><p id="80d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这些对象，有趣的是我们有两个嵌套的对象:<code class="fe mw mx my mz b">address</code>和<code class="fe mw mx my mz b">company</code>。<code class="fe mw mx my mz b">address</code>对象也有一个名为<code class="fe mw mx my mz b">geo</code>的嵌套对象，但是消费和访问它的数据是微不足道的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cf72" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">基本获取</strong></h1><p id="6f1f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在深入研究如何使用这些数据之前，我们首先需要获取数据。让我们来处理一些网络代码。</p><p id="f9c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过点击项目导航器中的sources文件夹并输入<code class="fe mw mx my mz b">⌘N</code>来创建一个新文件。将文件名从<code class="fe mw mx my mz b">New File.swift</code>更改为<code class="fe mw mx my mz b">Networking.swift</code>。</p><p id="2f52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编辑器中，您现在应该只看到一条<code class="fe mw mx my mz b">import Foundation</code>语句。</p><p id="d18b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输入以下内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="31cc" class="nf ma iq mz b gy ng nh l ni nj">import Foundation</span><span id="237d" class="nf ma iq mz b gy nk nh l ni nj">public enum NetworkingError: Error {<br/>   case unableToGenerateURL<br/>}</span><span id="6005" class="nf ma iq mz b gy nk nh l ni nj">public class Networking {<br/>   public static func fetch(fromEndpoint endpoint: String, completionHandler: @escaping ((Result&lt;Data?, Error&gt;) -&gt; Void)) {<br/>      guard let url = URL(string: endpoint) else {<br/>         let error = NetworkingError.unableToGenerateURL<br/>         completionHandler(Result.failure(error))<br/>         return<br/>      }</span><span id="1f6b" class="nf ma iq mz b gy nk nh l ni nj">      let session = URLSession(configuration: .default)<br/>      let task = session.dataTask(with: url) { (data, _, error) in<br/>         guard error == nil else {<br/>            completionHandler(Result.failure(error!))<br/>            return<br/>         }<br/>         completionHandler(Result.success((data)))<br/>      }<br/>      task.resume()<br/>   }<br/>}</span></pre><p id="8771" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理解<code class="fe mw mx my mz b">URLSession</code>是一个非常深入的主题，超出了本文的范围，所以我将简单解释一下这里发生了什么。</p><p id="7e31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经创建了一个非常简单的方法来从端点获取数据。我们首先尝试从<code class="fe mw mx my mz b">endpoint</code>生成一个<code class="fe mw mx my mz b">URL</code>对象。如果失败，我们返回一个错误。如果成功，我们用默认配置创建<code class="fe mw mx my mz b">URLSession</code>。</p><p id="d107" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，<code class="fe mw mx my mz b">URLSession</code>的<code class="fe mw mx my mz b">dataTask</code>方法将完成通过网络与服务器通信的所有繁重工作，并返回三个可能的对象:<code class="fe mw mx my mz b">data</code>、<code class="fe mw mx my mz b">response</code>和<code class="fe mw mx my mz b">error</code>。</p><p id="30d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将首先检查<code class="fe mw mx my mz b">error</code>对象，如果它不是<code class="fe mw mx my mz b">nil</code>，我们将返回一个包含<code class="fe mw mx my mz b">error</code>对象的失败结果。如果<code class="fe mw mx my mz b">error</code>是<code class="fe mw mx my mz b">nil</code>，我们将使用<code class="fe mw mx my mz b">data</code>对象返回一个成功的结果。</p><p id="cdb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们忽略了<code class="fe mw mx my mz b">URLResponse</code>对象，因为老实说，我们假设，如果您从端点获得数据，一切都是好的。这不是最佳实践，所以不要在生产代码中这样做。为了避免复杂性，我选择了一个准系统实现。</p><p id="292c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您是第一次接触<code class="fe mw mx my mz b">URLSession</code>，我鼓励您检查这段代码以理解这个非常基本的实现，但是一定要深入研究这个主题，因为如果您将它剪切并粘贴到您的项目中，这段代码会在许多方面让您失望。</p><p id="25f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个需要注意的事项是，我们将大量使用<a class="ae kv" href="https://developer.apple.com/documentation/swift/result" rel="noopener ugc nofollow" target="_blank">结果类型</a>。如果您以前没有使用过<code class="fe mw mx my mz b">Result</code>,它是一种可以用来封装来自异步流程的成功或失败响应的类型，比如我们的网络方法。</p><p id="03bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是第一次接触<code class="fe mw mx my mz b">Result</code>，只要坚持使用这里的代码，到本文结束时，你就应该理解它了。奖金！</p><p id="1a11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经有了获取数据的能力，让我们从获取用户列表的代码开始。</p><p id="1626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们继续保持我们的代码组织良好，使用这个函数作为一个内部API的第一个函数，我们的主操场代码可以调用它来获得用户列表。</p><p id="292e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在sources文件夹中创建另一个新文件，命名为<code class="fe mw mx my mz b">UserAPI.swift</code>。在新文件中输入以下代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="6622" class="nf ma iq mz b gy ng nh l ni nj">import Foundation</span><span id="2527" class="nf ma iq mz b gy nk nh l ni nj">public struct UserAPI {<br/>   static let endpoint = “https://jsonplaceholder.typicode.com/users”<br/>}</span></pre><p id="bfa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们的API不需要一个类的开销，我们就把它做成一个<code class="fe mw mx my mz b">struct</code>。这也是保存端点字符串的逻辑位置。</p><p id="6b3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">endpoint</code>属性后，输入以下内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="6caa" class="nf ma iq mz b gy ng nh l ni nj">public static func getUsers() {<br/>   Networking.fetch(fromEndpoint: endpoint) { (result) in<br/>      switch result {<br/>      case .success(let data):<br/>         print(data)<br/>      case .failure(let error):<br/>         print(error.localizedDescription)<br/>      }<br/>   }<br/>}</span></pre><p id="95e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里发生的事情是，我们有一个<code class="fe mw mx my mz b">getUsers()</code>方法，它将调用我们之前创建的<code class="fe mw mx my mz b">Networking.fetch</code>方法。它将传入<code class="fe mw mx my mz b">endpoint</code>属性和一个简单的完成处理程序来处理fetch方法的<code class="fe mw mx my mz b">result</code>响应。</p><p id="a797" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们得到一个成功的响应(暂时忽略Xcode的隐式强制警告),我们将打印出数据；如果我们得到一个失败的响应，我们将打印出错误。</p><p id="8cd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个很好的起点，可以确保我们实际上可以与服务器通信并从中获取数据，所以让我们来测试一下。</p><p id="9d1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在项目导航器中，单击JSON playground文件。删除所有默认代码，并替换为以下代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="127b" class="nf ma iq mz b gy ng nh l ni nj">UserAPI.getUsers()</span></pre><p id="6072" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行playground代码，您应该会在控制台日志中看到类似下面的内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="b508" class="nf ma iq mz b gy ng nh l ni nj">Optional(5645 bytes)</span></pre><p id="c07a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您看到一个错误，请仔细检查您的代码和您的端点，以确保没有打字错误。如果您确实看到了与上面类似的消息，那么恭喜您，因为您现在正在从服务器中提取数据！</p><p id="59c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了数据，我们需要对它做些什么。这将需要一个数据模型和一个JSON解码器。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="86cf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">数据模型</strong></h1><p id="8c99" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">除了作为我们数据的存储容器之外，数据模型将是这个项目的关键组件之一，它将使使用JSON变得方便和容易。</p><p id="0509" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它背后的力量将是它符合<a class="ae kv" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank">可编码协议</a>。可编码一致性意味着对象可以与外部格式(如JSON)相互转换。</p><p id="3ed0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">Codable</code>实际上是一个由<code class="fe mw mx my mz b">Encodable</code>和<code class="fe mw mx my mz b">Decodable</code>协议组成的协议，所以如果你只需要解码那么你应该使用<code class="fe mw mx my mz b">Decodable</code>。我们将会看到从JSON到我们的数据模型再回到JSON的往返过程，所以我们使用了<code class="fe mw mx my mz b">Codable</code>。</p><p id="4be0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按照我们的代码组织主题，点击项目导航器中的sources文件夹，创建一个名为<code class="fe mw mx my mz b">DataModels.swift</code>的新文件。</p><p id="8d2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文件中，用以下代码替换默认代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="2984" class="nf ma iq mz b gy ng nh l ni nj">public struct User: Codable {<br/>   public var id: Int<br/>   public var name: String?<br/>   public var username: String?<br/>   public var email: String?<br/>   public var phone: String?<br/>   public var website: String?<br/>   public var address: Address?<br/>   public var company: Company?<br/>}</span><span id="f742" class="nf ma iq mz b gy nk nh l ni nj">public struct Address: Codable {<br/>   public var street: String?<br/>   public var suite: String?<br/>   public var city: String?<br/>   public var zipcode: String?<br/>   public var geo: Geo?<br/>}</span><span id="295c" class="nf ma iq mz b gy nk nh l ni nj">public struct Geo: Codable {<br/>   public var lat: String?<br/>   public var lng: String?<br/>}</span><span id="7c06" class="nf ma iq mz b gy nk nh l ni nj">public struct Company: Codable {<br/>   public var name: String?<br/>   public var catchPhrase: String?<br/>   public var bs: String?<br/>}</span></pre><p id="1bf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里所做的是创建一组结构，这些结构镜像服务器返回的JSON用户数据。为了进行比较，我们再来看看JSON数据的结构:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="fb21" class="nf ma iq mz b gy ng nh l ni nj">{<br/>   id<br/>   name<br/>   username<br/>   email<br/>   phone<br/>   website<br/>   address {<br/>      street<br/>      suite<br/>      city<br/>      zipcode<br/>      geo {<br/>         lat<br/>         lng<br/>      }<br/>   },<br/>   company {<br/>      name<br/>      catchPhrase<br/>      bs<br/>   }<br/>}</span></pre><p id="1566" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了可读性，我稍微重新安排了键并删除了数据值，这样我们就可以专注于结构。</p><p id="635d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个离散对象— <code class="fe mw mx my mz b">user</code>、<code class="fe mw mx my mz b">address</code>、<code class="fe mw mx my mz b">geo</code>和<code class="fe mw mx my mz b">company</code> —都有自己的结构。我们的JSON数据的所有值都是字符串，除了<code class="fe mw mx my mz b">User.id</code>是一个整数。</p><p id="ad74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些类型与JSON数据中提供的类型相匹配。<code class="fe mw mx my mz b">User.id</code>也是我们唯一确定知道服务器会返回的值。所有其他值都是可选的，因为我们不能保证从服务器为每个用户获取的数据都包含这些数据值。</p><p id="1d42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然一对一的比赛在很多时候是有意义的，但并不总是必要的。例如，在我们的例子中，我们不需要<code class="fe mw mx my mz b">company</code>对象的<code class="fe mw mx my mz b">bs</code>参数。</p><p id="ec9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用可编码协议处理这个问题非常简单；只是不包括它。从<code class="fe mw mx my mz b">Company</code>结构中删除<code class="fe mw mx my mz b">public var bs: String?</code>行。就这么简单。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a45e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">解码</strong></h1><p id="3006" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们有了数据模型，我们需要一个解码器来将来自服务器的数据转换成我们全新的数据模型。</p><p id="ca96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在上面说过，数据模型是整个项目的一个关键。解码器(以及后来的编码器)是另一个，因为模型和解码器/编码器作为一个团队一起工作。</p><p id="a455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们创建一个解码器。</p><p id="5b87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次在sources文件夹中创建一个名为<code class="fe mw mx my mz b">JSONConverter.swift</code>的新文件。用以下代码替换文件中的默认代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="130c" class="nf ma iq mz b gy ng nh l ni nj">import Foundation</span><span id="d965" class="nf ma iq mz b gy nk nh l ni nj">public struct JSONConverter {<br/>   public static func decode&lt;T: Decodable&gt;(_ data: Data) throws -&gt; [T]? {<br/>   do {<br/>         let decoded = try JSONDecoder().decode([T].self, from: data)<br/>         return decoded<br/>      } catch {<br/>         throw error<br/>      }<br/>   }<br/>}</span></pre><p id="5404" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常基本但非常有用的通用解码器。</p><p id="b688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一行一行地检查它，因为理解它非常重要。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="d886" class="nf ma iq mz b gy ng nh l ni nj">public static func decode&lt;T: Decodable&gt;(_ data: Data) throws -&gt; [T]? {</span></pre><p id="bfd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当调用该方法时，您将传递一个<code class="fe mw mx my mz b">Data</code>对象给它——特别是我们从<code class="fe mw mx my mz b">getUsers()</code>函数中获取的数据——并获取一个符合<code class="fe mw mx my mz b">Decodable</code>的可选通用对象数组。</p><p id="1b12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在此过程中发生错误，该方法将引发错误。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="fe7c" class="nf ma iq mz b gy ng nh l ni nj">do {<br/>   let decoded = try JSONDecoder().decode([T].self, from: data)<br/>   return decoded<br/>} catch {<br/>   throw error <br/>}</span></pre><p id="58a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe mw mx my mz b">do/catch</code>块是实际解码发生的地方。</p><p id="762a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们调用<code class="fe mw mx my mz b">JSONDecorder</code>的<code class="fe mw mx my mz b">decode</code>方法，传入一个符合<code class="fe mw mx my mz b">Decodable</code>的泛型对象，以及我们的<code class="fe mw mx my mz b">data</code>对象。</p><p id="8bd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，我们告诉解码器从服务器获取我们的<code class="fe mw mx my mz b">data</code>对象，并将其解码成一个<code class="fe mw mx my mz b">Decodable</code>对象的数组。一旦解码，我们返回数组。如果decode方法抛出一个错误，我们将捕捉它并抛出。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="81b4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">拼凑起来</strong></h1><p id="1e9b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们有了这些构建块，让我们实际使用它们将JSON服务器数据解码成我们的数据模型。</p><p id="4fee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mw mx my mz b">UserAPI.swift</code>文件。在<code class="fe mw mx my mz b">getUsers()</code>方法中，找到对<code class="fe mw mx my mz b">Networking.fetch</code>的调用，并用以下代码替换<code class="fe mw mx my mz b">case .success(let data):</code>代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="ee7e" class="nf ma iq mz b gy ng nh l ni nj">case .success(let data):<br/>   guard let data = data else {<br/>      return<br/>   }<br/>   do {<br/>      let users: [User]? = try JSONConverter.decode(data)<br/>      print(users)<br/>   } catch {<br/>      print(“Decoding error: \(error.localizedDescription)”)<br/>   }</span></pre><p id="cf86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们检查从网络调用返回的<code class="fe mw mx my mz b">data</code>对象不是<code class="fe mw mx my mz b">nil</code>，如果是，我们简单地返回(稍后我们将对此做更多的事情)。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="a3a8" class="nf ma iq mz b gy ng nh l ni nj">guard let data = data else {<br/>   return<br/>}</span></pre><p id="e6bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们进入一个<code class="fe mw mx my mz b">do/catch</code>块来捕捉解码器抛出的任何错误。然后，我们解码我们的数据:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="ebd4" class="nf ma iq mz b gy ng nh l ni nj">let users: [User]? = try JSONConverter.decode(data)</span></pre><p id="0346" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们调用上面创建的decode方法，并传入从服务器接收的数据。</p><p id="0829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将数据赋给一个<code class="fe mw mx my mz b">[Users]?</code>类型的变量，我们编写的通用解码方法在执行<code class="fe mw mx my mz b">JSONDecorder().decode(:)</code>调用时将使用这个<code class="fe mw mx my mz b">[Users]?</code>类型。如果您不熟悉泛型，这就是解码器如何知道将JSON解码成什么类型的对象。</p><p id="780f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在解码器里，我们写了行<code class="fe mw mx my mz b">JSONDecoder().decode([T].self, from: data)</code>。在运行时，该调用中的通用数组<code class="fe mw mx my mz b">[T]</code>被替换为<code class="fe mw mx my mz b">[User]?</code>类型。这一切都行得通，因为<code class="fe mw mx my mz b">Users</code>符合<code class="fe mw mx my mz b">Codable</code>。如果没有，那么这段代码就不会编译。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="9ad7" class="nf ma iq mz b gy ng nh l ni nj">   print(users)<br/>} catch {<br/>   print(“Decoding error: \(error.localizedDescription)”)<br/>}</span></pre><p id="2535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果解码过程没有抛出任何错误，我们将打印用户对象(稍后我们将解决Xcode抛出的警告)。如果有错误，我们将捕捉它并打印出来。</p><p id="6746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，回到JSON playground文件，再次执行代码。您应该会看到一个看起来非常混乱的数据列表，类似于:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="7647" class="nf ma iq mz b gy ng nh l ni nj">Optional([JSON_Sources.User(id: 1, name: Optional(“Leanne Graham”), username: Optional(“Bret”), email: Optional(“Sincere@april.biz”), phone: Optional(“1–770–736–8031 x56442”), website: Optional(“hildegard.org”), address: Optional(JSON_Sources.Address(street: Optional(“Kulas Light”), suite: Optional(“Apt. 556”), city: Optional(“Gwenborough”), zipcode: Optional(“92998–3874”), geo: Optional(JSON_Sources.Geo(lat: Optional(“-37.3159”), lng: Optional(“81.1496”))))), company: Optional(JSON_Sources.Company(name: Optional(“Romaguera-Crona”), catchPhrase: Optional(“Multi-layered client-server neural-net”))))</span></pre><p id="17bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜您，因为您刚刚将服务器的JSON数据转换成了我们的内部数据模型！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a85e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">家政</strong></h1><p id="53f3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们现在有一点清理工作要做。</p><p id="4156" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们的<code class="fe mw mx my mz b">UserAPI.getUsers()</code>方法不应该打印用户数据，相反，它应该将数据返回给调用代码。</p><p id="71d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mw mx my mz b">UserAPI.swift</code>文件，修改<code class="fe mw mx my mz b">getUsers()</code>方法的签名，使其与下面的匹配:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="3a68" class="nf ma iq mz b gy ng nh l ni nj">public static func getUsers(completionHandler: @escaping (Result&lt;[User]?, Error&gt;) -&gt; Void) {</span></pre><p id="575e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">getUsers(completionHandler:)</code>现在要做的是将成功/失败结果连同用户数据或错误数据一起返回到调用代码将分配的完成处理程序中。</p><p id="7759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，用下面这段代码替换<code class="fe mw mx my mz b">guard let data = data</code>代码块:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="2af7" class="nf ma iq mz b gy ng nh l ni nj">guard let data = data else {<br/>   completionHandler(.success(nil))<br/>   return<br/>}</span></pre><p id="cee7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有数据返回，我们会返回一个成功类型(只是因为服务器没有发回数据，所以调用还是成功的)带<code class="fe mw mx my mz b">nil</code>数据。接下来，将<code class="fe mw mx my mz b">print(users)</code>线替换为:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="a08e" class="nf ma iq mz b gy ng nh l ni nj">completionHandler(.success(users))</span></pre><p id="3576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并将<code class="fe mw mx my mz b">print(error.localizedDescription)</code>替换为:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="e81e" class="nf ma iq mz b gy ng nh l ni nj">completionHandler(.failure(error))</span></pre><p id="576f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的<code class="fe mw mx my mz b">getUsers(completionHandler:)</code>现在应该是这样的:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="3664" class="nf ma iq mz b gy ng nh l ni nj">public static func getUsers(completionHandler: @escaping (Result&lt;[User]?, Error&gt;) -&gt; Void) {<br/>   Networking.fetch(fromEndpoint: endpoint) { (result) in<br/>      switch result {<br/>      case .success(let data):<br/>         guard let data = data else {<br/>            completionHandler(.success(nil))<br/>            return<br/>         }<br/>         do {<br/>            let users: [User]? = try JSONConverter.decode(data)<br/>            completionHandler(.success(users))<br/>         } catch {<br/>            print(“Decoding error: \(error.localizedDescription)”)<br/>         }<br/>      case .failure(let error):<br/>         completionHandler(.failure(error))<br/>      }<br/>   }<br/>}</span></pre><p id="508d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到JSON playground文件，在<code class="fe mw mx my mz b">UserAPI.getUsers()</code>调用上面添加下面的方法:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="d009" class="nf ma iq mz b gy ng nh l ni nj">func printUser(_ user: User) {<br/>   var msg = “\(user.name ?? user.id.description)”<br/>   if let latitude = user.address?.geo?.lat,<br/>      let longitude = user.address?.geo?.lng {<br/>      msg += “ at coordinates \(latitude), \(longitude)”<br/>   }<br/>   print(msg)<br/>}</span></pre><p id="9016" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法将以一种更干净的方式打印出我们的一些用户数据。这里发生的不仅仅是一个漂亮的打印功能。</p><p id="8ada" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我特意选择打印出纬度和经度数据，因为它深埋在JSON数据中。看看现在访问这些数据是多么容易，因为它们已经被解码到我们的数据模型中。</p><p id="775c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了创建适当的结构来保存数据以及创建一个非常简单的解码器之外，我们不必做任何更复杂的事情。</p><p id="2ad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了获得用户名，我们调用<code class="fe mw mx my mz b">user.name</code>。很有道理。为了获得纬度数据，我们称之为<code class="fe mw mx my mz b">user.address?.geo?.lat</code>。我们现在可以用简单明了的点符号遍历服务器发送给我们的多层JSON数据。</p><p id="f6c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一直是开源JSON框架的主要卖点之一，但是现在您可以自己轻松地构建它。</p><p id="ea5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们用以下内容替换<code class="fe mw mx my mz b">UserAPI.getUsers()</code>呼叫:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="e557" class="nf ma iq mz b gy ng nh l ni nj">UserAPI.getUsers { (result) in<br/>   switch result {<br/>   case .success(let users):<br/>      guard let users = users else {<br/>         print(“No users were returned.”)<br/>         return<br/>      }<br/>      users.forEach({ (user) in<br/>         printUser(user)<br/>      })<br/>   case .failure(let error):<br/>      print(error.localizedDescription)<br/>   }<br/>}</span></pre><p id="1bd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们对<code class="fe mw mx my mz b">UserAPI.getUsers(completionHandler:)</code>的新调用中，完成块将获取发回的结果类型并对其进行处理。</p><p id="4ef8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果返回一个失败，我们将打印相关的错误。如果成功，我们将确保<code class="fe mw mx my mz b">Users</code>的可选数组确实包含用户，如果是这样，我们将遍历数组中的每个用户并打印出一些用户数据。</p><p id="e571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过执行代码，您现在应该得到以下内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="6c1f" class="nf ma iq mz b gy ng nh l ni nj">Leanne Graham at coordinates -37.3159, 81.1496<br/>Ervin Howell at coordinates -43.9509, -34.4618<br/>Clementine Bauch at coordinates -68.6102, -47.0653<br/>Patricia Lebsack at coordinates 29.4572, -164.2990<br/>Chelsey Dietrich at coordinates -31.8129, 62.5342<br/>Mrs. Dennis Schulist at coordinates -71.4197, 71.7478<br/>Kurtis Weissnat at coordinates 24.8918, 21.8984<br/>Nicholas Runolfsdottir V at coordinates -14.3990, -120.7677<br/>Glenna Reichert at coordinates 24.6463, -168.8889<br/>Clementina DuBuque at coordinates -38.2386, 57.2232</span></pre><p id="2203" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来不错！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ffc6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">符合您的数据模型</strong></h1><p id="e682" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">虽然这现在可以工作，我们可以让它保持原样，让我们继续改进它一点点。</p><p id="fcc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员可以承担的最重要也是最被低估的任务之一是让他们的代码可读。可读性可以减少混淆，并使将来为自己或其他开发人员阅读代码变得更加简单。</p><p id="562c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们看一下数据模型，我们有一个名为<code class="fe mw mx my mz b">Geo</code>的结构，它的<code class="fe mw mx my mz b">lat</code>和<code class="fe mw mx my mz b">lng</code>值与来自服务器的JSON数据完全匹配。虽然我们现在明白了这些意味着什么，但是通过改进它们，我们不会失去任何东西，并且变得清晰。</p><p id="f9f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们被服务器发送给我们的数据困住时，我们可以修改我们的内部模型。</p><p id="93da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将修改<code class="fe mw mx my mz b">Geo</code>以符合<code class="fe mw mx my mz b">CodingKey</code>协议。<code class="fe mw mx my mz b">CodingKey</code>允许我们在编码和解码时修改密钥，本质上是将服务器数据映射到我们自己的数据模型。</p><p id="cf3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了可读性，我们将把<code class="fe mw mx my mz b">lat</code>和<code class="fe mw mx my mz b">lng</code>的传入键改为<code class="fe mw mx my mz b">latitude</code>和<code class="fe mw mx my mz b">longitude</code>的内部键。修改<code class="fe mw mx my mz b">Geo</code>结构以匹配以下内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="3802" class="nf ma iq mz b gy ng nh l ni nj">public struct Geo: Codable {<br/>   public var latitude: String?<br/>   public var longitude: String?</span><span id="9296" class="nf ma iq mz b gy nk nh l ni nj">   enum CodingKeys: String, CodingKey {<br/>      case latitude = “lat”<br/>      case longitude = “lng”<br/>   }<br/>}</span></pre><p id="7a61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们设置<code class="fe mw mx my mz b">Geo</code>的属性来匹配我们内部想要的，在这个例子中，是可读性更好的<code class="fe mw mx my mz b">latitude</code>和<code class="fe mw mx my mz b">longitude</code>。</p><p id="76c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们创建一个名为<code class="fe mw mx my mz b">CodingKeys</code>的嵌入式枚举，它的类型是<code class="fe mw mx my mz b">String</code>，并且符合<code class="fe mw mx my mz b">CodingKey</code>。我们为每个<code class="fe mw mx my mz b">Geo</code>的属性设置一个case语句，并从JSON数据中分配匹配键值。</p><p id="6bbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当<code class="fe mw mx my mz b">Geo</code>的JSON数据包含<code class="fe mw mx my mz b">{“lat”: “123”, “lng”: “456”}</code>时，解码器将使用来自<code class="fe mw mx my mz b">CodingKeys</code>枚举的值将<code class="fe mw mx my mz b">lat</code>映射到<code class="fe mw mx my mz b">latitude</code>并将<code class="fe mw mx my mz b">lng</code>映射到<code class="fe mw mx my mz b">longitude</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/9e8c57e6ab56f924bc3f581f0fdfa632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSvvn_v2vzKnOpTJicqcuw.png"/></div></div></figure><p id="93f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，很好，但是如果我们只想将一些JSON键映射到新的内部键呢？</p><p id="a199" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在让我们通过从<code class="fe mw mx my mz b">Address</code>结构修改<code class="fe mw mx my mz b">geo</code>属性，并将其重命名为可读性更好的<code class="fe mw mx my mz b">coordinates</code>来实现。</p><p id="88a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，将<code class="fe mw mx my mz b">Geo</code>结构重命名为<code class="fe mw mx my mz b">Coordinates</code>:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="0073" class="nf ma iq mz b gy ng nh l ni nj">public struct Coordinates: Codable {</span></pre><p id="a34f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，在<code class="fe mw mx my mz b">Address</code>结构中，将<code class="fe mw mx my mz b">geo</code>属性重命名为<code class="fe mw mx my mz b">coordinates</code>:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="2aa1" class="nf ma iq mz b gy ng nh l ni nj">public var coordinates: Coordinates?</span></pre><p id="c56a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，将<code class="fe mw mx my mz b">CodingKeys</code>枚举添加到<code class="fe mw mx my mz b">Address</code>结构中:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="195b" class="nf ma iq mz b gy ng nh l ni nj">enum CodingKeys: String, CodingKey {<br/>   case coordinates = “geo”<br/>   <br/>   case street<br/>   case suite<br/>   case city<br/>   case zipcode<br/>}</span></pre><p id="e79e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们只提供了从内部模型坐标到JSON数据的<code class="fe mw mx my mz b">geo</code>键的映射。其余的键保持不变，因此没有为它们分配字符串。</p><p id="d712" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管我们没有创建显式映射，但是当您没有提供新的键值时，JSON值会有一个隐式映射。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/dc44cecc7a65315b1f681cfecf41145b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSAkRjnT2t2-trLBd_Zppw.png"/></div></div></figure><p id="0e88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是新的完整的<code class="fe mw mx my mz b">Address</code>和<code class="fe mw mx my mz b">Coordinates</code>结构:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="ef46" class="nf ma iq mz b gy ng nh l ni nj">public struct Address: Codable {<br/>    public var street: String?<br/>    public var suite: String?<br/>    public var city: String?<br/>    public var zipcode: String?<br/>    public var coordinates: Coordinates?<br/>    <br/>    enum CodingKeys: String, CodingKey {<br/>        case coordinates = "geo"<br/>        <br/>        case street<br/>        case suite<br/>        case city<br/>        case zipcode<br/>    }<br/>}</span><span id="be76" class="nf ma iq mz b gy nk nh l ni nj">public struct Coordinates: Codable {<br/>    public var latitude: String?<br/>    public var longitude: String?<br/>    <br/>    enum CodingKeys: String, CodingKey {<br/>        case latitude = "lat"<br/>        case longitude = "lng"<br/>    }<br/>}</span></pre><p id="6a75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，回到JSON playground，将<code class="fe mw mx my mz b">printUser(:)</code>函数中的<code class="fe mw mx my mz b">if</code>语句修改如下:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="d416" class="nf ma iq mz b gy ng nh l ni nj">if let latitude = user.address?.coordinates?.latitude,<br/>   let longitude = user.address?.coordinates?.longitude {<br/>   msg += “ at coordinates \(latitude), \(longitude)”<br/>}</span></pre><p id="4bfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那就可读性强多了！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="00ed" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">修改数据</strong></h1><p id="710c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们已经学习了如何使用JSON数据，但是现在，让我们看看如何修改这些数据。</p><p id="c4e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比方说，我们数据集中的第一个用户得到了一份新工作，我们想更新他们的数据。</p><p id="7747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JSON playground中的<code class="fe mw mx my mz b">users.forEach</code>循环之后的<code class="fe mw mx my mz b">UserAPI.getUsers(completionHandler:)</code>调用中添加以下代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="6cd0" class="nf ma iq mz b gy ng nh l ni nj">var modifiedUser = users[0]<br/>modifiedUser.company?.name = “Apple Inc.”<br/>modifiedUser.company?.catchPhrase = “We make iThings”<br/>modifiedUser.address?.street = “1 Infinite Loop”<br/>modifiedUser.address?.suite = nil<br/>modifiedUser.address?.city = “Cupertino”<br/>modifiedUser.address?.zipcode = “95014”<br/>modifiedUser.address?.coordinates?.latitude = “37.331586”<br/>modifiedUser.address?.coordinates?.longitude = “-122.029895”<br/>modifiedUser.website = “apple.com”<br/>printUser(modifiedUser)</span></pre><p id="74b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行playground，您应该会看到我们之前的用户列表加上一个用户。</p><p id="f35b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该看到，第一次打印时，第一个用户的坐标是“-37.3159，81.1496”，但第二次打印时，我们的新坐标是“37.331586，-122.029895”。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="d65a" class="nf ma iq mz b gy ng nh l ni nj">Leanne Graham at coordinates -37.3159, 81.1496<br/>…<br/>Leanne Graham at coordinates 37.331586, -122.029895</span></pre><p id="96e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，那很简单。</p><p id="f118" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要将更新后的用户发送回服务器。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ade8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">编码</strong></h1><p id="7dcc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在将它发送到服务器之前，我们需要对它进行编码，以便服务器可以使用它。</p><p id="b00b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mw mx my mz b">JSONConverter.swift</code>文件，在<code class="fe mw mx my mz b">decode(:)</code>函数后添加以下内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="d822" class="nf ma iq mz b gy ng nh l ni nj">public static func encode&lt;T: Encodable&gt;(_ value: T) throws -&gt; Data? {<br/>   do {<br/>      let data = try JSONEncoder().encode(value)<br/>      return data<br/>   } catch {<br/>      throw error<br/>   }<br/>}</span></pre><p id="3b34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们获取想要编码的值，并通过<code class="fe mw mx my mz b">JSONEncoder</code>运行它。</p><p id="ea2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们发送的值是一个符合<code class="fe mw mx my mz b">Codable</code>的<code class="fe mw mx my mz b">User</code>，通过扩展<code class="fe mw mx my mz b">Encodable</code>,<code class="fe mw mx my mz b">JSONEncoder</code>知道如何将我们的数据模型编码成JSON数据。然后，数据被返回给调用函数。</p><p id="2948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">UserAPI.swift</code>文件中，让我们创建一个函数来处理编码调用并随后发送回服务器。</p><p id="42bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">getUsers(completionHandler:)</code>功能后添加以下内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="6258" class="nf ma iq mz b gy ng nh l ni nj">public static func saveUser(_ user: User) {<br/>   do {<br/>      guard let data = try JSONConverter.encode(user) else {<br/>         return<br/>      }<br/>      let serialized = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any]<br/>      print(serialized?.description ?? “&lt;no serialized description&gt;”)<br/>   } catch {<br/>     print(“Encoding error: \(error.localizedDescription)”)<br/>   }<br/>}</span></pre><p id="c367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们调用刚刚创建的<code class="fe mw mx my mz b">encode</code>函数，并将输出保存到名为<code class="fe mw mx my mz b">data</code>的变量中。</p><p id="6008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，为了将它打印到控制台，以便您可以看到编码函数的输出，我们将JSON序列化<code class="fe mw mx my mz b">data</code>并将其打印出来。</p><p id="9e62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JSON playground文件中，在<code class="fe mw mx my mz b">printUser(modifiedUser)</code>行之后的<code class="fe mw mx my mz b">UserAPI.getUsers(completionHandler:)</code>完成块中，添加一个调用来保存修改后的用户:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="bf52" class="nf ma iq mz b gy ng nh l ni nj">UserAPI.saveUser(modifiedUser)</span></pre><p id="f786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行playground，您应该会看到修改后的用户数据被编码成JSON格式，如下所示:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="1596" class="nf ma iq mz b gy ng nh l ni nj">["id": 1,<br/> "username": Bret,<br/> "name": Leanne Graham,<br/> "phone": 1-770-736-8031 x56442,<br/> "address": {<br/>   city = Cupertino;<br/>   geo = {<br/>      lat = "37.331586";<br/>      lng = "-122.029895";<br/>   };<br/>   street = "1 Infinite Loop";<br/>   zipcode = 95014;<br/>  },<br/> "email": Sincere@april.biz, <br/> "website": apple.com, <br/> "company": {<br/>   catchPhrase = "We make iThings";<br/>   name = "Apple Inc.";<br/> }<br/>]</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d940" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">过账</strong></h1><p id="e235" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们就要完成了！我们现在需要做的就是将JSON编码的数据发送回服务器。</p><p id="7ac1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mw mx my mz b">Networking.swift</code>文件，在<code class="fe mw mx my mz b">fetch(fromEndpoint:completionHandler:)</code>函数后添加以下代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="37ef" class="nf ma iq mz b gy ng nh l ni nj">public static func post(toEndpoint endpoint: String, data: Data, completionHandler: @escaping ((Result&lt;Int, Error&gt;) -&gt; Void)) {<br/>   guard let url = URL(string: endpoint) else {<br/>      print(“Unable to generate url”)<br/>      return<br/>   }<br/>   let session = URLSession(configuration: .default)<br/>   var request = URLRequest(url: url)<br/>   request.httpMethod = “PUT”<br/>   request.httpBody = data<br/>   request.setValue(“application/json”, forHTTPHeaderField: “Content-Type”)<br/>   let task = session.dataTask(with: request) { (data, response, error) in<br/>      guard error == nil else {<br/>         completionHandler(Result.failure(error!))<br/>         return<br/>      }<br/>      completionHandler(Result.success((response as!    HTTPURLResponse).statusCode))<br/>   }<br/>   task.resume()<br/>}</span></pre><p id="0c18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像我们的<code class="fe mw mx my mz b">fetch(fromEndpoint:completionHandler:)</code>方法一样，理解<code class="fe mw mx my mz b">URLSession</code>的内部工作超出了本文的范围，但是我们将快速回顾一下这里发生了什么。</p><p id="fa0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先确保可以生成一个有效的<code class="fe mw mx my mz b">URL</code>。如果我们有了这个，那么我们创建一个默认的<code class="fe mw mx my mz b">URLSession</code>并用我们生成的<code class="fe mw mx my mz b">URL</code>创建一个<code class="fe mw mx my mz b">URLRequest</code>对象。</p><p id="79db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请求的默认<code class="fe mw mx my mz b">httpMethod</code>是一个<code class="fe mw mx my mz b">GET</code>，所以我们将把它改为一个<code class="fe mw mx my mz b">PUT</code>。然后，我们将JSON编码的数据对象添加到请求的<code class="fe mw mx my mz b">httpBody</code>中，并将“应用程序/json”的“内容类型”添加到请求的HTTP头中。</p><p id="2a22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从<code class="fe mw mx my mz b">request</code>创建一个<code class="fe mw mx my mz b">dataTask</code>，并给它一个完成处理程序，它将根据任务是成功还是失败来生成适当的结果类型。</p><p id="76a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些就绪后，我们调用<code class="fe mw mx my mz b">task</code>上的<code class="fe mw mx my mz b">resume</code>方法来发送我们的数据。</p><p id="e74f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们修改<code class="fe mw mx my mz b">UserAPI.swfift</code>文件中的<code class="fe mw mx my mz b">saveUser(:)</code>方法来调用我们的新<code class="fe mw mx my mz b">post(toEndpoint:data:completionHandler:)</code>方法。</p><p id="f528" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">print(serialized?.description ?? “&lt;no serialized description&gt;”)</code>后添加:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="5a97" class="nf ma iq mz b gy ng nh l ni nj">Networking.post(toEndpoint: “\(endpoint)/\(user.id)”, data: data) { (result) in<br/>   switch result {<br/>   case .success(let statusCode):<br/>      print(“Saved with code \(statusCode)”)<br/>   case .failure(let error):<br/>      print(“Unable to save: \(error.localizedDescription)”)<br/>   }<br/>}</span></pre><p id="7bf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们通过发送我们的<code class="fe mw mx my mz b">endpoint</code>并附加用户ID来调用我们的<code class="fe mw mx my mz b">post(toEndpoint:data:completionHandler:)</code>方法，以便服务器知道我们正在修改哪个用户。</p><p id="bfc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成处理程序将简单地向控制台输出一条适当的成功/失败消息。</p><p id="d79e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到JSON操场，执行代码。您应该在控制台中看到的最后一行是:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="edf6" class="nf ma iq mz b gy ng nh l ni nj">Saved with code 200</span></pre><p id="9dfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，由于我们使用的是公共JSON端点，服务器并没有真正保存我们的数据，而只是返回一个200。</p><p id="2f67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们调用另一个fetch来再次获取用户，您将看到我们修改的用户返回到原始数据，并且不包含我们修改的信息。然而，在真实的场景中，这将按预期工作。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="90ed" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">结论</strong></h1><p id="a0e6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本文的整个过程中，您了解了如何从服务器获取JSON数据，将其解码成您自己的内部数据模型，访问和修改该数据，将其编码回JSON数据，并将其发送回服务器。</p><p id="afe7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您学习了如何忽略不需要的数据，以及如何映射数据以适应您的内部数据模型。所有这些都不需要我们从Swift基础框架中获得的任何外部依赖，也没有混乱的解析代码。</p><p id="142b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我鼓励您更深入地研究Codable协议，因为您可以用它做更多的事情，而不仅仅是从服务器获取和发送JSON数据。</p><p id="afc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，您可以使用它轻松编码/解码要在设备上本地保存的数据模型，如用户设置或其他有用的应用程序数据。</p><p id="baae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在GitHub 上的<a class="ae kv" href="https://github.com/CoreyWDavis/File" rel="noopener ugc nofollow" target="_blank">文件项目，我在之前的文章</a><a class="ae kv" href="https://medium.com/@CoreyWDavis/reading-writing-and-deleting-files-in-swift-197e886416b0" rel="noopener"> <em class="nm">中提到过，在Swift </em> </a>中读取、写入和删除文件，它依靠Codable来读取和保存数据。</p><p id="9398" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您已经有了一些使用Codable的经验，摆脱这些依赖，开始用您自己的、可维护的代码来处理JSON！</p><p id="60da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在GitHub 上找到<a class="ae kv" href="https://github.com/CoreyWDavis/JSON-Without-Dependencies" rel="noopener ugc nofollow" target="_blank">完整的游乐场源代码。</a></p></div></div>    
</body>
</html>