<html>
<head>
<title>How to Add Editable HTML Content to a React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何向React应用程序添加可编辑的HTML内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-add-editable-html-content-to-a-react-app-c98564856761?source=collection_archive---------2-----------------------#2022-12-22">https://betterprogramming.pub/how-to-add-editable-html-content-to-a-react-app-c98564856761?source=collection_archive---------2-----------------------#2022-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e030" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何将contentEditable与React结合使用，以支持交互式可编辑内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9fe9049a8d4a58593571adf2889bc231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dcjb15gzVR-USEqN"/></div></div></figure><p id="89fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你有没有想过像<a class="ae lq" href="http://docs.google.com" rel="noopener ugc nofollow" target="_blank"> Google Docs </a>或<a class="ae lq" href="http://notion.so" rel="noopener ugc nofollow" target="_blank">concept</a>这样的应用是如何在网络应用中实现交互式、可编辑的丰富内容的？使用像<code class="fe lr ls lt lu b">textarea</code>这样的输入来构建表单的通常方法不能提供同样的体验。</p><p id="f646" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，像这样的应用程序利用HTML的<code class="fe lr ls lt lu b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable" rel="noopener ugc nofollow" target="_blank">contentEditable</a></code>属性，允许用户直接编辑页面上的内容。虽然启用内容编辑就像设置<code class="fe lr ls lt lu b">contentEditable</code>属性一样简单，但实际上将其集成到应用程序中并从中获取可用数据却是另一回事。</p><p id="5590" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">特别是，如果你尝试过在<a class="ae lq" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>中使用contentEditable，你会很快意识到这两者不能很好地配合——至少，没有一点额外的工作。在本帖中，我们将了解如何将<code class="fe lr ls lt lu b">contentEditable</code>与React结合使用，以在React应用中实现可编辑的交互式内容。</p><h1 id="98f7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是内容可编辑？</h1><p id="96f5" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><code class="fe lr ls lt lu b">contentEditable</code>是一个属性，可以放在HTML元素上，让用户可以编辑内容。我们可以通过下面的HTML片段演示如何使用<code class="fe lr ls lt lu b">contentEditable</code>:</p><pre class="kj kk kl km gt ms lu mt bn mu mv bi"><span id="7071" class="mw lw it lu b be mx my l mz na">&lt;div style="border: 1px solid #ccc; padding: 8px" contentEditable&gt; <br/>  &lt;h4&gt;Editable Content - Edit Me!&lt;/h4&gt; <br/>  &lt;p&gt;This piece of content has the contentEditable attribute set.&lt;/p&gt; <br/>&lt;/div&gt;</span></pre><p id="0b0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，使用<code class="fe lr ls lt lu b">contentEditable</code>进行编辑很简单，但并不总是<em class="nb">容易</em>使用你的应用程序。为了用<code class="fe lr ls lt lu b">contentEditable</code>完整地构建一个应用程序，你需要以某种方式解决以下问题。</p><ul class=""><li id="cc96" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated">为更新的内容添加更改处理程序</li><li id="7b21" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">添加对编辑内容的验证和净化</li><li id="aad0" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">添加内部数据表示的翻译(大多数应用程序不存储内容的原始HTML)</li><li id="e6b7" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">使内容可编辑与应用程序数据生命周期的其余部分配合良好</li></ul><p id="6923" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后这一点对于React- <code class="fe lr ls lt lu b">contentEditable</code>和React conflict来说是一个特殊的挑战，因为它们管理和更新DOM状态的方式不同。</p><h1 id="1e7c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在React中使用contentEditable有哪些挑战？</h1><p id="5fc3" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">在用React查看<code class="fe lr ls lt lu b">contentEditable</code>之前，让我们快速看一下如何用<code class="fe lr ls lt lu b">textarea</code>实现<em class="nb">非富</em>文本编辑:</p><pre class="kj kk kl km gt ms lu mt bn mu mv bi"><span id="c06d" class="mw lw it lu b be mx my l mz na">const TextAreaEditable = () =&gt; { <br/>  const [content, setContent] = React.useState("") <br/>  return ( <br/>    &lt;textarea value={content} onChange={e =&gt; setContent(e.currentTarget.value)} /&gt; <br/>  ) <br/>}</span></pre><p id="5748" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果我们试图在React应用程序中对<code class="fe lr ls lt lu b">contentEditable</code>内容采用这种模式，我们很快就会遇到错误、警告和意外行为。让我们来看看为<code class="fe lr ls lt lu b">contentEditable</code>改编上述代码的一个幼稚尝试:</p><pre class="kj kk kl km gt ms lu mt bn mu mv bi"><span id="c449" class="mw lw it lu b be mx my l mz na">🚫 Our naive attempt at using contentEditable: <br/><br/>const Editable = () =&gt; { <br/>  const [content, setContent] = React.useState("") <br/>  return ( <br/>    &lt;div onBlur={t =&gt; setContent(t.currentTarget.innerHTML)} contentEditable&gt;<br/>      {content} <br/>    &lt;/div&gt; <br/>  ) <br/>}</span></pre><p id="daea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们查看控制台，我们会在呈现页面时看到以下警告:</p><blockquote class="nq nr ns"><p id="1b86" class="ku kv nb kw b kx ky ju kz la lb jx lc nt le lf lg nu li lj lk nv lm ln lo lp im bi translated"><em class="it">警告:一个组件是</em> <code class="fe lr ls lt lu b"><em class="it">contentEditable</em></code> <em class="it">并且包含由React管理的</em> <code class="fe lr ls lt lu b"><em class="it">children</em></code> <em class="it">。现在，您有责任保证这些节点不会被意外修改或复制。这大概不是故意的。</em></p></blockquote><p id="135b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">问题是启用了<code class="fe lr ls lt lu b">contentEditable</code>后，React和浏览器都想处理元素内部内容的状态。此外，当我们开始编辑内容时，我们会遇到一些其他问题。</p><p id="c978" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我开始编辑内容，并按下command-B来加粗我正在编辑的一些文本，我会注意到两件事:</p><p id="d6f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先——它有效！-不需要做任何特殊处理，我们就能从交互式编辑器中进行文本样式操作。</p><p id="2323" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我注意到的第二件事是，当视图模糊和状态更新发生时，我的文本变成了一堆HTML！我没有看到文本“1 <strong class="kw iu"> 2 </strong> 3”，而是看到了<code class="fe lr ls lt lu b">1&lt;span style="font-weight: bold;"&gt;2&lt;/span&gt;3</code></p><p id="8c58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这不是我们想要的！</p><p id="1c83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，问题是我们的内容字符串是纯HTML，但是我们试图通过将它作为<code class="fe lr ls lt lu b">div</code>的子元素传递来在React中呈现它。React不会将这些子元素解释为HTML，而是对内容进行转义。</p><h1 id="ba64" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">危险的解决方案</h1><p id="9a0b" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">为了让我们的<code class="fe lr ls lt lu b">contentEditable</code>组件正确工作，我们需要告诉React呈现一个HTML字符串，而不是纯文本。幸运的是，这样的技术是存在的，但它有一个听起来很吓人的名字:<code class="fe lr ls lt lu b"><a class="ae lq" href="https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml" rel="noopener ugc nofollow" target="_blank">dangerouslySetInnerHTML</a></code>。</p><p id="4103" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">属性可以用来设置元素的内部HTML，让我们重写我们的组件:</p><pre class="kj kk kl km gt ms lu mt bn mu mv bi"><span id="eb12" class="mw lw it lu b be mx my l mz na">✅ Our second attempt at using contentEditable: const Editable = () =&gt; { const [content, setContent] = React.useState("") const onContentBlur = React.useCallback(evt =&gt; setContent(evt.currentTarget.innerHTML)) return ( &lt;div contentEditable onBlur={onContentBlur} dangerouslySetInnerHTML={{__html: content} /&gt; ) }</span></pre><p id="6bf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顾名思义，<code class="fe lr ls lt lu b">dangerouslySetInnerHTML</code>就是<em class="nb">危险。</em>为什么？因为未经组织的HTML输入可能存在安全风险，并使用户面临跨站点脚本(XSS)攻击。想象一下，我们正在使用<code class="fe lr ls lt lu b">contentEditable</code>来实现用户之间的协作。如果我们不小心，攻击者可能会在内容中嵌入JavaScript，当使用<code class="fe lr ls lt lu b">dangerouslySetInnerHTML</code>时，这些内容将在受害者的浏览器中执行。</p><p id="7410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当使用<code class="fe lr ls lt lu b">contentEditable</code>和<code class="fe lr ls lt lu b">dangerouslySetInnerHTML</code>时，总是<em class="nb">建议使用某种形式的输入净化。这个包<code class="fe lr ls lt lu b"><a class="ae lq" href="https://www.npmjs.com/package/sanitize-html" rel="noopener ugc nofollow" target="_blank">sanitize-html</a></code>可以帮助执行一组白名单HTML标签来阻止XSS攻击。</em></p><pre class="kj kk kl km gt ms lu mt bn mu mv bi"><span id="4db7" class="mw lw it lu b be mx my l mz na">✅ Sanitized HTML with contentEditable: <br/><br/>import sanitizeHtml from "sanitize-html" <br/><br/>const Editable = () =&gt; { <br/>  const [content, setContent] = React.useState("") <br/>  const onContentBlur = React.useCallback(evt =&gt; { <br/>    const sanitizeConf = { <br/>      allowedTags: ["b", "i", "a", "p"], <br/>      allowedAttributes: { a: ["href"] } <br/>    }<br/>    setContent(sanitizeHtml(evt.currentTarget.innerHTML, sanitizeConf)) <br/>  }, [setContent]) <br/>  return ( <br/>    &lt;div contentEditable onBlur={onContentBlur} dangerouslySetInnerHTML={{__html: content}} /&gt; <br/>  ) <br/>}</span></pre><p id="08d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，要确保您的应用程序不受XSS攻击，仅在编辑期间进行验证是不够的。您还需要净化和验证服务器端的内容或从服务器返回的内容！如果你只是在用户编辑内容时进行清理，聪明的攻击者可以绕过安全检查，直接向服务器发送不安全的数据。</p><h1 id="dad6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何使用react-contenteditable</h1><p id="0dbb" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">虽然上面的基本方法允许您在React应用程序中使用<code class="fe lr ls lt lu b">contentEditable</code>，但是当您开始在应用程序中实现功能时，您可能会注意到一些边缘情况。具体来说，如果在模糊事件之前向<code class="fe lr ls lt lu b">div</code>添加额外的事件处理程序来捕获输入，您可能会看到光标跳跃和其他不良行为。这是因为需要一点额外的逻辑来确定<em class="nb">何时</em>实际修改内容状态并触发重新呈现。</p><p id="ae52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然我们可以在组件中添加一个解决这个问题和其他边缘情况的方法，而不会给<em class="nb">带来太多麻烦，但是为什么要重新发明轮子呢？<code class="fe lr ls lt lu b"><a class="ae lq" href="https://www.npmjs.com/package/react-contenteditable" rel="noopener ugc nofollow" target="_blank">react-contenteditable</a></code>包解决了您在React应用程序中可能遇到的大多数常见问题。</em></p><p id="9146" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用这个包是对我们前面例子的一个非常简单的改变:</p><pre class="kj kk kl km gt ms lu mt bn mu mv bi"><span id="5e28" class="mw lw it lu b be mx my l mz na">✅ Sanitized HTML with the ContentEditable package: <br/><br/>import sanitizeHtml from "sanitize-html" <br/>import ContentEditable from 'react-contenteditable' <br/><br/>const Editable = () =&gt; { <br/>  const [content, setContent] = React.useState("") <br/>  const onContentChange = React.useCallback(evt =&gt; { <br/>    const sanitizeConf = { <br/>      allowedTags: ["b", "i", "a", "p"], <br/>      allowedAttributes: { a: ["href"] } <br/>    } <br/>    setContent(sanitizeHtml(evt.currentTarget.innerHTML, sanitizeConf)) <br/>  }, [setContent]) <br/><br/>  return ( <br/>    &lt;ContentEditable onChange={onContentChange} onBlur={onContentChange} html={content} /&gt; <br/>  ) <br/>}</span></pre><p id="2dae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用<code class="fe lr ls lt lu b">sanitize-html</code>和<code class="fe lr ls lt lu b">react-contenteditable</code>，我们可以在React应用中快速构建丰富的交互式内容编辑的基础。</p><h1 id="a5c7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">总结</h1><p id="da7a" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">在这篇文章中，我们学习了一些如何在React应用中添加用户可编辑的内容。主要考虑因素是:</p><ul class=""><li id="9902" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated"><code class="fe lr ls lt lu b">contentEditable</code>在React中需要一些特殊的处理。</li><li id="cfc6" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe lr ls lt lu b"><a class="ae lq" href="https://www.npmjs.com/package/react-contenteditable" rel="noopener ugc nofollow" target="_blank">react-contenteditable</a></code>包可以帮助处理您可能遇到的边缘情况。</li><li id="9e93" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">编辑<em class="nb">和</em>时，记得在呈现不可信的内容之前净化HTML。<code class="fe lr ls lt lu b"><a class="ae lq" href="https://www.npmjs.com/package/sanitize-html" rel="noopener ugc nofollow" target="_blank">sanitize-html</a></code>包可以在这方面有所帮助。</li></ul><p id="70ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用这种简单的方法，您可以开始向任何React应用程序添加可编辑的内容！</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="2c50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nb">原载于2022年12月22日https://blixtdev.com</em><a class="ae lq" href="https://blixtdev.com/how-to-use-contenteditable-with-react/" rel="noopener ugc nofollow" target="_blank"><em class="nb"/></a><em class="nb">。</em></p></div></div>    
</body>
</html>