<html>
<head>
<title>Coding Tic Tac Toe in C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C语言编码井字游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/programming-tic-tac-toe-in-c-6ba4b6965ba3?source=collection_archive---------1-----------------------#2022-04-21">https://betterprogramming.pub/programming-tic-tac-toe-in-c-6ba4b6965ba3?source=collection_archive---------1-----------------------#2022-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fc90" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">C语言编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5c0cf38823163f8e5e7d621476a35f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5x7v16DHERztbpViS0jCA.png"/></div></div></figure><p id="8063" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编程井字游戏是一个初学者级别的练习，世界上许多Python学习者都在练习，包括我自己。c语言是我的主要编程语言，我想试试看我能否用c语言构建同样的游戏。</p><p id="4445" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一步是决定如何实现游戏。为此，我需要5个不同的功能；</p><ul class=""><li id="9246" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">显示表(板)的功能</li><li id="4aeb" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">函数将“X”或“O”插入到表格中</li><li id="6d44" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">一个功能，检查是否有人赢了</li><li id="95d6" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">检查平局的函数</li><li id="9036" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">帮助转弯的附加功能</li></ul><p id="bb0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这个大纲，第一件事就是在我的主要职能范围内创建董事会；</p><pre class="kg kh ki kj gt mb mc md me aw mf bi"><span id="236e" class="mg mh iq mc b gy mi mj l mk ml">char board[] = { ‘-’,’-’,’-’,’-’,’-’,’-’,’-’,’-’,’-’ };</span></pre><p id="ac21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个元素中的连字符表示那里的单元格是空的，我们稍后会用到它。</p><p id="aac4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，我们编写我们的表格显示函数如下所示；</p><pre class="kg kh ki kj gt mb mc md me aw mf bi"><span id="5f64" class="mg mh iq mc b gy mi mj l mk ml">void display_table(char board[]) {                              <br/>   int i;<br/>   for (i = 0; i &lt; 9; i++) {<br/>      printf("%c ", board[i]);<br/>      if (((i + 1) % 3) == 0) {<br/>         printf("\n");<br/>      }<br/>   }<br/>}</span></pre><p id="9877" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们在输出每3个单元格后打印一个新行。我们这样做是为了在游戏板上创建下一行。当我们测试我们的函数时，输出应该是这样的。</p><pre class="kg kh ki kj gt mb mc md me aw mf bi"><span id="ba92" class="mg mh iq mc b gy mi mj l mk ml">- - -<br/>- - -<br/>- - -</span></pre><p id="6589" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这之后，我们希望能够发挥作用，因此“插入”功能。insert函数将获取轮到谁了(即“X”或“O”)，并简单地将其插入给定索引的单元格中，如下所示；</p><pre class="kg kh ki kj gt mb mc md me aw mf bi"><span id="3cd8" class="mg mh iq mc b gy mi mj l mk ml">...</span><span id="c085" class="mg mh iq mc b gy mm mj l mk ml">//We write this inside our main function to store who's turn it is<br/>char turn = 'X';<br/>...</span><span id="fd90" class="mg mh iq mc b gy mm mj l mk ml">void insert(char board[],char *turn) {<br/>   int index;<br/>   printf("Turn of %c\nEnter index : ", *turn);<br/>   scanf("%d", &amp;index);<br/>   if (index == SENTINEL) {<br/>      exit(0);<br/>   } <br/>   board[index - 1] = *turn;<br/>}</span></pre><p id="7b83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:作为程序中的一个出口，我在实现中定义了一个SENTINEL值-999。这一步是可选的。</p><p id="61dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在一个玩家玩完他/她的回合后，我们需要切换到另一个玩家。这就是切换转弯功能的用武之地；</p><pre class="kg kh ki kj gt mb mc md me aw mf bi"><span id="db65" class="mg mh iq mc b gy mi mj l mk ml">void switch_turn(char *turn) {<br/>   if (*turn == 'X') {*turn = 'O';}<br/>   else {*turn = 'X';}<br/>}</span></pre><p id="d59c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个函数相当简单。如果玩家“X”已经玩了他/她的回合，则“O”的值被分配给回合变量。如果玩家“O”已经玩了他/她的回合，则“X”的值被分配给它。</p><p id="8dc8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步是检查是否有玩家赢了，这一步实际上比大多数尝试这一步的人一开始所想的要简单得多。我们先总结一下赢的条件；</p><ul class=""><li id="b7f3" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">一名玩家将他/她的3个符号水平放置在同一行</li><li id="79ce" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">一名玩家将他/她的3个符号垂直放置在同一列上</li><li id="06b3" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">一名玩家将他/她的3个符号对角放置在其中一个轴上</li></ul><p id="b7a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了检查是否满足这些条件，我们可以使用它们各自的索引(如下所示)检查每个单元格，以检查它们是否匹配。</p><ul class=""><li id="db40" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">对于水平:(0，1，2)，(3，4，5)，(6，7，8)</li><li id="dcc2" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">对于垂直:(0，3，6)，(1，4，7)，(2，5，8)</li><li id="e340" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">对于对角线:(0，4，8)，(2，4，6)</li></ul><p id="b474" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果这些指数组中的任何一组中的字符匹配，我们就可以说玩家赢了。我们使用下面的函数来实现这一点:</p><pre class="kg kh ki kj gt mb mc md me aw mf bi"><span id="d66d" class="mg mh iq mc b gy mi mj l mk ml">bool check_win(char board[]) {<br/>   bool win = false;</span><span id="71fd" class="mg mh iq mc b gy mm mj l mk ml">//Row 1<br/>   if (board[0] != '-') {<br/>      if (board[0] == board[1]) {<br/>         if (board[0] == board[2]) {<br/>            win = true;<br/>         }<br/>      }<br/>   }</span><span id="6f72" class="mg mh iq mc b gy mm mj l mk ml">...</span><span id="1267" class="mg mh iq mc b gy mm mj l mk ml">//Column 1<br/>   if (board[0] != '-') {<br/>      if (board[0] == board[3]) {<br/>         if (board[0] == board[6]) {<br/>            win = true;<br/>         }<br/>      }<br/>   }</span><span id="3e03" class="mg mh iq mc b gy mm mj l mk ml">...</span><span id="96d7" class="mg mh iq mc b gy mm mj l mk ml">//Axis 1<br/>   if (board[0] != '-') {<br/>      if (board[0] == board[4]) {<br/>         if (board[0] == board[8]) {<br/>            win = true;<br/>         }<br/>      }<br/>   }</span><span id="77b6" class="mg mh iq mc b gy mm mj l mk ml">...</span><span id="5ad3" class="mg mh iq mc b gy mm mj l mk ml">return win;<br/>}</span></pre><p id="e09b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个函数中，我们用win变量来表示是否满足了任何条件。</p><p id="639f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在每个条件的开始，我们检查每个组的第一个单元格是否为空(等于“-”)。如果它是空的，我们不检查该组。如果不是空的，我们要做的是检查每组中的单元格是否包含相同的字符。</p><p id="d14f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，真正的布尔值被分配给win变量，它被返回以指示玩家是否已经赢了。</p><p id="7aba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们需要检查听牌。为此，我们需要创建一个变量来存储在我们的主函数中已经玩了多少回合。之后，我们将简单地检查已经玩了多少回合。如果少于9，那么游戏可以继续。如果所有9个单元格都满了(意味着已经过了9轮)，游戏将产生平局。</p><pre class="kg kh ki kj gt mb mc md me aw mf bi"><span id="0b43" class="mg mh iq mc b gy mi mj l mk ml">...<br/>int turn_count = 0;<br/>...<br/>bool check_draw(int turn_count) {<br/>   if (turn_count &lt; 9) {<br/>      return false;<br/>   }<br/>   else {<br/>      return true;<br/>   }<br/>}</span></pre><p id="f3f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这最后一个函数之后，我们需要在我们的主函数中取整这些函数，来完成游戏。</p><p id="fbf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的主函数中，我们将创建一个游戏变量，该变量将被赋予真实值。之后，我们将使用游戏变量作为条件创建一个无限while循环。首先在这个循环中，我们将展示棋盘，让其中一个玩家使用他们的回合。在一个玩家使用他/她的回合后，我们将检查是否有任何玩家赢了，或者游戏的结果是平局。如果两个条件都不满足，回合将会转换，下一个玩家将被提示使用他/她的回合。</p><pre class="kg kh ki kj gt mb mc md me aw mf bi"><span id="c46b" class="mg mh iq mc b gy mi mj l mk ml">int main() {<br/>   char turn = 'X', board[] = { '-','-','-','-','-','-','-','-','-' };<br/>   bool game = true;<br/>   int turn_count = 0;</span><span id="fbc1" class="mg mh iq mc b gy mm mj l mk ml">   while (game) {<br/>      display_table(board);<br/>      insert(board, &amp;turn);<br/>      turn_count++;<br/>      //We check for a win<br/>      if (check_win(board)) {<br/>         display_table(board);<br/>         printf("%c Wins!!!", turn);<br/>         getch();<br/>         exit(0);<br/>      }<br/>      //We check for a draw<br/>      if (check_draw(turn_count)) {<br/>         display_table(board);<br/>         printf("Draw!!!");<br/>         getch();<br/>         exit(0);<br/>      }<br/>      switch_turn(&amp;turn);<br/>   }<br/>}</span></pre><p id="96dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整代码可在以下网址找到:</p><div class="mn mo gp gr mp mq"><a href="https://github.com/dekaottoman/tic-tac-toe-C" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">GitHub-dekaotoman/井字游戏</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne kp mq"/></div></div></a></div></div></div>    
</body>
</html>