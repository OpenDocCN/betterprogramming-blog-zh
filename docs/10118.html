<html>
<head>
<title>Why Functional Programmers Prefer For-Comprehension Over Imperative Code Blocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么函数式程序员更喜欢For-comprehensive而不是命令式代码块</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-functional-programmers-prefer-for-comprehension-over-imperative-code-blocks-7f2cebc34d15?source=collection_archive---------3-----------------------#2021-12-01">https://betterprogramming.pub/why-functional-programmers-prefer-for-comprehension-over-imperative-code-blocks-7f2cebc34d15?source=collection_archive---------3-----------------------#2021-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="10c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简而言之:可读性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/95d4ed3cdbba58604ff1da137ec4b493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lRF1j9wE_M4StT7r"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@azganmjeshtri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> AZGAN MjESHTRI </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ba9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">"为什么你把所有的东西都包装成一个效果，然后在这里放一个森林？"—另一个团队的一位高级工程师对我的第二次代码评审发表了评论。我查看了一下代码，首先出现在我脑海中的是，“因为它是可读的。”</p><p id="63c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可读性是很主观的。来自命令式编程领域并习惯于Java 8 API流式语法的人会说，用for-comprehensive对程序排序会使其更难阅读。另一方面，函数式程序员会认为Java 8 API类似流的语法更难跟踪代码的效果。因此，我试图找到一个更客观的观点来解释为什么它是可读的。</p><h1 id="4865" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">看起来像伪代码</h1><p id="2b12" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">For-comprehension与Haskell monad comprehension非常相似。</p><p id="5027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解是<code class="fe ms mt mu mv b">flatMap</code>的语法糖。</p><p id="5b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">flatMap</code>代表顺序计算，是Monad的主要特质。因此，设计者Scala使用单子进行集合操作。</p><p id="5514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scala中的单子理解被设计成类似于一般C/伪代码语言中的命令式<code class="fe ms mt mu mv b">for</code>循环。为什么？所以它看起来像是命令式的顺序副作用代码块，就像C风格的语言。用于赋值的左数组在命令式伪代码中是典型的。因此，它创造了更好的可读性。</p><p id="5c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Scala和Haskell在理解语法上有所不同——它能做的不仅仅是执行两个一元运算<code class="fe ms mt mu mv b">join</code>和<code class="fe ms mt mu mv b">bind</code>(或者<code class="fe ms mt mu mv b">map</code>和<code class="fe ms mt mu mv b">flatMap</code>)。</p><p id="97eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Scala中，没有<code class="fe ms mt mu mv b">yield</code>的<code class="fe ms mt mu mv b">for</code>理解翻译成<code class="fe ms mt mu mv b">foreach</code>。<code class="fe ms mt mu mv b">foreach</code>是产生副作用的命令式迭代。一个<code class="fe ms mt mu mv b">yield</code>可以有一个保护，<code class="fe ms mt mu mv b">yield bar if baz</code>，它转化为过滤元素。</p><p id="d64f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅这个原因并不能给出一个好的理由来解释为什么你更喜欢<code class="fe ms mt mu mv b">for</code>理解而不是一般的Java代码块。然而，因为for-comprehension等价于monad comprehension，所以您可以确保您的代码按顺序运行。</p><h1 id="7adf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">实施顺序操作</h1><p id="2d98" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">除非你使用<code class="fe ms mt mu mv b">IO</code>，否则在你的函数中使用多重<a class="ae ky" href="https://edward-huang.com/functional-programming/scala/monad/2020/06/21/what-is-effect-or-effectful-mean-in-functional-programming/" rel="noopener ugc nofollow" target="_blank">效果</a>很难在不理解的情况下进行调试。</p><p id="2502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个例子，如果您有一个函数，它对多个API调用进行排序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a6ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码中，您可以看到您用<code class="fe ms mt mu mv b">flatMap</code>对多个API调用进行了排序。但是，您正在进行并行调用，而不是顺序调用。</p><p id="7b38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">未来是渴望的。这意味着一旦你实例化了这个值，它将触发一个线程并执行未来的内容。</p><p id="cd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与将每个效果包装在for-comprehension中相比，它强制任何效果按顺序执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用for-comprehension和effects的另一个好处是，另一个开发人员可以很容易地快速浏览代码库并理解您的程序的意图，而无需了解未来如何工作。您不需要猜测这个模块是顺序运行还是并行运行。</p><p id="21b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码看起来非常简单，因为我们只是在做简单的API获取调用。然而，如果我们有一个嵌套效应会发生什么呢？比如调用一个会返回<code class="fe ms mt mu mv b">Future[Option[Int]]</code>或者<code class="fe ms mt mu mv b">Future[Future[Future[_]]]</code>的API？</p><h1 id="180c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用嵌套效果增加可读性</h1><p id="e999" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果不理解的话，你会看到这样的东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="df45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，如果有更多的顺序调用，上面的代码行将会向右移动—就像回调地狱一样。</p><p id="d357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于for-comprehension，它有助于减少嵌套调用效果的数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用monad transformer上的<code class="fe ms mt mu mv b">cats.data</code>集合，并使用for-comprehension来计算多个嵌套的情感调用。for-comprehension有助于减少嵌套调用的数量，使其看起来像一个顺序调用。</p><p id="d258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种面向铁路的编程。使用面向铁路的编程，您可以在一个地方分离所有效果的所有错误处理——保持主要逻辑像伪代码一样。</p><h1 id="ea5f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">这都是基于你的风格指南</h1><p id="74c8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在PR中说服理解性代码块相对于常规代码块的好处，因为它完全基于你团队的风格指南。</p><p id="76fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果所有开发人员都认为编写常规代码块比理解更具可读性，那么编写代码块是更可取的。</p><p id="6c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以我为例，另一个开发者也评论了，在他的评论上“加1”。但是，我并不完全同意这个解释。该团队更喜欢用命令式代码块风格编写代码，而不是用<code class="fe ms mt mu mv b">for</code>理解。</p><p id="813e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最终对首选的风格指南进行了修改。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="f1c3" class="lv lw it bd lx ly nf ma mb mc ng me mf jz nh ka mh kc ni kd mj kf nj kg ml mm bi translated">来源</h1><ul class=""><li id="5055" class="nk nl it lb b lc mn lf mo li nm lm nn lq no lu np nq nr ns bi translated"><a class="ae ky" href="https://softwareengineering.stackexchange.com/questions/307565/why-does-scala-name-monadic-composition-as-for-comprehension" rel="noopener ugc nofollow" target="_blank">编程语言Scala为什么把一元合成命名为“为了理解”？—软件工程栈交换</a></li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="95e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">最初发表于</em><a class="ae ky" href="https://edward-huang.com/scala/functional-programming/2021/11/30/why-do-functional-programmers-prefer-for-comprehension-over-imperative-code-block/" rel="noopener ugc nofollow" target="_blank">T5【https://edward-huang.com】</a><em class="nt">。</em></p></div></div>    
</body>
</html>