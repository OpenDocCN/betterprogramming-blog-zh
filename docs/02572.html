<html>
<head>
<title>Angular Application With Loaders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">装载机的角度应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-application-with-loaders-216390c6da92?source=collection_archive---------13-----------------------#2019-12-09">https://betterprogramming.pub/angular-application-with-loaders-216390c6da92?source=collection_archive---------13-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="55d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在显示内容之前，让用户知道您的应用程序正在加载</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4eb33f75e7419790c14c3c8d8907ef1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hi7euM223Sr-9PIi1Pk7ng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载时如何生成图像。io</p></figure><h1 id="a9d6" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">为什么您应该总是使用装载机</h1><p id="d55b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">加载器，也称为加载指示器，在几个方面有所帮助。</p><p id="72a4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">首先，用户不必盯着空白的屏幕等待你的应用程序启动。盯着空白页看太久会让人怀疑这一页是否有效。这可能会导致用户刷新页面—您的整个应用程序又要从头开始下载。这可能会造成永无止境的挫败感。最终用户可能会离开你的网站，我们不希望这样！我们希望快乐的用户会留下来，是忠诚的！</p><p id="0bf6" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">其次，加载器防止在加载资源时页面上显示持续的变化。这些微小的变化会扰乱布局——页面会闪烁、改变颜色和字体，或者元素会改变位置。如果其中一个元素的加载时间比另一个长，用户的操作可能会被中断。同样，这会导致沮丧和负面情绪，导致用户不再希望使用该应用程序。</p><p id="bd9a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们继续看看如何实现加载器并让我们的用户满意！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="ed13" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated">初始加载屏幕</h1><p id="9281" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当应用程序正在下载并且<code class="fe nd ne nf ng b">app-root</code>标签仍然为空时，可以显示第一个加载屏幕。我们可以通过在<code class="fe nd ne nf ng b">index.html</code>文件中添加<code class="fe nd ne nf ng b">style</code>元素，用一些CSS技巧来实现这一点:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="d7ff" class="nl kz it ng b gy nm nn l no np">&lt;style type="text/css"&gt;<br/>  app-root:empty::after {<br/>    content: "Loading...";<br/>    position: absolute;<br/>    display: block;<br/>    top: 50%;<br/>    left: 50%;<br/>    font-size: 20px;<br/>    transform: translate(-50%, -50%);<br/>  }<br/>&lt;/style&gt;</span></pre><p id="6fa6" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它检查我们的<code class="fe nd ne nf ng b">app-root</code>元素是否为空，并显示<code class="fe nd ne nf ng b">Loading...</code>文本。在应用程序被下载后,<code class="fe nd ne nf ng b">app-root</code>被初始化，并根据您的应用程序逻辑填充其余的元素。但这意味着应用程序可能会开始下载一些外部资源(徽标、样式)并开始应用它们。</p><p id="fd05" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果外部请求检索应用程序的某种配置，那么我们可以使用Angular <code class="fe nd ne nf ng b">APP_INITIALIZER</code>并在初始化应用程序时加载该信息。这可以解决一些我们必须订阅响应<code class="fe nd ne nf ng b">Promise/Observable</code>的情况。</p><h1 id="a5fa" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">加载应用外部资源的屏幕</h1><h2 id="3d79" class="nl kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">加载样式</h2><p id="f951" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">应用程序可以下载必须在第一页(或任何其他页面)向用户显示的外部样式/字体/图像。在大多数情况下，这些资源是并行下载的，这意味着页面会随着时间的推移而发生明显的变化。下面是它可能的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8b1c34b1822ceade26812d4b6006c346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*NuzFS59MgqjdSZj2KHIDqw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缓慢的例子来看变化</p></figure><p id="bfa7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">正如你所看到的，首先我们看到的是黑色文本，只有在这之后才应用样式和字体。在日常情况下，这种转换取决于互联网速度，可能不太明显，但它仍然会产生一些闪烁。</p><p id="266e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了解决loader的这个问题，我们首先需要了解我们的应用程序是如何处理资源的。在我的例子中，我为外部样式创建了一个新的<code class="fe nd ne nf ng b">link</code>元素，它基于可以由单独的请求检索的配置，将<code class="fe nd ne nf ng b">link</code>处理部分的内容留给浏览器。这允许基于后端配置应用远程样式。然而，这产生了一个小问题:添加<code class="fe nd ne nf ng b">link</code>元素并不意味着样式被加载——浏览器仍然会尝试下载并应用这些样式。我们可以通过为<code class="fe nd ne nf ng b">load</code>事件添加一个事件监听器来解决这个问题，并标记我们的样式已加载。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="de79" class="nl kz it ng b gy nm nn l no np">const stylesheet = document.createElement('link');<br/><br/>stylesheet.addEventListener('load', () =&gt; {<br/>  this.isStylesLoaded = true;<br/>});<br/><br/>stylesheet.rel = 'stylesheet';<br/>stylesheet.href = this.configurationService.getConfig().style + '.css';<br/><br/>document.getElementsByTagName('head')[0].appendChild(stylesheet);</span></pre><h2 id="67bb" class="nl kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">加载字体</h2><p id="40aa" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果您使用scss或sass，那么可能会出现从其他位置导入字体的情况，这可能会产生问题。我们不能简单地检测它们何时被下载——浏览器对此有实验性的功能——但是Angular还不支持它们。为了解决这个问题我们可以使用<code class="fe nd ne nf ng b"><a class="ae oc" href="https://github.com/typekit/webfontloader" rel="noopener ugc nofollow" target="_blank">webfontloader</a></code>。这是一个小库，允许加载外部字体，并让我们能够检测它们何时被加载。我们可以简单地将这个库导入到我们的应用程序中，然后像这样使用它:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="2b45" class="nl kz it ng b gy nm nn l no np">import { Component, OnInit } from '@angular/core';<br/><br/>import * as WebFontLoader from 'webfontloader';<br/><br/>@Component({<br/>  selector: 'app-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.scss']<br/>})<br/>export class AppComponent implements OnInit {<br/>  isFontsLoaded = false;<br/><br/>  constructor() { }<br/><br/>  ngOnInit(): void {<br/>    WebFontLoader.load({<br/>      active: () =&gt; {<br/>        this.isFontsLoaded = true;<br/>      },<br/>      google: {<br/>        families: ['Monoton']<br/>      }<br/>    });<br/><br/>  }<br/><br/>}</span></pre><h2 id="6f29" class="nl kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">创建加载屏幕</h2><p id="70a3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在我们可以在应用程序HTML文件中使用这两个参数<code class="fe nd ne nf ng b">isFontsLoaded</code>和<code class="fe nd ne nf ng b">isStylesLoaded</code>，在这里我们想要显示一个加载屏幕。下面是最简单的方法:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="fd10" class="nl kz it ng b gy nm nn l no np">&lt;div style="text-align:center" *ngIf="isFontsLoaded &amp;&amp; isStylesLoaded; else loading"&gt;<br/>  &lt;h1&gt;Welcome to {{ title }}!&lt;/h1&gt;<br/>  &lt;h2&gt;Current style: {{ style }}&lt;/h2&gt;<br/>&lt;/div&gt;<br/><br/>&lt;ng-template #loading&gt;<br/>  &lt;div class="loader"&gt;<br/>  &lt;/div&gt;<br/>&lt;/ng-template&gt;</span></pre><p id="43cb" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">就是这样！最终结果中间不会有任何黑色文本，用户将会看到<code class="fe nd ne nf ng b">Loading…</code>以及之后的完全加载的内容。不再有挫败感，消极思想，内容跳跃和闪烁。使用你的应用程序只是纯粹的快乐！<a class="ae oc" href="https://github.com/b-pagis/angular-remote-styles" rel="noopener ugc nofollow" target="_blank">可以在github </a>找到完整的代码示例。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="2a32" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated">结论</h1><p id="a07f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">加载器通过防止用户看到某些时候不应该看到的东西，对用户产生了积极的影响。如果使用正确，它们还可以指示加载的进度，这意味着用户将知道应用程序正在启动，他不需要刷新页面或询问网站是否真的在工作。通过消除消极的想法，我们创造了幸福。满意的用户往往比思想灰暗的用户更忠诚！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="a109" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="od">示例是用Angular 8编写的，但通用方法应该也适用于以前和即将推出的版本</em>。</p><h1 id="9815" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">来源</h1><div class="oe of gp gr og oh"><a href="https://github.com/b-pagis/angular-remote-styles" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">b-pagis/angular-remote-style</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">颜色和字体由外部配置控制的小例子。配置服务包含两个…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://github.com/typekit/webfontloader" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">typekit/webfontloader</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">当通过@font-face使用链接字体时，Web字体加载器为您提供额外的控制。- typekit/webfontloader</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://www.npmjs.com/package/ng-http-loader" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">ng-http-loader</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">请用叉子阅读变更日志，卢克。没有测试的PR可能不会被合并。要安装此库，请运行…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">www.npmjs.com</p></div></div><div class="oq l"><div class="ox l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/webfont-optimization?hl=en" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">网络字体优化|网络基础|谷歌开发者</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">排版是好的设计、品牌、可读性和易访问性的基础。网络字体支持以上所有功能…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">developers.google.com</p></div></div><div class="oq l"><div class="oy l os ot ou oq ov ks oh"/></div></div></a></div></div></div>    
</body>
</html>