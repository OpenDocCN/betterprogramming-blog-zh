<html>
<head>
<title>What is Object Destructuring in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中什么是对象析构？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/destructuring-5909dd48dff0?source=collection_archive---------7-----------------------#2019-12-11">https://betterprogramming.pub/destructuring-5909dd48dff0?source=collection_archive---------7-----------------------#2019-12-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aea4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">析构、扩展操作符，以及为什么应该使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/91fa0ac8cd154fb00c54dafa6193bc13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ux1xPkJTzUE73jfTlBiY7w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@lee2d2?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">李·艾德伍德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/combustion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在担心世界可能会被失控的神经网络摧毁之前，让我们想想完全不同的事情。<em class="lv">破坏</em>到底是什么？</p><p id="f6a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">destructing-assignment</a>语法是一个JavaScript表达式，允许我们将数组或对象属性中的值解包到不同的变量中。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ff9a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">数组析构与对象析构</h1><p id="3169" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">JavaScript中有两种类型的析构:</p><p id="b43a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先是<em class="lv">数组析构。</em> <strong class="lb iu"> </strong>数组析构允许我们将数组中的每一个值赋给它的变量。自从引入了spread操作符之后，将数组拆分成与用户相关的值就变得非常简单了。</p><p id="cdb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个数组析构的例子:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5046" class="nf me it nb b gy ng nh l ni nj">var <strong class="nb iu">numbers</strong> = [1,6,9,8,2];<br/>[<strong class="nb iu">number1</strong>, <strong class="nb iu">number2</strong>, ...<strong class="nb iu">otherNumbers</strong>] = numbers;</span><span id="775e" class="nf me it nb b gy nk nh l ni nj">console.log(<strong class="nb iu">number1</strong>) // -&gt; 1<br/>console.log(<strong class="nb iu">number2</strong>) // -&gt; 6<br/>console.log(<strong class="nb iu">otherNumbers</strong>) // -&gt; (3) [9, 8, 2]</span></pre><p id="826f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次是<em class="lv">对象析构。我发现这个特性比数组析构更强大。数组析构很简单，并且是基于位置的——正如你在上面的例子中看到的。</em></p><p id="87bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对象析构更进一步。让我们通过一些例子来发现这一点。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d798" class="nf me it nb b gy ng nh l ni nj">var <strong class="nb iu">dog</strong> = {age: 6, name: 'Lizzy', paws: 4};<br/>var {<strong class="nb iu">name</strong>, ...<strong class="nb iu">other</strong>} = <strong class="nb iu">dog</strong>;</span><span id="5eb2" class="nf me it nb b gy nk nh l ni nj">console.log(<strong class="nb iu">name</strong>) // -&gt; Lizzy<br/>console.log(<strong class="nb iu">other</strong>) // -&gt; {age: 6, paws: 4}</span></pre><p id="fa74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我简单解释一下这里发生了什么。<code class="fe nl nm nn nb b">dog</code>对象被析构为一个变量<code class="fe nl nm nn nb b">name</code>，它收集了<code class="fe nl nm nn nb b">other</code><strong class="lb iu"/>(rest参数)中的其余属性。它不是基于位置的，而是基于对象的属性。在这种情况下，<code class="fe nl nm nn nb b">name</code>只是一个简写。这不是很棒吗？我们也可以写:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fd58" class="nf me it nb b gy ng nh l ni nj">var {'name': <strong class="nb iu">nameProperty</strong>, ...<strong class="nb iu">other</strong>} = <strong class="nb iu">dog</strong>;</span><span id="b92e" class="nf me it nb b gy nk nh l ni nj">console.log(<strong class="nb iu">nameProperty</strong>) // -&gt; Lizzy</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="24f0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">用例</h1><p id="0c31" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">由于人类倾向于通过例子来学习，我将会给你一些析构的例子和一个非常相似的特性spread操作符。</p><h2 id="7841" class="nf me it bd mf no np dn mj nq nr dp mn li ns nt mp lm nu nv mr lq nw nx mt ny bi translated">创建对象的副本</h2><p id="d4b1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当你在JavaScript中将一个变量赋给一个没有析构的<code class="fe nl nm nn nb b">other</code>对象，并且你改变了一个属性时，两个对象都会改变——如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5c52" class="nf me it nb b gy ng nh l ni nj">var <strong class="nb iu">dog</strong> = {name: 'Lizzy', age: 4};<br/>var <strong class="nb iu">otherDog</strong> = <strong class="nb iu">dog</strong>; // no destructuring</span><span id="379a" class="nf me it nb b gy nk nh l ni nj"><strong class="nb iu">otherDog</strong>.age = 3;</span><span id="f6fd" class="nf me it nb b gy nk nh l ni nj">console.log(<strong class="nb iu">otherDog</strong>.age) // -&gt; 3<br/>console.log(<strong class="nb iu">dog</strong>.age) // -&gt; 3 (I don't want this!)</span></pre><p id="c851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不总是你想要的。您可以使用spread运算符来防止这种情况发生，并从对象创建副本。下面的例子将从<code class="fe nl nm nn nb b">dog</code>对象中获取每个属性(使用spread运算符),并且只改变<code class="fe nl nm nn nb b">age</code>。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="444d" class="nf me it nb b gy ng nh l ni nj">var <strong class="nb iu">dog</strong> = {name: 'Lizzy', age: 4};<br/>var <strong class="nb iu">otherDog</strong> = {...dog, age: 3}; // spread operator</span><span id="a502" class="nf me it nb b gy nk nh l ni nj"><strong class="nb iu">otherDog</strong>.age = 3;</span><span id="510b" class="nf me it nb b gy nk nh l ni nj">console.log(<strong class="nb iu">otherDog</strong>.age) // -&gt; 3<br/>console.log(<strong class="nb iu">dog</strong>.age) // -&gt; 4 (Happy age, happy life)</span></pre><p id="8733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用spread操作符时，对象可以彼此独立地改变，我们实际上已经创建了一个新的对象。这是创建一个新对象的简单方法，只需做一些小的改动。</p><p id="36cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些框架中，比如Angular，有很多用例。例如，我们可以用一种非常易读的方式在一个对象上发出一个新值。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4021" class="nf me it nb b gy ng nh l ni nj">this.<strong class="nb iu">articleUpdated</strong>.emit({<br/>  ...this.<strong class="nb iu">article</strong>,<br/>  <strong class="nb iu">status</strong>: value<br/>});</span></pre><p id="0078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">spread运算符不会创建对象的深层副本。</p><p id="32c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它从对象中提取的值仍然是引用，它不会创建新的实例。但是在极少数你需要的情况下，lodash的克隆Deep可以做到这一点。</p><h2 id="98bb" class="nf me it bd mf no np dn mj nq nr dp mn li ns nt mp lm nu nv mr lq nw nx mt ny bi translated">函数参数析构</h2><p id="ae11" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">函数参数析构建立在我们在本文中讨论过的东西的基础上，对于处理大型对象非常有用。</p><p id="c12b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以直接使用它，而不必创建一个新变量来创建属性的简写。用一个例子会更清楚:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5705" class="nf me it nb b gy ng nh l ni nj">var <strong class="nb iu">dog</strong> = {age: 5, paws: 4};</span><span id="3e2f" class="nf me it nb b gy nk nh l ni nj">function <strong class="nb iu"><em class="lv">printAge</em></strong>({<strong class="nb iu">age</strong>}) {<br/>  console.log(<strong class="nb iu">age</strong>); // instead of repeating dog.age everywhere<br/>}</span><span id="a645" class="nf me it nb b gy nk nh l ni nj">printAge(<strong class="nb iu">dog</strong>);</span></pre><p id="6ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大型对象，这非常有用。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4e70" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="b183" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">析构和spread操作符从ES6开始就有了，但是大多数程序员不使用它们。</p><p id="d3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些语言，比如Java，甚至没有这个特性。它们是对JavaScript语言的很好的补充，我总是很高兴看到它们发挥作用。</p></div></div>    
</body>
</html>