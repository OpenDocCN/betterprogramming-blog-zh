<html>
<head>
<title>Can Development Life Exist Without Docker Desktop?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有Docker桌面，开发生命还能存在吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/can-development-life-exist-without-docker-desktop-93791a3dc977?source=collection_archive---------2-----------------------#2021-09-27">https://betterprogramming.pub/can-development-life-exist-without-docker-desktop-93791a3dc977?source=collection_archive---------2-----------------------#2021-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="31a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">macOS上没有Docker桌面的Java微服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/05c76230dba368b1ddb8f67e6e675968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jx2VyIPdihLUfQqKxRFTcw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=835340" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/1137303-1137303/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=835340" rel="noopener ugc nofollow" target="_blank"> Pashminu Mansukhani </a>拍摄</p></figure><p id="1464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你现在还没听说，<a class="ae ky" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker Desktop </a>将对员工超过250人或收入超过1000万美元的公司收取订阅费。这并不是一笔很大的费用，如果你的公司已经在使用Docker Hub私有库，我相信你已经被覆盖了。但是它确实提出了一个问题，我们能在开发计算机上没有Docker桌面吗？我相信答案是肯定的，我将演示如何实现。</p><p id="72d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker有两个不同的方面需要替换:构建映像和运行映像。对于构建图像，有许多非Docker解决方案，但我将选择<a class="ae ky" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank"> Google Jib </a>。运行图片，我准备用<a class="ae ky" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank"> MicroK8s </a>。这两种解决方案都可以与大多数Java微服务一起工作，只需稍作修改。</p><p id="d263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示这些解决方案需要什么，我将把我的<a class="ae ky" href="https://github.com/rkamradt/blockchain" rel="noopener ugc nofollow" target="_blank">区块链微服务</a>从Docker Compose转换为基于MicroK8s的Kubernetes。这些服务已经使用了Google Jib，就像我的大多数Java服务一样，但是我将详细说明您需要做些什么来切换您的服务。请阅读我关于<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-mine-the-blockchain-in-java-9647de36a8fc">区块链微服务</a>的文章，了解更多有关代码的信息。</p><p id="8780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建Docker映像的一个技巧是，如果需要进行任何特定于平台的操作，那么构建需要在VM内部进行。这就是Java的“一次编写，随处运行”方面派上用场的地方，大多数构建都不需要特定于平台的操作。所以Jib在一个基本的JRE映像上增加了三层；依赖jar、构建中的类文件和构建中的资源文件。这样，如果你只改变一个资源文件，它只需要重建一个小层。只有当你改变你的依赖关系时，它才需要构建所有的三层。</p><p id="0870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用Jib，您只需将Maven插件添加到所有生成图像的项目的<code class="fe lv lw lx ly b">pom.xml</code>文件中。您不需要一个<code class="fe lv lw lx ly b">Dockerfile</code>,因为构建映像的指令对于所有Java应用程序都非常相似。唯一的区别是找到在映像启动时运行的主类，以及它是如何启动的。Jib在寻找唯一的主类方面做得很好，但是如果你有不止一个主类或者你的主类在一个依赖的jar中，它就需要帮助了。这个简单的例子不需要任何配置，并且对于Java Spring-Boot服务来说是现成的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b158" class="md me it ly b gy mf mg l mh mi">&lt;build&gt;<br/>    &lt;plugins&gt;<br/>        &lt;plugin&gt;<br/>            &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;<br/>            &lt;version&gt;3.1.4&lt;/version&gt;<br/>        &lt;/plugin&gt;<br/>    &lt;/plugins&gt;<br/>&lt;/build&gt;</span></pre><p id="3df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将使用<code class="fe lv lw lx ly b">adoptopenjdk:11-jre</code>作为基础创建一个图像，并用Maven工件ID命名。一个问题是，它需要推送到一个存储库，因为它没有Docker来本地存储图像。这可能会消耗一些时间，将数据推送到远程存储库，但是您可以通过运行本地容器存储库来减轻这种情况。我还没有做到这一点，所以你必须找出如何设置它。</p><p id="bafc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我在撰写本文时删除了Docker Desktop，所以我面临的一个问题是，配置文件使用凭证助手将docker hub用户名和密码存储在MacOS钥匙串中。所以我给我的<code class="fe lv lw lx ly b">.docker/config.json</code>添加了一个auth值，这是我的<code class="fe lv lw lx ly b">username:password</code>对于DockerHub的base 64编码(与基本认证相同):</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0c9c" class="md me it ly b gy mf mg l mh mi">{<br/>  "auths" : {<br/>    "<a class="ae ky" href="https://index.docker.io/v1/" rel="noopener ugc nofollow" target="_blank">https://index.docker.io/v1/</a>" : {<br/>       "auth": "&lt;your username password here&gt;"<br/>    }<br/>  }<br/>}</span></pre><p id="4d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个改变，我能够用简单的命令构建所有的图像:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b4ce" class="md me it ly b gy mf mg l mh mi">mvn install jib:build</span></pre><p id="fd5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这一切都没有安装Docker桌面。在<code class="fe lv lw lx ly b">pom.xml</code>中只有几行额外的代码，我们去掉了<code class="fe lv lw lx ly b">Dockerfile</code>(和不再需要的弹簧启动maven插件)。</p><h2 id="fe88" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">安装MicroK8s</h2><p id="d25f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">MicroK8s可以使用<a class="ae ky" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> Brew </a>安装。这些命令对我有用:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1505" class="md me it ly b gy mf mg l mh mi">brew install ubuntu/microk8s/microk8s<br/>microk8s install</span></pre><p id="d064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Brew MicroK8s安装程序必须在我的Mac上安装<a class="ae ky" href="https://multipass.run/" rel="noopener ugc nofollow" target="_blank"> Multipass </a>，以便在必要时创建虚拟机。<code class="fe lv lw lx ly b">microk8s install</code>命令看起来是启动一个Ubuntu VM并在其上安装MicroK8s，然后在Mac上安装一个<code class="fe lv lw lx ly b">microk8s</code>命令来代理它。您可以通过炮轰新虚拟机来确认这一点:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8d8c" class="md me it ly b gy mf mg l mh mi">multipass shell microk8s-vm<br/>...<br/>microk8s<br/>...<br/>exit</span></pre><p id="79aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装MicroK8s后，我们需要使用以下命令安装几个插件:<code class="fe lv lw lx ly b">dns</code>、<code class="fe lv lw lx ly b">storage</code>和<code class="fe lv lw lx ly b">helm3</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a816" class="md me it ly b gy mf mg l mh mi">microk8s enable dns<br/>microk8s enable helm3<br/>microk8s enable storage</span></pre><p id="8ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要添加<code class="fe lv lw lx ly b">kubectl</code>和<code class="fe lv lw lx ly b">helm</code> CLI，加上我们将要安装的使生活变得更容易的东西，奇妙的Kubernetes实用程序<a class="ae ky" href="https://github.com/derailed/k9s" rel="noopener ugc nofollow" target="_blank"> k9s </a>。以下是安装这些CLI的方法:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bbf7" class="md me it ly b gy mf mg l mh mi">brew install kubectl<br/>brew install helm<br/>brew install k9s</span></pre><p id="e957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后为指向新集群的<code class="fe lv lw lx ly b">kubectl</code>创建配置文件(注意，如果您已经有了一个<code class="fe lv lw lx ly b">~/.kube/config</code>文件，您应该备份它并将其与microk8s创建的文件合并)</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ad0f" class="md me it ly b gy mf mg l mh mi">mkdir ~/.kube<br/>microk8s config &gt; ~/.kube/config</span></pre><p id="35ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行<code class="fe lv lw lx ly b">k9s</code>进行测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/57c36e90f14020d92f7565e120b77e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*26qfKI33ieRW64IxhLTQcw.png"/></div></div></figure><p id="4332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ctrl-C退出。现在，您应该准备好开始创建部署了。</p><h2 id="8654" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">安装外部服务</h2><p id="7000" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在安装我们的服务之前，我们需要安装几个外部服务:<a class="ae ky" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>和<a class="ae ky" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>。Bitnami通常为这些类型的服务提供了非常好的导航图，可以帮助你进行开发。由于Kafka和MongoDB是有状态的，您可以考虑在生产环境中在Kubernetes之外运行它们。但是我们谈论的是一个开发环境。在本地Kubernetes中运行这些服务是有意义的，这样多个开发人员就不会互相踩着填满共享Kafka队列或将无效数据放入数据库。</p><p id="0952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我面对区块链服务的一个问题是，我想证明节点到节点的通信。这意味着我需要为每个服务创建多个通过某种方式消除歧义的服务。最初，我有两个docker-compose文件。在这个实例中，我将创建两个单独的名称空间来分隔节点。名称空间几乎创建了一个虚拟集群，任何跨名称空间的通信都必须明确定义。让我们用这些命令创建<code class="fe lv lw lx ly b">node1</code>和<code class="fe lv lw lx ly b">node2</code>名称空间:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9c98" class="md me it ly b gy mf mg l mh mi">kubectl create namespace node1<br/>kubectl create namespace node2</span></pre><p id="e2f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过Bitnami Helm图表安装MongoDB的说明可以在<a class="ae ky" href="https://github.com/bitnami/charts/tree/master/bitnami/mongodb" rel="noopener ugc nofollow" target="_blank">这个链接</a>找到。卡夫卡的说明可以在<a class="ae ky" href="https://github.com/bitnami/charts/tree/master/bitnami/kafka" rel="noopener ugc nofollow" target="_blank">这个链接</a>找到。我是这样做的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c654" class="md me it ly b gy mf mg l mh mi">helm repo add bitnami <a class="ae ky" href="https://charts.bitnami.com/bitnami" rel="noopener ugc nofollow" target="_blank">https://charts.bitnami.com/bitnami</a><br/>helm install mongo bitnami/mongodb -n node1<br/>helm install mongo bitnami/mongodb -n node2<br/>helm install kafka bitnami/kafka -n node1<br/>helm install kafka bitnami/kafka -n node2</span></pre><p id="3a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MongoDB安装将在每个名称空间中创建一个名为<code class="fe lv lw lx ly b">mongo-mongodb</code>的秘密。</p><h2 id="38bf" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">安装我们的服务</h2><p id="ad62" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">因为以前我们的服务是由Docker Compose启动的，所以我们可以用<a class="ae ky" href="https://kompose.io/" rel="noopener ugc nofollow" target="_blank"> Kompose </a>实用程序来转换它们。我从清理掉所有来自<code class="fe lv lw lx ly b">docker-compose.yaml</code>的外部服务开始。然后我把主机名改成了Kubernetes内部的DSN名，<code class="fe lv lw lx ly b">kafka</code>和<code class="fe lv lw lx ly b">mongo-mongodb</code>。我在本地安装了<code class="fe lv lw lx ly b">kompose</code> CLI，并使用以下命令运行它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="79d3" class="md me it ly b gy mf mg l mh mi">curl -L https://github.com/kubernetes/kompose/releases/download/v1.22.0/kompose-darwin-amd64 -o kompose<br/>chmod +x kompose<br/>./kompose convert -c</span></pre><p id="3b30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这创建了运行所有三个服务所需的所有图表。它创建了一个名为<code class="fe lv lw lx ly b">docker-compose</code>的目录，不过我把它改成了<code class="fe lv lw lx ly b">.helm/blocknode</code>。接下来我要做的就是让它从MongoDB helm图表在三个部署文件中创建的秘密中获取MongoDB密码，如下所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8ec4" class="md me it ly b gy mf mg l mh mi">spec:<br/>  containers:<br/>  - env:<br/>    - name: MONGO_HOST<br/>      value: mongo-mongodb<br/>    - name: MONGO_PASS<br/>      valueFrom:<br/>        secretKeyRef:<br/>          name: mongo-mongodb<br/>          key: mongodb-root-password</span></pre><p id="22ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以安装新的舵图了:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="61f6" class="md me it ly b gy mf mg l mh mi">helm install blocknode .helm/blocknode -n node1</span></pre><p id="806f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe lv lw lx ly b">k9s</code>以确保一切正常运行。这是一张图片:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/42ea87be2df8f331032cae2f1513a55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0lvkfJA4LQz00rSBYB8mw.png"/></div></div></figure><p id="1ad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，一切顺利！现在对<code class="fe lv lw lx ly b">node2</code>做同样的事情。</p><p id="ea82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试一切，我将进行一些端口转发。随着<code class="fe lv lw lx ly b">k9s</code>这变得容易，只需突出显示您想要端口转发的服务并按下Shift-f。我将区块链、区块链矿工和区块链节点设置为8080、8081和8082。现在你可以用Postman或curl运行服务来测试它。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0f9c" class="md me it ly b gy mf mg l mh mi">curl --location --request GET 'http://localhost:8081/user' \<br/>--header 'Authorization: Basic YWRtaW46YWRtaW4=' \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{ "name": "name2"}'</span></pre><p id="9bbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，概括地说，我们在没有Docker或Docker Desktop(这很方便，因为它允许您在Docker容器内为CI/CD构建映像)帮助的情况下构建了所有映像，我们通过公开可用的舵图部署了外部应用程序，并将我们的<code class="fe lv lw lx ly b">docker-compose.yaml</code>转换为部署我们所有服务的新舵图。全部来自我们的开发人员笔记本电脑。从IDE调试变得轻而易举；我们所要做的就是将所有的依赖项进行端口转发，并调整配置以从这些转发的端口中读取数据。</p><p id="2659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要卸载所有服务，只需使用<code class="fe lv lw lx ly b">helm uninstall</code>命令:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4369" class="md me it ly b gy mf mg l mh mi">helm uninstall mongo -n node1<br/>helm uninstall kafka -n node1<br/>helm uninstall blockchain -n node1<br/>helm uninstall blockchainminer -n node1<br/>helm uninstall blockchainnode -n node1<br/>...repeat for node2</span></pre><p id="c2a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读这篇长篇大论的文章，我希望您能从中吸取一些有用的知识，并将其应用到您的日常开发生活中。这篇文章的所有代码可以在这里找到<a class="ae ky" href="https://github.com/rkamradt/blockchain/tree/v0.4" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>