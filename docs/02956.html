<html>
<head>
<title>How to Use Environment Variables with RSpec Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在RSpec单元测试中使用环境变量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-environment-variables-with-rspec-unit-tests-f094b400c299?source=collection_archive---------3-----------------------#2020-01-11">https://betterprogramming.pub/using-environment-variables-with-rspec-unit-tests-f094b400c299?source=collection_archive---------3-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0dc4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写受环境变量影响的Ruby单元测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/88ebbf8615b2c35e8aef573b5ee26851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EF8VO7BgKVJM4zUp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清版</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="ea13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RSpec 是一个帮助我们使用特定领域语言为Ruby应用程序编写单元测试的工具。</p><p id="b582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件开发的最佳实践之一——尤其是在开发软件产品的情况下——是使用环境变量来存储应用程序的配置项。使用这些配置有几个原因:</p><ul class=""><li id="0d44" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">功能标志:这些是环境变量，指示应用程序支持的功能是否启用。</li><li id="16b2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">秘密:在源代码中存储生产秘密，比如数据库密码，是一个非常糟糕的主意(即使它是加密的)。更好的方法是将这些秘密作为环境变量只存储在运行应用程序的主机上。</li><li id="d159" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">特定于安装/客户/环境的配置项:这些配置项专门用于应用程序的安装或使用应用程序的客户，如用户帐户、定制配置和依赖关系配置。</li></ul><p id="d87f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于使用环境变量来构建可配置软件，源代码的执行结果变得依赖于这些变量的值。软件应用程序的行为可能因不同的配置值而有所不同，尤其是在软件考虑这些变量的值来启用/禁用功能或选择处理策略时。例如，使用环境变量定义主题国家的税收计算器应用程序可能会根据国家变量为相同的数据计算不同的税额(因为不同的国家有不同的税收百分比)。</p><p id="8720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为这样的软件应用程序编写单元测试有时可能是一项复杂的任务(因为需要定义测试的用例),并且需要大量的注意力来确保所定义的测试用例是独立的并且不会相互影响。</p><p id="6026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将介绍一种为受环境变量影响的软件应用程序连接单元测试的方法。下面是我将为之编写测试的Ruby应用程序。这个应用程序是一个简单的Ruby类，它使用环境变量<code class="fe mj mk ml mm b">MODE</code>来确定排列数组项目优先级的策略。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试上面的类的一种方法或想法是在执行RSpec测试之前设置所需的环境变量，以便能够模拟使用不同的值运行应用程序。可以通过多种方式实现这一点，尽管有些方式比其他方式更安全。</p><p id="575a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是为上面的类编写RSpec单元测试的第一次尝试。下面的测试使用<code class="fe mj mk ml mm b">before</code>块来设置各自的环境变量，并准备测试的上下文。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="08ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述单元测试高度依赖于测试的执行顺序，因为单元测试正在改变运行流程的环境变量。<code class="fe mj mk ml mm b">ENV</code>对象是所有测试用例之间的共享对象——即使测试用例在不同的名称空间或文件中定义。例如，在上面的例子中，<code class="fe mj mk ml mm b">default mode</code>上下文中的环境变量<code class="fe mj mk ml mm b">APPLICATION_MODE</code>的值将是<em class="mp">降序</em>，即使它没有在上下文中定义(我假设执行的顺序)。这将导致在运行单元测试时出现下面的错误消息。另一方面，将<code class="fe mj mk ml mm b">default mode</code>上下文移到文件的顶部会解决这个问题。</p><pre class="kj kk kl km gt mq mm mr ms aw mt bi"><span id="a765" class="mu mv it mm b gy mw mx l my mz">1) PriorityList#priority_list default mode  sorts ascending<br/>     Failure/Error: expect(subject.priority_list).to eq list.sort</span><span id="b9bf" class="mu mv it mm b gy na mx l my mz">expected: [0, 1, 3, 3, 3, 4, 6, 7, 20]<br/>            got: [20, 7, 6, 4, 3, 3, 3, 1, 0]</span><span id="5ca6" class="mu mv it mm b gy na mx l my mz">(compared using ==)</span></pre><p id="fbc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们的测试不是相互隔离的，并且存在一些测试用例配置影响其他测试用例的风险。这个问题可以通过为每个改变环境变量的上下文添加一个<code class="fe mj mk ml mm b">after</code>块来隔离测试用例的上下文来解决，如下所示:</p><pre class="kj kk kl km gt mq mm mr ms aw mt bi"><span id="5ca1" class="mu mv it mm b gy mw mx l my mz">after do<br/>  ENV['APPLICATION_MODE'] = nil<br/>end</span></pre><p id="ecd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我并不喜欢这种想法，因为它向测试中引入了更多的代码，而且<code class="fe mj mk ml mm b">after</code>块可能会变成一个很长的块，这会降低测试的可读性。</p><p id="5520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我更喜欢使用RSpec支持的<code class="fe mj mk ml mm b"><a class="ae ky" href="https://relishapp.com/rspec/rspec-mocks/docs" rel="noopener ugc nofollow" target="_blank">stubs</a></code>和<code class="fe mj mk ml mm b"><a class="ae ky" href="https://relishapp.com/rspec/rspec-mocks/docs" rel="noopener ugc nofollow" target="_blank">allow</a></code>方法来实现相同的单元测试。唯一需要实现的更改是对<code class="fe mj mk ml mm b">before</code>块的更改。我们需要用下面几行代码替换直接的环境变量赋值来模拟<code class="fe mj mk ml mm b">ENV</code>对象的行为:</p><pre class="kj kk kl km gt mq mm mr ms aw mt bi"><span id="f028" class="mu mv it mm b gy mw mx l my mz">allow(ENV).to receive(:fetch).with('APPLICATION_MODE', 'ascending')<br/>                                     .and_return('ascending')<br/># Or <br/>allow(ENV).to receive(:fetch).with('APPLICATION_MODE', 'ascending')<br/>                                     .and_return('descending')</span></pre><p id="3197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码行正在存根化<code class="fe mj mk ml mm b">ENV</code>对象，以模拟对象在用<code class="fe mj mk ml mm b">APPLICATION_MODE</code>键接收到一个<code class="fe mj mk ml mm b">fetch</code>调用的情况下的行为，并设置该调用的预期结果。这种方法的最大优点是，我们不需要在测试执行后重置<code class="fe mj mk ml mm b">after</code>块中单元用例的上下文。</p><p id="d86b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们在应用程序类中使用了没有方法<code class="fe mj mk ml mm b">fetch</code>的对象<code class="fe mj mk ml mm b">ENV</code>，比如<code class="fe mj mk ml mm b">@env = ENV['APPPLICATION_MODE']</code>。我们可以重写这些台词:</p><pre class="kj kk kl km gt mq mm mr ms aw mt bi"><span id="ddb2" class="mu mv it mm b gy mw mx l my mz">allow(ENV).to receive(:[]).with('APPLICATION_MODE')<br/>                                     .and_return('ascending')<br/># Or<br/>allow(ENV).to receive(:[]).with('APPLICATION_MODE')<br/>                                     .and_return('descending')</span></pre><p id="b8e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，下面是使用<code class="fe mj mk ml mm b"><a class="ae ky" href="https://relishapp.com/rspec/rspec-mocks/docs" rel="noopener ugc nofollow" target="_blank">stubs</a></code>和<code class="fe mj mk ml mm b"><a class="ae ky" href="https://relishapp.com/rspec/rspec-mocks/docs" rel="noopener ugc nofollow" target="_blank">allow</a></code>方法的所展示的应用程序的完整RSpec单元测试实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="0c48" class="ni mv it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">结论</h1><p id="b7e4" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">环境变量在软件开发中非常有用，有助于提高代码质量，降低在版本控制系统(如GitHub)中暴露安全配置的风险。</p><p id="f3a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试这样的软件可以通过直接在测试用例中修改环境变量或者使用<code class="fe mj mk ml mm b">stubs</code>来完成。后一种方法的优点是，它有助于减少编写测试用例所需的代码行数。最重要的是，它有助于保持单独的测试用例相互隔离。</p></div></div>    
</body>
</html>