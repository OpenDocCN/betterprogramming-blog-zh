<html>
<head>
<title>How React JSX Works Under The Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JSX在幕后是如何工作的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-react-jsx-works-under-the-hood-6b177a8a57e1?source=collection_archive---------10-----------------------#2021-06-23">https://betterprogramming.pub/how-react-jsx-works-under-the-hood-6b177a8a57e1?source=collection_archive---------10-----------------------#2021-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e189" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们解决这些怪癖和警告</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dba0d039b4de9ab9e67b55cdc8c687e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8MYHrazHy7yf4rWZz9mnbg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@thevanegmond" rel="noopener ugc nofollow" target="_blank"> @thevanegmond </a>于<a class="ae ky" href="https://unsplash.com/photos/Fy1USiu0SbA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，作者编辑</p></figure><p id="30fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React已经存在很长时间了。它还带来了JSX，这是React开发的核心部分。乍一看，JSX和HTML非常相似。然而，<a class="ae ky" href="https://reactjs.org/docs/introducing-jsx.html#specifying-attributes-with-jsx" rel="noopener ugc nofollow" target="_blank"> JSX实际上更接近于JavaScript而不是HTML </a>。在这里，我们将看看那些熟悉的类似HTML的标签。</p><p id="d11b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些非常标准的React代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们导入<code class="fe lx ly lz ma b">React</code>，然后创建我们的组件并返回一些JSX标记。</p><h2 id="eba3" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">为什么React需要导入</h2><p id="89f4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我开始学习React的时候，我发现一件奇怪的事情，那就是我们有<code class="fe lx ly lz ma b">import React</code>但是在任何地方都不使用它。事实上，我们确实在使用它。</p><p id="99c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浏览器无法直接理解React代码。每当我们编写React代码时，我们总是将其构建/转换为浏览器可以理解的JavaScript。</p><p id="8f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这通常是用像<a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>或<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>这样的工具来完成的。如果你使用像<a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>这样的工具和库，它们会在幕后为你做编译。</p><p id="1009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们构建/传输React代码时，我们的组件<code class="fe lx ly lz ma b">HomePage</code>将看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="95c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">注意:我做了一些改动，使其可读性更好，但概念仍然有效。</em> <a class="ae ky" href="https://babeljs.io/repl#?browsers=&amp;build=&amp;builtIns=false&amp;corejs=3.6&amp;spec=false&amp;loose=false&amp;code_lz=GYVwdgxgLglg9mABACTgWwKYAUCGBzDRACgEpEBvAKEUQCcMoRakibFq2AeXAxWKADYYAvAHJUmUQD4ObRJwAOiCAJwBnNQDkcmMQvwYAtPtr5TCgBbTZcxAE04IRDnp8LhcgBYAVAEYADIEAvlAWiABuMGowUHC0NjScAPQKMrbyFrRJaVxJPBg5JADclEFAA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=7.4.4&amp;externalPlugins=" rel="noopener ugc nofollow" target="_blank"> <em class="mz">跟随此链接</em> </a> <em class="mz">来一窥原著，更丑的版本。</em></p><p id="58c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JSX语法实际上被转换成普通的旧JavaScript。特别是，所有等同于HTML标签的东西都被转换成对<code class="fe lx ly lz ma b">React.createElement</code>的调用。如果我们愿意处理这种语法，我们实际上可以编写React代码，而不用编写任何JSX！</p><h2 id="bb6f" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">如果我不想导入React怎么办？</h2><p id="15c9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有了新版本的Babel或TypeScript，我们实际上可以省去React导入。从React 17开始，增加了对一个新函数<code class="fe lx ly lz ma b">_jsx</code>的支持。transpiler可以使用该功能代替<code class="fe lx ly lz ma b">React.createElement</code>。为了在巴别塔上运行，我们需要一个更新版本的<a class="ae ky" href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx" rel="noopener ugc nofollow" target="_blank"> JSX变换插件</a>。这对于新版本的TypeScript来说是现成的。</p><p id="bfd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不直接使用Babel/TypeScript，而是使用Create React App或基于React的库，这些库的新版本也对此提供了支持。</p><p id="a0a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用React以下版本的最新版本，这些版本也支持。请注意，这仍然需要更新版本的Babel或TypeScript。</p><p id="bcd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于哪些版本支持这个以及如何在Babel和TypeScript中设置它的更多信息，请看<a class="ae ky" href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html" rel="noopener ugc nofollow" target="_blank">这个链接</a>。</p><p id="cf5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想更多地了解这一变化带来的好处，那么Dilantha Prasanjith的文章是一个很好的阅读材料。</p><div class="nc nd gp gr ne nf"><a href="https://blog.bitsrc.io/new-jsx-enhancements-in-react-17-e5f64acbea89" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">React 17中新的JSX增强功能</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">React 17对JSX有什么新功能，为什么您应该关注它</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">blog.bitsrc.io</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><h2 id="8fdb" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">JavaScript表达式是如何计算的</h2><p id="d6bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们查看transpiled代码，我们会注意到花括号中写的纯文本子元素(在本例中为<code class="fe lx ly lz ma b">You are the {4*1000}th visitor</code>)被拆分，每个部分都作为一个单独的子元素被传递。这允许React评估用JSX编写的JavaScript表达式。</p><h2 id="771b" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">HTML标签和React组件的区别</h2><p id="f9bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在上面经过编译的代码中，如果我们更深入地研究对<code class="fe lx ly lz ma b">createElement</code>的实际调用，我们可以看到<code class="fe lx ly lz ma b">paragraph, horizontalRule</code>和<code class="fe lx ly lz ma b">ourComponent</code>的调用有些不同。</p><p id="c8af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当呈现一个React组件时(在我们的例子中是<code class="fe lx ly lz ma b">Page</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ul class=""><li id="6d32" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">第一个参数是对要呈现的组件的引用。</li><li id="ef4e" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">第二个参数指定必须传递给组件的属性。</li><li id="82fc" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">所有其他参数都是要传递给组件的子参数。</li></ul><p id="cb1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当呈现一个HTML标签时(在我们的例子中是<code class="fe lx ly lz ma b">p</code>和<code class="fe lx ly lz ma b">hr</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ul class=""><li id="d8d1" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">第一个参数是标记的名称。</li><li id="d87a" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">第二个参数是用于创建传递给标记的属性的属性。</li><li id="af4f" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">所有其他参数都是要传递给组件的子参数。</li></ul><h2 id="a9cd" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">为什么React组件必须以大写字母开头</h2><p id="66dd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">那么，transpiler如何区分哪些JSX标签呈现为HTML，哪些呈现为React组件呢？它只是查看标签的大小写。如果标签以大写字母开头，它将被视为React组件，否则它将被视为HTML标签。</p><p id="d6e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果我们要做这样的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，transpiler将把<code class="fe lx ly lz ma b">componentToRender</code>视为普通的HTML标签，而不是React组件。<a class="ae ky" href="https://babeljs.io/repl#?browsers=&amp;build=&amp;builtIns=false&amp;corejs=3.6&amp;spec=false&amp;loose=false&amp;code_lz=GYVwdgxgLglg9mABACTgWwKYAUCGBzDRACgG9EQBnDAeQBsATAEQwpjyQF8BKREgKESIICClCHoADggxgoAFTgAlGfQwAnRAF5yVOkxZskAfkR7cBRAC5E5jAG4BiNRigg1SIoMSPBAHmFoUmAy8koq6oiwULQYmgDkqJhxAHw-XsgYtLRwab4A9AFBIQrKYKpqqYJcDhxAA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=7.4.4&amp;externalPlugins=" rel="noopener ugc nofollow" target="_blank">这里有一个到传输代码</a>的链接。</p><p id="756b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用这种模式，我们可以简单地将<code class="fe lx ly lz ma b">componentToRender</code>重命名为<code class="fe lx ly lz ma b">ComponentToRender</code>。神奇之处在于标识符的第一个字母。</p><p id="5e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的好处是React不必维护有效HTML标签的列表。即使他们维护了这样一个列表，它也不能很好地与允许我们创建自定义元素的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>一起使用。因此，最好不要限制哪些标签应该被视为HTML标签。</p><h2 id="b3fd" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">为什么<code class="fe lx ly lz ma b">className</code>又不上课？为什么是<code class="fe lx ly lz ma b">forHtml</code>而不是<code class="fe lx ly lz ma b">for</code>？</h2><p id="db85" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们看一看带有<code class="fe lx ly lz ma b">className</code>属性的典型组件的transpiled代码，它看起来会像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="85f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们了解到，对于HTML标记，第二个参数是将传递给HTML标记的属性。但是，<code class="fe lx ly lz ma b">className</code>不是HTML属性。这里我们不使用<code class="fe lx ly lz ma b">class</code>,因为它是JavaScript中的保留关键字。</p><p id="8365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管在对象中将其作为键传递不成问题，但React团队还是选择了<code class="fe lx ly lz ma b">className</code>,因为<code class="fe lx ly lz ma b">class</code>是JavaScript中的保留关键字。用<code class="fe lx ly lz ma b">forHtml</code>代替<code class="fe lx ly lz ma b">for</code>也是如此。</p><p id="c05c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React 16之前，这些属性被忽略。从React 16开始，这些属性不会被忽略，但会给出警告。至于为什么——答案并不简单。详细回答，<a class="ae ky" href="https://github.com/facebook/react/issues/13525#issuecomment-417818906" rel="noopener ugc nofollow" target="_blank">关注此链接</a>。</p><h2 id="6819" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">呈现动态HTML</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b1b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要传输上面的代码，我们会得到类似这样的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里重要的是，上面的转换代码不同于下面的转换代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ba07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同之处在于，<code class="fe lx ly lz ma b">htmlFromSomewhere</code>中的<code class="fe lx ly lz ma b">p</code>标签实际上被视为一个字符串，而不是HTML标记，因为它是以字符串值的形式传递的。对于被视为HTML标记的<code class="fe lx ly lz ma b">p</code>标签，需要使用<code class="fe lx ly lz ma b">React.createElement</code>来创建。</p><p id="042a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">如果你熟悉DOM API，其区别类似于设置</em><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText" rel="noopener ugc nofollow" target="_blank"><em class="mz">innerText</em></a><em class="mz">vs设置</em><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML" rel="noopener ugc nofollow" target="_blank"><em class="mz">innerHTML</em></a><em class="mz">。</em></p><p id="742b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React将该字符串视为HTML并不困难，因为HTML已经处理了文本。然而，将未知来源的字符串视为HTML标记会带来一些安全漏洞。这是因为我们不知道这个字符串来自哪里——有人可能会在那里注入一个<code class="fe lx ly lz ma b">script</code>标签并利用系统。这被称为XSS攻击。</p><p id="2446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">务实的程序员的<a class="ae ky" href="https://medium.com/pragmatic-programmers/table-of-contents-d56d9bab2639" rel="noopener"> Secure Your Node.js Web应用</a>有一整节是关于XSS攻击和应对它们的方法的。别担心，你不需要买任何东西。这在介质上是可得到的。</p><p id="81f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是书中XSS部分的链接。</p><div class="nc nd gp gr ne nf"><a href="https://medium.com/pragmatic-programmers/recognize-different-types-of-xss-be8d66a91caf" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">认识不同类型的XSS</h2><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div></div></a></div><p id="1cdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你完全确定这个字符串是安全的，那么你可以如下使用<code class="fe lx ly lz ma b">dangerouslySetInnerHTML</code>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="de91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，该值必须是一个对象，并且将<code class="fe lx ly lz ma b">__html</code>属性设置为要呈现的HTML。<a class="ae ky" href="https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml" rel="noopener ugc nofollow" target="_blank">根据文档</a>的说法，这种语法被故意弄得很奇怪，以便提醒你这是危险的。</p><h1 id="1211" class="oi mc it bd md oj ok ol mg om on oo mj jz op ka mm kc oq kd mp kf or kg ms os bi translated">最后的想法</h1><p id="bb4e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JSX的引擎盖下发生了很多事情，也有一些怪癖和警告。理解这些怪癖能让我们更好地理解事情为什么会这样。</p></div></div>    
</body>
</html>