<html>
<head>
<title>Introduction to unittest: a Unit Testing Framework in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试简介:Python中的单元测试框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-unittest-a-unit-testing-framework-in-python-fa0d96fc8262?source=collection_archive---------10-----------------------#2020-02-12">https://betterprogramming.pub/introduction-to-unittest-a-unit-testing-framework-in-python-fa0d96fc8262?source=collection_archive---------10-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8eb3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python标准库创建您自己的单元测试脚本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/429750e8037b2ee39e51047cfc581d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wepaJVtTFEQ1RNGd_zBCnw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@dtravisphd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·特拉维斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将帮助你学习用Python对你自己的应用程序进行单元测试。基于官方<a class="ae ky" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">文件</a>，<code class="fe lv lw lx ly b">unittest</code>:</p><blockquote class="lz ma mb"><p id="7cb1" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">“…最初是受JUnit的启发，与其他语言中的主要单元测试框架有相似之处。它支持测试自动化，共享测试的设置和关闭代码，将测试聚合到集合中，以及测试独立于报告框架。”</p></blockquote><p id="51fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">unittest</code>是Python的标准库，支持面向对象的代码。它具有以下特点:</p><ul class=""><li id="62c0" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">text fixture</code>—<code class="fe lv lw lx ly b">test fixture</code>代表执行一个或多个测试和任何相关清理行动所需的准备工作。例如，这可能涉及创建临时或代理数据库、目录或启动服务器进程。</li><li id="afe9" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">test case</code> — A <code class="fe lv lw lx ly b">test case</code>是测试的个体单位。它检查对一组特定输入的特定响应。<code class="fe lv lw lx ly b">unittest</code>提供了一个基类<code class="fe lv lw lx ly b">TestCase</code>，它可以用来创建新的测试用例。</li><li id="96bf" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">test suite</code>—<code class="fe lv lw lx ly b">test suite</code>是<code class="fe lv lw lx ly b">test case</code>、<code class="fe lv lw lx ly b">test suite</code>或两者的集合。它用于聚集应该一起执行的测试。</li><li id="4e45" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">test runner</code>—<code class="fe lv lw lx ly b">test runner</code>是编排测试执行并向用户提供结果的组件。运行者可以使用图形界面、文本界面，或者返回一个特殊的值来指示执行测试的结果。</li></ul><p id="d740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将重点关注<code class="fe lv lw lx ly b">test case</code>。让我们进入下一节，开始用Python编写一些代码。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="f0b7" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">基本概念</h1><h2 id="c35f" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">导入</h2><p id="2a7b" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">首先，您需要通过在Python文件的顶部声明模块来导入它:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="3e0a" class="nt nc it ly b gy oo op l oq or">import unittest</span></pre><h2 id="0a1e" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">测试案例</h2><p id="7a33" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">为了创建一个<code class="fe lv lw lx ly b">testcase</code>，你必须创建一个继承<code class="fe lv lw lx ly b">unittest.TestCase</code>类的类</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="b387" class="nt nc it ly b gy oo op l oq or">class TestFunctions(unittest.TestCase):</span></pre><h2 id="acfe" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">测试方法</h2><p id="039d" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">可以通过在它们前面加上关键字<code class="fe lv lw lx ly b">test</code>来创建一个测试方法。任何以关键字<code class="fe lv lw lx ly b">test</code>开头的函数都将被视为单元测试方法。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="caf2" class="nt nc it ly b gy oo op l oq or">def test_some_function(self):</span></pre><p id="084c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个简单的函数来尝试一下，从输入字符串中删除空白。它接受一个输入字符串，并输出删除了空格的相同文本。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="aee0" class="nt nc it ly b gy oo op l oq or">def remove_whitespace(text):<br/>    result = text.replace(' ', '')<br/>    return result</span></pre><p id="647a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们必须创建一个测试方法来测试我们上面定义的功能。我将只使用相同的名称和前缀与<code class="fe lv lw lx ly b">test</code>关键字。你可以随意命名它，只要它以关键字<code class="fe lv lw lx ly b">test</code>开头。在函数内部，您需要使用<code class="fe lv lw lx ly b">assertEqual</code>调用来定义对预期结果的检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="ab21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面给出的例子中，我写了三行代码来检查<code class="fe lv lw lx ly b">remove_whitespace</code>函数的输出是否与预期结果相同。在一个实际的用例中，你应该涵盖所有你能想到的可能性。</p><h2 id="91b4" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">主要的</h2><p id="c2a2" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">完成后，编写以下代码来完成第一个单元测试的脚本:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="17fb" class="nt nc it ly b gy oo op l oq or">if __name__ == '__main__':<br/>    unittest.main()</span></pre><p id="5d2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将脚本保存为Python文件，并在命令提示符下使用以下语法正常运行。将名称更改为您设置的文件的名称。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="8887" class="nt nc it ly b gy oo op l oq or">python -m unittest myFile.py</span></pre><p id="1991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以指定其他参数。常见参数有:</p><ul class=""><li id="7897" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">-b </code> —测试运行期间缓冲标准输出和标准误差流。通过测试期间的输出被丢弃。输出通常在测试失败或出错时回显，并添加到失败消息中。</li><li id="2a6d" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">-c</code> —测试运行期间的Control-C等待当前测试结束，然后报告到目前为止的所有结果。第二个Control-C引发正常的键盘中断异常。</li><li id="5d21" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">-f </code> —在第一次出现错误或失败时停止测试运行。</li><li id="9011" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">-k</code> —只运行匹配模式或子串的测试方法和类。这个选项可能会被多次使用，在这种情况下，所有匹配给定模式的测试用例都会被包含进来。使用<code class="fe lv lw lx ly b">fnmatch.fnmatchcase()</code>将包含通配符(<code class="fe lv lw lx ly b">*</code>)的模式与测试名称进行匹配。否则，使用简单的区分大小写的子字符串匹配。模式与测试加载器导入的完全限定的测试方法名称相匹配。</li><li id="4e6e" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">-v</code> —详细输出</li></ul><p id="14b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要一个详细的输出。您运行以下命令。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="d3ca" class="nt nc it ly b gy oo op l oq or">python -m unittest -v myFile.py</span></pre><p id="ffb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在Jupyter笔记本上运行，你会遇到以下错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/c77e74d89b9c5b4a2ef48cceeb84c162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLAihdVsybmLPdziW2zcIQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过将主代码更改为以下内容来轻松解决这个问题:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="5e12" class="nt nc it ly b gy oo op l oq or">unittest.main(argv=['ignored'], exit=False)</span></pre><p id="80f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表参数是为了防止<code class="fe lv lw lx ly b">unittest</code>查找<code class="fe lv lw lx ly b">sys.argv</code>,因为它是笔记本的启动程序，而<code class="fe lv lw lx ly b">exit=False</code>是为了防止<code class="fe lv lw lx ly b">unittest</code>关闭内核。参数也可以添加到列表中。例如:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="a669" class="nt nc it ly b gy oo op l oq or">unittest.main(argv=['ignored', '-v'], exit=False)</span></pre><p id="dd6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该脚本时，您应该会看到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/52daef2190f6d35f2bd62072b27a39ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*indtfx01wTp4-BS77PAPiA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="b674" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">第二测试函数</h2><p id="e5e5" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">如果你很难编写单元测试，你的代码可能不够模块化。建议将您的代码分解成更小的函数，以便您可以轻松地测试它。让我们尝试添加另一个函数，并为它编写一个简单的测试方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="ba9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码接受一个输入字符串，根据其中的文本计算数学运算，并以字符串形式返回结果。之后，为它添加测试方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="5cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我添加了三行等式检查。请注意，我没有对不可计算的字符串执行任何异常检查。如果您的函数中有一个异常检查，您还应该在测试函数中为它创建一个相等检查。</p><p id="91c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行脚本时，以下结果将输出到控制台。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/828679d80ea5b704904e311405920101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nidFsqKVkB1Hfhe2hn2FPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ca29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将第二行的比较值从<code class="fe lv lw lx ly b">8.0</code>改为<code class="fe lv lw lx ly b">7.0</code>，以检查运行脚本时的输出。您应该会看到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/453043a7add59e9adf49fbf5ed6b8dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGgHYS3-r6IDdQJ44AYlhQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，它会在日志中反映出逻辑错误。在这种情况下，生成的输出<code class="fe lv lw lx ly b">8.0</code>不等于预期的结果<code class="fe lv lw lx ly b">7.0</code>。这将有助于在修改基本函数后运行单元测试时查明问题。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="f152" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">维护</h1><p id="3e93" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">在这一节中，我们将深入探索可以在您的测试用例中使用的上述其他类型的<code class="fe lv lw lx ly b">assert</code>。</p><h2 id="bdb7" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">assertNotEqual</h2><p id="6be0" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">这用于检查左参数是否与右参数相同。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="f01f" class="nt nc it ly b gy oo op l oq or">self.assertNotEqual(1, 2)</span></pre><h2 id="0ead" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">assertTrue</h2><p id="3b9b" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">这将检查输入参数是否评估为<code class="fe lv lw lx ly b">true</code>。除了通常的<code class="fe lv lw lx ly b">True</code>和<code class="fe lv lw lx ly b">False</code>值。您也可以使用其他数据类型。<code class="fe lv lw lx ly b">0</code>将被评估为<code class="fe lv lw lx ly b">False</code>，而任何其他值将被视为<code class="fe lv lw lx ly b">True</code>。你也可以用它来计算一个字符串。空字符串被视为<code class="fe lv lw lx ly b">False</code>。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="39bb" class="nt nc it ly b gy oo op l oq or">self.assertTrue(1)</span></pre><h2 id="5922" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">assertFalse</h2><p id="57a6" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated"><code class="fe lv lw lx ly b">assertFalse</code>是<code class="fe lv lw lx ly b">assertTrue</code>的反义词。用于评估输入参数是否为<code class="fe lv lw lx ly b">False</code>。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="cc90" class="nt nc it ly b gy oo op l oq or">self.assertFalse(False)</span></pre><h2 id="b164" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">阿瑟公司</h2><p id="d88c" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated"><code class="fe lv lw lx ly b">assertIs</code>可用于检查两个输入参数是否是相同的对象。您也可以使用它来检查对象的类型。在调用它之前，我们先创建几个变量:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="01ca" class="nt nc it ly b gy oo op l oq or">a = 2<br/>b = 2<br/>c = 3</span><span id="9dfc" class="nt nc it ly b gy oy op l oq or">basket = [1, 2]</span></pre><p id="7277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续写<code class="fe lv lw lx ly b">assertIs</code>的代码:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="1160" class="nt nc it ly b gy oo op l oq or">self.assertIs(a, b)<br/>self.assertIs(type(a), int)</span></pre><h2 id="9b0f" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">资产广告</h2><p id="cee7" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">这将检查两个输入参数是否不是相等的对象。检查确切的类型和类别。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="ed6c" class="nt nc it ly b gy oo op l oq or">self.assertIsNot(a, c)<br/>self.assertIsNot(a, '2')</span></pre><h2 id="8fcd" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">阿瑟酮</h2><p id="7371" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">如果您想检查<code class="fe lv lw lx ly b">None</code>，您可以使用<code class="fe lv lw lx ly b">assertIsNone</code>。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="6162" class="nt nc it ly b gy oo op l oq or">self.assertIsNone(None)</span></pre><h2 id="8e43" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">资产声明无</h2><p id="003b" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated"><code class="fe lv lw lx ly b">assertIsNone</code>的对立面。用于检查不是<code class="fe lv lw lx ly b">None</code>的对象。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="8cbc" class="nt nc it ly b gy oo op l oq or">self.assertIsNotNone('string')</span></pre><h2 id="3eaa" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">assertIn</h2><p id="807c" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">assertIn</code>来检查左输入参数是否是右参数中的一项。下面的例子检查我们上面定义的变量是否是<code class="fe lv lw lx ly b">basket</code>列表中项目的一部分。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="9b86" class="nt nc it ly b gy oo op l oq or">self.assertIn(a, basket)</span></pre><h2 id="573a" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">资产净值</h2><p id="f97e" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated"><code class="fe lv lw lx ly b">unittest</code>模块还为我们提供了<code class="fe lv lw lx ly b">assertNotIn</code>，帮助我们检查左输入参数是否不是右参数中项目的一部分。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="8743" class="nt nc it ly b gy oo op l oq or">self.assertNotIn(c, basket)</span></pre><h2 id="9c2a" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">资产实例</h2><p id="2355" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">检查左输入参数是否是右输入参数的对象。它基于<code class="fe lv lw lx ly b">isinstance()</code>功能。这意味着它将返回<code class="fe lv lw lx ly b">True</code>，即使对于子类也是如此。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="d3a3" class="nt nc it ly b gy oo op l oq or">self.assertIsInstance(a, int)</span></pre><h2 id="59a4" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">资产声明实例</h2><p id="a07b" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">与<code class="fe lv lw lx ly b">asserIsInstance</code>相反的是<code class="fe lv lw lx ly b">assertIsNotInstance</code>，可以用来评估两个对象是否不是彼此的实例。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="b419" class="nt nc it ly b gy oo op l oq or">self.assertNotIsInstance(a, float)</span></pre><h2 id="7187" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">比较运算符</h2><p id="88d1" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">这个模块还附带了两个对象之间数学运算的断言。</p><ul class=""><li id="68c9" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">assertGreater</code></li><li id="4835" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">assertGreaterEqual</code></li><li id="5434" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">assertLess</code></li><li id="a661" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">assertLessEqual</code></li></ul><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="b109" class="nt nc it ly b gy oo op l oq or">self.assertGreater(c, a)<br/>self.assertGreaterEqual(a, b)<br/>self.assertLess(a, c)<br/>self.assertLessEqual(a, b)</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="6bf1" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">安装和拆卸</h1><h2 id="375d" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">设置</h2><p id="9054" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">可能会有这样的情况，在每个单元测试之前需要执行一些初始化。例如，在每次测试之前将配置设置重置为默认值或固定窗口分辨率。在这种情况下，您可以在<code class="fe lv lw lx ly b">setUp</code>函数中定义代码，它将在任何测试函数之前被调用。请注意，将为每个测试方法调用设置功能。因此，初始化，如登录系统或连接数据库，应该放在类中，而不是放在<code class="fe lv lw lx ly b">setUp</code>中。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="43f0" class="nt nc it ly b gy oo op l oq or">def setUp(self):<br/>    print('Setup')</span></pre><h2 id="9d51" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">拆卸</h2><p id="96af" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">如果您想在每次测试功能后处理或清理一些对象，您可以在<code class="fe lv lw lx ly b">tearDown</code>功能中记录下来。每次测试函数调用后，将记录结果并调用<code class="fe lv lw lx ly b">tearDown</code>函数。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="56ad" class="nt nc it ly b gy oo op l oq or">def tearDown(self):<br/>    print('TearDown')</span></pre><p id="206e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有三种测试方法，你会看到三行<code class="fe lv lw lx ly b">Setup</code>输出和三行<code class="fe lv lw lx ly b">TearDown</code>输出。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="4470" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">空白测试</h1><h2 id="bb36" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">装修工</h2><p id="d44a" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">此外，<code class="fe lv lw lx ly b">unittest</code>还允许我们设置<code class="fe lv lw lx ly b">decorator</code>来跳过特定的测试类或方法。让我们用下面的装饰者来测试一下:</p><ul class=""><li id="3e7f" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">skipIf</code></li><li id="a3a9" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><code class="fe lv lw lx ly b">skipUnless</code></li></ul><p id="0896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个函数都接受两个参数。第一个参数是测试类或方法被跳过时所遵循的条件、原因或要输出的消息。</p><h2 id="3abb" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">斯基皮夫</h2><p id="d8b1" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">假设您刚刚更新了您的自定义模块，由于向后兼容性，它现在将导致一个错误。如果版本是最新的，可以用<code class="fe lv lw lx ly b">skipIf</code>跳过。如果日志版本为0.5.1.2，以下示例测试函数将不会运行:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="ef30" class="nt nc it ly b gy oo op l oq or">import logging</span><span id="8a12" class="nt nc it ly b gy oy op l oq or">@unittest.skipIf(logging.__version__ == '0.5.1.2', "not supported in this library version")<br/>def test_format(self):<br/>    #Tests that work for only a certain version of the library.<br/>    print(logging.__version__)</span></pre><p id="4411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/c69ab97a4aadd2a4ffb224b51ba83902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YvTUktaWDAVr8dvahDm6NA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="46c9" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">无技能</h2><p id="ead3" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">另一方面，当且仅当条件满足时，如果您希望运行测试，<code class="fe lv lw lx ly b">skipUnless</code>是有用的。例如，以下测试方法仅在现有系统平台为Windows时运行。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="6938" class="nt nc it ly b gy oo op l oq or"><a class="ae ky" href="http://twitter.com/unittest" rel="noopener ugc nofollow" target="_blank">@unittest</a>.skipUnless(sys.platform.startswith("win"), "requires Windows")<br/>def test_windows_support(self):<br/>    # windows specific testing code<br/>    print(sys.platform)</span></pre><p id="90a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用Windows，以下结果将输出到控制台:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/a59efb6eb4cfecf3c2d4d676f1a1062f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CM1WcMWkODfe0BnQDj6ng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="bd3e" class="nt nc it bd nd nu nv dn nh nw nx dp nl li ny nz nn lm oa ob np lq oc od nr oe bi translated">skipTest</h2><p id="f049" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">您也可以通过在函数内部进行评估来跳过测试。您可以轻松地实现一个简单的条件语句来触发<code class="fe lv lw lx ly b">skipTest</code>调用。以下测试功能仅在周六或周日运行:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="7f3a" class="nt nc it ly b gy oo op l oq or">import datetime</span><span id="5ba8" class="nt nc it ly b gy oy op l oq or">def test_weekend(self):<br/>    index = datetime.datetime.today().isoweekday()<br/>    if(index &gt;= 1 and index &lt;= 5):<br/>        self.skipTest("Not weekend")</span></pre><p id="75f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意查看以下要点以获得完整的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="2228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该脚本时，您应该能够看到以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/b252c289398ccf574371c5289b160a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8un93o21G1SsHEZ2yS-cQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="7aae" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">结论</h1><p id="b7f9" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">让我们回顾一下今天所学的内容。</p><p id="eb58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从简单解释<code class="fe lv lw lx ly b">unittest</code>模块的基本概念开始。我们编写了一个简单的测试脚本并运行它。</p><p id="71df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们详细探讨了<code class="fe lv lw lx ly b">unittest</code>模块中可用的不同类型的资产。</p><p id="8dda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模块还带有一个<code class="fe lv lw lx ly b">setUp</code>函数，作为每个测试方法的初始化调用。此外，<code class="fe lv lw lx ly b">tearDown</code>函数可用于在每次测试方法调用后释放或终止对象。</p><p id="052c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们测试了skip <code class="fe lv lw lx ly b">decoractor</code> s和函数，它允许我们跳过一个粒子测试类或方法。</p><p id="c120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，我希望你喜欢它。下一篇再见！</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="34d9" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">参考</h1><ol class=""><li id="8280" class="mg mh it lb b lc of lf og li pc lm pd lq pe lu pf mm mn mo bi translated"><a class="ae ky" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> Unittest的文档</a></li><li id="4527" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu pf mm mn mo bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/37895781/unable-to-run-unittests-main-function-in-ipython-jupyter-notebook" rel="noopener ugc nofollow" target="_blank">Jupyter笔记本运行单元测试故障排除</a></li></ol></div></div>    
</body>
</html>