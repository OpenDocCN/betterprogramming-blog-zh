<html>
<head>
<title>Handling iOS 13 Location Permissions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理iOS 13位置权限</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-ios-13-location-permissions-5482abc77961?source=collection_archive---------2-----------------------#2019-10-23">https://betterprogramming.pub/handling-ios-13-location-permissions-5482abc77961?source=collection_archive---------2-----------------------#2019-10-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="da45" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">新权限，更多隐私</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/5ad0a0d9d4713352e2a87911eaea0843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEByjYnX28a0Mq7NG3-K4Q.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@marjan_blan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">марьянблан</a>在<a class="ae kz" href="https://unsplash.com/s/photos/map?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6a3a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">苹果在<a class="ae kz" href="https://developer.apple.com/videos/play/wwdc2019/705/" rel="noopener ugc nofollow" target="_blank"> WWDC 2019 </a>期间展示了核心位置框架的变化。位置权限在iOS 13中有了更好的改变。用户的隐私受到了更多的重视。</p><p id="2f77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">苹果不仅增加了一个新的权限类型允许一次，而且他们改变了总是允许权限的工作方式。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="51a0" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">核心位置有什么变化？</h1><p id="1852" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">随着iOS 13的发布，核心位置框架发生了变化。现在你会看到一个不同类型的位置许可对话框。它有一次新的许可。</p><p id="16bc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下图显示了从iOS 12到iOS 13的权限模型更改。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj na"><img src="../Images/6763d6227c5dce8669f416435308d61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*6-x0dsDiE0kK9zdT.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">iOS 12与13位置权限对比</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="de4f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">核心位置许可授权</h1><p id="14d8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">为了显示位置许可，我们需要以两种方式之一配置<code class="fe nb nc nd ne b">CLLocationManager</code>实例:</p><ul class=""><li id="aeb7" class="nf ng iu lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated"><code class="fe nb nc nd ne b">requestAlwaysAuthorization</code></li><li id="b09e" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe nb nc nd ne b">requestWhenInUseAuthorization</code></li></ul><p id="3add" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS 13要求在<code class="fe nb nc nd ne b">info.plist</code>文件中增加以下两条隐私使用说明:</p><ul class=""><li id="a161" class="nf ng iu lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated"><code class="fe nb nc nd ne b">NSLocationWhenInUseUsageDescription</code></li><li id="6bb4" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe nb nc nd ne b">NSLocationAlwaysAndWhenInUseUsageDescription</code></li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0198" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">设置核心位置</h1><p id="b961" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">下面是让您开始使用iOS应用程序中的核心位置的代码:</p><pre class="kk kl km kn gu nt ne nu nv aw nw bi"><span id="900c" class="nx me iu ne b gz ny nz l oa ob">var locationManager = CLLocationManager()<br/>locationManager.requestAlwaysAuthorization() <br/>//or use <!-- -->requestWhenInUseAuthorization()</span><span id="af63" class="nx me iu ne b gz oc nz l oa ob">locationManager.desiredAccuracy = kCLLocationAccuracyBest<br/>locationManager.startUpdatingLocation()<br/>locationManager.allowsBackgroundLocationUpdates = true<br/>locationManager.pausesLocationUpdatesAutomatically = false</span></pre><p id="7109" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于<code class="fe nb nc nd ne b">allowsBackgroundLocationUpdates</code>，确保您已经从Xcode项目的功能中启用了后台模式位置。</p><p id="0b6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不再浪费时间，让我们深入研究新的位置许可模型。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2ae9" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">位置权限:引擎盖下</h1><p id="6742" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">iOS 13有以下三个位置权限(忽略拒绝，因为它忽略了权限):</p><ul class=""><li id="6bf1" class="nf ng iu lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated"><strong class="lc iv">使用时允许</strong> —拥有允许的超能力</li><li id="fae7" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><strong class="lc iv">允许一次</strong> —使用中暂时允许</li><li id="b039" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><strong class="lc iv">允许</strong> —推迟到真正需要的时候</li></ul><p id="bef1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是新权限模型的工作流程:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj od"><img src="../Images/e405c78f7465f9ae54cb439c63a8809d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*ZiSJCqk3fO2OzRveDLIq7w.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8644" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">允许一次权限</h1><p id="7c44" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Allow Once类似于Allow While Using，但仅用于一个前台会话。这意味着一旦你离开应用程序相当长一段时间，许可状态就会变成<code class="fe nb nc nd ne b">notDetermined</code>。</p><p id="dac8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下次用户启动应用程序时，开发人员可以根据他们的用例再次请求权限。这让用户对位置数据有了更好的控制，也让开发人员可以轻松处理一次性的位置案例。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f84f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">使用权限时，“允许”总是隐藏在“允许”中</h1><p id="2437" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">“使用权限时允许”推迟“总是允许”权限。</p><p id="3345" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认情况下，新权限对话框中没有“始终允许”权限。它以临时形式存在，以便在实际需要时使用。</p><p id="1c3f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来看看不同类型的位置授权是如何工作的。</p><h2 id="a070" class="nx me iu bd mf oe of dn mj og oh dp mn lj oi oj mp ln ok ol mr lr om on mt oo bi translated"><strong class="ak">案例1 </strong>:请求AlwaysAuthorization</h2><ul class=""><li id="9b86" class="nf ng iu lc b ld mv lg mw lj op ln oq lr or lv nk nl nm nn bi translated">使用权限句柄时允许仅当您使用<code class="fe nb nc nd ne b">requestAlwaysAuthorisation</code>请求位置授权时才允许权限。</li><li id="84d1" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">使用上述类型的授权，用户将其视为前台权限，但是<code class="fe nb nc nd ne b">CoreLocation</code>通知代理这是<code class="fe nb nc nd ne b">always</code>权限。这样，它可以在后台监控位置事件，但是<code class="fe nb nc nd ne b">CLLocationManagerDelegate</code>不能接收这些事件。</li><li id="be2f" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><code class="fe nb nc nd ne b">CoreLocation</code>持有事件，并在适当的时候询问用户是否愿意<code class="fe nb nc nd ne b"><strong class="lc iv">Allow Always?</strong></code>。之后，也可以在后台接收位置事件。</li><li id="217a" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">这样,“始终允许”会推迟到真正需要用户同意才能在后台更新位置的阶段。</li><li id="f3ea" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">上述情况使得始终允许临时授权。</li></ul><h2 id="cad4" class="nx me iu bd mf oe of dn mj og oh dp mn lj oi oj mp ln ok ol mr lr om on mt oo bi translated"><strong class="ak">案例二</strong> : <code class="fe nb nc nd ne b">requestWhenInUseAuthorization</code></h2><ul class=""><li id="e272" class="nf ng iu lc b ld mv lg mw lj op ln oq lr or lv nk nl nm nn bi translated">在这种情况下，Always Allowed永远不会发生，因为开发人员自己没有在<code class="fe nb nc nd ne b">CLLocationManager</code>实例上设置它。</li><li id="0151" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated">仅当应用程序在前台时才访问位置(尽管一旦用户切换到后台，它会在很短的时间间隔内继续访问它)。</li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6417" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="25f4" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">新的权限模型要简单得多，因为它在提示中隐藏了总是允许的选项，并使其成为使用权限时的一部分。</p><p id="d254" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于“始终允许”，当您尝试在后台访问该位置时，它会要求用户同意。这样，它努力向用户提供关于何时访问该位置的清晰和透明性。</p><p id="ce0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">总结了这篇文章。这里有一个<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/iOS13CoreLocationChanges" rel="noopener ugc nofollow" target="_blank">的例子</a>的<code class="fe nb nc nd ne b">MapKit</code>和<code class="fe nb nc nd ne b">CoreLocation</code>带有新的iOS 13位置权限。</p></div></div>    
</body>
</html>