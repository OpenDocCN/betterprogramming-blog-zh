<html>
<head>
<title>8 Useful Tricks for React Apps You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的React应用的8个有用技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-useful-tricks-for-react-apps-you-should-know-a15c2678c846?source=collection_archive---------2-----------------------#2019-11-11">https://betterprogramming.pub/8-useful-tricks-for-react-apps-you-should-know-a15c2678c846?source=collection_archive---------2-----------------------#2019-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="047b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">把戏不只是给孩子玩的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/951418b14d275c3cbdf193a628e3b8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_cp-XpPGXPsFteQztLDgmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">丹尼尔·科尔派拍摄的照片</em></p></figure><p id="29bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React已经经历了许多阶段的转变，从来没有让它的粉丝感到惊讶。</p><p id="e15a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，我们用<a class="ae lv" href="https://www.reddit.com/r/reactjs/comments/alc005/what_exactly_is_a_mixin/" rel="noopener ugc nofollow" target="_blank"> mixins </a>来创建和管理我们的界面，然后出现了<a class="ae lv" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">类组件</a>的概念，现在<a class="ae lv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React挂钩</a>改变了我们在React中构建应用的方式。</p><p id="b389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道还有什么很棒吗？了解一些你可以在React中使用的巧妙技巧，这将有助于你更好地构建你的应用程序(当然，如果你遇到一些你不知道自己能做的事情)。</p><p id="9bc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将介绍React中每个React开发人员都应该知道的八个巧妙技巧。</p><p id="1468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我并不期望这个列表中的每一项对你来说都是新的，但是我希望你能在这个列表中找到至少一项对你有用的，你直到现在才知道你可以做的事情。</p><p id="dc7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是你应该知道的React的八个技巧:</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="67fd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.用字符串创建React元素</h1><p id="6d8a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这个列表中的第一项是创建一个常规的react DOM元素，用简单的字符串表示HTML DOM元素标签。更准确地说，是表示DOM元素的字符串。</p><p id="de7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以通过将字符串<code class="fe na nb nc nd b">'div'</code>赋给变量来创建React组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React将只调用<code class="fe na nb nc nd b">React.createElement</code>并使用该字符串在内部创建元素。这不是很棒吗？</p><p id="c100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/material-ui.com"> Material UI </a>这样的组件库中常用，可以声明一个<code class="fe na nb nc nd b">component</code>道具，调用者可以为其决定组件的根节点成为<code class="fe na nb nc nd b">props.component</code>的值，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9f83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以传入将用作根节点的自定义组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8fe6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">2.使用误差边界</h1><p id="a169" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在JavaScript中，我们习惯于用<code class="fe na nb nc nd b">try/catch</code>处理代码执行中的大多数错误，这个代码块可以“捕捉”发生的错误。当这些错误在catch块中被捕获时，您可以避免您的应用程序在代码边界内崩溃。</p><p id="dd29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的一个例子如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ec39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React最终只是JavaScript，所以我们可以假设我们可以使用相同的策略来捕捉和处理错误。然而，由于React的性质，组件内部的JavaScript错误会破坏React的内部状态，并导致它在未来的渲染中发出神秘的错误。</p><p id="5861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于这个原因，React团队引入了<a class="ae lv" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">错误边界</a>，每个React开发者都应该知道它们，这样他们就可以在他们的React应用中使用它们。</p><p id="c068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在错误边界之前发生的错误的问题是，当这些隐含的错误在以前的渲染中发生后，在将来的渲染中发出时，React没有提供一种方法来处理它们，也没有从组件中恢复它们。这就是为什么我们都需要误差边界！</p><p id="356e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误边界是React组件，它捕捉组件树中任何地方的错误，记录它们，并可以显示一个后备UI，而不是崩溃的组件树。</p><p id="1418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们在渲染期间、在生命周期方法内部以及在它们下面的整个树的构造函数内部捕捉错误(这就是为什么我们在应用程序的顶部某处声明和渲染它们)。</p><p id="bf74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个来自<a class="ae lv" href="https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries" rel="noopener ugc nofollow" target="_blank"> React文档</a>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cdea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以将它作为常规组件使用:</p><pre class="kj kk kl km gt nh nd ni nj aw nk bi"><span id="30f5" class="nl me it nd b gy nm nn l no np">&lt;ErrorBoundary&gt;<br/>  &lt;MyWidget /&gt;<br/>&lt;/ErrorBoundary&gt;</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="17d0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">3.保留以前的值</h1><p id="20b5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">更新道具或状态时，只需使用<code class="fe na nb nc nd b">React.useRef</code>就可以保留它们以前的值。</p><p id="cc63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，要跟踪一个项目数组的当前和以前的更改，您可以创建一个被赋予以前值的<code class="fe na nb nc nd b">React.useRef</code>和一个当前值的<code class="fe na nb nc nd b">React.useState</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<code class="fe na nb nc nd b">React.useEffect</code>是在组件完成渲染后运行<em class="ng">的。</em></p><p id="f49d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe na nb nc nd b">setNames</code>被调用时，组件重新渲染，<code class="fe na nb nc nd b">prefNamesRef</code>将保留之前的名称，因为<code class="fe na nb nc nd b">React.useEffect</code>是从<em class="ng">之前的渲染</em>执行的最后一个代码。</p><p id="9a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，由于我们在<code class="fe na nb nc nd b">useEffect</code>中重新分配了<code class="fe na nb nc nd b">prevNamesRef.current</code>，它在下一个渲染阶段成为之前的名称，因为它最后被分配了之前渲染阶段的名称。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="32ce" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">4.使用React.useRef进行灵活的非过时值检查</h1><p id="d328" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在React中引入React挂钩之前，如果我们想确保操作(比如获取数据)发生在组件挂载到DOM上的之后的<em class="ng">，我们就有了类组件的<code class="fe na nb nc nd b">componentDidMount</code>静态方法。</em></p><p id="f7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当React Hooks出现时，它很快成为编写我们的组件的最流行的方式，而不是使用类组件。当我们想要跟踪一个组件是否已经安装，以防止在组件卸载后设置状态时，我们应该这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子在迁移到React钩子之后没有了<code class="fe na nb nc nd b">componentDidMount</code>,卸载之后状态更新导致的内存泄漏的概念仍然适用于钩子。</p><p id="6149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，类似于<code class="fe na nb nc nd b">componentDidMount</code>使用React钩子的方法是使用<code class="fe na nb nc nd b">React.useEffect</code>，因为它是在组件完成渲染之后<em class="ng">执行的。如果您在这里使用<code class="fe na nb nc nd b">React.useRef</code>来分配挂载值的值，您可以达到与类组件示例相同的效果:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fd5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个跟踪最新变化而不导致重新渲染的好用例的例子是像这样与<code class="fe na nb nc nd b">React.useMemo</code>结合使用(<a class="ae lv" href="https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/utils/useForkRef.js" rel="noopener ugc nofollow" target="_blank"> source </a>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6d2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果ref属性改变并被定义，这将创建一个新的函数。这意味着React将用<code class="fe na nb nc nd b">null</code>调用旧的分叉ref，用当前ref调用新的分叉ref。</p><p id="2c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于使用了<code class="fe na nb nc nd b">React.useMemo</code>，ref将被记忆，直到<code class="fe na nb nc nd b">refA</code>或<code class="fe na nb nc nd b">refB</code>的ref props发生变化，在此行为中会发生自然清除。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="bb69" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">5.使用React.useRef自定义依赖于其他元素的元素</h1><p id="f68b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe na nb nc nd b">React.useRef</code>有几个有用的用例，包括将其自身分配给ref prop以反应节点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要获取<code class="fe na nb nc nd b">div</code>元素的坐标位置，这个例子就足够了。</p><p id="651d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果应用程序中某处的另一个元素想要在<code class="fe na nb nc nd b">position</code>相应地改变或应用一些条件逻辑的同时更新它们自己的位置，最好的方法是使用<code class="fe na nb nc nd b">ref callback function pattern</code>。</p><p id="5c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用回调函数模式时，您将接收React组件实例或HTML DOM元素作为第一个参数。</p><p id="e6ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子只是显示了一个简单的例子，其中<code class="fe na nb nc nd b">setRef</code>是应用于<code class="fe na nb nc nd b">ref</code>属性的回调函数。您可以看到，在<code class="fe na nb nc nd b">setRef</code>中，您可以做任何您需要的事情，而不是直接将<code class="fe na nb nc nd b">React.useRef</code>版本应用到DOM元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="dd13" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">6.高阶组件</h1><p id="e3ac" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">普通JavaScript中创建强大的可重用函数的常见模式是<a class="ae lv" href="https://eloquentjavascript.net/05_higher_order.html" rel="noopener ugc nofollow" target="_blank">高阶函数</a>。因为React最终是JavaScript，所以也可以在React内部使用高阶函数。</p><p id="e264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于可重复使用的<em class="ng">组件</em>，诀窍是使用<em class="ng">高阶组件</em>。</p><p id="9a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<em class="ng">高阶组件</em>是当你有一个以组件作为参数并返回一个组件的函数时。</p><p id="6b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像高阶函数可以用来抽象出逻辑并在应用程序的其他函数中共享一样，高阶组件使我们能够从组件中抽象出逻辑并在其他组件中共享它们。</p><p id="2542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以使用一堆可重用的组件在您的应用程序中重用。</p><p id="0b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个高阶元件的例子。在这个代码片段中，一个高阶组件<code class="fe na nb nc nd b">withBorder</code>接受一个定制组件并返回一个隐藏的<em class="ng">“中间层”</em>组件。</p><p id="bfd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当父组件决定呈现这个返回的高阶组件时，它作为一个组件被调用，并接收从“中间层组件”传入的属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3364" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">7.渲染道具</h1><p id="c113" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我最喜欢在React库中使用的技巧之一是<em class="ng">渲染道具模式</em>。它在某种程度上类似于高阶组件，解决了一个类似的问题:在多个组件之间共享代码。</p><p id="806f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">渲染道具公开了一个函数，它的目的是传回外部世界渲染其子对象所需的一切。</p><p id="9d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React中渲染组件的最基本方式是这样渲染它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用渲染道具时，渲染其子对象的道具按照惯例称为<code class="fe na nb nc nd b">render</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bda9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe na nb nc nd b">MyComponent</code>是一个组件的例子，我们称之为<em class="ng">渲染道具组件</em>，因为它期望<code class="fe na nb nc nd b">render</code>作为道具，并调用它来渲染其子组件。</p><p id="66be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在React中是一个强大的模式，因为我们可以通过render回调将共享状态和数据作为参数传递，从而允许组件在多个组件中被渲染和重用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4698" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">8.记忆</h1><p id="15aa" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">作为React开发人员，最重要的事情之一是优化像<code class="fe na nb nc nd b">React.memo</code>这样的组件的性能。这有助于防止令人讨厌的错误，如在应用程序运行时导致灾难性崩溃的无限循环T2。</p><p id="6db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读下面的React应用程序中应用记忆的几种方法:</p><ul class=""><li id="014c" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><a class="ae lv" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> React.memo </a></li><li id="64d0" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae lv" href="https://flaviocopes.com/react-hook-usememo/" rel="noopener ugc nofollow" target="_blank"> React.useMemo </a></li><li id="5ae4" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">react . use回调</a></li><li id="956f" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae lv" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank">做出反应。纯组件</a></li><li id="300d" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae lv" href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener ugc nofollow" target="_blank">优化性能</a></li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="eeaf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="2ffd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这篇文章到此结束！我希望你发现这是有价值的，并期待在未来更多。</p></div></div>    
</body>
</html>