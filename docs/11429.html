<html>
<head>
<title>How to Write Clean TypeScript Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写干净的类型脚本代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-clean-typescript-code-eda1716eead1?source=collection_archive---------0-----------------------#2022-03-19">https://betterprogramming.pub/how-to-write-clean-typescript-code-eda1716eead1?source=collection_archive---------0-----------------------#2022-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2460" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">8个知识点写出优雅的打字稿代码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/641cd809f0dc80d6e5eb061dcc82ac78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PALozqeaPRtviePr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@olia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Olia Gozha </a>拍摄的照片</p></figure><h1 id="5142" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.用不可变类型标记</h1><p id="725d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有些常量我们不希望以任何方式修改，虽然const关键字很好，但它并不限制引用类型，其值仍然可以修改，例如:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="0ac7" class="ms la it mo b gy mt mu l mv mw">const obj = {<br/>   elementId: '#dashboard',<br/>}</span><span id="e145" class="ms la it mo b gy mx mu l mv mw">// Try modifying the properties of ElementID<br/>obj.elementId = '';</span><span id="91b5" class="ms la it mo b gy mx mu l mv mw">// output =&gt; ''<br/>console.log(obj.elementId)</span></pre><p id="d47d" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">虽然可以通过<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank"><em class="nd">object . freeze()</em></a>方法冻结对象，但是开发过程中没有任何错误提示，体验非常不好，所以如何通过TypeScript防止上述情况，就需要使用TypeScript <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#readonly-and-const" rel="noopener ugc nofollow" target="_blank"> <em class="nd">作为const关键字</em> </a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/d2e68c7c3d57e41622ceedb524e93576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*utw_Z-wN-aTaonQ4_KaMjA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TypeScript作为const关键字</p></figure><p id="1416" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">值得一提的是，无论你的对象层次结构有多深，任何在使用<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#readonly-and-const" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">作为const关键字</strong> </a>之后修改一个值的操作都会导致错误，这是很棒的，因为我们有很多在开发过程中不希望被修改的常量。</p><p id="3a84" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">同时，<code class="fe nf ng nh mo b">as const</code>关键字也适用于<strong class="lt iu">数组</strong>，TypeScript会在运行时自动阻止对数组有破坏性的方法，比如<code class="fe nf ng nh mo b"><strong class="lt iu">push, pop, splice, unshift</strong></code>方法，当你使用它们时会出错</p><p id="084a" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><code class="fe nf ng nh mo b">as const</code>其实相当于<code class="fe nf ng nh mo b">readonly</code></p><h1 id="038a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.使用默认参数，而不是短路或条件</h1><p id="de5a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">默认参数通常比短路更简洁。</p><p id="42d0" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">不好:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="a5d0" class="ms la it mo b gy mt mu l mv mw">function loadPages(count?: number) {<br/>  const loadCount = count !== undefined ? count : 10;<br/>  // ...<br/>}</span></pre><p id="a420" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">好:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="1def" class="ms la it mo b gy mt mu l mv mw">function loadPages(count: number = 10) {<br/>  // ...<br/>}</span></pre><h1 id="7f5e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.使用enum记录意图</h1><p id="e393" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">枚举可以帮助您记录代码的意图。例如，当我们关心的是不同的值，而不是这些值的精确值时。</p><p id="b117" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">不好:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="0cfe" class="ms la it mo b gy mt mu l mv mw">const IMPORT_FILE_ERROR_MESSAGE: Record&lt;ImportFileErrorType, string&gt; = {  <br/>   'LIMIT': 'import.file.limit',<br/>   'UPLOAD_FAILED': 'import.file.upload.failed' <br/>}</span></pre><p id="737f" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">好:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="f2be" class="ms la it mo b gy mt mu l mv mw">export enum ImportFileErrorType {<br/>  LIMIT = 'LIMIT',<br/>  UPLOAD_FAILED = 'UPLOAD_FAILED',<br/>}</span><span id="f8f9" class="ms la it mo b gy mx mu l mv mw">const IMPORT_FILE_ERROR_MESSAGE: Record&lt;ImportFileErrorType, string&gt; = {<br/>   [ImportFileErrorType.LIMIT]: 'import.file.limit', <br/>   [ImportFileErrorType.UPLOAD_FAILED]: 'import.file.upload.failed'<br/>}</span></pre><p id="2cdf" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">值得注意的是，枚举是不可变的，试图修改它们的值会导致错误。</p><p id="8cbe" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">一般来说，枚举通常用在条件判断、常量和类型语句中，使您的代码更加健壮和可读。</p><p id="9667" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">如何区分类型和接口？请<a class="ae ky" href="https://javascript.plainenglish.io/the-difference-between-typescript-interface-and-type-final-version-3e8801a16b2f" rel="noopener ugc nofollow" target="_blank">阅读我的另一篇</a>文章，其中详细解释了他们的差异。</p><h1 id="d77f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">4.抽象类</h1><p id="c9ce" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当使用类继承时，我们不希望基类被实例化，所以我们可以使用TypeScript的<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members" rel="noopener ugc nofollow" target="_blank"> <em class="nd">抽象关键字</em> </a>来修改一个类，以表示它是一个只能被实现而不能被实例化的抽象类</p><p id="2e44" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">不好:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e952" class="ms la it mo b gy mt mu l mv mw">class Animal {<br/>   a(): void {}<br/>}</span><span id="5a1a" class="ms la it mo b gy mx mu l mv mw">class Dog extends Animal {}</span><span id="b045" class="ms la it mo b gy mx mu l mv mw">// No error, but the Animal is the base class,<br/>// We don't want it to be instantiated<br/>new Animal().a()</span></pre><p id="8299" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">好:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="1084" class="ms la it mo b gy mt mu l mv mw">abstract class Animal {<br/>   a(): void {}<br/>}</span><span id="5ade" class="ms la it mo b gy mx mu l mv mw">class Dog extends Animal {<br/>   a() {}<br/>}</span><span id="d90f" class="ms la it mo b gy mx mu l mv mw">// Error: Cannot create an instance of an abstract class.(2511)<br/>new Animal().a()</span></pre><h1 id="34a2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">5.高内聚低耦合</h1><p id="c8a6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">内聚定义了类成员之间相互关联的程度。理想情况下，每个方法都应该使用一个类中的所有字段。然后我们说这个类是<em class="nd">最大内聚</em>。然而，在实践中，这并不总是可能的，甚至也不可取。然而，您应该更喜欢内聚力高。</p><p id="f799" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">耦合指的是两个类之间的相关或依赖程度。如果其中一个类的变化不影响另一个，那么这个类就是低耦合的。</p><p id="90c9" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">好的软件设计是高内聚低耦合的。</p><p id="1709" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">不好:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="fb84" class="ms la it mo b gy mt mu l mv mw">class UserManager {<br/>  // Bad: each private variable is used by one or another group of methods.<br/>  // It makes clear evidence that the class is holding more than a single responsibility.<br/>  // If I need only to create the service to get the transactions for a user,<br/>  // I'm still forced to pass and instance of `emailSender`.<br/>  constructor(<br/>    private readonly db: Database,<br/>    private readonly emailSender: EmailSender) {<br/>  }</span><span id="513f" class="ms la it mo b gy mx mu l mv mw">  async getUser(id: number): Promise&lt;User&gt; {<br/>    return await db.users.findOne({ id });<br/>  }</span><span id="0cd2" class="ms la it mo b gy mx mu l mv mw">  async getTransactions(userId: number): Promise&lt;Transaction[]&gt; {<br/>    return await db.transactions.find({ userId });<br/>  }</span><span id="2d94" class="ms la it mo b gy mx mu l mv mw">  async sendGreeting(): Promise&lt;void&gt; {<br/>    await emailSender.send('Welcome!');<br/>  }</span><span id="a29c" class="ms la it mo b gy mx mu l mv mw">  async sendNotification(text: string): Promise&lt;void&gt; {<br/>    await emailSender.send(text);<br/>  }</span><span id="94b9" class="ms la it mo b gy mx mu l mv mw">  async sendNewsletter(): Promise&lt;void&gt; {<br/>    // ...<br/>  }<br/>}</span></pre><p id="a531" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">好:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="cc53" class="ms la it mo b gy mt mu l mv mw">class UserService {<br/>  constructor(private readonly db: Database) {}</span><span id="c949" class="ms la it mo b gy mx mu l mv mw">  async getUser(id: number): Promise&lt;User&gt; {<br/>    return await this.db.users.findOne({ id });<br/>  }</span><span id="71ce" class="ms la it mo b gy mx mu l mv mw">  async getTransactions(userId: number): Promise&lt;Transaction[]&gt; {<br/>    return await this.db.transactions.find({ userId });<br/>  }<br/>}</span><span id="a19a" class="ms la it mo b gy mx mu l mv mw">class UserNotifier {<br/>  constructor(private readonly emailSender: EmailSender) {}</span><span id="5d55" class="ms la it mo b gy mx mu l mv mw">  async sendGreeting(): Promise&lt;void&gt; {<br/>    await this.emailSender.send('Welcome!');<br/>  }</span><span id="14a4" class="ms la it mo b gy mx mu l mv mw">  async sendNotification(text: string): Promise&lt;void&gt; {<br/>    await this.emailSender.send(text);<br/>  }</span><span id="3489" class="ms la it mo b gy mx mu l mv mw">  async sendNewsletter(): Promise&lt;void&gt; {<br/>    // ...<br/>  }<br/>}</span></pre><h1 id="c897" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">6.偏好组合而非继承</h1><p id="cdf4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如四人组在<a class="ae ky" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">设计模式</a>中所说的，在可能的情况下，你应该<em class="nd">更喜欢组合而不是继承</em>。有很多很好的理由使用继承，也有很多很好的理由使用组合。这条格言的主要观点是，如果你的大脑本能地去继承，试着想想构图是否能更好地模拟你的问题。在某些情况下，它可以。</p><p id="17d3" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">你可能会想，“什么时候我应该使用继承？”这取决于你手头的问题，但是这是一个继承比组合更有意义的列表:</p><ol class=""><li id="2a79" class="ni nj it lt b lu my lx mz ma nk me nl mi nm mm nn no np nq bi translated">您的继承代表“是-a”关系，而不是“有-a”关系(人类-&gt;动物对用户-&gt;用户详细信息)。</li><li id="0577" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">您可以重用基类中的代码(人类可以像所有动物一样移动)。</li><li id="a5a5" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">您希望通过更改基类来对派生类进行全局更改。(改变所有动物运动时的热量消耗)。</li></ol><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="81b5" class="ms la it mo b gy mt mu l mv mw">class Employee {<br/>  constructor(<br/>    private readonly name: string,<br/>    private readonly email: string) {<br/>  }</span><span id="5cee" class="ms la it mo b gy mx mu l mv mw">  // ...<br/>}</span><span id="f8b8" class="ms la it mo b gy mx mu l mv mw">// Bad because Employees "have" tax data. <br/>// EmployeeTaxData is not a type of Employee<br/>class EmployeeTaxData extends Employee {<br/>  constructor(<br/>    name: string,<br/>    email: string,<br/>    private readonly ssn: string,<br/>    private readonly salary: number) {<br/>    super(name, email);<br/>  }</span><span id="0589" class="ms la it mo b gy mx mu l mv mw">  // ...<br/>}</span></pre><p id="55aa" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">好:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="fe95" class="ms la it mo b gy mt mu l mv mw">class Employee {<br/>  private taxData: EmployeeTaxData;</span><span id="2847" class="ms la it mo b gy mx mu l mv mw">  constructor(<br/>    private readonly name: string,<br/>    private readonly email: string) {<br/>  }</span><span id="4f28" class="ms la it mo b gy mx mu l mv mw">  setTaxData(ssn: string, salary: number): Employee {<br/>    this.taxData = new EmployeeTaxData(ssn, salary);<br/>    return this;<br/>  }</span><span id="61a6" class="ms la it mo b gy mx mu l mv mw">  // ...<br/>}</span><span id="f344" class="ms la it mo b gy mx mu l mv mw">class EmployeeTaxData {<br/>  constructor(<br/>    public readonly ssn: string,<br/>    public readonly salary: number) {<br/>  }</span><span id="88f2" class="ms la it mo b gy mx mu l mv mw">  // ...<br/>}</span></pre><h1 id="69b0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">7.使类型更加耦合</h1><p id="17d0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当许多人编写类型脚本代码时，他们通常喜欢这样写:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6039" class="ms la it mo b gy mt mu l mv mw">const getUserNameById = (id: string) =&gt; {}</span></pre><p id="eb01" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">嗯，这很好，至少我们知道我们需要传入一个<code class="fe nf ng nh mo b">string</code>参数，但是<code class="fe nf ng nh mo b">getUserNameById</code>看起来像一组相关的函数，所以最好的办法是:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="7ecb" class="ms la it mo b gy mt mu l mv mw">interface IUser {<br/>   readonly id: string;<br/>   name: string;<br/>   email: string;<br/>}</span><span id="d7d1" class="ms la it mo b gy mx mu l mv mw">const getUserNameById = (id: IUser['id']) =&gt; {}</span></pre><p id="56f8" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">这个看起来好多了。另一个有趣的情况是当你的函数返回<code class="fe nf ng nh mo b">a Boolean type</code>时，如果条件合适，你最好这样写:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="7dc0" class="ms la it mo b gy mt mu l mv mw">const isCurrentUser = (user: IUser): user is IUser =&gt; { <br/>   return user.name === 'Keris'<br/>}</span></pre><p id="5e1f" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">让类型充满耦合性无疑是最好的决定，在React中可以大量练习。</p></div></div>    
</body>
</html>