# 从数小时到数秒:SQL 查询优化的故事

> 原文：<https://betterprogramming.pub/from-hours-to-seconds-a-tale-of-sql-query-optimization-e0d38066e043>

## 查询优化技术的一个例子

![](img/3ea852b2e73171d619775b5a35f9079f.png)

upklyak 创作的卡通城堡矢量—[www.freepik.com](http://www.freepik.com)

那是星期一中午。当一个新特性发布到产品中时，我知道它会导致大量新记录被添加到表中:`movies`。但是我不知道接下来会发生什么。

# 问题是

我监控了一个客户的日志，等待一个主要流程完成，然后确认发布没有破坏任何东西。随着时间的推移，流程未能完成，我意识到有些地方出错了。

因为这是一个关键的过程，而一个客户在另一边等着，所以我必须马上修复它。在一次调试过程中，我发现我们的一个数据库查询变得非常慢。手术花了几个小时才完成。

## “淘气”的查询

```
SELECT   
  title,   
  director,  
  time 
FROM movies 
WHERE  
  idStudio= 10 AND   
  genre IN ('Crime Thriller', 'Spy Thriller', 'Legal Thriller') AND   
  time > '1970-01-01' 
ORDER BY time ASC 
LIMIT 10000
```

关于`movies`表，值得注意以下几点:

1.  这是一个 InnoDB 表。
2.  表的主键是`id`，这是一个自动递增的列，用于给每一行一个惟一的标识。
3.  该表的两个索引是:
    a .`KEY `idx_time` (`time`)`b .`KEY `idx_idStudio_genre_time` (`idStudio`,`genre `,`time`)`

请注意:

*   索引`idx_idStudio_genre_time`涵盖了“淘气”查询的`WHERE`子句中使用的列。
*   在`SELECT`子句中有两列(`title`、`director`)没有被表的任何索引覆盖。

## 放弃

您可能已经猜到，我不从事电影行业，因此电影表是虚构的，但是表索引和查询结构是基于原始查询的。

# 没有选择的路——改变桌子

最初，我的方法是改变`movies`表的结构(从而修改查询)。

我使用了`explain`语句来收集关于 MySQL 优化器如何执行查询的信息，看起来 MySQL 优化器并没有选择我期望的索引。我预计会选择`idx_idStudio_genre_time`索引，但结果却是选择了`idx_time`索引。

此外，我们在查询的`SELECT`子句中选择了两列(`title`和`director`，它们没有被任何索引覆盖。在这种情况下，MySQL 遍历整个表来检索不在索引中的列的值。这可能会导致性能问题。

而且，查询有两个范围条件:`genre IN (...) AND time > '1970-01-01'`。一旦满足第一个范围条件，查询中的任何后续条件都不会使用任何进一步的索引。索引中同时包含`genre`和`time`不会影响查询性能。索引只是占用了额外的存储空间。

我打算改进表索引并向表中添加列，以解决这些问题和其他问题。例如，“犯罪惊悚片”、“间谍惊悚片”和“法律惊悚片”都属于同一类别:“惊悚片”。通过向表中添加一个`category`列并用`INDEX(`idStudio`,`category`,`time`)`对其进行索引，我们可以更新查询以使用`category`而不是`genre`，从而避免使用第二个范围条件。

我的目标是提高查询性能，但是，我提出的方法有两个主要缺点:

*   首先，索引有很大的开销。添加更多索引时，索引表上的写入速度会变慢。
*   第二，桌子太大了，所以要花几个小时来改变它。为了测试我的理论，我复制了我们的数据库(模拟生产尺寸表)并在测试数据库的`movies`表中添加了**一个**列。因为这个表太大了，所以迁移花了 7 个小时。

此时，很明显这不是我们想要走的路。更改`movies`表有更广泛的影响，需要很长时间，我们面临着一个紧迫的问题。

# 选择的道路—重写查询

“唯一代码”解决方案是最快的策略。我们可以在数据库上手动运行它，以立即了解查询的性能，然后将其合并到产品中，并为我们所有的客户进行测试。如果不起作用，我们可以通过单击回滚到之前的查询。

尽管看起来希望渺茫，但我们选择更新查询以利用表的现有索引`idx_idStudio_genre_time`，并减少查询从中选择`title`、`director`和`time`列的数据集。

重写查询以产生与原始查询相同的结果的效果令人惊讶。查询不再在**小时**内执行，而是在**秒**内执行。

## 重写的查询

```
SELECT   
  title,   
  director,  
  time 
FROM movies
JOIN (
  **SELECT   
    id
  FROM movies
  WHERE  
    idStudio= 10 AND   
    genre IN ('Crime Thriller', 'Spy Thriller', 'Legal Thriller')AND 
    time > '1970-01-01' 
  ORDER BY time ASC 
  LIMIT 10000**
) innerTable  
ON movies.id = innerTable.id
```

请注意以下几点:

*   `JOIN`子句查询(“子查询”)与“淘气”查询相同。除了选择了作为`movies`表主键的`id`列。
*   “子查询”产生的表称为`innerTable`。
*   工作台`movies`与工作台`innerTable`连接。在“淘气”查询中选择的列是从重写的查询中的连接表中选择的。

# 有什么魔力？

万岁！问题已经解决。现在，查询在几秒钟内返回结果，流程对我们的客户来说是有效的，每个人都很高兴。

但是这让我很困扰…为什么这个查询的性能要好得多呢？这两个查询提供了相同的输出，但是它们在大型数据集上的性能却大不相同…有什么诀窍吗？

你可能会惊讶地发现 [MySQL 会自动索引主键](https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html)。这意味着所有的`movies`表索引都包括表的`id`列。

`idx_idStudio_genre_time`现在是“子查询”的**覆盖索引**。这是一个为查询提供所有必要结果的索引。因为“子查询”只使用属于该索引的列，所以可以快速地从索引树中提取所选的值(`id`)。不像“淘气”查询，它需要额外的表查找来检索所有需要的列。

`PRIMARY KEY`索引用于连接`movies`和`innerTable`表。使用`eq_ref`连接类型连接表，如`explain`输出中所述。这是可能的最佳连接类型之一。当索引的所有部分都被 join 使用并且索引是一个 `[PRIMARY KEY](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)`"时使用。

在查询中使用`(INNER) JOIN`导致我们从中选择值的数据集的大小显著减小。当数据集较小时，选择`title`、`director`和`time`列相对较快。

# 外卖食品

1.  **做出“最小可行的改变”。**当我们发现一个问题时，我们可能会试图解决所有有问题的方面，但是专注于最小的可测试解决方案，为我们的客户提供价值，让我们能够更快地行动并提供快速的解决方案。
2.  减少查询的 FROM 子句中的记录数量。如果您在查询大型表时遇到问题，请尝试使您从中选择值的数据集变小。例如，使用我在这篇博客中提到的技巧。
3.  充分利用你所拥有的。利用当前的表索引，了解数据库的“免费”功能，并创造性地使用它们。
4.  **与你的队友合作提出解决方案。**头脑风暴是创造新想法的宝贵工具。当你和你的团队需要考虑一个新的解决方案时，尤其如此。
5.  **分享你学到的东西。与他人交流你的新知识和见解，这样他们也能从中受益。**

感谢阅读。我希望这有所帮助！

特别感谢我在鸟居的同事 Lital Weiss 和 Tal Bereznitskey，感谢你们对这个问题的深思熟虑和集思广益。