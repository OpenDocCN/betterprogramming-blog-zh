<html>
<head>
<title>Why Do Programming Languages Have Types?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么编程语言有类型？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-do-programming-languages-have-types-c9346faf9559?source=collection_archive---------7-----------------------#2021-07-27">https://betterprogramming.pub/why-do-programming-languages-have-types-c9346faf9559?source=collection_archive---------7-----------------------#2021-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a70c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从非类型化到类型化的演练</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eb57bfcf99f581b94f5cf8e3a5c9f264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EnnaewM_kB4w8bxa.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sf1221?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扶苏</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="83a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">静态类型和动态类型哪个更好？</p><p id="f458" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">静态类型可以在运行代码之前发现代码中的错误。然而，这样的打字错误发生的频率有多高？此外，类型不是测试，即使使用类型，您仍然必须证明程序的正确性。尽管如此，一个良好类型的程序将会更加可靠和易于阅读。</p><p id="83c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打字不仅是一个有趣的争论话题，也是一种可以帮助完成工作的工具。</p><p id="61da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想做一个概述，找出不同类型的打字是如何联系在一起的。我相信，理解类型是如何产生的，将有助于我们更明智地使用它们，尤其是在我们可以选择的语言中。</p><h1 id="a52a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">无类型世界</h1><p id="b9c2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">低级上没有类型。CPU和内存过着自己的生活，却不知道什么是类型。他们只有0和1。</p><p id="97b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">机器字是低级别的唯一类型。</p><p id="a7e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算机内存在各种大小的存储单元中存储信息，CPU执行机器字上的指令。非类型化的0和1变成1类型的宇宙——不同大小的位串。</p><p id="1b35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">底层世界是1型的，一切都要用机器字来表示:字符、数字、指针、结构化数据、程序等。</p><p id="ed3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当查看一段原始内存时，无法判断它代表了什么。一段记忆的意义是由对其内容的外部解释决定的。</p><h1 id="690a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是类型？</h1><p id="e5d1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">类型自然出现，甚至从非类型化开始。一旦我们开始在一个单一类型的世界中工作，我们就开始为了不同的目的以不同的方式组织它。任何领域都会出现类型，根据对象的用途和行为对它们进行分类。根据目的对对象进行分类会产生一个类型系统。</p><p id="1b8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型是用机器语言表达的抽象概念。当我们谈论类型时，我们通常指的是以下几种情况。</p><ul class=""><li id="fd91" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">语法—类型是与变量相关联的标签。</li><li id="9f67" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">值域-变量可以处理的可能值。</li><li id="eb77" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">表示——如何表示一个类型，它可以是一个原始的机器类型，也可以是多个类型的组合。</li><li id="2d4f" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">行为——用给定类型限定的一些操作。</li></ul><p id="939b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些意义可以结合起来。例如，如果我们只定义一个行为，那么我们有一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Abstract_data_type" rel="noopener ugc nofollow" target="_blank">抽象数据类型</a>。当我们有了表现+行为，我们就有了具体的实现。</p><h1 id="fe3f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">类型为什么有用？</h1><p id="d296" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">类型系统的目的是避免关于表示的问题，并描述适当的行为。类型施加约束，有助于加强正确性。此外，类型对于开发人员思考软件结构很有价值。</p><p id="0313" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型是我们思考事物过程的一部分。</p><p id="c490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们看看使用类型系统的好处，我们可以强调:</p><ul class=""><li id="5de2" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">抽象</strong> —类型有助于在比字节更高的层次上思考</li><li id="f91d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">文档</strong> —定义良好的类型也可以是代码的文档</li><li id="2256" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">安全</strong> —帮助查找行为未定义的无效代码</li><li id="fd45" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">优化</strong> —在运行时或编译阶段进行优化</li></ul><p id="128f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">静态和动态类型。</p><p id="f696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们有类型，我们必须有一个验证它们的需求和约束的过程。这个过程可以在运行程序之前静态完成，也可以在运行时动态完成。</p><h1 id="05af" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">静态打字</h1><p id="c22d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">静态类型是通过分析源代码来证明类型正确性的过程。</p><h2 id="c8b0" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated"><strong class="ak">清单类型化</strong>和<strong class="ak">类型化推理。</strong></h2><p id="adf1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以手动定义程序中每个变量的类型，这样我们就有了一个清单类型。或者我们可以依靠类型推断规则，这些规则可以在很少或没有类型信息的情况下推断出表达式的类型。</p><p id="221f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">静态类型是一个很好的工具，但是源代码中所有变量和表达式都绑定到一个类型的要求有时过于严格。</p><p id="1442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多编程语言特性不能被静态检查。其中有<a class="ae kv" href="https://en.wikipedia.org/wiki/Dynamic_dispatch" rel="noopener ugc nofollow" target="_blank">动态调度</a>、<a class="ae kv" href="https://en.wikipedia.org/wiki/Late_binding" rel="noopener ugc nofollow" target="_blank">后期绑定</a>、<a class="ae kv" href="https://en.wikipedia.org/wiki/Downcasting" rel="noopener ugc nofollow" target="_blank">向下转换</a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Reflective_programming" rel="noopener ugc nofollow" target="_blank">反射</a>。</p><p id="e448" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">静态地知道每个变量的类型的约束可以由较弱的需求代替。所有表达式都保证类型一致，尽管类型本身可能是静态未知的。这通常可以通过引入一些运行时类型检查来实现。</p><h1 id="a4cc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">动态打字</h1><p id="ae4b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">动态类型化是在运行时检查程序类型安全的过程。</p><p id="2619" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多编程语言包括某种动态类型检查，即使它们也有静态类型检查器。原因是有些属性很难甚至不可能静态验证。</p><p id="b966" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">甚至像C++和Java这样的传统静态类型语言也在运行时进行类型检查。这些语言支持将<a class="ae kv" href="https://en.wikipedia.org/wiki/Downcasting" rel="noopener ugc nofollow" target="_blank">类型向下转换为</a>类型的子类型。</p><p id="8037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在运行时，程序可能有各种类型的错误。在一些语言中，这样的错误被认为是致命的，在其他语言中，从这些错误中恢复是可能的。</p><h2 id="5ce3" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated"><strong class="ak">强</strong>和<strong class="ak">弱打字。</strong></h2><p id="6d94" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">另一个选择是运行时可以进行隐式类型转换。或者我们是否可以使用指针对它们执行算术运算并绕过类型限制。在这种情况下，通常称为弱类型。</p><h1 id="dabc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">多态性</h1><p id="07a0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">语言的另一个非常重要的特性是代码能够操作多种类型的值。这种能力就是多态性，它提供了在不同类型上重用相同代码的可能性。</p><h2 id="e495" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated"><strong class="ak"> <em class="np">多态</em> </strong> <em class="np">和</em> <strong class="ak"> <em class="np">单态</em> </strong> <em class="np">语言</em></h2><p id="f092" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与多态形成对比的是单态语言。在这些语言中，函数和过程只能有一个唯一的类型。Pascal可以是这种语言的一个例子。</p><p id="c77d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种方法可以在语言中实现多态性。反正这些可能性都是和打字紧密相关的。</p><h1 id="edea" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">渐进打字</h1><p id="ef37" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">静态或动态类型检查都不是最好的。如果有可能在不改变编程语言的情况下选择一种类型就好了。这个概念把我们带到了渐进打字。</p><p id="009a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它允许程序的一部分被动态类型化，而另一部分被静态类型化。</p><p id="8086" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">历史上，这个术语被用于引入静态分析可能性的动态语言。其中有Python，Typescript，Clojure。</p><p id="0b3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">C#可以被认为是逐渐类型化的，从4.0版本开始变量可以被标记为动态的。</p><p id="5feb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，在这个新术语出现之前，不同类型方法的组合就已经存在了。</p><h1 id="f902" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="1e28" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如我们所见，什么是更好的没有正确的答案。但是看到语言是如何不断地变化和发展是令人兴奋的。</p><p id="aa90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更先进的方法被用来实现语言的灵活性、优化性和表现力。</p><blockquote class="nq"><p id="13e5" class="nr ns iq bd nt nu nv nw nx ny nz lr dk translated"><em class="np">那些不知道底子的人，注定要不断争论更好的办法。但这总是一种权衡。</em></p></blockquote><p id="87dd" class="pw-post-body-paragraph kw kx iq ky b kz oa jr lb lc ob ju le lf oc lh li lj od ll lm ln oe lp lq lr ij bi translated">感谢您的阅读！在<a class="ae kv" href="https://twitter.com/pavelfokin_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我分享你的想法</p><h1 id="6da9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考</h1><ul class=""><li id="fc95" class="mp mq iq ky b kz mk lc ml lf of lj og ln oh lr mu mv mw mx bi translated">卢卡·卡德里，彼得·韦格纳(1985年12月)。理解类型、数据抽象和多态。</li><li id="b915" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">卢卡·卡德里，2004，类型系统</li><li id="815d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">罗伯特·马丁，干净代码博客，<a class="ae kv" href="https://blog.cleancoder.com/uncle-bob/2017/01/13/TypesAndTests.html" rel="noopener ugc nofollow" target="_blank">类型和测试</a></li><li id="09ec" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">Jeremy Siek，<a class="ae kv" href="https://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/" rel="noopener ugc nofollow" target="_blank">什么是渐进打字</a></li></ul></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="d276" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="op">原发布于</em><a class="ae kv" href="https://pavelfokin.dev/blog/why-do-programming-languages-have-types" rel="noopener ugc nofollow" target="_blank"><em class="op">https://Pavel fokin . dev</em></a><em class="op">。</em></p></div></div>    
</body>
</html>