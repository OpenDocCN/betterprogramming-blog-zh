<html>
<head>
<title>Fetching Data With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React获取数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fetching-data-with-react-72df95683c70?source=collection_archive---------6-----------------------#2022-02-01">https://betterprogramming.pub/fetching-data-with-react-72df95683c70?source=collection_archive---------6-----------------------#2022-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="965c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从定制代码到强大的库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d956f768ea52bb5b0058dfc63bb7760d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6FIWECCievGq5916Z4h_w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sanderweeteling" rel="noopener ugc nofollow" target="_blank">桑德韦特林</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><h1 id="663f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="a8c4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们创建一个React应用程序时，有很多机会您必须从远程服务器获取数据。</p><p id="6b4e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">根据您的项目，您可能需要进行简单的调用或使用高级技术来缓存或更新您的数据。</p><p id="9455" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇博文中，我们将讨论定制的数据获取，同时也快速预览一下<a class="ae ky" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> React Query </a>和<a class="ae ky" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank"> SWR </a>。让我们浏览一下这些常见的技术，这样您就可以为您的用例选择正确的技术。</p><h1 id="5ebd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">基本数据提取</h1><p id="fa4b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了解释如何进行自定义数据提取，我们将通过几个步骤来理解如何使代码足够健壮，这是基于对完美加载系统的考虑。</p><p id="3270" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您没有足够的信心独自管理它，我建议您直接阅读SWR的最后一部分，然后使用React Query。</p><h1 id="c7aa" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用JavaScript获取方法</h1><p id="352e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了让一个基本的数据获取工作，我们只需要一个包含恢复数据的位置和一个进行实际获取的方法。</p><p id="d2e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">说到代码，它由获取数据的<code class="fe ms mt mu mv b">useEffect</code>钩子和请求一结束就存储数据的<code class="fe ms mt mu mv b">useState</code>钩子组成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b6b8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如您所见，只需几行代码就可以从远程服务器获取数据。收集数据就像使用React一样简单。</p><h1 id="92ab" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">分离关注点</h1><p id="2d9a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">前面的代码非常简单，但是web开发中的一个共同原则是关注点分离，这是我们在前面的两个钩子部分中没有考虑到的。</p><p id="cd4a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有很多方法可以做到。例如，我将使用Provider组件和React上下文来处理这个问题。你可以在我以前的文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-i-dropped-redux-for-the-context-api-7338d481e179">中找到更多关于我如何为上下文API </a>放弃Redux的信息。</p><p id="aead" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了按照这种方式分离关注点，我现在将把显示组件包装到另一个管理数据获取的组件中。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="beb4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的渲染代码现在更整洁了，因为逻辑已经被提取到另一个负责逻辑的组件中。</p><p id="72d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以看到，这次我选择使用loadData回调和<code class="fe ms mt mu mv b">useEffect</code>挂钩。这是因为我考虑用额外的参数来改进这个方法——虽然不在本教程中——来管理分页、重新验证等等。</p><p id="f145" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">同样，我已经将数据封装在一个子对象<code class="fe ms mt mu mv b">values</code>中，准备支持另一个子对象<code class="fe ms mt mu mv b">actions</code>进行手动重新加载等等。</p><h1 id="cade" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">添加加载和错误状态</h1><p id="dbf1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在许多应用程序中，我们希望向用户显示我们当前正在加载数据，或者我们是否遇到了错误。</p><p id="ca62" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为此，我们只需添加两个对应于加载和错误的布尔状态。</p><p id="f12a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些状态意味着这样工作:</p><ul class=""><li id="c3ec" class="my mz it lt b lu mn lx mo ma na me nb mi nc mm nd ne nf ng bi translated">默认情况下，加载状态应为false，因为没有进行任何操作</li><li id="f222" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">一旦我们启动数据加载，加载状态应该切换到true</li><li id="7a13" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">当请求结束时，加载状态应该回到false</li><li id="f530" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">默认情况下，错误状态应该为false，因为还没有错误(希望永远没有)</li><li id="fd7c" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">一旦我们启动数据加载，错误状态应该被重置为false以删除旧的错误</li><li id="be62" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">如果加载出错，错误状态应该转换为真</li></ul><p id="a06c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是一个代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="73e7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们的应用程序用自定义消息向用户报告加载和错误状态。</p><p id="502c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个解决方案非常简单，但是您可以自由地添加额外的数据，比如针对错误的特定消息、更好的加载，或者页面的框架，以创建更好的界面。</p><p id="5327" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在很多网站上犯的一个常见错误是不提供网站上发生了什么的信息。你可能会失去用户，因为如果没有加载指示器，他们会认为你的应用程序崩溃了，或者如果错误不够明确，他们可能会认为你的服务没有工作。</p><p id="442f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我个人的建议是:</p><ul class=""><li id="7606" class="my mz it lt b lu mn lx mo ma na me nb mi nc mm nd ne nf ng bi translated">加载数据时添加页面的框架</li><li id="4c02" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">如果可能，显示加载进度指示器</li><li id="d91e" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">如果第一点太复杂，添加一个微调按钮或文本来指示数据正在加载</li><li id="eac1" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">缓存请求以避免服务器不必要的等待，或者提出“重新验证时过时”的行为</li><li id="1213" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">如果你遇到一个错误，给你的用户准确的信息。，例如，“您的数据无效，尚未保存”或“加载此产品时遇到问题，请稍后再试。”</li></ul><h1 id="b98c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">分解为挂钩</h1><p id="ff09" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">开发应用程序时，您可能不会只有一个地方需要加载数据。您的每个页面都是获取远程服务器的候选者。</p><p id="eec8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过前面的代码，我们可以清楚地看到，如果我们希望保持相同的代码结构，就会复制很多代码，即使我们希望进行的唯一更新是URL更改。</p><p id="bd8d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">解决这个问题的一个很好的方法是创建一个自定义钩子来包含错误、加载和数据状态钩子以及数据加载方法。这个钩子将获得一个URL作为参数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3293" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，所有的数据获取都将由钩子来管理，提供者代码将更容易阅读。</p><p id="1aa0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">同样，这是一个非常简单的用例，您可能需要处理:</p><ul class=""><li id="6af1" class="my mz it lt b lu mn lx mo ma na me nb mi nc mm nd ne nf ng bi translated">提出发布请求</li><li id="a566" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">根据POST请求添加正文内容</li><li id="0a3b" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">处理HTTP头</li><li id="be8e" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">管理认证</li></ul><h1 id="fd99" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">我们真的需要组件中的分离问题吗？</h1><p id="1e45" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们的提供者变成了一个简单的从钩子到组件的通道，我们可以问自己它是否仍然是一个相关的组件来包含在我们的代码中，或者它是否是不必要的。</p><p id="ea92" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我相信你的组件越少，你的代码就越容易被其他人阅读(验证KISS原则)。然后，我选择删除提供者部分，只保留视图组件和挂钩。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7711" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为什么要走这么多步才能到达那里？我在许多项目中看到，保留遗留代码层是一个非常常见的错误。我希望你能避免这些错误，因为你在数据获取中添加了更多的特性。</p><p id="4ea0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">根据我的需要，我也可以删除本可以在这里完成的<code class="fe ms mt mu mv b">useEffect</code>部分，因为我们显然总是希望直接加载数据。</p><h1 id="35e4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用数据提取库</h1><p id="8d54" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">编写数据获取非常简单，但是有很多原因会让自己编写代码变得非常痛苦。我们刚刚编写的预览代码可能很容易在您的脑海中想象出来，但是如果您需要:</p><ul class=""><li id="b62d" class="my mz it lt b lu mn lx mo ma na me nb mi nc mm nd ne nf ng bi translated">添加查询缓存系统</li><li id="5294" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">处理总是最新的数据</li><li id="adc5" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">调试您的请求</li><li id="9da3" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">处理分页和无限加载</li><li id="335e" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">保持数据脱机可用</li></ul><p id="9ee2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你现在能想象出你脑子里所有需要的代码吗？我个人不能，所以我要把这个留给最伟大的天才。</p><p id="c8f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，我们的需求给了我们大量的工作，甚至不包括代码维护和所需的安全补丁。希望有一些开源库已经为你管理了这个，比如<a class="ae ky" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> React Query </a>和<a class="ae ky" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank"> SWR </a>。</p><p id="f033" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些库在你的应用中实现起来可能比我们之前编写的钩子稍微复杂一点，但是它们也更加强大。</p><p id="72f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看看如何开始使用它们。</p><h1 id="1a20" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">SWR</h1><p id="73bd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank"> SWR </a>是由<a class="ae ky" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>开发的轻量级库。</p><p id="f5e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，SWR本身不会处理这一请求。您需要创建一个<code class="fe ms mt mu mv b">fetcher</code>方法，但是代码非常简单，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4494" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">几乎所有我们以前自己编写的逻辑都是由<code class="fe ms mt mu mv b">useSWR</code>钩子管理的。不要以为代码神奇的消失了！</p><p id="3f74" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你可能会问自己，如果我们仍然需要使用<code class="fe ms mt mu mv b">fetcher</code>方法，为什么还要使用SWR？因为SWR有很多有用的特点，包括以下几点:</p><ul class=""><li id="e320" class="my mz it lt b lu mn lx mo ma na me nb mi nc mm nd ne nf ng bi translated">它会自动缓存您的请求</li><li id="b98e" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">它处理反应悬念</li><li id="6f63" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">当聚焦窗口和/或定期时，它自动重新验证数据</li><li id="ffee" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">它可以管理分页、SSR</li></ul><h1 id="bbc6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">反应查询</h1><p id="9dae" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> React Query </a>开始有点复杂:它需要在您的应用程序之上有一个提供者组件，并结合一个查询客户端。</p><p id="51ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，像SWR一样，实际的抓取是由你来做。</p><p id="a7ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">完成后，它将像我们到目前为止所介绍的一样简单易用，只有一个不同的标签系统。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e7e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与其他系统相比，React query还有许多令人惊叹的功能，可以在<a class="ae ky" href="https://react-query.tanstack.com/comparison" rel="noopener ugc nofollow" target="_blank"> React Query网站</a>上找到，包括:</p><ul class=""><li id="e039" class="my mz it lt b lu mn lx mo ma na me nb mi nc mm nd ne nf ng bi translated">强大的缓存系统</li><li id="89c1" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">专用开发工具</li><li id="edf7" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">反应暂停支持</li><li id="ae6f" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">自动刷新</li><li id="5536" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">分页，SRR</li></ul><h1 id="60fc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="8a0c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在React中加载数据有很多方法——从管理我们自己的代码到使用强大的库。</p><p id="4ebd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就个人而言，在以下情况下，我会根据项目的规模和性质改变我使用的方法:</p><ul class=""><li id="a5dc" class="my mz it lt b lu mn lx mo ma na me nb mi nc mm nd ne nf ng bi translated">当制作一个请求很少的小网站时，我会制作自己的抓取代码(SWR和React Query是以规模为代价的)</li><li id="ca2e" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">当项目变大时，我会选择SWR(最佳尺寸/特征比)</li><li id="b7f0" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">在大型项目中，我更喜欢使用React Query，因为它将减少我在许多有用功能上的工作(需要高级功能)</li></ul><p id="a444" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢阅读。如果你想了解更多关于React的事情，请加入我的<a class="ae ky" href="https://twitter.com/brunosabot" rel="noopener ugc nofollow" target="_blank">推特</a>。</p></div></div>    
</body>
</html>