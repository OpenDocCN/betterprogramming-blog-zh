<html>
<head>
<title>Returning Collections From Methods in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Java中的方法返回集合</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/returning-collections-from-methods-in-java-33e0795df46e?source=collection_archive---------5-----------------------#2020-01-17">https://betterprogramming.pub/returning-collections-from-methods-in-java-33e0795df46e?source=collection_archive---------5-----------------------#2020-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd1f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">永远不要返回null来代替集合</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a474d69dea5d91f54dbee90c13cb75e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f5TltmrDo66_cZy-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@ellaolsson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ella Olsson </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写软件通常意味着获取和返回数据。在像Java这样的面向对象语言中，我们通常用类的属性来表示数据。与许多新的面向对象语言不同，Java不提供属性作为一级结构，所以我们使用JavaBean getters和setters来维护封装。因此，我们大多数人已经习惯于编写如下代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9e68" class="ma mb it lw b gy mc md l me mf">public class MyClass {<br/>    private String data;<br/>    public String getData() { return this.data; }<br/>    public void setData(String data) { this.data = data; }<br/>}</span></pre><p id="3079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们看到了一个具有简单属性的简单类:一个名为<em class="mj"> data </em>的<code class="fe mg mh mi lw b">String</code>。当然，<em class="mj">数据</em>既可以包含一个值，也可以是<em class="mj"> null </em>。</p><p id="8ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何处理<code class="fe mg mh mi lw b">Collection</code>类型的属性？让我们构造一个简单的类来封装一个<code class="fe mg mh mi lw b">List</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7b1c" class="ma mb it lw b gy mc md l me mf">public class MyClass {</span><span id="1d9e" class="ma mb it lw b gy mk md l me mf">    private List&lt;String&gt; myStrings;</span><span id="7069" class="ma mb it lw b gy mk md l me mf">}</span></pre><p id="732c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个名为<code class="fe mg mh mi lw b">myStrings</code>的字段——一列<code class="fe mg mh mi lw b">String</code>,它封装在<code class="fe mg mh mi lw b">MyClass</code>中。现在，我们需要提供访问器方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b740" class="ma mb it lw b gy mc md l me mf">public class MyClass {</span><span id="b4ac" class="ma mb it lw b gy mk md l me mf">    private List&lt;String&gt; myStrings;</span><span id="733d" class="ma mb it lw b gy mk md l me mf">    public void setMyStrings(List&lt;String&gt; s) {<br/>        this.myStrings = s;<br/>    }</span><span id="b0d1" class="ma mb it lw b gy mk md l me mf">    public List&lt;String&gt; getMyStrings() {<br/>        return this.myStrings;<br/>    }</span><span id="6d3e" class="ma mb it lw b gy mk md l me mf">}</span></pre><p id="b0c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个适当封装的——虽然冗长——类。所以我们做得很好，对吗？保持这种想法。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="cea7" class="ms mb it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">选修课</h1><p id="dcd8" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">考虑Java 8中引入的<code class="fe mg mh mi lw b">Optional</code>类。到目前为止，您可能已经听说过这样一句口头禅:永远不要从返回<code class="fe mg mh mi lw b">Optional</code>的方法中返回<em class="mj"> null </em>。为什么？考虑下面这个虚构的例子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c1bd" class="ma mb it lw b gy mc md l me mf">public class Foo {</span><span id="d5da" class="ma mb it lw b gy mk md l me mf">    private String bar;</span><span id="c9d2" class="ma mb it lw b gy mk md l me mf">    public Optional&lt;String&gt; getBar() {<br/>        // don't actually ever do this<br/>        return (bar == null) ? null : Optional.of(bar);<br/>    }</span><span id="ae2c" class="ma mb it lw b gy mk md l me mf">}</span></pre><p id="0a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在客户可以像这样使用这个方法，并冒着抛出<code class="fe mg mh mi lw b">NullPointerException</code>的风险:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8bb2" class="ma mb it lw b gy mc md l me mf">foo.getBar().ifPresent(log::info);</span></pre><p id="6dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，他们可以执行空检查:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9394" class="ma mb it lw b gy mc md l me mf">if (foo.getBar() != null) {<br/>    foo.getBar().ifPresent(log::info);<br/>}</span></pre><p id="8ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们永远不会写这样的方法。这样做违背了<code class="fe mg mh mi lw b">Optional</code> s的目的。事实上，它违背了<code class="fe mg mh mi lw b">Optional</code> s的目的，即任何返回<code class="fe mg mh mi lw b">Optional</code>的API都不会<em class="mj">返回空值。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/409fbb03c70ee8123ef54d432538d180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MltHP9q_Op6qFlj4.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">即使所有的袜子都拿掉了，抽屉还是存在的，对吧？</p></figure><p id="2d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe mg mh mi lw b">Collection</code> s. <code class="fe mg mh mi lw b">Collection</code> s和<code class="fe mg mh mi lw b">Optional</code> s其实是类似的野兽。它们都是用来保存其他值的“容器”对象。一个<code class="fe mg mh mi lw b">Optional</code>包含<em class="mj">无</em>或<em class="mj">有一个</em>，而一个<code class="fe mg mh mi lw b">Collection</code>包含<em class="mj">无</em>或<em class="mj">有</em>。(那些熟悉函数式编程的人可能会认为<code class="fe mg mh mi lw b">Collection</code> s和<code class="fe mg mh mi lw b">Optional</code> s是<a class="ae ky" href="https://samgrayson.me/2019-08-06-monads-as-a-programming-pattern/" rel="noopener ugc nofollow" target="_blank">单子</a>，尽管Java 8决定使用<code class="fe mg mh mi lw b">Stream</code> s意味着这在技术上是不正确的。)</p><p id="8626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，应该没有理由返回空的<em class="mj"/><code class="fe mg mh mi lw b">Collection</code>s。简单地返回一个空的(零大小)<code class="fe mg mh mi lw b">Collection</code>来指示缺少任何元素。</p><p id="41bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正是因为这个原因，确保返回<code class="fe mg mh mi lw b">Collection</code>类型(包括数组)的方法永远不返回<em class="mj"> null </em>值变得越来越常见，这与返回<code class="fe mg mh mi lw b">Optional</code>类型的方法相同。也许您或您的组织已经在编写新代码时采用了这条规则。如果没有，你应该。毕竟，你(或你的客户)愿意这样做吗？：</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a70b" class="ma mb it lw b gy mc md l me mf">boolean isUnique = personDao.getPersonsByName(name).size() == 1;</span></pre><p id="b01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者您的代码中有类似这样的东西吗？：</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4c03" class="ma mb it lw b gy mc md l me mf">List&lt;Person&gt; persons = personDao.getPersonsByName(name);<br/>boolean isUnique = (persons == null) ? false : persons.size() == 1;</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="158e" class="ms mb it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">掌控我们的收藏</h1><p id="c97b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">但是还有更多的东西。让我们回到我们的<code class="fe mg mh mi lw b">MyClass</code>课。事实上，<code class="fe mg mh mi lw b">MyClass</code>的实例可以很容易地从<code class="fe mg mh mi lw b">getMyStrings()</code>方法返回<code class="fe mg mh mi lw b">null</code>。事实上，一个新的实例就可以做到这一点。因此，为了遵守我们新的<em class="mj">永不返回空集合</em>准则，我们需要解决这个问题:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a01d" class="ma mb it lw b gy mc md l me mf">public class MyClass {</span><span id="b2d9" class="ma mb it lw b gy mk md l me mf">    private List&lt;String&gt; myStrings = new ArrayList&lt;&gt;();</span><span id="75a1" class="ma mb it lw b gy mk md l me mf">    public void setMyStrings(List&lt;String&gt; s) {<br/>        this.myStrings = s;<br/>    }</span><span id="11df" class="ma mb it lw b gy mk md l me mf">    public List&lt;String&gt; getMyStrings() {<br/>        return this.myStrings;<br/>    }</span><span id="9e02" class="ma mb it lw b gy mk md l me mf">}</span></pre><p id="af20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题解决了？不完全是。任何客户都可以调用<code class="fe mg mh mi lw b">aMyClass.setMyStrings(null)</code>，在这种情况下，我们又回到了起点。所以让我们扩展一下<code class="fe mg mh mi lw b">setMyStrings()</code>方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="39e9" class="ma mb it lw b gy mc md l me mf">public void setMyStrings(List&lt;String&gt; s) {<br/>    if (s == null) {<br/>        this.myStrings.clear();<br/>    } else {<br/>        this.myStrings = s;<br/>    }<br/>}</span></pre><p id="f6d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，即使将<code class="fe mg mh mi lw b">null</code>传递给setter，<code class="fe mg mh mi lw b">myStrings</code>也会保留一个有效的引用。我们都说完了吗？</p><p id="3634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算是吧。我们可以停在这里。但是真的，我们应该做更多的事情。</p><p id="3d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到我们仍然在用调用者传递给我们的<code class="fe mg mh mi lw b">List</code>替换我们的私有<code class="fe mg mh mi lw b">ArrayList</code>。这有两个问题。首先，我们不再控制<code class="fe mg mh mi lw b">myStrings</code>使用的具体的<code class="fe mg mh mi lw b">List</code>实现。理论上这应该不成问题吧？但是，请考虑以下情况:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="07f4" class="ma mb it lw b gy mc md l me mf">myClass.setMyStrings(Collections.unmodifiableList("Heh, gotcha!"));</span></pre><p id="fcf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们更新了<code class="fe mg mh mi lw b">MyClass</code>，使得它试图修改<code class="fe mg mh mi lw b">myStrings</code>的内容，运行时就会发生不好的事情。</p><p id="c3d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个问题是调用者保留了对<code class="fe mg mh mi lw b">MyClass</code>的底层<code class="fe mg mh mi lw b">List</code>的引用。所以现在，调用者可以直接操作我们的<code class="fe mg mh mi lw b">List</code>。</p><p id="3bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该做的是将传递给我们的元素存储在初始化了<code class="fe mg mh mi lw b">myStrings</code>的<code class="fe mg mh mi lw b">ArrayList</code>中。此外，我们应该对外部调用者隐藏类的内部。事实上，我们的类的调用者不应该关心是否有底层的<code class="fe mg mh mi lw b">List</code>、或者<code class="fe mg mh mi lw b">Set</code>、或者数组、或者一些运行时动态代码生成巫毒术存储我们传递给它的<code class="fe mg mh mi lw b">String</code>。他们应该关心的是设置和检索一组<code class="fe mg mh mi lw b">String</code> s。所以让我们更新<code class="fe mg mh mi lw b">setMyStrings()</code>方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3b8b" class="ma mb it lw b gy mc md l me mf">public void setMyStrings(Collection&lt;String&gt; s) {<br/>    this.myStrings.clear(); <br/>    if (s != null) { <br/>        this.myStrings.addAll(s); <br/>    } <br/>}</span></pre><p id="ad93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这具有确保<code class="fe mg mh mi lw b">myStrings</code>以包含在输入参数中的相同元素结束(或者如果传递了<code class="fe mg mh mi lw b">null</code>则为空)的效果，同时确保调用者没有对<code class="fe mg mh mi lw b">myStrings</code>的引用。</p><p id="aeb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然<code class="fe mg mh mi lw b">myStrings</code>引用不能改变，我们就让它保持不变吧:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ad19" class="ma mb it lw b gy mc md l me mf">public class MyClass {<br/>    private final List&lt;String&gt; myStrings = new ArrayList&lt;&gt;();<br/>    ...<br/>}</span></pre><p id="04b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们这么做的时候，我们不应该通过getter返回底层的<code class="fe mg mh mi lw b">List</code>。这也会让打电话的人直接提到<code class="fe mg mh mi lw b">myStrings</code>。为了补救这一点，回想一下<em class="mj">有效Java </em>灌输到我们头脑中的“防御性复制”咒语(或者应该有):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f58a" class="ma mb it lw b gy mc md l me mf">public List&lt;String&gt; getMyStrings() {<br/>    // depending on what, exactly, we want to return<br/>    return new ArrayList&lt;&gt;(this.myStrings);  <br/>}</span></pre><p id="8d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们有了一个封装良好的类，每当调用它的getter时，它都不需要进行空检查。然而，我们已经从客户那里拿走了一些控制权。因为他们不再能直接访问我们的底层<code class="fe mg mh mi lw b">List</code>，他们不再能添加或删除单个的<code class="fe mg mh mi lw b">String</code>。</p><p id="9eb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没问题—我们可以像这样简单地添加方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="47ab" class="ma mb it lw b gy mc md l me mf">public void addString(String s) {<br/>    this.myStrings.add(s);<br/>}</span></pre><p id="2229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有这个:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2de2" class="ma mb it lw b gy mc md l me mf">public void removeString(String s) { <br/>    this.myStrings.remove(s); <br/>}</span></pre><p id="a648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的调用者可能需要一次向一个<code class="fe mg mh mi lw b">MyClass</code>实例添加多个<code class="fe mg mh mi lw b">String</code>吗？这也很好:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5b8d" class="ma mb it lw b gy mc md l me mf">public void addStrings(Collection&lt;String&gt; c) {<br/>    if (c != null) {<br/>        this.myStrings.addAll(c);<br/>    }<br/>}</span></pre><p id="9ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以此类推:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e5af" class="ma mb it lw b gy mc md l me mf">public void clearStrings() {<br/>    this.myStrings.clear();<br/>}</span><span id="d578" class="ma mb it lw b gy mk md l me mf">public void replaceStrings(Collection&lt;String&gt; c) {<br/>    clearStrings();<br/>    addStrings(c); <br/>}</span></pre><h1 id="bb20" class="ms mb it bd mt mu np mw mx my nq na nb jz nr ka nd kc ns kd nf kf nt kg nh ni bi translated">收集我们的想法</h1><p id="4712" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">那么，下面是我们的(公认是人为的)类最终可能的样子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e510" class="ma mb it lw b gy mc md l me mf">public class MyClass {</span><span id="1250" class="ma mb it lw b gy mk md l me mf">    private final List&lt;String&gt; myStrings = new ArrayList&lt;&gt;();</span><span id="68ee" class="ma mb it lw b gy mk md l me mf">    public void setMyStrings(Collection&lt;String&gt; s) {<br/>        this.myStrings.clear(); <br/>        if (s != null) { <br/>            this.myStrings.addAll(s); <br/>        } <br/>    }</span><span id="08f9" class="ma mb it lw b gy mk md l me mf">    public List&lt;String&gt; getMyStrings() {<br/>        return new ArrayList&lt;&gt;(this.myStrings);<br/>    }</span><span id="5b80" class="ma mb it lw b gy mk md l me mf">    public void addString(String s) { <br/>        this.myStrings.add(s); <br/>    }</span><span id="228b" class="ma mb it lw b gy mk md l me mf">    public void removeString(String s) { <br/>        this.myStrings.remove(s); <br/>    }</span><span id="e5ea" class="ma mb it lw b gy mk md l me mf">    // And maybe a few more helpful methods...</span><span id="84b4" class="ma mb it lw b gy mk md l me mf">}</span></pre><p id="0652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们实现了一个类:</p><ul class=""><li id="06ce" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">仍然是一个符合JavaBean规范的POJO</li><li id="0715" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">完全封装其私有成员</li></ul><p id="602a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的是确保它返回<code class="fe mg mh mi lw b">Collection</code>的方法总是这样做——返回<code class="fe mg mh mi lw b">Collection </code>——而从不返回<code class="fe mg mh mi lw b">null</code>。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="1ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">觉得这个故事有用？想多读点？只需<a class="ae ky" href="https://dt-23597.medium.com/subscribe" rel="noopener">在此订阅</a>即可将我的最新故事直接发送到您的收件箱。</p><p id="a97d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天<a class="ae ky" href="https://dt-23597.medium.com/membership" rel="noopener">成为媒体会员</a>，你也可以支持我和我的写作，并获得无限数量的故事。</p></div></div>    
</body>
</html>