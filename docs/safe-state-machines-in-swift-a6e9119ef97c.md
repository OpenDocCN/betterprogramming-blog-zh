# Swift 中的安全状态机

> 原文：<https://betterprogramming.pub/safe-state-machines-in-swift-a6e9119ef97c>

## 使用枚举安全键入

![](img/5fd16326d73deb38b365ddc3eb427574.png)

伊利亚·巴甫洛夫在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

状态机是许多 Swift 开发人员喜欢、使用和撰写的一种模式。

Swift 的枚举和相关类型使它们比其他编程语言更安全。但是我们怎样才能让它们尽可能的安全呢？

状态机可以被认为是一种数据结构，它可以处于不同的状态，并且只允许状态之间的某些转换。

例如，如果你有一个电脑游戏，点击主菜单中的“单人游戏”，你很可能不会立即开始游戏，但你会进入一些配置屏幕，然后可能是加载屏幕，只有这样你才能进入游戏。

同样，你不会在“你赢了”的状态下开始游戏但是你必须真正地演奏它。而且如果游戏是回合制，招式不是所有人同时下的，很可能会有你根本什么都做不了的时候(就游戏逻辑而言)。

状态机的主要目的是在允许进行哪种转换时封装逻辑。

Swift 开发人员已经就此撰写了大量文章。例如，参见 Swift 中的[状态机或 Swift](https://levelup.gitconnected.com/state-machine-in-swift-8687673f5df6) 中最简单的状态机[。](https://albertodebortoli.com/2018/12/16/the-easiest-state-machine-in-swift/)

这些解决方案已经满足了无效调用不做任何事情的基本要求。然而，转换仍然是公开的，因此，如果为您的应用程序编写视图的程序员不知道哪些转换是有效的或无效的，他们可能仍然会向用户显示按钮，这些按钮不做任何事情，而不会让用户在视觉上很明显。

这个问题可以通过[类型安全状态机](https://lukematthewsutton.com/post/type-safe-state-machines/)解决。

然而，这带来了一个更糟糕的问题:为了存储它们，你必须删除它们的类型，最有可能的是`Any`。

虽然它们是一个很好的玩具，但是一旦你试图用它们做任何实际的事情，所有的安全都失去了。此外，在这个版本中使用 enum 本身的事实意味着您一次只能进行一次转换，而不是触发一系列转换。

我真的想两全其美，我想我找到了一个合理的解决方案，我想在这里分享。

首先，如果我们想要每个转换触发进一步转换的能力，我们将不得不使用一些`Controller`类。所以让我们继续写一个:

我在这里使用 SwiftUI 的`Published`和`ObservableObject`，但是如果您正在处理非 SwiftUI 视图，您也可以使用传统的委托模式或`NotificationCenter`。

作为一般规则，我将调用我想要操作的变量`state`，将其设为私有，并使用属性观察器在主队列上发布对它的更改——因为只允许在主队列上发布。不过，我们不会在这里使用任何其他队列。

你可能还注意到`state`和`publicState`是隐式展开的可选的。我们以后会明白为什么会这样。

现在让我们继续定义我们的状态机的状态:

如你所见，这类似于《生活大爆炸》中的[友谊算法](https://bigbangtheory.fandom.com/wiki/The_Friendship_Algorithm)。

现在棘手的部分来了:我们到底如何添加动作，使得它们只有在正确的情况下才可用？嗯，最明显和简单的方法是将闭包附加到枚举用例上:

现在我们确切地知道在每个状态下我们有哪些选择。除了一个问题:我们还没有绑定动作！它们只是随机的闭包，它们做什么将在运行时决定。如何解决这个问题？

让我们回到编写`Controller`类的文件。我们要做的第一件事是为枚举中的每个闭包添加空方法:

在实现它们之前，我们现在将确保我们的状态机实际上已经初始化。

也就是说，将以下初始化器添加到控制器中:

现在你可以明白为什么`state`是一个隐式展开的可选变量:如果我们要求`state`从一开始就被定义，那么编译器就会抱怨 self 在所有存储的属性被初始化之前就被使用了。我们刚刚绕过了这个。

现在，在 start 方法中，我们添加以下代码:

如您所见，我们在`start`方法中封装了一个随机化的状态转换。只有两种可能的状态可以结束，句号！

现在我们将赋予`askShareAMeal`和`leaveMessage`意义。

正如你所看到的，我们在`leaveMessage`中做的第一件事就是让用户进入等待状态，不附加任何动作。我们的控制器在回调发生时接管控制权。这将在随机时间之后发生，该时间与以文字表示的左消息的长度成比例。

另一种方法再次封装了随机化的状态转换。

到现在为止，我们实际上已经得到了一些终端箭头。如果我们潜在的朋友想和我们一起吃饭，我们就完了！

如果他们不想和我们一起吃饭，而是想喝一杯热饮，情况也是如此。我们还没有新朋友的唯一情况是，他们既不想和我们一起吃饭，也不想喝饮料:

现在我们需要升级要求其他娱乐活动。我们将要求我们的潜在朋友说出一个兴趣，并将该提议与我们的兴趣进行比较。如果我们喜欢我们听到的，我们会分享兴趣，否则，我们会再问。参与兴趣爱好会带来友谊。

如您所见，将所有可能的转换封装到 enum 本身非常容易。

此外，如果您为每个 enum 用例编写专用的视图，几乎不可能意外地向用户公开一个无效的方法。所有必要的运行时检查都可以在控制器层完成，同时您的视图可以对其状态的正确性相当有信心，因为您总是可以从`Published`属性包装器中获得哪些方法是有效的最新信息(以及您的视图所需的所有数据)。

出错的唯一方法是将闭包转义并存储在其他地方，但是这样会有明显的代码味道，你宁愿更改枚举。

完整的代码可以在[这里](https://github.com/AnarchoSystems/StateMachine)找到。

[](https://github.com/AnarchoSystems/StateMachine) [## 无政府系统/国家机器

### 在 GitHub 上创建一个帐户，为 AnarchoSystems/StateMachine 开发做贡献。

github.com](https://github.com/AnarchoSystems/StateMachine) 

挑战:

1.  如您所见，`agreeToInterest`方法是唯一真正读取当前状态的方法。如果你想为你的方法提供更好的保护(也就是说，如果你处于错误的状态，不要做任何事情)，这样做可能是个好主意。尤其是当多个进程可以操作状态时，您可能希望读取状态。然而，我们的例子非常简单，您甚至可以消除这个读操作。怎么会？提示:我们的控制器的方法不需要和枚举中的闭包有完全相同的签名。
2.  `Interest`枚举只有一种情况。案例越多，算法越有意义。理想情况下，每个选项你只需要提议一次。如果控制器用完了选项，您可能还想处理这种情况。
3.  将已经向用户提出的所有兴趣传递回去，以便他们可以决定打破可能的长循环。

编码快乐！