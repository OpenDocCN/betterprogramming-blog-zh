<html>
<head>
<title>7 Tips To Write Efficient and Performant JavaScript Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写高效高性能JavaScript代码的7个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-tips-to-write-efficient-and-performant-javascript-code-bccbdb9662ae?source=collection_archive---------1-----------------------#2021-05-17">https://betterprogramming.pub/7-tips-to-write-efficient-and-performant-javascript-code-bccbdb9662ae?source=collection_archive---------1-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e25" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提升您的JavaScript应用程序的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc899fcf0badf85636c8c1bded7af243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QH2fHMJynCkSKj_t"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">肖恩·亨利在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="1b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">专注于让事情运转起来而忘记性能和效率是一个常见的错误。这是初级和高级开发人员之间的一个关键区别。在编写JavaScript时，我们总是需要关注性能。我们希望我们的应用程序能够在任何可能访问它的设备上尽可能高效地运行。我们不能假设我们的网络应用总是在功能强大的设备上运行。</p><p id="4736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能做些什么来提高我们的JavaScript性能？今天，我们将了解一些提示，帮助您提升web应用程序的整体性能。它们将防止您的代码产生瓶颈，并确保向用户交付高质量的用户体验。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e8ac" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.注意本地存储和会话存储</h1><p id="d887" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">LocalStorage</code>和<code class="fe mz na nb nc b">SessionStorage</code>是让我们在web应用程序中持久化数据的伟大特性。两者有什么区别？<code class="fe mz na nb nc b">SessionStorage</code>页面会话结束时，数据被清除。</p><blockquote class="nd ne nf"><p id="361d" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">这些机制可以通过<code class="fe mz na nb nc b">Window.sessionStorage</code>和<code class="fe mz na nb nc b">Window.localStorage</code>属性获得(更准确地说，在支持浏览器中，<code class="fe mz na nb nc b">Window</code>对象实现了<code class="fe mz na nb nc b">WindowLocalStorage</code>和<code class="fe mz na nb nc b">WindowSessionStorage</code>对象，而<code class="fe mz na nb nc b">localStorage</code>和<code class="fe mz na nb nc b">sessionStorage</code>属性挂起了这两个对象)，调用其中一个将创建一个<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" rel="noopener ugc nofollow" target="_blank">Storage</a></code>对象的实例，通过它可以设置、检索和删除数据项。不同的存储对象用于每个原点的<code class="fe mz na nb nc b">sessionStorage</code>和<code class="fe mz na nb nc b">localStorage</code>——它们分别运行和控制。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="5fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这些web APIs很好也很有用，但是它们是同步的。那是什么意思？这意味着，如果你不小心，你可能会减慢你的应用程序。这些API将保存主线程。<code class="fe mz na nb nc b">LocalStorage</code>和<code class="fe mz na nb nc b">SessionStorage</code>只能存储字符串。这意味着存储大的或复杂的对象会损害性能，因为您需要使用<code class="fe mz na nb nc b">JSON.stringify</code>和<code class="fe mz na nb nc b">JSON.parse</code>操作。</p><p id="deec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个虚拟的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="476d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这次测试中，我可以在2017款MacBook Pro上体验到0.15-0.20ms的执行时间。客观地说:这是一帧动画应该花费的时间。我们可以断定那是相当长的一段时间。</p><p id="2fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有哪些可能的解决方案？以下是一些想法:</p><ul class=""><li id="e143" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">仅存储所需的最少量数据。</li><li id="5eaf" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">为它创建你自己的抽象。您可以缓存对它的访问，从而更快地访问已经提取的信息。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ul class=""><li id="ae89" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">思考存储数据的替代方法。例如，您可以使用cookies来代替。这取决于每一个特定的场景。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a8d2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.使用Observer Web APIs</h1><p id="952a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">试图从浏览器持续监控事件会对我们的web应用程序产生显著的性能影响。这在听<code class="fe mz na nb nc b">scrolling</code>事件时尤其明显。</p><p id="8e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，当一个元素在屏幕上变得可见时，您想要触发一些动作。大多数开发人员会连接到<code class="fe mz na nb nc b">scroll</code>事件，然后尝试判断该元素在屏幕上是否可见。这是非常低效的。我们怎样才能做到与众不同？</p><p id="208d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mz na nb nc b">IntersectionObserver</code>功能。它让我们反应性地观察元素。当这些元素在视口中变得可见或隐藏时，我们会收到事件通知。</p><p id="d5eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个例子。让我们来看看我们本地支持的observer Web APIs的完整列表:</p><ul class=""><li id="ddfd" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">IntersectionObserver</code>:报告广告的可见性，以便计算广告收入。</li><li id="7727" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">MutationObserver</code>:监视DOM树变化的能力。</li><li id="c08d" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">ResizeObserver</code>:报告<code class="fe mz na nb nc b">Element</code>的内容或边框尺寸的变化，或者<code class="fe mz na nb nc b">SVGElement</code>的边框尺寸的变化。</li></ul><p id="2f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浏览器对所有这些的支持都很好，而且对旧浏览器也有很好的填充。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c2f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.拥抱早归模式</h1><p id="c142" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经习惯了<code class="fe mz na nb nc b">if/else</code>模式，从来没有真正质疑过它。但是，通过经验，你认识到一个充满<code class="fe mz na nb nc b">if</code>和<code class="fe mz na nb nc b">else</code>的代码是:</p><ul class=""><li id="0184" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">无能的</li><li id="b0f8" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">难以阅读</li><li id="0fe0" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">难以维护</li></ul><p id="2dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能做些什么来改善这种情况？我们可以拥抱<em class="ng">早归模式</em>。</p><p id="b554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“尽早返回”是一种模式，建议尽早返回结果，而不是使用<code class="fe mz na nb nc b">else</code>语句。</p><p id="4d89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来做一个经典的<code class="fe mz na nb nc b">FizzBuzz</code>例子。下面的代码可能是一个解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们应用提前返回模式，我们会得到下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="79d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过应用提前返回模式，我们的代码变成了:</p><ul class=""><li id="c014" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">更加做作</li><li id="209e" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">可读性更强</li><li id="d4f5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">更有效率</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e4e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.主异步和延迟</h1><p id="50bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如何在你的网站上加载脚本是至关重要的。它在关键的渲染路径中扮演着重要的角色。当用户导航到你的网站后，就要和时间赛跑，尽快提供内容。就此而言，理解如何以最高效的方式加载脚本至关重要。</p><p id="bb48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有三个选择:</p><ul class=""><li id="389d" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">default</code>:获取并执行脚本，同时解析保持暂停，直到执行完成。</li><li id="9e30" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">async</code>:当<code class="fe mz na nb nc b">async</code>属性存在时，脚本将被并行获取并解析，一旦准备好就进行评估。脚本执行的顺序是不可预知的。</li><li id="99d5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">defer</code>:当该属性存在时，它确实向浏览器表明该脚本应该在文档被解析之后，但在触发<code class="fe mz na nb nc b">DOMContentLoaded</code>之前执行。与<code class="fe mz na nb nc b">async</code>相反，这些脚本将按照它们在文档中出现的顺序执行。</li></ul><p id="e901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解这三种加载脚本的方式之间的区别变得非常重要。</p><p id="f6f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据经验，没有依赖关系的脚本应该用<code class="fe mz na nb nc b">async</code>属性执行，而其他的应该用<code class="fe mz na nb nc b">defer</code>属性标记。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="90a4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.推迟不重要的任务</h1><p id="973a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">复杂的JavaScript应用程序经常会运行大量代码。然而，可能有些任务不需要马上发生。对于那些低优先级的任务，我们能做的就是把它们推迟到浏览器不那么忙的时候。将你的浏览器从那些任务中解放出来将会导致更有效的执行。</p><p id="064f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何做到这一点？通过使用浏览器的<code class="fe mz na nb nc b">requestIdleCallback</code>方法。</p><blockquote class="nd ne nf"><p id="9171" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">“<code class="fe mz na nb nc b"><strong class="lb iu"><em class="it">window.requestIdleCallback()</em></strong></code>方法将在浏览器空闲期间调用的函数排队。这使开发人员能够在主事件循环上执行后台和低优先级工作，而不会影响动画和输入响应等延迟关键事件。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="26a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很多情况下，您都可以应用这一策略。最常见的一种是发送分析信息。我们不介意数据是早是晚。这是一个非关键任务，因为它将由另一个服务异步处理。</p><p id="27fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个使用示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="57d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们将等待浏览器空闲，以执行我们的分析代码。如果在接下来的两秒钟内没有发生这种情况，它将被执行。<code class="fe mz na nb nc b">timeout</code>选项是可选的。它帮助您进一步定制代码的执行。如果该选项不存在，它将只在浏览器有时间时执行。</p><p id="8a53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback" rel="noopener ugc nofollow" target="_blank">cancelIdleCallback()</a></code>方法可以取消回调。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="58f7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.优化您的动画</h1><p id="d459" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果做得好，动画是一个非常酷的功能。它们向用户提供了事物的来源和发展方向。如果处理得当，它们的用处怎么强调都不为过。</p><p id="bc65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果做错了，它们会对性能产生严重的负面影响。自定义的JavaScript动画可能会很慢，并损害您的用户体验。这在React本地应用程序上尤其明显，JavaScript桥是一个很大的瓶颈。</p><p id="0add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么不依靠浏览器来帮我们完成繁重的工作呢？CSS动画以更高性能的方式运行。由于新的网络动画API，CSS动画框架也可以通过JavaScript访问。</p><p id="2ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您需要创建一些自定义动画，请避免使用<code class="fe mz na nb nc b">setTimeout</code>:</p><pre class="kj kk kl km gt oa nc ob oc aw od bi"><span id="25f4" class="oe md it nc b gy of og l oh oi">setTimeout(() =&gt; {<br/>  triggerAnimation();<br/>}, 16.6)</span></pre><p id="7395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">setTimeout</code>回调不会每隔<code class="fe mz na nb nc b">16.6ms</code>运行一次。超时时间只是一个近似值。相反，你应该使用<code class="fe mz na nb nc b">requestAnimationFrame</code>。</p><blockquote class="nd ne nf"><p id="391d" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated"><code class="fe mz na nb nc b"><strong class="lb iu"><em class="it">window.requestAnimationFrame()</em></strong></code>方法告诉浏览器你想要执行一个动画，并请求浏览器在下一次重画之前调用一个指定的函数来更新动画。该方法将回调作为在重画之前调用的参数。— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="250b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重写上面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="341d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的动画方法将在每个绘制周期之前运行。你现在的工作是专注于拥有一个高性能的动画代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7c6d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.留意一下记忆</h1><p id="26e5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript不提供任何内存管理原语。相反，内存是由JavaScript VM通过内存回收过程来管理的。这个过程被称为<em class="ng">垃圾收集</em>。</p><p id="8533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么是内存泄漏？它是软件无法回收的一块已分配的内存。</p><p id="ef4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript本身不会泄漏内存。相反，这是由开发人员无意的内存保留造成的。只要代码是整洁的，并且我们不忘记自己清理，就不会发生泄漏。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/30c0a7c5b7d6c87f072bac1e186c6d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TP_cZfez9AtOE71SdmeRIA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存泄漏代码的示例</p></figure><p id="5c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存泄漏会对我们的web应用程序的性能产生很大的影响。代码将耗尽用户的计算机资源。使用的内存越多，垃圾收集器运行的时间就越长，频率就越高。这降低了网页的响应性和交互性，损害了用户体验。</p><p id="60d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须牢记的关键领域是什么？</p><ul class=""><li id="9054" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">事件监听器:确保所有计时器在不需要的时候已经从文档中清除。</li><li id="19f5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">计时器监听器:确保所有间隔和超时一旦不再需要就被取消。</li><li id="ac34" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">观察者:确保任何观察者在不需要的时候都是断开的。</li><li id="9795" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b">Window</code>对象:确保我们没有增加我们的全局内存使用。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee75" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="c6cd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经看到了很多可以提高JavaScript性能的地方。您需要选中所有这些框，以使您的代码具有高性能:</p><ul class=""><li id="1807" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">正确使用存储功能</li><li id="ffc7" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">良好的内存管理</li><li id="20bf" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">依靠浏览器的API来管理元素的状态</li><li id="a6ed" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">明智地加载我们的脚本</li><li id="e43a" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">尽可能在CSS上做动画</li><li id="ed1a" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">避免纠缠<code class="fe mz na nb nc b">if/else</code>的逻辑</li><li id="1d76" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">将不重要的JavaScript代码推迟到不太忙的时候</li></ul><p id="ae51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这些技巧有助于让您的应用程序更高效地运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a02e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">相关文章</h1><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/10-javascript-array-methods-to-boost-your-code-performance-acb57b455189"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">提高代码性能的10种JavaScript数组方法</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">Every、some、includes和其他数组方法</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/5-common-javascript-memory-mistakes-c8553972e4c2"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">5个常见的JavaScript内存错误</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">避免应用程序内存泄漏的技巧</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>