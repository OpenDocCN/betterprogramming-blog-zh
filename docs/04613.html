<html>
<head>
<title>Audio Visualization in Swift Using Metal and Accelerate (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Metal和Accelerate在Swift中实现音频可视化(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/audio-visualization-in-swift-using-metal-accelerate-part-2-7ec8df4def91?source=collection_archive---------5-----------------------#2020-04-24">https://betterprogramming.pub/audio-visualization-in-swift-using-metal-accelerate-part-2-7ec8df4def91?source=collection_archive---------5-----------------------#2020-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="38ec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">音频可视化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6136fc956879bb01fbee850f820ac627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_a9uDbsYtpcYtUNmvSvhw.png"/></div></div></figure><p id="c2cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎回到第二部分。如果你还没有完成第一部分，去做第一部分😉</p><div class="ln lo gp gr lp lq"><a href="https://medium.com/@barbulescualex/audio-visualization-in-swift-using-metal-accelerate-part-1-390965c095d7" rel="noopener follow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">使用Metal &amp; Accelerate在Swift中实现音频可视化(第1部分)</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">我们都见过各种形式的音频可视化，但是我们如何在Cocoa应用程序中实现呢？</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">medium.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me kp lq"/></div></div></a></div><p id="dea5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总结一下我们在上一部分所做的事情:</p><p id="2328" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们定义了项目需求、输入和输出。要求是使用来自音频信号的数据标记，以快速有效的方式将视觉效果呈现到屏幕上。输入被定义为获取音频样本的标量值以表示平均响度(电平计量)，并获取频率能量以进行频率计量。输出被定义为根据平均响度绘制一个弹跳的圆圈，并在圆圈周围绘制代表不同频率能量的线条。</p><p id="dbf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一部分讲述了如何获取输入，即从音频信号中获取数据。至此，我们已经获得了开始可视化部分所需的所有数据！</p><p id="ae2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，在这个系列教程中(回到<em class="mf">使用金属着色器制作第一个圆圈</em>)，我们已经讲述了如何使用金属着色器和加速框架。在这一部分，我将只对金属中的一些概念做一个快速的回顾，并且只解释一个新概念(制服)。</p><p id="5a23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这部分从我们上次停止的地方开始(开始代码<a class="ae mg" href="https://github.com/barbulescualex/MetalAudioVisualizer" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="0f6d" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">第2部分:创建输出(图形)</h1><p id="6204" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">对于这一部分，我们将不再在SignalProcessing.swift类中工作，只在ViewController.swift、AudioVisualizer.swift和CircleShader.metal文件中工作。</p><h2 id="cb9c" class="nl mp iq bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne nw bi translated"><strong class="ak">第一部分:扩大圈子和使用制服</strong></h2><p id="e9e8" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">好的，让我们从我们需要做的事情开始。我们知道我们有一个介于0.3和0.6之间的标量值，我们想用它来缩放一个圆。如果你还记得这个系列的第一个教程(<em class="mf">使用金属着色器</em>制作你的第一个圆)，我们也已经有了这个圆。我们现在要做的就是用我们的标量量值来缩放。</p><p id="69d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们快速刷新一下我们目前是如何渲染这个圆的。</p><p id="4e9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在CPU方面:</p><p id="f718" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有一个向量数组(SIMD库向量),保存连续三角形的x和y坐标。</p><p id="02dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nx ny nz oa b">private var circleVertices = [simd_float2]()</code></p><p id="0694" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用SIMD库的目的是确保数据在CPU和GPU的内存中得到一致的表示，因为Swift和Metal都有该库。</p><p id="9cba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将circleVertices存储到一个MTLBuffer中:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="8b9c" class="nl mp iq oa b gy of og l oh oi">vertexBuffer = metalDevice.makeBuffer(bytes: circleVertices, length: circleVertices.count * MemoryLayout&lt;simd_float2&gt;.stride, options: [])!</span></pre><p id="eba9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们的GPU了解资源:</p><p id="06d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nx ny nz oa b">renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0)</code></p><p id="2aa9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并触发它运行:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="a4d3" class="nl mp iq oa b gy of og l oh oi">renderEncoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 1081)</span></pre><p id="c41d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，在GPU方面…</p><p id="2ee9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用1081的vertexCount调用drawPrimitives，这将触发我们的着色器中的vertex函数以0到1080的vertex_id(vid)运行1081次。使用vid，我们从(存储在第0个缓冲区中)访问顶点数组，在那里我们从CPU端复制了顶点。在我们的顶点函数中，我们创建了一个保存4D输入的输出，其中我们只关心前两个坐标和一个颜色，该颜色将沿着管道进一步传递。</p><p id="99be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在食物链更下游的片段着色器中，我们接收顶点函数的输出，并简单地返回输出中指定的颜色。</p><p id="fb22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，现在我们已经复习了如何画圆。那么，我们应该如何进行扩展呢？</p><p id="6013" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">a)将我们用来画圆的1081个点按每个音频帧在CPU端的响度大小进行缩放(也称为为每个帧传入1081个新点)。</p><p id="3cf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">b)什么都不做。</p><p id="653f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">c)始终保持1081个点和这些点的缓冲区固定，并简单地传入作为标量(统一变量)的量值，并在顶点着色器本身内应用变换(也称为为每帧传入1个新点)。</p><p id="6c77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的正确答案是c。</p><p id="03fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，什么是<strong class="kt ir">均匀变量</strong>？</p><p id="ab2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个想法很简单，真的——一个常量值被均匀地应用到所有的顶点，就是我们所知道的统一变量/输入/常量，等等……就是这样。</p><p id="4fd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始吧。</p><p id="e98e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要做的第一件事是打开一条从ViewController到AudioVisualizer的通信路径，view controller具有我们插值的响度值。这将把值作为一个统一的值传递到管道中。当我们设置一个响度值时，我们希望将其转换成一个MTLBuffer，可以通过管道向下传送。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">Inside AudioVisualizer.swift</p></figure><p id="c80c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们给它默认的最小刻度值来开始；你很快就会明白其中的原因。接下来，我们可以从ViewController类中设置这些值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="3426" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们需要把缓冲液送到管道里。如果我们把这当成制服，我们该怎么做呢？为了将数据传递给我们的着色器函数，我们在renderEncoder上使用setVertexBuffer。</p><p id="1afa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，我们为圆形顶点设置了一个vertexBuffer，并告诉渲染编码器从这些顶点中绘制出三角形条带。要传入制服，我们只需传入一个单独的缓冲区。drawPrimitives指令，正如我们从使用金属着色器在Swift中制作第一个圆的<em class="mf">中了解到的，将运行我们的顶点函数1081次，增加每个顶点传递到函数中的vid。由于我们希望将统一缓冲区内的值应用于所有顶点，因此我们不会触发更多对着色器函数的调用。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">在AudioVisualizer.swift的draw函数中</p></figure><p id="4b95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，在我们的顶点着色器中，我们有了另一个来自缓冲索引1的缓冲区。接下来，我们只需要进入顶点着色器，并适当地缩放我们的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">内圈.金属</p></figure><p id="99f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以看到这是多么容易:对于每个顶点，圆标量是相同的值，只是简单地应用于x和y坐标。我们将loudnessUniform数组索引为零，因为其中只有一个元素！</p><p id="7c64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们点击运行，看看我们会得到什么😍</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="5b94" class="nl mp iq oa b gy of og l oh oi"><strong class="oa ir">validateFunctionArguments:3476: failed assertion `Vertex Function(vertexShader): missing buffer binding at index 1 for levelUniform[0].’</strong></span></pre><p id="faae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，那不好吗？那是怎么回事？当第一次调用metalView时，我们的缓冲区实际上并不存在，这就是为什么我们会遇到运行时错误。如果我们查看<code class="fe nx ny nz oa b">AudioVisualizer.swift</code>类中的<code class="fe nx ny nz oa b">setupMetal()</code>，我们可以看到我们在第一个绘制周期之前设置了圆的顶点。我们需要为loudnessBuffer做同样的事情。幸运的是，我们已经有了一个默认值0.3来初始化这个圆。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">Inside AudioVisualizer.swift</p></figure><p id="4a78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">再次运行它，我们仍然感到失望。实际上什么也没发生；该圆的比例为0.3。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/bd30b5be669f86fb755b88e65a08b4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*HrIvhmhD0bs4LJqhVL626A.png"/></div></figure><p id="2b78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是由于我们在第一个教程中如何绘制循环(<em class="mf">使用金属着色器</em>在Swift中制作第一个圆)。我们将metalView设置为暂停，等待被告知开始绘制。现在，由于我们想要显式的绘制行为，我们需要将metalView设置为paused，禁用enableSetNeedsDisplay，并告诉它使用draw()直接绘制。如果你需要温习这是什么意思，文档中有一个快速复习<a class="ae mg" href="https://developer.apple.com/documentation/metalkit/mtkview" rel="noopener ugc nofollow" target="_blank">这里</a>。我们希望它在设置完成后绘制，并且每次我们都希望更新loudnessUniform！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/8c619f0e6f146d0e9c0184af34280a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/1*0BJhPX03N7pKFoXpQJFEqQ.gif"/></div></figure><p id="cba2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成第一部分后，我们的ViewController.swift和更新的draw生命周期如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="cb0d" class="nl mp iq bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne nw bi translated"><strong class="ak">第2节:添加频率线</strong></h2><p id="d29a" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">我们如何在圆圈周围画这些线？第一个问题是，我们把这些当作制服还是顶点？如果我们把它们当作制服，那么我们要把制服也用来做什么呢？目前，顶点着色器只被调用1081次，这是画圆所需要的。所以我们需要把这些当作顶点而不是制服。</p><p id="7ad9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用这些顶点绘制什么类型的图元？它们被称为频率线，但不一定是线。我们可以使用任何基本类型，它仍然看起来很好(除了点——点看起来很差，因为它们太小了)。</p><p id="09c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们回到我们如何渲染圆。我们创建720个三角形来构成圆，也就是说，周长上有两个点，原点上有一个点。我们总共有720个周界点。我们想在周长点上开始我们的线(显然)，我喜欢做的是让线从圆三角形的第一个周长点开始，然后向外延伸到圆三角形到原点的地方，然后将线带回来与下一个圆三角形顶点相遇。这里有一个小图形来说明我的意思:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/fb01fad117094061b984caf8ab7650a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nawmv0Fvcw35Elj0UDPhqw.jpeg"/></div></div></figure><p id="5e5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上述方法意味着只使用了360个频率幅度。这是个问题吗？不完全是。如果你愿意，你可以在中间插入“空”点:[假点，真点，假点，真点…]。因此，通过检查，我们可以知道我们需要运行顶点着色器大约1080次，这个方法才能工作。</p><p id="69b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于512个频率仓和1/40的采样速率(对于FFT中使用的1024个数据点)，我们有从40Hz到20.48Khz的幅度仓(松散近似)。人耳平均能听到20Hz-20k Hz的声音。假设在前面的部分中，我们使用了2048个数据点来呈现1024个频率仓。这些值中有一半以上是无用的，因为这些频率我们听不到，可能在母带制作过程中被从音乐中删除了。</p><p id="f017" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的，所以我们需要720个频率线点在圆周上，360个向外(显示幅度)。简而言之，这意味着我们实际上可以为外向点使用360/512的值，以及720个“空”值。我们应该从512中选择中心360，这样我们就有了索引范围76中的值..&lt;437. Now we don’t necessarily need to waste any CPU time shoving in “empty” values into the line vertex buffer; instead, we can do some simple arithmetic so that the vertex shader for the line drawing gets called 1080 but still only uses a 360 element buffer.</p><p id="db3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">We’ll start off this section the way we started off the first section: by communicating the frequency data from the ViewController class to the AudioVisualizer class and initializing the buffer appropriately.</p><p id="a7ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">We declare a public var that can take in frequencies from the ViewController class and turn them into a buffer.</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">Inside AudioVisualizer.swift</p></figure><p id="7c90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Now, you may notice we’re using 361 data points instead of 360. What gives? If you remember way back (<em class="mf">使用金属着色器在Swift中创建第一个圆，</em>是的，我将继续命名它，我不希望任何人混淆并认为这是来自第一部分<em class="mf"> ) </em>我们必须使用一个额外的数据点来完成圆(回到0*)，否则圆将在x轴下方缺少一个长条。同样的逻辑也适用于此——如果我们只使用360个数据点来计算频率，我们将会错过x轴下方的一小部分。</p><p id="89eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，就像我们对响度测量所做的那样，我们希望确保在第一个draw命令之前初始化缓冲区，并且我们在每次计算频率幅度时都从ViewController中设置它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">Inside AudioVisualizer.swift</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">ViewController.swift内部</p></figure><p id="5322" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在是时候渲染我们的数据了。在我们讨论如何使用任何类型的带点的原语之前。在代码中，我将使用lineStrips，但是您可以随意使用任何您想要的东西。</p><p id="5040" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要顶点着色器来显示361个数据点，只有1/3的点是真实的数据点(其余的在圆上)。我们希望运行尽可能多的圆顶点，这将允许我们在没有额外内存开销的情况下重用这些周界点(它们已经在缓冲区中)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">Inside AudioVisualizer.swift</p></figure><p id="71d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在等一下——只有一个顶点着色器，但是有两种不同类型的图元。我们如何为每个原语改变我们的逻辑，我们如何知道一个何时停止，另一个何时开始？答案很简单:不要想太多。我们的VID会从0-&gt;2161。为了对我们正在绘制的不同对象执行不同的逻辑，我们只需要一个if语句。还值得注意的是，您设置的所有顶点缓冲区在所有顶点着色器过程中都可用。还要注意，我们已经将metalView的背景颜色从蓝色改为黑色(相信我，这样会更好看)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="def7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在回到我们关于如何处理绘制频率线的讨论，我们需要利用vertex array[vid-1081]+loudness uniform处可用的圆形顶点，以便我们知道频率线从哪里开始。同样的逻辑也适用于频率线的结尾。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e31b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这实际上完成了频率线的绘制。如果您运行您的程序，您应该会看到最终的产品:)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/927800e1b59491767686996c870d57c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PwNBIgQFlOk6csZ5HkIEWQ.gif"/></div></div></figure><p id="fbe2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这基本上结束了所有的编码。为自己一路走来感到自豪！🎉</p><p id="f179" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的第二部分可以在我的Github <a class="ae mg" href="https://github.com/barbulescualex/MetalAudioVisualizer" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="eefd" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">后续步骤和缺点</h1><p id="1747" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">所以现在你已经学会了基本的构建模块，这将使你能够做任何你想做的事情。但是，如果我们不对我们所学的内容做一些反思，看看我们如何在它的基础上扩展，以及它的缺点是什么，它就不是一个好的教程。</p><h2 id="1d6d" class="nl mp iq bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne nw bi translated">让它成为你自己的</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/779554ad3aac58b4658689ee2bf218b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*kvXRXYzpQOSrZfx5NCTVLQ.gif"/></div></figure><p id="7093" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">右上方的音频可视化工具使用1080条频率线环绕圆圈两次，没有范围选择。它还采用了低音强调水平计量。我选择在本教程中不使用它——我想让本教程更通用，而是允许您开发这些事情背后的一些直觉，以便您可以使用任何您想要的可视化。</p><p id="fbc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如何自定义音频可视化工具来满足您的需求？嗯，最简单的方法是改变频率线的颜色和基本类型。</p><div class="kg kh ki kj gt ab cb"><figure class="ou kk ov ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/77e331a71b086d9239b0542da7ff413c.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*T5Se9yxjooOOsw5UJLwTjQ.png"/></div></figure><figure class="ou kk pa ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/778bc7972dec1b2583222214575f18a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*mbk4If_GBs_kqdcFXAb_jw.png"/></div></figure><figure class="ou kk pb ow ox oy oz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/3aaca89d5755710d4a92b33fac089399.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*pVaHDcUfreSqeAjpJl1hGg.png"/></div></figure></div><p id="7ac3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，您可以摆弄数据点本身。如果你还记得本教程的第一部分，有不同的电平计量公式，比如A加权，它更强调我们能听到的频率。由于这是一个非常EDM类型的音频可视化，一个伟大的替代水平计量将是低频计量；也就是说，用圆圈代表低音能量(这比我们对这种音乐类型采用的方法更常见)。</p><p id="92f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在频率方面，当进行音频可视化时，我们有一些范围选择。如果我们想更进一步地关注一个范围，或者让频率线不止一次地环绕这个圆，会怎么样呢？(又名，如果我们想要更多的频率仓呢？)如第一部分所讨论的，你可以从n个音频帧中得到n/2个频率仓。因此，通过增加用于FFT的样本大小，可以获得更多可用的数据点。你也可以研究hann-windowing来获得更精确的频谱。</p><p id="4590" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们谈到频率的话题时，值得注意的是我们没有对频率线进行插值，所以它们的变化比圆圈慢十倍。</p><p id="281b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，还有正常化。我试图给出非常通用的规范化方法，但是您可以进一步使用它们来获得更好的结果。</p><h2 id="f640" class="nl mp iq bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne nw bi translated">缺点</h2><p id="9196" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">好吧，那么我们用过的方法有什么缺点？我认为最大的一个问题是延迟。不幸的是，虽然我们很快，但我们没有<em class="mf">那么</em>快，所以这肯定是显而易见的。可以注意到，我们在同一个线程上顺序地进行所有的信号处理。这不是必需的，您可以在不同的分支上分别完成这项工作，而不用担心任何竞争条件或死锁。</p><p id="6e9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们错过了数据。我们不会从我们的回拨率中遗漏数据；相反，我们会丢失数据，因为我们在信号处理中实际上并没有使用所有的数据。可以这样想:如果我们有来自x.1s -&gt; x.2s的样本数据，歌曲在窗口的前半段是安静的，在窗口的后半段是响亮的，我们不会得到最准确的表示。在我们的例子中，我们只使用前四分之一的音频样本。我们将完全错过整个采样周期的较大部分。现在，这个问题很容易解决，因为增加液位计量的数据点不会增加输出数量(仍然是一个)。</p><p id="606c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相反，在频率方面，如果我们增加使用的数据点数量，输出就会线性增加。这对我们如何绘制频率线有直接的影响，使得处理相应的可视化更具挑战性。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="93e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就结束了<em class="mf">使用金属&amp;加速在Swift中制作音频可视化器。</em>我希望你学到了新的有用的东西！🎉</p><p id="3233" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果这对你有帮助，请随意去share️.一如既往，如果你有任何问题或建议，请在下面的评论区留下。</p></div></div>    
</body>
</html>