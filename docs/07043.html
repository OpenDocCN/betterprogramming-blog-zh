<html>
<head>
<title>My React App Unit-Testing Strategies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的React应用程序单元测试策略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-react-app-unit-testing-strategies-18ebe55cd078?source=collection_archive---------7-----------------------#2020-12-01">https://betterprogramming.pub/my-react-app-unit-testing-strategies-18ebe55cd078?source=collection_archive---------7-----------------------#2020-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="39df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一套可靠的单元测试来强化你的代码库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cf4ef9c8fd24ca07815634f26cd3ca78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RqDBFF8VmWIP6zSl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图为<a class="ae ky" href="https://unsplash.com/@bertomacario?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝托·马卡里奥</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="0df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论应用程序有多小，单元测试对于开发都是至关重要的。这篇博客文章将介绍我是如何为这个示例应用程序编写单元测试的:</p><div class="lv lw gp gr lx ly"><a href="https://github.com/xiongemi/white-label-airline" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">GitHub-Xiong EMI/white-label-airline:使用Nx React创建的白标航班搜索应用程序</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">这个项目是一个使用Nx生成的样本航班搜索应用程序。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="4f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Github页面:<a class="ae ky" href="https://xiongemi.github.io/white-label-airline" rel="noopener ugc nofollow" target="_blank">https://xiongemi.github.io/white-label-airline</a></p><p id="46f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将解释我对React应用程序不同部分的一些单元测试策略:</p><ul class=""><li id="bc23" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">服务</li><li id="cbc6" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">表象成分</li><li id="3608" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">智能/容器/连接组件</li><li id="ea8d" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">还原文件</li><li id="a677" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">钩住</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b6d148cad222d647b52838147fe32cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*lajVtnLs4z-X4Z_qeP5khQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">React应用程序的单元测试策略</p></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="dff5" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">技术堆栈</h1><p id="7034" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">以下是我使用过的库的列表:</p><ul class=""><li id="7c9c" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">测试框架:<a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a></li><li id="53f1" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">DOM测试:<a class="ae ky" href="https://testing-library.com/docs/react-testing-library/intro/" rel="noopener ugc nofollow" target="_blank"> @testing-library/react </a></li><li id="9077" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">林挺:<a class="ae ky" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank">诚信通</a></li><li id="cc64" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">ESLint插件:<a class="ae ky" href="https://github.com/testing-library/eslint-plugin-testing-library" rel="noopener ugc nofollow" target="_blank">lint-plugin-testing-library</a>和<a class="ae ky" href="https://github.com/testing-library/eslint-plugin-jest-dom" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-jest-dom </a></li><li id="5a71" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">可访问性测试:<a class="ae ky" href="https://github.com/nickcolley/jest-axe" rel="noopener ugc nofollow" target="_blank"> jest-axe </a></li></ul></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="5416" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">ESLint插件</h1><p id="d6d2" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">添加林挺将有助于开发人员在编写单元测试时避免一些错误。要安装ESLint插件<a class="ae ky" href="https://github.com/testing-library/eslint-plugin-testing-library" rel="noopener ugc nofollow" target="_blank">lint-plugin-testing-library</a>和<a class="ae ky" href="https://github.com/testing-library/eslint-plugin-jest-dom" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-jest-dom </a>，输入以下命令:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="fb11" class="ol nk it oh b gy om on l oo op"><em class="oq"># npm</em><br/>npm install --save-dev lint-plugin-testing-library eslint-plugin-jest-dom</span><span id="6a0f" class="ol nk it oh b gy or on l oo op"><em class="oq"># yarn<br/></em>yarn add lint-plugin-testing-library --dev<br/>yarn add eslint-plugin-jest-dom --dev</span></pre><p id="b0c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件<code class="fe os ot ou oh b">.eslintrc</code>中，添加你需要的规则。例如，在<code class="fe os ot ou oh b">extends</code>中添加推荐规则:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="2588" class="ol nk it oh b gy om on l oo op">"extends": [<br/>  "plugin:jest-dom/recommended",<br/>  "plugin:testing-library/react",<br/>],</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="d299" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">易访问性的单元测试</h1><p id="3d1e" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">单元测试也可以审计可访问性，我们可以使用库jest-axe:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="3e4b" class="ol nk it oh b gy om on l oo op"><em class="oq"># npm</em><br/>npm install --save-dev jest-axe</span><span id="2557" class="ol nk it oh b gy or on l oo op"><em class="oq"># yarn</em><br/>yarn add jest-axe --dev</span></pre><p id="9229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要设置它，在根目录下创建一个名为<code class="fe os ot ou oh b">jest.setup.js</code>的文件，内容如下:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="f3dd" class="ol nk it oh b gy om on l oo op">import { toHaveNoViolations } from 'jest-axe';</span><span id="2d2f" class="ol nk it oh b gy or on l oo op">expect.extend(toHaveNoViolations);</span></pre><p id="2416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Jest配置文件(<code class="fe os ot ou oh b">jest.config.js</code>或<code class="fe os ot ou oh b">jest.config.ts</code>)中将该文件指定为设置文件:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="9728" class="ol nk it oh b gy om on l oo op">setupFilesAfterEnv: ['./jest.setup.js']</span></pre><p id="a14b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是检查React组件的可访问性违规的单元测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可访问性的单元测试</p></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="cc31" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">模拟进口</h1><p id="6f46" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">有时候我们不能建立一个测试用的库或服务，但我们总是可以嘲笑它。它将对从这个库或服务返回的内容进行粒度控制。</p><h2 id="8987" class="ol nk it bd nl ox oy dn np oz pa dp nt li pb pc nv lm pd pe nx lq pf pg nz ph bi translated">模拟图书馆</h2><p id="281d" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated"><strong class="lb iu">例如:</strong>T2】</p><p id="a0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个例子，我使用了库<code class="fe os ot ou oh b">react-i18next</code>，在我的组件中有这个导入:<code class="fe os ot ou oh b">import { useTranslation } from ‘react-i18next’;</code>。然而，我真的不需要设置它来进行测试——我可以模仿它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="cebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的单元测试中，我只需要将这个模拟文件导入到<code class="fe os ot ou oh b">jest.setup.js</code>文件中。</p><p id="d945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例如:</strong> <code class="fe os ot ou oh b"><strong class="lb iu">react-router-dom</strong></code></p><p id="b638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用了库<code class="fe os ot ou oh b">react-router-dom</code>，我用了这个库中的组件<code class="fe os ot ou oh b">&lt;Link /&gt;</code>:<code class="fe os ot ou oh b">import { Link as RouterLink, useLocation } from ‘react-router-dom’</code>。当我试图运行单元测试时，我得到了这个错误:<code class="fe os ot ou oh b">[Error: Invariant failed: You should not use &lt;Link&gt; outside a &lt;Router&gt;]</code>。</p><p id="16c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘲笑它:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="6912" class="ol nk it oh b gy om on l oo op">jest.mock('react-router-dom', () =&gt; ({<br/>  ...jest.requireActual('react-router-dom'),<br/>  Link: ({ children }) =&gt; &lt;div&gt;{children}&lt;/div&gt;,<br/>  useLocation: jest.fn().mockReturnValue({ pathanme: '/outbound' }),<br/>}));</span></pre><h2 id="667d" class="ol nk it bd nl ox oy dn np oz pa dp nt li pb pc nv lm pd pe nx lq pf pg nz ph bi translated">模拟服务</h2><p id="ec6a" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">举个例子，我得到了一个名为<code class="fe os ot ou oh b">countriesService</code>的函数服务。我需要在我的单元测试中模拟这个服务。下面是这个服务文件的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">国家/地区.服务. ts</p></figure><p id="2cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我在单元测试文件中模拟它的方式:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="80ca" class="ol nk it oh b gy om on l oo op">countriesService.getCountries = jest<br/>        .fn()<br/>        .mockImplementation(() =&gt; Promise.resolve(mockCountriesResponse));</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="13cb" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">服务</h1><p id="bcbb" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">例如，对于<code class="fe os ot ou oh b">countriesService</code>，我使用<code class="fe os ot ou oh b">fetch</code>来发出网络请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">国家/地区.服务. ts</p></figure><h2 id="a5f4" class="ol nk it bd nl ox oy dn np oz pa dp nt li pb pc nv lm pd pe nx lq pf pg nz ph bi translated">模拟<code class="fe os ot ou oh b">fetch</code></h2><p id="853a" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">为了测试这个文件，我需要模拟出<code class="fe os ot ou oh b">fetch</code>函数。为此，我安装了库<code class="fe os ot ou oh b"><a class="ae ky" href="https://github.com/jefflau/jest-fetch-mock" rel="noopener ugc nofollow" target="_blank">jest-fetch-mock</a></code>:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="7b60" class="ol nk it oh b gy om on l oo op"># npm<br/>npm install jest-fetch-mock --save-dev</span><span id="f1a7" class="ol nk it oh b gy or on l oo op"># yarn<br/>yarn add jest-fetch-mock --dev</span></pre><p id="0e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要设置它，将这些行添加到<code class="fe os ot ou oh b">jest.setup.js</code>:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="b7e9" class="ol nk it oh b gy om on l oo op">require('jest-fetch-mock').enableMocks()</span></pre><h2 id="8ed0" class="ol nk it bd nl ox oy dn np oz pa dp nt li pb pc nv lm pd pe nx lq pf pg nz ph bi translated">单元测试</h2><p id="4551" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">在单元测试文件中模拟成功的fetch调用，键入:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="5ad8" class="ol nk it oh b gy om on l oo op">fetchMock.mockResponseOnce(JSON.stringify(<em class="oq">&lt;mock response&gt;</em>));</span></pre><p id="1710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要模拟失败的fetch调用，请键入:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="0a07" class="ol nk it oh b gy om on l oo op">const response = new Response(null, {<br/>  status: 401,<br/>});<br/>fetchMock.mockReturnValueOnce(Promise.resolve(response));</span></pre><p id="6ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是上述服务的实际单元测试文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">国家/地区.服务.规格</p></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="b4b3" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">表象成分</h1><p id="e900" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">表示组件仅根据从其父组件传入的属性来显示数据——它们不连接到任何状态。</p><p id="8bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，对于表象组件，我不需要检查传入的道具是否相应显示。大多数时候，我只是做一个可访问性检查的单元测试。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="d290" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">智能/容器/连接组件</h1><p id="a409" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">智能/容器/连接组件连接到状态。在我的例子中，我使用Redux进行状态管理。我没有建立真正的Redux商店，而是使用库<code class="fe os ot ou oh b"><a class="ae ky" href="https://github.com/reduxjs/redux-mock-store" rel="noopener ugc nofollow" target="_blank">redux-mock-store</a></code>模拟它:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="979a" class="ol nk it oh b gy om on l oo op"><em class="oq"># npm</em><br/>npm install redux-mock-store @types/redux-mock-store --save-dev</span><span id="3f37" class="ol nk it oh b gy or on l oo op"><em class="oq"># yarn</em><br/>yarn add redux-mock-store --dev<br/>yarn add @types/redux-mock-store --dev</span></pre><p id="67e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要设置模拟商店:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="a031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我平时写的测试:</p><ul class=""><li id="fa48" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">传入不同类型的存储状态，并查看数据是否正确显示:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><ul class=""><li id="1938" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">检查当某个事件发生时，派单是否由正确的操作触发</li></ul><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="f9e8" class="ol nk it oh b gy om on l oo op">expect(store.dispatch).toBeCalledWith(&lt;expected action&gt;);</span></pre><p id="479e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我为智能组件编写的一个实际单元测试文件的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="319e" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">还原文件</h1><p id="47f5" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在下面的例子中，对于要测试的Redux文件，我使用了<a class="ae ky" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux Toolkit </a>和<a class="ae ky" href="https://redux-observable.js.org/" rel="noopener ugc nofollow" target="_blank"> redux-observable </a>。</p><h2 id="6a66" class="ol nk it bd nl ox oy dn np oz pa dp nt li pb pc nv lm pd pe nx lq pf pg nz ph bi translated">还原剂</h2><p id="a879" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">减速器是易于测试的纯函数，通常遵循以下模式:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="d0b1" class="ol nk it oh b gy om on l oo op">const action = &lt;any action&gt;;<br/>const state = reducer(&lt;initial state value&gt;, action);<br/>expect(state).toEqual(&lt;expected state value&gt;);</span></pre><p id="5062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个减速器单元测试的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">减速器的单元测试文件</p></figure><h2 id="f45a" class="ol nk it bd nl ox oy dn np oz pa dp nt li pb pc nv lm pd pe nx lq pf pg nz ph bi translated">选择器</h2><p id="823f" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">与reducers类似，选择器是纯函数，通常遵循以下模式:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="7883" class="ol nk it oh b gy om on l oo op">const actual = selectorFn(&lt;mock state value&gt;);<br/>const expected = &lt;expected selector return value&gt;;</span><span id="4efd" class="ol nk it oh b gy or on l oo op">expect(actual).toEqual(expected);</span></pre><p id="4851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个选择器单元测试文件的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择器的单元测试文件</p></figure><h2 id="0d9a" class="ol nk it bd nl ox oy dn np oz pa dp nt li pb pc nv lm pd pe nx lq pf pg nz ph bi translated">史诗</h2><p id="c93f" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">我使用<code class="fe os ot ou oh b"><a class="ae ky" href="https://redux-observable.js.org/" rel="noopener ugc nofollow" target="_blank">redux-observable</a></code>作为中间件来处理异步动作。肯定还有其他方式，比如<code class="fe os ot ou oh b"><a class="ae ky" href="https://redux.js.org/recipes/writing-tests#async-action-creators" rel="noopener ugc nofollow" target="_blank">Thunk</a></code>或者<code class="fe os ot ou oh b"><a class="ae ky" href="https://redux-saga.js.org/docs/advanced/Testing.html" rel="noopener ugc nofollow" target="_blank">redux-saga</a></code>。</p><p id="f4a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，单元测试遵循以下模式:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="aa7f" class="ol nk it oh b gy om on l oo op">describe('&lt;epic name&gt;', () =&gt; {<br/>  let action$: ActionsObservable&lt;Action&gt;;</span><span id="4ff2" class="ol nk it oh b gy or on l oo op">  beforeEach(() =&gt; {<br/>    action$ = new ActionsObservable(<br/>     of(&lt;triggered action&gt;)<br/>    );<br/>  });</span><span id="6a4e" class="ol nk it oh b gy or on l oo op">  it('should map to certain action', (done) =&gt; {<br/>    epicFn(action$).subscribe({<br/>      next: (action) =&gt; {<br/>        expect(action).toEqual(&lt;expected action&gt;);<br/>        done();<br/>      },<br/>    });<br/>  });<br/>});</span></pre><p id="7590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个epic的单元测试文件的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="cad1" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">钩住</h1><p id="48d1" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">为了测试<a class="ae ky" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">自定义的React钩子</a>，我们需要使用库<code class="fe os ot ou oh b"><a class="ae ky" href="https://github.com/testing-library/react-hooks-testing-library" rel="noopener ugc nofollow" target="_blank">@testing-library/react-hooks</a></code>:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="e213" class="ol nk it oh b gy om on l oo op"><em class="oq"># npm</em><br/>npm install --save-dev @testing-library/react-hooks react-test-renderer</span><span id="6494" class="ol nk it oh b gy or on l oo op"><em class="oq"># yarn</em><br/>yarn add @testing-library/react-hooks --dev<br/>yarn add react-test-renderer --dev</span></pre><p id="538e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在我的自定义钩子中使用了另一个库中的钩子:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="a999" class="ol nk it oh b gy om on l oo op">import { useFormikContext, getIn } from 'formik';</span><span id="d1a7" class="ol nk it oh b gy or on l oo op">const { touched, errors, isSubmitting } = useFormikContext();</span></pre><p id="7d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我的单元测试，我是这样模拟的:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="94a2" class="ol nk it oh b gy om on l oo op">jest.mock('formik', () =&gt; ({<br/>  useFormikContext: () =&gt; {<br/>    return {<br/>      touched: { fieldName: true },<br/>      errors: { fieldName: 'random error' },<br/>      isSubmitting: true,<br/>    };<br/>  },<br/>  getIn: (context: Record&lt;string, unknown&gt;, fieldName: string) =&gt; {<br/>    return context[fieldName];<br/>  },<br/>}));</span></pre><p id="8206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我的定制钩子及其单元测试的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="7edf" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">覆盖阈值</h1><p id="2455" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">既然我已经写了一些单元测试，我需要设置一个覆盖率阈值。在我的<code class="fe os ot ou oh b">jest.config</code>文件中，我添加了这几行:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="872a" class="ol nk it oh b gy om on l oo op">  collectCoverage: true,<br/>  coverageReporters: ['text', 'html'],<br/>  coverageThreshold: {<br/>    global: {<br/>      branches: 50,<br/>      functions: 60,<br/>      lines: 60,<br/>      statements: 60,<br/>    },<br/>  },</span></pre><p id="ebbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在终端中，它应该输出覆盖报告:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/7e92235d7154c960fc285af85b450c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*hoxfgxVpxkJn8kvZQ6_6uA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单元测试-终端中的覆盖报告</p></figure><p id="e0db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，对于一个app来说，没必要试图达到超高的覆盖数。数字越大并不意味着代码越好。我只是在这里添加了一些数字，作为继续编写有意义的单元测试的提醒。</p><h2 id="f13e" class="ol nk it bd nl ox oy dn np oz pa dp nt li pb pc nv lm pd pe nx lq pf pg nz ph bi translated">提交前挂钩</h2><p id="aa1e" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">然而，我还需要设置一个预提交挂钩，以确保单元测试在每次提交之前运行并通过。</p><ul class=""><li id="e9bb" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">安装<code class="fe os ot ou oh b"><a class="ae ky" href="https://github.com/typicode/husky" rel="noopener ugc nofollow" target="_blank">husky</a></code></li><li id="b4c6" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">在您的<code class="fe os ot ou oh b">package.json</code>中，添加以下几行:</li></ul><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="a93a" class="ol nk it oh b gy om on l oo op">  "husky": {<br/>    "hooks": {<br/>      "pre-push": "npm run lint &amp;&amp; npm run test"<br/>    }<br/>  }</span></pre></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="1d4f" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">结论</h1><p id="2b24" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">谢谢你一直读到最后。下面是我在一个React应用程序中使用的测试策略。它可能不适合每个项目的需求。</p><p id="eb8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，更多的单元测试并不意味着更好的代码。我见过一些单元测试很脆弱，经常出错。单元测试应该小到只测试一个文件，而不应该成为集成测试。好的单元测试易于维护和阅读，也是好的代码文档。</p><p id="aacb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试愉快。</p></div></div>    
</body>
</html>