<html>
<head>
<title>How to Create a Draggable Floating View in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中创建可拖动的浮动视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-draggable-floating-view-in-swift-13802a410e?source=collection_archive---------1-----------------------#2020-12-09">https://betterprogramming.pub/how-to-create-a-draggable-floating-view-in-swift-13802a410e?source=collection_archive---------1-----------------------#2020-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a581" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为你的应用添加有趣的用户界面元素</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dbe272e87a7214e84efefa3dcaa487c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y-JvQj1UM8uDG-QF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@terrawill?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">将</a>放在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的Unsplash </a>上。</p></figure><p id="f38d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">长话短说，在我们的最新项目中，我们的团队必须实现一个可以在屏幕上自由拖动的浮动视图。对于那些有Android开发背景的人来说，可以把它想象成一个悬浮的动作按钮，但不是静止在屏幕的某些部分，而是可以自由拖动！</p><p id="eb09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于那些不知道的人，看看这些图片:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/4749eeb009f8f2901ee58cde8b918063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Wv8kZrHCm63rlOKchESlA.jpeg"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/59e39fb241af66178df4de831bfca373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBAGGFVs4gGRbLymrj3yug.jpeg"/></div></div></figure><p id="8727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浮动视图用红色圈出，如上图所示。</p><p id="237e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在进行了一些研究后，我们发现在iOS应用程序上从头实现它并不困难。本教程将涵盖你需要创建一个的每一件事。</p><p id="dc43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lt">注意:由于我还没有在苹果的HIG上找到这个组件的正式名称，所以在本文中我将继续称它为可拖动视图。</em></p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="434e" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">准备</h1><p id="f9cc" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">在Xcode上创建一个iOS项目，选择storyboard作为项目的界面，UIKit App Delegate作为其生命周期。然后我们以您非常喜欢的普通Xcode启动代码结束:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/8e1e3588bcd45f08928f398c042a8769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sEGYPyC_Gp0EmQ1qBgn7g.png"/></div></div></figure><p id="b28c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，转到<code class="fe mz na nb nc b">Main.storyboard</code>，添加一个<code class="fe mz na nb nc b">UIView</code>，放在屏幕的某个地方。您可以自由决定将视图放在哪里。例如，我的答案是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/3404f1e2ca06d340cec9a0e044a5692e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yk9HfN0HbgwsMYJFJUDj6Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我制作了一个红色的UIView，宽度和高度为70磅，通过16磅的约束将其尾部与安全区域对齐，并将300磅与安全区域的底部对齐。</p></figure><p id="9b39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，我们的可拖动视图只是一个圆形视图，上面有一些背景颜色。你可以进一步定制它(比如添加一张图片或其他东西)。</p><p id="29fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们接下来要做的是将我们新创建的视图连接到<code class="fe mz na nb nc b">ViewController</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/92939717c25fc0f84c95a06cbb366e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0kZ36rfx9kuDGP77Jp6Ag.png"/></div></div></figure><p id="7d06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们现在运行我们的应用程序，我们会在屏幕上看到一个小红框。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="42d1" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">我们开始吧</h1><p id="e608" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">为了使我们的视图可拖动，我们必须添加一个名为<code class="fe mz na nb nc b">UIPanGestureRecognizer</code>的手势识别器。</p><p id="6318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/uikit/uipangesturerecognizer#//apple_ref/occ/cl/UIPanGestureRecognizer" rel="noopener ugc nofollow" target="_blank">苹果对<code class="fe mz na nb nc b">UIPanGestureRecognizer</code>的解释</a>相当直白:</p><blockquote class="nd ne nf"><p id="043b" class="kw kx lt ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">"解释平移手势的离散手势识别器。</p><p id="b0f8" class="kw kx lt ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi">…</p><p id="b6af" class="kw kx lt ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">这个类的客户端可以在它们的动作方法中查询<code class="fe mz na nb nc b">UIPanGestureRecognizer</code>对象，以获得手势的当前平移(平移(输入:))和平移的速度(速度(输入:))。"</p></blockquote><p id="64f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更简单地说，这个手势可以检测视图上发生的任何平移，甚至使您能够获得它的属性，如速度、最终位置等。</p><p id="3e36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着在我们的<code class="fe mz na nb nc b">ViewController</code>上实现它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5d1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是详细报道:</p><ol class=""><li id="2aef" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">在第16行，我们为我们的可拖动视图设置了一个<code class="fe mz na nb nc b">UIPanGestureRecognizer</code>,在这里我们还为我们的识别器创建了一个回调函数(每次发出平移事件时都会调用这个函数)。</li><li id="a2aa" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">在处理函数中，我们只是打印手势的当前位置。</li></ol><p id="298f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试运行应用程序，然后自由拖动视图。请注意，尽管我们的视图没有移动，但我们可以在调试控制台上看到某种元组，这是坐标中给出的当前手势位置。我们正在实现我们的目标！</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="2994" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">现在怎么办？</h1><p id="9d7f" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">既然我们已经设置了手势识别器，我们要做的就是更新视图的位置。因为我们已经从处理函数中获得了最终位置，所以让我们重用它。</p><p id="b1ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将此代码添加到我们的<code class="fe mz na nb nc b">ViewController</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6250" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中:</p><ol class=""><li id="7847" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">在第20行，我们得到了手势的当前位置。</li><li id="ae4e" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">在第21行，我们将发送平移事件的手势视图(我们的可拖动视图)赋给一个变量。</li><li id="a8c3" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">然后，我们用之前获取的当前位置更新视图的中心。</li></ol><p id="beb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你再次尝试运行应用程序，我们的视图最终会被拖动。耶！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d9b849de7a26309c670d2e5aadb28572.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*sJ7_bgokV1gRbq5pdlPXrg.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">已成功使视图可拖动</p></figure><p id="c8d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有些事情是不对的:虽然我们成功地使视图可拖动，但是我们可以将它拖动到屏幕之外，这不是一种正常的行为。</p><p id="db7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，<em class="lt">普通</em>可拖动视图有能力在用户停止拖动时将自己拖动到屏幕最近的一侧，而我们的没有。</p><p id="59ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们能做些什么呢？</p><p id="7c25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，要实现这种行为，我们只需要做一点变通。当用户停止拖动时，我们可以应用一些逻辑。将此代码添加到我们的<code class="fe mz na nb nc b">ViewController</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d2cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">逻辑是这样的:</p><ol class=""><li id="0124" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">从第24行开始，我们向处理程序添加一些逻辑，使视图具有我们期望的行为。</li><li id="6f07" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">我们检查用户是否已经停止拖动，然后我们比较当前视图的<code class="fe mz na nb nc b">midX</code>位置和它的超级视图的一半宽度。我们通过比较来确定当前视图是更靠近其超级视图的左侧还是右侧。</li><li id="612c" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">如果视图的<code class="fe mz na nb nc b">midX</code>大于或等于其超级视图宽度的一半(更靠近屏幕的右侧)，那么我们将它的<code class="fe mz na nb nc b">X</code>位置更新为其超级视图宽度减40。这意味着我们的视图的最终位置将位于其超级视图的尾部40点。</li><li id="ca2a" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">如果它更靠近左边的屏幕，我们就把它的<code class="fe mz na nb nc b">X</code>位置更新为<code class="fe mz na nb nc b">40</code>。这意味着我们的视图的最终位置将位于离它的超级视图尾部40磅的地方。</li></ol><p id="821c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试运行应用程序。瞧啊。我们的视图现在的行为与预期的一样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/17feff3dd43c8a0b5833a4d58d7264f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*uB4p6xgb_BwlHciNhyObug.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的可拖动视图正在运行</p></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="cee8" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated"><strong class="ak">结论</strong></h1><p id="ab09" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">如你所见，在iOS上创建一个可拖动的视图并不像看起来那么难。我们只需要实现一些关于视图最终位置的逻辑。</p><p id="6a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p></div></div>    
</body>
</html>