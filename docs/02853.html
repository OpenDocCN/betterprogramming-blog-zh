<html>
<head>
<title>Docker for Node.js in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产中Node.js的Docker</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-for-node-js-in-production-b9dc0e9e48e0?source=collection_archive---------2-----------------------#2020-01-05">https://betterprogramming.pub/docker-for-node-js-in-production-b9dc0e9e48e0?source=collection_archive---------2-----------------------#2020-01-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="e1ce" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在生产环境中使用Docker运行Node.js应用程序的清单</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/23d1d478a3774c7fb575aa0519cd6300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acitGdej20dJorWACI-H_Q.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">小阿米尔在<a class="ae kz" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="bccc" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">1.选择正确的基础图像</h1><p id="5f27" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">为Node.js应用程序选择正确的基本Docker映像至关重要。你应该总是尝试使用<a class="ae kz" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">官方Docker图片</a>——因为它们拥有优秀的文档，使用最佳实践，并且是为最常见的用例设计的。</p><p id="1241" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">看官方的<a class="ae kz" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank"> Node.js Docker图片</a>还是有很多图片可以选择的。我总是选择可以运行我的Node.js应用程序的最小尺寸的图像。目前，如果您想在64位Linux上运行Node.js应用程序，您有以下选择:</p><ul class=""><li id="f8ba" class="mt mu iu lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">节点:拉伸(最新)→ <strong class="lu iv"> 344.36 MB </strong></li><li id="5239" class="mt mu iu lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">节点:stretch-slim → <strong class="lu iv"> 65.29 MB </strong></li><li id="2e6d" class="mt mu iu lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">节点:lts-buster-slim→<strong class="lu iv">57.57 MB</strong></li><li id="9e0f" class="mt mu iu lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">节点:lts-buster → <strong class="lu iv"> 321.14 MB </strong></li><li id="95a9" class="mt mu iu lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">节点:13 . 5 . 0-alpine 3.11→<strong class="lu iv">37.35 MB</strong></li></ul><p id="ced0" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><a class="ae kz" href="https://github.com/nodejs/docker-node" rel="noopener ugc nofollow" target="_blank">负责维护Node.js映像的Node.js Docker团队</a>基于<a class="ae kz" href="https://en.wikipedia.org/wiki/Debian_version_history" rel="noopener ugc nofollow" target="_blank"> Debian </a>的stretch和buster映像。Docker团队将alpine映像基于Alpine Linux发行版，这是一个带有强化内核的最小Linux发行版。我的建议是，如果你的应用程序在Alpine上工作，你应该使用Alpine图像作为你的基础图像，因为这可能会导致最小的图像大小。</p></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="e332" class="la lb iu bd lc ld no lf lg lh np lj lk ka nq kb lm kd nr ke lo kg ns kh lq lr bi translated">2.使用非根容器用户</h1><p id="1bf0" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">默认情况下，您的应用程序以root用户身份在容器内运行。但是，容器中的根与主机上的根不同。Docker容器中的用户仍然受到限制。但是为了进一步减少安全攻击，您可能希望尽可能以无特权用户的身份运行容器。</p><p id="8939" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">大多数官方图像已经在其Docker图像中创建了一个非root用户。例如，参见<a class="ae kz" href="https://github.com/nodejs/docker-node/blob/ab3d54cef9f236ed9792aa4b786215db9ee7c1b6/12/alpine3.11/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Alpine Dockerfile </a>，它已经创建了一个名为<em class="nt"> node </em>的组和一个名为<em class="nt"> node </em>的用户供您使用。如果您的Docker文件基于Alpine，您可以使用这个节点用户作为非根用户运行您的应用程序。有关使用节点用户的示例，请参见下面的docker文件。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">以非root用户身份运行Node.js应用程序</p></figure><p id="8b95" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">在第一行中，我使用node:12-alpine图像作为基础图像。第3行的语句为我的应用程序创建了目录。我将这个新目录的所有者显式地设置为节点用户，因为我仍然运行root用户。注意，<code class="fe nw nx ny nz b">WORKDIR</code>指令也创建文件夹，但是没有办法设置目录的所有者。<code class="fe nw nx ny nz b">WORKDIR</code>指令设置工作目录。</p><p id="5eae" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我在第9行将用户设置为节点用户。<code class="fe nw nx ny nz b">USER</code>指令在运行映像时设置用户名(或UID)。Dockerfile设置好用户后，我执行<code class="fe nw nx ny nz b">NPM install</code>来安装我的app的依赖项。该命令将以节点用户的身份运行。在第13和14行，我将应用程序的源代码复制到工作文件夹中。在最后一行，应用程序开始使用<code class="fe nw nx ny nz b">CMD</code>指令。<code class="fe nw nx ny nz b">CMD</code>指令提供执行容器的缺省值。</p></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="ce2c" class="la lb iu bd lc ld no lf lg lh np lj lk ka nq kb lm kd nr ke lo kg ns kh lq lr bi translated">3.启动和停止Node.js应用程序</h1><p id="8e66" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">在Docker容器中以正确的方式启动和停止Node.js应用程序至关重要。在前面显示的Dockerfile中，我使用<code class="fe nw nx ny nz b">CMD</code>指令启动Node.js应用程序。当您使用<code class="fe nw nx ny nz b">CMD</code>指令启动Node.js时，您要确保在您的应用程序内部，您可以接收来自操作系统的信号，比如<code class="fe nw nx ny nz b">SIGINT</code>和<code class="fe nw nx ny nz b">SIGTERM</code>，并处理它们以优雅地关闭您的应用程序。</p><p id="31a4" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">如果你忽略这些信号并停止你的容器，Docker将等待10秒(默认超时)让你的应用程序响应。如果在那个时候，你的应用程序没有响应，它会终止你的节点进程并停止容器。所以你要做的第一件事就是响应<code class="fe nw nx ny nz b">SIGINT</code>和<code class="fe nw nx ny nz b">SIGTERM</code>命令，优雅地关闭你的应用程序。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过响应SIGINT和SIGTERM来优雅地停止Node.js应用程序</p></figure><p id="3053" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">上面的代码示例展示了如何实现对<code class="fe nw nx ny nz b">SIGINT</code>和<code class="fe nw nx ny nz b">SIGTERM</code>信号的响应。在这个例子中，我通过调用<code class="fe nw nx ny nz b">process.exit()</code>退出进程，但是这也是停止服务器和清理未完成连接的地方。</p><p id="6683" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">如果您无法访问源代码或不想更改应用程序的源代码，有两种不同的方法可以关闭您的应用程序。第一种是使用<code class="fe nw nx ny nz b">--init</code>；这个标志向Docker表明应该使用一个init进程作为容器中的PID 1。启动容器时，可以这样使用它:</p><p id="7e23" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><code class="fe nw nx ny nz b">docker run --init -d yournodeappimage</code></p><p id="9c75" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">你的容器将直接对Ctrl-C或Docker stop命令做出反应。</p><p id="22b1" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">另一个更持久的选择是将<a class="ae kz" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank"> tini </a>添加到您的docker文件中，并将其包含在您的图像中。这也是你在使用<code class="fe nw nx ny nz b">--init</code>标志的时候Docker在后台做的事情。您必须在您的映像中安装tini，并使用<code class="fe nw nx ny nz b">ENTRYPOINT</code>启动和包装<code class="fe nw nx ny nz b">CMD </code>——参见下面的示例。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">带蒂尼的Dockerfile</p></figure><h2 id="a922" class="oa lb iu bd lc ob oc dn lg od oe dp lk mb of og lm mf oh oi lo mj oj ok lq ol bi translated">优雅地关闭未完成的HTTP连接</h2><p id="d67d" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">为了能够优雅地停止Node.js应用程序，最后要添加的是处理未完成的HTTP请求，并停止对新HTTP请求的响应。这将允许在使用Docker Swarm或Kubernetes之类的容器编排器时进行无停机更新。</p><p id="7c05" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">代替开发你自己的，有一些库可以为你处理这些。我最常用的是<a class="ae kz" href="https://github.com/hunterloftis/stoppable" rel="noopener ugc nofollow" target="_blank">stop able</a>——这个库停止接受新的连接，并关闭现有的空闲连接(包括keep-alive ),而不会终止正在进行的请求。</p><p id="95e1" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">您必须用可停止的构造函数来包装HTTP服务器的创建，如下所示。</p><pre class="kk kl km kn gu om nz on oo aw op bi"><span id="e37a" class="oa lb iu nz b gz oq or l os ot">const server = stoppable(http.createServer(handler))</span></pre><p id="5935" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">最后，如前所示，通过Stoppable的<code class="fe nw nx ny nz b">server.close</code>关闭服务器来扩展关机功能。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用Stoppable停止您的服务器</p></figure></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="30f7" class="la lb iu bd lc ld no lf lg lh np lj lk ka nq kb lm kd nr ke lo kg ns kh lq lr bi translated">4.健康检查</h1><p id="4d9d" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">Docker文件中的<code class="fe nw nx ny nz b">HEALTHCHECK</code>指令告诉Docker如何验证容器是否仍在工作。这可以检测到这样的情况，例如web服务器陷入无限循环，无法处理新的连接，即使服务器进程仍在运行。</p><p id="fb5e" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">您必须实现自己执行健康检查的功能，这是显而易见的，因为Docker不知道您的应用程序何时正常运行。我通常向我的服务器添加一个不同的路由，专门用于处理健康请求。</p><p id="7599" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我添加了一个单独的小Node.js应用程序，它执行对健康端点的GET请求。这个小应用程序是由<code class="fe nw nx ny nz b">HEALTHCHECK</code>指令使用的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Node.js应用程序来执行对健康端点的GET请求</p></figure><p id="a0dd" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">在Dockerfile文件中，我使用这个小应用程序来执行健康检查。</p><p id="1777" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><code class="fe nw nx ny nz b">HEALTHCHECK --interval=21s --timeout=3 --start-period=10s CMD node healthcheck.js</code></p></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="08c8" class="la lb iu bd lc ld no lf lg lh np lj lk ka nq kb lm kd nr ke lo kg ns kh lq lr bi translated">5.从Node.js应用程序记录日志</h1><p id="e85a" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">在Docker容器中运行时，从Node.js应用程序进行日志记录很简单:根据具体情况，登录到<code class="fe nw nx ny nz b">stdout</code>或<code class="fe nw nx ny nz b">stderr</code>。这背后的基本原理是让其他东西负责处理日志记录。让其他人负责日志记录是有意义的，因为Docker容器主要用在微服务架构中，在微服务架构中，责任分布在多个服务中。</p><p id="5bf7" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我不建议直接从Node.js应用程序中使用<code class="fe nw nx ny nz b">console.log</code>或<code class="fe nw nx ny nz b">console.err</code>。相反，我会编写一个包装器或者使用一个低开销的日志框架，比如<a class="ae kz" href="https://github.com/pinojs/pino" rel="noopener ugc nofollow" target="_blank"> Pino </a>。Pino使用JSON记录到<code class="fe nw nx ny nz b">stdout</code>和<code class="fe nw nx ny nz b">stderr</code>，提供结构化日志记录。</p></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="881b" class="la lb iu bd lc ld no lf lg lh np lj lk ka nq kb lm kd nr ke lo kg ns kh lq lr bi translated">6.使用环境变量的配置</h1><p id="7525" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">我怀疑您已经使用了一个特定的配置对象，它为您的应用程序构造并集中了所有的配置选项，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="417d" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">这样一个对象简洁地定义并集中了应用程序的所有配置选项。这种方法在Docker容器中运行时的问题是，所有的配置都要通过环境变量来完成。</p><p id="f470" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我通常通过让环境变量覆盖配置对象<code class="fe nw nx ny nz b">httpPort: process.env.HTTP_PORT || 3000</code>的默认值来解决这个问题。例如:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure></div></div>    
</body>
</html>