<html>
<head>
<title>Implementing Classes and STL Using the ROOT C++ Interpreter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用根C++解释器实现类和STL</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-classes-and-stl-using-the-root-c-interpreter-335d4caff90e?source=collection_archive---------19-----------------------#2022-01-20">https://betterprogramming.pub/implementing-classes-and-stl-using-the-root-c-interpreter-335d4caff90e?source=collection_archive---------19-----------------------#2022-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8fd1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用根C++解释器的力量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4dedb0c07c5adca8bc602ce78a2fed51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NS7ks0B6aRehNKal"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@heylagostechie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉格斯技术人员</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将演示如何使用ROOT C++解释器定义和实现类，并演示如何使用标准模板库(STL)中可用的一些数据结构和算法。但是首先，我需要演示如何使用ROOT编写独立的程序。</p><h1 id="6de3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">根宏</h1><p id="578b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如我将在后面演示的，在根shell中编写类定义是不可行的。但是，您可以使用shell编写宏并执行它们。下面是定义根宏的方法。</p><p id="c3e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，宏存储在主根目录下的macros子目录中。宏以. C扩展名保存。您可以在宏中编写任何可执行的C++代码，并且不必担心包含任何库，因为shell中包含的库也包含在您的宏中。宏可以从shell或命令行执行。</p><p id="1585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示，下面是一个简单的宏，它显示“Hello，world！”对着屏幕:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f68c" class="mx lw it mt b gy my mz l na nb">void hello() {<br/>  std::cout &lt;&lt; "Hello, world!" &lt;&lt; endl;<br/>}</span></pre><p id="ee39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是从shell中执行宏的样子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a33c" class="mx lw it mt b gy my mz l na nb">root [9] .x hello.C<br/>Hello, world!<br/>root [10]</span></pre><p id="18f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是从命令行执行宏的样子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="79c5" class="mx lw it mt b gy my mz l na nb">C:\root_v6.24.06\bin&gt;root hello.c</span><span id="bab8" class="mx lw it mt b gy nc mz l na nb">------------------------------------------------------------------</span><span id="4092" class="mx lw it mt b gy nc mz l na nb">| Welcome to ROOT 6.24/06                        https://root.cern |</span><span id="f808" class="mx lw it mt b gy nc mz l na nb">| (c) 1995-2021, The ROOT Team; conception: R. Brun, F. Rademakers |</span><span id="bff4" class="mx lw it mt b gy nc mz l na nb">| Built for win32 on Sep 02 2021, 14:20:23                         |</span><span id="7149" class="mx lw it mt b gy nc mz l na nb">| From tags/v6-24-06@v6-24-06                                      |</span><span id="ab29" class="mx lw it mt b gy nc mz l na nb">| With MSVC 19.23.28107.0                                          |</span><span id="91d0" class="mx lw it mt b gy nc mz l na nb">| Try '.help', '.demo', '.license', '.credits', '.quit'/'.q'       |</span><span id="30a8" class="mx lw it mt b gy nc mz l na nb">------------------------------------------------------------------</span><span id="1912" class="mx lw it mt b gy nc mz l na nb">root [0]<br/>Processing hello.c...<br/>Hello, world!<br/>root [1]</span></pre><p id="9b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我必须导航到bin目录来执行宏。</p><p id="5f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三种选择是加载一个函数，例如，用宏编写的函数，然后在shell中执行它。在下面的例子中，我写了一个摄氏到华氏的转换函数，并让它将一组摄氏温度转换成华氏温度。我在一个名为ctof.c的宏文件中定义了该函数。下面是该函数的定义以及从宏中加载该函数并在程序中使用它的脚本:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1638" class="mx lw it mt b gy my mz l na nb">double ctof(double cel) {<br/>  return (9.0 / 5.0) * cel + 32.0;<br/>}</span><span id="24d4" class="mx lw it mt b gy nc mz l na nb">root [0] .L ctof.c<br/>root [1] for (int c = 0; c &lt;= 100; c+=5) {<br/>root (cont'ed, cancel with .@) [2]std::cout &lt;&lt; ctof(c) &lt;&lt; endl;<br/>root (cont'ed, cancel with .@) [3]}<br/>32<br/>41<br/>50<br/>59<br/>68<br/>77<br/>86<br/>95<br/>104<br/>...<br/>194<br/>203<br/>212<br/>root [4]</span></pre><p id="2ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经知道了如何执行宏，让我们利用这些知识来帮助我们更好地使用ROOT构建和执行面向对象的程序。</p><h1 id="c7f2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在宏中创建类定义</h1><p id="d20f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可以在一个宏中创建一个类定义，然后像我们刚才处理函数一样加载它。下面是一个简化的堆栈类定义(我没有把声明和定义部分分开),它是在一个宏文件标题堆栈中定义的。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d4ac" class="mx lw it mt b gy my mz l na nb">template &lt;typename T&gt;<br/>class Stack {<br/>private:<br/>  std::vector&lt;T&gt; data;<br/>public:<br/>  Stack() { }<br/>  void push(T element) {<br/>    data.push_back(element);<br/>  }<br/>  void pop() {<br/>    data.pop_back();<br/>  }<br/>  T top() {<br/>    return data.back();<br/>  }<br/>  void clear() {<br/>    data.clear();<br/>  }<br/>  bool isEmpty() {<br/>    if (data.size() == 0) {<br/>      return true;     <br/>    }<br/>    return false;<br/>  }<br/>};</span></pre><p id="b332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将这个定义加载到解释器中并使用它:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0e4b" class="mx lw it mt b gy my mz l na nb">root [0] .L stack.c<br/>root [1] Stack&lt;string&gt; names;<br/>root [2] names.push("Cynthia");<br/>root [3] names.push("Jonathan");<br/>root [4] std::cout &lt;&lt; names.top() &lt;&lt; endl;<br/>Jonathan<br/>root [5] names.pop();<br/>root [6] std::cout &lt;&lt; names.top() &lt;&lt; endl;<br/>Cynthia<br/>root [7] names.push("Danny");<br/>root [8] if (!names.isEmpty()) {<br/>root (cont'ed, cancel with .@) [9]std::cout &lt;&lt; names.top() &lt;&lt; endl;<br/>root (cont'ed, cancel with .@) [10]}<br/>Danny<br/>root [11] names.clear();<br/>root [12]</span></pre><h1 id="5f1e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用标准模板库</h1><p id="89ae" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">ROOT C++解释器允许你使用标准模板库(STL)中的所有数据结构和算法。让我们看看如何使用STL。</p><p id="ecbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从使用随机数生成创建一个简单的整数向量开始，然后使用<code class="fe nd ne nf mt b">sort</code>函数将向量按升序排列:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1eb5" class="mx lw it mt b gy my mz l na nb">root [0] std::default_random_engine dre(std::time(0));<br/>root [1] std::uniform_int_distribution&lt;int&gt; ints(1,100);<br/>root [2] std::vector&lt;int&gt; numbers;<br/>root [3] for (int i = 1; i &lt;= 10; i++) {<br/>root (cont'ed, cancel with .@) [4]numbers.push_back(ints(dre));<br/>root (cont'ed, cancel with .@) [5]}<br/>root [6] for (int n : numbers) {<br/>root (cont'ed, cancel with .@) [7]std::cout &lt;&lt; n &lt;&lt; endl;<br/>root (cont'ed, cancel with .@) [8]}<br/>13<br/>65<br/>75<br/>21<br/>62<br/>80<br/>95<br/>75<br/>26<br/>71<br/>root [9] std::sort(numbers.begin(), numbers.end());<br/>root [10] for (int n : numbers) {<br/>root (cont'ed, cancel with .@) [11]std:: cout &lt;&lt; n &lt;&lt; endl;<br/>root (cont'ed, cancel with .@) [12]}<br/>13<br/>21<br/>26<br/>62<br/>65<br/>71<br/>75<br/>75<br/>80<br/>95<br/>root [13]</span></pre><p id="8945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试另一种算法。与其显示整个向量，不如使用<code class="fe nd ne nf mt b">for_each</code>函数和一个用户定义的函数来显示大于50的数字，以确定向量元素是否大于50:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6236" class="mx lw it mt b gy my mz l na nb">root [17] void print_greater_than_50(int val) {<br/>root (cont'ed, cancel with .@) [18]if (val &gt; 50) { std::cout &lt;&lt; val &lt;&lt; " "; }<br/>root (cont'ed, cancel with .@) [19]}<br/>root [20] for_each(numbers.begin(), numbers.end(), print_greater_than_50);<br/>62 65 71 75 75 80 95</span></pre><p id="243d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以用lambda函数来编写上面的代码:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="449a" class="mx lw it mt b gy my mz l na nb">root [21] for_each(numbers.begin(), numbers.end(),<br/>[] (int val)   { if (val &gt; 50) std::cout &lt;&lt; val &lt;&lt; " "; });<br/>62 65 71 75 75 80 95</span></pre><p id="afea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺序数据很好，但有时您需要本质上更具关联性的数据。<code class="fe nd ne nf mt b">map</code>数据结构允许您以键/值对的形式存储数据，创建类似电话簿和字典的结构。</p><p id="f8df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子创建了一个存储一组名字和数字的<code class="fe nd ne nf mt b">map</code>。在创建了几组数据之后，该示例演示了如何使用name键提取一个电话号码。代码如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8e50" class="mx lw it mt b gy my mz l na nb">root [0] std::map&lt;string, int&gt; contacts = {{"Cynthia", 2112}, {"Jonathan", 2213},<br/>{"Danny", 2001}, {"Mayo", 2313}};<br/>root [1] std::cout &lt;&lt; contacts["Cynthia"] &lt;&lt; endl;<br/>2112<br/>root [2] std::cout &lt;&lt; contacts["Danny"] &lt;&lt; endl;<br/>2001</span></pre><p id="a13a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个片段演示了如何向地图中插入新数据:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="aa58" class="mx lw it mt b gy my mz l na nb">root [4] contacts.insert({"Raymond", 2412});<br/>root [5] contacts.insert({"April", 2534});</span></pre><p id="c288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们遍历列出存储的每个姓名和号码的完整地图:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0869" class="mx lw it mt b gy my mz l na nb">root [17] for (const auto &amp;contact : contacts) {<br/>root (cont'ed, cancel with .@) [18]std::cout &lt;&lt; contact.first &lt;&lt; ": " &lt;&lt; contact.second &lt;&lt; endl;<br/>root (cont'ed, cancel with .@) [19]}<br/>April: 2534<br/>Cynthia: 2112<br/>Danny: 2001<br/>Jonathan: 2213<br/>Mayo: 2313<br/>Raymond: 2412</span></pre><p id="f4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不熟悉地图，地图元素存储为一个pair结构，它有两个字段，<code class="fe nd ne nf mt b">first</code>和<code class="fe nd ne nf mt b">second</code>。<code class="fe nd ne nf mt b">firs</code> t字段存储联系人地图中的姓名，而<code class="fe nd ne nf mt b">second</code>字段存储号码。</p><p id="027a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个例子，让我们看看如何从列表中删除一个联系人。这涉及到调用<code class="fe nd ne nf mt b">find</code>函数，该函数将一个键作为其参数，返回一个指向带有该键的map元素的迭代器。然后用迭代器作为参数调用<code class="fe nd ne nf mt b">erase</code>函数。下面是一个例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4ce8" class="mx lw it mt b gy my mz l na nb">root [20] auto removed = contacts.find("Raymond");<br/>root [21] contacts.erase(removed);<br/>root [22] for (const auto &amp;contact : contacts) {<br/>root (cont'ed, cancel with .@) [23]std::cout &lt;&lt; contact.first &lt;&lt; ": " &lt;&lt; contact.second &lt;&lt; endl;<br/>root (cont'ed, cancel with .@) [24]}<br/>April: 2534<br/>Cynthia: 2112<br/>Danny: 2001<br/>Jonathan: 2213<br/>Mayo: 2313</span></pre><h1 id="4458" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后的想法</h1><p id="ff50" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我通过演示如何在解释器中创建和使用类，以及如何使用标准模板库的数据结构和算法来执行相当复杂的计算，进一步展示了ROOT C++解释器的强大功能。</p><p id="abf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的下一篇文章中，我将开始演示如何使用ROOT解释器来执行数据分析，这当然是ROOT的全部目的。</p></div></div>    
</body>
</html>