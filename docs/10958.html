<html>
<head>
<title>Build a Functional Programming Library Using ES6 Iterator Protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ES6迭代器协议构建函数式编程库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-our-own-functional-programming-library-from-scratch-with-es6-iterator-protocol-292085f66df2?source=collection_archive---------9-----------------------#2022-02-07">https://betterprogramming.pub/build-our-own-functional-programming-library-from-scratch-with-es6-iterator-protocol-292085f66df2?source=collection_archive---------9-----------------------#2022-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0fb5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解ES6迭代器协议以及如何使用它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b5b4847ff92d0127474bde81958867aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0fvHozBAZHKAcz71"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">保罗·吉尔摩在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><pre class="kg kh ki kj gt kw kx ky kz aw la bi"><span id="f11a" class="lb lc iq kx b gy ld le l lf lg">Table of Contents</span><span id="f318" class="lb lc iq kx b gy lh le l lf lg"><a class="ae kv" href="#ae34" rel="noopener ugc nofollow">Intro</a><br/><a class="ae kv" href="#c647" rel="noopener ugc nofollow">What is Iterator Protocol?</a><br/><a class="ae kv" href="#e2b5" rel="noopener ugc nofollow">map, filter and reduce</a><br/><a class="ae kv" href="#8a00" rel="noopener ugc nofollow">take, takeL</a><br/><a class="ae kv" href="#9c5e" rel="noopener ugc nofollow">pipe and curry</a><br/><a class="ae kv" href="#d315" rel="noopener ugc nofollow">Performance test</a></span></pre></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="ae34" class="lp lc iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">介绍</h1><p id="927e" class="pw-post-body-paragraph mg mh iq mi b mj mk jr ml mm mn ju mo mp mq mr ms mt mu mv mw mx my mz na nb ij bi translated">JavaScript开发者和函数式编程爱好者们，你们好。</p><p id="6d9b" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">在上一篇文章中，我谈到了函数式编程库FxTs，它是用ES6迭代器协议实现的。</p><p id="f137" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">但是你可能和我有同样的问题:</p><blockquote class="nh ni nj"><p id="5c2a" class="mg mh nk mi b mj nc jr ml mm nd ju mo nl ne mr ms nm nf mv mw nn ng mz na nb ij bi translated">什么是ES6迭代器协议，如何使用？</p></blockquote><p id="183b" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">为了回答这个问题，我打算建立我们自己的FP库，因为没有比自己实现更好的方法来理解一些东西。</p><p id="6afe" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">每个人都同意我吗？</p><p id="6635" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">然后，让我们从头开始创建一个函数库。我们就叫它<code class="fe no np nq kx b">light-fp.js</code>。不要害怕。你会惊奇地发现这比你想象的要容易得多。</p><h1 id="c647" class="lp lc iq bd lq lr nr lt lu lv ns lx ly jw nt jx ma jz nu ka mc kc nv kd me mf bi translated">什么是迭代器协议？</h1><p id="8add" class="pw-post-body-paragraph mg mh iq mi b mj mk jr ml mm mn ju mo mp mq mr ms mt mu mv mw mx my mz na nb ij bi translated">有没有想过<code class="fe no np nq kx b">for .. of</code>怎么可以循环<code class="fe no np nq kx b">Map</code>，<code class="fe no np nq kx b">Set</code>不仅仅是<code class="fe no np nq kx b">Array</code>？答案要归功于iterable协议，我现在将对此进行解释。</p><p id="d59e" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">如果我们使用迭代器协议，我们可以通过一个<code class="fe no np nq kx b">for .. of</code>语句使任何对象都是可迭代的。比如<code class="fe no np nq kx b">Map</code>、<code class="fe no np nq kx b">Set</code>、<code class="fe no np nq kx b">Array</code>等内置对象已经有了自己的迭代器，可以循环使用，我们不需要自己实现。另一方面，普通对象没有迭代器，所以不能使用<code class="fe no np nq kx b">for .. of</code>语句。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为..循环示例</p></figure><p id="4337" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">为了能够迭代普通对象，您必须实现遵循迭代器协议的自定义迭代器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="745f" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">看起来很复杂，但如果你一个一个看，其实并不复杂。制作iterable对象的第一个条件是拥有<code class="fe no np nq kx b">Symbol.iterator</code>属性。</p><pre class="kg kh ki kj gt kw kx ky kz aw la bi"><span id="4a1b" class="lb lc iq kx b gy ld le l lf lg">obj[Symbol.iterator] = function() { ... }</span></pre><p id="fe73" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">第二，这个方法应该返回一个具有<code class="fe no np nq kx b">next()</code>的对象，该对象是一个返回<code class="fe no np nq kx b">{ value: someValue, done: false }</code>或<code class="fe no np nq kx b">{ done: true }</code>的方法。<code class="fe no np nq kx b">next</code>方法使用<code class="fe no np nq kx b">done</code>作为标志来停止<code class="fe no np nq kx b">for .. of</code>语句中的迭代。</p><pre class="kg kh ki kj gt kw kx ky kz aw la bi"><span id="0a1d" class="lb lc iq kx b gy ld le l lf lg">obj[Symbol.iterator] = function() {<br/>  return {<br/>    next() {<br/>      return isIterationFinished <br/>        ? { done: true }<br/>        : { value: someValue, done: false }<br/>    }<br/>  }<br/>}</span></pre><p id="3e5c" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">第三，要让一个结构良好的迭代器像内置迭代器一样，<code class="fe no np nq kx b">next()</code>应该返回迭代器本身。注意，不能使用<code class="fe no np nq kx b">for .. of</code>语句，除非它是一个格式良好的迭代器。</p><pre class="kg kh ki kj gt kw kx ky kz aw la bi"><span id="ed8a" class="lb lc iq kx b gy ld le l lf lg">obj[Symbol.iterator] = function() {<br/>  return {<br/>    next() {<br/>      return isIterationFinished <br/>        ? { done: true }<br/>        : { value: someValue, done: false }<br/>    },<br/>    [Symbol.iterator]() { return this; } // &lt;-- HERE<br/>  }<br/>}</span></pre><p id="7dd3" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">太简单了，不是吗？使用生成器函数有一种更简单的方法来构造一个格式良好的迭代器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="5b16" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">要创建一个生成器函数，应该在函数名前附加一个星号(*)。然后，对每个迭代值使用<code class="fe no np nq kx b">yield</code>关键字。这个<code class="fe no np nq kx b">yield</code>关键字停止了生成器函数的执行，每次迭代器执行<code class="fe no np nq kx b">next()</code>时，都会返回跟在<code class="fe no np nq kx b">yield</code>关键字后面的表达式的值。</p><p id="6487" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">这是一个关键的技术，用它我们可以创建懒惰的<code class="fe no np nq kx b">map</code>、<code class="fe no np nq kx b">filter</code>和<code class="fe no np nq kx b">reduce</code>。</p><h1 id="e2b5" class="lp lc iq bd lq lr nr lt lu lv ns lx ly jw nt jx ma jz nu ka mc kc nv kd me mf bi translated">映射、过滤和减少</h1><p id="6f07" class="pw-post-body-paragraph mg mh iq mi b mj mk jr ml mm mn ju mo mp mq mr ms mt mu mv mw mx my mz na nb ij bi translated">既然您已经熟悉了迭代器，那么让我们从实现<code class="fe no np nq kx b">map</code>、<code class="fe no np nq kx b">filter</code>和<code class="fe no np nq kx b">reduce</code>开始。这些函数是函数式编程中的基本函数，因为大多数函数都是从这三个函数派生出来的。</p><p id="5bfa" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">先来看看<code class="fe no np nq kx b">map</code>吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="2d69" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">第一个是我们知道的通用map实现，第二个是lazy map。它在<code class="fe no np nq kx b">for .. of</code>语句中的<code class="fe no np nq kx b">yield</code>处停止迭代，并执行<code class="fe no np nq kx b">f(a)</code>函数。</p><p id="2147" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">接下来是<code class="fe no np nq kx b">filter</code>。实现与<code class="fe no np nq kx b">map</code>几乎相同。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f5d3" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">最后，<code class="fe no np nq kx b">reduce</code>功能。由于<code class="fe no np nq kx b">reduce</code>函数的目的是做一个值，所以我们不需要实现lazy reduce。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="8a00" class="lp lc iq bd lq lr nr lt lu lv ns lx ly jw nt jx ma jz nu ka mc kc nv kd me mf bi translated">拿着，塔科</h1><p id="b997" class="pw-post-body-paragraph mg mh iq mi b mj mk jr ml mm mn ju mo mp mq mr ms mt mu mv mw mx my mz na nb ij bi translated">take函数接收一个数字作为参数，用于只提取数组的一部分，与相应的值一样多。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="9c5e" class="lp lc iq bd lq lr nr lt lu lv ns lx ly jw nt jx ma jz nu ka mc kc nv kd me mf bi translated">烟斗和咖喱</h1><p id="f3e8" class="pw-post-body-paragraph mg mh iq mi b mj mk jr ml mm mn ju mo mp mq mr ms mt mu mv mw mx my mz na nb ij bi translated">让我们也制作<code class="fe no np nq kx b">pipe</code>和<code class="fe no np nq kx b">curry</code>函数来帮助函数合成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6573" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">下面举例说明如何使用<code class="fe no np nq kx b">pipe</code>和<code class="fe no np nq kx b">curry</code>功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="43fe" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">这里要注意的是我们的curry函数只能做1次curry。您必须在第一个中填入1个参数，在第二个中填入所有其余的参数。可以使一个<code class="fe no np nq kx b">curry</code>函数多次弯曲，但为了方便函数组合，函数有两个以上的参数，如<code class="fe no np nq kx b">reudce</code>，一次弯曲更好。</p><pre class="kg kh ki kj gt kw kx ky kz aw la bi"><span id="4c30" class="lb lc iq kx b gy ld le l lf lg">// our curry function doesn't surrpot currying 3 times,<br/>curried_sum3(1)(2)(3); // Doesn't work!<br/>curried_sum(1)(2, 3); // Works !</span></pre><p id="ef1f" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">现在我们已经创建了一个<code class="fe no np nq kx b">curry</code>函数，让我们将它应用于<code class="fe no np nq kx b">map</code>、<code class="fe no np nq kx b">filter</code>、<code class="fe no np nq kx b">take</code>和<code class="fe no np nq kx b">reduce</code>。我们完整版的FP库应该是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">light-fp.js</p></figure><p id="a54b" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">准备结束。现在是时候测试我们的成果了。</p><h1 id="d315" class="lp lc iq bd lq lr nr lt lu lv ns lx ly jw nt jx ma jz nu ka mc kc nv kd me mf bi translated">特性试验</h1><p id="8fdc" class="pw-post-body-paragraph mg mh iq mi b mj mk jr ml mm mn ju mo mp mq mr ms mt mu mv mw mx my mz na nb ij bi translated">让我们测试惰性函数和非惰性函数的性能。这两组将执行相同的功能，但表现出完全不同的性能。</p><blockquote class="nh ni nj"><p id="0696" class="mg mh nk mi b mj nc jr ml mm nd ju mo nl ne mr ms nm nf mv mw nn ng mz na nb ij bi translated"><a class="ae kv" href="https://codesandbox.io/s/light-fp-performace-test-e9nlh" rel="noopener ugc nofollow" target="_blank">性能测试:非懒惰vs懒惰</a></p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/46b1e4629132e1882b7ec028effd3769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xiMgU5yrOXhFcjX0825Cgw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">性能测试1:非懒惰与懒惰</p></figure><p id="f82a" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">如您所见，多亏了惰性评估，我们能够排除不必要的操作。然而，懒惰评估并不总是所有情况下的灵丹妙药。如果只是简单地遍历一个数组来创建一个新数组，非懒惰会更快。</p><blockquote class="nh ni nj"><p id="8ea1" class="mg mh nk mi b mj nc jr ml mm nd ju mo nl ne mr ms nm nf mv mw nn ng mz na nb ij bi translated"><a class="ae kv" href="https://codesandbox.io/s/light-fp-performace-test2-55hh7" rel="noopener ugc nofollow" target="_blank">性能测试2:非懒惰vs懒惰</a></p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/93c2fffa8796998c1706f8291301503e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42Zrb4ulX1QZsG_QUcdoBw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">性能测试2:非懒惰与懒惰</p></figure><p id="37a4" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">因此，如果您必须处理重要的性能问题，您应该选择正确的评估方法，而不是总是选择懒惰的函数。</p><h1 id="e48f" class="lp lc iq bd lq lr nr lt lu lv ns lx ly jw nt jx ma jz nu ka mc kc nv kd me mf bi translated">结论</h1><p id="3645" class="pw-post-body-paragraph mg mh iq mi b mj mk jr ml mm mn ju mo mp mq mr ms mt mu mv mw mx my mz na nb ij bi translated">在本文中，我们研究了如何使用迭代器和生成器从头创建一个函数库。如果你对使用懒求值的函数库感兴趣，建议研究一下FxTs Github代码。</p><p id="f6f5" class="pw-post-body-paragraph mg mh iq mi b mj nc jr ml mm nd ju mo mp ne mr ms mt nf mv mw mx ng mz na nb ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>