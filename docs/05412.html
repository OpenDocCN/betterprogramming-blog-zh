<html>
<head>
<title>The Kotlin Features You’ve Been Missing Out On</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你错过的科特林特色</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-features-youve-been-missing-out-on-f80a415334c1?source=collection_archive---------22-----------------------#2020-07-06">https://betterprogramming.pub/kotlin-features-youve-been-missing-out-on-f80a415334c1?source=collection_archive---------22-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="da54" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看一些很酷但经常被忽视的功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/828c860f4b08e6e939aaaca091ae7463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-sgWjeumkfps0nY-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Marc Reichelt 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="e800" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">析构声明</h1><p id="1314" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://kotlinlang.org/docs/reference/multi-declarations.html" rel="noopener ugc nofollow" target="_blank">析构声明</a>允许我们从对象中提取字段，类似于在TypeScript/ES6中可以做到的。</p><p id="e2b2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">想象我们有以下的<code class="fe mp mq mr ms b">data class</code>:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a8f8" class="mx kx iq ms b gy my mz l na nb">data class Person(val name: String, val age: Int)</span></pre><p id="562b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">可以在一条指令中将<code class="fe mp mq mr ms b">name</code>和<code class="fe mp mq mr ms b">age</code>字段析构为两个独立的变量:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="2334" class="mx kx iq ms b gy my mz l na nb">val john = Person("John Doe", 23)<br/>val (name, age) = john<br/>println(name) // John Doe<br/>println(age) // 23</span></pre><p id="f0ce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不过，有一点需要记住。变量的名字与过程完全无关。重要的是它们相对于对象场的位置。如果你移动了一个<code class="fe mp mq mr ms b">data class</code>的一些字段的位置并且使用了析构，这可能会有问题。如果您添加一个新的字段，这也可能会有问题。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="5400" class="mx kx iq ms b gy my mz l na nb">// before<br/>data class Person(val name: String, val age: Int)<br/>val jane = Person("Jane Doe", 23)<br/>val (name, age) = jane</span><span id="d8ce" class="mx kx iq ms b gy nc mz l na nb">// after<br/>data class Person(<br/>  val firstName: String,<br/>  val lastName: String,<br/>  val age: Int<br/>)</span><span id="19e1" class="mx kx iq ms b gy nc mz l na nb">val (name, age) = jane // this will now be firstName and lastName</span></pre><p id="cdb3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你使用的是<a class="ae kv" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank"> TDD </a>，你的测试应该会发现这些问题。反正小心点还是好的。</p><p id="94ca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">析构也可以用于lambda参数:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="9edc" class="mx kx iq ms b gy my mz l na nb">val people = listOf(<br/>   Person("John Doe", 23),<br/>   Person("Jane Doe", 21),<br/>   ...<br/>)<br/>people.forEach { (name, age) -&gt; ... }</span></pre><p id="813f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">默认情况下，这可用于配对、<code class="fe mp mq mr ms b">map</code>条目和许多其他类型:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d195" class="mx kx iq ms b gy my mz l na nb">map.forEach { (key, value) -&gt; ... }<br/>val (x, y) = Pair(1, 2)</span></pre><p id="f25d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">默认情况下，简单类不支持析构。可以通过添加<code class="fe mp mq mr ms b">componentN</code>方法来启用它，其中<code class="fe mp mq mr ms b">N</code>是析构位置。例如:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="f244" class="mx kx iq ms b gy my mz l na nb">class Person(val name: String, val age: Int) {<br/>  operator fun component1() = name<br/>  operator fun component2() = age<br/>}</span></pre><p id="b333" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mp mq mr ms b">component</code>后面的数字表示对象析构后值的最终位置。</p><p id="f501" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您不需要每次都析构所有的字段。您可以选择只析构您需要的第一个字段。您也可以使用<code class="fe mp mq mr ms b">_</code>字符忽略字段。例如:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="9f42" class="mx kx iq ms b gy my mz l na nb">data class Person(<br/>   val firstName: String,<br/>   val lastName: String,<br/>   val age: Int<br/>)</span><span id="4c55" class="mx kx iq ms b gy nc mz l na nb">val john = Person("John", "Doe", 23)<br/>val (firstName, lastName) = john<br/>val (_, _, age) = john</span></pre></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="228c" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">运算符重载</h1><p id="1b97" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Kotlin支持<a class="ae kv" href="https://kotlinlang.org/docs/reference/operator-overloading.html" rel="noopener ugc nofollow" target="_blank">运算符重载。一些类已经有了重载的操作符。例如:</a></p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="b01a" class="mx kx iq ms b gy my mz l na nb">val result = listOf(1, 2, 3) + listOf(4, 5, 6)<br/>println(result) // 1, 2, 3, 4, 5, 6</span><span id="883e" class="mx kx iq ms b gy nc mz l na nb">val duration = Duration.ofSeconds(10) + Duration.ofSeconds(5)<br/>println(duration) // PT15S (15 seconds)</span></pre><p id="b7f9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以通过声明<code class="fe mp mq mr ms b">operator</code>方法来为您的类重载操作符。可用操作员的完整列表可在<a class="ae kv" href="https://kotlinlang.org/docs/reference/operator-overloading.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到。举个简单的例子，让我们只考虑<code class="fe mp mq mr ms b">plus</code>操作符:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a04e" class="mx kx iq ms b gy my mz l na nb">data class Quantity(val value: Int) {<br/>    operator fun plus(other: Quantity) =<br/>       Quantity(value + other.value)<br/>}</span></pre><p id="4944" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mp mq mr ms b">other</code>不一定是同一类型——它可以是任何类型。现在我们可以写:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="bc3f" class="mx kx iq ms b gy my mz l na nb">val a = Quantity(10)<br/>val b = Quantity(15)<br/>val c = a + b // Quantity(25)</span></pre><p id="9509" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一件很酷的事情是你可以使用<a class="ae kv" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank">扩展</a>来添加操作符到现有的类中:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6270" class="mx kx iq ms b gy my mz l na nb">operator fun Quantity.plus(quantity: Int) =<br/>   Quantity(value + quantity)</span><span id="cfbe" class="mx kx iq ms b gy nc mz l na nb">val a = Quantity(10) + 15 // Quantity(25)</span></pre><h2 id="f654" class="mx kx iq bd ky np nq dn lc nr ns dp lg lx nt nu li mb nv nw lk mf nx ny lm nz bi translated">可比较的</h2><p id="354c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">任何实现<code class="fe mp mq mr ms b">Comparable</code>的类都自动带有以下比较运算符:<code class="fe mp mq mr ms b">&lt;</code>、<code class="fe mp mq mr ms b">&gt;</code>、<code class="fe mp mq mr ms b">&lt;=</code>和<code class="fe mp mq mr ms b">&gt;=</code>:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="3e9c" class="mx kx iq ms b gy my mz l na nb">data class Quantity(val value: Int) : Comparable&lt;Quantity&gt; {<br/>    override fun compareTo(other: Quantity) =<br/>            value.compareTo(other.value)<br/>}</span><span id="c78a" class="mx kx iq ms b gy nc mz l na nb">// now we can compare:<br/>val a = Quantity(10)<br/>val b = Quantity(5)<br/>if (a &gt;= b) ...</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/7f40db9155a10839dc3ab94734c6fb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1CjktA3eAOuGPJS_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@asthetik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·肯尼利</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="222f" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">复制</h1><p id="5ecf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你有没有遇到过一个巨大的<a class="ae kv" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank">数据传输对象</a>或<a class="ae kv" href="https://martinfowler.com/bliki/ValueObject.html" rel="noopener ugc nofollow" target="_blank">值对象</a>有很多属性，而想要创建一个副本，只改变一个属性？Kotlin为<code class="fe mp mq mr ms b">data class</code> es提供了开箱即用的特性。</p><p id="a879" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">实际上，用Kotlin的<a class="ae kv" href="https://kotlinlang.org/docs/reference/data-classes.html#copying" rel="noopener ugc nofollow" target="_blank"> copy </a> on <code class="fe mp mq mr ms b">data class</code> es，你可以一次改变不止一个属性。所有其他属性将使用原始对象中设置的值。</p><p id="21af" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="8c48" class="mx kx iq ms b gy my mz l na nb">data class Person(<br/>    val firstName: String,<br/>    val lastName: String,<br/>    val age: Int<br/>)</span><span id="2fa7" class="mx kx iq ms b gy nc mz l na nb">val john = Person("John", "Doe", 23)<br/>val jane = john.copy(<br/>  firstName = "Jane",<br/>  age = 21<br/>) // Jane Doe, 21</span></pre></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="ca26" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">中辍法</h1><p id="0e38" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">即使你不知道<a class="ae kv" href="https://kotlinlang.org/docs/reference/functions.html#infix-notation" rel="noopener ugc nofollow" target="_blank"> <em class="ob">中缀</em> </a> <em class="ob"> </em>关键词<em class="ob">，</em>你肯定用过。例如，<code class="fe mp mq mr ms b">"a" to 10</code>创建一个对，<code class="fe mp mq mr ms b">0 until 10</code>创建一个范围都使用中缀符号。<a class="ae kv" href="https://github.com/kotest/kotest" rel="noopener ugc nofollow" target="_blank"> Kotest </a>在它的<a class="ae kv" href="https://github.com/kotest/kotest/blob/master/doc/matchers.md" rel="noopener ugc nofollow" target="_blank">断言</a>上提供了中缀符号，使得它们读起来很好:<code class="fe mp mq mr ms b">something shouldBe someValue</code>。</p><p id="30a2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mp mq mr ms b">infix</code>符号允许您在调用函数时省略点号和括号。例如，上述示例相当于:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c521" class="mx kx iq ms b gy my mz l na nb">"a" to 10 == "a".to(10)<br/>0 until 10 == 0.until(10)<br/>something shouldBe someValue == something.shouldBe(someValue)</span></pre><p id="509f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要声明一个函数<code class="fe mp mq mr ms b">infix</code>，它应该只有一个没有任何默认值的参数，并且应该是一个成员或扩展函数。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0e93" class="mx kx iq ms b gy my mz l na nb">enum class CoffeeType { espresso }<br/>class CoffeeMachine {<br/>    infix fun make(coffee: CoffeeType) {<br/>       // ...<br/>    }<br/>}</span><span id="6cf0" class="mx kx iq ms b gy nc mz l na nb">val coffeeMachine = CoffeeMachine()<br/>coffeeMachine make espresso</span></pre><p id="67ab" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">中缀调用可以根据它们的返回类型进行链接。这让我们可以写下:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="32cc" class="mx kx iq ms b gy my mz l na nb">0 until 10 step 2</span></pre></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="33ff" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">使具体化</h1><p id="6cfb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">关键字<code class="fe mp mq mr ms b"><a class="ae kv" href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters" rel="noopener ugc nofollow" target="_blank">reified</a></code>允许您访问一个类类型，而不必将其作为参数提供。这只适用于<code class="fe mp mq mr ms b">inline</code>方法，不使用任何反射。这不是你经常需要的东西，但是在处理类类型的时候它会派上用场。</p><p id="534a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是<a class="ae kv" href="https://github.com/mockk/mockk" rel="noopener ugc nofollow" target="_blank">mock</a>嘲笑类时使用的:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="7d8a" class="mx kx iq ms b gy my mz l na nb">val service = mockk&lt;Service&gt;()<br/>// instead of having to write<br/>val service = mockk(Service::class.java)</span></pre><p id="0496" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是我遇到的一个例子，其中一个<code class="fe mp mq mr ms b">reified</code>方法被用来为一个工厂创建一对类型到创建者的lambda。工厂需要根据类类型调用不同的创建者lambda:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0b9f" class="mx kx iq ms b gy my mz l na nb">inline fun &lt;reified T&gt; factory(noinline creator: () -&gt; T) =<br/>    T::class.<em class="ob">java to </em>creator</span><span id="5caa" class="mx kx iq ms b gy nc mz l na nb">val factoriesByClass = <em class="ob">mapOf</em>(<br/>    <em class="ob">factory </em><strong class="ms ir">{ </strong>Person("John Doe", 23) <strong class="ms ir">}</strong>,<br/>    <em class="ob">factory </em><strong class="ms ir">{ </strong>CoffeMachine() <strong class="ms ir">}<br/></strong>)<br/>// instead of <br/>val factoriesByClass = <em class="ob">mapOf</em>(<br/>    Person::class.<em class="ob">java to </em><strong class="ms ir">{ </strong>Person("John Doe", 23) <strong class="ms ir">}</strong>,<br/>    CoffeMachine::class.<em class="ob">java to </em><strong class="ms ir">{ </strong>CoffeMachine() <strong class="ms ir">}<br/></strong>)</span></pre><p id="b153" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这使得工厂代码可读性更好，因为它不会被多余的类类型参数所污染。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/cbbd4002918efe85d2c6e3138098be5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wC4SOsD01GqON9Si"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亚历山大·曾在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="d77e" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">类型别名</h1><p id="4ef7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当你开始得到多种类型的复杂组合时，比如一个<code class="fe mp mq mr ms b">Map&lt;String, List&lt;Person&gt;&gt;</code>(我敢肯定你遇到过比这更复杂的方式)，每次都要把它打出来是相当乏味的。幸运的是，Kotlin附带了<a class="ae kv" href="https://kotlinlang.org/docs/reference/type-aliases.html" rel="noopener ugc nofollow" target="_blank">类型别名</a>，允许您简化这些类型，使它们更具表现力:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6afd" class="mx kx iq ms b gy my mz l na nb">typealias Registry = Map&lt;String, List&lt;Person&gt;&gt;</span></pre><p id="d034" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个特性也可以仅仅用于表现:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="ff3e" class="mx kx iq ms b gy my mz l na nb">typealias Position = Pair&lt;Int, Int&gt;</span></pre></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="ca88" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">委派属性</h1><p id="ec74" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">委托属性允许您向属性中添加逻辑，而不必在同一个类中手动编写该逻辑。您可以编写自己的委托。这样，委托逻辑可以从您的业务逻辑中独立出来并进行测试。在<a class="ae kv" href="https://kotlinlang.org/docs/reference/delegated-properties.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中解释的很好。你也可以使用一些标准的委托。</p><p id="95c8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最常见的是<code class="fe mp mq mr ms b">Lazy</code>委托，它将在第一次调用时计算lambda的结果，并在以后的调用中返回一个记忆化的值。如果初始化值非常昂贵和/或可能不需要，这非常有用。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a858" class="mx kx iq ms b gy my mz l na nb">val <em class="ob">lazyValue</em>: SomethingExpensiveToCreate by <em class="ob">lazy </em><strong class="ms ir">{<br/>    </strong>SomethingExpensiveToCreate()<br/><strong class="ms ir">}</strong></span></pre><p id="cb2d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一个标准的方法是<code class="fe mp mq mr ms b">Observable</code>，通过提供一个用新旧值调用的lambda，允许您跟踪对字段所做的任何修改。</p><p id="0a80" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为您可以实现自己的委托，所以可能性是无限的。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="2fcc" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">包扎</h1><p id="583d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">希望你会发现其中一些功能很有用——如果你还不知道的话。了解更多关于Kotlin的一个很好的资源是<a class="ae kv" href="https://kotlinlang.org/docs/tutorials/edu-tools-learner.html" rel="noopener ugc nofollow" target="_blank"> EduTools </a>插件。也请务必查看一下<a class="ae kv" href="https://kotlinlang.org/docs/reference/" rel="noopener ugc nofollow" target="_blank"> Kotlin参考文献</a>。这里有很多我没有涉及的主题，比如协程，在那里有详细的解释。</p><p id="6149" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>