<html>
<head>
<title>How to Work With SQL in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中使用SQL</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-work-with-sql-in-go-ca8bc0b30722?source=collection_archive---------1-----------------------#2022-02-07">https://betterprogramming.pub/how-to-work-with-sql-in-go-ca8bc0b30722?source=collection_archive---------1-----------------------#2022-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="03a5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">知道如何在Go中查询SQL数据库。正确的方式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2638c729d61f89821cc91459be24f8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j388HWMtWfe0S6v2"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@sunder_2k25?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sunder Muthukumaran </a>拍摄</p></figure><p id="9f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事基于一个关于在Go中使用SQL的好资源:<a class="ae kv" href="http://go-database-sql.org/" rel="noopener ugc nofollow" target="_blank">http://go-database-sql.org/</a>。我鼓励您查看它，全面了解SQL数据库的Go方法。</p><h1 id="2fb1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">概观</h1><p id="a488" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在Go中使用SQL或类似SQL的数据库的惯用方式是通过<code class="fe mp mq mr ms b"><a class="ae kv" href="http://golang.org/pkg/database/sql/" rel="noopener ugc nofollow" target="_blank">database/sql package</a></code>。它为面向行的数据库提供了一个轻量级接口。这个包的文档告诉你每件事都做什么，但是没有告诉你如何使用这个包。我们中的许多人发现自己希望有一个快速的参考和一个讲述故事而不是列举事实的“入门”方向。这个故事就是关于这个的。我们走吧！</p><h2 id="7850" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">sql。分贝</h2><p id="d43c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要在Go中访问数据库，可以使用一个<a class="ae kv" href="https://pkg.go.dev/database/sql#DB" rel="noopener ugc nofollow" target="_blank"> sql。DB </a>。您可以使用这种类型来创建语句和事务、执行查询以及获取结果。</p><p id="0dde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该知道的第一件事是<code class="fe mp mq mr ms b">sql.DB</code>不是一个数据库连接。它也没有映射到任何特定数据库软件的“数据库”或“模式”概念它是数据库的抽象，可以像本地文件一样变化，可以通过网络连接访问，也可以在内存中和进程中访问。</p><p id="4dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">sql.DB</code>在幕后为你执行一些重要的任务:</p><ul class=""><li id="da41" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">它通过驱动程序打开和关闭与实际底层数据库的连接。</li><li id="591c" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">它根据需要管理一个连接池，可能是上面提到的各种东西。</li></ul><p id="2d37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">sql.DB</code>抽象旨在让您不必担心如何管理对底层数据存储的并发访问。多个goroutines并发使用是安全的。</p><p id="d45a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您使用某个连接来执行某项任务时，该连接会被标记为正在使用，当它不再使用时，会被返回到可用池中。这样做的一个后果是，如果您无法将连接释放回池中，您可能会导致<code class="fe mp mq mr ms b">sql.DB</code>打开大量的连接，潜在地耗尽资源(太多的连接，太多的打开文件句柄，缺少可用的网络端口，等等)。我们稍后会详细讨论这一点。</p><h2 id="4106" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">数据库驱动程序</h2><p id="ff9d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要使用<code class="fe mp mq mr ms b">database/sql</code>,你需要软件包本身，以及你想要使用的特定数据库的驱动程序。</p><p id="1167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你通常不应该直接使用驱动包，尽管有些驱动鼓励你这样做。(在我们看来，这通常是个坏主意。)相反，如果可能的话，您的代码应该只引用在<code class="fe mp mq mr ms b">database/sql</code>中定义的类型。这有助于避免使您的代码依赖于驱动程序，因此您可以用最少的代码更改来更改底层驱动程序(以及您正在访问的数据库)。这也迫使你使用Go习惯用法，而不是某个特定驱动作者可能提供的特别习惯用法。</p><p id="4e31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Go标准库中不包含数据库驱动程序。但是有很多是作为第三方实现的，参见<a class="ae kv" href="https://golang.org/s/sqldrivers" rel="noopener ugc nofollow" target="_blank">https://golang.org/s/sqldrivers</a>。</p><p id="ce6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于演示目的，我们将使用优秀的<a class="ae kv" href="https://github.com/go-sql-driver/mysql" rel="noopener ugc nofollow" target="_blank"> MySQL驱动程序</a>。</p><p id="7332" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将以下内容添加到Go源文件的顶部:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="992c" class="mt lt iq ms b gy nx ny l nz oa">import (<br/>	"database/sql"<br/>	_ "github.com/go-sql-driver/mysql"<br/>)</span></pre><p id="e824" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们正在匿名加载驱动程序，将它的包限定符别名化为<code class="fe mp mq mr ms b">_</code>,因此它的导出名称对我们的代码都不可见。在幕后，驱动程序将自己注册为对<code class="fe mp mq mr ms b">database/sql</code>包可用，但是一般来说，除了init函数运行之外，不会发生任何其他事情。</p><p id="e696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您已经准备好访问数据库了。</p><h1 id="85de" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">访问数据库</h1><p id="a292" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在您已经加载了驱动程序包，您已经准备好创建一个数据库对象，一个<code class="fe mp mq mr ms b">sql.DB</code>。</p><p id="61b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建一个<code class="fe mp mq mr ms b">sql.DB</code>，您需要使用<code class="fe mp mq mr ms b">sql.Open()</code>。这将返回一个<code class="fe mp mq mr ms b">*sql.DB</code>:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="3b55" class="mt lt iq ms b gy nx ny l nz oa">func main() {<br/>	db, err := sql.Open("mysql",<br/>		"user:password@tcp(127.0.0.1:3306)/hello")<br/>	if err != nil {<br/>		log.Fatal(err)<br/>	}<br/>	defer db.Close()<br/>}</span></pre><p id="b910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在所示的例子中，我们举例说明了几件事:</p><ol class=""><li id="3cfc" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr ob nl nm nn bi translated"><code class="fe mp mq mr ms b">sql.Open</code>的第一个参数是驱动程序名。这是驱动程序用来向<code class="fe mp mq mr ms b">database/sql</code>注册自己的字符串，通常与包名相同以避免混淆。例如，<code class="fe mp mq mr ms b">mysql</code>代表<a class="ae kv" href="https://github.com/go-sql-driver/mysql" rel="noopener ugc nofollow" target="_blank">github.com/go-sql-driver/mysql</a>。有些驱动不遵循惯例，使用数据库名，例如<code class="fe mp mq mr ms b">sqlite3</code>代表<a class="ae kv" href="https://github.com/mattn/go-sqlite3" rel="noopener ugc nofollow" target="_blank">github.com/mattn/go-sqlite3</a>和<code class="fe mp mq mr ms b">postgres</code>代表<a class="ae kv" href="https://github.com/lib/pq" rel="noopener ugc nofollow" target="_blank">github.com/lib/pq</a>。</li><li id="c556" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ob nl nm nn bi translated">第二个参数是特定于驱动程序的语法，它告诉驱动程序如何访问底层数据存储。在本例中，我们连接到本地MySQL服务器实例中的“hello”数据库。</li><li id="41fd" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ob nl nm nn bi translated">您应该始终检查并处理所有<code class="fe mp mq mr ms b">database/sql</code>操作返回的错误。</li><li id="6909" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ob nl nm nn bi translated">对于<code class="fe mp mq mr ms b">defer db.Close()</code>来说，如果<code class="fe mp mq mr ms b">sql.DB</code>不应该有超出函数范围的生存期，这是惯用的。</li></ol><p id="dd18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许与直觉相反，<code class="fe mp mq mr ms b">sql.Open()</code>没有建立到数据库的任何连接，也没有验证驱动程序连接参数。相反，它只是为以后的使用准备数据库抽象。当第一次需要时，第一个到底层数据存储的实际连接将被延迟建立。如果您想立即检查数据库是否可用和可访问(例如，检查您是否可以建立网络连接并登录)，使用<code class="fe mp mq mr ms b">db.Ping()</code>来完成，并记住检查错误:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="d4b5" class="mt lt iq ms b gy nx ny l nz oa">err = db.Ping()<br/>if err != nil {<br/>	// do something here<br/>}</span></pre><p id="6c87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管当您使用完数据库时习惯于使用<code class="fe mp mq mr ms b">Close()</code>，但是<code class="fe mp mq mr ms b">sql.DB</code>对象被设计成是长期存在的。不要频繁的<code class="fe mp mq mr ms b">Open()</code>和<code class="fe mp mq mr ms b">Close()</code>数据库。相反，为您需要访问的每个不同的数据存储创建一个<code class="fe mp mq mr ms b">sql.DB</code>对象，并保留它，直到程序访问完那个数据存储。根据需要传递它，或者让它在全球范围内可用，但要保持开放。并且不要从一个短命的函数<code class="fe mp mq mr ms b">Open()</code>和<code class="fe mp mq mr ms b">Close()</code>。相反，将<code class="fe mp mq mr ms b">sql.DB</code>作为一个参数传递给这个短期函数。</p><h1 id="822c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">检索结果集</h1><p id="d58e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Go的<code class="fe mp mq mr ms b">database/sql</code>函数名很重要。如果一个函数名包含<code class="fe mp mq mr ms b">Query</code>，它被设计成询问数据库的一个问题，并且将返回一组行，即使它是空的。不返回行的语句不应使用<code class="fe mp mq mr ms b">Query</code>函数；他们应该使用<code class="fe mp mq mr ms b">Exec()</code>。</p><h2 id="9a59" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">从数据库获取数据</h2><p id="e85a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们看一个例子，看看如何查询数据库，处理结果。我们将在<code class="fe mp mq mr ms b">users</code>表中查询一个<code class="fe mp mq mr ms b">id</code>为1的用户，并打印出该用户的<code class="fe mp mq mr ms b">id</code>和<code class="fe mp mq mr ms b">name</code>。我们将用<code class="fe mp mq mr ms b">rows.Scan()</code>将结果分配给变量，一次一行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="99cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是上面代码中发生的情况:</p><ol class=""><li id="6965" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr ob nl nm nn bi translated">我们使用<code class="fe mp mq mr ms b">db.Query()</code>将查询发送到数据库。像往常一样，我们检查错误。</li><li id="2db1" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ob nl nm nn bi translated">我们推迟<code class="fe mp mq mr ms b">rows.Close()</code>。这一点非常重要。</li><li id="f696" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ob nl nm nn bi translated">我们用<code class="fe mp mq mr ms b">rows.Next()</code>遍历这些行。</li><li id="d4c0" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ob nl nm nn bi translated">我们用<code class="fe mp mq mr ms b">rows.Scan()</code>将每行中的列读入变量。</li><li id="ea6f" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ob nl nm nn bi translated">我们在完成对行的迭代后检查错误。</li></ol><p id="6a03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这几乎是围棋中唯一的方法。例如，你不能把一行作为一个地图。那是因为一切都是强类型的。您需要创建正确类型的变量，并将指针传递给它们，如下所示。</p><p id="004c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这其中的几个部分很容易出错，并可能产生不良后果。</p><ul class=""><li id="b27e" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated"><code class="fe mp mq mr ms b">rows.Next()</code>指示结果集中的下一行是否可用，并将返回<code class="fe mp mq mr ms b">true</code>，直到结果集用尽或者在获取数据期间出现错误。因此，你应该在<code class="fe mp mq mr ms b">for rows.Next()</code>循环结束时检查错误(这是通过调用<code class="fe mp mq mr ms b">rows.Err()</code>完成的)。如果在循环过程中有错误，你需要知道它。不要只是假设循环会迭代，直到处理完所有的行。</li><li id="6481" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第二，只要有一个打开的结果集(由<code class="fe mp mq mr ms b">rows</code>表示)，底层连接就是繁忙的，在<code class="fe mp mq mr ms b">rows.Close()</code>被调用之前不能用于任何其他查询。这意味着它在连接池中不可用。关于<code class="fe mp mq mr ms b">database/sql</code>的好处是，当<code class="fe mp mq mr ms b">rows.Next()</code>返回<code class="fe mp mq mr ms b">false</code>时，它会隐式地为您调用<code class="fe mp mq mr ms b">rows.Close()</code>，但是如果您过早地退出循环，那么您有责任关闭这些行，否则连接将被占用，无法用于其他操作，从而导致连接泄漏。因此，根据经验，您应该总是<code class="fe mp mq mr ms b">defer rows.Close()</code>，以避免连接泄漏和资源耗尽。</li><li id="7ffb" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><code class="fe mp mq mr ms b">rows.Close()</code>是一个无害的no-op，如果它已经被关闭，那么多次调用它是可以的。但是，请注意，我们首先检查来自<code class="fe mp mq mr ms b">db.Query()</code>的错误，只有在没有错误的情况下才推迟<code class="fe mp mq mr ms b">rows.Close()</code>，以避免运行时混乱(例如，当从<code class="fe mp mq mr ms b">db.Query()</code>方法返回错误时，<code class="fe mp mq mr ms b">rows</code>对象将是<code class="fe mp mq mr ms b">nil</code>)。</li></ul><h2 id="52cc" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">Scan()的工作原理</h2><p id="56e7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当您遍历行并将它们扫描到目标变量中时，Go会在后台为您执行数据类型转换工作。它基于目标变量的类型。意识到这一点可以清理您的代码，并有助于避免重复工作。</p><p id="1091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您从一个用字符串列定义的表中选择一些行，比如<code class="fe mp mq mr ms b">VARCHAR(45)</code>或类似的。然而，您碰巧知道该表总是包含数字。如果你传递一个指向字符串的指针，Go会把字节复制到字符串中。现在您可以使用<code class="fe mp mq mr ms b">strconv.ParseInt()</code>或类似的方法将值转换为数字。您必须检查SQL操作中的错误，以及解析整数时的错误。这是混乱和乏味的。</p><p id="0d92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，你可以只传递给<code class="fe mp mq mr ms b">Scan()</code>一个指向整数的指针。Go会检测到并为你调用<code class="fe mp mq mr ms b">strconv.ParseInt()</code>。如果转换中有错误，对<code class="fe mp mq mr ms b">Scan()</code>的调用将返回错误。您的代码现在更整洁、更小了。这是推荐使用<code class="fe mp mq mr ms b">database/sql</code>的方式。</p><h2 id="dadc" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">单行查询</h2><p id="17c7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果查询最多返回一行，您可以在一些冗长的样板代码周围使用快捷方式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b4f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自查询的错误被推迟，直到调用<code class="fe mp mq mr ms b">Scan()</code>，然后从那里返回。</p><h1 id="1395" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">修改数据</h1><p id="6bf0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用<code class="fe mp mq mr ms b">Exec()</code>，完成一个<code class="fe mp mq mr ms b">INSERT</code>、<code class="fe mp mq mr ms b">UPDATE</code>、<code class="fe mp mq mr ms b">DELETE</code>或另一个不返回行的语句(可能是特定于数据库的)。以下示例显示了如何插入一行并检查有关该操作的元数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="efd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行该语句会产生一个<code class="fe mp mq mr ms b">sql.Result</code>,用于访问语句元数据:最后插入的ID和受影响的行数。</p><p id="5051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不在乎结果呢？如果您只想执行一条语句并检查是否有错误，但忽略结果，该怎么办？下面两种说法不也是这样吗？</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="62ba" class="mt lt iq ms b gy nx ny l nz oa">_, err := db.Exec("DELETE FROM users")  // OK<br/>_, err := db.Query("DELETE FROM users") // BAD</span></pre><p id="94f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案是否定的。它们不做同样的事情，你永远不应该这样使用<code class="fe mp mq mr ms b">Query()</code>。<code class="fe mp mq mr ms b">Query()</code>将返回一个<code class="fe mp mq mr ms b">sql.Rows</code>，它保留一个数据库连接，直到<code class="fe mp mq mr ms b">sql.Rows</code>关闭。由于可能存在未读数据(例如，更多数据行)，因此无法使用该连接。在上面的例子中，连接将<em class="oe">不再</em>被释放。因此，这种反模式是耗尽资源的好方法(例如，连接太多)。</p><h1 id="83a3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="d83d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们探索了使用标准<code class="fe mp mq mr ms b">database/sql</code>包在Go编程语言中使用SQL数据库的惯用方法。为了简洁起见，先不讨论事务和准备好的语句的高级概念。</p><p id="cbbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您需要更多关于如何在<code class="fe mp mq mr ms b">database/sql</code>中处理事务和预准备语句的细节，我鼓励您查看优秀的golang SQL教程:【http://go-database-sql.org/index.html】<a class="ae kv" href="http://go-database-sql.org/index.html" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>