<html>
<head>
<title>Setting Up a Multiplayer 3D Chess Using RealityKit, ARKit, and SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RealityKit、ARKit和SwiftUI设置多人3D象棋</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/setting-up-a-multiplayer-3d-chess-using-realitykit-arkit-and-swiftui-905345301153?source=collection_archive---------3-----------------------#2022-12-13">https://betterprogramming.pub/setting-up-a-multiplayer-3d-chess-using-realitykit-arkit-and-swiftui-905345301153?source=collection_archive---------3-----------------------#2022-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c842" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“用await/async和actors构建3D象棋”的后续</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/562c428c83e4e6e84d663023548b2b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LYDOVJ5R2ub7sYc2Igezw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的外星棋局中的女王截图</p></figure><p id="9e57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我一直在修改今年早些时候写的一篇关于使用SceneKit创建3D象棋游戏的文章。</p><p id="6bf8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在某种程度上基于RealityKit上的WWDC2019演示文稿的返工——尽管本文需要观看的演示文稿是<a class="ae lu" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwjzgvb5-eH7AhVBU6QEHSqOA9UQwqsBegQICxAB&amp;url=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2019%2F610%2F&amp;usg=AOvVaw1lQq1RTuLfTJSjEVyHx7Dx" rel="noopener ugc nofollow" target="_blank">这个</a>。和我一起填写WWDC2019演示文稿中的空白和更多内容。</p><p id="f60d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在实现多对等框架时，我发现自己也深陷在async/await/actor代码中，这不是前者的先决条件，但却是更好的编程。</p><p id="a9b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">多点框架基于BONJOUR协议——苹果公司在2002年推出的“zeroconf”技术组的一部分。</p><p id="31a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管当时很少有人意识到，这是苹果的一个战略举措，以帮助建立他们今天的生态系统套件的标志——一个所有产品都可以透明地相互对话的生态系统。</p><p id="675d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我相信你知道我的意思；你的Apple watch可以和你的iPhone通话，iPhone连接到你在AppleTV上使用的电脑——相信我，当我在80年代中期进入IT世界时，情况并不是这样的。</p><h1 id="fd6e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">多对等框架</h1><p id="ddcd" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">建立多对等框架有点挑剔。</p><p id="c9cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，您需要向<code class="fe ms mt mu mv b">info.plist</code>文件添加三个标志。</p><p id="a24c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个是网络安全设置，第二个和第三个是您想要创建的bonjour服务的名称。</p><p id="e72c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mw">预先警告BONJOUR服务的名称必须以下划线开头，它使用的协议也是如此。所以是_tcp或者_udp。</em></p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="54dd" class="nb lw it mv b be nc nd l ne nf">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;<br/>&lt;plist version="1.0"&gt;<br/>&lt;dict&gt;<br/> &lt;key&gt;NSBonjourServices&lt;/key&gt;<br/> &lt;array&gt;<br/>  &lt;string&gt;_chess-game._tcp&lt;/string&gt;<br/>  &lt;string&gt;_chess-game._udp&lt;/string&gt;<br/> &lt;/array&gt;<br/>&lt;/dict&gt;<br/>&lt;/plist&gt;</span></pre><h1 id="d65b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">多对等服务</h1><p id="4c1e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">完成后，您可以设置服务并启动浏览器来查找它，这取决于您所在的代码分支。</p><p id="a53e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在代码中创建了一个专门的类来做这件事。</p><p id="978f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:这里的<code class="fe ms mt mu mv b">serviceType</code>的名字没有下划线！奇怪的怪癖。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="97ee" class="nb lw it mv b be nc nd l ne nf">class ChessMultipeerSession: NSObject, ObservableObject {<br/>    static var shared = ChessMultipeerSession()<br/>    <br/>    private let serviceType = "chess-game"<br/>    private let myPeerId = MCPeerID(displayName: UIDevice.current.name)<br/>    private var serviceAdvertiser: MCNearbyServiceAdvertiser!<br/>    private var serviceBrowser: MCNearbyServiceBrowser!<br/>    public var session: MCSession!<br/>    <br/>    deinit {<br/>        serviceAdvertiser.stopAdvertisingPeer()<br/>        serviceBrowser.stopBrowsingForPeers()<br/>    }<br/>    <br/>    func startHost() {<br/>        session = MCSession(peer: myPeerId, securityIdentity: nil, encryptionPreference: .required)<br/>        session.delegate = self<br/>        serviceAdvertiser = MCNearbyServiceAdvertiser(peer: myPeerId, discoveryInfo: nil, serviceType: serviceType)<br/>        serviceAdvertiser.delegate = self<br/>        serviceAdvertiser.startAdvertisingPeer()<br/>    }<br/>    <br/>    func startClient() {<br/>        session = MCSession(peer: myPeerId, securityIdentity: nil, encryptionPreference: .required)<br/>        session.delegate = self<br/>        serviceBrowser = MCNearbyServiceBrowser(peer: myPeerId, serviceType: serviceType)<br/>        serviceBrowser?.delegate = self<br/>        serviceBrowser.startBrowsingForPeers()<br/>    }<br/>}</span></pre><p id="7c75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧——但是等等！这里有更多的微妙之处，你需要考虑。因为我们知道我们将只有一个主机和一个客户端，所以我们可以设置对话，以便主机一检测到客户端，就邀请他们加入，而客户端一收到邀请，就接受邀请。显然，在野外你可能要多考虑一下这个问题。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="5185" class="nb lw it mv b be nc nd l ne nf">extension ChessMultipeerSession: MCNearbyServiceAdvertiserDelegate {<br/>    public func advertiser(_ advertiser: MCNearbyServiceAdvertiser, didReceiveInvitationFromPeer peerID: MCPeerID, withContext context: Data?, invitationHandler: @escaping (Bool, MCSession?) -&gt; Void) {<br/>        log.info("didReceiveInvitationFromPeer \(peerID)")<br/>        print("invitationHandler")<br/>    }<br/>}<br/><br/>func browser(_ browser: MCNearbyServiceBrowser, foundPeer peerID: MCPeerID, withDiscoveryInfo info: [String: String]?) {<br/>        log.info("ServiceBrowser found peer: \(peerID)")<br/>        browser.invitePeer(peerID, to: self.session, withContext: nil, timeout: 10)<br/>}</span></pre><p id="17f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了保持简洁，我在这里展示了最少的代码，没有任何错误处理。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="2b97" class="nb lw it mv b be nc nd l ne nf">class Coordinator: NSObject, ARSessionDelegate {<br/>        private let arView: ARView<br/>        private var pieceTemplates: [ChessEntity] = []<br/>        <br/>        private var chessSession = ChessMultipeerSession.shared<br/>        private var common = Common.shared<br/>        private var config = ARWorldTrackingConfiguration()<br/>        private var tapGesture:UITapGestureRecognizer!<br/>        <br/>        init(_ view: ARView) {<br/>            <br/>            config.isCollaborationEnabled = true<br/>            <br/>            self.arView = view<br/>            super.init()<br/>            print("common.role \(common.role)")<br/>            <br/>            if common.role == .host {<br/>                print("host ")<br/>                chessSession.startHost()<br/>                tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleTap(_:)))<br/>                arView.addGestureRecognizer(tapGesture)<br/>            } else {<br/>                print("client ")<br/>                chessSession.startClient()<br/>                tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleTap2(_:)))<br/>                arView.addGestureRecognizer(tapGesture)<br/>            }<br/>            do {<br/>                arView.scene.synchronizationService = try MultipeerConnectivityService(session: chessSession.session)<br/>                arView.session.run(config, options: [])<br/>                arView.session.delegate = self<br/>            } catch {<br/>                print("unable to sync")<br/>            }<br/>}</span></pre><p id="5c02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">RealityKit和ARKit一起处理客户端同步中的所有事情。例如，在这种情况下，它将创建第二个棋盘，用棋子填充它，并保持两个棋盘同步。</p><p id="c488" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了确保资产正确转移，y <em class="mw"> ou必须在建立连接之前创建实体</em> <code class="fe ms mt mu mv b">Codable</code>并上传它们。</p><p id="40c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">谈到资产，这里也需要对我上次构建的原型进行微妙但关键的更改。在其中，我从文件中加载了一个资产作为材料，然后将其添加到实体中。这是一个不能跨多个设备工作的事件序列[即使资产在那里],因为同步将尝试从文件系统引用中引用预加载的资产，这在第二个客户机上将是错误的！</p><p id="4df0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，<em class="mw">你必须使用一个间接引用</em>，比如一组资产材料，一个可以在你所有的iOS设备上工作的引用。这适用于任何/所有资产。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="871d" class="nb lw it mv b be nc nd l ne nf">class Common: ObservableObject {<br/>    static var shared = Common()<br/>    @Published var role:Roles = .host<br/>    @Published var pieceModels:[ChessEntity] = []<br/>    private var loading:Cancellable!<br/>    <br/>    func loadKing(_ andFire:Bool, onCompletion: @escaping () -&gt; Void) {<br/>        let assetName = "GCHKing"<br/>        loading = Entity.loadModelAsync(named: assetName)<br/>            .sink(receiveCompletion: { completion in<br/>                if case let .failure(error) = completion {<br/>                    print("Unable to load a model due to error \(error)")<br/>                }<br/>                self.loading?.cancel()<br/>                <br/>            }, receiveValue: { [self] (entity: Entity) in<br/>                if let entity = entity as? ModelEntity {<br/>                    loading?.cancel()<br/>                    print("Congrats! Model is successfully loaded!")<br/>                    <br/>                    let piecePlayer = ChessEntity()<br/>                    piecePlayer.model = entity.model<br/>                    <br/>                    piecePlayer.position = SIMD3(x: 0, y: 0, z: 0)<br/>                    piecePlayer.setScale(SIMD3(0.0025,0.0025,0.0025), relativeTo: piecePlayer)<br/>                    piecePlayer.generateCollisionShapes(recursive: true)<br/>                    piecePlayer.name = "GCHKing"<br/>                    piecePlayer.components[PieceComponent.self] = PieceComponent(color: .white, value: 0)<br/>                    pieceModels.append(piecePlayer)<br/>                    //anchor.addChild(piecePlayer)<br/>                }<br/>            })<br/>        print("completed")<br/>        <br/>    }<br/>}</span></pre><p id="d4e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此处显示的<code class="fe ms mt mu mv b">loadKing</code>也应该在您启动应用程序时调用，因此登录屏幕。</p><p id="33b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mw">注意:这里要同步的服务名称有</em> <strong class="la iu"> <em class="mw">没有下划线，另一个怪癖</em>。</strong></p><h1 id="58e4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">行动者</h1><p id="dd5b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当然，我需要的不仅仅是一个国王，我把方法改成了<code class="fe ms mt mu mv b">loadAssets</code>上传半打。</p><p id="2a62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是把它放到一个循环中，我马上就遇到了访问我的模型数组的困难——我使用Combine框架解决了这个问题，我使用它来对需要添加到我的数组中的条目进行排队。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="dfbc" class="nb lw it mv b be nc nd l ne nf">pushing = push<br/>    .sink(receiveValue: { [self] model in<br/>        common.pieceModels.append(model)<br/>        print("saved \(common.pieceModels.count)")<br/>})</span></pre><p id="edf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我之所以说修复，是因为我后来读了一篇由matt写的文章，这篇文章告诉我你应该永远不要在Combine框架中使用async/await。为什么是马特？如果你知道为什么，请告诉我为什么，如果你在评论中知道，有人认识马特？替我问他。</p><p id="e139" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我考虑了一下，认为这是尝试实现一个actor——async/await表亲——的好机会。使用此处显示的代码块，最终结果。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="0981" class="nb lw it mv b be nc nd l ne nf">actor ModelsDB: ObservableObject {<br/>    static var shared = ModelsDB()<br/>    var chessModels:[ChessEntity] = []<br/>    <br/>    func saveModel(model: ChessEntity) {<br/>        chessModels.append(model)<br/>    }<br/>}</span></pre><p id="ce16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我开始之前，让我解释一下。</p><p id="1fc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我用这里看到的<code class="fe ms mt mu mv b">chessModels</code>代替了<code class="fe ms mt mu mv b">pieceModels</code>阵。一个数组，你只能在守护它的演员里面访问它——我不禁想起了曼达洛人的那句台词——“这就是方法”——我喜欢演员；尽管实现起来很痛苦，但它们迫使您编写结构化代码。<br/>我创建了一个保存方法并修改了克隆方法——这是异步/等待编码动态的一个很好的练习。</p><h2 id="ba50" class="ng lw it bd lx nh ni dn mb nj nk dp mf lh nl nm mh ll nn no mj lp np nq ml nr bi translated">复制</h2><p id="e516" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">是的，你是对的。这听起来越来越像《星球大战》了。事情是这样的。在国际象棋中，你有六个模型，只有六个。你有国王和王后，主教，骑士，城堡和卒。你可以重复加载模型，尽管正如WWDC所说，那是疯狂的。</p><p id="7e21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不，有一个具体的命令来处理这个，即<code class="fe ms mt mu mv b">clone()</code>。我只需要加载一次原理模型，然后克隆它们。</p><p id="80b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的第一个挑战是延迟克隆过程，直到我有了所有的六个模型——我通过放入一个标志来确保我不会开始克隆过程，直到<strong class="la iu">我确信</strong>一切都被锁定和加载。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="28eb" class="nb lw it mv b be nc nd l ne nf">if chessModels.count == 6 {<br/>    print("downloaded, now cloning")<br/>    sortPlayersV()<br/>}</span></pre><p id="22a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个挑战是我不能确定模型会按照我期望的顺序加载到数组中，尽管这被证明是一种预防措施。我调用了序列X，但可能以序列y结束。为了解决这个问题，我以这段代码结束。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="f55c" class="nb lw it mv b be nc nd l ne nf">func returnPiece(pieceName:String) -&gt; ChessEntity? {<br/>    for piece in chessModels {<br/>        if piece.name == pieceName {<br/>            return piece<br/>        }<br/>    }<br/>    return nil<br/>}</span></pre><p id="3a63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除此之外，很容易使用“<em class="mw">抵抗方法</em>”这个例程使用Swift的可选参数来克隆/构建对方团队。我的团队涂上了金属棕色，看起来像金色，和金属灰色，看起来像银色。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="d873" class="nb lw it mv b be nc nd l ne nf">func cloneUpdateModel(chessPiece: ChessEntity? = nil, index:Int? = nil, x:Float? = nil, y:Float? = nil, z:Float? = nil, material:SimpleMaterial? = nil, color:PieceColor? = nil) {<br/>    var clonedCopy: ChessEntity!<br/>    if chessPiece != nil {<br/>        clonedCopy = chessPiece?.clone(recursive: true)<br/>    }<br/>    if index != nil {<br/>        clonedCopy = chessModels[index!].clone(recursive: true)<br/>    }<br/>    //let newIndex = cloneModel(index: index!)<br/>    if x != nil {<br/>        clonedCopy?.position.x = x!<br/>    }<br/>    if y != nil {<br/>        clonedCopy?.position.y = y!<br/>    }<br/>    if z != nil {<br/>        clonedCopy?.position.z = z!<br/>    }<br/>    if material != nil {<br/>        clonedCopy?.model?.materials = [material!]<br/>    }<br/>    if color != nil {<br/>        clonedCopy?.piece.color = color!<br/>    }<br/>    chessModels.append(clonedCopy!)<br/>}</span></pre><p id="d4b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我对放置板子和锚的手势做了一个小小的改动。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="9c4f" class="nb lw it mv b be nc nd l ne nf">@objc func longPress(_ sender: UIGestureRecognizer? = nil) {<br/><br/>    let result = arView.raycast(from: (sender?.location(in: arView))!, allowing: .estimatedPlane, alignment: .horizontal).first<br/><br/>    if result != nil {<br/>        // Create anchor to sync<br/>        let arAnchor = ARAnchor(name: "chess-game", transform: result!.worldTransform)<br/>        self.arView.session.add(anchor: arAnchor)<br/>        // Add anchor to local scene<br/>        let anchorEntity = AnchorEntity(anchor: arAnchor)<br/>        self.arView.scene.addAnchor(anchorEntity)<br/>        self.doBoard(anchor: anchorEntity)<br/>    } else {<br/>        print("error")<br/>    }<br/>}</span></pre><p id="3d5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一切看起来都很好，虽然，虽然我们还没有完全完成多人游戏，我们有两个玩家，一个棋盘和一些加载的棋子，以及一个基本的移动方式，它都工作了——但只是从一边。</p><p id="0c0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到WWDC2019演讲，这显示了我们需要管理它的代码。我们需要更改用于移动的例程，在尝试这样做之前，更新它以请求棋子的所有权。</p><h1 id="cf7c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">所有权</h1><p id="e179" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">最初，主机拥有所有资产，第二方只有读取权限。没有概念所有权。这是一个对等系统，所有系统都是平等的。</p><pre class="kj kk kl km gt mx mv my bn mz na bi"><span id="2b80" class="nb lw it mv b be nc nd l ne nf">@objc func handleTap(_ sender: UIGestureRecognizer? = nil) {<br/>    let tapLocation = sender?.location(in: arView)<br/>    <br/>    if let piece = arView.entity(at: tapLocation!) as? ChessEntity {<br/>        piece.requestOwnership { request in<br/>            if request == .granted {<br/>                piece.movePiece()<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="e716" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">表演</h1><p id="80c0" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">但是，当我在128 Gb内存的iPhone 13上运行这个应用程序时，我很快遇到了一个更严重的问题，出现了一些严重的延迟和性能问题。我的外星人国际象棋里有太多的几何图形。我通过移除光线使事情变得稍微好了一点，但最终唯一合理的解决办法是找到一套新的象棋模型，从几何学的角度来看，这要简单得多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/7582238a8b89b06ae5213f1c6f480848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s4b8UBMDNsO9-7ug68iDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用ARKit锚定的3D国际象棋，用RealityKit绘制</p></figure><h1 id="45d4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将来的</h1><p id="9b5e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这就把我带到了这篇长文的结尾。在我有一个最小可行的产品之前，主要剩下的工作是整理动作和一些游戏管理——哦，对了，修复黄金骑士+主教，这两个都指向错误的方向！敬请期待下一部分！</p></div></div>    
</body>
</html>