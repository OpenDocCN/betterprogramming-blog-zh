<html>
<head>
<title>30 Days With GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL天</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/30-days-with-graphql-3df3459b0f0c?source=collection_archive---------13-----------------------#2020-03-19">https://betterprogramming.pub/30-days-with-graphql-3df3459b0f0c?source=collection_archive---------13-----------------------#2020-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6cd9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是我在使用GraphQL的第一个月中所学到的东西的汇编</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4dfbd7dfcd2738296ec3ea384ac34fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsDYBuG0Q2Q1EoVs0cfUbQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">埃文·丹尼斯在<a class="ae kv" href="https://unsplash.com/s/photos/question?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d522" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用<a class="ae kv" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">GraphQL</a>30天后，如果我必须用简单的语言向某人解释GraphQL是什么，那么我会说，“Graph QL是一种查询语言，它允许你从你的应用程序数据图中导出树。”我在听Apollo GQL播客时遇到的另一个非常好的定义是“GraphQL为您提供了一种查询语言，使用它您可以请求所需数据和服务的任何组合<em class="ls">。</em>好的，再来一个定义，然后我们可以继续:“GraphQL将控制权放在它应该在的地方，其中服务器描述功能，客户端描述它需要的数据。它们之间的映射是自动完成的。</p><p id="ccde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望我能想出这些定义中的一个。也许我只是开始得有点太晚了(双关语)。但我认为获得新的视角永远不会太晚。让我详细说明这一点。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="db01" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">不同角度</h1><p id="8055" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">GraphQL提供了一个非常不同的API设计视角。在REST中，您设计response，它包含web客户机用来构建视图的字段，而在GraphQL中，客户机使用您公开的字段来构建它们的响应。也可以说GraphQL中存在控制反转。就是这样:<em class="ls">字段—</em>graph QL最原子的部分。</p><p id="3584" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，它是原子的类型，但我喜欢这么想。你所需要做的就是根据一个字段而不是完全响应来思考，突然你就可以解决一些最令人生畏的问题，比如欠取、过取和N + 1 <em class="ls">。对于那些从未听说过这些术语的人，让我快速解释一下。</em></p><h2 id="aad4" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">过量提取</h2><p id="1442" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><em class="ls">超取</em>是指您想要的只是学生选择的名字、姓氏、年龄和科目名称，但是API给了您这个:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="11e4" class="mx mb iq nk b gy no np l nq nr">&gt;&gt;curl <a class="ae kv" href="http://localhost:8080/students" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/students</a><br/>{<br/>  "data":{<br/>    "id": 34,<br/>    "first":"john",<br/>    "middle": "Abraham",<br/>    "last": "Doe",<br/>    "age": 27,<br/>    "DOB": "8/34/1998 13:12:32",<br/>    "enroll_num": "12POKK89POL",<br/>    "enroll_year": 2019,<br/>    "current_sem": 2,<br/>    "subjects": [<br/>      {<br/>        "id": 2,<br/>        "code": "BE-402",<br/>        "name": "Software Engineering"<br/>      },<br/>      {<br/>        "id": 13,<br/>        "code": "AL-24",<br/>        "name": "Machine Learning"<br/>      }<br/>      ]<br/>  }<br/>}</span></pre><h2 id="6c09" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">提取不足</h2><p id="0ca1" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><em class="ls">欠取</em>是当你想要多一点，但是API给你的少一点，你不得不多做一些请求来满足你的需求。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="dd90" class="mx mb iq nk b gy no np l nq nr">&gt;&gt; curl <a class="ae kv" href="http://localhost:8080/students" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/students</a><br/>{<br/>  "data":{<br/>    "id": 34,<br/>    "first":"john",<br/>    "middle": "Abraham",<br/>    "last": "Doe",<br/>    "age": 27,<br/>    "DOB": "8/34/1998 13:12:32",<br/>    "enroll_num": "12POKK89POL",<br/>    "enroll_year": 2019,<br/>    "current_sem": 2,<br/>    "subjects": [2,13]<br/>  }<br/>}<br/>&gt;&gt; curl <a class="ae kv" href="http://localhost:8080/subjects/2" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/subjects/2</a><br/>{<br/>  "data":{<br/>    "id": 2,<br/>    "code": "BE-402",<br/>    "name": "Software Engineering"<br/>  }<br/>}<br/>&gt;&gt; curl <a class="ae kv" href="http://localhost:8080/subjects/2" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/subjects/</a>13<br/>{<br/>  "data":{<br/>    "id": 13,<br/>    "code": "AL-24",<br/>    "name": "Machine Learning"<br/>  }<br/>}</span></pre><h2 id="1d28" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">N + 1</h2><p id="6cb9" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">您最终设法为给定的需求构建了一个理想的响应，但是突然您注意到了一些您从未有过的东西。您注意到许多查询被触发来获取数据，而您认为只需几个查询就可以轻松获取这些数据。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="c5f3" class="mx mb iq nk b gy no np l nq nr">&gt;&gt;curl <a class="ae kv" href="http://localhost:8080/students" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/students</a><br/>{<br/>  "data":{<br/>    "first":"john",<br/>    "last": "Doe",<br/>    "age": 27,<br/>    "subjects": [<br/>      {<br/>        "name": "Software Engineering"<br/>      },<br/>      {<br/>        "name": "Machine Learning"<br/>      }<br/>      ]<br/>  }<br/>}<br/>-------<br/>CONSOLE<br/>-------<br/>SELECT * FROM students;<br/>SELECT * FROM subjects where student_id = 1;<br/>SELECT * FROM subjects where student_id = 13;<br/>...(Upto <em class="ls">N</em>, where N is the number of queries fired to retive subjects enrolled by a student)</span></pre><p id="101d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(如果你在思考GraphQL是如何解决N + 1问题的，就保持这个想法吧。我很快会处理的。)</p><h2 id="cc0c" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">GraphQL方式</h2><p id="531c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在GraphQL中，您只需简单地要求您想要的，您就会得到您所要求的—不多也不少。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="8a82" class="mx mb iq nk b gy no np l nq nr">{<br/>  student{<br/>    first<br/>    last<br/>    age<br/>    subjects{<br/>      name<br/>    }<br/>  }<br/>}</span><span id="2f67" class="mx mb iq nk b gy ns np l nq nr">{<br/>  "data":{<br/>    "first":"john",<br/>    "last": "Doe",<br/>    "age": 27,<br/>    "subjects": [<br/>      {<br/>        "name": "Software Engineering"<br/>      },<br/>      {<br/>        "name": "Machine Learning"<br/>      }<br/>      ]<br/>  }<br/>}</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3054" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">关于GraphQL模式的简要说明</h1><p id="e662" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">GraphQL文档是定义的集合，例如可执行文件定义、类型定义和类型扩展。GraphQL有三个主要操作，即查询(读操作)、突变(写操作后跟读操作)和订阅。这些操作是可执行定义的一部分。只有当您的GraphQL文档包含可执行定义或操作时，它才有资格执行，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="925f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们稍微讨论一下上面定义的模式。以上定义统称为<em class="ls">模式</em>。如您所见，一个模式包含多个类型和指令定义。该模式还为它支持的所有三种操作定义了根操作类型。此外，它是为您隐式定义的，因此您不必在您的模式中定义以下内容:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="69fe" class="mx mb iq nk b gy no np l nq nr"><strong class="nk ir">schema </strong>{<br/>    <strong class="nk ir">query</strong>: Query<br/>    <strong class="nk ir">mutation</strong>: Mutation<br/>}</span></pre><p id="0c69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您需要更改操作的默认名称，您可以显式定义它。假设你想叫它<code class="fe nv nw nx nk b">CustomQuery</code> <em class="ls"> </em>而不是<code class="fe nv nw nx nk b">Query</code>。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="31a6" class="mx mb iq nk b gy no np l nq nr"><strong class="nk ir">schema </strong>{<br/>    <strong class="nk ir">query</strong>: CustomQuery<br/>    ...<br/>}</span></pre><p id="ff23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些根操作决定了这些操作在类型系统中开始的位置。查询<em class="ls"> </em>类型中定义的字段成为GraphQL查询可用的顶级字段。例如，<code class="fe nv nw nx nk b"><strong class="ky ir">user</strong>(id: <strong class="ky ir">String</strong>): User</code>是顶级查询字段，而用户类型中的<code class="fe nv nw nx nk b">age(in: DurationKind): String</code>字段是嵌套查询。</p><p id="8f7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GraphQL是强类型的，正是这个属性允许GraphQL工具在查询执行之前对其进行验证。此外，它有非常丰富的类型系统和语法，允许客户编写各种查询。例如，除了对象类型，它还支持:</p><ul class=""><li id="5721" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">枚举类型——它们描述了一组可能的值，与JAVA或C#等语言的枚举类型相同。</li><li id="7fc1" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">接口类型——graph QL对象然后可以实现这些接口，这要求对象类型将定义由这些接口定义的所有字段。</li><li id="bef3" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">标量类型—标量类型表示GraphQL类型系统中的原始叶值。GraphQL响应采用分层树的形式；这些树上的叶子是GraphQL标量。GraphQL中预定义的标量有<code class="fe nv nw nx nk b">Int</code>、<code class="fe nv nw nx nk b">Float</code>、<code class="fe nv nw nx nk b">String</code>、<code class="fe nv nw nx nk b">ID</code>等。您还可以拥有类似于上面schema中定义的<code class="fe nv nw nx nk b">LocalDate</code>标量的自定义标量。</li><li id="c28e" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">输入对象类型—字段可以采用参数来配置行为，例如<code class="fe nv nw nx nk b">age(in: DurationKind): String</code>。参数可以是枚举、标量，如果需要一些复杂的值，它们可以将输入类型作为输入。提示:让字段只接受单个输入是一个好习惯。如果它需要不止一个，您应该考虑将它组合成一个输入对象类型。</li></ul><p id="dd10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我也让您注意到上面提到的模式中的一些有趣的东西。</p><ul class=""><li id="51db" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated"><code class="fe nv nw nx nk b">!</code>表示给定字段不应为空。如果它应用于数组<code class="fe nv nw nx nk b">[String]!</code>，这意味着字段不应该返回空数组，尽管数组可以有空值。例如，这是一个有效值<code class="fe nv nw nx nk b">[1,2,null]</code>，但这不是<code class="fe nv nw nx nk b">null</code>。</li><li id="dfd0" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated"><code class="fe nv nw nx nk b">directives</code>提供一种在GraphQL文档中描述替代运行时执行和类型验证行为的方式。例如，<code class="fe nv nw nx nk b">@UpperCase</code>会在将字符串的返回值返回给客户端之前将其转换成大写形式，而<code class="fe nv nw nx nk b">@Length</code>会在将值传递给实际的执行引擎之前验证字段的长度。我遇到的一个有趣的指令用例是使用它进行授权。假设有一些字段您只想让具有<code class="fe nv nw nx nk b">ADMIN</code>角色的用户可见和访问。对于这种情况，您可以简单地创建一个<code class="fe nv nw nx nk b">@Admin</code>指令，并用它来注释感兴趣的字段:</li></ul><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="041e" class="mx mb iq nk b gy no np l nq nr"><strong class="nk ir">directive </strong>@Admin <strong class="nk ir">on </strong>FIELD_DEFINITION</span><span id="878d" class="mx mb iq nk b gy ns np l nq nr"><strong class="nk ir">type </strong>User {<br/>    <strong class="nk ir">id</strong>: ID!<br/>    <strong class="nk ir">name</strong>: String @UpperCase<br/>    <strong class="nk ir">age</strong>(in: DurationKind): String<br/>    <strong class="nk ir">phone</strong>: [String!]!<br/>    <strong class="nk ir">DOB</strong>: LocalDate <strong class="nk ir">@Admin</strong><br/>}</span></pre><p id="4c40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的用例中，我总是在单个文件中编写GraphQL模式，但是也可以将模式分布在多个<code class="fe nv nw nx nk b">.graphql</code>文件中。要做到这一点，请确保只有一个文件定义了根查询操作，并且在其他文件中，您可以扩展它。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="c17e" class="mx mb iq nk b gy no np l nq nr">File 1: user.graphql<br/>------------------<br/>type Query{<br/>   user(id: String): User<br/>}</span><span id="3508" class="mx mb iq nk b gy ns np l nq nr">File 2: address.graphql<br/>------------------<br/>extend type Query {<br/>   address(id: String): Address<br/>}</span></pre><p id="e619" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，您可以将许多事情卸载到GraphQL，无论是验证、转换，甚至是API文档。GraphQL有一个叫做<em class="ls">自省查询</em>的东西，它允许查询模式本身。GraphQL Playground等工具使用它来生成文档。</p><p id="03f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GraphQL模式还有很多，但我认为<a class="ae kv" href="https://spec.graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL规范文档</a>在详细解释它方面做得非常好。作为结束语，我想说要永远记住模式是GraphQL最重要的部分之一。想花多少时间就花多少时间去创造和完善它。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c2df" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">一张图</strong></h1><p id="cb9d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们的API一团糟。拥有一个通用的请求和响应负载并不能使我们的API变得完美——承认吧！</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="7e64" class="mx mb iq nk b gy no np l nq nr"><strong class="nk ir">public class </strong>CommonResponse&lt;T&gt; {<br/>    <strong class="nk ir">private </strong>T <strong class="nk ir">data</strong>;<br/>    <strong class="nk ir">private </strong>String <strong class="nk ir">message</strong>;<br/>    <strong class="nk ir">private int statusCode</strong>;<br/>    <strong class="nk ir">private </strong>List&lt;Error&gt; <strong class="nk ir">errors</strong>;<br/>    ...<br/>}</span><span id="0a26" class="mx mb iq nk b gy ns np l nq nr"><strong class="nk ir">public class </strong>CommonRequest&lt;T&gt; {<br/>    <strong class="nk ir">private </strong>T <strong class="nk ir">data</strong>;<br/>}</span></pre><p id="2744" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们对设计API以满足客户需求的追求将我们带到了这样一个地方:我们所有的API都给出完全独特的响应，即使它们显然共享一些共同的结构。例如，看看下面的实体和一些API对它们的响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8d43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你们中的一些人可能认为上面的API响应没有问题，而你们中的一些人可能会感到愤怒，并且一定会想，“这显然是夸大其词了。”因此，对于那些认为这没有错的人，我只想说一个词:重新考虑。对于那些被激怒的人，我要说的是冷静下来。是的，有更好的方法来设计上面的API，是的，有指导方针可以让你做出像样的REST APIs。</p><p id="3857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但关键是，即使你正在设计糟糕的API，也没有什么能阻止你。在GraphQL中并不是没有办法搞砸。只是误差幅度比较小。原因是在GraphQL中，你实际上并没有设计响应。相反，你在定义可能性。</p><p id="e0d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在GraphQL中，使用schema定义可能性。在定义模式时，我们应该记住什么？以下是我在设计模式时谨记的一些事情:</p><ul class=""><li id="6663" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">用与建模实体相似的方式来建模您的模式。这不是必需的，但这是一个很好的起点。通常情况下，您会在服务层之上实现GraphQL，而服务层并不知道您的底层数据库结构。</li><li id="4da6" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">将您的模式描绘成一个图形，其中类型是节点，它们之间的关系是边。想想你是想要他们之间的单向关系还是双向关系。在单向类型中，只有父类型才会有子类型的引用，而在双向类型中，您可能已经猜到了，甚至子类型也会有父类型的引用。这样做的好处是，您的客户端可以轻松地在实体之间移动，并可以获得各种各样的响应。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/ab9743c03a863427f70b58e9537cbd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHmENwwe1gMIDVi5Jk0FEw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://blog.apollographql.com/the-concepts-of-graphql-bc68bd819be3" rel="noopener ugc nofollow" target="_blank">https://blog . apollographql . com/the-concepts-of-graph QL-BC 68 BD 819 be 3</a></p></figure><ul class=""><li id="6a85" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">开始时，只添加客户绝对需要的类型中的那些字段，然后根据需要不断添加更多的字段。</li><li id="9dfe" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">尝试编写返回被查询改变的类型对象的变异，例如<code class="fe nv nw nx nk b">addUser(input: UserInput): <strong class="ky ir">User</strong></code>。</li></ul><p id="1315" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">真正拓宽我对GraphQL理解的一篇文章是<a class="ae kv" href="https://principledgraphql.com/" rel="noopener ugc nofollow" target="_blank"> Principled GraphQL </a>。它由Apollo GraphQL团队编写，定义了在使用数据图时应该牢记的十条原则。数据图是一个层，它将所有应用程序数据和服务汇集在一起，并通过一个一致的界面进行访问。这意味着在你的应用中有一个单一的模式。</p><p id="753d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个让我印象深刻的原则是<em class="ls">一图原则。</em><em class="ls"/>一图原则说，“你的公司应该有一个统一的图，而不是每个团队创建多个图。”好处是每个人都有一个单一的真实来源，而且，因为它是由所有团队共同构建的，所以不会有类型重复。因此，更多的工作将是可重用的，尽管实际的实现可以由单个团队来完成。这起初看起来似乎微不足道，但将有助于充分利用GraphQL的潜力。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1ea9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">数据加载器</strong></h1><p id="fd57" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Data Loader让我注意到一个对我来说并不是真正问题的问题。它叫做<em class="ls">’</em>N+1’。当您的ORM在单个查询中获取一个对象列表时，就会发生这种情况。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="dcb8" class="mx mb iq nk b gy no np l nq nr">SELECT * FROM users</span></pre><p id="e879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是随后它又发出N个查询来获取其子节点。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="2dcb" class="mx mb iq nk b gy no np l nq nr">SELECT * from address where user_id = 1<br/>SELECT * from address where user_id = 2<br/>...</span></pre><p id="841e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">N + 1，也称为‘N+1选择问题<em class="ls">’</em>，早于GraphQL。在这一节中，我们将看到如何解决这个问题，以及GraphQL提供了哪些工具来轻松解决这个问题。通常，这个问题可以通过在单个批处理操作中获取所有父代的子代来解决。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="69ed" class="mx mb iq nk b gy no np l nq nr">SELECT * from address where user_id in (1,2)</span></pre><p id="cdd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GraphQL提供了一个名为Data Loader的工具来帮助您实现这种优化。为了理解如何优化查询，我们首先需要理解GraphQL实际上是如何解析查询的。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="77c4" class="mx mb iq nk b gy no np l nq nr">{<br/>    users{<br/>        first<br/>        last<br/>        age<br/>        address{<br/>            line1<br/>            city<br/>        }<br/>    }<br/>}</span></pre><p id="111c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦验证了上面的查询，它就开始逐个解析字段的值。这些字段中的每一个都由服务器中称为解析器的功能支持。每个解析器返回一个需要进一步解析的类型。这种情况会一直发生，直到遇到标量。结果值存储在键值映射中。这种解析以自下而上的方式进行，从叶子到根。让我们假设在后端有一个名为<code class="fe nv nw nx nk b">address</code>的函数，它负责返回地址值。让我们修改它以支持数据加载器。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="db45" class="mx mb iq nk b gy no np l nq nr"><strong class="nk ir">function </strong>address(User user, Context context) {<br/> <strong class="nk ir">return</strong> context.dataloader('address').<em class="ls">load</em>(user.id)<em class="ls"><br/></em>}</span></pre><p id="5237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数是用一种假设的语言编写的，所以不要过多地研究它的语法。这个函数不是返回给定用户的地址，而是返回地址的一个承诺或未来<em class="ls">T3。这将延迟地址解析，直到所有用户都被解析。到那时，数据加载器也将收集到所有用户的id<em class="ls"/>，这是通过<code class="fe nv nw nx nk b">load()</code>方法完成的。最后，我们还有<code class="fe nv nw nx nk b">AddressDataLoader</code>，它将实际加载数据。</em></p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="77f3" class="mx mb iq nk b gy no np l nq nr"><strong class="nk ir">class </strong>AddressDatalLoader<strong class="nk ir">{<br/>  function </strong>load(int [] ids){<br/>    return loadAddressForAllUsers(ids);<br/> }<br/><strong class="nk ir">}</strong></span></pre><p id="dec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">load函数返回一个地址列表。但是我们的address方法需要一个对象，而不是一个列表，并且也对应于给定的用户ID。数据加载器提供一致的API实现批量加载，但是业务逻辑需要我们提供。我们需要编写一个逻辑，从数据库中批量获取所有需要的数据，并将这些数据返回给加载器。反过来，它会用相应的ID为我们映射一个对象。你只需要遵循一些规则来正确地构建你的结果。</p><ul class=""><li id="ae20" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">值列表的大小必须与键列表的大小相同。如果不是，它将抛出一个异常。</li><li id="22cc" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">值列表中的每个索引必须对应于关键字列表中的相同索引。我们需要通过我们的逻辑来确保这一点。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c52a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">用什么库？</h1><p id="3a51" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果JavaScript是你从客户端到服务器的所有语言的选择，那么我认为没有比Apollo GraphQL更好的库了。这是GraphQL领先的产品级实现之一。但是如果这不是你的情况，那么我认为你将不得不像我一样在某个地方寻找庇护。</p><p id="b715" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">免责声明:</strong>本节将严格谈论GraphQL Java实现。如果Java不是您的首选语言，您可以转到下一个主题。</p><p id="d82c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将从解决房间里的大象开始:<a class="ae kv" href="https://github.com/graphql-java/graphql-java" rel="noopener ugc nofollow" target="_blank"> GraphQL Java </a>实现。</p><h2 id="9848" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">GraphQL Java实现</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d770f7ab7f6e42e6d8c9779631c3c078.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/format:webp/1*8a_QfkVLjGATYfA1lzcB4g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://www.graphql-java.com/" rel="noopener ugc nofollow" target="_blank">https://www.graphql-java.com/</a></p></figure><p id="afca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，它是GraphQL在Java中的一个实现，是所有用Java编写的GraphQL库的核心。它得到了很好的支持，并更新了GraphQL规范中的所有特性。如果您刚刚开始学习GraphQL，这个库应该是您的首选。虽然它对学习有好处，但有些人可能会发现在他们的web应用程序中实现它令人望而生畏，因为需要大量的工作。另一方面，它为您提供了比其他库更多的控制。</p><p id="b514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢GraphQL Java的其他方面:</p><ul class=""><li id="4373" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">一个巨大而活跃的社区支持它</li><li id="5126" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">包含代码示例的优秀文档</li><li id="8dde" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">简单易学</li></ul><p id="7400" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我担心GraphQL Java的事情是…没有！<em class="ls"> </em>即使有，我们也没有真正的选择，不是吗？将它与web应用程序框架如<a class="ae kv" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring </a>集成需要一些努力，但为此，我们有其他可用的库。它只做一项工作，即实现GraphQL规范，而且做得很好。您可能会发现缺少一些有用的标量和模式验证指令，但不用担心:它们正在构建有助于解决这个问题的扩展库。有些可能已经有了，所以检查他们的回购。</p><h2 id="0348" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">GraphQL SPQR</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/241dcece5b693e8f61a7ca88381145a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*RWtpay5oLUcrOmtBxoR09A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://github.com/leangen/graphql-spqr" rel="noopener ugc nofollow" target="_blank">https://github.com/leangen/graphql-spqr</a></p></figure><p id="a986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/leangen/graphql-spqr" rel="noopener ugc nofollow" target="_blank">graph QL SPQR</a>(<em class="ls">speaker</em>)为您提供了一种构建GraphQL APIs的代码优先方法。它承诺大大减少构建GraphQL APIs的开发时间，我认为它信守了承诺。有了SPQR，您只需使用几个注释就可以开始构建API。它使用方法和类型推理从您的类中导出模式。这也意味着，每当您在类中进行更改时，您的模式都会自动更新。老实说，这是一个非常强大的特性，相比之下，有些库必须同时管理模式和类，还要努力使它们保持同步。</p><p id="ed9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢GraphQL SPQR的其他方面:</p><ul class=""><li id="956f" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">它有自己的弹簧启动装置，可以帮你加快一切。</li><li id="53b7" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">它附带了为map、java.time、* classes、object type等类型预先配置的自定义标量。这可能不是SPQR的卖点，但我个人很喜欢这种触感。当您刚刚开始时，您可能会发现很难找到注册自定义标量的方法。</li><li id="e962" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">它的starter pack还为您配置了WebSocket，以防您打算使用订阅。</li><li id="d101" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">它还有一个名为<code class="fe nv nw nx nk b">@GraphQLComplexity</code> <em class="ls"> </em>的注释，限制了查询的深度。这当然很重要，因为客户机可能会给服务器增加查询负担，从而导致大量的数据库查询。这可能会对服务器造成损害。</li></ul><p id="e1eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，SPQR是一个非常可靠的库。它也是经过深思熟虑的，并且在需要时可以扩展。我对SPQR唯一担心的是以下几点:</p><ul class=""><li id="b645" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">一个非常小的社区支持它，所以有时可能需要一段时间来解决问题。</li><li id="8cf9" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">稀疏的文档。对于不是很主流的图书馆来说，这是一个很普遍的问题。也就是说，我已经找到了使用它时遇到的所有问题的解决方案，无论是堆栈溢出、频谱还是问题部分。</li></ul><p id="2d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">荣誉奖:</p><ul class=""><li id="9611" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated"><a class="ae kv" href="https://github.com/graphql-java-kickstart/graphql-spring-boot" rel="noopener ugc nofollow" target="_blank">graph QL-Java-kickstarter</a><em class="ls">:</em>这也是一个很好的探索选项。它为构建GraphQL APIs提供了一种模式优先的方法。SPQR已经存在一段时间了。它有一个活跃的社区和良好的春季支持。</li><li id="6c93" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated"><a class="ae kv" href="https://hasura.io/" rel="noopener ugc nofollow" target="_blank"> Hasura </a> <em class="ls"> : </em> Hasura不是一个库，而是一个为你自动生成高性能GraphQL APIs的开源平台。你需要做的就是把它连接到你的数据库。它还可以连接到多个源，并可以公开一个统一的模式。这真是一个有趣的项目，一定要去看看。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3452" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结束注释</h1><p id="ac3d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">GraphQL不再是一个新手了。Apollo等库和Hasura等平台真正展示了GraphQL的潜力。让脸书和GitHub这样的大玩家在产品中使用它有助于为它建立一个强大的案例。考虑到所有这些因素，您可能仍然不会选择切换到GraphQL。如果您的REST APIs已经构建得很好，这是公平的。不过话说回来，GraphQL到底是什么？只是更好的休息。</p><p id="1b13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8ff1" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">参考</h1><ul class=""><li id="20c7" class="ny nz iq ky b kz ms lc mt lf op lj oq ln or lr od oe of og bi translated"><a class="ae kv" href="https://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank">https://graphql.org/learn/</a></li><li id="8c9e" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated"><a class="ae kv" href="https://spec.graphql.org/draft/" rel="noopener ugc nofollow" target="_blank">https://spec.graphql.org/draft/</a></li><li id="617c" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated"><a class="ae kv" href="https://principledgraphql.com/" rel="noopener ugc nofollow" target="_blank">https://principledgraphql.com/</a></li></ul></div></div>    
</body>
</html>