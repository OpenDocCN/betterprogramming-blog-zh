# Python 对象可调用性的实际含义

> 原文：<https://betterprogramming.pub/the-practical-implications-of-python-objects-callability-50ec2f54e24a>

## 通过汇集相关主题来提高您的 Python 知识

![](img/1fddedd6694162e8db6dc7ce6289ef41.png)

照片由[丹·斯塔克](https://unsplash.com/@dan_stark?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄。

从本质上讲，Python 是一种面向对象的编程(OOP)语言。就实现而言，Python 将其构建块(如包、模块、类、函数和数据)组织为不同种类的对象。因此，理解对象的特征对于编写更好的、错误更少的 Python 代码至关重要。

在本文中，我将重点关注 Python 对象的一个具体特征:可调用性。除了基本概念之外，我想讨论一下它的实际含义，您可以在 Python 项目中实际使用它。

# 基本概念

可调用性是指对象是否可以被调用。像大多数其他现代语言一样，调用一个对象是通过使用一对括号来实现的(被一些人称为调用操作符)。所以如果一个对象可以和调用操作符一起使用，我们说它是可调用的。如果不能，我们说它不可赎回。

下面是一些简单的例子:

使用呼叫接线员

如您所见，函数是可调用的，您可以通过调用它来调用函数。然而，`list`对象是不可调用的。Python 类是可调用的，使用它是我们创建实例对象的方式。我们可以使用内置的`callable()`函数来检查 Python 对象的可调用性，而不是尝试直接调用对象，如下所示:

当我们对这些对象使用 call 操作符时，返回的布尔值与上面显示的行为一致。

# 实践含义 1:类与函数

第一个含义是理解类和函数之间的细微差别。作为可能是最基本和最常用的一组函数，有将近 70 个 [Python 内置函数](https://docs.python.org/3/library/functions.html)。

但是，严格来说，这些函数很多都不是函数。相反，它们实际上是类，如`bool()`、`int()`、`list()`和`dict()`，而不是`sum()`、`callable()`和`hash()`，它们是函数。

知道这种区别在语法上当然不重要，但是从语义的角度来看，这种区别是很明显的。当我们调用类时，我们期望得到相应类的实例对象。虽然我们可以设置任何适用的参数，但是我们知道返回的对象将总是属于与“函数”同名的类，例如`int`、`list`、`dict`和`set`。

相比之下，实函数并不直接与任何底层类相关联。因此，您永远不会期望通过调用这些函数来获得同名的实例对象。例如，你不会期望通过调用`sum()`得到一个`sum`对象，或者通过调用`callable()`得到一个`callable`对象。

# 实践含义 2:重新访问地图和过滤器

尽管被打上了 OOP 语言的烙印，Python 还是有函数式编程的特性。一个这样的特性是高阶函数的集成(两个常见的是`map`和`filter`)。以下代码片段向您展示了这两个函数的一些简单用例:

高阶函数:映射和过滤

但是，如果您检查`map`和`filter`，您会发现以下情况:

```
>>> map
<class 'map'>
>>> filter
<class 'filter'>
```

与我们许多人可能认为的不同，`map`和`filter`实际上都是类。这种误解可能源于这样一种假设，即类通常采用非功能对象来构造实例。但是别忘了 Python 的函数都是对象。因此，`map`和`filter`类的特殊之处在于它的构造包含了函数的传递。

然而，我并不是说我们应该停止调用`map`和`filter`高阶函数。我们应该简单地认识到它们是作为 Python 中的类来实现的。

# 实际含义 3:关键参数

几个 Python 函数包含一个名为`key`的参数，该参数通常在函数执行一些排序或比较操作时使用。独立于函数的指定功能，`key`参数具有相同的要求:一个函数。

以下代码片段向您展示了我们如何在`sorted()`函数中使用常规函数和 lambda 函数:

在 sorted()中使用函数

然而，我们应该明白，我们可以向`key`参数发送任何调用。考虑下面的例子:

在 sorted()中使用类

在上面的例子中，我们创建了一个名为`PokerSorter`的定制类。它所做的只是将非数字卡片映射到它们相应的数值上。通过将这个类应用于`sorted()`函数，我们能够按照预期对卡片进行排序。

# 实践含义 4:使用类作为装饰者

一般来说，装饰器是高阶函数，它修改被装饰的函数，而不影响被装饰的函数的预期操作。这就是为什么我们可以说一个高阶函数修饰了另一个函数。

以下代码向您展示了我们如何创建一个装饰函数并装饰另一个函数:

*   `logging_time`函数是 decorator 函数，它将一个函数作为其参数。
*   这个函数包含一个名为`logger`的内部函数，在这个函数中发生与装饰相关的操作。在本例中，我们记录了函数调用和完成之间的时间差。
*   decorator 函数返回内部函数`logger`作为输出值。
*   为了使用装饰器，我们把它放在要装饰的函数上面，在装饰器函数名前面加一个`@`符号。大家可以看到，装饰之后，调用`calculate_sum_n`就会产生这个函数的运行时间。

鉴于到目前为止已经讨论过的类和函数之间的相似性，您可能会猜测使用类来实现修饰特性是可能的。让我们看看它是如何工作的:

作为装饰者的类

*   我们创建一个名为`TimeLogger`的定制类。一个显著的特性是这个类的构造函数接受一个参数，这个参数就是要修饰的函数。
*   在初始化方法(即`__init__`)中，我们创建了与装饰函数相同的函数(即`logger`)。不同之处在于，我们现在将它保存为实例的属性。
*   我们可以使用相同的语法来修饰这个类的函数。但是，需要注意的是，修饰函数不再是函数。相反，它是`TimeLogger`类的实例对象。

```
>>> calculate_sum_n_cls
<__main__.TimeLogger object at 0x110105340>
```

*   为了使这个实例对象的行为像一个函数，我们必须覆盖`__call__`特殊方法，在该方法中我们调用`_logger`函数的属性。

你可能想知道为什么我们想要使用类作为装饰者。有几个原因:

*   您可以实现更复杂的接受参数的装饰器。使用类更容易提供这种灵活性。
*   我们可以向实例对象添加其他属性。例如，我们可以保存计算结果的记录作为对象的属性，这样当一些昂贵的计算发生多次时，我们可以节省大量时间。

# 结论

本文讨论了 Python 对象可调用性的概念。我们讨论了可赎回性的四个实际含义。本质上，类和函数在 Python 中都是可调用的，这就在它们之间创造了很多相互交流的可能性。因此，当我们考虑到可调用性时，我们可以编写更灵活的代码。