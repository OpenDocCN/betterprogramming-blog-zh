# 如何避免实例化无效的实体类

> 原文：<https://betterprogramming.pub/how-to-avoid-instantiating-invalid-entity-classes-8e5af0c6bd4>

## 帮助您节省实例化时间的简短探索

![](img/20bfefe973f08855a48a6667ec9cef04.png)

由[迈克尔·泽兹奇](https://unsplash.com/@lazycreekimages?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

在 [Infraspeak](https://infraspeak.com/) ，整个工程团队每个月都有几天时间完全投入到宠物项目中。当我和我的朋友 Nelson 在开发我们的自动化机器人时，我们向我们的域引入了第一批实体，却没有首先注意到我们正在创建无效的实例。本文展示了为什么这些实例从一开始就被破坏，以及如何确保我们总是使用有效的实例，甚至是在将它们保存在数据存储中之前。

实体是由连续性和同一性的线索定义的。这意味着，由于有一个唯一的 ID，无论何时它们的属性值改变，它仍然是同一个实体，我们总是能够引用它(这是连续性部分)。

在开发软件时，我们应该努力实现不可变的对象，这一点被广泛接受。如果我们想改变不可变对象内部的某些东西，我们用更新后的值创建新的实例。这可以防止对象在应用程序逻辑的执行过程中被无意地改变，从而可能使其处于无效状态。

我不会过多地研究这种模式(改天再发)，但重点是当处理不可变对象时，它们应该处于有效和可用的状态。接受该对象的任何地方都不需要担心不断检查其有效性。

因此，如果通过惟一 ID 拥有一个身份完全定义了一个实体，并且它应该在实例化时立即有效，那么使用来自数据存储的顺序生成的数字作为实体身份的来源就是一个问题。原因如下:我们无法安全地预测下一个数字是什么，而且这样做甚至不是实体的责任，这让我们陷入了两难境地:我们需要实例化一个实体来持久化它并获得那个 ID，但我们不能，因为要实例化它，我们需要有一个 ID。那么，该怎么办呢？

一个天真、本能的解决方法是接受两种类型的 ID 属性:一个`integer`或一个`null`。这确实解决了实例化对象的问题，但并没有使它有效。我们现在隐式地创建了对数据存储的依赖，因为我们需要首先持久化实体，并创建一个具有实际 ID 的新实例。这需要在我们可以在应用程序中进一步使用它之前完成。

问题是，虽然这是个错误，但这是我在处理实体时见过的最常见的实现。我也是这样做的。不过，我最近发现了另一种处理完全有效的实体的方法，不需要在应用程序中使用它们之前将它们保存在数据存储中。

诀窍是在应用程序级别放弃使用数据存储中内部生成的顺序 id，代之以随机的、唯一可识别的 id，比如 UUIDs。使用 UUIDs，我们可以生成惟一的 id，并立即拥有完全有效的实体实例。这也将消除对数据存储的硬性依赖。

我们可以节省对象实例化的时间，因为我们不再需要在持久化时重新创建实体类，因为可能没有新的属性要获取。而在以前，我们需要这样做来从数据存储中填充 ID。实体的持久性成为实现细节。

*感谢阅读！敬请关注更多内容。*