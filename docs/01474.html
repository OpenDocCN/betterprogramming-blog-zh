<html>
<head>
<title>The Power of React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩子的力量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-react-hooks-7584df3af9fe?source=collection_archive---------2-----------------------#2019-09-16">https://betterprogramming.pub/the-power-of-react-hooks-7584df3af9fe?source=collection_archive---------2-----------------------#2019-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="90ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">仅使用React的这一新功能创建应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9948da97f4231b48ad5bf914218ae321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_noMNoZ-JibgoY0gfEbrw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">Blake Connally在Unsplash上拍摄的照片</em></p></figure><p id="3e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae lv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"><em class="lw">React</em></a><em class="lw"/><a class="ae lv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"><em class="lw">Hooks</em></a>是React库的新成员，已经席卷了React开发者。钩子允许你编写状态逻辑和使用其他React特性，而不必编写一个<a class="ae lv" href="https://reactjs.org/docs/components-and-props.html#function-and-class-components" rel="noopener ugc nofollow" target="_blank">类组件</a>。你可以单独使用钩子来开发自己的应用程序，这对于React团队中的任何人来说都是一个巨大的转变。</p><p id="a54a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将构建一个应用程序，我称之为“Slotify”，只使用React钩子。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="86ac" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">Slotify是做什么的，怎么做的？</h1><p id="57d8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">Slotify将提供一个用户界面，该界面提供一个<code class="fe nb nc nd ne b"><a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea" rel="noopener ugc nofollow" target="_blank">textarea</a></code>来将引用插入到任何博客文章中。换行符(<code class="fe nb nc nd ne b">\n</code>)和字数会在数量上起作用。一个“槽化”的帖子最少一个，最多三个引号。</p><p id="8278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要有<em class="lw">槽</em>可用，就可以插入报价。用户将能够与插槽和类型或粘贴在报价和他们选择的作者属性互动。当他们完成后，他们可以点击保存按钮，博客文章将重新加载，现在包括他们的报价。</p><p id="562e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是我们将使用的Hooks APIs基本上，它们都是:</p><ul class=""><li id="e232" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe nb nc nd ne b"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">React.useState</a></code></li><li id="eb4d" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nb nc nd ne b"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">React.useEffect</a></code></li><li id="d526" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nb nc nd ne b"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">React.useRef</a></code></li><li id="a304" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nb nc nd ne b"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">React.useReducer</a></code></li><li id="256c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nb nc nd ne b"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">React.useCallback</a></code></li><li id="224e" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nb nc nd ne b"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">React.useMemo</a></code></li><li id="655f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nb nc nd ne b"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank">React.useImperativeHandle</a></code></li><li id="dfcb" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nb nc nd ne b"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank">React.useLayoutEffect</a></code></li><li id="5ce4" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nb nc nd ne b">useSlotify</code>(风俗)</li></ul><p id="eed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们将要构建的:(将一篇博文转换成带有样式化引用的博文，并返回包含样式的博文的HTML源代码)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/1eb57be06d43771771ea3a9cb52f2f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/0*iu5ws0R7gOPEeHWL.gif"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="6a62" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">我们开始吧</h1><p id="3402" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在本教程中，我们将使用<code class="fe nb nc nd ne b">create-react-app</code>快速生成一个React项目；GitHub库<a class="ae lv" href="https://github.com/jsmanifest/build-with-hooks" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="c808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续使用下面的命令创建一个项目。对于本教程，我们称我们的项目为<code class="fe nb nc nd ne b">build-with-hooks</code>。</p><pre class="kj kk kl km gt nu ne nv nw aw nx bi"><span id="d9f6" class="ny mf it ne b gy nz oa l ob oc">npx create-react-app build-with-hooks</span></pre><p id="03f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，现在进入目录:</p><pre class="kj kk kl km gt nu ne nv nw aw nx bi"><span id="995a" class="ny mf it ne b gy nz oa l ob oc">cd build-with-hooks</span></pre><p id="16f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将稍微清理一下主条目<code class="fe nb nc nd ne b">src/index.js</code>，这样我们就可以专注于<code class="fe nb nc nd ne b">App</code>组件:<code class="fe nb nc nd ne b">src/index.js</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe nb nc nd ne b">src/App.js</code>让我们从什么都不渲染开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将制作一个开始按钮。然后，我们将为用户创建<code class="fe nb nc nd ne b">textarea</code>元素来插入内容:<code class="fe nb nc nd ne b">src/Button.js</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nb nc nd ne b">index.css</code>内部，我们将应用一些样式，以便每个<code class="fe nb nc nd ne b">button</code>都有相同的样式:<code class="fe nb nc nd ne b">src/index.css</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续创建<code class="fe nb nc nd ne b">textarea</code>组件。我们就叫它<code class="fe nb nc nd ne b">PasteBin </code> ( <code class="fe nb nc nd ne b">src/PasteBin.js</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用内联样式，因为我们希望在生成最终内容时包含这些样式。如果我们使用纯CSS，只会生成类名字符串，所以组件会变得没有风格。</p><p id="f357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个React <a class="ae lv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>来从顶部包装整个事情，以便我们强制所有子组件与其余组件保持同步。我们将通过使用<code class="fe nb nc nd ne b"><a class="ae lv" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">React.useContext</a></code>来做到这一点。</p><p id="a888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个<code class="fe nb nc nd ne b">Context.js</code>文件(<code class="fe nb nc nd ne b">src/Context.js</code>):</p><pre class="kj kk kl km gt nu ne nv nw aw nx bi"><span id="4e67" class="ny mf it ne b gy nz oa l ob oc">import React from 'react'</span><span id="fc77" class="ny mf it ne b gy of oa l ob oc">const Context = React.createContext()</span><span id="0338" class="ny mf it ne b gy of oa l ob oc">export default Context</span></pre><p id="e31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将创建<code class="fe nb nc nd ne b">Provider.js</code>，它将导入<code class="fe nb nc nd ne b">Context.js</code>，并将所有逻辑保持在管理状态(<code class="fe nb nc nd ne b">src/Provider.js</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e21f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这最后一段代码非常重要。我们本来可以使用<code class="fe nb nc nd ne b">React.useState</code>来管理我们的状态，但是当你考虑我们的应用程序将要做什么时，你可能会意识到它不仅仅是一个单一的状态。这是因为需要考虑双方的情况:</p><ol class=""><li id="210e" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu og nl nm nn bi translated">用户什么时候想把他们的博客文章分槽？</li><li id="2ed0" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated">我们应该何时向他们展示最终的翻新内容？</li><li id="736b" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated">我们应该在博文中插入几个槽？</li><li id="fe06" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated">我们应该何时显示或隐藏插槽？</li></ol><p id="cec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">知道了这一点，我们应该使用<code class="fe nb nc nd ne b">React.useReducer</code>来设计我们的状态，以便将状态更新逻辑封装到一个单独的位置。我们的第一个动作是通过添加第一个可通过调度类型为<code class="fe nb nc nd ne b">'set-slotified-content'</code>的动作访问的开关用例来声明的。</p><p id="5a91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在博客文章中插入槽的方法是获取一个字符串，并将其转换为一个数组，用换行符<code class="fe nb nc nd ne b">'\n'</code>对其进行分隔。这就是为什么初始状态声明<code class="fe nb nc nd ne b">slotifiedContent</code>为数组；因为那是我们存放工作数据的地方。</p><p id="cbb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还看到声明了一个<code class="fe nb nc nd ne b">textareaRef</code>,因为我们需要使用它来获取对我们之前创建的<code class="fe nb nc nd ne b">PasteBin</code>组件的引用。我们本可以让<code class="fe nb nc nd ne b">textarea</code>完全由<a class="ae lv" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">控制</a>，但是与它沟通的最简单和最有效的方式是获取对根<code class="fe nb nc nd ne b">textarea</code>元素的引用。我们真正需要做的是获取它的值，而不是设置状态。这将在稍后使用<code class="fe nb nc nd ne b">textarea</code>上的<code class="fe nb nc nd ne b">ref</code>支柱来抓取。</p><p id="1232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nb nc nd ne b">slotify</code>函数在用户按下开始引用按钮来将他们的博客文章归档时被调用。目的是弹出一个模式，并向他们显示可以输入报价的位置。我们使用对<code class="fe nb nc nd ne b">PasteBin</code>组件的引用来获取<code class="fe nb nc nd ne b">textarea</code>的当前值，并将内容迁移到模态。</p><p id="c88d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用两个实用函数，<code class="fe nb nc nd ne b">attachSlots</code>和<code class="fe nb nc nd ne b">split</code>来对博客文章进行开槽，并使用它们来设置<code class="fe nb nc nd ne b">state.slotifiedContent</code>，以便我们的UI可以拾取它。</p><p id="9c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe nb nc nd ne b">attachSlots</code>和<code class="fe nb nc nd ne b">split</code>放入一个<code class="fe nb nc nd ne b">utils.js</code>文件(<code class="fe nb nc nd ne b">src/utils.js</code>)如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="80ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将<code class="fe nb nc nd ne b">textareaRef</code>应用到<code class="fe nb nc nd ne b">PasteBin</code>，我们必须使用<code class="fe nb nc nd ne b">React.useContext</code>来获得我们之前在<code class="fe nb nc nd ne b">useSlotify </code> ( <code class="fe nb nc nd ne b">src/PasteBin.js</code>)中声明的<code class="fe nb nc nd ne b">React.useRef</code>钩子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="32ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们缺少的最后一样东西是<code class="fe nb nc nd ne b">&lt;Slot /&gt;</code>组件，因为我们在上下文中使用了它。这个<code class="fe nb nc nd ne b">slot</code>组件接受来自用户的报价。用户不会马上看到它，因为我们将把它放在模态组件中，只有当用户单击开始报价按钮时，它才会打开。</p><p id="e5c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe nb nc nd ne b">slot</code>组件可能有点难，但是我会在后面解释发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件最重要的部分是<code class="fe nb nc nd ne b">state.drafting</code>。我们还没有在上下文中声明这一点，但它的目的是给我们一种方法来知道何时向用户显示插槽，以及何时向他们显示最终输出。当<code class="fe nb nc nd ne b">state.drafting</code>为<code class="fe nb nc nd ne b">true</code>(这将是默认值)时，我们将向他们展示可以插入报价的插槽。当他们点击保存按钮时，<code class="fe nb nc nd ne b">state.drafting</code>将切换到<code class="fe nb nc nd ne b">false</code>，我们将使用它来确定他们想要查看他们的最终输出。</p><p id="d55a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们声明了一个默认值为<code class="fe nb nc nd ne b">'textfield'</code>的<code class="fe nb nc nd ne b">input</code>参数，因为将来我们可能想要使用除了输入之外的其他输入类型(例如:文件输入，我们可以让他们上传图片作为引用，等等。).对于本教程，我们将只支持<code class="fe nb nc nd ne b">'textfield'</code>。</p><p id="8dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以当<code class="fe nb nc nd ne b">state.drafting</code>为<code class="fe nb nc nd ne b">true</code>时，<code class="fe nb nc nd ne b">&lt;SlotDrafting /&gt;</code>被<code class="fe nb nc nd ne b">Slot</code>使用，当<code class="fe nb nc nd ne b">false</code>时，<code class="fe nb nc nd ne b">&lt;SlotStatic /&gt;</code>被使用。最好将这种区别分成组件，这样我们就不会用一堆<code class="fe nb nc nd ne b">if/else</code>条件来膨胀组件。</p><p id="ff30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，尽管我们为报价输入字段声明了一些内联样式，但是我们仍然应用了<code class="fe nb nc nd ne b">className={styles.slotQuoteInput}</code>以便我们可以样式化占位符，因为我们不能使用内联样式来这样做。(这对于最终的翻新内容来说是可以的，因为甚至不会生成输入。)</p><p id="5e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe nb nc nd ne b">src/styles.module.css</code>的CSS:</p><pre class="kj kk kl km gt nu ne nv nw aw nx bi"><span id="25c1" class="ny mf it ne b gy nz oa l ob oc">.slotQuoteInput::placeholder {<br/>  color: #fff;<br/>  font-size: 0.9rem;<br/>}</span></pre><p id="ba83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回过头来向上下文<code class="fe nb nc nd ne b">src/Provider.js</code>声明<code class="fe nb nc nd ne b">drafting</code>状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="105b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们把它放到<code class="fe nb nc nd ne b">App.js</code>组件中，这样我们就可以看到目前为止它是什么样子了。</p><p id="decf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(注意:在这个例子中，我使用了来自<code class="fe nb nc nd ne b">semantic-ui-react</code>的模态组件，它不是模态所必需的。您可以使用任何模型，或者使用React <a class="ae lv" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">门户</a> API创建自己的普通模型。下面是<code class="fe nb nc nd ne b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b7e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在启动我们的服务器之前，我们需要声明模态状态(<code class="fe nb nc nd ne b">open/closed</code>):</p><p id="881f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> src/Provider.js </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们目前应该有的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/284acfee33c55201de5e0ca1606ce4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/0*PjenMpo28NDcXLbh.gif"/></div></figure><p id="f1d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(注意:保存按钮关闭了图像中的模态，但这是一个小错误。它不应该关闭模态。)</p><p id="008e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将对<code class="fe nb nc nd ne b">PasteBin</code>做一点修改，为<code class="fe nb nc nd ne b">textarea</code>声明一个使用<code class="fe nb nc nd ne b">React.useImperativeHandle</code>的新API，这样我们就可以在<code class="fe nb nc nd ne b">useSlotify</code>中使用它。我们不会用一堆函数来膨胀钩子；相反，我们将提供一个封装的API ( <code class="fe nb nc nd ne b">src/PasteBin.js</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="03ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">textareaUtils</code>也将是一个<code class="fe nb nc nd ne b">React.useRef</code>，它将紧挨着<code class="fe nb nc nd ne b">textareaRef</code>放置在<code class="fe nb nc nd ne b">useSlotify</code>钩中；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在<code class="fe nb nc nd ne b">slotify</code>函数(<code class="fe nb nc nd ne b">src/Provider.js</code> ) <strong class="lb iu"> : </strong>中使用这个新的API</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户正在查看这些位置时，我们发现他们还没有插入作者属性，我们希望闪现该元素以引起他们的注意。</p><p id="d02e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将在<code class="fe nb nc nd ne b">SlotDrafting</code>组件中使用<code class="fe nb nc nd ne b">React.useLayoutEffect</code>，因为<code class="fe nb nc nd ne b">SlotDrafting</code>包含作者输入(<code class="fe nb nc nd ne b">src/Slot.js</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这里大概不需要<code class="fe nb nc nd ne b">useLayoutEffect</code>，只是为了演示。众所周知，这是样式更新的一个好选择，因为钩子是在安装了<code class="fe nb nc nd ne b">dom</code>并更新了它的变体之后调用的。它对样式有好处的原因是因为它在下一次浏览器重画之前被调用，而<code class="fe nb nc nd ne b">useEffect</code>钩子是在之后被调用的——这可能会在UI中造成迟钝、浮华的效果。风格。现在，<code class="fe nb nc nd ne b">src/styles.module.css</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在模态的底部，我们放了一个<code class="fe nb nc nd ne b">SAVE</code>按钮，它将从<code class="fe nb nc nd ne b">useSlotify</code>调用<code class="fe nb nc nd ne b">onSave</code>。当用户点击时，插槽将转换为最终插槽(当<code class="fe nb nc nd ne b">drafting === false</code>时)。我们还将在附近呈现一个按钮，将HTML中的源代码复制到用户的剪贴板，以便他们可以将内容粘贴到他们的博客帖子中。</p><p id="71b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都将保持不变，除了现在我们将使用CSS类名。新的CSS类名以<code class="fe nb nc nd ne b">Static</code>为后缀，表示它们在<code class="fe nb nc nd ne b">drafting === false</code>时使用。这里对<code class="fe nb nc nd ne b">Slot</code>组件做了一点小小的改动，以适应CSS的变化(<code class="fe nb nc nd ne b">src/Slot.js</code> ) <strong class="lb iu"> : </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0d74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是新添加的CSS样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的应用程序现在的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9dcbfc32be5322cfe17f03c0946a7b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/0*TmnOll7_BWupH0ph.gif"/></div></figure><p id="0e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的最后一件事是添加一个关闭按钮来关闭modal，并添加一个复制按钮来复制最终博客文章的源代码。</p><p id="40fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加关闭按钮很容易。只需在保存按钮旁边添加这个按钮。复制按钮将放在关闭按钮旁边。这些按钮将被赋予一些<code class="fe nb nc nd ne b">onClick</code>处理程序(<code class="fe nb nc nd ne b">src/App.js</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来我们应该在实现<code class="fe nb nc nd ne b">onCopyFinalContent</code>函数的时候就完成了——但是我们没有。我们遗漏了最后一步。当我们复制最终确定的内容时，我们复制的是UI的哪一部分？我们不能复制整个模态，因为我们不想在我们的博客文章中使用保存、关闭和复制按钮；看起来会非常尴尬。我们必须制作另一个<code class="fe nb nc nd ne b">React.useRef</code>并使用它来附加到一个只包含我们想要的内容的特定元素。</p><p id="7013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们使用内联样式，而不完全是CSS类；因为我们希望翻新版包含这些款式。</p><p id="c28d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nb nc nd ne b">useSlotify</code>中声明<code class="fe nb nc nd ne b">modalRef</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="67bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将其附加到只包含内容的元素(<code class="fe nb nc nd ne b">src/App.js</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们用一个<code class="fe nb nc nd ne b">React.useCallback </code>包装了<code class="fe nb nc nd ne b">ModalContent</code>，因为我们希望引用保持不变。如果我们不这样做，那么组件将被重新呈现，所有的引用/作者值将被重置，因为<code class="fe nb nc nd ne b">onSave</code>函数更新了状态。当状态更新时，<code class="fe nb nc nd ne b">ModalContent</code>会重新创建自己，产生一个新的空状态，这是我们<strong class="lb iu">不想要的。</strong></p><p id="6951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nb nc nd ne b">onCopyFinalDraft</code>将被放置在<code class="fe nb nc nd ne b">useSlotify</code>钩子内，钩子将使用<code class="fe nb nc nd ne b">modalRef</code> ref ( <code class="fe nb nc nd ne b">src/Provider.js</code> ) <strong class="lb iu"> : </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="70e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们结束了！</p><p id="3241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a2d8e9bac45f874e564363ac71a3c246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/0*XZgMt7hMScaE8BZ4.gif"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="17e3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="62d8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我希望这篇文章对你有用，并期待将来有更多的发现！</p></div></div>    
</body>
</html>