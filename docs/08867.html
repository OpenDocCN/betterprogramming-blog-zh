<html>
<head>
<title>Want to Write Clean Code? Make It S.O.L.I.D!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想写干净的代码？让它成为神盾局！</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/want-to-write-clean-code-make-it-s-o-l-i-d-26bbedba31a0?source=collection_archive---------6-----------------------#2021-06-21">https://betterprogramming.pub/want-to-write-clean-code-make-it-s-o-l-i-d-26bbedba31a0?source=collection_archive---------6-----------------------#2021-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d6aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写功能性的、可重用的、干净的代码的简单原则</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b40bef663a36269a17bc3e2965c1d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CJS65Z7bW9tDeL4x"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@enginakyurt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Engin Akyurt </a>拍摄的照片</p></figure><blockquote class="kz"><p id="8e4b" class="la lb it bd lc ld le lf lg lh li lj dk translated">代码就像幽默。当你不得不解释它的时候，它是糟糕的。</p><p id="0e79" class="la lb it bd lc ld lk ll lm ln lo lj dk translated">—科里屋</p></blockquote><p id="bc8e" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj lj im bi translated">作为软件工程师，我们必须牢记的一件重要事情是，我们编写的代码将被其他人看到，他们可能希望在我们所创建的基础上进行构建。请不要让他们的生活更加艰难！</p><p id="676c" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">如果您希望您的代码在将来尽可能多地被使用和重用，并且只需要最小的更改，那么您需要编写简洁的代码:</p><ul class=""><li id="1a3e" class="mp mq it lr b ls mk lv ml ly mr mc ms mg mt lj mu mv mw mx bi translated">很容易理解</li><li id="26d1" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">很容易发现漏洞</li><li id="431c" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">编辑起来很舒服</li></ul><p id="d8d3" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">当设计一个系统时，这是通过将许多模块组合在一起完成的。</p><p id="db45" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">把一个复杂的设计系统想象成一个拼图。模块是拼图块，拼图中的每一块都有且只有一个位置，与特定形状的拼图相连，不能在任何其他位置。</p><p id="e7c1" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">另一方面，设计良好的系统应该更像乐高积木。任何两块乐高积木都可以毫不费力地连接在一起——所有的乐高积木都是兼容的。</p><p id="0c97" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">在设计一个软件系统的时候，你想把它做得像乐高一样。您希望能够轻松地将模块连接在一起，重用它们，并且仍然了解每个模块在未来的用途。</p><p id="f6a7" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">这就是为什么找到一种评估设计复杂性的方法真的很重要——它将帮助你更好地应用面向对象的设计原则，并构建可控的系统。</p><p id="5541" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">任何软件的开发都有两个相关的评估概念:<em class="nd">耦合</em>和<em class="nd">内聚。</em></p><h2 id="ecd3" class="ne nf it bd ng nh ni dn nj nk nl dp nm ly nn no np mc nq nr ns mg nt nu nv nw bi translated"><strong class="ak">联轴器</strong></h2><p id="0a23" class="pw-post-body-paragraph lp lq it lr b ls nx ju lu lv ny jx lx ly nz ma mb mc oa me mf mg ob mi mj lj im bi translated">关注一个模块和其他模块之间的复杂性。模块的耦合捕获了模块之间和模块之间连接的<em class="nd">复杂性。</em></p><p id="1557" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">如果这些模块强烈地相互依赖，那么这个模块就是所谓的<em class="nd">紧耦合</em> <strong class="lr iu"> </strong>模块——这就像拼图。如果一个模块不强烈依赖于其他模块，并且发现很容易连接到其他模块，那么这个模块就<em class="nd">松散耦合</em> <strong class="lr iu"> </strong>到其他模块——这就像乐高。</p><p id="6fac" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">耦合是通过模块间关系的数量来衡量的。也就是说，随着模块间调用次数的增加或共享数据量的增加，耦合度也会增加。所以，从逻辑上讲，高耦合的设计会有更多的错误。</p><h2 id="00e1" class="ne nf it bd ng nh ni dn nj nk nl dp nm ly nn no np mc nq nr ns mg nt nu nv nw bi translated"><strong class="ak">衔接</strong></h2><p id="e8e5" class="pw-post-body-paragraph lp lq it lr b ls nx ju lu lv ny jx lx ly nz ma mb mc oa me mf mg ob mi mj lj im bi translated">关注模块内部的复杂性。它测量给定模块中各功能之间的关系强度。</p><p id="7bea" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">如果一个模块有明确的目的，并且执行一个且只有一个任务，这意味着这个模块有<em class="nd">高内聚。</em>另一方面，如果模块试图执行一个以上的任务，并且封装一个以上的目的，那么这个模块就有<em class="nd">低内聚</em>。</p><p id="251a" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">最佳实践表明，如果模块有不止一个职责，那么可能是时候将模块的职责分开了。</p><p id="b4ef" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">您希望您的模块具有低耦合性或松散耦合性，而不是紧密耦合性，并且具有高内聚性。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="0518" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">因此，面向对象编程包含了帮助您理解特定设计模式和软件架构需求的原则。</p><p id="6a02" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">在面向对象编程的世界里，有许多设计规则、模式和原则。这些原则中的五条通常被归为一类，称为S.O.L.I.D原则——由<a class="ae ky" href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin" rel="noopener ugc nofollow" target="_blank">罗伯特·c·马丁(鲍勃叔叔)</a>定义的规则。</p><p id="0384" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">坚实的原则告诉我们如何将函数和数据结构组织成类，以及这些类应该如何一起工作。</p><h1 id="ab22" class="oj nf it bd ng ok ol om nj on oo op nm jz oq ka np kc or kd ns kf os kg nv ot bi translated">什么是神盾局？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/0a3aa4c622c2fc413ed961264d672987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7gKl65NKfSGzubKl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hnhmarketing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨特·哈利</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><ul class=""><li id="0ac5" class="mp mq it lr b ls mk lv ml ly mr mc ms mg mt lj mu mv mw mx bi translated">单一责任原则。(SRP)</li><li id="4d69" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">o:开闭原则。(铬)</li><li id="bef2" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">l:利斯科夫替代原理。(LSP)</li><li id="2fcd" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">I:界面分离原理。(ISP)</li><li id="dc7a" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">d:依存倒置原则。(蘸)</li></ul><p id="7e7e" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">再来多讲讲每个原理。</p><h1 id="d6ac" class="oj nf it bd ng ok ol om nj on oo op nm jz oq ka np kc or kd ns kf os kg nv ot bi translated">单一责任原则</h1><blockquote class="ov ow ox"><p id="83ce" class="lp lq nd lr b ls mk ju lu lv ml jx lx oy mm ma mb oz mn me mf pa mo mi mj lj im bi translated">一个类应该只有一个责任。</p></blockquote><p id="a28c" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">这个原则说，类应该只有一个明确的工作和一个责任。</p><h2 id="5943" class="ne nf it bd ng nh ni dn nj nk nl dp nm ly nn no np mc nq nr ns mg nt nu nv nw bi translated"><strong class="ak">但是什么是责任呢？</strong></h2><p id="243a" class="pw-post-body-paragraph lp lq it lr b ls nx ju lu lv ny jx lx ly nz ma mb mc oa me mf mg ob mi mj lj im bi translated">一个类必须被改变的原因应该只有一个。</p><p id="5684" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">你的类的职责越多，你就越需要经常改变它。</p><p id="06c5" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">在你做出任何改变之前，你需要问一个简单的问题:“你的班级的职责是什么？”</p><p id="7058" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">如果你的答案中包含“和”这个词，你很可能违反了单一责任原则。</p><p id="ff43" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">用一个例子就能很好地理解原理。想象一个执行以下操作的类雇员:</p><ul class=""><li id="4a55" class="mp mq it lr b ls mk lv ml ly mr mc ms mg mt lj mu mv mw mx bi translated">计算付款。</li><li id="f52b" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">提交报告。</li><li id="6b64" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">将数据保存在数据库中。</li></ul><p id="b25d" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">在这里，类有多重责任，有太多不同的理由改变。因此，它不符合单一责任原则。</p><p id="1b56" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">为了应用单一责任原则，你需要将不同的责任分成不同的类别。</p><p id="5dec" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">这一原则使软件更容易实现，防止未来变化后的意外副作用，并减少耦合。</p><p id="393d" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated"><em class="nd">注意:这个原则不仅适用于类，也适用于软件组件和微服务。</em></p><h1 id="3133" class="oj nf it bd ng ok ol om nj on oo op nm jz oq ka np kc or kd ns kf os kg nv ot bi translated">o:开闭原则(CR)</h1><blockquote class="ov ow ox"><p id="35da" class="lp lq nd lr b ls mk ju lu lv ml jx lx oy mm ma mb oz mn me mf pa mo mi mj lj im bi translated">软件实体(类、模块、功能)应该对扩展开放，但对修改关闭。</p></blockquote><p id="5f1a" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">Robert C. Martin认为这个原则是“面向对象设计最重要的原则”</p><p id="0d79" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">需求会随着时间而变化。开闭原则的目标是编写不必在每次需求变化时都要改变的代码。</p><p id="a78b" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated"><em class="nd">我们如何在不改变模块本身的情况下改变模块的功能？</em></p><p id="8b60" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">开闭原则指出，如果需求发生变化，这些变化应该通过添加新代码来实现，而不是通过更改已经工作的旧代码来实现。</p><h2 id="ab6f" class="ne nf it bd ng nh ni dn nj nk nl dp nm ly nn no np mc nq nr ns mg nt nu nv nw bi translated"><strong class="ak">抽象是关键</strong></h2><p id="6b29" class="pw-post-body-paragraph lp lq it lr b ls nx ju lu lv ny jx lx ly nz ma mb mc oa me mf mg ob mi mj lj im bi translated">一个模块操纵一个抽象是可能的。该模块可以关闭进行修改，因为它依赖于一个固定的抽象。并且可以通过创建抽象的新衍生物来扩展模块的行为。</p><p id="bbca" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">这个原则使您能够编写健壮的、可维护的和可重用的软件组件。</p><p id="8116" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">开闭原则说:永远不要重写代码。</p><h1 id="d874" class="oj nf it bd ng ok ol om nj on oo op nm jz oq ka np kc or kd ns kf os kg nv ot bi translated">l:利斯科夫替代原理。(LSP)</h1><blockquote class="ov ow ox"><p id="f23b" class="lp lq nd lr b ls mk ju lu lv ml jx lx oy mm ma mb oz mn me mf pa mo mi mj lj im bi translated">基本类型必须可由其子类型替换</p></blockquote><p id="9893" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">这个原则定义了一个子类的对象必须可以替换其超类的对象，而不会破坏应用程序。</p><p id="22d2" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">这就要求子类的对象有和它们的超类相同的行为，如果一个超类能做一件事，那么子类也必须能做和它的超类一样的事。</p><p id="9f63" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">利斯科夫替代原理与遗传密切相关。它通过关注超类及其子类型的行为扩展了开闭原则。</p><p id="03db" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated"><em class="nd">举个例子就能很好的理解原理。</em></p><p id="477e" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">假设有一个类<code class="fe pb pc pd pe b">Animal</code>执行以下操作:</p><ul class=""><li id="e9b3" class="mp mq it lr b ls mk lv ml ly mr mc ms mg mt lj mu mv mw mx bi translated"><code class="fe pb pc pd pe b">Speak</code></li><li id="1db6" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated"><code class="fe pb pc pd pe b">Eat</code></li><li id="d5d3" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated"><code class="fe pb pc pd pe b">Walk</code></li></ul><p id="6fa7" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">我们有子类<code class="fe pb pc pd pe b">cat</code>，是动物，继承了超类<code class="fe pb pc pd pe b">Animal</code>，有它的行为，说话，吃饭，走路。因此，这适用利斯科夫替代原则。</p><p id="85d8" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">但是假设有一个子类<code class="fe pb pc pd pe b">snail</code>，它仍然是动物，但是不能说话，所以它不能继承超类<code class="fe pb pc pd pe b">Animal</code>。这打破了利斯科夫替代原理。</p><p id="212f" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">总而言之，如果你说的关于父类型的事情是真的，那么它在整个链中都必须是真的。如果您声明父类型可以做一些事情，那么所有子类型也需要能够做这些事情。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="2044" class="oj nf it bd ng ok pf om nj on pg op nm jz ph ka np kc pi kd ns kf pj kg nv ot bi translated">I:界面分离原理。(ISP)</h1><blockquote class="ov ow ox"><p id="2e37" class="lp lq nd lr b ls mk ju lu lv ml jx lx oy mm ma mb oz mn me mf pa mo mi mj lj im bi translated">不应该强迫客户依赖他们不使用的接口。</p></blockquote><p id="8d68" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">根据接口分离原则，客户永远不应该被迫实现他们不需要或对他们不重要的方法。</p><p id="f78a" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">这意味着小的特定接口比大的接口更好。</p><p id="50c3" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">分离=分裂</p><p id="52b9" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">因此，接口分离原则意味着将你的接口分成更小的部分。</p><p id="77a0" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated"><em class="nd">举个例子就能很好的理解原理。</em></p><p id="c2d1" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">假设您有一个类<code class="fe pb pc pd pe b">Restaurant interface</code>，它执行以下操作:</p><ul class=""><li id="388a" class="mp mq it lr b ls mk lv ml ly mr mc ms mg mt lj mu mv mw mx bi translated"><code class="fe pb pc pd pe b">Pay Online</code></li><li id="130e" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated"><code class="fe pb pc pd pe b">Order Online</code></li><li id="f51b" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated"><code class="fe pb pc pd pe b">Pay in Person</code></li><li id="2801" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated"><code class="fe pb pc pd pe b">Order in person</code></li></ul><p id="9179" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated"><code class="fe pb pc pd pe b">Restaurant</code>接口定义了四种方法:<code class="fe pb pc pd pe b">online payment</code>、<code class="fe pb pc pd pe b">in-person payment</code>、<code class="fe pb pc pd pe b">online order</code>、<code class="fe pb pc pd pe b">in-person order</code>。</p><p id="2ea4" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">我们有两个子类:</p><ul class=""><li id="8906" class="mp mq it lr b ls mk lv ml ly mr mc ms mg mt lj mu mv mw mx bi translated">在线客户端</li><li id="e9dc" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">面对面的客户</li></ul><p id="2806" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">由于这四个方法是<code class="fe pb pc pd pe b">Restaurant</code>接口的一部分，任何子类都必须实现这四个方法。但是由于子类<code class="fe pb pc pd pe b">Online Client</code>不需要实现<code class="fe pb pc pd pe b">Pay in Person</code>或者<code class="fe pb pc pd pe b">Order in person</code>，所以即使它不需要，也会被强制使用这些方法。</p><p id="bfa3" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">此处的<code class="fe pb pc pd pe b">Restaurant</code>接口打破了接口分离原则和单一责任原则，因为不同的支付方式被分组到单一接口中。</p><p id="04d1" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">为了克服这个问题，我们需要将支付和订单功能分成两个独立的类:<code class="fe pb pc pd pe b">Payment</code>接口和<code class="fe pb pc pd pe b">order</code>接口。</p><p id="efba" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">每个客户端分别使用<code class="fe pb pc pd pe b">Payment interface</code>和<code class="fe pb pc pd pe b">Order interface</code>的一个实现。比如<code class="fe pb pc pd pe b">Online Client</code>会用<code class="fe pb pc pd pe b">Online Payment</code>和<code class="fe pb pc pd pe b">Online Order</code>。</p><p id="9335" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">接口分离原则有助于保持类和接口的清晰、紧凑和切题。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="8373" class="oj nf it bd ng ok pf om nj on pg op nm jz ph ka np kc pi kd ns kf pj kg nv ot bi translated">d:依存倒置原则。(蘸)</h1><blockquote class="ov ow ox"><p id="0b84" class="lp lq nd lr b ls mk ju lu lv ml jx lx oy mm ma mb oz mn me mf pa mo mi mj lj im bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</p></blockquote><p id="3be8" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">这个原则声明高级模块不应该依赖于低级模块，但是两者都应该依赖于抽象。</p><p id="9167" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">抽象不应该依赖于细节，但是细节应该依赖于抽象。</p><p id="0e43" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">这与开闭原则和利斯科夫替换原则密切相关，因为它们都依赖于接口。</p><p id="2015" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">用一个例子就可以很好地理解这个原理。</p><p id="d8c9" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">电脑鼠标有很多种。现在，假设每台计算机只使用特定类型的鼠标。您必须购买您的计算机系统支持的确切类型的鼠标。在这种情况下，如果您的电脑只能使用无线鼠标，那么有线或轨迹球鼠标或任何其他类型的鼠标都不能在您的电脑上使用。幸运的是，它不是这样工作的，因为计算机不依赖于特定的鼠标端口或类型。无论你的鼠标是什么类型，它都有一个通用的界面(至少有两个按钮和移动屏幕指针的能力)。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="0726" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">关键点:</p><ul class=""><li id="f12c" class="mp mq it lr b ls mk lv ml ly mr mc ms mg mt lj mu mv mw mx bi translated">为了挽救团队的生命，最好编写可读性强、可重用且切中要点的代码。</li><li id="b7ef" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">坚实的原则是编写更好代码的OOP规则。</li><li id="67e7" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">固体的五个原则服务于同一点。</li></ul></div></div>    
</body>
</html>