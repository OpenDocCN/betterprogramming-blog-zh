<html>
<head>
<title>Why Use Redux When We Have the Context API?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">既然有了上下文API，为什么还要使用Redux呢？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-use-redux-when-we-have-context-api-95be70581148?source=collection_archive---------1-----------------------#2020-09-27">https://betterprogramming.pub/why-use-redux-when-we-have-context-api-95be70581148?source=collection_archive---------1-----------------------#2020-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">哪个状态管理解决方案适合您的项目？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/222f1c39e47b8b277bc7d4c76defd779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFWe0OgadLpTNk7Hvmv6_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="f8fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>这个问题的简单答案是“是的，因为它有助于我们的国家管理。”这没有错，但是我们有别的选择吗？</p><p id="b851" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，我们有。作为一名JavaScript开发人员，我逐渐明白我们不满足于一件事。我们需要替代方案。这就是React 16.4为我们提供<a class="ae lu" href="https://reactjs.org/docs/context.html#api" rel="noopener ugc nofollow" target="_blank">上下文API </a>的原因。</p><p id="464c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将帮助您理解和回答关于状态管理的最常见问题:</p><ul class=""><li id="0b2f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">为什么不能直接用道具来管理状态(道具链)？</li><li id="34ac" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Redux是什么，我们为什么要用它？</li><li id="ac60" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">我们如何为我们的应用程序配置Redux？</li><li id="ece3" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">什么是上下文API？</li><li id="b4f5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">我们如何使用钩子来配置上下文API？</li><li id="fadd" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">最后，哪个选项更好？</li></ul><p id="e1be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mj">注意:如果你已经知道Redux是如何工作的，什么是道具链，你可以跳到上下文API部分。</em></p><p id="875d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将从一个演示应用程序开始，它将只显示多个用户以及他们的姓名和身份验证状态。为此，我们将有三个主要组件:应用程序组件、用户组件和用户组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/b350e962f3ba9cd79f215150688c3191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vpck49nPXvFOMWgWayeJ-w.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="632f" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated"><strong class="ak"> App组件</strong></h1><p id="d09b" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">这个组件(容器)将可以访问状态。我们的状态将有几样东西:一个<code class="fe np nq nr ns b">users</code>数组和另一个用于<code class="fe np nq nr ns b">authentication</code>的布尔字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cee8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将有一个<strong class="la iu"> </strong>登录用户按钮在我们的<code class="fe np nq nr ns b">App.js</code>里面。点击后，将登录所有用户(将其身份验证状态更改为<code class="fe np nq nr ns b">true</code>)。然后，我们将通过道具将用户和<code class="fe np nq nr ns b">isAuthenticated </code>标志传递给<code class="fe np nq nr ns b">Users.js</code>。</p><p id="2d4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的应用程序组件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="021b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated"><strong class="ak">用户组件</strong></h1><p id="19bd" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">这个组件将是一个无状态组件。这里，我们将只映射来自<code class="fe np nq nr ns b">App.js</code>的用户，并将值作为道具传递给<code class="fe np nq nr ns b">User.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="2b01" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated"><strong class="ak">用户组件</strong></h1><p id="cfbd" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated"><code class="fe np nq nr ns b">User.js</code>仅显示作为道具从<code class="fe np nq nr ns b">Users.js</code>接收的数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="85f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个非常基础的应用。现在，当我们按下Login User按钮时，我们将所有三个用户的身份验证状态更改为<code class="fe np nq nr ns b">true</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d48b48e4eb00abe852a316e55a07a202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AhRAWch2fhT73e6pL0OBg.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="452d" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">那么这个App到底是什么问题呢？</h1><p id="7723" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">好吧，我们肯定能改进一件事。这可能与如此小的应用程序无关，但对于更大的应用程序却非常重要。我们可以解决道具链的问题。</p><h2 id="9c61" class="nw mt it bd mu nx ny dn my nz oa dp nc lh ob oc ne ll od oe ng lp of og ni oh bi translated">道具链问题到底是什么？</h2><p id="64cf" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">在我们的应用程序中，我们将<code class="fe np nq nr ns b">isAuthenticated </code>标志作为道具传递给<code class="fe np nq nr ns b">Users.js</code>，然后再作为道具传递给<code class="fe np nq nr ns b">User.js</code>。</p><p id="bb77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我们甚至需要<code class="fe np nq nr ns b">Users.js</code>中<code class="fe np nq nr ns b">isAuthenticated </code>的值吗？用户组件只转发<code class="fe np nq nr ns b">isAuthenticated</code>的值。它确实接收了作为道具的值，但并不真正关心。这没什么大不了的，因为这只会导致额外的冗余，降低组件的可重用性，因为无论我们在哪里使用Users组件，我们都必须将<code class="fe np nq nr ns b">isAuthenticated </code>的值传递给它。</p><h2 id="f2b7" class="nw mt it bd mu nx ny dn my nz oa dp nc lh ob oc ne ll od oe ng lp of og ni oh bi translated">还原到救援</h2><p id="b2a1" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">如前所述，Redux是一个用于管理应用程序状态的JavaScript库。</p><p id="7603" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将试着解释Redux是如何工作的，在那之后，你可能会有一个它如何解决我们的道具链问题的想法。</p><p id="9bd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以Redux围绕着一个叫做商店的中心状态的想法工作。要改变状态，组件必须分派一个动作。<strong class="la iu"> </strong>这个动作然后被传递给reducer，它改变了我们的应用程序的状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oi"><img src="../Images/daf61e3eff7aba5ec0e91a064e81b4bf.png" data-original-src="https://miro.medium.com/v2/0*68aLnHHt5H4fzztc"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae lu" href="https://upload.wikimedia.org/wikipedia/commons/0/06/Ngrx-redux-pattern-diagram.png" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure><p id="a9b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这只是对Redux工作原理的一个简单总结。让我们回到它将如何解决我们的道具链问题的问题。为了理解这一点，让我们使用Redux来转换我们的项目。要使用React连接Redux，我们需要遵循某种方法:</p><ul class=""><li id="ee4a" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">这里的第一步是将<code class="fe np nq nr ns b">redux</code>和<code class="fe np nq nr ns b">react-redux</code>安装到我们的应用程序中。</li><li id="24a7" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">第二步，添加我们的店铺。商店应该在我们的应用程序开始之前创建，所以<code class="fe np nq nr ns b">index.js</code>将是添加我们的商店的好地方。所以我们就<code class="fe np nq nr ns b">import { createStrore } from ‘redux’</code>。然后，这个存储需要存储在一个常量变量中。我们把它命名为<code class="fe np nq nr ns b">store</code>，在这里我们将调用<code class="fe np nq nr ns b">createStore</code>函数并传递我们的reducer。</li><li id="1f83" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">因为我们需要传递我们的reducer，所以我们必须为这个reducer创建一个文件，并将这个文件导入到我们的<code class="fe np nq nr ns b">index.js</code>中。我们的reducer文件看起来怎么样？如前所述，状态变化只能通过减速器发生。所以在我们的<code class="fe np nq nr ns b">reducer.js</code>中会有一个初始状态。reducer函数有两个参数:state和action <strong class="la iu"> </strong>(它将接收来自组件的调度动作)。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="04fa" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">我们的减速器目前正在返回状态。现在我们可以将这个减速器导入到我们的<code class="fe np nq nr ns b">index.js</code>中，并将这个减速器传递给<code class="fe np nq nr ns b">createStore </code>函数(<code class="fe np nq nr ns b">const store = createStore(reducer)</code>)。我们现在已经创建了我们的商店。为了将这个商店连接到我们的React应用程序，我们需要一个特殊的包，我们已经安装了这个包(<code class="fe np nq nr ns b">react-redux</code>)。安装后，我们将不得不<code class="fe np nq nr ns b">import { Provider } from ‘react-redux’</code>。这个提供者需要包装我们的应用组件。提供者<strong class="la iu"> </strong>是一个助手组件，它允许我们将存储注入到应用程序中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="7672" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">现在，我们如何从商店获取数据？为此，我们需要将<code class="fe np nq nr ns b">App.js</code>与商店联系起来。为此，我们使用了由<code class="fe np nq nr ns b">react-redux</code>包提供的叫做<code class="fe np nq nr ns b">connect</code>的东西。<code class="fe np nq nr ns b">connect</code> <strong class="la iu"> </strong>是我们在<code class="fe np nq nr ns b">App.js</code>导出中使用的高阶函数。然而，<code class="fe np nq nr ns b">connect</code> <strong class="la iu"> </strong>本身就是一个函数，返回一个函数，然后这个函数把组件作为输入(<code class="fe np nq nr ns b">export default connect()(App);</code>)。现在对于<code class="fe np nq nr ns b">connect</code>的第一次函数执行，我们可以通过一些配置。更准确地说，我们传递两条信息。首先，我们在组件中需要的整个应用程序状态的一部分。第二，我们需要从组件调度的动作。这两种配置命名为<code class="fe np nq nr ns b">mapStateToProps</code>和<code class="fe np nq nr ns b">mapDispatchToProps</code>(不一定同名，但这是最常见的命名约定)。现在，我们不再需要之前在<code class="fe np nq nr ns b">App.js</code>中使用的本地状态，我们也可以去掉<code class="fe np nq nr ns b">loginHandler</code>，因为我们将在我们的reducer中处理登录功能，这反过来又作为一个动作从我们的<code class="fe np nq nr ns b">App.js</code>中发出。现在可以使用<code class="fe np nq nr ns b">this.props</code>在我们的组件内部访问状态值。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="64bb" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">最后，当我们按下登录用户按钮时，我们的reducer将返回更新后的状态。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="f64a" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">现在我们已经在我们的应用程序中设置了Redux，这里要做的最后一件事是将<code class="fe np nq nr ns b">isAuthentication </code>标志的值从我们的中央状态直接传递给<code class="fe np nq nr ns b">User.js </code>，而不是通过<code class="fe np nq nr ns b">Users.js</code>传递给<strong class="la iu"> </strong>。如何实现这一点？很简单。因为每个组件现在都可以直接访问状态(使用<code class="fe np nq nr ns b">connect</code>)，所以我们可以在<code class="fe np nq nr ns b">User.js</code>中直接访问状态值。试着尝试一下，但如果你做不到，下面是一个参考:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a30a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样Redux就帮我们解决了道具链的问题。这在这么小的应用程序中可能无关紧要，但在更大的应用程序中使用Redux时，它使我们的工作变得容易得多。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="3356" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">上下文API和使用上下文挂钩</h1><p id="7330" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">最后，我们现在到达了有趣的部分，上下文API。<strong class="la iu"> </strong>首先，我们来搞清楚它到底是什么。</p><p id="a245" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们需要来自多个组件中某个状态的某些数据，但是我们不想在多个层之间传递数据时，就需要上下文API。</p><p id="17b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们将创建一个新文件<code class="fe np nq nr ns b">auth-context.js</code>。在这个文件中，我们将创建一个上下文对象。React将提供对它的访问。</p><pre class="kj kk kl km gt oj ns ok ol aw om bi"><span id="53fd" class="nw mt it ns b gy on oo l op oq">const authContext = React.createContext(); </span></pre><p id="9d34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe np nq nr ns b">createContext</code>允许我们用默认值初始化我们的上下文。这个<code class="fe np nq nr ns b">createContext</code>是一个JavaScript对象(技术上也可以是数组、字符串、数字等。)可以在不同的组件之间传递。给你。我们可以通过<code class="fe np nq nr ns b">isAuthenticated</code>的默认值。</p><p id="a5af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:我们在项目中添加这个是为了更好的自动完成。</p><pre class="kj kk kl km gt oj ns ok ol aw om bi"><span id="31a0" class="nw mt it ns b gy on oo l op oq">import React from 'react';</span><span id="45e1" class="nw mt it ns b gy or oo l op oq">const authContext = React.createContext({<br/>    isAuthenticated: false,<br/>});</span><span id="a9d3" class="nw mt it ns b gy or oo l op oq">export default authContext;</span></pre><p id="80cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以在应用程序中的任何地方导入这个上下文，它需要包装应用程序中需要访问它的所有部分。我们必须使用<code class="fe np nq nr ns b">context</code>进口名称并在其后添加<code class="fe np nq nr ns b">.Provider</code>来包装它。</p><p id="8657" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我们的<code class="fe np nq nr ns b">App.js</code>渲染函数应该看起来的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4cc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们将<code class="fe np nq nr ns b">AuthContext</code>包装在<code class="fe np nq nr ns b">Users</code>组件中。然后，我们可以访问我们的<code class="fe np nq nr ns b">Users</code>组件及其所有子组件中<code class="fe np nq nr ns b">isAuthenticated</code>的值(在我们的例子中是<code class="fe np nq nr ns b">User.js</code>)。</p><p id="d5e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有三种方法可以实现这一点。</p><h2 id="3487" class="nw mt it bd mu nx ny dn my nz oa dp nc lh ob oc ne ll od oe ng lp of og ni oh bi translated"><strong class="ak">使用消费者</strong></h2><p id="6f6e" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">要做到这一点，可以直接去我们的<code class="fe np nq nr ns b">User.js</code>。在我们的渲染函数中，我们可以添加<code class="fe np nq nr ns b">AuthContext.Consumer</code>。不要忘记将<code class="fe np nq nr ns b">AuthContext</code>导入到我们需要访问<code class="fe np nq nr ns b">isAuthenticated</code>标志的区域。这就是我们的渲染函数现在的样子。现在这个<code class="fe np nq nr ns b">AuthContext.Consumer</code>就是我们的<code class="fe np nq nr ns b">JSX</code>组件。因为这是一些JavaScript表达式，我们需要用花括号把它括起来。您需要记住的唯一问题是，<code class="fe np nq nr ns b">Consumer</code>在开始和结束标记之间将一个函数作为子函数，这个函数将接受我们的<code class="fe np nq nr ns b">context</code>对象。最后，要获得<code class="fe np nq nr ns b">isAuthenticated </code>标志，我们可以通过<code class="fe np nq nr ns b">context</code>获得。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="a6d1" class="nw mt it bd mu nx ny dn my nz oa dp nc lh ob oc ne ll od oe ng lp of og ni oh bi translated"><strong class="ak">使用上下文类型</strong></h2><p id="8ade" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">使用<code class="fe np nq nr ns b">Consumer</code>的问题是它只在渲染函数中运行，但是我们很有可能在组件的其他部分需要状态值(例如<code class="fe np nq nr ns b">componentDidMount()</code>)。我们将无法访问我们的上下文。<br/>为了克服这个问题，React 16.6给我们介绍了一个特殊的静态道具<code class="fe np nq nr ns b">contextType</code>，可以用在基于类的组件中(<code class="fe np nq nr ns b">static contextType = AuthContext</code>)。现在，这允许React在后台自动将这个组件与我们的上下文连接起来。这给了我们一个新的属性，我们可以在应用程序的任何部分使用它:<code class="fe np nq nr ns b">this.context</code>。<br/>为了现在获得认证状态，我们只需使用:</p><pre class="kj kk kl km gt oj ns ok ol aw om bi"><span id="ffe8" class="nw mt it ns b gy on oo l op oq">&lt;p&gt;AuthenticationStatus:this.context.isAuthenticated.toString()}&lt;/p&gt;</span></pre><h2 id="0737" class="nw mt it bd mu nx ny dn my nz oa dp nc lh ob oc ne ll od oe ng lp of og ni oh bi translated"><strong class="ak">使用useContext挂钩</strong></h2><p id="6d04" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">最后，要在一个<strong class="la iu"> </strong>函数组件中使用这个，我们可以使用React提供的钩子，<code class="fe np nq nr ns b">useContext</code>。</p><pre class="kj kk kl km gt oj ns ok ol aw om bi"><span id="2366" class="nw mt it ns b gy on oo l op oq">const authContext = useContext(AuthContext);</span></pre><p id="e47c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以在函数组件的任何地方使用这个<code class="fe np nq nr ns b">authContext</code>来访问<code class="fe np nq nr ns b">isAuthenticated </code>标志。</p><pre class="kj kk kl km gt oj ns ok ol aw om bi"><span id="3c9b" class="nw mt it ns b gy on oo l op oq">&lt;p&gt;AuthenticationStatus: authContext.isAuthenticated.toString()}&lt;/p&gt;</span></pre><p id="7f3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样。我们现在已经学会了如何使用上下文API来管理我们的状态。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="7e6b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">哪个更好？</h1><p id="5c62" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">现在我们已经了解了Redux和Context APIs是如何工作的，我们可以比较它们并了解它们的优缺点。</p><ul class=""><li id="5348" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">包大小:我们必须记住的一点是，redux是第三方包库，不属于React，因此我们需要安装依赖项——主要是其中的三个(Redux、react-redux、redux-thunk)。使用Redux是有代价的。安装这些依赖项会增加我们最终的包大小。相反，上下文API是React的一部分，所以我们的包大小保持不变。</li><li id="43aa" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">样板代码:使用Redux，我们需要有一个详尽的设置，我们需要建立一个商店，我们需要分派动作。然后，我们需要将商店与组件连接起来。有时候，这对开发人员来说是一种痛苦。很有可能一个人会迷失在代码中，漫无目的地游荡，不知道如何修复任何东西。基本上，你需要有一个实际操作的方法来使用Redux。在我看来，上下文API包含较少的样板代码。随着React 16.6的推出，我们甚至不需要消费者。只需一行代码，您就可以访问您的上下文。</li><li id="5812" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">处理异步代码:在上下文API中，一旦掌握了窍门，触发API(异步代码)相对简单(尤其是在使用钩子时)。你也不需要像<code class="fe np nq nr ns b">redux-thunk</code>这样的包来处理异步动作。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="fee0" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="6188" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">通过这篇文章，您现在可以猜测为什么上下文API可以比Redux更好。不过，预计将推出Redux的新版本。它将包含更少的样板代码，效率更高。让我们拭目以待，看看效果如何。</p></div></div>    
</body>
</html>