<html>
<head>
<title>Implement Your First Swift Package Build Plugin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实施您的首个Swift包构建插件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-your-first-swift-package-build-plugin-9835a7aded0b?source=collection_archive---------3-----------------------#2022-08-29">https://betterprogramming.pub/implement-your-first-swift-package-build-plugin-9835a7aded0b?source=collection_archive---------3-----------------------#2022-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4490" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用新的构建插件改进您的开发过程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2456a1378a939421798a70559f3520de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wR98bIyYIHQlagW0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sh_sumon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Solaiman Hossen </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="0091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Xcode 14和Swift 5.7开始，可以创建和分发一种新类型的Swift产品:插件。插件有可能简化和改进任何iOS工程师的开发过程，在构建和预构建阶段添加自定义步骤。它们有两种口味:</p><ul class=""><li id="62ab" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">构建插件:这些插件可以在构建发生之前运行可执行文件。它们接受输入文件并产生一个或多个输出文件。</li><li id="5f52" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">命令插件:这些插件可以直接在Xcode中执行，也可以从命令行界面手动执行。他们可以执行定制的Swift脚本，也可以使用<code class="fe mj mk ml mm b">Process</code>类运行其他脚本和系统命令。</li></ul><p id="8d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些WWDC视频中展示了插件，我强烈建议大家了解一下可以用它们构建什么以及它们是如何工作的:</p><ul class=""><li id="e6f1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2022/110359/" rel="noopener ugc nofollow" target="_blank">认识Swift包插件</a></li><li id="3830" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2022/110401/" rel="noopener ugc nofollow" target="_blank">创建Swift包插件</a></li></ul><p id="f5f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我将向你展示如何创建你的第一个构建插件，并在你的其他包中使用它。</p><blockquote class="mn mo mp"><p id="5023" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>你需要下载Xcode 14 beta版来自己试用这段代码。</p></blockquote><h1 id="4501" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">构建插件</h1><p id="869c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">苹果从命令插件开始描述插件，但是我发现构建插件更容易编写和测试。总的来说，我也认为它们比命令插件更有用。</p><p id="487f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者之间的主要区别是，构建插件在构建步骤中自动执行，而命令插件需要显式操作才能运行:例如，更容易忘记执行它。</p><p id="f5fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果提供两种构建插件:预构建插件和构建插件。两者之间的主要区别在于它们可以产生的输出:</p><ul class=""><li id="5e19" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">当输出事先未知时，必须使用预构建插件。想象一个基于一些规范生成一些代码的构建步骤。您事先不知道代码生成步骤的输出会是什么。</li><li id="5a44" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">相反，构建插件要求您指定一组输出文件。想象一个步骤，创建一个在构建过程中被改变的文件的概要:输出文件被很好地定义，并且它是概要。</li></ul><p id="2186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的段落中，您将探索如何创建一个构建插件来在您的项目中运行<a class="ae ky" href="https://github.com/realm/SwiftLint" rel="noopener ugc nofollow" target="_blank"> SwiftLint </a> linter。</p><h1 id="afa6" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.声明插件</h1><p id="c8e2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">首先，你需要创建一个新的<code class="fe mj mk ml mm b">Package.swift</code>文件:插件是用SwiftPM描述的。要使用新的插件功能，步骤如下:</p><ol class=""><li id="65cd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">使用大于或等于<code class="fe mj mk ml mm b">5.7</code>的<code class="fe mj mk ml mm b">swift-tools-version</code>版本。</li><li id="84ed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">在<code class="fe mj mk ml mm b">product</code>列表中，添加一个新的<code class="fe mj mk ml mm b">.plugin</code>产品。它需要一个名字和一个目标。</li><li id="852d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">在<code class="fe mj mk ml mm b">target</code>列表中，添加一个新的<code class="fe mj mk ml mm b">.plugin</code>目标。对于构建插件，定义<code class="fe mj mk ml mm b">name</code>和<code class="fe mj mk ml mm b">capability</code>。正确的功能是<code class="fe mj mk ml mm b">.buildTool()</code>，与命令插件的<code class="fe mj mk ml mm b">command()</code>相反。</li></ol><p id="0520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">Package.swift</code>文件的示例如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="19d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果插件依赖于另一个目标或包，你也可以在<code class="fe mj mk ml mm b">capability</code>属性下添加一个<code class="fe mj mk ml mm b">dependencies</code>属性。</p><h1 id="47e0" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">文件夹结构</h1><p id="8ef5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果您现在尝试构建，将会得到一个错误。SwiftPM需要一个合适的插件结构。构建错误的描述性足以指导他们解决问题，但简而言之，您必须执行以下操作:</p><ol class=""><li id="8327" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">在<code class="fe mj mk ml mm b">Package.swift</code>文件下创建一个<code class="fe mj mk ml mm b">Plugins</code>文件夹。</li><li id="7d21" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">在<code class="fe mj mk ml mm b">Plugins</code>文件夹中创建一个<code class="fe mj mk ml mm b">SwiftLintPlugin</code>文件夹(该文件夹的名称必须与<code class="fe mj mk ml mm b">target</code>数组中插件的名称相匹配)。</li><li id="5332" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">添加一个<code class="fe mj mk ml mm b">Plugin.swift</code>文件来实现插件。这个文件的名称并不重要。</li></ol><p id="eaad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的结构可能如下所示:</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="ae35" class="ny mv it mm b gy nz oa l ob oc">SwiftlintPlugin<br/>├── Package.swift<br/>└── Plugins<br/>    └── SwiftLintPlugin<br/>        └── Plugin.swift</span></pre><h1 id="0149" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">实现插件</h1><blockquote class="mn mo mp"><p id="f3ab" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:为了让这个部分工作，你需要在本地安装SwiftLint。您可以在此处遵循安装说明<a class="ae ky" href="https://github.com/realm/SwiftLint#using-homebrew" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="8247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现新插件的主要步骤是:</p><ol class=""><li id="a987" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">导入<code class="fe mj mk ml mm b">PackagePlugin</code>框架，它包含了插件的所有新API。</li><li id="d312" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">声明一个包含插件代码的新结构。</li><li id="d593" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">用<code class="fe mj mk ml mm b">@main</code>注释来注释这个结构。这标志着你的插件的入口点。</li><li id="db25" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">确保你的插件实现了<code class="fe mj mk ml mm b">BuildToolPlugin</code>协议。</li><li id="0953" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">实现<code class="fe mj mk ml mm b">createBuildCommands(context:,target:) async throws -&gt; [Command]</code>功能。</li></ol><p id="8eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现的一个例子如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ac9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实施遵循以下步骤:</p><ol class=""><li id="5e67" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">它创建一个目录来存储输出文件，最终删除旧的目录。</li><li id="82a5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">它获取必须传递给SwiftLint的当前路径，以递归Lint文件。</li><li id="8e51" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">它返回一个<code class="fe mj mk ml mm b">.prebuildCommand</code>来创建一个预构建插件。</li></ol><p id="3e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">prebuildCommand</code>的参数是:</p><ul class=""><li id="110a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">构建阶段的名称。这将通过Xcode显示在构建步骤中</li><li id="eff6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您想要运行的可执行文件</li></ul><blockquote class="mn mo mp"><p id="b8e6" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>记得用SwiftLint可执行文件的正确路径更新<code class="fe mj mk ml mm b"><em class="it">executable</em></code>参数！</p></blockquote><ul class=""><li id="3bae" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">可执行文件需要的参数</li><li id="4e0f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">必须创建文件的目录</li></ul><p id="e4c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建命令总是要求您定义一些输出:</p><ul class=""><li id="d260" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">预构建命令需要一个文件夹，</li><li id="7f27" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">构建命令需要特定文件的列表。</li></ul><p id="c3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftLint不一定输出任何文件。使用没有输出的可执行文件的技巧是:</p><ul class=""><li id="ffe6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用预生成命令而不是生成命令</li><li id="dcda" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建一个空目录</li><li id="6a35" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用那个作为<code class="fe mj mk ml mm b">outputFilesDirectory</code></li></ul><p id="1ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您现在构建项目，您可以看到它构建成功。</p><h1 id="9200" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">在另一个包中使用插件</h1><p id="31ad" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在您已经有了一个插件，是时候将它插入到另一个包中了，例如，一个控制台应用程序:</p><ol class=""><li id="e830" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">使用swift命令行<br/> <code class="fe mj mk ml mm b">swift package init — type executable — name MyConsoleApp</code>创建新的控制台应用程序</li><li id="3576" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">将本地包作为依赖项添加。</li><li id="97a1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">将插件添加为控制台应用程序的插件。</li></ol><p id="7a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个命令生成一个由SwiftPM支持的新项目。双击<code class="fe mj mk ml mm b">Package.swift</code>文件可以在Xcode中打开。</p><p id="052a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现第二步和第三步，修改<code class="fe mj mk ml mm b">Package.swift</code>文件如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您构建了项目，您应该会立即看到弹出的一些警告。这些是由SwiftLint生成的，它正在运行并报告它的错误！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/b843b228f096ce330e43ad1728d48c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62QqrEfHtzTepKSDaDGnVQ.png"/></div></div></figure><p id="df54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看插件是否正在运行的另一种方法是执行以下操作:</p><ol class=""><li id="d5e5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">打开报告导航器(<code class="fe mj mk ml mm b">⌘+9</code>)</li><li id="943f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">点击构建日志</li><li id="f3b1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">观察中央面板中的日志</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/d92f870882158f3be3b5d716ee728406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJW_Dz83TF2b90QxG6afzg.png"/></div></div></figure><h1 id="f094" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="a52d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">本文教你如何为其他Swift包创建一个构建插件。您学习了如何声明它，实现它，并为另一个包启用它。</p><p id="c978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode插件可以改善iOS工程师优化开发过程的方式。我迫不及待地想看看社区会产生什么，现在我们有了在Xcode中添加构建步骤的简单方法。</p></div></div>    
</body>
</html>