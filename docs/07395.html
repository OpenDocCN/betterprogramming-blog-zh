<html>
<head>
<title>Perform Effective Auto Layout Programmatically in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中以编程方式执行有效的自动布局</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/effective-auto-layout-programmatically-in-swift-2e68d1b2f546?source=collection_archive---------9-----------------------#2021-01-11">https://betterprogramming.pub/effective-auto-layout-programmatically-in-swift-2e68d1b2f546?source=collection_archive---------9-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="831e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以编程方式布局您的视图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7a045b0d9a1e3c0a53d72f5c5005d69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ptMVo9mZOUAnKpFyoLv3w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae kv" href="https://unsplash.com/s/photos/rocket?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="3623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">界面构建器(IB)从任何人能回忆起<a class="ae kv" href="https://en.wikipedia.org/wiki/Interface_Builder" rel="noopener ugc nofollow" target="_blank">【1】</a>的时候就已经在Xcode了。它引发了持续至今的关于用代码还是用IB开发用户界面的争论。不过随着SwiftUI的发布，苹果已经将程序化布局作为主流方式。</p><p id="738c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么以前没有出现这种情况？民间传说告诉我们，用代码构建UI要比用界面构建器慢。在本文中，我将展示当使用有效的编程式自动布局的五种技术时，不仅相反，而且编程式布局更具可伸缩性、可维护性和面向未来性。</p><p id="baca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">这不是一篇入门文章。为了熟悉题目，我推荐</em> <a class="ae kv" href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1" rel="noopener ugc nofollow" target="_blank"> <em class="ls">苹果的自动布局指南</em> </a> <em class="ls">。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e629" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">以编程方式自动布局与故事板</h1><p id="f326" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们来看看关于界面构建器的一些事实:</p><ul class=""><li id="01c5" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">界面构建器的进入门槛很低。</li><li id="a84d" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">变化是可见的。</li><li id="b43b" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">要全面了解UI组件，您需要检查界面构建器文件和源代码文件。一个UI组件有两个真实的来源会降低可读性，并为错误留下更多的空间。</li><li id="b31a" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">通过IB配置一个组件有太多的方法:运行时属性，不同设置的多个选项卡，特定大小级别的覆盖，等等。这使得很难发现哪些设置被覆盖。</li><li id="4715" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">解决故事板和xib中的合并冲突容易出错，因为我们必须处理可读性差的XML。此外，在修复合并冲突时，接口生成器文件可能会无声地中断。您可能不会注意到丢失的<code class="fe nl nm nn no b">IBAction</code>连接，直到您触发那个动作。</li><li id="c524" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">在复杂的场景中，当您需要对布局进行更多控制时(例如，屏幕旋转、每个屏幕大小或平台的变化、动画、动态字体)，您将需要求助于编程约束甚至手动帧计算。</li></ul><p id="2159" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于程序布局的一些事实:</p><ul class=""><li id="62e0" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">代码是UI组件真实性的单一来源。</li><li id="1b34" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">视图设置是明确的。很清楚配置了哪些属性以及如何配置。</li><li id="ccb9" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">合并冲突更容易解决，因为我们处理的是代码而不是XML。</li><li id="a85c" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">可扩展复杂场景:屏幕旋转、动画、动态字体等。</li><li id="3387" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">通过编程构建UI的一致的<a class="ae kv" href="https://www.vadimbulavin.com/swift-code-style/" rel="noopener ugc nofollow" target="_blank">编码风格</a>在一个混合的UIKit和SwiftUI项目中得到维护。随着SwiftUI的逐渐采用，这变得越来越重要。</li><li id="b628" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">代码库中的噪音更少:没有segues、字符串标识符、来自storyboard和xib的复杂初始化，或者许多帮助扩展试图隐藏噪音的一部分。</li></ul><p id="4ba8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这些事实，我们可以得出结论，民间传说是错误的。代码布局比故事板和xib更快，更经得起未来的考验。将一些视图放在一块画布上似乎又快又容易。然而，从长远来看，界面构建器的所有缺点累积起来，使它成为一个次优的选择。</p><p id="d34b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使编程布局在编写速度和可维护性方面更加有效，我们将使用有效编程自动布局的五种技术:</p><ol class=""><li id="ef72" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr np nd ne nf bi translated">自动布局DSL。</li><li id="f118" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr np nd ne nf bi translated">专注的独立组件。</li><li id="91f0" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr np nd ne nf bi translated">回调作为一种沟通模式。</li><li id="d6c5" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr np nd ne nf bi translated">自动布局约束上的堆栈视图。</li><li id="2338" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr np nd ne nf bi translated">SwiftUI预览。</li></ol></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ac26" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">自动布局DSL</h1><p id="e2df" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当您以编程方式构建UI已经有一段时间了，您会注意到有些组合会随着时间的推移而重复。为了避免样板代码，我建议设计一个DSL，在优秀的<a class="ae kv" href="https://developer.apple.com/documentation/uikit/nslayoutanchor" rel="noopener ugc nofollow" target="_blank">布局锚点API </a>之上提供一个薄薄的抽象层。</p><p id="4310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">我考虑热门库像</em><a class="ae kv" href="https://github.com/SnapKit/SnapKit" rel="noopener ugc nofollow" target="_blank"><em class="ls">snap kit</em></a><em class="ls">和</em> <a class="ae kv" href="https://github.com/robb/Cartography" rel="noopener ugc nofollow" target="_blank"> <em class="ls">制图学</em> </a> <em class="ls">次优选择。我从本·桑多夫斯基</em>  <em class="ls">那里学到的一条有价值的建议是，只对你领域之外的问题使用库。</em></p><p id="6d24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这是我在项目中使用的DSL。认为它是信息性的，而不是指令性的。我将简要强调关键点，以便我们可以看到它们的好处。</p><p id="3ff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">LayoutAnchor</code>代表单个约束，可以是常量(如固定宽度或高度)，也可以是相对于另一个约束(如前导或尾随):</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="5b28" class="nu mb iq no b gy nv nw l nx ny">import UIKit<br/><br/>enum LayoutAnchor {<br/>    case constant(attribute: NSLayoutConstraint.Attribute,<br/>                  relation: NSLayoutConstraint.Relation,<br/>                  constant: CGFloat)<br/><br/>    case relative(attribute: NSLayoutConstraint.Attribute,<br/>                  relation: NSLayoutConstraint.Relation,<br/>                  relatedTo: NSLayoutConstraint.Attribute,<br/>                  multiplier: CGFloat,<br/>                  constant: CGFloat)<br/>}</span></pre><p id="2cd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">工厂方法简化了锚点定义:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="8194" class="nu mb iq no b gy nv nw l nx ny">extension LayoutAnchor {<br/>    ...<br/>    static let leading = relative(attribute: .leading, relatedBy: .equal, relatedTo: .leading)<br/>    static let trailing = relative(attribute: .trailing, relatedBy: .equal, relatedTo: .trailing)<br/><br/>    static let width = constant(attribute: .width, relatedBy: .equal)<br/>    static let height = constant(attribute: .height, relatedBy: .equal)<br/>    ...<br/>}</span></pre><p id="a39f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">UIView</code>有一个方便的方法，它应用了一组<code class="fe nl nm nn no b">LayoutAnchor</code>:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="aa44" class="nu mb iq no b gy nv nw l nx ny">extension UIView {<br/>    func addSubview(_ subview: UIView, anchors: [LayoutAnchor]) {<br/>        translatesAutoresizingMaskIntoConstraints = false<br/>        subview.translatesAutoresizingMaskIntoConstraints = false<br/>        addSubview(subview)<br/>        subview.activate(anchors: anchors, relativeTo: self)<br/>    }<br/>    <br/>    func activate(anchors: [LayoutAnchor], relativeTo: UIView? = nil) {<br/>        let constraints = anchors.map { NSLayoutConstraint(from: self, relativeTo: relativeTo, anchor: $0) }<br/>        NSLayoutConstraint.activate(constraints)<br/>    }<br/>}<br/><br/>extension NSLayoutConstraint {<br/>    convenience init(from: UIView, to item: UIView?, anchor: LayoutAnchor) {<br/>        ...<br/>    }<br/>}</span></pre><p id="18f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们如何使用DSL将几个视图放在一起:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="c828" class="nu mb iq no b gy nv nw l nx ny">class ViewController: UIViewController {<br/><br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/><br/>        let yellow = UIView()<br/>        yellow.backgroundColor = .yellow<br/>        view.addSubview(yellow, anchors: [.leading(0), .trailing(0), .bottom(0), .top(0)])<br/><br/>        let redBox = UIView()<br/>        redBox.backgroundColor = .red<br/>        view.addSubview(redBox, anchors: [.centerX(0), .centerY(0), .width(100), .height(100)])<br/>    }<br/>}</span></pre><p id="a0c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对比标准<a class="ae kv" href="https://developer.apple.com/documentation/uikit/nslayoutanchor" rel="noopener ugc nofollow" target="_blank">锚API </a>:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="e1c9" class="nu mb iq no b gy nv nw l nx ny">class ViewController: UIViewController {<br/><br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/><br/>        let yellow = UIView()<br/>        yellow.backgroundColor = .yellow<br/>        yellow.translatesAutoresizingMaskIntoConstraints = false<br/>        view.addSubview(yellow)<br/>        NSLayoutConstraint.activate([<br/>            yellow.leadingAnchor.constraint(equalTo: view.leadingAnchor),<br/>            yellow.trailingAnchor.constraint(equalTo: view.trailingAnchor),<br/>            yellow.topAnchor.constraint(equalTo: view.topAnchor),<br/>            yellow.bottomAnchor.constraint(equalTo: view.bottomAnchor),<br/>        ])<br/><br/>        let redBox = UIView()<br/>        redBox.backgroundColor = .red<br/>        redBox.translatesAutoresizingMaskIntoConstraints = false<br/>        view.addSubview(redBox)<br/>        NSLayoutConstraint.activate([<br/>            redBox.widthAnchor.constraint(equalToConstant: 100),<br/>            redBox.heightAnchor.constraint(equalToConstant: 100),<br/>            redBox.centerXAnchor.constraint(equalTo: view.centerXAnchor),<br/>            redBox.centerYAnchor.constraint(equalTo: view.centerYAnchor),<br/>        ])<br/>    }<br/>}</span></pre><p id="474b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们算上<code class="fe nl nm nn no b">viewDidLoad()</code>方法，那就是11对24行代码。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="69da" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">专注、独立的组件</h1><p id="007a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">界面构建器使得重用组件变得困难。要在画布中呈现一个视图，您需要用<code class="fe nl nm nn no b">@IBDesignable</code>属性对其进行标记，并通过<code class="fe nl nm nn no b">prepareForInterfaceBuilder()</code>支持另一条生命周期路径。即使你设法做到了这一点，故事板也会加载缓慢，视图只会偶尔出现在画布上(这是Xcode 6以来的情况，我不相信它会被修复)。</p><p id="a84a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，不需要额外的努力来组成编程编写的组件。以下是在考虑可重用性的情况下设计组件的经验法则:</p><ul class=""><li id="a0af" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">争取专注、独立的观点。</li><li id="961c" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">传递视图呈现所需的最小数据子集。比起视图模型、业务模型对象，更喜欢原始值——你能想到的。</li><li id="695b" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">不要将视图与协议或基类耦合，因为过早的抽象可能会损害你的设计。这是因为UI组件的变化速度不同，原因也不同。</li></ul><h1 id="7b79" class="ma mb iq bd mc md nz mf mg mh oa mj mk jw ob jx mm jz oc ka mo kc od kd mq mr bi translated">回调作为一种沟通模式</h1><p id="b518" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">使用回调作为视图之间的主要通信模式。从iOS 14开始，你已经可以通过系统API来做到这一点。例如，下面是如何将回调附加到<code class="fe nl nm nn no b">UITextField</code>文本更改:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="f48b" class="nu mb iq no b gy nv nw l nx ny">let textField = UITextField()<br/>textField.addAction(<br/>    UIAction { action in<br/>        let textField = action.sender as! UITextField<br/>        print("Text changed \(textField.text)")<br/>    },<br/>    for: .editingChanged<br/>)</span></pre><p id="c65e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者用回调实例化一个<code class="fe nl nm nn no b">UIButton</code>:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="9d05" class="nu mb iq no b gy nv nw l nx ny">let button = UIButton(primaryAction: UIAction { action in<br/>    print("Tapped!")<br/>})</span></pre><p id="bab3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们大多数人都没有支持iOS 14+的特权，所以实现自定义的基于回调的控件是微不足道的。这里有一个<code class="fe nl nm nn no b">UIButton</code>的例子:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="a780" class="nu mb iq no b gy nv nw l nx ny">class CallbackButton: UIButton {<br/>    var onAction: ((CallbackButton) -&gt; Void)?<br/><br/>    init(onAction: ((CallbackButton) -&gt; Void)? = nil) {<br/>        self.onAction = onAction<br/>        super.init(frame: .zero)<br/>        setup()<br/>    }<br/><br/>    required init?(coder: NSCoder) {<br/>        super.init(coder: coder)<br/>        setup()<br/>    }<br/><br/>    private func setup() {<br/>        addTarget(self, action: #selector(onTap), for: .primaryActionTriggered)<br/>    }<br/><br/>    @objc private func onTap() {<br/>        onAction?(self)<br/>    }<br/>}</span></pre><p id="97ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用法类似于系统API:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="34f1" class="nu mb iq no b gy nv nw l nx ny">let button = CallbackButton { btn in<br/>    print("Tapped!")<br/>}</span></pre><p id="a199" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感觉差不多是SwiftUI吧？</p><p id="d118" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里描述<a class="ae kv" href="https://www.vadimbulavin.com/passing-data-between-swiftui-views/" rel="noopener ugc nofollow" target="_blank"> SwiftUI视图通信模式</a>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f21b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">自动布局约束上的堆栈视图</h1><p id="4098" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">堆栈视图在自动布局之上提供了一个抽象层，允许我们从原始的容器视图组成复杂的布局。<code class="fe nl nm nn no b">UIStackView</code>所做的一切都是在给我们制造约束。</p><p id="b4a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你查看苹果的<a class="ae kv" href="https://developer.apple.com/documentation/uikit/view_layout" rel="noopener ugc nofollow" target="_blank">视图布局</a>概述，第一句话就是:</p><blockquote class="oe"><p id="0672" class="of og iq bd oh oi oj ok ol om on lr dk translated">使用堆栈视图自动布局界面视图。当需要精确放置视图时，请使用自动布局。</p></blockquote><p id="9347" class="pw-post-body-paragraph kw kx iq ky b kz oo jr lb lc op ju le lf oq lh li lj or ll lm ln os lp lq lr ij bi translated">甚至苹果的<a class="ae kv" href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html#//apple_ref/doc/uid/TP40010853-CH8-SW1" rel="noopener ugc nofollow" target="_blank">自动布局指南</a>也在约束本身之前引入了堆栈。</p><p id="b90a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，如果您只能使用堆栈视图，那么就去使用它。</p><p id="aafd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从我的经验来看，栈可以解决自动布局想要解决的超过50%的问题。与约束相比，基于堆栈的布局构建速度更快，更简洁，可读性更好，也更灵活。此外，堆栈还有其他一些好处:</p><ul class=""><li id="b100" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">支持不同的内容大小类别是微不足道的。如果不合适，只需翻转内容的轴。</li><li id="a53e" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><a class="ae kv" href="https://useyourloaf.com/blog/scrolling-stack-views/" rel="noopener ugc nofollow" target="_blank">添加滚动</a>很琐碎。这对于表单、短列表和集合来说很方便，不会引入<code class="fe nl nm nn no b">UITableView</code>或<code class="fe nl nm nn no b">UICollectionView</code>的开销。</li><li id="4821" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/uikit/uistackview/1616243-alignment" rel="noopener ugc nofollow" target="_blank">对齐</a>和<a class="ae kv" href="https://developer.apple.com/documentation/uikit/uistackview/1616233-distribution" rel="noopener ugc nofollow" target="_blank">分配</a> <a class="ae kv" href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" rel="noopener ugc nofollow" target="_blank">排列好的子视图</a>有多种方式，通过约束来实现并不容易。</li><li id="6eaf" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">很容易从视图层次结构中隐藏和显示排列好的子视图，而不会破坏约束。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="523f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">SwiftUI预览</h1><p id="4b80" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当在代码中构建布局时，通常很难验证您所做的更改是否达到了预期的结果。SwiftUI预览的目标是最大限度地减少您构建、运行和配置视图以验证您所做的变更的时间<a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2019/233/" rel="noopener ugc nofollow" target="_blank">【2】</a>。</p><p id="a12d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然<a class="ae kv" href="https://developer.apple.com/documentation/swiftui/previewprovider" rel="noopener ugc nofollow" target="_blank">预览提供者</a>只支持<code class="fe nl nm nn no b">SwiftUI.View</code>，但是我们可以通过符合<code class="fe nl nm nn no b">UIView(Controller)Representable</code><a class="ae kv" href="https://gist.github.com/mattt/ff6b58af8576c798485b449269d43607" rel="noopener ugc nofollow" target="_blank">【3】</a>无缝地使<code class="fe nl nm nn no b">UIView</code>和<code class="fe nl nm nn no b">UIViewController</code>可供预览:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="cc4b" class="nu mb iq no b gy nv nw l nx ny">import SwiftUI<br/><br/>@available(iOS 13, *)<br/>struct UIViewControllerPreview&lt;ViewController: UIViewController&gt;: UIViewControllerRepresentable {<br/>    let viewController: ViewController<br/><br/>    init(_ builder: @escaping () -&gt; ViewController) {<br/>        viewController = builder()<br/>    }<br/><br/>    func makeUIViewController(context: Context) -&gt; ViewController { viewController }<br/><br/>    func updateUIViewController(_ uiViewController: ViewController, context: Context) {}<br/>}</span></pre><p id="e8c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.vadimbulavin.com/swift-code-style/" rel="noopener ugc nofollow" target="_blank"><em class="ls">UIKit with swift ui</em></a><em class="ls">更详细的介绍了这个主题。</em></p><p id="bc25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了上面的内容，我们现在可以让<code class="fe nl nm nn no b">UIViewController</code>的任何实例都符合<code class="fe nl nm nn no b">UIViewControllerRepresentable</code>，从而可以预览上一个例子中的视图控制器:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="800a" class="nu mb iq no b gy nv nw l nx ny">struct ViewControllerPreviews: PreviewProvider {<br/>    static var previews: some View {<br/>        UIViewControllerPreview {<br/>            let storyboard = UIStoryboard(name: "Main", bundle: nil)<br/>            return storyboard.instantiateViewController(identifier: "ViewController") as! ViewController<br/>        }<br/>        .previewDevice("iPhone SE (2nd generation)")<br/>    }<br/>}</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="0ad5" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">摘要</h1><p id="ce63" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们总结一下有效的程序化自动布局的五个技巧:</p><ol class=""><li id="4709" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr np nd ne nf bi translated">利用自动布局DSL裁剪样板文件。本文中的例子<a class="ae kv" href="https://gist.github.com/V8tr/3d28b3468bb60b02c5134d8d6ad78c43" rel="noopener ugc nofollow" target="_blank">在这里</a>。</li><li id="6aae" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr np nd ne nf bi translated">设计组件时要考虑重用:(a)需要最小的数据子集，(b)专注于做一件事，而不是通过继承耦合到其他组件。</li><li id="fd36" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr np nd ne nf bi translated">通过回调在组件之间通信。</li><li id="1b2a" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr np nd ne nf bi translated">使用堆栈视图来简化布局并使其更加灵活。</li><li id="14dd" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr np nd ne nf bi translated">使用SwiftUI预览实现更快的反馈循环。</li></ol></div></div>    
</body>
</html>