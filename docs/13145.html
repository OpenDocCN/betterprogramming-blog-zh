<html>
<head>
<title>An Introduction to Coordinator pattern in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的协调器模式介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-coordinator-pattern-in-swiftui-38e5b02f031f?source=collection_archive---------1-----------------------#2022-08-02">https://betterprogramming.pub/an-introduction-to-coordinator-pattern-in-swiftui-38e5b02f031f?source=collection_archive---------1-----------------------#2022-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1519" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入阅读这份关于处理SwiftUI导航的深度指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/b28f10c817d8705b391bb533b216feec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jsdWN0oVqDOITm0IX8wEA.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">控制流</p></figure><p id="602d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文是关于在iOS 13.0+的SwiftUI应用中处理复杂流程的解决方案。SwiftUI应用中的导航可能会成为一个难点。</p><p id="a1b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当谈到处理应用程序流的有用模式时，协调器模式肯定是其中之一。本文将向您展示如何将协调器模式与SwiftUI这样的声明性框架集成在一起。它将通过解释导航系统的每个部分，并找到一个解决方案来应用协调器模式来修复导航问题。如果您理解这个概念，您可以将解决方案映射到Jetpack Compose或其他框架。</p><p id="f7b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“SwiftUI中的协调器模式介绍”是一系列文章的一部分，通过该系列文章，您将学习如何处理多个协调器、子协调器如何与其父协调器通信、如何处理<code class="fe ln lo lp lq b">UITabBarControllers</code>、不同的流程以及可以为您的应用选择正确流程的智能协调器。</p><p id="1c21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，只描述了协调器模式中负责路由的部分。因此，要创建一个真实的应用程序，需要阅读以下文章:</p><ul class=""><li id="2a1e" class="lr ls iq kt b ku kv kx ky la lt le lu li lv lm lw lx ly lz bi translated">协调员模式综合指南(即将推出)</li><li id="784f" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">智能协调员(即将推出)</li><li id="84a1" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">与协调员的深度链接(即将推出)</li></ul><h1 id="e90d" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">导航=州</h1><p id="220d" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">许多标记语言，如HTML或其他用户界面，通常是声明性的。HTML仅仅描述了网页上应该出现的内容。它没有指定用于呈现页面的<a class="ae nc" href="https://en.wikipedia.org/wiki/Control_flow" rel="noopener ugc nofollow" target="_blank">控制流</a>。</p><p id="e31f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，在命令式编程语言中，控制流<em class="nd">语句</em>是导致选择两条或多条路径中的哪一条的语句。这就是为什么协调模式中的指令在命令式语言中工作良好。</p><p id="d25a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">引用<a class="ae nc" href="https://medium.com/@mattcarroll?source=post_page-----dd84b624d0e--------------------------------" rel="noopener">马特·卡罗尔</a>中的<a class="ae nc" href="https://medium.com/super-declarative/understanding-state-management-and-why-you-never-will-dd84b624d0e" rel="noopener">这篇文章</a>很好地定义了国家:</p><blockquote class="ne nf ng"><p id="aec3" class="kr ks nd kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated">应用程序在给定时刻的行为</p></blockquote><p id="7523" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">App(t) = State</code></p><p id="51fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，我们可以认为导航是状态吗？导航状态每次可以是一个值，它会因另一个函数的副作用而改变。</p><p id="12d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，如果您选择导航作为状态，将会发现问题！</p><h1 id="0fe2" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">问题陈述</h1><p id="8f0a" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">下载starter项目，以便更轻松地执行步骤:</p><div class="nk nl gp gr nm nn"><a href="https://github.com/mohamadrezakoohkan/coordinator-intro-swiftui-starter" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">GitHub——swift ui中协调模式的介绍</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">启动项目</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob kl nn"/></div></div></a></div><p id="eee0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们知道SwiftUI是一个声明性的框架，所以它会有状态，当从屏幕1到2，2到3，3到4，…，n-1到n转换时，框架中会有一些限制。一些主要问题会出现！</p><p id="3d28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在SwiftUI <a class="ae nc" href="https://developer.apple.com/documentation/swiftui/navigationview" rel="noopener ugc nofollow" target="_blank"> NavigationView </a>中，我们错过了弹出到根，向后弹出一步，在堆栈中间取消整个导航堆栈，或者替换中间的视图，或者其他功能和导航代码增加了每个屏幕的复杂性。</p><p id="e8e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">屏幕2应该保持来自屏幕1的导航状态，并且屏幕2应该产生一个<a class="ae nc" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">副作用</a>来弹出一步回到屏幕1。</p><p id="1ef9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">甚至很难解释，让我们看看一些代码！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">协调者-启动者</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/3203280d791b20136064464076842153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wfxzh617gMPFBAkDVL18kA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图一</p></figure><p id="6e11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">图1看起来是这样的:一个主页(<code class="fe ln lo lp lq b">MapView</code>)，有一个按钮通过一个推转换导航到详细页(<code class="fe ln lo lp lq b">CityView</code>)，在详细页中有一个弹出按钮导航回主页。</p><p id="c6de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">混乱来了！</p><p id="07ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">@State var showCity: Bool</code>是航海州。母版页将该状态传递给详细视图，以便能够在详细页中触发副作用，从而再次改变母版页中的导航。所以在两种情况下，从主页面推送到详细页面和从详细页面弹出到主页面，导航状态都是参与者并存储在主页面中！</p><p id="3fee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一个问题。如果有十个屏幕用这些状态链接在一起，我们必须推回到第一个或根屏幕，会怎么样？这将是完全混乱处理这一流程！</p><p id="c143" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们总结一下事实:</p><ol class=""><li id="a3af" class="lr ls iq kt b ku kv kx ky la lt le lu li lv lm oe lx ly lz bi translated">应用程序的导航状态是一种状态，一次只有一个值。每次，我们的导航状态可以代表屏幕A，而在另一次，它可以是屏幕b。</li><li id="6974" class="lr ls iq kt b ku ma kx mb la mc le md li me lm oe lx ly lz bi translated">导航和路由是必须改变对方环境/屏幕的路线的副作用，所以状态是一条路线，因为它是从导航的副作用改变而来的。</li></ol><p id="ddad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了所有的事实，解决问题的工具和说明是什么？</p><h1 id="08f8" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">思考不同</h1><p id="55b2" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">目前的导航系统有<code class="fe ln lo lp lq b"><a class="ae nc" href="https://developer.apple.com/documentation/swiftui/navigationstack/" rel="noopener ugc nofollow" target="_blank">NavigationStack</a></code>、<code class="fe ln lo lp lq b">NavigationView</code>和<code class="fe ln lo lp lq b"><a class="ae nc" href="https://developer.apple.com/documentation/uikit/uinavigationcontroller" rel="noopener ugc nofollow" target="_blank">UINavigationController</a></code>。</p><p id="4e15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">NavigationView在iOS 16.0中已被弃用，但对于新的iOS版本，苹果在WWDC22 中引入了新的<a class="ae nc" href="https://developer.apple.com/videos/play/wwdc2022/10054/" rel="noopener ugc nofollow" target="_blank"> NavigationStack。这是从iOS 16.0+开始提供的，它适用于每个苹果平台，但它不是协调器模式，也不向后兼容。</a></p><blockquote class="ne nf ng"><p id="068d" class="kr ks nd kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated">有了新的<code class="fe ln lo lp lq b">NavigationStack</code>，您可以弹出到根视图或向后弹出一步，而不需要传递前一个视图的push引用，但是您仍然不能从堆栈中间的视图中删除整个导航堆栈。消除行为仅适用于根视图！</p></blockquote><p id="ffc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与UINavigationController相比:</p><ul class=""><li id="1968" class="lr ls iq kt b ku kv kx ky la lt le lu li lv lm lw lx ly lz bi translated"><code class="fe ln lo lp lq b">UINavigationController</code>在iOS 2.0+上工作，这对于混合的UIKit/SwiftUI应用来说很好，但<code class="fe ln lo lp lq b">NavigationStack</code>在iOS 16.0上工作</li><li id="f104" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><code class="fe ln lo lp lq b">UINavigationController</code>比<code class="fe ln lo lp lq b">NavigationStack</code>更能控制导航</li><li id="6d7a" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><code class="fe ln lo lp lq b">UINavigationController</code>定制更加灵活</li><li id="e5bf" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><code class="fe ln lo lp lq b">NavigationStack</code>是新的，更兼容不同的苹果平台</li></ul><p id="d669" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">NavigationView</code> vs <code class="fe ln lo lp lq b">UINavigationController</code>呢？</p><p id="5495" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从设计角度来看，UIKit中的<code class="fe ln lo lp lq b">UINavigationController</code>与SwiftUI中的<code class="fe ln lo lp lq b"><a class="ae nc" href="https://developer.apple.com/documentation/swiftui/navigationview" rel="noopener ugc nofollow" target="_blank">NavigationView</a></code>不同。它有不同的实现和用法。</p><p id="d8a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但从技术角度来说，SwiftUI中的<code class="fe ln lo lp lq b">NavigationView</code>就是<code class="fe ln lo lp lq b">UINavigationController</code>！没错！UIKit和SwiftUI都是闭源框架，它们的文档并没有说太多它们的组件是如何创建的。因此有很多不确定性。</p><p id="8519" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是通过更深入地观察<code class="fe ln lo lp lq b">NavigationView</code>的层次，我们能够确定它们是相同的！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi of"><img src="../Images/0732344cae5574900a7a69b9b0feadda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeIHa33HCvl9a4H1I-7AkQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图2</p></figure><p id="15ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以如果都是<code class="fe ln lo lp lq b"><a class="ae nc" href="https://developer.apple.com/documentation/uikit/uinavigationcontroller" rel="noopener ugc nofollow" target="_blank">UINavigationController</a></code>的话，那么有一个很棒的导航管理器，但是不能照原样使用。SwiftUI视图不能堆叠到UINavigationController中！</p><p id="fcd6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是等等，也有一些好消息！如果您再次检查Debug视图层次结构，您将会看到MapView嵌入在继承自<code class="fe ln lo lp lq b"><a class="ae nc" href="https://developer.apple.com/documentation/uikit/uiviewcontroller" rel="noopener ugc nofollow" target="_blank">UIViewController</a></code>的<code class="fe ln lo lp lq b"><a class="ae nc" href="https://developer.apple.com/documentation/swiftui/uihostingcontroller" rel="noopener ugc nofollow" target="_blank">UIHostingController</a></code>中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi ok"><img src="../Images/48c90e1bce9d67d6cdfb5a72ea060512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQ0RC6OnND_2ZTX-f5T_Rw.png"/></div></div></figure><p id="8f69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，这似乎是我们在UIKit中为协调者使用的相同方法。<code class="fe ln lo lp lq b">NavigationView</code>持有<code class="fe ln lo lp lq b">View</code>的筹码，与<code class="fe ln lo lp lq b">UINavigationController</code>持有<code class="fe ln lo lp lq b">UIViewController</code>的筹码完全相同！</p><p id="de2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nc" href="https://khanlou.com/" rel="noopener ugc nofollow" target="_blank"> Soroush Khanlou </a>引入了导航流管理器、<a class="ae nc" href="https://khanlou.com/2015/01/the-coordinator/" rel="noopener ugc nofollow" target="_blank">协调器</a>模式。在那篇文章之后，他有一个<a class="ae nc" href="https://www.youtube.com/watch?v=a1g3k3NObkE" rel="noopener ugc nofollow" target="_blank">演讲</a>，更深入地探讨了如何解决大规模视图控制器的问题。一旦您理解了流程背后的思想，协调器模式就是处理流程的最直接、最灵活的模式！</p><p id="99cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">听起来很有趣！我们可以对其应用协调器模式！</p><h1 id="2903" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">SwiftUI中协调员的实施</h1><p id="15c4" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">如前所述，协调器(导航系统)应该是一种因功能的副作用而改变的状态。状态管理器可以是触发给定的<a class="ae nc" href="https://www.controleng.com/articles/ladder-logic-106-one-shots/" rel="noopener ugc nofollow" target="_blank">单触发</a>值的功能，具有改变流程的副作用。</p><p id="0b25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一次性是指一次恰好发生一次并产生副作用的值/信号！例如，计算器中的<code class="fe ln lo lp lq b">=</code>运算符是一次性值/信号。它将进行计算，并在显示屏上产生一个新值。你可以想象UIKit的present/push函数，它接受单个对象，并对应用程序的生命周期产生副作用。</p><p id="ac86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在协调器模式中，一次性的值被称为“路由”，我们将它们存储在枚举中。协调功能将使用路由，并且每条路由都应该有路由要求。</p><p id="079e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在一个简单的应用程序中，一条路线至少应该包含它的“过渡风格”和“目的地视图”,这样我们就可以识别出一条路线的价值，以及它可以如何路由到哪里！路由不仅仅是路径，还可以做路径做的事情！</p><p id="d72e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始实施吧！</p><p id="445e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于过渡风格，我们考虑一个简单的应用程序，它只能选择<code class="fe ln lo lp lq b">push</code>、<code class="fe ln lo lp lq b">presentModally</code>或<code class="fe ln lo lp lq b">presentFullScreen</code>一条路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">navigationtransitionstyle . swift</p></figure><p id="829c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于目的地，它必须根据它的路线选择应该创建哪个视图/路径。</p><blockquote class="ne nf ng"><p id="0291" class="kr ks nd kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated">下面的函数只是伪代码，以便更好地形象化我们将要实现的目标。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">目的地视图</p></figure><p id="77b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，所有的需求都可以用伪代码实现，我们可以通过将它们全部放入一个新概念<code class="fe ln lo lp lq b">NavigationRouter</code>中来实现我们的北极星“路线”！</p><p id="fbcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">再说一次，路由至少应该包含它的转换风格和目的地视图，所以通过抽象路由，我们可以将这些需求应用到任何其他具体类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">导航路由器. swift</p></figure><p id="18c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于路由必须是一次性的，枚举更有意义！这些路由将成为指向单个流的协调器的触发点</p><blockquote class="ne nf ng"><p id="7396" class="kr ks nd kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated">在下一篇文章“协调器模式综合指南”中，您可以了解更多关于处理不同流、多个<code class="fe ln lo lp lq b">UINavigationController</code>、<code class="fe ln lo lp lq b">UITabBarControllers</code>和<code class="fe ln lo lp lq b">child</code>协调器的信息。</p><p id="203a" class="kr ks nd kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated">记得在你做了这篇文章中的大量练习后检查一下。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">MapRouter.swift</p></figure><p id="427b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了所有的路线和<code class="fe ln lo lp lq b">UINavigationController</code>，唯一剩下的就是一个厨师做一顿饭叫<code class="fe ln lo lp lq b">Coordinator</code>！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">我们做饭吧！</p></figure><p id="3848" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发者不是奇才，但是可以想象很多！他们通过混合指令和持续的努力，过去的成功和失败，通过想象的力量，并在其中加入创新思维来制作东西。</p><p id="21c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们创建一个<code class="fe ln lo lp lq b">Coordinator</code>的抽象来理解它的核心功能！</p><p id="bf0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它必须有:</p><ul class=""><li id="c77e" class="lr ls iq kt b ku kv kx ky la lt le lu li lv lm lw lx ly lz bi translated">引用一个<code class="fe ln lo lp lq b">UINavigationController</code></li><li id="c5bf" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">用于启动流程的启动功能</li><li id="15bf" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">显示路线目的地的功能</li><li id="9ee9" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">所有的<code class="fe ln lo lp lq b">UINavigationController</code>功能，例如后退一步，返回到根页面的所有步骤，以及取消整个<code class="fe ln lo lp lq b">navigationController</code></li><li id="0c50" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">它应该可以注入到每条路线的目的地/视图/页面。导航堆栈中的所有页面都应该有一个单独的<code class="fe ln lo lp lq b">Coordinator</code>对象！</li></ul><p id="ef81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们写下我们的需求，应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">协调器-抽象</p></figure><p id="ccd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">似乎足够了。让我们实现这个抽象吧！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Coordinator.swift</p></figure><p id="aab7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">啊？？问题出现了！</p><h2 id="e779" class="om mg iq bd mh on oo dn ml op oq dp mp la or os mr le ot ou mt li ov ow mv ox bi translated">什么是<code class="fe ln lo lp lq b">public let startingRoute: Router</code>？</h2><p id="a4dc" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">要启动协调器，我们可以创建一个继承自协调器类的新类，然后在<code class="fe ln lo lp lq b">start</code>函数中，我们实现启动它的逻辑！但是，我决定为起始路由创建一个属性来使用同一个<code class="fe ln lo lp lq b">Coordinator</code>类，因为在本文中，我只是描述了协调器模式的路由责任。</p><p id="c88e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用这两种场景，并自己进行一些练习。我非常乐意在评论区听到你的子类之旅。</p><h2 id="d4f5" class="om mg iq bd mh on oo dn ml op oq dp mp la or os mr le ot ou mt li ov ow mv ox bi translated">什么是<code class="fe ln lo lp lq b"><strong class="ak">public func show(_ route: Router, animated: Bool </strong>= true)</code></h2><p id="565a" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">这是协调器的主要功能。它选择一条路线，创建目的地，为其注入一个协调器，并使用不透明的<code class="fe ln lo lp lq b">View</code>类型将视图放入<code class="fe ln lo lp lq b">UIHostingController</code>。这个<code class="fe ln lo lp lq b">View</code>是基于路线的转场，它将系统导航到目的地！</p><h2 id="f163" class="om mg iq bd mh on oo dn ml op oq dp mp la or os mr le ot ou mt li ov ow mv ox bi translated">什么是<code class="fe ln lo lp lq b">public func pop(animated: Bool = true)</code></h2><p id="0576" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">因为它是<code class="fe ln lo lp lq b">UINavigationController</code>的功能，所以应该可以从协调器对象访问它。它与路线无关，所以它只是改变流程中的一些东西。</p><h2 id="21f4" class="om mg iq bd mh on oo dn ml op oq dp mp la or os mr le ot ou mt li ov ow mv ox bi translated">什么是<code class="fe ln lo lp lq b">public func popToRoot(animated: Bool = true)</code></h2><p id="fc82" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">与<code class="fe ln lo lp lq b">navigationController</code>的另一个功能<code class="fe ln lo lp lq b">pop</code>相同</p><h2 id="e3eb" class="om mg iq bd mh on oo dn ml op oq dp mp la or os mr le ot ou mt li ov ow mv ox bi translated">什么是<code class="fe ln lo lp lq b">open func dismiss(animated: Bool = true)</code></h2><p id="3dcf" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">这是<code class="fe ln lo lp lq b">UIViewController</code>的主要功能之一，但也有一些不同。在这种架构中，<code class="fe ln lo lp lq b">UIHostingControllers</code>不会仅仅通过解除<code class="fe ln lo lp lq b">navigationController</code>而从内存中释放。这时，就会发生内存泄漏。</p><p id="9aeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">hostingControllers</code>将被保留，因为它们仍然具有对<code class="fe ln lo lp lq b">navigationController</code>的强引用，但是通过从导航堆栈中手动移除<code class="fe ln lo lp lq b">hostingControllers </code>，该问题将被解决，并且它们对<code class="fe ln lo lp lq b">navigationController </code>的引用将被销毁，因此<code class="fe ln lo lp lq b">hostingControllers </code>将被成功释放</p><h2 id="8229" class="om mg iq bd mh on oo dn ml op oq dp mp la or os mr le ot ou mt li ov ow mv ox bi translated">为什么有些函数是公共的、开放的还是私有的？</h2><p id="8f88" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">这取决于您的需求，但是我发现了对<code class="fe ln lo lp lq b">Coordinator</code>属性的访问控制的最佳封装。</p><h2 id="2304" class="om mg iq bd mh on oo dn ml op oq dp mp la or os mr le ot ou mt li ov ow mv ox bi translated">为什么它是一个可观察的物体？</h2><p id="28f0" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la mz lc ld le na lg lh li nb lk ll lm ij bi translated">如前所述，它应该可注入SwiftUI视图，因此<code class="fe ln lo lp lq b">Observable Object</code>类型是SwiftUI视图中依赖注入的唯一可能的解决方案。它将被解析为一个<code class="fe ln lo lp lq b">@EnvironmentObject</code>。</p><h2 id="f222" class="om mg iq bd mh on oo dn ml op oq dp mp la or os mr le ot ou mt li ov ow mv ox bi translated">找不到答案？在评论区提问</h2></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><p id="3773" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然<code class="fe ln lo lp lq b">Coordinator</code>和<code class="fe ln lo lp lq b">Router</code>似乎是合适的工具，但是我们如何将它们放入应用的生命周期中呢？</p><p id="c480" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe ln lo lp lq b">UINavigationController</code>放入应用生命周期的最简单方法是我们在基于UIKit的应用中使用的<code class="fe ln lo lp lq b">AppDelegate</code>和<code class="fe ln lo lp lq b">SceneDelegate</code>。在我看来，即使我们能够在屏幕上添加多个窗口，他们和他们的功能的分离对于大多数复杂的功能来说是一个痛苦的杀手！</p><p id="db46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，如果我们回到过去使用<code class="fe ln lo lp lq b">AppDelegate</code>和<code class="fe ln lo lp lq b">SceneDelegate</code>的时代，我们将能够将<code class="fe ln lo lp lq b">UINavigationController</code>放入<code class="fe ln lo lp lq b">UIWindow </code>并启动应用程序！</p><p id="f68e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们去掉<code class="fe ln lo lp lq b">YOUR_PROJECT_NAMEApp.swift</code>文件，它是应用程序的<code class="fe ln lo lp lq b">@main</code>入口点。让我们把它扔进垃圾桶吧！</p><p id="38ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，用<code class="fe ln lo lp lq b">configurationForConnecting</code>委托创建<code class="fe ln lo lp lq b">AppDelegate.swift</code>。正是这个技巧将<code class="fe ln lo lp lq b">SceneDelegate</code>类连接到您的应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">AppDelegate.swift</p></figure><blockquote class="ne nf ng"><p id="ed30" class="kr ks nd kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated">重要提示:请记住，如果您以前在设备上使用旧的YourApp.swift文件(应用程序的@main入口点)构建和运行您的应用程序，您应该从该设备上完全删除应用程序并重新运行项目。</p></blockquote><p id="0ffe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第三，创建<code class="fe ln lo lp lq b">SceneDelegate.swift</code>来修改窗口，并将你的第一个<code class="fe ln lo lp lq b">navigationController</code>插入其中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">SceneDelegate.swift</p></figure><p id="3523" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">app启动后会新建一个窗口，通过启动功能的副作用将协调器移动到<code class="fe ln lo lp lq b">startingRoute </code>。</p><p id="2075" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后剩下的是视图中的用法。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">协调员-介绍-用法</p></figure><p id="68cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最有趣的是，所有适用于<code class="fe ln lo lp lq b">NavigationView</code>的<code class="fe ln lo lp lq b">ViewModifiers</code>仍然适用于这个模式。像<code class="fe ln lo lp lq b">navigationBarHidden</code>、<code class="fe ln lo lp lq b">navigationBarItems</code>之类的东西。</p><p id="bd8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">毕竟，您可以使用没有协调器模式的旧的基于状态的导航管理来检查这个代码块。再也不用担心处理100个页面，从第73页跳到第18页，或者删除第99页的整个导航堆栈。</p><p id="350b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这只是对大协调器模式的介绍。在接下来的文章中，我将解释许多事情，比如:</p><ul class=""><li id="dba5" class="lr ls iq kt b ku kv kx ky la lt le lu li lv lm lw lx ly lz bi translated">如何处理多个协调员</li><li id="053d" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">儿童协调员如何与父母沟通</li><li id="1bf3" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">如何处理<code class="fe ln lo lp lq b">UITabBarControllers</code></li><li id="641e" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">不同的流程和智能协调器可为您的应用提供合适的流程。</li></ul><p id="ab89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下载最终项目以遵循每个步骤，并将它们改为练习:</p><div class="nk nl gp gr nm nn"><a href="https://github.com/mohamadrezakoohkan/coordinator-intro-swiftui-final" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">GitHub——swift ui中协调模式的介绍</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">最终方案</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="pf l ny nz oa nw ob kl nn"/></div></div></a></div></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><p id="927e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢<a class="ae nc" href="https://khanlou.com/" rel="noopener ugc nofollow" target="_blank"> Soroush Khanlou </a>的这一成熟模式。他还有很多创新，我建议你看看他的个人博客！</p><p id="6607" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实是，苏斯博士说得对:“你读得越多，你知道的东西就越多，你学得越多，你去的地方就越多。”谢谢你阅读我的想法。我非常欢迎你的评论、想法、批评和建议。我希望看到你创造不可思议的东西！</p><h1 id="e324" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">下一步是什么？</h1><ul class=""><li id="10c5" class="lr ls iq kt b ku mx kx my la pg le ph li pi lm lw lx ly lz bi translated">协调器模式综合指南(即将推出)<br/>我已经解释了更多关于处理不同流、多个<code class="fe ln lo lp lq b">UINavigationController</code>、<code class="fe ln lo lp lq b">UITabBarControllers</code>和<code class="fe ln lo lp lq b">child</code>协调器的内容</li><li id="c6ee" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">智能协调器(即将推出)<br/>在本文中，您将能够创建协调器，它们不仅仅是从屏幕A移动到B的路由器，还具有一些更智能的功能来决定是从A移动到B还是从A移动到C</li><li id="a301" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">与协调员的深度链接(即将推出)<br/>这篇文章将从路线创建一个图表，并使任何或每个视图可以从一个独特的深度链接</li><li id="0a3e" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">SwiftUI中有协调员的MVVM模式(即将推出)</li><li id="3db4" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">SwiftUI中的MVI模式(即将推出)</li><li id="f39e" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">SwiftUI中有协调员的MVI模式(即将推出)</li></ul><h1 id="4d39" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">资源</h1><ul class=""><li id="0e1a" class="lr ls iq kt b ku mx kx my la pg le ph li pi lm lw lx ly lz bi translated"><a class="ae nc" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Side _ effect _(computer _ science)</a></li><li id="09a2" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://en.wikipedia.org/wiki/User_interface_markup_language" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/User _ interface _ markup _ language</a></li><li id="2069" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Declarative_programming</a></li><li id="67b8" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://en.wikipedia.org/wiki/Control_flow" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Control_flow</a></li><li id="95c6" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Side _ effect _(computer _ science)</a></li><li id="7eea" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://developer.apple.com/documentation/uikit/uinavigationcontroller" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/ui kit/uinavigationcontroller</a></li><li id="03ef" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://developer.apple.com/documentation/swiftui/navigationview" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/swift ui/navigation view</a></li><li id="f78c" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://developer.apple.com/videos/play/wwdc2022/10054/" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/videos/play/wwdc2022/10054/</a></li><li id="5aeb" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://khanlou.com/2015/01/the-coordinator/" rel="noopener ugc nofollow" target="_blank">https://khanlou.com/2015/01/the-coordinator/</a></li><li id="f5d4" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://www.youtube.com/watch?v=a1g3k3NObkE" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=a1g3k3NObkE</a></li><li id="6b38" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://developer.apple.com/documentation/swiftui/uihostingcontroller" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/swift ui/uihostingcontroller</a></li><li id="6615" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://developer.apple.com/documentation/uikit/uiviewcontroller" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/ui kit/uiview controller</a></li><li id="5aa3" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><a class="ae nc" href="https://www.controleng.com/articles/ladder-logic-106-one-shots/" rel="noopener ugc nofollow" target="_blank">https://www . controleng . com/articles/ladder-logic-106-one-shots/</a></li></ul></div></div>    
</body>
</html>