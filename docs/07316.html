<html>
<head>
<title>How to Build an LRU Cache in Less Than 10 Minutes and 100 Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不到10分钟和100行代码内构建LRU缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-an-lru-cache-in-less-than-10-minutes-and-100-lines-of-code-fddad56d7af5?source=collection_archive---------2-----------------------#2021-01-04">https://betterprogramming.pub/how-to-build-an-lru-cache-in-less-than-10-minutes-and-100-lines-of-code-fddad56d7af5?source=collection_archive---------2-----------------------#2021-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="09df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">掌握这个常见的面试话题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f807096c7abf046c641551fa59389665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HE8j1-iCHIZiiO9YOVYpAA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">https://corvostore.github.io/#LRU LRU高速缓存(图片来源:<a class="ae ky" href="https://corvostore.github.io/#LRU" rel="noopener ugc nofollow" target="_blank"/>)</p></figure><p id="6366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注:本文所有代码均可在</em> <a class="ae ky" href="https://github.com/sunny-b/lrucache_examples" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> GitHub </em> </a> <em class="lv">上找到。</em></p><p id="c85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我面试我的第一份软件工程工作时，我被多次问到最近最少使用(LRU)缓存。我被要求对它们进行编码，并描述它们如何在更大的系统中使用。如果你已经完成了你的编码面试，很可能你也已经完成了。</p><p id="4513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从采访者的角度来看，缓存是一个通用的话题。它可以用来衡量一个人对数据结构和算法的底层理解。也可以反过来挑战自己对分布式系统的高层次理解。</p><p id="226a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于求职者来说，这可能是一种不和谐的体验——尤其是如果你从未在专业场合使用过它们。对我来说就是这样。第一次被问及LRU·卡奇斯时，我的大脑一片空白。我当然听说过他们。但是在我对二叉树和堆的所有研究中，我并没有费心去了解它们包含了什么。生活在面试官面前并不是解决这个问题的理想环境。</p><p id="55dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我在那次面试中表现不太好，但这不一定是你的命运。在这篇文章中，我将教你什么和如何LRU缓存。最终，您将知道如何在不到100行的代码中实现自己的缓存，而无需任何第三方库——所有这一切都在10分钟之内完成。</p><p id="05f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们开始吧——时间在流逝。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9410" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是最近最少使用的(LRU)缓存？</h1><p id="7704" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">高速缓存是一种数据存储设备，通常将数据存储在内存中以便快速检索。它们通常被实现为键值存储，这意味着您通过某种标识键来存储和访问数据。</p><p id="e1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算机上的RAM就是缓存的一个例子。操作系统将数据存储在RAM中，以获得比硬盘更快的访问速度，它使用内存单元的地址作为密钥。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/506b667fd1f2b7326646a24b1ebfc1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*vMjQS4WCtP5bS93c21X3sA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操作系统缓存(图像来源:<a class="ae ky" href="https://www.sciencedirect.com/topics/computer-science/disks-and-data" rel="noopener ugc nofollow" target="_blank">https://www.sciencedirect.com</a>)</p></figure><p id="e603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LRU缓存是一种特殊类型的缓存，具有独特的功能。当LRU缓存空间不足，需要删除数据时，它会逐出最近最少从缓存中取出的键-值对。</p><p id="66f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LRU缓存的流行开源例子有<a class="ae ky" href="https://en.wikipedia.org/wiki/Redis" rel="noopener ugc nofollow" target="_blank"> Redis </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Memcached" rel="noopener ugc nofollow" target="_blank"> Memcached </a>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="05de" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">为什么LRU缓存有用？</h1><p id="1241" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于提供API或用户界面的科技企业来说，性能和可用性至关重要。想想你最近一次访问速度慢的网站。你是留下来等待它加载，还是离开并访问另一个网站？很可能是后者。速度慢或表现不佳的网站会导致数百万美元的收入损失。</p><p id="9043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，许多依赖于高正常运行时间的系统也不得不存储大量数据。社交媒体和电子商务网站通常都是如此。这些网站将其数据存储在某种数据库中，无论是SQL还是NoSQL。虽然这是标准做法，但当您需要获取数据时，问题就来了。查询数据库，尤其是当数据库包含大量数据时，可能会非常慢。</p><p id="06f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入缓存。</p><p id="80b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为高速缓存将数据保存在内存中，所以它们比传统数据库的性能高得多。对于社交媒体网站，20%最受欢迎的内容驱动着80%的流量，缓存可以显著降低数据库的负载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/78aa794a2431b323824af854184e55ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KVhvYNodqDcOPwqJx89_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SQL与缓存速度对比(图片来源:【https://dzone.com/articles/redis-vs-mysql-benchmarks】T4)</p></figure><p id="1476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次面试官问你如何优化一个API端点或需要反复获取相同数据的工作流时，缓存是一个很好的开始。</p><p id="ff4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，了解缓存如何工作以及如何使用它们是很容易的。知道如何自己建造一个是困难的部分。这正是我们要关注的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b102" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">如何构建LRU缓存</h1><p id="ce26" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">出于本文的目的，我将使用Python来实现LRU缓存。它简洁易读，很多人都知道。然而，如果你不喜欢Python或者你对如何用其他语言实现它很好奇，你可以看看我的<a class="ae ky" href="https://github.com/sunny-b/lrucache_examples" rel="noopener ugc nofollow" target="_blank">范例库</a>。</p><h2 id="4616" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated">要求</h2><p id="4832" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我们开始构建缓存之前，我们必须了解需求是什么。首先是API。我们需要实现哪些方法？</p><p id="c7ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然生产质量的缓存功能丰富，但我们会保持简单。您只需要创建两个方法:</p><ul class=""><li id="7909" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe nx ny nz oa b">get(key)</code></li><li id="b3e7" class="no np it lb b lc ob lf oc li od lm oe lq of lu nt nu nv nw bi translated"><code class="fe nx ny nz oa b">set(key, value)</code></li></ul><p id="a1f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这还不是全部。LRU缓存本身有许多要求:</p><ol class=""><li id="06ff" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu og nu nv nw bi translated">当达到高速缓存的最大值时，删除最近最少使用的键。</li><li id="1a11" class="no np it lb b lc ob lf oc li od lm oe lq of lu og nu nv nw bi translated">每当获取或更新一个键时，它就会成为最近使用的键。</li><li id="ded5" class="no np it lb b lc ob lf oc li od lm oe lq of lu og nu nv nw bi translated"><code class="fe nx ny nz oa b">get</code>和<code class="fe nx ny nz oa b">set</code>操作都必须在<a class="ae ky" href="https://stackoverflow.com/questions/697918/what-does-o1-access-time-mean" rel="noopener ugc nofollow" target="_blank"> O(1)时间复杂度</a>内完成(意思是不管缓存有多大，完成它需要的时间是一样的)。</li><li id="5de1" class="no np it lb b lc ob lf oc li od lm oe lq of lu og nu nv nw bi translated">当获取一个不存在的键时，返回一个<code class="fe nx ny nz oa b">null</code>值。</li></ol><p id="c4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这些要求，我们就可以开始工作了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/9f3d5a49ff5f1a1985e4e9d94b61f87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xSMMi7sHX9EfD4eh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@convertkit?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ConvertKit </a>拍照</p></figure><h2 id="084b" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated">数据结构</h2><p id="2097" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们需要回答的第一个问题是，哪种数据结构应该支持我们的LRU缓存？毕竟，缓存本身不是数据结构。</p><p id="b596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于缓存使用了<code class="fe nx ny nz oa b">get</code>和<code class="fe nx ny nz oa b">set</code>，并且需要在O(1)时间内运行，所以您可能会想到哈希表或字典。这确实满足了一些要求。但是拿掉LRU钥匙呢？字典不允许我们知道哪个是最古老的钥匙。</p><p id="599c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用时间戳作为字典值的一部分，并在获取键时更新它。这将告诉我们哪个键值对是最老的。问题是，我们需要遍历所有的字典条目来检查哪一个是最老的——这违反了我们的O(1)要求。</p><p id="c554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么答案是什么呢？</p><p id="f359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我应该告诉你一个秘密的地方。我们实际上需要<strong class="lb iu">两个</strong>数据结构:一个用于获取值(字典/哈希映射),另一个用于保存按最近使用排序的条目。</p><h2 id="54ae" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated">第二数据结构</h2><p id="3d09" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">那么第二种数据结构应该是什么呢？如果你想到了一个数组，你就快成功了。</p><p id="52b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用一个数组来保持项目排序。字典中的每个键都可以引用数组中某个值的索引。每当获取一个键时，我们可以将该值移动到数组的前面，将其余的项推回，并更新字典中的索引。</p><p id="6bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，还有一个小问题。在幕后，数组是一行连续的数据单元。如果我们需要将值移动到数组的前面，并将其余的值下推，那么随着数组大小的增加，操作会变得更慢。换句话说，在数组的开头插入元素需要O(N)时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/0cb632dc5631d76c2a49e444fc2ba05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suuHOtE36U1NqV9zoigyzg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="6ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们很亲密。我们只需要一个数据结构，它具有与数组相同的排序优势，还可以在O(1)时间内获取、设置和删除数据。满足所有这些需求的数据结构是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Doubly_linked_list" rel="noopener ugc nofollow" target="_blank">双向链表(DLL) </a>。</p><p id="3396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双向链表与<a class="ae ky" href="https://www.geeksforgeeks.org/data-structures/linked-list/" rel="noopener ugc nofollow" target="_blank">链表</a>相同，除了链表中的每个节点都有一个对前一个节点和下一个节点的额外引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/fcab0d274c16f0986ddfca632f158a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2w-LLnoE6SYOv9a5.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片鸣谢:<a class="ae ky" href="https://medium.com/flawless-app-stories/doubly-linked-lists-swift-4-ae3cf8a5b975" rel="noopener">https://medium . com/flashly-app-stories/double-linked-lists-swift-4-AE 3c F8 a5b 975</a></p></figure><p id="b477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字典中的每个键都将引用链表中的一个节点。这样，我们将能够轻松地获取数据，以及更新和删除它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/d7e8bff3ccc82e527ea36b0071be6c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9PdywPRbyMNcztsIsMASg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://corvostore.github.io/#LRU" rel="noopener ugc nofollow" target="_blank">https://corvostore.github.io/#LRU</a></p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f650" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">建设LRU高速缓存</h1><p id="f76e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们知道了LRU缓存的数据结构，我们可以开始构建它了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="ce29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看着这段代码，您可能会认为我们已经完成了。但是有一个问题。你注意到第六行的<code class="fe nx ny nz oa b">DoublyLinkedList</code>了吗？Python在标准库中没有提供<code class="fe nx ny nz oa b">DoublyLinkedList</code>。</p><p id="a23c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，大多数编程语言都没有配备DLL。由于实时编码挑战很少让你使用第三方库，我们将不得不自己实现它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6ace" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">构建双向链表</h1><p id="c7c9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">说到制作DLL，最重要的方面是设计。有许多不同类型的链表具有不同的权衡，但是对于我们的用例，我们将创建一个循环DLL。这将使我们快速访问头部和尾部，这对LRU缓存很重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/59328cd015eeb643ce24cd31dc919d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*myztJG4u2y5oau8_JcPe4w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有根节点的循环双向链表(图片来源:作者)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="984f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然链表通常有许多方便的方法，但我们只需要实现其中的一小部分:</p><ol class=""><li id="cb2f" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu og nu nv nw bi translated"><code class="fe nx ny nz oa b">move_front(node)</code></li><li id="5470" class="no np it lb b lc ob lf oc li od lm oe lq of lu og nu nv nw bi translated"><code class="fe nx ny nz oa b">unshift(value)</code></li><li id="861e" class="no np it lb b lc ob lf oc li od lm oe lq of lu og nu nv nw bi translated"><code class="fe nx ny nz oa b">remove_tail</code></li></ol><h2 id="f547" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated">移动前沿</h2><p id="833e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">每当从我们的缓存中获取一个键时，我们都需要使那个键成为最近使用的。这涉及到将该键移到DLL的前面。</p><p id="990e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现<code class="fe nx ny nz oa b">move_front</code>可能会有点混乱，因为它既涉及到从列表中删除一个节点，又涉及到将它插入到不同的位置。我们通过改变和交换一些周围节点上的<code class="fe nx ny nz oa b">next</code>和<code class="fe nx ny nz oa b">prev</code>来做到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/bd870f2abe06fb22befa8b1faae1ba82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*46btArIaub0qpvcD.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前移动画(图片来源:作者)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="6382" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated">松开打字机或键盘的字型变换键</h2><p id="7ffa" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">DLL的<code class="fe nx ny nz oa b">unshift</code>方法非常类似于数组，我们在列表的前面或头部插入一个值。每当调用<code class="fe nx ny nz oa b">set(key, value)</code>时，我们的LRU缓存将使用这个方法。</p><p id="d993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，<code class="fe nx ny nz oa b">unshift</code>和<code class="fe nx ny nz oa b">move_front</code>有很多相同的逻辑。如果我们稍微更新一下<code class="fe nx ny nz oa b">move_front</code>，就可以用它来实现<code class="fe nx ny nz oa b">unshift</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/d09a885f6d439f61d54c6afd6537c27d.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/1*Ks8dkzLBMVt7W-KYGzqOvg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">未移动画(图片鸣谢:<a class="ae ky" href="https://visualgo.net/en/list" rel="noopener ugc nofollow" target="_blank">https://visualgo.net</a>)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="0674" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated">移除尾巴</h2><p id="b770" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果我们的缓存达到最大值，我们将需要删除最近最少使用的键。这包括移除我们的DLL的尾部。与<code class="fe nx ny nz oa b">unshift</code>相似，<code class="fe nx ny nz oa b">remove_tail</code>与<code class="fe nx ny nz oa b">move_front</code>有一些共同的逻辑。虽然我们不能为<code class="fe nx ny nz oa b">remove_tail</code>重用<code class="fe nx ny nz oa b">move_front</code>，但是我们可以抽象出一些共同的逻辑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/56b22e6ed98e292cb905758cf07b5fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/1*X3FCZSkJrMm6YN7L4uv_YA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">去掉尾巴动画(图片来源:<a class="ae ky" href="https://visualgo.net/en/list" rel="noopener ugc nofollow" target="_blank">https://visualgo.net</a>)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="56d8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">把所有的放在一起</h1><p id="43ed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当我们结合我们的LRU缓存和DLL时，我们得到的是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，10分钟后，我们用不到100行代码创建了一个基本的LRU缓存。对于额外的练习，您可以尝试添加删除键的功能，创建简单的单元测试来证明它的工作，或者用不同的语言创建它。</p><p id="905c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前提到的，如果Python不是你的菜，不要担心。<a class="ae ky" href="https://github.com/sunny-b/lrucache_examples" rel="noopener ugc nofollow" target="_blank">我有更多JavaScript、Ruby和Go的例子</a>。我也开放拉其他语言的请求。</p><p id="926b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你发现这个深入探究LRU的宝藏是有用的和有信息的。这可能是一个令人困惑的话题，但是通过一些练习，你可以在睡梦中建立一个。所以下一次面试官试图挑战你的秘密时，让他们看看你学到了什么。</p><p id="7886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/subscribe/@SunnyB" rel="noopener"> <em class="lv">订阅我的个人资料</em> </a> <em class="lv">如果您想在我上传新故事时收到通知。</em></p></div></div>    
</body>
</html>