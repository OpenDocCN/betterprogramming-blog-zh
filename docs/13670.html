<html>
<head>
<title>Introducing The AppIntents Framework — A New Way to Integrate App’s Functionality Into the System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍AppIntents框架——一种将App功能集成到系统中的新方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-appintents-framework-a-new-way-to-hook-up-apps-functionality-to-the-system-96279feb4cce?source=collection_archive---------8-----------------------#2022-09-15">https://betterprogramming.pub/the-appintents-framework-a-new-way-to-hook-up-apps-functionality-to-the-system-96279feb4cce?source=collection_archive---------8-----------------------#2022-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3f08" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">演示AppIntents框架的费用跟踪器应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b52a27e2ca5594421f07b7f9cf89afd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kd_2Sd0t1QEXckaT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">米格尔·托马斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c842" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">WWDC一直是苹果每年最大的活动之一，因为世界上最大的技术公司向其客户、媒体和世界其他地方，更重要的是向开发者宣布其最新的软件和硬件产品，这些产品采用了尖端技术。</p><p id="90c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个iOS开发者都会在这一天赶上苹果的最新产品，并通过整合苹果操作系统新版本发布的新功能来增加应用程序的价值。</p><p id="0f27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着iOS 16和Xcode 14的发布，我们现在可以在我们的iPhones和开发环境中完全访问iOS 16功能。</p><p id="1918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将深入探讨苹果在iOS 16中引入的一个很酷的功能，以增强我们的iOS应用程序并使其更加用户友好，这就是所谓的应用程序意图。</p><p id="36ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用意向框架提供了一种编程方法，使系统服务可以访问您的应用的内容和功能。这些意图是可以在整个系统中使用的动作。应用程序意图使您的应用程序的功能在更多地方可用，包括快捷方式、Spotlight、焦点滤镜和Siri，这为您的客户带来了巨大的好处。听起来很棒，对吧？那么我们来试着理解一下这些App意图的结构。</p><p id="86f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">意图是你的应用程序向系统公开的单一功能。这项功能可以从您的应用程序中获取一些数据，例如找出下一次会议的时间和您的订单所在的位置，并将数据推送到您的应用程序，而无需在前台启动，例如向您的日历添加新事件。这些功能完全取决于你的应用程序的功能和你的创造力。</p><p id="2f4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个意向主要由三部分组成；</p><ul class=""><li id="5d6b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">元数据(关于意图的信息，如快捷方式应用程序中显示的标题)。</li><li id="3061" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">参数(您的意图需要用户通过使用键盘、交互或Siri进行的输入)。</li><li id="a887" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">执行方法(在执行意图时负责运行主函数)。</li></ul><p id="af19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序的意图就像写几行代码集成到你的应用程序中一样简单。但是，如果您想要创建更复杂的特性，框架也可以让您这样做。您可以使用Swift为我们提供的所有功能来创建意图。不需要重构您的项目或一些自动代码生成步骤。</p><p id="a536" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地可视化如何将应用程序意图添加到iOS项目中，我将创建一个名为HarcaMA的费用跟踪器应用程序。就其功能和用户界面而言，这款应用不会是世界上最好的，但它足以解释应用意图框架的力量。</p><p id="5c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个项目中，我将在使用SnapKit设计用户界面时以编程方式使用UIKit，但同样值得注意的是，您也可以将应用程序意图应用于您的SwiftUI应用程序。</p><p id="53d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的应用程序将有三页。第一个是我们到目前为止所做的费用列表，第二个是添加新的费用，第三个是编辑当前的费用。我们还将有机会从申请中删除费用。所有这些费用都将存储在核心数据中。我将遵循MVVM的委托设计模式来创建这个应用程序。所以，让我们从从Xcode创建我们的应用程序开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/24cb836a0766401a78eb5d17cd0b218b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kPQ2ZCI2jyvggVQJ"/></div></div></figure><p id="0da2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择storyboard界面，swift作为语言，并选中“使用核心数据”选项，然后将项目保存在存储器中的某个位置。</p><p id="c3c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我所说的，我们不会使用故事板来创建用户界面，我们也可以从项目导航器中删除<code class="fe mh mi mj mk b">Main.storyboard</code>文件。并开始配置我们的项目。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="85cb" class="mp mq iq mk b gy mr ms l mt mu">func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {<br/><br/>        guard let windowScene = (scene as? UIWindowScene) else { return }<br/>        window = UIWindow(windowScene: windowScene)<br/>        window?.rootViewController = UINavigationController(rootViewController: ViewController())<br/>        window?.makeKeyAndVisible()<br/>    }</span></pre><p id="f401" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到<code class="fe mh mi mj mk b">SceneDelegate</code>文件，用上面的代码替换<code class="fe mh mi mj mk b">connectionOptions</code>函数的内容。</p><p id="ec70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后打开<code class="fe mh mi mj mk b">Info.plist</code>文件，删除键为<code class="fe mh mi mj mk b">UISceneStoryboardFile</code>值为<code class="fe mh mi mj mk b">Main</code>的属性。</p><p id="a492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后转到目标的构建设置，过滤<code class="fe mh mi mj mk b">Main</code>的内容，并删除UIKit主故事板文件基本名称属性的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/7602fbf55d91addc223e601346076a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iG3tTTK4RlzELeQz"/></div></div></figure><p id="699f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们安全地移除了故事板，并准备创建用户界面——在将SnapKit作为依赖项添加到我们的项目之后。</p><p id="c605" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用Swift包管理器，但你也可以使用CocoaPods或Carthage。转到文件菜单，并从Xcode选项中选择添加包。搜索“<a class="ae kv" href="https://github.com/SnapKit/SnapKit.git" rel="noopener ugc nofollow" target="_blank">https://github.com/SnapKit/SnapKit.git</a>”，然后按添加包按钮。</p><p id="e13e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一小段时间后，它会询问您要在应用程序中包含的产品包。仅选择SnapKit就足以满足我们的目的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/2bd55c975bc28d4b20c598e16b49c359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PTTT6Gpo3aBwV6cx"/></div></div></figure><p id="d555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可以在项目导航器的<code class="fe mh mi mj mk b">PackageDependencies</code>中看到SnapKit。让我们继续为项目创建文件夹结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/6b96d98131d6750091267ff798bb2895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pPlb7NGYayvs1-aM"/></div></div></figure><p id="ed78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所示，在开始开发之前，我创建了一些文件夹来组织我们的项目。现在，让我们看看第一页，它列出了我们在<code class="fe mh mi mj mk b">tableview</code>中的花费。由于我们将使用一个<code class="fe mh mi mj mk b">UITableView</code>，我认为从设计表格视图的单元格开始是一个好方法。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="94fe" class="mp mq iq mk b gy mr ms l mt mu">import UIKit<br/>import SnapKit<br/>class ExpenseListTableViewCell: UITableViewCell {<br/>    static let identifier = "ExpenseListTableViewCell"<br/>    <br/>    var expense: Expense? {<br/>        didSet {<br/>            self.configure()<br/>        }<br/>    }<br/>    <br/>    private lazy var stackView: UIStackView = {<br/>        let stackView = UIStackView()<br/>        stackView.layoutMargins = UIEdgeInsets(top: 0, left: 20, bottom: 0, right: 20)<br/>        stackView.isLayoutMarginsRelativeArrangement = true<br/>        stackView.axis = .horizontal<br/>        return stackView<br/>    }()<br/>    <br/>    private lazy var tailStackView: UIStackView = {<br/>        let stackView = UIStackView()<br/>        stackView.spacing = 50<br/>        return stackView<br/>    }()<br/>    <br/>    private lazy var titleLabel: UILabel = {<br/>        let label = UILabel()<br/>        return label<br/>    }()<br/>    <br/>    private lazy var dateLabel: UILabel = {<br/>        let label = UILabel()<br/>        label.textAlignment = .right<br/>        return label<br/>    }()<br/>    <br/>    private lazy var priceLabel: UILabel = {<br/>        let label = UILabel()<br/>        return label<br/>    }()<br/>    <br/>    private func configure(){<br/>        self.titleLabel.text = expense?.title.shorted(to: 15)<br/>        self.dateLabel.text = expense?.formattedDate<br/>        let price = expense?.price ?? 0<br/>        self.priceLabel.text = "$ \(price)"<br/>        setupConsts()<br/>    }<br/>    <br/>    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {<br/>        super.init(style: style, reuseIdentifier: reuseIdentifier)<br/>    }<br/>    <br/>    required init?(coder: NSCoder) {<br/>        fatalError("init(coder:) has not been implemented")<br/>    }<br/>    <br/>    private func setupConsts(){<br/>        tailStackView.addArrangedSubview(dateLabel)<br/>        tailStackView.addArrangedSubview(priceLabel)<br/>        priceLabel.snp.makeConstraints { $0.width.equalTo(70) }<br/>        stackView.addArrangedSubview(titleLabel)<br/>        stackView.addArrangedSubview(tailStackView)<br/>        contentView.addSubview(stackView)<br/>        stackView.snp.makeConstraints { $0.edges.equalToSuperview() }<br/>    }<br/>}</span></pre><p id="f7e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将上面的代码粘贴到一个名为<code class="fe mh mi mj mk b">ExpenseListTableViewCell</code> .swift的文件中。注意，我们有一个名为expense的属性，它代表一个<code class="fe mh mi mj mk b">Expense</code>，也就是一个模型。当该费用被设置为用该属性的内容填充视图时，我们运行配置功能。让我们也将费用结构添加到<code class="fe mh mi mj mk b">Models</code>文件夹中。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="9d2c" class="mp mq iq mk b gy mr ms l mt mu">struct Expense {<br/>    let title: String<br/>    let date: Date<br/>    let price: Double<br/>    var formattedDate: String {<br/>        let formatter = DateFormatter()<br/>        formatter.dateFormat = "MM-dd HH:mm"<br/>        return formatter.string(from: date)<br/>    }<br/>}</span></pre><p id="fb36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe mh mi mj mk b">Expense</code>模型现在由三个存储的和一个计算的属性组成。</p><p id="16cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将默认的<code class="fe mh mi mj mk b">ViewController</code>重命名为<code class="fe mh mi mj mk b">ExpenseListViewController</code>，并开始添加我们的表格视图。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="556c" class="mp mq iq mk b gy mr ms l mt mu">class ExpenseListViewController: UIViewController {<br/>    <br/>    let viewModel: ExpenseListViewModel<br/>    <br/>    private lazy var tableView: UITableView = {<br/>        let tableView = UITableView()<br/>        return tableView<br/>    }()<br/>    <br/>    init(context: NSManagedObjectContext) {<br/>        self.viewModel = ExpenseListViewModel(context: context)<br/>        super.init(nibName: nil, bundle: nil)<br/>    }<br/>    required init?(coder: NSCoder) {<br/>        fatalError("init(coder:) has not been implemented")<br/>    }<br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        view.addSubview(tableView)<br/>        tableView.delegate = self<br/>        tableView.dataSource = self<br/>        tableView.register(ExpenseListTableViewCell.self, forCellReuseIdentifier: ExpenseListTableViewCell.identifier)<br/>        configureNavigationBar()<br/>    }<br/>    <br/>    override func viewDidLayoutSubviews() {<br/>        super.viewDidLayoutSubviews()<br/>        tableView.frame = view.bounds<br/>    }<br/>    private func configureNavigationBar(){<br/>        self.title = "Expenses"<br/>        let titleTextAttrs = [NSAttributedString.Key.foregroundColor: UIColor.black]<br/>        navigationController?.navigationBar.titleTextAttributes = titleTextAttrs<br/>        navigationController?.navigationBar.prefersLargeTitles = true<br/>        navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(didTapAddExpense))<br/>    }<br/>    @objc private func didTapAddExpense(){<br/>    <br/><br/>    }<br/>}</span><span id="1dc7" class="mp mq iq mk b gy my ms l mt mu">extension ExpenseListViewController: UITableViewDelegate, UITableViewDataSource {<br/>    <br/>    func numberOfSections(in tableView: UITableView) -&gt; Int {<br/>        1<br/>    }<br/>    <br/>    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {<br/>        1<br/>    }<br/>    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {<br/>        UITableViewCell()<br/>    }<br/>    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? {<br/>        nil<br/>    }<br/>    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {<br/>        50<br/>    }<br/>    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat {<br/>        40<br/>    }<br/>    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {<br/>        <br/>    }<br/>}</span></pre><p id="a2cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将上面的代码粘贴到视图控制器中。在这里，我们创建表格视图，设置其约束，注册单元格，并通过添加加号按钮来配置我们的导航栏，以便稍后添加新的费用。</p><p id="c1da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了启动表视图数据源和委托功能，我们还将为上面的视图控制器创建一个扩展。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="3261" class="mp mq iq mk b gy mr ms l mt mu">struct ExpenseListViewModel {<br/>    <br/>    var expenseList = [Expense]()<br/>}</span></pre><p id="763f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的视图模型目前还很基本，但是我们以后会改进它。现在让我们将一个视图模型实例添加到视图控制器中。并填充一些表视图委托函数，如下所示。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="e47a" class="mp mq iq mk b gy mr ms l mt mu">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {<br/>        viewModel.expenseList.count<br/>    }</span><span id="427b" class="mp mq iq mk b gy my ms l mt mu">    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {<br/>        guard let cell = tableView.dequeueReusableCell(withIdentifier: ExpenseListTableViewCell.identifier, for: indexPath) as? ExpenseListTableViewCell else { return UITableViewCell() }<br/>        cell.expense = viewModel.expenseList[indexPath.row]<br/>        return cell<br/>    }</span><span id="168b" class="mp mq iq mk b gy my ms l mt mu">    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? {<br/>        let stackView = UIStackView()<br/>        stackView.axis = .horizontal<br/>        stackView.backgroundColor = .systemGray<br/>        stackView.layoutMargins = UIEdgeInsets(top: 0, left: 20, bottom: 0, right: 20)<br/>        stackView.isLayoutMarginsRelativeArrangement = true<br/>        let titleLabel = UILabel()<br/>        titleLabel.text = "Title"<br/>        let tailStackView = UIStackView()<br/>        tailStackView.spacing = 100<br/>        let dateLabel = UILabel()<br/>        dateLabel.text = "Date"<br/>        let priceLabel = UILabel()<br/>        priceLabel.text = "Price"<br/>        stackView.addArrangedSubview(titleLabel)<br/>        tailStackView.addArrangedSubview(dateLabel)<br/>        tailStackView.addArrangedSubview(priceLabel)<br/>        stackView.addArrangedSubview(tailStackView)<br/>        return stackView<br/>    }</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/69fa9310c16b06c53d653d25edad3f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*2suN2G4QgcI9qYqG9Mz7ww.png"/></div></figure><p id="6a0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们的应用程序看起来像这样。现在让我们创建创建和编辑费用页面。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="128c" class="mp mq iq mk b gy mr ms l mt mu">import UIKit<br/><br/>protocol AddUpdateExpanseDelegate: AnyObject {<br/>    func addNewExpanse(title: String, date: Date, price: Double)<br/>    func updateExpanse(with expense: Expense)<br/>}<br/><br/>public enum AddEditExpenseMode {<br/>    case update<br/>    case add<br/>}<br/><br/>class AddUpdateExpenseViewController: UIViewController {<br/>    private let mode: AddEditExpenseMode<br/>    private let expense: Expense?<br/>    <br/>    weak var delegate: AddUpdateExpanseDelegate?<br/>    <br/>    private lazy var titleTextField: UITextField = {<br/>        let textField = UITextField()<br/>        textField.attributedPlaceholder = NSAttributedString(string: "Title...", attributes: [NSAttributedString.Key.foregroundColor: UIColor.lightGray])<br/>        textField.leftView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 0))<br/>        textField.leftViewMode = .always<br/>        textField.layer.borderWidth = 1<br/>        textField.layer.borderColor = UIColor.lightGray.cgColor<br/>        textField.layer.cornerRadius = 12<br/>        textField.returnKeyType = .continue<br/>        return textField<br/>    }()<br/>    <br/>    private lazy var priceTextField: UITextField = {<br/>        let textField = UITextField()<br/>        textField.attributedPlaceholder = NSAttributedString(string: "Amount...", attributes: [NSAttributedString.Key.foregroundColor: UIColor.lightGray])<br/>        textField.leftView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 0))<br/>        textField.leftViewMode = .always<br/>        textField.layer.borderWidth = 1<br/>        textField.layer.borderColor = UIColor.lightGray.cgColor<br/>        textField.layer.cornerRadius = 12<br/>        textField.keyboardType = .decimalPad<br/>        textField.returnKeyType = .done<br/>        return textField<br/>    }()<br/>    <br/>    private lazy var dateStackView: UIStackView = {<br/>        let stackView = UIStackView()<br/>        stackView.layer.borderWidth = 1<br/>        stackView.layer.borderColor = UIColor.lightGray.cgColor<br/>        stackView.layer.cornerRadius = 12<br/>        stackView.layoutMargins = UIEdgeInsets(top: 0, left: 10, bottom: 0, right: 10)<br/>        stackView.isLayoutMarginsRelativeArrangement = true<br/>        return stackView<br/>    }()<br/>    <br/>    private lazy var dateLabel: UILabel = {<br/>        let label = UILabel()<br/>        label.text = "Date"<br/>        label.textColor = .lightGray<br/>        return label<br/>    }()<br/>    <br/>    <br/>    private lazy var datePicker: UIDatePicker = {<br/>        let datePicker = UIDatePicker(frame: .zero)<br/>        datePicker.datePickerMode = .dateAndTime<br/>        datePicker.timeZone = TimeZone.current<br/>        return datePicker<br/>    }()<br/>    <br/>    private lazy var addUpdateButton: UIButton = {<br/>        let button = UIButton()<br/>        button.setTitle(self.mode == .add ? "Add Expense" : "Save Changes", for: .normal)<br/>        button.setTitleColor(.white, for: .normal)<br/>        button.backgroundColor = .systemPurple<br/>        button.contentEdgeInsets = UIEdgeInsets(top: 8, left: 12, bottom: 8, right: 12)<br/>        button.layer.borderWidth = 1<br/>        button.layer.borderColor = UIColor.lightGray.cgColor<br/>        button.layer.cornerRadius = 8<br/>        button.addTarget(self, action: #selector(didTapButton), for: .touchUpInside)<br/>        return button<br/>    }()<br/>    <br/>    init(mode: AddEditExpenseMode, expense: Expense?) {<br/>        self.mode = mode<br/>        self.expense = expense<br/>        super.init(nibName: nil, bundle: nil)<br/>    }<br/>    <br/>    required init?(coder: NSCoder) {<br/>        fatalError("init(coder:) has not been implemented")<br/>    }<br/>    <br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        self.hideKeyboardWhenTappedAround()<br/>        configureNavigationBar()<br/>        view.backgroundColor = .systemBackground<br/>        titleTextField.delegate = self<br/>        priceTextField.delegate = self<br/>        titleTextField.becomeFirstResponder()<br/>        addSubviews()<br/>    }<br/>    <br/>    <br/>    private func configureNavigationBar(){<br/>        self.title = self.mode == .add ? "Add Expense" : "Update Expense"<br/>        let titleTextAttrs = [NSAttributedString.Key.foregroundColor: UIColor.label]<br/>        navigationController?.navigationBar.titleTextAttributes = titleTextAttrs<br/>        navigationController?.navigationBar.prefersLargeTitles = true<br/>    }<br/>    <br/>    private func addSubviews(){<br/>        view.addSubview(titleTextField)<br/>        view.addSubview(priceTextField)<br/>        dateStackView.addArrangedSubview(dateLabel)<br/>        dateStackView.addArrangedSubview(datePicker)<br/>        view.addSubview(dateStackView)<br/>        view.addSubview(addUpdateButton)<br/>        guard let expense = self.expense, self.mode == .update else { return }<br/>        fillFields(with: expense)<br/>    }<br/>    <br/>    private func fillFields(with expense: Expense){<br/>        self.titleTextField.text = expense.title<br/>        self.priceTextField.text = String(expense.price)<br/>        self.datePicker.date = expense.date<br/>    }<br/>    <br/>    override func viewDidLayoutSubviews() {<br/>        titleTextField.snp.makeConstraints { make in<br/>            make.top.equalToSuperview().offset(200)<br/>            make.leading.equalToSuperview().offset(50)<br/>            make.trailing.equalToSuperview().inset(50)<br/>            make.height.equalTo(52)<br/>        }<br/>        priceTextField.snp.makeConstraints { make in<br/>            make.leading.trailing.equalTo(titleTextField)<br/>            make.top.equalTo(titleTextField.snp.bottom).offset(20)<br/>            make.height.equalTo(52)<br/>        }<br/>        <br/>        dateStackView.snp.makeConstraints { make in<br/>            make.leading.trailing.equalTo(titleTextField)<br/>            make.top.equalTo(priceTextField.snp.bottom).offset(20)<br/>            make.height.equalTo(52)<br/>        }<br/>        <br/>        addUpdateButton.snp.makeConstraints { make in<br/>            make.trailing.equalTo(titleTextField)<br/>            make.top.equalTo(dateStackView.snp.bottom).offset(20)<br/>        }<br/>    }<br/>    <br/>    @objc private func didTapButton(){<br/>        guard let priceText = priceTextField.text,<br/>              let price = Double(priceText),<br/>              let title = titleTextField.text else { return }<br/>        let date = datePicker.date<br/>        if self.mode == .add {<br/>            delegate?.addNewExpanse(title: title, date: date, price: price)<br/>        } else {<br/>            let newExpense = Expense(title: title, date: date, price: price)<br/>            delegate?.updateExpanse(with: newExpense)<br/>        }<br/>        self.dismiss(animated: true)<br/>    }<br/>    <br/>}<br/>extension AddUpdateExpenseViewController: UITextFieldDelegate {<br/>    func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {<br/>        if textField == titleTextField {<br/>            priceTextField.becomeFirstResponder()<br/>        } else if textField == priceTextField {<br/>            view.endEditing(true)<br/>            <br/>        }<br/>        return true<br/>    }<br/>}</span></pre><p id="cc89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所示，我们将通过mode参数在同一个视图控制器中处理添加和更新操作。我们将使用<code class="fe mh mi mj mk b">AddUpdateExpanseDelegate</code>协议来触发添加和编辑操作。</p><p id="e4bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们的用户界面已经接近完成，让我们创建核心数据实体模型及其配置文件。打开<code class="fe mh mi mj mk b">HarcaMA.xcdatamodeld</code>文件并点击下方的<code class="fe mh mi mj mk b">Add Entity</code>按钮。将实体命名为<code class="fe mh mi mj mk b">ExpenseItem</code>，并添加具有兼容数据类型的属性，如下图所示。此外，从数据模型检查器中选择手动代码生成选项。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/b1b8b56e84c4adb51f56e7b97eb9cb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2hykb2iYxGosqOVy"/></div></div></figure><p id="d7ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您在Xcode中选择<code class="fe mh mi mj mk b">datamodel</code>文件时，进入编辑器并选择<code class="fe mh mi mj mk b">Create NSManagedObject Subclass</code>选项。当您选择实体模型并选择create时，Xcode将为<code class="fe mh mi mj mk b">Entity</code>创建<code class="fe mh mi mj mk b">CoreDataClass</code>，以及一个包含其属性的扩展文件。</p><p id="637e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这些步骤之后，如果您成功地构建了您的项目，我们可以继续创建我们的服务结构。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="84a7" class="mp mq iq mk b gy mr ms l mt mu">struct ExpenseService {<br/>    <br/>    let context: NSManagedObjectContext<br/>    <br/>    init(context: NSManagedObjectContext) {<br/>        self.context = context<br/>    }<br/>    <br/>    public func fetchExpenseItems(completion: @escaping (Result&lt;[ExpenseItem], ExpenseServiceErrors&gt;) -&gt; (Void)){<br/>        do {<br/>            let items = try context.fetch(ExpenseItem.fetchRequest())<br/>            completion(.success(items))<br/>        } catch  {<br/>            completion(.failure(.fetchError))<br/>        }<br/>    }<br/>    <br/>    public func addExpenseItem(title: String, date: Date, price: Double, completion: @escaping (Bool) -&gt; (Void)){<br/>        let newItem = ExpenseItem(context: context)<br/>        newItem.title = title<br/>        newItem.date = date<br/>        newItem.price = price<br/>        do {<br/>            try context.save()<br/>            completion(true)<br/>        } catch  {<br/>            completion(false)<br/>        }<br/>    }<br/>    <br/>    public func updateExpenseItem(with newExpense: Expense, completion: @escaping (Bool) -&gt; (Void)){<br/>        guard let prevExpense = context.object(with: newExpense.id) as? ExpenseItem else {<br/>            completion(false)<br/>            return<br/>        }<br/>        prevExpense.title = newExpense.title<br/>        prevExpense.date = newExpense.date<br/>        prevExpense.price = newExpense.price<br/>        do {<br/>            try context.save()<br/>            completion(true)<br/>        } catch  {<br/>            completion(false)<br/>        }<br/>    }<br/>    <br/>    public func deleteExpenseItem(with id: NSManagedObjectID, completion: @escaping (Bool) -&gt; (Void)){<br/>        guard let expense = context.object(with: id) as? ExpenseItem else {<br/>            completion(false)<br/>            return<br/>        }<br/>        context.delete(expense)<br/>        do {<br/>            try context.save()<br/>            completion(true)<br/>        } catch  {<br/>            completion(false)<br/>        }<br/>    }<br/>    <br/>    public func totalExpenseAmount() -&gt; Double? {<br/>        do {<br/>            let items = try context.fetch(ExpenseItem.fetchRequest())<br/>            let total = items.reduce(0) { $0 + $1.price }<br/>            return total<br/>        } catch  {<br/>            return nil<br/>        }<br/>    }<br/>}<br/><br/>public enum ExpenseServiceErrors: Error {<br/>    case fetchError<br/>}</span></pre><p id="bcac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所示，我们的服务在<code class="fe mh mi mj mk b">ExpenseItem</code>实体上有基本的CRUD操作。为了安全地执行这些操作，我们还在费用模型中添加了一个类型为<code class="fe mh mi mj mk b">NSManagedObjectID</code>的id参数，它是为每个条目自动生成的。</p><p id="f639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要修改我们的视图模型，以利用我们服务中的函数。用下面的代码替换视图模型的内容。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="1236" class="mp mq iq mk b gy mr ms l mt mu">class ExpenseListViewModel {<br/>    <br/>    var expenseList = [Expense]()<br/>    let service: ExpenseService<br/>    <br/>    init(context: NSManagedObjectContext) {<br/>        self.service = ExpenseService(context: context)<br/>        fetchExpenses(completion: nil)<br/>    }<br/>    <br/>    public func fetchExpenses(completion: (() -&gt; Void)?){<br/>        service.fetchExpenseItems {[weak self] result in<br/>            switch result {<br/>            case .success(let expenses):<br/>                self?.expenseList = expenses.map { Expense(id: $0.objectID, title: $0.title, date: $0.date, price: $0.price) }<br/>                completion?()<br/>            case .failure(_):<br/>                print("error")<br/>            }<br/>        }<br/>    }<br/>    <br/>    public func addExpense(title: String, date: Date, price: Double, completion: @escaping () -&gt; Void){<br/>        service.addExpenseItem(title: title, date: date, price: price) {[weak self] success in<br/>            if success {<br/>                self?.fetchExpenses(completion: completion)<br/>            }<br/>        }<br/>    }<br/>    <br/>    public func deleteExpense(id: NSManagedObjectID, completion: @escaping () -&gt; Void){<br/>        service.deleteExpenseItem(with: id) {[weak self] success in<br/>            if success {<br/>                self?.fetchExpenses(completion: completion)<br/>            }<br/>        }<br/>    }<br/>    <br/>    public func updateExpense(with newExpense: Expense, completion: @escaping () -&gt; Void){<br/>        service.updateExpenseItem(with: newExpense) {[weak self] success in<br/>            if success {<br/>                self?.fetchExpenses(completion: completion)<br/>            }<br/>        }<br/>    }<br/>    <br/>}</span></pre><p id="cebf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将向ExpenseListViewController添加另一个扩展，并遵循我们的协议。将以下代码添加到viewcontroller类中。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="6c97" class="mp mq iq mk b gy mr ms l mt mu">extension ExpanseListViewController: AddUpdateExpanseDelegate {<br/>    func updateExpanse(with expense: Expense) {<br/>        viewModel.updateExpense(with: expense) {[weak self] in<br/>            self?.tableView.reloadData()<br/>        }<br/>    }<br/>    <br/>    func addNewExpanse(title: String, date: Date, price: Double) {<br/>        viewModel.addExpense(title: title, date: date, price: price) {[weak self] in<br/>            self?.tableView.reloadData()<br/>        }<br/>    }<br/>}</span></pre><p id="c3bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后改变<code class="fe mh mi mj mk b">didSelectRowAt</code>功能的内容，如下图所示。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="6e6d" class="mp mq iq mk b gy mr ms l mt mu">func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {<br/>        tableView.deselectRow(at: indexPath, animated: true)<br/>        showAlertSheet(for: viewModel.expenseList[indexPath.row])<br/>        <br/>    }<br/>    <br/>    private func showAlertSheet(for expense: Expense){<br/>        let alert = UIAlertController(title: "What to do with this expense?", message: expense.title, preferredStyle: .actionSheet)<br/>        let deleteAction = UIAlertAction(title: "Delete", style: .destructive) {[weak self] _ in<br/>            guard let strongSelf = self else { return }<br/>            strongSelf.viewModel.deleteExpense(id: expense.id) {<br/>                strongSelf.tableView.reloadData()<br/>            }<br/>        }<br/>        let editAction = UIAlertAction(title: "Edit", style: .default) { [weak self] _ in<br/>            guard let strongSelf = self else { return }<br/>            let vc = AddUpdateExpenseViewController(mode: .update, expense: expense)<br/>            vc.delegate = strongSelf<br/>            strongSelf.present(UINavigationController(rootViewController: vc), animated: true)<br/>        }<br/>        alert.addAction(UIAlertAction(title: "Dismiss", style: .cancel))<br/>        alert.addAction(editAction)<br/>        alert.addAction(deleteAction)<br/>        present(alert, animated: true)<br/>    }</span></pre><p id="2648" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜🎉。现在您有了一个漂亮的费用跟踪应用程序。现在让我们跳转到本文的主体部分，也就是<code class="fe mh mi mj mk b">AppIntents</code>。</p><h1 id="d128" class="nb mq iq bd nc nd ne nf ng nh ni nj nk jw nl jx nm jz nn ka no kc np kd nq nr bi translated">将应用意图集成到应用中</h1><p id="6827" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">在我们的应用程序中，我们将创建两个不同的应用程序意图。</p><p id="9c01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中之一是添加新的费用记录。</p><p id="0165" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个是得到我们到目前为止的总支出。</p><p id="e9f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些功能可以从快捷方式应用程序、Spotlight和Siri中访问。让我们从创建第二个意图开始。</p><p id="1c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入<code class="fe mh mi mj mk b">Intents</code>文件夹，新建一个名为<code class="fe mh mi mj mk b">ShowTotalExpense.swift</code>的Swift文件，导入<code class="fe mh mi mj mk b">AppIntents</code>框架。</p><p id="343e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何意图都可以通过遵守一个叫做<code class="fe mh mi mj mk b">AppIntent</code>的协议来创建。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="f301" class="mp mq iq mk b gy mr ms l mt mu">import AppIntents<br/><br/>struct ShowTotalExpense: AppIntent {<br/>    static var title: LocalizedStringResource = ""<br/>    func perform() async throws -&gt; some IntentResult {<br/>           return .result()<br/>    }<br/>}</span></pre><p id="ed07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以用这两个参数创建意图，这两个参数是title和以最简单的形式执行功能。如果您的perform函数需要在主线程上执行，您可以通过添加<code class="fe mh mi mj mk b">@MainActor</code>注释来实现。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="cd9e" class="mp mq iq mk b gy mr ms l mt mu">@MainActor<br/>func perform() async throws -&gt; some IntentResult {<br/>    print("You know, I am doing something on the main thread...")<br/>    return .result()<br/>}</span></pre><p id="9022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">标题参数是快捷方式编辑器中显示的参数。您可以将其设置为静态值，或者将其设置为注册到可本地化文件中的本地化键，并使用该键的值。</p><p id="d275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免这篇文章太长，我们将不讨论本地化步骤，但是您可以找到大量的资源来解释如何为您的iOS应用程序添加本地化支持。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="facb" class="mp mq iq mk b gy mr ms l mt mu">struct ShowTotalExpense: AppIntent {<br/>    static var title: LocalizedStringResource = "Show my total expense"<br/>    <br/>    func perform() async throws -&gt; some IntentResult &amp; ProvidesDialog {<br/>        let total = await getTotalExpanse()<br/>        let dialog = IntentDialog(total)<br/>        return .result(dialog: dialog)<br/>    }<br/>    <br/>    private func getTotalExpanse() async -&gt; LocalizedStringResource {<br/>        let service = await ExpenseService(context: (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext)<br/>        guard let total = service.totalExpenseAmount() else { return LocalizedStringResource(stringLiteral: "0") }<br/>        return LocalizedStringResource(stringLiteral: String(format: "%2.f", total))<br/>    }<br/>}</span></pre><p id="9999" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的意图的最终外观将如上所示。我们运行一个服务函数来获取总费用并返回它。最后，我们提供一个对话框作为运行这个意图的结果。</p><p id="5623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你用这段代码运行你的应用程序，你不会看到为你的应用程序创建的快捷方式，也不会在聚光灯下找到它，因为我们还应该告诉系统哪个<code class="fe mh mi mj mk b">AppIntents</code>对用户可用，并配置这些意图。</p><p id="043d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了保持项目的模块化，让我们在Intents文件夹中创建一个新的swift文件并命名为<code class="fe mh mi mj mk b">HarcaMAShortCuts.swift</code>。该文件将包含一个符合AppShortcutsProvider协议的结构，并将成为快捷方式的主条目。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="8dad" class="mp mq iq mk b gy mr ms l mt mu">struct HarcaMAShortCuts: AppShortcutsProvider {<br/>    static var appShortcuts: [AppShortcut] {<br/>        AppShortcut(<br/>            intent: ShowTotalExpense(),<br/>            phrases: [<br/>                "What is my total expense in \(.applicationName)?",<br/>                "Show my total expense in \(.applicationName)",<br/>                "How much did I spend in \(.applicationName)?"<br/>            ]<br/>        )<br/>    }<br/>}</span></pre><p id="24be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该结构有一个名为<code class="fe mh mi mj mk b">appShortcuts</code>的静态属性，它是一个类型为<code class="fe mh mi mj mk b">AppShortcut</code>的数组。请记住，目前我们限制一个iOS应用程序最多有10个应用程序快捷方式。在设置了意图和短语参数之后，现在我们的应用程序可以在不同的地方使用我们的<code class="fe mh mi mj mk b">AppIntent</code>。</p><p id="1bcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以添加任意数量的短语。通过在Spotlight中键入或告诉Siri，这些短语将用于触发意图的执行方法。短语数组的第一个元素将是显示给用户的元素。</p><p id="bcc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们运行我们的应用程序，看看我们的应用程序是否如预期的那样工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/eb07defae96b71b4fb4b61b465f213b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*5KufOyf99t9z3rRjxmzgig.png"/></div></figure><p id="b135" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看到了你的<code class="fe mh mi mj mk b">AppIntent</code>并获得了成功的结果，那么为自己骄傲吧！现在你已经创造了一个<code class="fe mh mi mj mk b">AppIntent</code>。</p><p id="f747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建第二个应用程序意图，它使用户能够添加新的费用项目。在Intents文件夹中创建一个名为<code class="fe mh mi mj mk b">AddExpense.swift</code>的新文件，并将下面的代码添加到其中。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="6c98" class="mp mq iq mk b gy mr ms l mt mu">struct AddExpense: AppIntent {<br/>    <br/>    static var title: LocalizedStringResource = "Add a new expense"<br/>    <br/>    @Parameter(title: "Title")<br/>    var title: String<br/>    <br/>    @Parameter(title: "Price")<br/>    var price: Double<br/>    <br/>    @Parameter(title: "Date")<br/>    var date: Date<br/>    <br/>    <br/>    func perform() async throws -&gt; some IntentResult &amp; ProvidesDialog  {<br/>        await addExpense()<br/>        let dialog = IntentDialog("Successfully added your \(title) expense!")<br/>        return .result(dialog: dialog)<br/>    }<br/>    <br/>    <br/>    private func addExpense() async {<br/>        let service = await ExpenseService(context: (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext)<br/>        service.addExpenseItem(title: title, date: date, price: price, completion: {_ in})<br/>    }<br/>    <br/>}</span></pre><p id="b4a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了标题参数和执行函数之外，这个intent还有三个输入参数。当添加到<code class="fe mh mi mj mk b">AppIntent</code>中时，我们为这种输入添加了<code class="fe mh mi mj mk b">@Parameter</code>属性包装器。</p><p id="4388" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在用于<code class="fe mh mi mj mk b">AppIntent</code>之前，每个Intent参数应符合<code class="fe mh mi mj mk b">AppEnum</code>协议。如果你想有一些自定义的数据类型，不要忘记遵守这个协议。由于我们的应用程序只使用基本数据类型，我们不需要，因为它们已经符合该协议。</p><p id="0bbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们在从用户那里获得输入(无论是通过键盘还是Siri)后，在perform函数中运行另一个服务方法。然后向用户显示一个对话框。现在我们还需要将这个意图添加到<code class="fe mh mi mj mk b">AppShortcutsProvider</code>中。</p><pre class="kg kh ki kj gt ml mk mm mn aw mo bi"><span id="bbf1" class="mp mq iq mk b gy mr ms l mt mu">struct HarcaMAShortCuts: AppShortcutsProvider {<br/>    static var appShortcuts: [AppShortcut] {<br/>        AppShortcut(<br/>            intent: ShowTotalExpense(),<br/>            phrases: [<br/>                "What is my total expense in \(.applicationName)?",<br/>                "Show my total expense in \(.applicationName)",<br/>                "How much did I spend in \(.applicationName)?"<br/>            ]<br/>        )<br/>        <br/>        AppShortcut(<br/>            intent: AddExpense(),<br/>            phrases: [<br/>                "Add a new expense to \(.applicationName)",<br/>                "Create an expense in \(.applicationName)"<br/>            ]<br/>        )<br/>    }<br/>}</span></pre><p id="5faa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行该应用程序，您将会看到我们的新意图。让我们试试它是否像预期的那样工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c10cb43223cfb5e6f070b1d1be2220f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*EZ5IsAc0HiD4IlcVkMbDpA.png"/></div></figure><p id="47b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做得好，它的工作像一个魔咒！！我们现在为用户提供了另一种方式，无需打开应用程序就可以从多个地方注册新的费用。相信我，这些功能使您的iOS应用程序更加用户友好，用户将快速完成日常任务，这对您和您的客户都有巨大的好处。</p><p id="d733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们找到了一种无需在前台启动就能与应用程序交互的方法。但是AppIntents框架允许的不止这些，您可以通过在您的<code class="fe mh mi mj mk b">AppIntent</code>结构中将<code class="fe mh mi mj mk b">openAppWhenRun</code>参数设置为true来打开您的应用程序的某些特定部分，创建定义如何填充intent参数的参数摘要并显示自定义用户界面，如SwiftUI视图，创建自定义实体并编写查询来收集它们，通过添加<code class="fe mh mi mj mk b">ReturnsResult</code>协议从intent返回结果并在另一个应用程序intent中使用该结果，等等。</p><p id="dee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在计划您将为应用程序提供的应用程序快捷方式之前，也要考虑这些限制。一个iOS应用程序不能有10个以上的应用程序快捷方式。此外，如果你想在应用程序意图中显示你的自定义视图，这些视图不能包括交互性或动画。我强烈建议你在计划你的应用意图之前考虑这些。最后，我们还应该考虑我们的应用程序快捷方式将被用户发现的方式。</p><p id="c1fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，AppIntents框架似乎是一种增加用户和应用程序之间的交互并为我们的iOS应用程序创造更多价值的绝佳方式。让我们想想我们的快捷方式，看看为iOS应用程序创建的伟大AppIntent创意。</p><p id="e658" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GitHub资源库:</p><div class="nz oa gp gr ob oc"><a href="https://github.com/sadikcoban/HarcaMA" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">GitHub - sadikcoban/HarcaMA</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq kp oc"/></div></div></a></div><h1 id="306e" class="nb mq iq bd nc nd ne nf ng nh ni nj nk jw nl jx nm jz nn ka no kc np kd nq nr bi translated"><strong class="ak"> <em class="or">参考文献</em> </strong></h1><ul class=""><li id="6931" class="ls lt iq ky b kz ns lc nt lf os lj ot ln ou lr lx ly lz ma bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/AppIntents" rel="noopener ugc nofollow" target="_blank">苹果开发者文档</a></li><li id="0a28" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2022/10032/" rel="noopener ugc nofollow" target="_blank">深入了解应用意图</a></li><li id="b9dd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2022/10170" rel="noopener ugc nofollow" target="_blank">使用应用意图实现应用快捷方式</a></li></ul></div></div>    
</body>
</html>