<html>
<head>
<title>UIKit Animations Are Messy — Here’s Why SwiftUI Can Fix That</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UIKit动画很混乱——这就是SwiftUI可以解决这个问题的原因</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/uikit-animations-are-messy-heres-why-swiftui-may-fix-it-ad1303cd0003?source=collection_archive---------7-----------------------#2021-07-01">https://betterprogramming.pub/uikit-animations-are-messy-heres-why-swiftui-may-fix-it-ad1303cd0003?source=collection_archive---------7-----------------------#2021-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="326e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">UIKit中的动画是可行的，但是SwiftUI可以使这个过程更加方便</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d55034580ad6988313f22041ea3c3ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LIbxysqWpr7jEV94"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">里卡多·维亚纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="ecdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS动画不仅感觉和外观都很棒，而且非常容易创建。所以我怎么好意思说他们“乱七八糟”呢？</p><p id="59c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，让我们回到iOS开发的早期——那时我们用Objective C编写代码，Xcode是一个有多个窗口和没有标签的IDE(实际上，Xcode 3是垃圾)——并尝试了解从那时起UIKit发生了什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b4d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你记得承诺吗？</h1><p id="f63d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一些<code class="fe mz na nb nc b">UIView</code>属性是动画的——背景颜色、框架、居中等等。</p><p id="f452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要制作一个视图的动画，你所要做的就是修改它的属性并用<code class="fe mz na nb nc b">beginAnimations</code>和<code class="fe mz na nb nc b">commitAnimations</code>函数包装它:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bd32" class="nh md it nc b gy ni nj l nk nl">UIView.beginAnimations(nil, context: nil)</span><span id="209d" class="nh md it nc b gy nm nj l nk nl">UIView.setAnimationDuration(0.2)</span><span id="ba64" class="nh md it nc b gy nm nj l nk nl">view.frame = newFrame</span><span id="cd6f" class="nh md it nc b gy nm nj l nk nl">UIView.commitAnimations()</span></pre><p id="13b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，视图帧被动画化为<code class="fe mz na nb nc b">newFrame</code>。</p><p id="588a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不能再简单了，是吗？</p><p id="9f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子的主要问题是很难将这个动画与屏幕流的其余部分同步。我们必须使用一个委托函数在动画结束时采取行动(说到古代历史，没有块或闭包)。</p><p id="e858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，开发人员需要一个完成块来将动画链接在一起或更好地控制动画事件。</p><p id="6f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，在iOS 4中，苹果给了我们一个新功能，叫做<code class="fe mz na nb nc b">UIView</code>基于块的动画。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="19ef" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">UIView基于块的动画</h1><p id="870f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有了<code class="fe mz na nb nc b">UIView</code>基于块的动画，设置动画、链接动画或与UI流的其他部分同步变得非常容易:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="729c" class="nh md it nc b gy ni nj l nk nl">UIView.animate(withDuration: 0.2) {<br/> 	self.view.frame = newFrame<br/> } completion: { finished in<br/>    self.doSomethingAtTheEnd()<br/>}</span></pre><p id="ceea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是很可爱吗？</p><p id="94ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后来，苹果增加了关键帧动画来帮助我们在应用程序中创建更复杂的动画。</p><p id="3e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是后来苹果推出了自动布局。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b67a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">自动布局</h1><p id="bba3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在iOS 6中，苹果增加了自动布局，基于块的动画变得更加复杂。</p><p id="d482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在自动布局中，我们不改变视图框架，而是改变它的一个(或多个)自动布局约束。自动布局系统基于一组被优先化的其他约束来处理框架变化。</p><p id="a191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的代码片段:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="36dc" class="nh md it nc b gy ni nj l nk nl">UIView.animate(withDuration: 0.2) {<br/>   self.leadingConstraint.constant = 50<br/>}</span></pre><p id="2304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上一个改变帧的例子不同，运行这个例子不会提供任何动画。原因是约束中的变化会导致父视图中的其他变化，因此它们将仅在接下来的UI呈现周期中应用。</p><p id="77b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，解决办法是什么呢？在动画块内部调用<code class="fe mz na nb nc b">layoutIfNeeded()</code>即可:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d7eb" class="nh md it nc b gy ni nj l nk nl">UIView.animate(withDuration: 0.2) {<br/>    self.leadingConstraint.constant = 50<br/>    self.layoutIfNeeded()<br/>}</span></pre><p id="af5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单吧？没那么快。哪个视图需要刷新其布局？动画视图还是其父视图？</p><p id="c7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为动画视图影响它的兄弟，我们需要重新布局父视图。</p><p id="5d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动布局是一个约束系统，一个约束的更改可能会影响多个视图。因此，我们需要考虑父约束的改变可能会有副作用。Errggg！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="95ed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">核心动画层和自动布局</h1><p id="1e19" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">但这并没有结束。</p><p id="98e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe mz na nb nc b">UIView</code>都基于一个<code class="fe mz na nb nc b">CALayer</code>(代表核心动画层)。</p><p id="a2bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe mz na nb nc b">UIView</code>都有一个主层，我们可以在主层上添加子层(就像子视图机制一样)。</p><p id="db5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">核心动画层允许我们为视图添加形状、渐变、阴影和更多效果。</p><p id="ab99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主<code class="fe mz na nb nc b">CALayer</code>边界总是等于它的<code class="fe mz na nb nc b">UIView</code>边界。但是子层的帧是静态的，我们需要不断更新它们以保持它们与我们的<code class="fe mz na nb nc b">UIView</code>同步。</p><p id="8def" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是覆盖系统在每个UI刷新周期中调用的<code class="fe mz na nb nc b">layoutSubviews()</code>方法(如果需要的话)。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="be3f" class="nh md it nc b gy ni nj l nk nl">override func layoutSubviews() {<br/>    super.layoutSubviews()<br/>    sublayer.frame = self.bounds<br/>}</span></pre><p id="f14c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，一方面我们在动画块内部调用<code class="fe mz na nb nc b">layoutIfNeeded()</code>。另一方面，我们在<code class="fe mz na nb nc b">layoutSubviews()</code>中更新<code class="fe mz na nb nc b">CALayer</code>帧。</p><p id="28d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感觉有点别扭，但是应该管用，不是吗？</p><p id="ba7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，没有。</p><p id="4f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎核心动画层和自动布局不能很好地协同工作。自动布局仅与<code class="fe mz na nb nc b">UIViews</code>相关。</p><p id="6506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想给用户界面添加一个独特的层，最好是基于该层创建一个<code class="fe mz na nb nc b">UIView</code>并将其添加到视图层次结构中。</p><p id="94fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，忘记正在被很好地转换的<code class="fe mz na nb nc b">CALayers</code>的层次结构。创建一个专用的<code class="fe mz na nb nc b">UIView</code>并将其连接到自动布局系统。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="469a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么我们需要动画？</h1><p id="3a88" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这一点上，我们应该已经理解了UIKit动画的一些不正常的工作。自动布局不能很好地适应，而且<code class="fe mz na nb nc b">CALayer</code>问题让我们头疼。</p><p id="2cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们需要问自己:动画的目的到底是什么？</p><p id="1152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟，我们不是在经营皮克斯或迪士尼工作室。</p><p id="8629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动画不仅仅是为了好看。它们还提供了一种向用户反映UI状态变化的好方法。</p><p id="39df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，大多数动画就是这样做的——向用户表达屏幕上发生了什么变化。</p><p id="a3d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个新的屏幕从底部弹出，应该是有原因的。屏幕之间的转换为用户提供了他们从哪里来以及应该返回哪里的上下文。</p><p id="5e20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI作为一个声明式框架，自然地处理状态变化，并负责响应数据更新、按钮按下等等。</p><p id="07bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们用动画包装了这些状态变化，我们实际上解决了我刚才提到的关于UIKit的大部分陷阱。</p><p id="c496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI等声明式框架似乎与动画齐头并进，可以快速实现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0299" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如果我不用SwiftUI呢？</h1><p id="0f75" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管UIKit不是一个声明式框架，但我们可以从SwiftUI借鉴一些原则或思想。</p><p id="9354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用视图模型创建自己的状态，并在每次状态更新时“刷新”屏幕。</p><p id="27e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着将会有一个地方并且只有一个地方所有的约束或显示的数据被修改。</p><p id="99b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们用动画块包装了“刷新”代码，我们可能会获得类似于SwiftUI中存在的用户体验——UI和状态之间的直接匹配，动画效果很好。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d9bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="89a4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我知道UIKit中的动画对于一些开发者来说似乎非常方便，并且可能被认为是自奥利奥冰淇淋以来人类发生的最好的事情。</p><p id="da49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人觉得很乱，和其他iOS库比如自动布局或者核心图形不同步。</p><p id="2ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为SwiftUI解决了这些问题中的大部分，即使它没有解决，它也可以教会我们如何在我们当前的UIKit代码库中更好地处理它。</p></div></div>    
</body>
</html>