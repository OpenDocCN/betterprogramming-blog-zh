<html>
<head>
<title>Learn Generics in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中学习泛型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/generics-in-swift-2cd549c53075?source=collection_archive---------3-----------------------#2022-11-22">https://betterprogramming.pub/generics-in-swift-2cd549c53075?source=collection_archive---------3-----------------------#2022-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5535" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">知道它是什么，如何使用它们，何时使用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/eb4f348ef27abc35983cf895618bdcca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*E1P8Z-_oCdOjhDEdOJt8WQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><h1 id="e701" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">什么是泛型？</h1><p id="ecb0" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">泛型编程是一种在维护类型安全的同时编写可重用代码的技术。这是一种叫做“参数多态性”的多态性多态性意味着使用一个接口或名称来处理多种类型。</p><p id="16ff" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">主要有三种不同类型的多态性:</p><ul class=""><li id="5590" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated">即席多态性。我们可以定义多个同名但类型不同的函数，称为临时多态。</li><li id="9658" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">亚型多态性。如果一个函数期望一个C类，我们也可以传入C的一个子类，这叫做子类型多态性。</li><li id="88e3" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">参数多态性。如果一个函数有一个泛型参数，我们可以用不同的类型传递它。这被称为参数多态性。</li></ul><h1 id="d138" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">为什么我们需要泛型</h1><p id="6ed6" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">原因之一是代码少。与其这样写:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="4012" class="nd ks iq mz b be ne nf l ng nh">func square(value: Int) -&gt; Int{…}<br/>func square(value: Double) -&gt; Double {…}<br/>func square(value: Float) -&gt; Float {…}</span></pre><p id="9689" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们可以这样写:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="afea" class="nd ks iq mz b be ne nf l ng nh">func square&lt;T&gt;(value: T) -&gt; T {…}</span></pre><p id="6c5b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这样，我们可以编写单个函数，而不是编写多个函数来处理不同的参数类型(函数重载)。这里<code class="fe ni nj nk mz b">T</code>代表类型。你可以把任何东西放在那里；不一定是<code class="fe ni nj nk mz b">T</code>，我们放什么也没关系。该功能也可以定义为:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="842b" class="nd ks iq mz b be ne nf l ng nh">func square&lt;PutAnythingHere&gt;(value: PutAnythingHere) -&gt; PutAnythingHere {…}</span></pre><p id="2cb1" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这意味着如果你传递一个类型为<code class="fe ni nj nk mz b">x</code>的对象给这个函数，它将返回一个类型为<code class="fe ni nj nk mz b">x</code>的对象。</p><h1 id="25cf" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">为什么不用呢？</h1><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="157f" class="nd ks iq mz b be ne nf l ng nh">func square(value: Any) -&gt; Any{}</span></pre><p id="3c8d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这不好，也不会起作用，因为我们可以传递任何类型，也可以返回任何类型，这没有意义。</p><p id="f5c0" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们使用泛型来表达和限制一个类使用哪种类型。例如，当我们声明一个数组时，我们这样声明它:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="7e5a" class="nd ks iq mz b be ne nf l ng nh">var arr: Array&lt;Int&gt;<br/>arr = [1,2,3,4,5]</span></pre><p id="c273" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这意味着<code class="fe ni nj nk mz b">arr</code>是一个整数数组。这样，我们就不能在这个数组中插入除整数以外的任何东西。我们可以定义一个整数数组，因为array有一个如下定义的泛型类型:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="0005" class="nd ks iq mz b be ne nf l ng nh">public struct Array&lt;Element&gt; {…}</span></pre><p id="b10a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果您真的想要一个可以容纳任何项目的异构数组，那么您可以将其定义为:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="8608" class="nd ks iq mz b be ne nf l ng nh">var arr: Array&lt;Any&gt;<br/>arr = [1, “Two”, 5.8, Car(), Calendar(), OperationQueue()]</span></pre><p id="4385" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这是你应该避免的事情，除非你真的知道你在做什么，因为它可能会打开一个蠕虫的罐子。原因是如果你想使用数组中的元素，你需要像这样强制展开它们:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="4df8" class="nd ks iq mz b be ne nf l ng nh">var obj0 = arr[0] as! Int<br/>var obj1 = arr[1] as! String<br/>var obj2 = arr[2] as! Double<br/>var obj3 = arr[3] as! Car<br/>var obj4 = arr[4] as! Calendar<br/>var obj5 = arr[5] as! OperationQueue</span></pre><p id="8b5f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">你看这是多么有问题和危险。感觉你的app随时可能崩溃。像这样简单的代码可能会导致崩溃:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="88d0" class="nd ks iq mz b be ne nf l ng nh">var obj0 = arr[0] as! String</span></pre><pre class="nl my mz na bn nb nc bi"><span id="2f9e" class="nd ks iq mz b be ne nf l nm nh">error: Execution was interrupted, reason: signal SIGABRT.<br/>Could not cast value of type ‘Swift.Int’ (0x1b9ac80b8) <br/>to ‘Swift.String’ (0x1b9ac6258).</span></pre><p id="a778" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">因此，在创建数组时，请坚持使用泛型类型。</p><h1 id="4af5" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">如果我们想处理特定类型的子集呢？</h1><p id="2be5" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们上面的square函数是有问题的，因为我们可以传递任何类型给它。如果我们传递一个字符串呢？</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="5841" class="nd ks iq mz b be ne nf l ng nh">func square&lt;T&gt;(value: T) -&gt; T {…}<br/>square(“Some string here”)</span></pre><p id="69d4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">字符串没有方块，所以这没有任何意义。我们需要将泛型进一步限制为数字类型，如下所示:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="71eb" class="nd ks iq mz b be ne nf l ng nh">func square&lt;T: Numeric&gt;(value: T) -&gt; T {…}</span></pre><p id="1fc4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这样，我们只能传递类型符合数字协议的值。我们知道所有的数值都有平方，所以我们的函数现在有了正确的限制，没有人可以传递没有意义的东西。如果我们试图把它叫做:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="aeb5" class="nd ks iq mz b be ne nf l nm nh">square(“Some string here”)</span></pre><p id="3d54" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">编译器在下面给出了这个错误，并且不允许它发生:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="07a3" class="nd ks iq mz b be ne nf l nm nh">function ‘square(value:)’ requires that ‘String’ conform to ‘Numeric’</span></pre><p id="7afa" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们通过将泛型类型限制为符合协议来限制它。我们也可以使用一个类，将泛型类型限制为特定类的子类。</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="90e2" class="nd ks iq mz b be ne nf l ng nh"><br/>class SomeClass {<br/> var name: String = “class name”<br/>}<br/><br/>func printClassName&lt;T: SomeClass&gt;(value: T) {<br/> print(value.name)<br/>}<br/><br/>class SomeSubClass: SomeClass {}<br/><br/>printClassName(value: SomeSubClass())<br/>//prints:<br/>//class name</span></pre><h1 id="7e6c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">更大范围内的泛型</h1><p id="33b9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">函数和方法不是唯一的泛型类型。我们也可以有泛型结构、类和枚举。</p><h2 id="f02f" class="nn ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated"><strong class="ak">例1 </strong></h2><p id="a46e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们创建一个使用泛型类型的堆栈结构。我们需要用一个我们命名为<code class="fe ni nj nk mz b">Object</code>的类型来定义这个堆栈，所以我们只能用同一个类型来定义<code class="fe ni nj nk mz b">push</code>、<code class="fe ni nj nk mz b">pop</code>和<code class="fe ni nj nk mz b">peek </code>。</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="1721" class="nd ks iq mz b be ne nf l ng nh"><br/>struct Stack&lt;Object&gt; {<br/> private var objects: [Object] = []<br/> <br/> mutating func push(object: Object) {<br/>   objects.append(object)<br/> }<br/> <br/> mutating func pop() -&gt; Object? {<br/>   return objects.popLast()<br/> }<br/> <br/> func peek() -&gt; Object? {<br/>   return objects.last<br/> }<br/>}</span></pre><p id="fee4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这里我们定义了一个struct，它应该有一个预定义的对象类型。例如，一个函数堆栈将是这样的:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="9e8b" class="nd ks iq mz b be ne nf l ng nh">typealias Work = () -&gt; Void<br/>var stack: Stack&lt;Work&gt; = Stack()<br/>stack.push {…}</span></pre><p id="ca90" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这里，我们将堆栈限制为一个<code class="fe ni nj nk mz b">Work</code>函数堆栈。我们只能将函数压入堆栈，特别是别名为<code class="fe ni nj nk mz b">Work</code>的函数，它不接收任何参数，也不返回任何内容。我们可以这样调用堆栈中的函数:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="17e1" class="nd ks iq mz b be ne nf l ng nh">while let work = stack.pop() {<br/> work()<br/>}</span></pre><h2 id="1038" class="nn ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated"><strong class="ak">例2 </strong></h2><p id="c1f3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们创建一个SwiftUI <code class="fe ni nj nk mz b">View</code>，它接收另一个<code class="fe ni nj nk mz b">View</code>作为子视图。SwiftUI中的<code class="fe ni nj nk mz b">View</code>是一个协议，所以我们需要定义一个符合<code class="fe ni nj nk mz b">View</code>协议的struct，并将一个子视图作为同样符合<code class="fe ni nj nk mz b">View</code>协议的泛型类型传递。</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="aa09" class="nd ks iq mz b be ne nf l ng nh">struct SomeView&lt;Content: View&gt;: View {<br/> let subview: Content<br/> var body: some View {<br/>   subview<br/> }<br/>}</span></pre><p id="8f34" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们可以通过传递一个<code class="fe ni nj nk mz b">Text</code>或一个<code class="fe ni nj nk mz b">Image</code>作为子视图来创建一个<code class="fe ni nj nk mz b">SomeView</code>的实例，因为<code class="fe ni nj nk mz b">Text</code>和<code class="fe ni nj nk mz b">Image</code>都符合<code class="fe ni nj nk mz b">View</code>协议，就像这样:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="0976" class="nd ks iq mz b be ne nf l ng nh">let someView = SomeView(subview: Text("some text…"))<br/>let anotherView = SomeView(subview: Image("some_image"))</span></pre><h2 id="f2b5" class="nn ks iq bd kt no np dn kx nq nr dp lb ls ns nt ld lw nu nv lf ma nw nx lh ny bi translated"><strong class="ak">例3 </strong></h2><p id="76ec" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">以下是Swift中<code class="fe ni nj nk mz b">Optional</code>的定义:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="b4a3" class="nd ks iq mz b be ne nf l ng nh">enum Optional&lt;Wrapped&gt; { <br/> case none <br/> case some(Wrapped)<br/>}</span></pre><p id="d36c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe ni nj nk mz b">Optional</code>是通用类型。当我们为Wrapped选择一个值时，我们得到一个具体的类型。比如可选的&lt; Int &gt;或者可选的&lt; UIView &gt;都是具体类型。</p><p id="2bde" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当我们想把一个泛型类型转换成一个具体类型时，我们必须为每个泛型参数选择一个具体类型。</p><p id="aaa6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在整个Swift标准库中使用泛型。例如:</p><ul class=""><li id="d5d9" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated">像数组、集合和字典这样的集合。</li><li id="ed54" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated"><code class="fe ni nj nk mz b">Optional</code>使用通用参数对其包装类型进行抽象。</li><li id="1c7d" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated"><code class="fe ni nj nk mz b">Result</code>有两个通用参数——一个代表成功的值，另一个代表错误。</li><li id="7fb0" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated"><code class="fe ni nj nk mz b">Unsafe[Mutable]Pointer</code>是它所指向的内存类型的总称。</li><li id="f1f6" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">路径在其根类型和结果值类型上都是通用的。</li></ul><h1 id="4242" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">具有关联类型的协议</h1><p id="bb50" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">关联类型是用作协议一部分的类型的占位符名称。关联类型的实际类型直到协议被采用后才被指定。它是在协议中声明的泛型类型。这就是我们如何在协议中使用泛型。</p><p id="b476" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果我们想定义我们的<code class="fe ni nj nk mz b">Stack</code>协议而不是一个结构，该怎么办？让我们试试。如果我们写下下面一行:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="bdd8" class="nd ks iq mz b be ne nf l ng nh">protocol Stack&lt;Object&gt;</span></pre><p id="9877" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">编译器给出这个错误，并告诉我们如何在协议中使用泛型。以下是消息:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="20e9" class="nd ks iq mz b be ne nf l nm nh">An associated type named ‘Object’ must be declared in the protocol ‘Stack’ <br/>or a protocol it inherits</span></pre><p id="348f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">那么，我们如何将堆栈定义为一个协议呢？像这样:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="ecb9" class="nd ks iq mz b be ne nf l ng nh">protocol Stack {<br/> associatedtype Object<br/> <br/> mutating func push(object: Object)<br/> mutating func pop() -&gt; Object?<br/> func peek() -&gt; Object?<br/>}</span></pre><p id="153c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">唯一不同的是，我们没有将其定义为<code class="fe ni nj nk mz b">protocol Stack&lt;Object&gt; {…}</code>，而是将其定义为<code class="fe ni nj nk mz b">protocol Stack { associatedtype Object }</code>。现在，让我们创建一个符合<code class="fe ni nj nk mz b">Stack</code>协议的<code class="fe ni nj nk mz b">Stack</code>结构。</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="8c16" class="nd ks iq mz b be ne nf l ng nh"><br/>struct WorkStack: Stack {<br/>  typealias Object = Work<br/>  private var objects: [Work] = []<br/> <br/>  mutating func push(object: @escaping Work) {<br/>   objects.append(object)<br/>  }<br/>  <br/>  mutating func pop() -&gt; Work? {<br/>   return objects.popLast()<br/>  }<br/>   <br/>  func peek() -&gt; Work? {<br/>   return objects.last<br/>  }<br/>}</span></pre><p id="fd04" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在<code class="fe ni nj nk mz b">WorkStack</code>中，我们可以删除typealias行，因为编译器可以从函数声明中推断出关联的类型，并理解关联的类型是<code class="fe ni nj nk mz b">Work</code>。所以，我们可以这样定义它:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="cc68" class="nd ks iq mz b be ne nf l ng nh">struct WorkStack: Stack {<br/> private var objects: [Work] = []<br/> <br/> mutating func push(object: @escaping Work) {<br/>   objects.append(object)<br/> }<br/> <br/> mutating func pop() -&gt; Work? {<br/>   return objects.popLast()<br/> }<br/> <br/> func peek() -&gt; Work? {<br/>   return objects.last<br/> }<br/>}<br/><br/>//We can create an instance of WorkStack and use it like this:<br/>var workStack = WorkStack()<br/>workStack.push {…}<br/>while let work = workStack.pop() {<br/> work()<br/>}</span></pre><p id="fdad" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们可以创建符合<code class="fe ni nj nk mz b">Stack</code>协议的其他栈，如<code class="fe ni nj nk mz b">IntStack</code>、<code class="fe ni nj nk mz b">StringStack</code>、<code class="fe ni nj nk mz b">CarStack</code>等。，就像我们上面做的那样。但是如果我们想要创建一个符合<code class="fe ni nj nk mz b">Stack</code>协议的通用堆栈，它可以是任何特定类型的堆栈，该怎么办呢？我们可以这样实现它:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="b187" class="nd ks iq mz b be ne nf l ng nh">struct MyStack&lt;Item&gt;: Stack {<br/> private var objects: [Item] = []<br/> <br/> mutating func push(object: Item) {<br/>   objects.append(object)<br/> }<br/> <br/> mutating func pop() -&gt; Item? {<br/>   return objects.popLast()<br/> }<br/> <br/> func peek() -&gt; Item? {<br/>   return objects.last<br/> }<br/>}<br/> <br/>//With MyStack, we can create a stack of any type.<br/>var carStack = MyStack&lt;Car&gt;()<br/>carStack.push(Car())</span></pre><p id="209d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这太棒了。现在我们可以创建任何类型的堆栈。如果我们扩展一个现有的类来符合一个带有关联类型的协议会怎么样？例如，扩展数组以符合<code class="fe ni nj nk mz b">Stack</code>协议。我们可以这样做:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="9a06" class="nd ks iq mz b be ne nf l ng nh">extension Array: Stack {<br/> mutating func push(object: Element) {<br/>   self.append(object)<br/> }<br/> <br/> mutating func pop() -&gt; Element? {<br/>   return self.popLast()<br/> }<br/> <br/> func peek() -&gt; Element? {<br/>   return self.last<br/> }<br/>}</span></pre><p id="2cb8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">上面，我们使用数组的通用类型<code class="fe ni nj nk mz b">Element</code>作为<code class="fe ni nj nk mz b">Stack</code>协议的关联类型<code class="fe ni nj nk mz b">Object</code>。编译器推断<code class="fe ni nj nk mz b">Array.Element == Stack.Object</code>。记住<code class="fe ni nj nk mz b">Array</code>和<code class="fe ni nj nk mz b">Stack</code>是如何声明的:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="b5c1" class="nd ks iq mz b be ne nf l ng nh">public struct Array&lt;Element&gt; {…}<br/>protocol Stack { <br/> associatedtype Object <br/> …<br/>}</span></pre><h1 id="0578" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">具有主要关联类型的协议</h1><p id="1bd2" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果我们将一堆<code class="fe ni nj nk mz b">Work</code>实例传递给一个函数会怎么样？如果我们写下面的代码会发生什么？(关键词<code class="fe ni nj nk mz b">inout</code>是修改我们传递的栈，与我们的主题无关)。</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="6cb3" class="nd ks iq mz b be ne nf l ng nh">func executeStack(stack: inout Stack) {<br/>  ...<br/>}</span></pre><p id="77ac" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们得到这个错误:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="53da" class="nd ks iq mz b be ne nf l nm nh">Use of protocol ‘Stack’ as a type must be written ‘any Stack’</span></pre><p id="a579" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这里我们可以使用<code class="fe ni nj nk mz b">any</code>或者<code class="fe ni nj nk mz b">some</code>关键字。这两者的区别是另一个话题。如果我们把它写成<code class="fe ni nj nk mz b">some Stack</code>，它意味着符合协议<code class="fe ni nj nk mz b">Stack</code>的东西。让我们试着像这样调用函数:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="e6d6" class="nd ks iq mz b be ne nf l ng nh">func executeStack(stack: inout some Stack) {<br/> while let work = stack.pop() {<br/>   work()<br/> }<br/>}</span></pre><p id="9ce9" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">对于上面的代码，编译器给出以下错误:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="1dba" class="nd ks iq mz b be ne nf l nm nh">Cannot call value of non-function type ‘(some Stack).Object’</span></pre><p id="a4e7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这很容易理解，因为编译器不知道堆栈中的项目是它可以调用的“函数”。为了让编译器明白，我们需要像这样声明它:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="06ba" class="nd ks iq mz b be ne nf l ng nh">func executeStack&lt;T: Stack&gt;(stack: inout T) where T.Object == Work {<br/> while let work = stack.pop() {<br/>   work()<br/> }<br/>}</span></pre><p id="4bae" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">上面，我们告诉编译器参数栈符合<code class="fe ni nj nk mz b">Stack</code>协议，其中它的<code class="fe ni nj nk mz b">Object</code>，是<code class="fe ni nj nk mz b">Work</code>的一个实例。这个可以，但是有点丑。我们也可以这样定义(有一个条件):</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="52ed" class="nd ks iq mz b be ne nf l ng nh">func executeStack(stack: inout some Stack&lt;Work&gt;){<br/> while let work = stack.pop() {<br/>   work()<br/> }<br/>}</span></pre><p id="a326" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">条件是我们需要声明我们的<code class="fe ni nj nk mz b">Stack</code>协议的主要关联类型，就像这样:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="5e69" class="nd ks iq mz b be ne nf l ng nh">protocol Stack&lt;Object&gt; {<br/> associatedtype Object<br/> …<br/>}</span></pre><p id="078e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">上面，<code class="fe ni nj nk mz b">Stack&lt;Object&gt;</code>告诉编译器<code class="fe ni nj nk mz b">Object</code>是<code class="fe ni nj nk mz b">Stack</code>协议的主要关联类型。</p><p id="a253" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">假设我们想合并两个堆栈。下面是我们如何声明这样做的函数:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="8d2e" class="nd ks iq mz b be ne nf l ng nh">func merge&lt;Item&gt;(stack1: some Stack&lt;Item&gt;, <br/> stack2: some Stack&lt;Item&gt;) -&gt; some Stack&lt;Item&gt; {<br/> …<br/> return mergedStack<br/>}</span></pre><h1 id="9b87" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">带有Where子句的扩展</h1><p id="731d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们在上面的例子中使用了where子句，这是不必要的，因为我们有一个使用主关联类型的更好的替代方法，上下文扩展需要where子句。</p><p id="8511" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">假设我们想为我们的<code class="fe ni nj nk mz b">MyStack</code>编写一个扩展来添加编码自身的功能。也许我们想把它保存到磁盘上。要进行编码，堆栈及其项目必须符合<code class="fe ni nj nk mz b">Encodable</code>协议。我们是这样定义的:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="fb61" class="nd ks iq mz b be ne nf l ng nh">extension MyStack: Encodable where Item: Encodable {<br/> func encode() -&gt; Data? {<br/>   try? JSONEncoder().encode(self)<br/> }<br/>}</span></pre><p id="4d1d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如您所见，我们使用了<code class="fe ni nj nk mz b">where</code>子句将关联类型限制为可编码。因此，这个扩展只适用于它们和它们的项目可编码的<code class="fe ni nj nk mz b">MyStack</code>实例。对于所有其他人来说，这个扩展是不存在的。</p><p id="6cd0" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">例如，因为<code class="fe ni nj nk mz b">String</code>符合<code class="fe ni nj nk mz b">Encodable</code>协议，我们可以这样使用它:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="5f23" class="nd ks iq mz b be ne nf l ng nh">var stringStack = MyStack&lt;String&gt;()<br/>stringStack.push(object: “a string”)<br/>print(stringStack.encode())</span></pre><pre class="nl my mz nz oa aw ob bi"><span id="d8e3" class="nn ks iq mz b gy oc od l nm nh">prints: Optional(20 bytes)</span></pre><p id="16c3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">有时，我们可能需要关联的类型是一个特定的类型，而不是遵循一个协议。例如，如果我们只想为关联类型为<code class="fe ni nj nk mz b">Work</code>的堆栈编写一个扩展，我们可以这样声明:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="b45a" class="nd ks iq mz b be ne nf l ng nh">extension MyStack where Item == Work {<br/> mutating func execute() {<br/>   while let work = self.pop() {<br/>     work()<br/>   }<br/> }<br/>}</span></pre><p id="ebcb" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">从Swift 5.7开始，也可以使用尖括号来编写:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="3277" class="nd ks iq mz b be ne nf l ng nh">extension MyStack&lt;Work&gt; {<br/> mutating func execute() {<br/>   while let work = self.pop() {<br/>     work()<br/>   }<br/> }<br/>}</span></pre><p id="203e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">where子句可以有多种限制。大概是这样的:</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="9975" class="nd ks iq mz b be ne nf l ng nh">extension Foo where T: Sequence, T.Element == Character {<br/> func specialCaseFoo() { … }<br/>}</span></pre><h1 id="85b1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">泛型类型别名</h1><p id="c609" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">泛型类型别名允许您为现有的标称泛型类型提供名称，或者为非标称类型(例如元组、函数等)提供名称。)和泛型参数。</p><pre class="kg kh ki kj gt my mz na bn nb nc bi"><span id="f890" class="nd ks iq mz b be ne nf l ng nh">typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br/>typealias DictionaryOfStrings&lt;T : Hashable&gt; = Dictionary&lt;T, String&gt;<br/>typealias IntFunction&lt;T&gt; = (T) -&gt; Int<br/>typealias Vec3&lt;T&gt; = (T, T, T)<br/>typealias BackwardTriple&lt;T1,T2,T3&gt; = (T3, T2, T1)</span></pre><h1 id="1fb1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">实施细节</h1><p id="687c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">关于Swift中泛型的实现细节，可以看<a class="ae oe" href="https://www.youtube.com/watch?v=ctS8FzqcRug" rel="noopener ugc nofollow" target="_blank">这个</a>视频。</p></div></div>    
</body>
</html>