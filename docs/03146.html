<html>
<head>
<title>What Is a Decorator in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的装饰器是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-a-decorator-in-javascript-a098a243ff16?source=collection_archive---------4-----------------------#2020-01-23">https://betterprogramming.pub/what-is-a-decorator-in-javascript-a098a243ff16?source=collection_archive---------4-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用装饰者来清理和简化你的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/28a484aa18b71d46513bc18c6540fca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OwtS7Vl2vPCIJa49"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kadh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kira auf der Heide </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你用JavaScript写一个类的时候，你可能不得不向类中的方法添加更多的特性。但有时它们看起来又脏又乱。</p><p id="e6e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何能让过程更优雅？在这篇文章中，我将谈论一个很有前途的功能，装饰。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="243c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">阅读前</h1><p id="4b4d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这项功能不包括在最新的ECMA-262中，换句话说，是JavaScript。在你的项目中，你应该经常使用巴别塔。</p><p id="967c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装修人员的提议目前处于第二阶段。你可以在<a class="ae ky" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看这个提议。</p><p id="d7d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这篇文章中附上的例子是用<a class="ae ky" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank"> JSFiddle </a>编写的，采用了巴别塔+ JSX的配置。如果你想在你的项目中使用这个特性，你应该自己建立Babel。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2a78" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">没有室内装潢师</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个类<code class="fe nb nc nd ne b">Medium</code>，在其构造函数中使用作者的名字。有一个函数返回作者的名字。</p><p id="0c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个<code class="fe nb nc nd ne b">Medium</code>类型的属性。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="fae5" class="nj md it ne b gy nk nl l nm nn">const medium = new Medium('Jane');</span><span id="76bc" class="nj md it ne b gy no nl l nm nn">const fakeMedium = {<br/>  writer: 'Fake Jane',<br/>  getWriter: medium.getWriter,<br/>};</span></pre><p id="d898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">medium</code>是使用<code class="fe nb nc nd ne b">Medium</code>的构造函数创建的，不像<code class="fe nb nc nd ne b">fakeMedium</code>是一个对象文字。但是和<code class="fe nb nc nd ne b">medium</code>有着相同的属性。</p><p id="e47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们比较一下<code class="fe nb nc nd ne b">getWriter</code>的结果。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="23a9" class="nj md it ne b gy nk nl l nm nn">medium.getWriter(); // Jane<br/>fakeMedium.getWriter(); // Fake Jane</span></pre><p id="f557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">价值观为什么不一样？</p><p id="ae5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为JavaScript的普通函数<code class="fe nb nc nd ne b">this</code>被绑定到实际调用该函数的对象上。</p><p id="f8ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">medium.getWriter()</code>被<code class="fe nb nc nd ne b">medium</code>对象调用，然而<code class="fe nb nc nd ne b">fakeMedium.getWriter()</code>被<code class="fe nb nc nd ne b">fakeMedium</code>调用。因此，函数<code class="fe nb nc nd ne b">getWriter</code>中的<code class="fe nb nc nd ne b">this</code>从<code class="fe nb nc nd ne b">fakeMedium</code>中查找值。</p><p id="240c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/better-programming/javascript-whats-the-difference-between-normal-and-arrow-functions-74c367324ae1" rel="noopener">本文</a>概述了普通函数和箭头函数的区别。</p><p id="e1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得与调用<code class="fe nb nc nd ne b">medium.getWriter</code>时相同的结果，让我们使用<code class="fe nb nc nd ne b">Object.defineProperty</code>。<code class="fe nb nc nd ne b">Object.defineProperty</code>所做的是在对象上定义新的属性或者修改对象的现有属性，然后它返回对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="38b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当<code class="fe nb nc nd ne b">fakeMedium.getWriter</code>被调用时，<code class="fe nb nc nd ne b">Access to getWriter</code>就会被打印两次。但是为什么两次？</p><ol class=""><li id="755a" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">当您调用<code class="fe nb nc nd ne b">fakeMedium.getWriter()</code>时，它的getter-mode被检测到并运行定制的<code class="fe nb nc nd ne b">get</code>方法。</li><li id="bd38" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">在<code class="fe nb nc nd ne b">get</code>方法内部，<code class="fe nb nc nd ne b">getWriter</code>被<code class="fe nb nc nd ne b">medium</code> — <code class="fe nb nc nd ne b">this.getWriter.bind(medium)</code>新绑定。这里的<code class="fe nb nc nd ne b">this</code>是指<code class="fe nb nc nd ne b">fakeMedium</code>本身。所以和<code class="fe nb nc nd ne b">fakeMedium.getWriter.bind(medium)</code>一样。这就是它的<code class="fe nb nc nd ne b">get</code>再次被调用的原因。</li><li id="98d3" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">但是在函数绑定之前，<code class="fe nb nc nd ne b">isDefining</code>被设置为true，所以在<em class="od"> if-condition </em>下的代码不会被执行，直到<code class="fe nb nc nd ne b">isDefining</code>再次被设置回false。</li></ol><p id="a2f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这种方式真的很讨厌。因为每做一个<code class="fe nb nc nd ne b">Medium</code>的新实例，都要再做一次这个。</p><p id="b5bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能用更优雅的方式吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9775" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">和一个装潢师</h1><p id="cc2d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">任何函数都可以是装饰器。基本上，你可以为一个类或者类中的一个方法使用装饰器。它有三个参数——<em class="od">目标</em>、<em class="od">值</em>和<em class="od">描述符</em>。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="a511" class="nj md it ne b gy nk nl l nm nn">function decorator(target, value, descriptor) {}</span></pre><ol class=""><li id="37d3" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b">target</code>指该类或该类的原型。</li><li id="d688" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b">value</code>是类的<code class="fe nb nc nd ne b">undefined</code>，是方法的方法名。</li><li id="4a1c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b">descriptor</code>是一个包含对象上可定义属性的对象——比如<em class="od">可配置</em>、<em class="od">可写</em>、<em class="od">可枚举</em>和<em class="od">值</em>。一节课就<code class="fe nb nc nd ne b">undefined</code>了。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">decorator与at符号(<code class="fe nb nc nd ne b">@</code>)一起使用，带有您将用作decorator的函数的名称——正如我刚才解释的，它需要三个参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ad67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">descriptor.value</code>是您放置装饰函数的函数名——在本例中，它是<code class="fe nb nc nd ne b">getWriter</code>本身。</p><p id="ff95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe nb nc nd ne b">autobind</code>的返回值是一个新对象，那么<code class="fe nb nc nd ne b">getWriter</code>将返回值应用到它的环境中。</p><p id="b3c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用decorators的好处在于它们是可重用的。在定义装饰函数之后，你需要做的只是在函数上写<code class="fe nb nc nd ne b">@autobind</code>。</p><p id="be38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是另一个将类成员属性设为只读的例子，这甚至更简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="cdc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，通过将<code class="fe nb nc nd ne b">writable</code>属性设置为<code class="fe nb nc nd ne b">false</code>来更改属性的描述符，如此而已。非常简单。对吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3245" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">完整代码比较</h1><p id="c6ec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是完整代码的对比。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">不带</strong>装饰器</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">用</strong>装饰器</p></figure><p id="d13d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自己试试吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aca0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e618" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">装饰师是非常有用的，强大的，令人惊讶的，非凡的。老实说，我看不出有任何理由拒绝使用这个令人敬畏的功能。</p><p id="fc56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，请记住，它仍然处于第二阶段，我在这篇文章中使用的方式更像巴别尔的风格，而不是目前提出的第二阶段。所以，事情可能会有所不同，比如如何使用它或者你实际上可以用它做什么。</p><p id="79fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我绝对推荐你在你的项目中使用这个特性和合适的Babel配置，但是我也想提到在TC39中关注这个特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2a31" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="a56f" class="np nq it lb b lc mu lf mv li oe lm of lq og lu oh nv nw nx bi translated"><a class="ae ky" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank">TC39</a>中的装饰提案</li><li id="8661" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oh nv nw nx bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank">MDN中的object . define property</a></li><li id="2de4" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oh nv nw nx bi translated"><a class="ae ky" href="https://github.com/andreypopp/autobind-decorator/blob/master/src/index.js" rel="noopener ugc nofollow" target="_blank">Github上的auto bind-decorator</a></li></ul></div></div>    
</body>
</html>