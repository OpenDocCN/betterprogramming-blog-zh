<html>
<head>
<title>How to Increase a SwiftUI View's Internal Reusability and Maintenance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高SwiftUI视图的内部可重用性和可维护性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-increasing-a-view-internal-reusability-and-maintenance-the-power-of-viewbuilders-26805714103?source=collection_archive---------11-----------------------#2022-06-02">https://betterprogramming.pub/swiftui-increasing-a-view-internal-reusability-and-maintenance-the-power-of-viewbuilders-26805714103?source=collection_archive---------11-----------------------#2022-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="49e2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">视图构建器的力量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3048101457b4f05380fde515b1dfe27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fmll-DjdD3NqXJHb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sigun?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿尔迪·斯贡</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="21d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI最强的一点是，由于其声明式的定义方式，以及仅用几行代码编写复杂接口的便利性，它能够使任何视图/组件在其插入的任何可能的上下文中完全可重用。此外，你可以通过预览实时检查结果。</p><p id="4688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是想象一下下面的场景:你有多个内容有点相似的屏幕，保留它们会增加重复代码的数量。</p><p id="cb56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等，但是在这种情况下，将公共部分转换成可重用的视图还不够吗？好吧，如果两个场景的整个公共代码部分是相同的，那会是这样，但是如果我们在每个内容的中间有一些不同的UI部分呢？</p><p id="2e31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让您理解，我将举例说明以下场景:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/5d1064e1961beccd558ffe1e4c717d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yOa-e5KVuqXGEEjRrJ9XQ.jpeg"/></div></div></figure><p id="88cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面我们有三个场景:第一个场景对应于一个简单的个人信息处方集，第二个场景对应于一个招聘过程，最后一个场景对应于一个健康计划。</p><p id="33dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">三个不同的上下文，尽管界面有点类似，除了不同的标题和可用性标题视图，只显示健康计划。如果我们可以从外部定义我们应该遵循的上下文，那不是很实际吗？</p><h1 id="7a61" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">识别上下文之间的差异</h1><p id="d410" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了使该视图可重用，我们应该首先确定该视图中哪些UI是可定制的。</p><p id="6225" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，在不同的场景中，有两个地方可能会有所不同，即顶部标题和可用性标题，它们可能存在，也可能不存在:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/d591de62d16f3413487b58e65ff936ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kFCMLnJciyEdXE8c3s_Aw.jpeg"/></div></div></figure><p id="c1fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，正如我们所检查的，我们在这个场景中的视图有6个可能的定制:顶部内容的个人信息标题视图、雇用信息标题视图或健康计划标题视图，中间有或没有可用性标题视图。</p><h1 id="8046" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">在不同的背景下构建我们的观点</h1><p id="b5e4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在，让我们以声明的方式定义我们的视图结构，让我们首先定义可能填充我们屏幕的标题视图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/12b4d33524de9b20f8cc86eb19148211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PzQSMUrnurwdTcAdbU7NMQ.jpeg"/></div></div></figure><p id="73b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们定义根视图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/4a7ee251978449cb180ca4dd8ca6583a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgMJ9NqjBvYkoBy-i4xqzw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这导致了带有可用性标题视图的健康计划场景</p></figure><p id="90fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只是简单地将<code class="fe mt mu mv mw b">HealthPlanFormHeaderView</code>和<code class="fe mt mu mv mw b">AvailabilityHeaderView</code>作为原始组件，但是我们真正想要的是将它们变成可定制的参数。这就是我们所说的<code class="fe mt mu mv mw b">ViewBuilders</code>！</p><p id="c6cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mt mu mv mw b">ViewBuilders</code>是两个参数，它们是返回视图类型的闭包，我们将使用它们来填充我们的根视图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/7aaaea0e6c0cdb24da00f8652308215b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URie_CnYog3P3U6GIRac1w.png"/></div></div></figure><p id="0308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为与UIKit不同，我们处理的是<code class="fe mt mu mv mw b"><em class="my">structs</em></code>而<code class="fe mt mu mv mw b">View</code>是一个协议，我们需要定义两个符合视图协议的通用类型。我们定义了两个不同的参数注入到我们的<code class="fe mt mu mv mw b">RootView</code>中，分别是返回<code class="fe mt mu mv mw b">Content1</code>和<code class="fe mt mu mv mw b">Content2</code>类型的闭包。</p><p id="7de0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当初始化我们的根视图时，我们简单地从两个闭包获取返回的视图，并分配给<code class="fe mt mu mv mw b">topContent</code>和<code class="fe mt mu mv mw b">availabilityHeader</code>属性。我们还必须将<em class="my"> init </em>方法中的这两个参数标记为ViewBuilders。</p><p id="eb7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经对top和availability标题视图进行了参数化，让我们简单地在主体中调用它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/bc39246ea3590186e2b939533b01e403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcaF2CKRXbgItTwa_LChAQ.png"/></div></div></figure><p id="c930" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了。既然我们已经对这两个组件进行了参数化，我们可以将任何类型的视图传递给这个组件，它将显示在正确的位置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/5b6b77e49760450c6ef03606970380e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*DVpa6m_S6AGASalESbqcNg.png"/></div></div></figure><p id="883d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为SwiftUI开发人员，您实际上对这个概念很熟悉，因为大多数框架的本地组件实际上都接收了<code class="fe mt mu mv mw b">ViewBuilders</code>来定制它的外观。</p><p id="0860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI <code class="fe mt mu mv mw b">Button</code>是两个很好的例子，它定义了点击时的行为，然后是描述其外观的<code class="fe mt mu mv mw b">label</code>闭包。同样的情况也可以在<code class="fe mt mu mv mw b">VStacks</code>和<code class="fe mt mu mv mw b">HStacks</code>中得到验证，它们获取一些注入的内容，并在水平或垂直的轴上显示出来</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/1928a53b5ee643bd8ba8473b6c3d2682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itSeztnB_758LxKhOCiMEQ.jpeg"/></div></div></figure><p id="949b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些视图作为可定制的参数被注入到另一个视图中。</p><h1 id="988e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">在不同的场景中传播我们的可重用视图</h1><p id="b982" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在我们有了<code class="fe mt mu mv mw b">RootView</code>，这是一个可定制的组件，我们可以在其他屏幕(视图)中重用它，注入该上下文所需的适当数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/38b556b4a3abce35935069fa997b2587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edsYNuDsigASTyLhKtnaxA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/9079e2bad2965561033c37b6ac61aefd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGDpIrivbakVPdMLGnNPDA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/6fb981c26d5abefe9311cec7bd29e4ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1x3metBys6MtDcIicwonJg.png"/></div></div></figure><p id="580e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分别地，我们将有这些场景:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/5d1064e1961beccd558ffe1e4c717d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yOa-e5KVuqXGEEjRrJ9XQ.jpeg"/></div></div></figure><p id="d8d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一些新的场景和可能的头出现，我们只需要将相应的实例注入到我们的可重用的<code class="fe mt mu mv mw b">RootView</code>中，它在屏幕的主体中被调用。</p><h1 id="c918" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">作为私有函数的视图生成器</h1><p id="5f0f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">正如我们所见，<code class="fe mt mu mv mw b">ViewBuilder</code>是一个返回<code class="fe mt mu mv mw b">View</code>类型的闭包，但它也可能是视图类型中的一个命名函数，为UI的某些部分建立一些参数化:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/36ce147a5f6cf809c67b73c6cc56472f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3vDFO7qzJm966lHVJN19w.png"/></div></div></figure><p id="e4ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们创建了一段代码，它根据<code class="fe mt mu mv mw b">hasHeader</code>布尔值返回一个可定制的组件。</p><p id="85b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你的视图有一个太复杂的UI，并且不认为创建分离的文件和视图来填充它是一个好的方法，因为这些UI正是为这个上下文而制作的，那么将视图的不同部分分离到一个<code class="fe mt mu mv mw b">ViewBuilder</code>私有方法中总是一个好的选择。</p><h1 id="cbee" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">摘要</h1><p id="3689" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在本文中，我们描述了一种提高视图可重用性的方法，通过将一些UI变体转换成可定制的参数。随着应用程序的增长，您可以通过从外部注入视图的某些部分来重用视图。</p><p id="520a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">视图构建器作为视图的参数，视图实际上是子视图。任何时候你发现一个屏幕在不同的上下文中被重用，修复特定的部分并把它们转换成参数。</p><p id="5fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢它，并不断提高你的代码的美观性和可重用性；)</p></div></div>    
</body>
</html>