<html>
<head>
<title>Introduction to Vuex in Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js中的Vuex介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/vuejs-introduction-to-vuex-82bf35be5130?source=collection_archive---------7-----------------------#2017-11-01">https://betterprogramming.pub/vuejs-introduction-to-vuex-82bf35be5130?source=collection_archive---------7-----------------------#2017-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c57c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Vue中的状态管理</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/7058d217a6775e9f48b750b1ca335331.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wqYF-8Dmh7LhtLkKfERc3Q.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">vue . j</p></figure><p id="f552" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您使用Vue时，在组件中上下传递状态是很正常的。如果您正在开发一个小的应用程序，这可能不会给您带来任何问题。</p><p id="94f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是一旦你的应用程序开始有很多组件——有时嵌套两三层——维护状态就开始变得复杂和混乱。如果你觉得你处于这种情况，你应该开始考虑迟早使用<a class="ae ln" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>。</p><p id="164f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你需要理解，像在大多数情况下一样，当你选择使用一个工具时，你是在进行权衡，当决定使用Vuex时也是如此。用Vue.js团队的话说:</p><blockquote class="lo lp lq"><p id="834f" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">“虽然Vuex帮助我们处理共享状态管理，但它也带来了更多概念和样板文件的成本。这是短期和长期生产力之间的权衡。”</p></blockquote><p id="95b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我们将对Vuex做一个简单的介绍，然后看一些例子。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="38ce" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">Vuex是什么</h1><p id="b989" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">Vuex是一种基于Flux、Redux和Elm架构的模式。Vuex的好处之一是它由Vue团队维护，因此它们可以完美地合作。</p><p id="9534" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Vuex的目标是为应用程序中的所有组件提供可预测的状态管理和集中存储。它强制使用一些规则来管理状态，这也有助于为我们的代码提供更好的结构和可维护性。</p><h2 id="a0dd" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated"><strong class="ak"> Vuex关键概念</strong></h2><p id="c1d1" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">让我们看一下使用Vuex时必须理解的一些关键概念(我们也将在后面的代码示例中看到其中的大部分)。</p><p id="9a5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Vue组件</strong></p><p id="3941" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您的组件可以使用应用程序的全局存储状态，也有自己的状态。在多个组件中需要的任何信息都应该在存储状态中。</p><p id="3f7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了能够访问所有组件上的存储，您需要将它添加到根组件中。</p><p id="46b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">存储状态</strong></p><p id="759f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您声明您的存储时，您必须初始化您的应用程序的状态属性。</p><p id="a5b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">改变商店状态</strong></p><p id="a0b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有两种方法可以改变组件的存储状态。</p><ul class=""><li id="b40b" class="nl nm iq kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><strong class="kt ir">提交突变</strong> <br/>突变是由我们商店管理的对我们状态的操作。您不能直接从您的组件中执行它们。为了执行一个变异，您必须使用store <code class="fe nu nv nw nx b">commit</code>方法，该方法接收要执行的变异的名称，并且可能接收一个包含定制数据的对象。突变是同步的。</li><li id="b28e" class="nl nm iq kt b ku ny kx nz la oa le ob li oc lm nq nr ns nt bi translated"><strong class="kt ir">分派动作</strong> <br/>您的商店也可能包含动作。为了从组件中执行一个动作，您必须执行store的<code class="fe nu nv nw nx b">dispatch</code>方法。此方法还接收要调度的操作的名称和包含自定义数据的对象。动作最终会导致突变，它们不会直接改变状态。动作可以是异步的，并且可以返回承诺。</li></ul><p id="09b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">动作和突变存在的主要原因是为了分离同步和异步操作之间的关注点。</p><p id="e2a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当存储状态改变任何组件时，它使用的那部分状态将做出反应并更新。</p><p id="5c96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">储存吸气剂</strong></p><p id="7f1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它们就像是你商店的计算属性。getter的结果是基于其存储状态依赖关系进行缓存的，只有当它的一些依赖关系发生变化时才会重新计算。</p><p id="50a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">存储模块</strong></p><p id="5471" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着应用程序的增长，存储的单个声明会变得非常混乱。为了解决这一问题，您可以将商店划分为模块，每个模块都可以包含所有商店功能。最后，您可以将所有这些模块添加到您的商店声明中。</p><p id="ee03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们看一些例子。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="8926" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">Vuex示例</h1><p id="70f4" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">派对时间到了！</p><h2 id="3d00" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated"><strong class="ak">商店初始化</strong></h2><p id="2de0" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我们将创建一个具有我们之前提到的一些商店功能的商店。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi od"><img src="../Images/2151b7210d5913e1c7f1067bcd61dfa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lq8wzJ5QbDpdOShT34bvQg.png"/></div></div></figure><p id="7f99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇！不要担心，我们将深入研究该实现。</p><ul class=""><li id="a43b" class="nl nm iq kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><strong class="kt ir">初始化</strong> <br/>我们要做的第一件事就是使用Vuex store实例化我们的store。</li><li id="a01f" class="nl nm iq kt b ku ny kx nz la oa le ob li oc lm nq nr ns nt bi translated"><strong class="kt ir">状态<br/> </strong>在这里，我们声明并初始化我们商店的状态属性。</li><li id="3a49" class="nl nm iq kt b ku ny kx nz la oa le ob li oc lm nq nr ns nt bi translated"><strong class="kt ir"> Getters <br/> </strong>这是我们计算得到的getter，用来获得<code class="fe nu nv nw nx b">userName </code>状态属性的反向版本。这些函数接收状态作为第一个参数。</li><li id="bef4" class="nl nm iq kt b ku ny kx nz la oa le ob li oc lm nq nr ns nt bi translated"><strong class="kt ir">突变<br/> </strong>这是为了改变我们的状态，我们将要提供的两种突变。它们还接收状态作为第一个参数。</li><li id="ebcb" class="nl nm iq kt b ku ny kx nz la oa le ob li oc lm nq nr ns nt bi translated">我们将只提供一个返回承诺的异步动作。动作接收代表状态的上下文。动作总是以调用存储<code class="fe nu nv nw nx b">commit</code>函数的突变来改变状态而告终。在这种情况下，承诺被解析并返回count属性的新值。</li></ul><h2 id="ba46" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">将商店添加到我们的根组件</h2><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/7e52f12c34e81455a96f1060714c4dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*XUc4rk9bfXjj9H-fBWIAAg.png"/></div></figure><p id="c0a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很简单。我们只需要在根组件中设置属性存储。现在，我们应用程序的所有组件都可以访问商店了。</p><h2 id="453a" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">使用商店的组件</h2><p id="9634" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我们将浏览一些使用Vuex的组件示例，并解释它们的功能。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi oj"><img src="../Images/47afba89ec0715f7322b68d9f5258369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0BZGgZ2w8YWIz5PJSzVIQ.png"/></div></div></figure><p id="fe07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该组件有两个计算属性。它们是通过使用Vuex的<code class="fe nu nv nw nx b">mapState</code>助手来设置的，这个助手的目的是当我们使用多个存储状态属性或getters时，简化存储状态到组件的映射。在这个例子中并不真的需要，但是值得展示一下。</p><ul class=""><li id="5efe" class="nl nm iq kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">首先，我们创建一个<code class="fe nu nv nw nx b">userFullName</code> computed属性，它接收状态并返回两个状态属性的连接(这应该用存储中的computed getter来完成，但我们这样做只是作为一个例子)。</li><li id="0163" class="nl nm iq kt b ku ny kx nz la oa le ob li oc lm nq nr ns nt bi translated">然后我们使用spread ( <code class="fe nu nv nw nx b">…</code>)数组向组件计算属性添加一个在我们的存储中声明的getters。我们还使用了一个Vuex助手——在本例中是<code class="fe nu nv nw nx b">mapGetters</code>。</li></ul><p id="88ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">两个助手(<code class="fe nu nv nw nx b">mapState</code>和<code class="fe nu nv nw nx b">mapGetters</code>)都可以通过提供一个字符串数组来使用(当组件属性与存储状态属性或getter同名时，我们使用这种方法)，或者它们也可以通过传递一个对象(组件属性的键值表示)来使用。在这里阅读更多关于地图状态的信息。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/92f321c0098cef039d5180ab7392e5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*tH-167ogrqU7KDeO7uMzMQ.png"/></div></figure><p id="d822" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第二个例子中，我们可以看到如何对存储数据使用<code class="fe nu nv nw nx b">v-model</code>,以及如何执行存储操作。</p><ul class=""><li id="7445" class="nl nm iq kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">首先，声明一个名为<code class="fe nu nv nw nx b">userName</code>的计算属性，该属性获取存储状态的<code class="fe nu nv nw nx b">userName</code>值，当它改变时，它执行一个setter，该setter使用存储状态<code class="fe nu nv nw nx b">commit</code>来触发<code class="fe nu nv nw nx b">changeName</code>变异，并提供新值作为有效负载参数。</li><li id="7db8" class="nl nm iq kt b ku ny kx nz la oa le ob li oc lm nq nr ns nt bi translated">我们还使用助手<code class="fe nu nv nw nx b">mapActions</code>添加了一个方法。这个助手的工作方式和我们之前看到的一样。在这种情况下并不需要spread ( <code class="fe nu nv nw nx b">…</code>)操作符，因为没有其他方法，但是由于在实际应用程序中会有其他方法，所以习惯于看到它是有好处的。在帮助器内部，我们声明了一个<code class="fe nu nv nw nx b">add</code>方法，该方法调度商店的动作<code class="fe nu nv nw nx b">increment</code>。由于这个动作返回一个承诺，我们可以使用一个带有回调的<code class="fe nu nv nw nx b">then</code>。</li></ul><p id="0ac2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个组件中可以访问<code class="fe nu nv nw nx b">$store</code>,因为我们将它添加到了应用程序的根组件中。</p><p id="5df6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/SantiagoGdaR/vue-vuex" rel="noopener ugc nofollow" target="_blank">链接到GitHub </a></p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="7317" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结论</h1><p id="2a68" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">Vuex功能强大，使用简单，但是使用它不是一个简单的决定。</p><p id="880b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们在本文中所讨论的，这是一种权衡，所以要确保你得到的比失去的多。</p></div></div>    
</body>
</html>