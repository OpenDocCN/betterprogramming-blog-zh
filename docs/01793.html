<html>
<head>
<title>Gitlab CI/CD for a Dockerized Flask and Next.js Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于Dockerized Flask和Next.js应用程序的Gitlab CI/CD</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/gitlab-ci-cd-for-dockerize-flask-and-nextjs-application-b01868401904?source=collection_archive---------11-----------------------#2019-10-14">https://betterprogramming.pub/gitlab-ci-cd-for-dockerize-flask-and-nextjs-application-b01868401904?source=collection_archive---------11-----------------------#2019-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9b73" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们为您的应用程序设置持续集成</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5b13515e9dc28b6661939904d48b6905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfut2HonD_NHKvtcaaJBmQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gitlab，Docker，Flask，Next.js，DigitalOcean</p></figure><p id="75b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">几周前，我写了一篇关于用<a class="ae lr" href="https://medium.com/better-programming/setup-flask-nextjs-application-with-docker-97e82a897573" rel="noopener"> Flask、Next.js和Docker </a>构建应用程序的文章。在那篇文章中，我描述了如何对后端的Flask应用程序进行dockerize。现在是前端，而<a class="ae lr" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>是反向代理服务器。</p><p id="12ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还展示了一种使用<code class="fe ls lt lu lv b">docker-compose</code>为本地开发轻松运行所有容器的方法，并使用<code class="fe ls lt lu lv b">docker-machine</code>将其直接部署到<a class="ae lr" href="https://www.digitalocean.com/" rel="noopener ugc nofollow" target="_blank"> DigitalOcean </a>。</p><p id="cc51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您还在玩一个玩具项目，我在那篇文章中描述的设置就足够了。在真实的、基于团队的协作环境中，很难只允许本地机器部署。</p><p id="f5fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们需要能够让我们安全、自动地将应用程序部署到云服务器的技术。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="36bd" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">持续集成/持续部署</h1><p id="8ea5" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">这就是CI/CD技术的用武之地。正如ThoughtWorks在他们的文章中解释的那样:</p><blockquote class="na nb nc"><p id="2498" class="kv kw nd kx b ky kz jr la lb lc ju ld ne lf lg lh nf lj lk ll ng ln lo lp lq ij bi translated"><em class="iq">持续集成(CI)是一种开发实践，它要求开发人员每天数次将代码集成到共享存储库中。然后，每个签入都由一个自动构建来验证，允许团队尽早发现问题。</em></p><p id="5944" class="kv kw nd kx b ky kz jr la lb lc ju ld ne lf lg lh nf lj lk ll ng ln lo lp lq ij bi translated"><em class="iq">持续部署与持续集成密切相关，是指将通过自动化测试的软件发布到产品中。</em></p></blockquote><p id="3332" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之，CI/CD允许开发人员将代码推送到存储库，并自动构建和部署到我们的部署环境中。</p><p id="d169" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将向您展示如何使用GitLab CI/CD基础设施轻松集成我们的项目，以自动部署到我们在DigitalOcean中的服务器。</p><p id="6c7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有几种CI/CD技术或提供商可供您使用。比如一个SASS平台比如<a class="ae lr" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> circleci </a>、<a class="ae lr" href="https://travis-ci.com/" rel="noopener ugc nofollow" target="_blank"> Travis CI </a>、<a class="ae lr" href="https://buildkite.com/" rel="noopener ugc nofollow" target="_blank"> Buildkite </a>，或者用<a class="ae lr" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>搭建自己的基础设施。</p><p id="dd7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我使用GitLab进行CI/CD基础设施演示。我选择GitLab的原因是我最近正在为我的项目集成它。此外，它是提供免费CI/CD基础架构和合理功能的平台之一。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="751b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">与GitLab CI/CD集成</h1><p id="cffc" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">在本教程中，我将演示如何使用GitLab CI/CD基础架构运行自动Docker映像构建，并将其部署到dockered<a class="ae lr" href="https://palletsprojects.com/p/flask/" rel="noopener ugc nofollow" target="_blank">Flask</a>和<a class="ae lr" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>应用程序的DigitalOcean droplet。</p><p id="99a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要完成本教程，您可能需要事先做一些准备:</p><ul class=""><li id="e331" class="nh ni iq kx b ky kz lb lc le nj li nk lm nl lq nm nn no np bi translated"><a class="ae lr" href="https://gitlab.com/users/sign_in#register-pane" rel="noopener ugc nofollow" target="_blank"> GitLab账户</a></li><li id="6b41" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">数字海洋账户。</li></ul><p id="bc38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文中的所有示例都可以在本<a class="ae lr" href="https://github.com/martindavid/flask-react-docker-learning" rel="noopener ugc nofollow" target="_blank">报告</a>中找到。回购包含一个简单的应用程序，包括:</p><ul class=""><li id="33ef" class="nh ni iq kx b ky kz lb lc le nj li nk lm nl lq nm nn no np bi translated">具有<code class="fe ls lt lu lv b">Users</code>和<code class="fe ls lt lu lv b">Auth</code>端点的后端的Flask API。</li><li id="3a78" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">Next.js应用程序的前端，有一个简单的主页和登录页面。</li><li id="d00b" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">NGINX用于Flask API和Next.js应用程序的反向代理。</li></ul><p id="09bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GitLab中的CI/CD工作流使用一个名为<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>的文件进行配置。让我们将<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>文件添加到我们的根项目文件夹中。</p><p id="fba0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在脚本中，我们将创建两个阶段；一个用于构建Docker映像，另一个用于部署它。</p><p id="d9d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个配置中，我们将使用GitLab Docker映像注册表来存储Docker映像。如果您愿意，也可以使用<a class="ae lr" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="ab06" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">初始脚本</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="efcc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的脚本在工作流的每个阶段之前运行。<code class="fe ls lt lu lv b">before_script</code>部分是在配置文件中为工作流的每个阶段重用相同步骤的方法。</p><p id="a4c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">脚本的第一步是导出存放Docker图像的地址的环境变量。然后，它安装<code class="fe ls lt lu lv b">open-ssh</code>客户机，以便稍后登录到我们的数字海洋服务器，并安装<code class="fe ls lt lu lv b"><a class="ae lr" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank">Bash</a></code>来执行Bash脚本，以便设置环境变量。</p><p id="07eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">之后，该脚本登录到GitLab Docker注册表，这样我们就可以从中推送和提取图像。</p><p id="5d6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面脚本中的最后一步执行<code class="fe ls lt lu lv b">setup_env.sh</code>脚本。<code class="fe ls lt lu lv b">setup_env.sh</code>脚本获取GitLab CI/CD配置中设置的所有环境变量，并将其放入<code class="fe ls lt lu lv b">.env</code>文件中。</p><p id="09e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该文件将在接下来的步骤中执行。<code class="fe ls lt lu lv b">setup_env.sh</code>的内容是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="443e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">构建阶段</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3312" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的构建阶段包括三个主要步骤。</p><ol class=""><li id="d7e1" class="nh ni iq kx b ky kz lb lc le nj li nk lm nl lq nx nn no np bi translated">首先，如果图像存在于注册表中，它会提取图像。</li><li id="9d18" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">接下来，它根据我们在<code class="fe ls lt lu lv b">docker-compose.ci.yml</code>文件中的配置构建映像。</li><li id="bb5c" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">最后，在构建映像之后，它将最新的构建映像推回GitLab Docker映像注册中心。</li></ol><p id="8ac6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">docker-compose.ci.yml</code>文件非常简单，它只包含Flask和Next.js应用程序的配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="3bfa" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">部署阶段</h1><p id="5a63" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">对于部署阶段，脚本包含几个步骤。</p><ol class=""><li id="4926" class="nh ni iq kx b ky kz lb lc le nj li nk lm nl lq nx nn no np bi translated">将用于<a class="ae lr" href="https://www.ssh.com/" rel="noopener ugc nofollow" target="_blank"> SSH </a>的私钥提取到DigitalOcean droplet中，并将其添加到GitLab CI/CD进程中。</li><li id="c0c6" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">通过SSH将部署所需的所有工件复制到DO droplet。</li><li id="62ec" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">运行部署脚本。部署脚本执行:</li></ol><ul class=""><li id="ebd5" class="nh ni iq kx b ky kz lb lc le nj li nk lm nl lq nm nn no np bi translated">SSH到DO droplet。</li><li id="18db" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">从DO droplet登录GitLab Docker注册表。</li><li id="fcd5" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">提取所需的Docker图像。(Flask和Next.js docker图片。)</li><li id="1062" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated">运行<code class="fe ls lt lu lv b">docker-compose</code>在液滴上运行。</li></ul><p id="8d00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的代码展示了如何在<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>文件中实现它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ad85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面这段代码可以看出，我们需要添加一个名为<code class="fe ls lt lu lv b">docker-compose.prod.yml</code>的新文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7945" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，上一步中的<code class="fe ls lt lu lv b">deploy.sh</code>脚本完成了大部分部署工作。脚本内容如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="281a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总之，该脚本将:</p><ol class=""><li id="c209" class="nh ni iq kx b ky kz lb lc le nj li nk lm nl lq nx nn no np bi translated">SSH进入数字海洋水滴。</li><li id="9eb8" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">导出Docker映像所需的所有环境变量。</li><li id="f80d" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">从GitLab Docker注册表中提取Docker图像。</li><li id="71e1" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">运行<code class="fe ls lt lu lv b">docker-compose.prod.yml</code>。</li></ol><p id="3d26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，这是我们最终的GitLab工作流脚本，GitLab将选择并运行CI/CD流程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="e970" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">在GitLab中运行CI/CD</h1><p id="bdd3" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">如果您的项目存储库在GitLab中，一旦您将该脚本推入存储库，GitLab将自动选择新的CI/CD配置并立即运行它。</p><p id="b04d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你没有将你的回购存储在GitLab中(比如在GitHub中)，你仍然可以将你的项目与GitLab CI/CD基础设施集成。在本节中，我将向您展示如何做到这一点。</p><ol class=""><li id="3708" class="nh ni iq kx b ky kz lb lc le nj li nk lm nl lq nx nn no np bi translated">登录您的GitLab帐户。</li><li id="5813" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">在主页上，点击<code class="fe ls lt lu lv b">New project</code>按钮。</li><li id="bd7e" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">在创建新项目页面上选择<code class="fe ls lt lu lv b">CI/CD for external repo</code>选项卡。</li><li id="8490" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">点击<code class="fe ls lt lu lv b">Github</code>按钮进行<code class="fe ls lt lu lv b">Connect repositories from</code>选择。<br/>您可能需要先创建一个GitHub <a class="ae lr" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank">个人令牌</a>并向GitLab注册。</li><li id="a476" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">选择要与GitLab CI/CD管道集成的repo，然后单击<code class="fe ls lt lu lv b">Connect</code>。连接到回购并完全集成它需要几分钟时间。这个进程在幕后做的是镜像我们的GitHub repo，并将其放入GitLab。有一个后台进程运行我们的GitHub repo和GitLab repo之间的同步过程。</li><li id="45f1" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nx nn no np bi translated">一旦连接上，对repo的每个提交都会自动触发CI/CD管道。</li></ol><p id="64fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下一步中，在我们对repo进行修改之前，我们需要首先设置DigitalOcean droplet。接下来，我们需要在GitLab上设置CI/CD工作流中所需的所有环境变量。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="25d5" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">设置数字海洋水滴</h1><p id="d81a" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">出于本教程的目的，让我们创建一个新的数字海洋水滴。当你创建一个新的droplet时，确保你添加了一个<code class="fe ls lt lu lv b">ssh-key</code>，类似于你将要放入GitLab CI/CD环境中的那个。</p><p id="8c11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在你创建了一个新的DigitalOcean droplet之后，你可能需要SSH到这个droplet并在根系统中创建一个新的文件夹<code class="fe ls lt lu lv b">/app</code>。我们将使用这个文件夹来存储我们所有的部署工件。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1c5e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">设置Gitlab CI/CD环境变量</h1><p id="d648" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我们还需要在GitLab CI/CD的环境变量中设置另一个东西。</p><p id="249c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您在上一部分中看到的，我们有一个<code class="fe ls lt lu lv b">setup_env.sh</code>脚本，它从GitLab CI/CD环境变量中获取所有内容，并将其放入<code class="fe ls lt lu lv b">.env</code>文件中。</p><p id="972a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要在GitLab CI/CD中添加环境变量，您需要进入设置-&gt; CI/CD，然后展开变量选择。以这种形式添加我们需要的可变环境。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/59057e759ebec62ee3534cda6915220b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0e09pd3nPim-KvDB.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将Github连接到Gitlab CI/CD管道</p></figure><p id="f416" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我们的示例应用程序，我们需要将这些变量放入CI/CD环境变量中:</p><ul class=""><li id="6b9d" class="nh ni iq kx b ky kz lb lc le nj li nk lm nl lq nm nn no np bi translated"><code class="fe ls lt lu lv b">DATABASE_URL</code> : <a class="ae lr" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgres </a>可以在云中访问的连接字符串。</li><li id="f76f" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated"><code class="fe ls lt lu lv b">SECRET_KEY</code>:我们的Flask应用程序的随机字符串。</li><li id="e630" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated"><code class="fe ls lt lu lv b">REACT_API_SERVICE_URL</code>:Flask API URL。这个变量值就是droplet API/域名(如果有的话)。例如<code class="fe ls lt lu lv b">http://&lt;droplet IP address&gt;</code>。</li><li id="5ad2" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated"><code class="fe ls lt lu lv b">PRIVATE_KEY</code> : SSH到DigitalOcean droplets的SSH私钥。</li><li id="3793" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated"><code class="fe ls lt lu lv b">DO_IP_ADDRESS</code>:数字海洋水滴IP地址。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/06c74f235aa0045d7786692387a80d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gwpUB_NQJco5_geb.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitLab CI/CD环境变量</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="324e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">将变更推送到回购</h1><p id="58f0" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">在我们设置好一切之后，现在我们可以将我们的更改推送到存储库。一旦你推了，你就可以去GitLab，打开CI/CD管道页面。</p><p id="1679" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从页面上，您可以看到有一个CI/CD流程正在运行。您可以单击正在运行的流程，查看当前正在运行哪个阶段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/73d7fc8e601bd8cd2a857ebc9908e12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/0*xxVgV6V9zQfHTPjd.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gitlab CI/CD管道菜单</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/d8838402ac4dbe71b1ed4612754f8716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vSyKpWX6fgjKVUER.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitLab CI/CD运行管道</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/df72d9a8559c7597e879ea4e2d854a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cE6gfmtVpKfZVSPk.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitLab CI/CD运行阶段</p></figure><p id="10d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果其中一个阶段失败，您可以单击失败的阶段，查看流程中发生的事情的完整日志以及错误消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/7752f9bbba93ed0c721726985920da9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/0*_ibwxQ5C6qbQzYge.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitLab CI/CD失败阶段</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/4bdc7902a56c2a3ca80bcc6a99e5fc5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*Osr-bN9yPUSSykic.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitLab失败阶段错误详细信息</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8acb" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">最后的想法</h1><p id="f0b5" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">如果我们想同时运行多个Docker容器，Docker和Docker Compose是一个很好的组合。这也使得从本地机器直接使用<code class="fe ls lt lu lv b">docker-machine</code>进行部署变得容易。</p><p id="566c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是在现实世界中，很多人都在使用应用程序，并且经常发生更改，我们需要一种更安全的机制来将更改部署到生产服务器。</p><p id="0a64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是CI/CD技术的用武之地。使用CI/CD，可以通过一组配置自动测试、构建和部署应用程序。</p><p id="6e16" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我展示了如何将dockerized Flask和Next.js应用程序集成到GitLab CI/CD基础设施中。项目存储库不一定要在GitLab中。</p><p id="9b20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们的项目驻留在其他源代码控制平台(例如GitHub)时，我们可以利用GitLab CI/CD runner。</p><p id="2536" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将展示如何从<code class="fe ls lt lu lv b">docker-compose.yml</code>文件构建Docker映像，将映像推送到GitLab Docker注册表，并将应用程序部署到DigitalOcean droplet。</p><p id="daf1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在工作流中添加更多步骤，例如，运行单元测试、运行集成测试等。希望这篇教程能帮助你了解更多关于CI/CD的知识，尤其是在GitLab环境下。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="920f" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">资源</h1><ul class=""><li id="24c2" class="nh ni iq kx b ky mv lb mw le of li og lm oh lq nm nn no np bi translated"><a class="ae lr" href="https://www.thoughtworks.com/continuous-integration" rel="noopener ugc nofollow" target="_blank">ThoughtWorks的CI/CD</a></li><li id="9180" class="nh ni iq kx b ky nq lb nr le ns li nt lm nu lq nm nn no np bi translated"><a class="ae lr" href="https://github.com/martindavid/flask-react-docker-learning" rel="noopener ugc nofollow" target="_blank">项目仓库</a></li></ul></div></div>    
</body>
</html>