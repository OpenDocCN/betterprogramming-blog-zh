# SwiftUI 中的确认对话框

> 原文：<https://betterprogramming.pub/confirmation-dialogs-in-swiftui-63758a57da5c>

## 复制苹果的提醒应用

![](img/23c248605696ab1ed120e375574120a2.png)

图片由作者根据科幻符号绘制

在我们的应用程序中，我们经常需要用户确认他们发起的一个动作，主要是因为这是一个破坏性的操作。在 SwiftUI 中，这需要许多视图和状态变量的相互作用:表示屏幕本身的视图、某种确认对话框、潜在的工具栏，通常还有一个*取消*和一个*完成*按钮，以及驱动这些视图可见性的状态变量。

在这篇文章中，我们将探索如何从苹果的提醒应用程序中复制确认对话框，我们将学习如何使用 SwiftUI 的自定义视图修改器将其转化为可重用的解决方案。在此过程中，我们还将研究如何防止用户删除表单，我们会发现苹果的 API 在这方面缺少一个重要的特性。

# 我们将要建造的

这篇文章中的代码基于 [Make It So](https://github.com/peterfriese/MakeItSo/tree/develop) ，一个苹果提醒应用的复制品。我的目标是看看是否有可能只用纯粹的 SwiftUI 和 Firebase 复制苹果的提醒应用程序。如果您想运行这个应用程序并跟随它，您可以从这个存储库中检查代码(确保使用`[develop](https://github.com/peterfriese/MakeItSo/tree/develop)`分支)。

这是应用程序的最终状态，以及提醒应用程序的原始行为:

![](img/6dcac579cfb3ffe9b1c30b13da0cfe54.png)

苹果提醒应用的并排演示

正如你所看到的，只有当用户更改了提醒时，应用程序才会要求用户确认，然后通过点击*取消*或向下滑动来尝试离开编辑对话框。

现在，让我们看看如何实现这一点！

# 检测变化

在我们开始实现确认对话框之前，我们需要检测用户是否在编辑对话框中更改了任何数据。因为我们使用`struct`来保存我们的数据，这比你想象的要容易得多:`struct`是值类型，这意味着我们可以使用一个简单的相等检查来测试两个提醒是否相同:

为了使编辑对话框中的数据处理更容易，我创建了一个简单的视图模型，它包装了一个`Reminder`并公开了一个属性`isModified`，该属性执行简单的不等式检查以指示提醒是否被用户编辑过:

这种方法的伟大之处在于:如果用户撤销了所有的更改，那么`reminder`和`original`将相等，而`isModified`将返回`false`——正如所料。

# 请求用户确认

构建卓越的用户体验就是尽可能消除摩擦，但要把它用在正确的地方。

例如，如果用户在编辑对话框中做了修改提醒，我们可以假设他们是故意这样做的。询问他们是否想要保存他们的更改只会增加不必要的摩擦。

然而，如果用户点击*取消*按钮，可能值得询问他们是否想要放弃他们所做的更改——毕竟，这是一个破坏性的操作，他们将丢失更改。想象一下，他们在提醒的*注释*栏中写下了一个重要的想法——丢失这些数据会让人很难过！

这在移动用户界面上更加重要，因为很容易不小心碰到取消按钮。

在 iOS 15 中，苹果引入了一个新的视图修改器`confirmationDialog`来创建确认对话框。在 SwiftUI 的许多 API 的精神中，这是一种跨平台的方式来表达我们想要实现什么，而不是如何实现。系统将负责使用最合适的特定于平台的 UI 元素来呈现确认对话框。

让我们来看看如何创建一个简单的确认对话框，我们可以用它来询问用户是否想要放弃他们的编辑:

这里，我们向确认对话框添加两个简单的`Button`:

*   第一个标记为`.destructive`，当用户点击它时，详细信息对话框将被关闭(感谢我们从环境中抓取的`dismiss`动作)。
*   第二个标记为`.cancel`，点击它将关闭确认对话框，用户可以继续编辑。iOS 会自动在动作表底部显示这个按钮。

我们想在用户修改提醒后点击*取消*按钮离开屏幕时显示确认对话框，所以我们添加一个带有*取消*和*完成*按钮的工具栏:

当用户点击*取消*按钮时，我们检查视图模型的`isModified`状态。如果用户修改了提醒，我们将把`presentingConfirmationDialog`设置为`true`，这将导致确认对话框出现。

> ***边注****:swift ui 以前的版本需要我们使用* `*actionSheet*` *视图修改器来实现确认对话框。当比较使用新的* `*confirmationDialog*` *视图修改器创建确认对话框的代码和使用* `*actionSheet*` *创建动作表的代码时，SwiftUI 团队似乎一直在致力于简化 SwiftUI 的一些 API。例如，我们现在可以使用常规的* `*Button*` *s，并将它们的* `*role*` *属性设置为各自的枚举用例，而不是使用特定于 API 的内部结构(如* `*Alert.Button*` *)和它们的自定义实例，如* `*.destructive*` *、* `*.cancel*` *。按钮是 SwiftUI 中的一个横切关注点，它们可以以许多不同的形状和形式出现。虽然清理 SwiftUI DSL 对于我们这些已经用 SwiftUI 编写了大量代码的人来说可能不太方便，但这有一些主要的好处:*
> 
> -通过在不同的关注点上使用相同的概念，事情变得更容易处理。例如，现在可以使用相同的代码在`Toolbar`上或在`confirmationDialog`内部创建一个`Button`。
> 
> ——你要少学点 API。不再需要学习给`actionSheet`添加按钮的语法——知道一个普通的老`Button`是如何工作的就足够了。这减少了精神负担，使开发人员更有效率。
> 
> -总体而言，这将使 SwiftUI 更具可扩展性，更经得起未来考验。
> 
> *要了解关于 DSL 和跨领域问题的更多信息，请查看 Markus Voelter 的优秀 DSL 工程书籍(* [*站点*](https://voelter.de/books.html) *，*[*PDF*](https://voelter.de/dslbook/markusvoelter-dslengineering-1.0.pdf)*)。*

# 遵从用户的意愿

一旦用户决定了他们想要提交、放弃还是取消，我们就需要根据他们的决定采取行动。

到目前为止，我们已经讨论了以下案例:

*   用户希望继续编辑(一旦用户点击*取消*按钮，确认对话框将自动消失)。
*   用户想要离开编辑对话框并放弃他们所做的任何更改——我们只需关闭编辑对话框。

如果用户点击*完成*按钮，剩下的唯一事情就是保存任何更改。为了以灵活和可重用的方式实现这一点，我们在编辑对话框的初始化器中添加了一个回调闭包(名为`onCommit`):

这个闭包有一个参数`reminder`，它将包含修改后的数据。要将修改后的数据发送回调用者(在我们的例子中是显示用户提醒的列表视图)，我们需要做的就是从编辑对话框工具栏上的 *Done* 按钮调用`doCommit`。

# 防止交互式解散

有了这些，我们现在可以确保用户不会意外地放弃他们所做的更改。

不过，有一个小问题:向下滑动编辑对话框所在的工作表会关闭编辑对话框，并放弃用户所做的任何更改。这根本不是用户所期望的，所以我们需要解决这个问题。

在 UIKit 中，您可以实现`UIAdaptivePresentationControllerDelegate`来控制用户是否可以取消工作表。到目前为止，还没有纯粹的 SwiftUI 等价物。好消息是苹果在 iOS 15 中引入了`interactiveDismissDisabled`视图修改器——这个视图修改器允许我们完全关闭这个功能，或者基于一个布尔值。

因此，为了防止用户向下滑动并无意中丢失他们的更改，我们可以应用`interactiveDismissDisabled`并传入视图模型的`isModified`属性:

这意味着用户仍然可以通过向下滑动来关闭编辑对话框，但前提是他们没有对提醒进行任何更改。如果他们做了任何更改，视图模型被标记为*修改*，向下滑动将被禁用。

# 确认交互式解散

这非常有效，在许多情况下，这可能正是您所需要的。苹果的提醒应用程序更进一步，当用户试图通过向下滑动来关闭编辑对话框时，它会显示一个确认对话框。这与用户点击*取消*按钮时应用程序显示的相同。

不幸的是，在当前版本的`interactiveDismissDisabled`中实现这种行为是不可能的，因为没有办法对用户试图*关闭表单做出反应。在 UIKit 应用程序中，我们可以使用`UIAdaptivePresentationControllerDelegate`来实现这种行为——这个协议有一个方法`presentationControllerDidAttemptToDismiss`,当用户试图关闭视图控制器时，这个方法就会被调用。可以肯定的是，苹果最终会通过`interactiveDismissDisabled`视图修改器提供这一功能，但同时，我认为在等待苹果解决 FB9782213(我申请将这一行为添加到视图修改器中)时，实现一个我们可以使用的嵌入式解决方案将是一个有趣的练习。*

我的解决方案受到了这个 [StackOverflow 问题](https://stackoverflow.com/questions/56615408/prevent-dismissal-of-modal-view-controller-in-swiftui)和 [this gist](https://gist.github.com/mobilinked/9b6086b3760bcf1e5432932dad0813c0) 的几个答案的启发，我试图像我相信苹果的 SwiftUI 团队那样对它建模。他们说，预测未来的最好方法是发明它——但是苹果仍然可能选择不同的 API 和行为。

解决方案的核心是一个符合`UIViewControllerRrepresentable`的视图，它允许我们响应`presentationControllerShouldDismiss`和`presentationControllerDidAttemptToDismiss`:

为了使这在任何视图上都可以访问，我在`View`上添加了一个扩展，包含了两个重载版本的`interactiveDismissDisabled`。第一个函数带有一个额外的参数，即闭包。通过实现这个闭包，您可以对试图关闭工作表的用户做出反应。第二个重载版本将绑定到一个`Bool`作为它的第二个参数。这使得使用这种方法来驱动确认对话框的显示状态变得更加容易。你可以这样使用它:

(很明显，你只需要使用两个选项中的一个！)

我已经将这段代码提取到一个[要点](https://gist.github.com/peterfriese/8fb3d76bdbe21b84495b79b3a86bf898)中，包括一个简单的示例应用程序——请随意在您的应用程序中使用我的实现，但请注意，我的解决方案将(希望)在不太遥远的将来被锁定，我将尽最大努力维护它。

# 可重复使用的确认对话框

作为这篇文章的最后一步，让我们把目前为止所得到的变成一个可重用的解决方案。能够在应用程序的其他屏幕中轻松重用该解决方案将使我们能够为用户创造更具凝聚力的体验。

如果您使用 SwiftUI，您已经使用了它的内置视图修改器。在下面的代码片段中，`font()`、`padding()`和`foregroundColor()`都是视图修饰符:

视图修改器是为什么用 SwiftUI 构建 UI 是如此愉快的体验的一个关键原因。如果我们没有视图修改器，我们将不得不使用视图的初始化参数来配置视图，这根本不是一个非常可扩展的方法。

SwiftUI 还允许我们自己创建定制的视图修改器，也许你之前已经这样做了，以使你的代码更容易阅读。

为了实现一个定制的视图修改器，我们需要创建一个符合`ViewModifier`协议的结构。该协议的唯一要求是`body`方法。它的作用类似于视图的`body`方法——事实上，两种方法的结果都是`some View`，因为两者都返回一个视图。然而，视图修改器的`body`方法只有一个参数`content`。此参数包含应用视图修改器的视图。

下面是`ViewModifier`的声明(取自`SwiftUI.swift`文件:

让我们实现一个视图修改器，即我们到目前为止创建的确认对话框实现。它应该:

*   使用工具栏显示*完成*和*取消*按钮
*   如果用户对屏幕上的数据进行了任何更改，为调用者提供一种信号方式
*   如果用户在修改屏幕上的数据后试图取消对话框，则显示确认对话框
*   如果数据已被修改，防止工作表的交互式关闭

我们将从创建视图修改器的框架开始，并将我们为`toolbar`、`confirmationDialog`和`interactiveDismissDisabled`编写的所有代码移动到新修改器的`body`方法中:

正如你所看到的，我们正在使用`body`函数的`content`参数，在这里我们之前有编辑屏幕的视图。

为了让上面的代码工作，我们需要添加一些缺失的部分:

就像普通视图一样，视图修改器可以访问环境，这允许我们访问`dismiss`动作，使得一旦用户点击 *Done* 按钮就很容易关闭对话框。

同样值得注意的是，视图修饰符可以保持状态，这就是为什么我们能够根据需要使用`presentingConfirmationDialog`来显示/隐藏确认对话框。

Swift 将根据未初始化的属性`isModified`、`onCancel`和`onCommit`为我们自动合成一个初始化程序。保持属性的顺序是很重要的，因为这将是它们在初始化参数列表中的顺序。

`isModified`是一个属性，调用者可以使用它来指示对话框中显示的数据是否已被修改。

我们现在可以像这样使用视图修改器:

由于编写起来有点麻烦，视图修改器通常会在`View`上进行扩展，该扩展定义了一个方便的方法，使得应用视图修改器更加容易:

这使得调用视图修改器看起来更加赏心悦目:

# 关闭

对于任何可能难以恢复的更改，例如在复杂的编辑表单中或删除数据时，提供确认提示非常重要。

在本文中，我向您展示了 MakeItSo 中编辑屏幕确认对话框的实现，这是一个试图尽可能复制苹果提醒应用程序的应用程序。如您所见，我们能够使用 SwiftUI 的内置功能复制大部分行为，并且大部分实现非常简单，不需要大量代码。

例如，由于我们的数据模型使用了结构，所以很容易检测用户是否进行了任何更改:由于结构是值对象，所以我们可以通过使用简单的相等检查将当前编辑的 todo 项与原始项进行比较来检测更改。由于我们为编辑屏幕设置了一个视图模型，我们能够很好地将这个逻辑封装在视图模型中，这保持了视图代码的整洁。

在 iOS 15 中，苹果取消了一些视图修改器，并提供了新的视图修改器。在过去，你可能会使用`actionSheet`，现在不推荐使用，将被`confirmationDialog`取代。该 API 在一些细微的方面有所改变，使其更易于使用。隐藏标题的能力是一个受欢迎的附加功能，事实上 SwiftUI 将自动使用特定于平台的行为。

离开编辑对话框应该是一个有意识的决定，并且由于新的`interactiveDismissDisabled`视图修改器，如果有一些未保存的更改(或任何其他未完成的工作)，现在可以防止用户通过向下滑动来离开表单。不幸的是，当用户试图关闭肮脏的编辑对话框时，不可能显示确认对话框。我向您展示了如何基于 UIKit 实现针对这一缺点的后备解决方案。然而，由于我们可以期待苹果在不久的将来填补这一空白(甚至可能是下一个测试版)，我们应该只把这看作是一个临时的解决方案，我已经向苹果提交了一份反馈来解决这一问题。

我希望你像我研究这个主题和实现一个解决方案一样喜欢这个实现确认对话框的小弯路。

感谢阅读。

*原载于*[*https://peterfriese . dev*](https://peterfriese.dev/swiftui-confirmation-dialogs/)*。*