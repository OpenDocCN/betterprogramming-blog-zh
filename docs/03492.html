<html>
<head>
<title>Exploring Android View Binding in Depth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探索Android视图绑定</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-viewbinding-in-depth-598925821e41?source=collection_archive---------3-----------------------#2020-02-13">https://betterprogramming.pub/exploring-viewbinding-in-depth-598925821e41?source=collection_archive---------3-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2fe1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用带有<include>、<merge>、适配器、片段和活动的ViewBinding</merge></include></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17373b9e9ba9295b354f51fa3e43cdba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfpK0zSsEVvhB7M5eyo69g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://youtu.be/Qxj2eBmXLHg?t=506" rel="noopener ugc nofollow" target="_blank">谷歌I/O 2019 </a></p></figure><p id="7664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谷歌在谷歌I/O 2019的<a class="ae ky" href="https://youtu.be/td3Kd7fOROw?t=1758" rel="noopener ugc nofollow" target="_blank">Android新功能会议</a>中引入了视图绑定。</p><p id="8b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://youtu.be/Qxj2eBmXLHg?list=PLWz5rJ2EKKc9FfSQIRXEWyWpHD6TtwxMM&amp;t=447" rel="noopener ugc nofollow" target="_blank">架构组件的新特性</a>中有一个关于视图绑定的简短讨论，它比较了视图绑定与现有解决方案，并进一步讨论了为什么视图绑定比数据绑定或Kotlin synthetics等现有解决方案更好。</p><p id="62b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，Kotlin synthetics工作得很好，但所有ID都驻留在一个全局名称空间中，因此如果您使用同名的ID，并且如果您从错误的布局中导入ID，您将会崩溃，因为ID不是当前布局的一部分，除非您运行应用程序并转到该布局，否则无法提前知道这一点。</p><p id="a4f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面这篇文章很好地概述了Kotlin合成材料的问题。</p><div class="lv lw gp gr lx ly"><a href="https://proandroiddev.com/the-argument-over-kotlin-synthetics-735305dd4ed0" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">关于科特林合成品的争论</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">这一切都始于一条提交消息</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">proandroiddev.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="3132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图绑定将在Android studio的3.6稳定版本中提供，但如果你想尝试它，你需要下载Android Studio 3.6 RC 3。<br/>编辑:作为Android Studio 3.6稳定版的一部分，视图绑定现在对每个人都可用。</p><p id="0e19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图绑定的主要优点是所有的绑定类都是由<a class="ae ky" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>插件生成的，所以它对构建时间没有影响，并且具有编译时安全性(我们将在示例中看到)。</p><p id="8d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从启用视图绑定开始。我们需要将以下内容添加到模块的<code class="fe mn mo mp mq b">build.gradle</code>文件中:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="ab98" class="mv mw it mq b gy mx my l mz na">// Android Studio 3.6.X<br/>android {<br/>    viewBinding {<br/>        enabled = true<br/>    }<br/>}</span><span id="1bf8" class="mv mw it mq b gy nb my l mz na">// Android Studio 4.0+<br/>android {<br/>    buildFeatures {<br/>        viewBinding = true<br/>    }<br/>}</span></pre><p id="5884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:视图绑定是在一个模块接一个模块的基础上启用的，所以如果您有一个多模块项目设置，您需要在每个<code class="fe mn mo mp mq b">build.gradle</code>文件中添加上面的代码。</p><p id="f61c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想禁用视图绑定特定布局，那么你需要添加<code class="fe mn mo mp mq b">tools:viewBindingIgnore=”true”</code>到布局文件的根视图。</p><p id="aea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用它后，我们可以立即开始使用它，当您完成同步您的<code class="fe mn mo mp mq b">build.gradle</code>文件时，所有的绑定类都会默认生成。</p><p id="147e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它通过将XML布局文件名转换为camel大小写并在末尾添加<code class="fe mn mo mp mq b">Binding</code>来生成一个绑定类。例如，如果你的布局文件被命名为<code class="fe mn mo mp mq b">activity_splash</code> <em class="nc"> </em>，那么它将生成绑定类<code class="fe mn mo mp mq b">ActivitySplashBinding</code>。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="1c10" class="nk mw it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">我如何使用它？</h1><h2 id="6394" class="mv mw it bd nl ob oc dn np od oe dp nt li of og nv lm oh oi nx lq oj ok nz ol bi translated">在活动中</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个名为<code class="fe mn mo mp mq b">activity_splash</code> <em class="nc"> </em>的布局文件，其中有一个ID为<code class="fe mn mo mp mq b">tvVersionName</code> <em class="nc"> </em>的<code class="fe mn mo mp mq b">TextView</code>，所以在使用视图绑定时，我们所要做的就是获取绑定类的引用，比如:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="59de" class="mv mw it mq b gy mx my l mz na">val binding: ActivitySplashBinding = ActivitySplashBinding.inflate(layoutInflater) </span></pre><p id="bea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并在返回我们布局的根布局的<code class="fe mn mo mp mq b">setContentView()</code>方法中使用它的<code class="fe mn mo mp mq b">getRoot()</code>。可以从我们创建的绑定类对象中访问视图，我们可以在创建对象后立即使用它，如下所示:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="02a5" class="mv mw it mq b gy mx my l mz na">binding.tvVersionName.text = getString(R.string.version)</span></pre><p id="d12c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，绑定类知道<code class="fe mn mo mp mq b">tvVersionName </code>是一个<code class="fe mn mo mp mq b">TextView</code>，所以我们不必担心类型转换。</p><h2 id="2915" class="mv mw it bd nl ob oc dn np od oe dp nt li of og nv lm oh oi nx lq oj ok nz ol bi translated">成碎片</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="c893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在片段中使用视图绑定略有不同。我们需要传递<code class="fe mn mo mp mq b">LayoutInflator</code>、<code class="fe mn mo mp mq b">ViewGroup</code>和一个通过覆盖<code class="fe mn mo mp mq b">onCreateView()</code>得到的<code class="fe mn mo mp mq b">attachToRoot</code>布尔变量。</p><p id="2d06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要通过调用<code class="fe mn mo mp mq b">binding.root</code>返回根视图来返回视图。您还注意到我们使用了两个不同的变量，并且在<code class="fe mn mo mp mq b">onDestroyView()</code>中<code class="fe mn mo mp mq b">_binding</code>变量被设置为空。</p><p id="d2c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为片段的生命周期不同于活动的生命周期，片段可以比它们的视图活得更久，所以如果我们不将它设置为null，就可能会出现内存泄漏。</p><p id="e0b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个变量是通过使一个变量为空，另一个为非空来避免使用<code class="fe mn mo mp mq b">!!</code>的空检查。</p><h2 id="2a5e" class="mv mw it bd nl ob oc dn np od oe dp nt li of og nv lm oh oi nx lq oj ok nz ol bi translated">在RecyclerView适配器中</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">row_payment.xml</code>是我们的<code class="fe mn mo mp mq b">RecyclerView</code>行的项目布局文件，这就是为什么会生成<code class="fe mn mo mp mq b">RowPaymentBinding</code> <em class="nc"> </em>类。</p><p id="ddc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要做的就是调用<code class="fe mn mo mp mq b">inflate()</code>方法，传递<code class="fe mn mo mp mq b">onCreateViewHolder()</code>中可用的所需参数，传递我们的<code class="fe mn mo mp mq b">PaymentHolder</code> <em class="nc"> </em>类的主构造函数中生成的绑定类对象，并将<code class="fe mn mo mp mq b">itemBinding.root</code>传递给<code class="fe mn mo mp mq b">RecyclerView.ViewHolder()</code>构造函数。就是这样。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="f040" class="nk mw it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">处理<include> d布局</include></h1><p id="55a3" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">视图绑定可与<code class="fe mn mo mp mq b">&lt;include&gt;</code>布局标签一起使用。布局中通常包含两种<code class="fe mn mo mp mq b">&lt;include&gt;</code>标签，有或者没有<code class="fe mn mo mp mq b">&lt;merge&gt;</code> <em class="nc">。</em></p><ul class=""><li id="7b39" class="ot ou it lb b lc ld lf lg li ov lm ow lq ox lu oy oz pa pb bi translated"><code class="fe mn mo mp mq b">&lt;include&gt;</code>不带<code class="fe mn mo mp mq b">&lt;merge&gt;</code>。</li></ul><p id="46ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要给<code class="fe mn mo mp mq b">&lt;include&gt;</code>分配一个ID，然后使用这个ID访问包含的布局中的视图。让我们来看一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="dc61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们在布局文件中包含了一个公共工具栏，<code class="fe mn mo mp mq b">&lt;include&gt;</code>有一个<code class="fe mn mo mp mq b">android:id=“@+id/appbar”</code> ID，我们将使用它从<code class="fe mn mo mp mq b">app_bar.xml</code>访问工具栏，并将其设置为我们的支持动作栏。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><ul class=""><li id="4637" class="ot ou it lb b lc ld lf lg li ov lm ow lq ox lu oy oz pa pb bi translated"><code class="fe mn mo mp mq b">&lt;include&gt;</code>同<code class="fe mn mo mp mq b">&lt;merge&gt;</code>。</li></ul><p id="4fb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时我们有一个带有<code class="fe mn mo mp mq b">&lt;merge&gt;</code>标签的布局，当一个布局包含在另一个布局中时，它有助于消除视图层次中的冗余视图组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b0fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个布局像往常一样包含在我们的布局文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="04f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图给这个<code class="fe mn mo mp mq b">&lt;include&gt;</code>一个ID，视图绑定不会在绑定类中生成ID，所以我们不能像在普通包含的情况下那样访问视图。</p><p id="5020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们有<code class="fe mn mo mp mq b">PlaceholderBinding</code> <em class="nc"> </em>，它是为<code class="fe mn mo mp mq b">placeholder.xml</code>(我们的<code class="fe mn mo mp mq b">&lt;merge&gt;</code>布局文件)自动生成的类。我们必须调用它的<code class="fe mn mo mp mq b">bind()</code>方法，并传递包含它的布局的根视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="bd31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以像<code class="fe mn mo mp mq b">placeholderBinding.tvPlaceholder.text</code>一样从我们的类中访问<code class="fe mn mo mp mq b">placeholder.xml</code>中的视图。</p><p id="5a66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我很想在评论中听到你的意见。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="8988" class="nk mw it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">来源:</h1><ul class=""><li id="01c6" class="ot ou it lb b lc oo lf op li pc lm pd lq pe lu oy oz pa pb bi translated"><a class="ae ky" href="https://developer.android.com/topic/libraries/view-binding" rel="noopener ugc nofollow" target="_blank"> Android开发者文档—视图绑定</a></li></ul></div></div>    
</body>
</html>