<html>
<head>
<title>How to Upload Media and Process Multipart Forms on Node.js Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js服务器上上传媒体和处理多部分表单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-upload-media-and-process-multipart-forms-on-node-js-server-cf483af5afa7?source=collection_archive---------7-----------------------#2021-02-03">https://betterprogramming.pub/how-to-upload-media-and-process-multipart-forms-on-node-js-server-cf483af5afa7?source=collection_archive---------7-----------------------#2021-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f3c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">高效上传图像和其他文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c66249fb4402c48a9d6268a1a2fa7cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-2unkpJMIOFboJl4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们上传吧！<a class="ae ky" href="https://unsplash.com/@vnwayne?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">范伟恩</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bfd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您有一个前端应用程序与后端通信，并且您需要在处理元数据之前将媒体上传到CDN提供商？太好了，我们将在<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>下看看如何在考虑重用和灵活性的情况下做到这一点。</p><p id="bf66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将介绍如何编写服务器端CDN服务，抽象出CDN提供者API，以及多部分表单数据解析服务。我们还将简要地处理客户端代码。</p><p id="a561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我的“用JavaScript解决现实生活中的问题”系列的第二部分。第一部分是关于WebSockets的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="855b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">背景</h1><p id="90b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将使用CDN提供商API。我选择了<a class="ae ky" href="https://github.com/cloudinary/cloudinary_npm" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Cloudinary </strong> </a>，它是一个很棒的工具，具有许多功能，一个慷慨的自由层，以及一个用于Node.js的npm包，对于解析HTML表单数据，我们将依靠优秀的<a class="ae ky" href="https://github.com/mscdex/busboy" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> busboy </strong> </a>库来完成底层工作。</p><p id="dc39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的目标是编写抽象这些工具的可重用服务(因此，如果您需要切换到另一个CDN提供商API，您只需编辑CDN服务)，这样我们就可以在我们选择的服务器上使用服务器端。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb67" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置CDN服务</h1><p id="941e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">CDN服务将实现三个方法:<code class="fe mz na nb nc b">start</code>、<code class="fe mz na nb nc b">end</code>和<code class="fe mz na nb nc b">setStream</code>，它接受两个参数:一个文件夹名和一个回调。下面是完整的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/a372db77a347cd18b1a0fca8210a3197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rY8zvOhTqBTctvDLnw1nhw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参见<a class="ae ky" href="https://gist.github.com/iperiago/3d1a5ebe888ed98c617319064a726e5c#file-cdn-js" rel="noopener ugc nofollow" target="_blank">要点</a></p></figure><p id="54f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，你需要在你的构造函数中注入一个<code class="fe mz na nb nc b">config</code>对象，并带有所需的Cloudinary配置参数(参见他们的<a class="ae ky" href="https://cloudinary.com/documentation/image_upload_api_reference" rel="noopener ugc nofollow" target="_blank">文档</a>)。</p><p id="625f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码非常简单，但是依赖于Cloudinary的API自己的方法。请注意，我们在<code class="fe mz na nb nc b">setStream</code>方法中的回调是用一个专门构造的文件名调用的——在调用了Cloudinary的<code class="fe mz na nb nc b">uploader.upload_stream</code>方法<em class="ne">之后，它利用了cloud inary的API提供的<code class="fe mz na nb nc b">result </code>对象。</em></p><p id="9f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">result</code>对象的<code class="fe mz na nb nc b">public_id</code>属性具有以下形式:<code class="fe mz na nb nc b">[folder]/id</code>，因此我们通过仅保留<code class="fe mz na nb nc b">id</code>并添加媒体格式来构建文件名。</p><p id="ab7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件名将在我们的应用程序中使用，例如，保存在数据库中。当然，通过向<code class="fe mz na nb nc b">setStream</code>方法提供额外的参数，您可以选择以完全不同的方式构建文件名。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="01c3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置解析器服务</h1><p id="b5fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然我们已经抽象出了与CDN提供商通信的代码，我们可以在解析服务中使用它，作为一个依赖项。事实上，我鼓励您在服务中使用依赖注入(DI)机制。</p><p id="b052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的解析服务的核心将具有以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/e36e38c7761d286fd836317d7268e9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6RNjAkLwH3hxgyNH7MELw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参见<a class="ae ky" href="https://gist.github.com/iperiago/3d1a5ebe888ed98c617319064a726e5c#file-parse-js" rel="noopener ugc nofollow" target="_blank">要点</a></p></figure><p id="a2e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的解析器属性是:请求(注入的)、我们的CDN服务(注入的)、文件路径(将通过我们的CDN服务获得)，以及伴随媒体的HTML表单的任何其他字段。</p><p id="20ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">exec</code>方法是基于承诺的。它用请求头调用busboy，并设置一系列事件和事件处理程序。然后它通过管道将busboy解析器传递给请求。更多信息请参考<a class="ae ky" href="https://github.com/mscdex/busboy" rel="noopener ugc nofollow" target="_blank">勤杂工文档</a>。</p><p id="2687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在事件处理程序如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/b0ed26ec3b29f7d25c2470b55c2de65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUyw621ueMtJ_tIVUyXD2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参见<a class="ae ky" href="https://gist.github.com/iperiago/3d1a5ebe888ed98c617319064a726e5c#file-parse-js" rel="noopener ugc nofollow" target="_blank">要点</a></p></figure><p id="99bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">onFile</code>处理程序接受两个参数:<code class="fe mz na nb nc b">name</code>，它是媒体文件的字段名(在客户端，我们将该名称设置为Cloudinary文件夹，详见下文)，以及<code class="fe mz na nb nc b">file</code>，它是实际的媒体文件。</p><p id="f5c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，该方法向服务<code class="fe mz na nb nc b">filepaths</code>数组添加一个新条目，这允许我们一次进行多次上传，只要有从HTML表单数据解析的文件。这个条目是一个等待文件上传时解决的承诺。</p><p id="c6ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用了所有的CDN服务方法:<code class="fe mz na nb nc b">setStream</code>来设置上传及其结果格式(见上文:这将是我们专门构造的文件名)，然后<code class="fe mz na nb nc b">start</code>和<code class="fe mz na nb nc b">end</code>作为文件上传生命周期中的事件处理程序。</p><p id="9ad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表单数据也可以包含由<code class="fe mz na nb nc b">onField</code>方法处理的常规字段。</p><p id="7f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当解析完成时，我们可以解析我们的文件路径的所有承诺。这是<code class="fe mz na nb nc b">onEnd</code>方法的工作，它本身必须是异步的，因此返回一个承诺。这个过程解析了解析服务<code class="fe mz na nb nc b">exec</code>方法的包装承诺，结果是一个包含所有常规字段和所有文件路径(这里是我们的文件名)的对象。</p><p id="7550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于整个过程涉及多个承诺，代码可能很难一目了然。但是一旦你理解了流程，你会发现它实际上非常简单。</p><p id="7619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的解析服务代码可以在本<a class="ae ky" href="https://gist.github.com/iperiago/3d1a5ebe888ed98c617319064a726e5c#file-parse-js" rel="noopener ugc nofollow" target="_blank">概要</a>中获得。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="84b3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">绑起来</h1><p id="9f62" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所以我们现在有了解析服务，它本身使用我们的CDN服务。当收到一个新的多部分表单请求时，我们如何调用前者？当然，这取决于您使用的服务器框架，但是从一个框架适应另一个框架应该不成问题，所以我将使用<a class="ae ky" href="https://koajs.com" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Koa </strong> </a>作为例子。我们可以这样编写多部分的Koa中间件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/403f0d151bc362a680a2636bbb6cf9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14ksIMm3sC6kdDsGeLCEXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参见<a class="ae ky" href="https://gist.github.com/iperiago/3d1a5ebe888ed98c617319064a726e5c#file-multipart-js" rel="noopener ugc nofollow" target="_blank">要点</a></p></figure><p id="da7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有一个多部分请求(Koa提供了一种简便的检查方法)，我们只需用请求和我们的CDN服务实例化我们的解析器，然后等待解析器的<code class="fe mz na nb nc b">exec</code>方法进行解析。</p><p id="d45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将结果字段和文件路径分配给请求体，这样就可以在控制器中处理路由了。该过程确保媒体已经上传，并且我们已经为它们获得了有效的文件路径。我们现在可以使用添加了信息的路由，例如，在数据库中保存每次上传的字段和文件路径。不过，剩下的过程由您来完成，因为这超出了本文的范围。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b91" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">客户端设置</h1><p id="297d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在客户端，基本上您所要做的就是发送一个多方请求。作为一个使用Vue.js和<a class="ae ky" href="https://quasar.dev/vue-components/uploader" rel="noopener ugc nofollow" target="_blank"> Quasar framework的上传组件</a>的快速示例，您将编写:</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="2323" class="nm md it nc b gy nn no l np nq">&lt;q-uploader :factory="uploader" multiple /&gt;</span></pre><p id="7f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最基本的层面上，您的uploader方法的canva将如下所示(假设我们在这里的<code class="fe mz na nb nc b">profile_pictures</code>文件夹中上传):</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="5bcd" class="nm md it nc b gy nn no l np nq">async uploader (files) {<br/>  const data = new FormData()</span><span id="cfe7" class="nm md it nc b gy nr no l np nq">  files.forEach(file =&gt; data.append(‘profile_pictures’, file))</span><span id="6605" class="nm md it nc b gy nr no l np nq">  // Add regular fields if needed then send the request<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1c03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6e3a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当然，所有这些都可以在许多方面得到很大的改进——添加日志记录，一旦上传完成就从CDN提供商那里获得更多信息，等等。我故意省略了一些实现细节，特别是在客户端和HTTP服务器级别，主要是因为我想关注可以在许多不同上下文中使用的可重用服务。另外，因为我觉得如果你自己去做，会更有学习价值。</p><p id="76a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我猜…编码快乐！</p></div></div>    
</body>
</html>