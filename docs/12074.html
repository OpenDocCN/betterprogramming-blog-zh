<html>
<head>
<title>Data Manipulation Using RxJS Declarative Pattern in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在角度分析中使用rjs声明模式的数据操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-manipulation-using-rxjs-declarative-pattern-in-angular-f6ea635886eb?source=collection_archive---------1-----------------------#2022-05-10">https://betterprogramming.pub/data-manipulation-using-rxjs-declarative-pattern-in-angular-f6ea635886eb?source=collection_archive---------1-----------------------#2022-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="0921" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/rxjs-39bc4f4110ec" rel="noopener">rjs</a>、<a class="ae ep" href="https://medium.com/@lorenzozar/list/angular-5496c492a185" rel="noopener">转角</a></h2><div class=""/><div class=""><h2 id="bcc8" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">在Angular中使用声明性RxJS模式处理数据</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a3af488465aef4ad286aa24be27a70ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Od_7B3N1IJgyNgYT_rblYg.png"/></div></div></figure><p id="fcd8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">虽然命令式和声明式编程风格都可以在正确的上下文中增加价值，但是将一些代码的执行委托给编程语言可以优化时间。</p><p id="0e3d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过在Angular中使用rjs声明性模式，当模板中需要数据时，我们可以委托执行一些代码来获取数据。</p><p id="1e82" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">例如，我们来看看下面的<a class="ae lw" href="https://www.vitainbeta.org/2022/05/03/angular-async-pipe/" rel="noopener ugc nofollow" target="_blank">异步管道</a>:</p><pre class="kp kq kr ks gt lx ly lz ma aw mb bi"><span id="c40d" class="mc md iq ly b gy me mf l mg mh">// app.component.html</span><span id="f6a5" class="mc md iq ly b gy mi mf l mg mh">&lt;div *ngIf="data$ | async as data"&gt;<br/>  {{ data.title }}<br/>&lt;/div&gt;</span></pre><p id="47b3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过使用<code class="fe mj mk ml ly b">async</code>管道，我们不需要订阅或取消订阅可观察到的东西。Angular会自动处理。</p><p id="5d64" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是，一旦加载了模板，异步管道就会获取数据并按原样显示。</p><p id="b8f5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通常，我们需要在显示数据之前对其进行处理。为此，我们可以使用一些rjs运算符在数据到达模板之前对其进行操作。</p><h1 id="1cae" class="mm md iq bd mn mo mp mq mr ms mt mu mv kf mw kg mx ki my kj mz kl na km nb nc bi translated">声明性数据操作</h1><p id="092b" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">想象一下这样一种情况:您从一个HTTP调用接收数据，并希望在组件中使用它之前对其进行操作。</p><p id="7a05" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">例如，我们将使用HttpClient服务从服务器获取数据。<em class="ni">异步方法发送一个HTTP请求，并返回一个可观测量，当接收到响应时发出请求的数据</em>，<a class="ae lw" href="https://angular.io/guide/http#requesting-data-from-a-server" rel="noopener ugc nofollow" target="_blank"> angular.io </a>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e0e7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在我们的例子中，可观察的包含一个特定形状的物体，所以我们可以创建一个<a class="ae lw" href="https://www.typescriptlang.org/docs/handbook/2/objects.html" rel="noopener ugc nofollow" target="_blank">界面</a>如下:</p><pre class="kp kq kr ks gt lx ly lz ma aw mb bi"><span id="cca9" class="mc md iq ly b gy me mf l mg mh">interface ToDo {</span><span id="4dfc" class="mc md iq ly b gy mi mf l mg mh">  userId: number;<br/>  id: number;<br/>  title: string;<br/>  completed: boolean;</span><span id="3074" class="mc md iq ly b gy mi mf l mg mh">}</span></pre><p id="fbec" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们想在显示标题键之前改变它的值。</p><h2 id="bf78" class="mc md iq bd mn nl nm dn mr nn no dp mv lj np nq mx ln nr ns mz lr nt nu nb iw bi translated">经典图案</h2><p id="3334" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">遵循一个命令式模式，我们将使用subscribe方法来订阅可观察的，可能在<code class="fe mj mk ml ly b">ngOnInit</code>中。</p><p id="26a0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后，我们将结果分配给一个变量，并最终在我们需要时操纵该变量。</p><p id="d904" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">例如，下面的代码将订阅的结果分配给<code class="fe mj mk ml ly b">subscription</code>变量。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d39b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果我们需要改变<code class="fe mj mk ml ly b">subscription</code>变量的值，我们可能会创建一个采用<code class="fe mj mk ml ly b">subscription</code>的方法，并在模板中使用之前改变标题。</p><h2 id="5a04" class="mc md iq bd mn nl nm dn mr nn no dp mv lj np nq mx ln nr ns mz lr nt nu nb iw bi translated">声明性数据操作</h2><p id="2550" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">在尝试声明性的同时，您可能想知道如何在不使用<code class="fe mj mk ml ly b">subscribe</code>方法的情况下操作数据。</p><p id="cf9d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面是初始的声明性代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5ffa" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">第10行是起点。</p><p id="15f1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们定义一个名为<code class="fe mj mk ml ly b">data$</code>的本地属性，并将服务中的可观察对象分配给该属性，使其在组件中可用。</p><p id="317a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果您没有阅读Angular 中的<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/rxjs-declarative-pattern-in-angular-cafba3983d21"> RxJS声明模式，请注意此时我们的代码没有“执行”可观察对象！</a></p><p id="0f58" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">换句话说，没有与从服务器获取数据相关的网络请求。这里什么都没有发生。<code class="fe mj mk ml ly b">data$</code>是空的可观测。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d01c26e251743230e646fc7b5805443a.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*ZYOpqHjfIyfJ6JQ40ing-Q.png"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">在任何订阅或异步管道之前记录可观察对象</p></figure><p id="2fc1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当我们订阅可观察对象或者在模板中使用异步管道时，<code class="fe mj mk ml ly b">data$</code>的值将会改变。</p><p id="b9b0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如上所述，前一种选择与反应式方法相反，因此我们只能使用异步管道。然而，一旦Angular渲染了组件视图，异步管道就会触发<code class="fe mj mk ml ly b">data$</code>并显示我们从可观察对象中获得的任何内容。</p><p id="70df" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，我们需要在从服务获取数据之后，在异步管道“调用”数据之前，对数据进行操作。</p><p id="a608" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为此，我们将使用<a class="ae lw" href="https://rxjs.dev/api/index/function/pipe" rel="noopener ugc nofollow" target="_blank"> RxJS管道</a> API和<a class="ae lw" href="https://www.vitainbeta.org/2022/03/29/hands-on-rxjs-operators-map-operator/" rel="noopener ugc nofollow" target="_blank"> RxJS映射操作符</a>。</p><h2 id="390b" class="mc md iq bd mn nl nm dn mr nn no dp mv lj np nq mx ln nr ns mz lr nt nu nb iw bi translated"><strong class="ak"> RxJS管道</strong></h2><p id="ccf6" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">我们可以如下使用管道:</p><pre class="kp kq kr ks gt lx ly lz ma aw mb bi"><span id="998c" class="mc md iq ly b gy me mf l mg mh">data$ = this.todoService.todo$.pipe(</span><span id="793b" class="mc md iq ly b gy mi mf l mg mh">  operator1(),<br/>  operator2(),<br/>  operatorN()</span><span id="3d54" class="mc md iq ly b gy mi mf l mg mh">);</span></pre><p id="df76" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">简单来说:</p><ol class=""><li id="d5a1" class="oa ob iq lc b ld le lg lh lj oc ln od lr oe lv of og oh oi bi translated">我们从服务中获得的可观察信息进入了<code class="fe mj mk ml ly b">pipe().</code></li><li id="0b88" class="oa ob iq lc b ld oj lg ok lj ol ln om lr on lv of og oh oi bi translated">它通过第一个操作符，并根据返回新的可观察值的函数进行操作。</li><li id="f49d" class="oa ob iq lc b ld oj lg ok lj ol ln om lr on lv of og oh oi bi translated">新的可观察值进入第二个操作符，根据提供的函数进行操作，依此类推，直到管道中的最后一个操作符。</li><li id="d771" class="oa ob iq lc b ld oj lg ok lj ol ln om lr on lv of og oh oi bi translated">最后，一旦我们订阅了它，可观察值就存储在<code class="fe mj mk ml ly b">data$</code>中。否则，我们只是声明了我们想要得到的东西，但是<code class="fe mj mk ml ly b">data$</code>仍然是空的，直到我们在模板中使用异步管道。</li></ol><h2 id="d6c2" class="mc md iq bd mn nl nm dn mr nn no dp mv lj np nq mx ln nr ns mz lr nt nu nb iw bi translated">RxJS映射运算符</h2><p id="14c7" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">按照上面的代码，我们将使用RxJS map操作符来操作可观察对象，然后再将它提供给异步管道。</p><p id="6fb6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">简而言之，我们可以说<a class="ae lw" href="https://www.vitainbeta.org/2022/03/29/hands-on-rxjs-operators-map-operator/" rel="noopener ugc nofollow" target="_blank">映射操作符</a>通过我们提供的函数来转换每个发出的项目。</p><p id="2d9e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">它订阅输入流，根据提供的函数转换接收到的项，并使用转换后的项创建输出流。</p><p id="af8c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">RxJS映射操作符与JavaScript <code class="fe mj mk ml ly b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">map()</a></code> <a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">方法</a>非常相似，其用法如下:</p><pre class="kp kq kr ks gt lx ly lz ma aw mb bi"><span id="ac8a" class="mc md iq ly b gy me mf l mg mh">data$ = this.todoService.todo$.pipe(</span><span id="7cb1" class="mc md iq ly b gy mi mf l mg mh">  map((x) =&gt; ({ <br/>    ...x, <br/>    title: x.title + 'and more' <br/>  }))</span><span id="0ae4" class="mc md iq ly b gy mi mf l mg mh">);</span></pre><p id="f2f9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们从服务接收的可观察对象进入管道，通过我们在map operator中提供的函数，然后退出管道。</p><p id="9472" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在map操作符内部，我们声明了一个匿名函数<code class="fe mj mk ml ly b">() =&gt; {}</code>，它接受一个参数<code class="fe mj mk ml ly b">x</code>并返回一个对象。</p><p id="d4ce" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">由于使用了<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展语法</a>，返回的对象拥有我们传入的对象的所有键值对，但是我们更改了标题的值，添加了字符串<code class="fe mj mk ml ly b">'and more'</code>。</p><p id="1af4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">更准确地说，我们甚至可以声明参数<code class="fe mj mk ml ly b">x</code>的类型，这样代码就变成了:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">使用RxJS tap运算符进行数据操作</p></figure><p id="b1cc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您可能希望在另一个文件中声明该接口，以使它在其他地方可用。在这种情况下，在同一个代码片段中更容易看到它。</p><h1 id="4ae6" class="mm md iq bd mn mo mp mq mr ms mt mu mv kf mw kg mx ki my kj mz kl na km nb nc bi translated">关于声明性数据操作的考虑</h1><p id="f55d" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">然而，进行某些操作所需的代码量似乎会增加得相当快。</p><p id="ec00" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，使用声明性模式的好处可能会被“太多代码”的代价所抵消。</p><h2 id="527f" class="mc md iq bd mn nl nm dn mr nn no dp mv lj np nq mx ln nr ns mz lr nt nu nb iw bi translated">代码太多？</h2><p id="6620" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">声明性代码以其高抽象级别而著称。</p><p id="189b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">开发人员可以用压缩的方式表现复杂的模式。然而，程序越复杂，代码变得如此混乱以至于只能由最初编写它的开发人员阅读的风险就越高。</p><p id="a891" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这可不好。</p><p id="3fef" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一般来说，如果在团队中工作，我们希望能够维护和构建应用程序，而不依赖于单个个人的知识。</p><p id="dfa2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">此外，在业务环境中，可能需要花更多的时间在新员工或外部开发人员身上，以便他们完全理解代码结构。</p><p id="d305" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">总而言之，这甚至会增加你的成本。</p></div></div>    
</body>
</html>