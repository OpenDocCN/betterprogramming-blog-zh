<html>
<head>
<title>What You Should Inspect in a Front-End Code Review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在前端代码评审中您应该检查什么</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-you-should-inspect-in-a-front-end-code-review-4010e1bc285a?source=collection_archive---------6-----------------------#2020-07-27">https://betterprogramming.pub/what-you-should-inspect-in-a-front-end-code-review-4010e1bc285a?source=collection_archive---------6-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7309" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">开发者体验</h2><div class=""/><div class=""><h2 id="0c96" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">质量代码清单，包括Angular/React/Vue.js示例</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7b77c293c8119368cfa77a932938c6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxJOFpNnTEqWGvsnMKqwqA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">阿伦·范·德·波尔在<a class="ae lh" href="https://unsplash.com/s/photos/abstract?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="fcb1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你是一个前端团队的一员，有几个人才(包括你)，每天可能会有数百个提交。事实上，无论您使用什么团队方法来交付新特性，每个开发人员都在开发特定的功能。</p><p id="dccd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了验证他们的更改，开发人员应该请求一个合并请求(或拉请求)来将这些更改合并到公共分支(用于引用的分支)。其他前端开发人员会做代码审核。</p><p id="a20a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码审查非常重要，原因有四:</p><ul class=""><li id="9560" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">您可以检查代码是否满足规范。</li><li id="cd79" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">您被告知代码修改，这将潜在地引导您在活动分支上改变您的修改或者建议一些增强。</li><li id="6fb0" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">保证代码质量是一个很好的实践。</li><li id="804a" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">这是一种分享经验、技巧和编码技能的方式。</li></ul><p id="4c43" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们一起来看看您在下一次前端代码审查中应该检查什么。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ms"><img src="../Images/d61d09d351703163827a3dae17b23e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AN5DcC5TPsS5eEc2P59k7w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片来源:作者</p></figure><p id="c1b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了回顾代码变更，我们将关注五个主要主题:</p><ul class=""><li id="ad81" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">代码的质量</li><li id="54ea" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">代码的效率和健壮性</li><li id="9fa5" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">JS框架原则得到尊重了吗？</li><li id="3de9" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">GitFlow原则</li><li id="e8b2" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">可访问性(a11y)和国际化(i18n)</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="f414" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">代码的质量</h1><p id="fc69" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">源代码的质量水平总是很难评估，尤其是当它涉及到几个文件，并且在更广的层面上，涉及到整个应用程序时。</p><p id="58c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不管怎样，好的代码必须遵循一般的软件开发原则，不管是什么语言。以下是其中的一些。</p><h2 id="811e" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">干燥和代码分解</h2><p id="5fa6" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">如果我们被问及想到的软件开发中的第一条编码规则，我们肯定会干巴巴地回答:不要重复你自己。避免代码冗余是一个关键原则。</p><p id="07e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">查找代码重复包括检查源代码，找出在一个文件或一堆文件中重复多次的代码片段。它可以采用常量值、语句或一组静态值的形式。</p><p id="633a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，您可以建议用一个包含静态值或helpers/util函数的新文件来分解这些代码行，这些文件在项目中的任何地方都可以访问。</p><p id="c72d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">利用Javascript框架的技术和特性是一个好习惯。无论您使用Angular、React还是Vue.js，它们都提供了分解代码片段的工具。您应该检查一个方法是否可以重用为:</p><ul class=""><li id="6cfd" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">一款<a class="ae lh" href="https://vuejs.org/v2/guide/mixins.html" rel="noopener ugc nofollow" target="_blank">米欣</a></li><li id="7acc" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">一个<a class="ae lh" href="https://angular.io/guide/attribute-directives" rel="noopener ugc nofollow" target="_blank">角度</a>或<a class="ae lh" href="https://vuejs.org/v2/guide/custom-directive.html" rel="noopener ugc nofollow" target="_blank"> Vue </a>指令</li><li id="c744" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">一个<a class="ae lh" href="https://vuejs.org/v2/guide/filters.html" rel="noopener ugc nofollow" target="_blank">过滤器</a>或一个<a class="ae lh" href="https://angular.io/guide/pipes" rel="noopener ugc nofollow" target="_blank">管道</a></li><li id="a6ba" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">有角度的<a class="ae lh" href="https://angular.io/tutorial/toh-pt4" rel="noopener ugc nofollow" target="_blank">服务</a></li><li id="e606" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">一个反应过来的<a class="ae lh" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a></li></ul><p id="b489" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，可以将重复的模板提取到一个专用组件或一个<a class="ae lh" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">片段</a>(如果使用React)中，以便根据需要重用。这遵循React的<a class="ae lh" href="https://reactjs.org/docs/composition-vs-inheritance.html#specialization" rel="noopener ugc nofollow" target="_blank">组件专门化</a>规则。</p><h2 id="c619" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">有意义的评论</h2><p id="147a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">干净的代码不言自明。</p><p id="9310" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是为什么干净的代码不应该包含注释。变量名和方法名应该是超显式的。在这种情况下，阅读代码可能类似于阅读一本书——但情况并非总是如此。</p><p id="88ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实话实说吧。每个项目都有自己的特点，应该加以评论。欢迎有意义的评论来解释是怎么回事。但是什么是有意义的评论呢？</p><p id="9e5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它应该写在两行上。第一个解释了这种情况(我们为什么要这样做)。然后第二个指示面对问题的行动。例如，假设我们必须自动认证一个用户:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="415c" class="nx nb it oj b gy on oo l op oq"><em class="or">// If a network error occurred because no cookie<br/>// Login again with JWT (JSON Web Token)</em></span><span id="5718" class="nx nb it oj b gy os oo l op oq">if (err.message.includes('Missing Session token') &amp;&amp; jwt) {<br/>  await loginUser(jwt);<br/>  doSomethingElse();<br/>}</span></pre><p id="fafb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，寻找注释代码并抑制它们！事实上，注释一段代码以便以后激活它或者避免丢失它是一种常见的习惯。坦率地说，它在10%的时间里是有用的，所以你可以毫无疑问地建议删除它们。如果以后需要，您可以参考Git历史来检索代码片段。删除这些注释将节省你滚动的时间，并避免文件中不相关的代码。</p><h2 id="f25f" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">巧妙的样式表</h2><p id="c181" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">CSS不仅仅是一组给内容块赋予颜色或者在DOM中布局的规则。它附带了一些在你的项目的每一个组成部分中都必须遵循的策略。</p><p id="db87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">必须在每个模板中设置一个清晰的CSS结构，有明确的、有意义的类名。例如，检查是否使用了有状态的名称:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="bf3a" class="nx nb it oj b gy on oo l op oq">&lt;div class="phone-field<strong class="oj jd">--is-error</strong>"&gt;For input with error&lt;/div&gt;<br/>&lt;div class="phone-field<strong class="oj jd">--is-success</strong>"&gt;For input with valid value&lt;/div&gt;</span></pre><p id="7944" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">新的样式表语言如<a class="ae lh" href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank"> Sass </a>、<a class="ae lh" href="http://lesscss.org/" rel="noopener ugc nofollow" target="_blank"> Less </a>和<a class="ae lh" href="https://stylus-lang.com/" rel="noopener ugc nofollow" target="_blank"> Stylus </a>允许您创建可重用的CSS类，这要归功于类的组合、变量和混合。使用他们的超能力会节省你的时间和精力。那么检查CSS的改进是为组件制作可重用的布局和外观的好办法。</p><p id="43b9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对智能样式表的另一个潜在检查是关于模板中类的使用。事实上，使用CSS类定义的对象语法可以增强代码的可读性。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="4d76" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是CSS类定义的对象语法的文档:<a class="ae lh" href="https://angular.io/guide/attribute-binding#class-binding" rel="noopener ugc nofollow" target="_blank"> Angular </a>，<a class="ae lh" href="https://reactjs.org/docs/faq-styling.html" rel="noopener ugc nofollow" target="_blank"> React </a>，<a class="ae lh" href="https://vuejs.org/v2/guide/class-and-style.html#Object-Syntax" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>。</p><h2 id="52d6" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">单元测试呢？</h2><p id="2be9" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">我们永远不会停止说:一段好的代码是用单元测试来测试的。</p><p id="93b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些单元测试检查执行可能运行的每个分支。它确保了良好控制的代码基础，并允许您在引入修改时快速检测潜在的回归。</p><p id="3987" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">测试是计算机科学中一个独立的领域。许多来自软件开发的关键原则应该应用到测试中，比如DRY(前面看到的)和KISS(保持愚蠢和简单)。</p><p id="0344" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像<a class="ae lh" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>、<a class="ae lh" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha </a>、<a class="ae lh" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank"> Chai </a>和<a class="ae lh" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank"> Jasmine </a>这样的单元测试库提供了大量的方法来简化单元测试。如果你想通过e2e(端到端)集成测试来扩展你的测试电池，拥有超级友好和直观GUI的<a class="ae lh" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress </a>是一个不错的选择。</p><p id="a941" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个基本的验证可以是检查测试设置或后清理语句是否没有重复多次。<code class="fe ot ou ov oj b">beforeEach</code>和<code class="fe ot ou ov oj b">afterEach</code>是分别准备和后期清理操场的适当方法(由单元测试框架提供)。</p><p id="7f59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">测试命名也有其重要性。关于命名的一个良好实践是选择以下技术之一，并坚持使用:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="f139" class="nx nb it oj b gy on oo l op oq">it('SHOULD do something WHEN myVariable is true')</span><span id="436a" class="nx nb it oj b gy os oo l op oq"># OR</span><span id="59e9" class="nx nb it oj b gy os oo l op oq">myMethod_SHOULD_return_true_WHEN_myVariable_is_true()</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="921a" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">代码的效率和健壮性</h1><p id="cf74" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">代码的效率和健壮性是获得一个良好控制和无bug的代码库的主要关键。它基于开发人员的编码习惯和技能，这些都是随着经验而来的。</p><h2 id="96d8" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">处理意外值</h2><p id="ca38" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">即使你101%确定一个值总是被定义或者有一个期望值，在你的项目中的某个点上不会是这种情况。事实上，项目和应用程序会不断发展，可能会出现一些意想不到的价值。</p><p id="3d85" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是为什么通过执行以下操作来防止这些情况发生非常重要:</p><ul class=""><li id="4166" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">检查对象属性中的<code class="fe ot ou ov oj b">null</code>或<code class="fe ot ou ov oj b">undefined</code>值。如果你使用的是<a class="ae lh" href="https://www.typescriptlang.org/index.html" rel="noopener ugc nofollow" target="_blank"> Typescript </a>或<a class="ae lh" href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank"> Babel的可选链接</a>，使用<code class="fe ot ou ov oj b">?</code>语法会非常简单。</li><li id="1126" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">确保在使用<code class="fe ot ou ov oj b">switch-case</code>语句处理意外值时提供了<code class="fe ot ou ov oj b">default</code>案例。</li><li id="6189" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">对<code class="fe ot ou ov oj b">if — else if — else</code>条件指令进行上述操作。</li></ul><h2 id="2879" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">让条件语句清晰易读</h2><p id="c023" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">条件指令中有效的验证和清晰的逻辑将有助于代码的可读性。</p><p id="b5c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，确保有一个合理的和合乎逻辑的方式在条件。也许是验证太复杂，也许是不够安全…</p><p id="2045" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">建议创建一个专用方法，使条件更具可读性。另外，它可以在其他地方重复使用。</p><h2 id="e19a" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">分解组件</h2><p id="374e" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在几个组件或单个组件模板中找到相似的模板是很常见的。一个好的做法是将这些代码提取到一个专门的组件或者一个可重用的模板中。</p><p id="ff3d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Angular提供了<code class="fe ot ou ov oj b">ng-template</code>或<code class="fe ot ou ov oj b">ng-container</code>元素来创建可重用的模板。</p><p id="b263" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据定义，React倾向于创建新的专门化组件。如果您喜欢可重用的模板，您可以在文章“<a class="ae lh" href="https://medium.com/javascript-in-plain-english/how-to-build-reusable-layouts-in-react-js-daf8adcbca79" rel="noopener">如何在React JS </a>中构建可重用的布局”中找到方法</p><p id="c3df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Vue.js不提供这样的东西，但是你可以创建一个专用的组件，或者遵循Anthony Gore在他的文章"<a class="ae lh" href="https://vuejsdevelopers.com/2020/02/24/extending-vuejs-components-templates/" rel="noopener ugc nofollow" target="_blank">扩展Vue组件模板</a>中的建议。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="9eaf" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">JS框架原则得到尊重了吗？</h1><p id="7474" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">当处理创建动态的和用户友好的web应用程序时，JS框架是不可避免的。他们是前端开发领域的游戏改变者。每个框架都有自己的原则、规则和约定。因此，您需要检查这些标准是否得到遵守。</p><h2 id="e1e7" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">命名约定</h2><p id="ab48" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">应该遵守命名约定，以便能够识别文件的内容或变量的用途。</p><p id="f1da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是每个框架的非详尽检查列表:</p><p id="d477" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ot ou ov oj b"><strong class="lk jd">Angular</strong></code> <strong class="lk jd"> </strong> ( <a class="ae lh" href="https://angular.io/guide/styleguide" rel="noopener ugc nofollow" target="_blank">更多详情在此</a>)</p><ul class=""><li id="5223" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">文件名以<code class="fe ot ou ov oj b">component</code>、<code class="fe ot ou ov oj b">directive</code>、<code class="fe ot ou ov oj b">filter</code>、<code class="fe ot ou ov oj b">service</code>或<code class="fe ot ou ov oj b">module</code>为后缀</li><li id="2308" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">可观察变量以<code class="fe ot ou ov oj b">$</code>结尾</li><li id="d724" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">类构造函数中的私有参数以下划线为前缀</li></ul><p id="7915" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ot ou ov oj b"><strong class="lk jd">React</strong></code> <strong class="lk jd"> </strong>(更多详情<a class="ae lh" href="https://css-tricks.com/react-code-style-guide/" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae lh" href="https://xcidic.github.io/coding-guidelines/react/" rel="noopener ugc nofollow" target="_blank">此处</a>)</p><ul class=""><li id="b034" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">对React组件使用PascalCase，对组件实例使用camelCase</li><li id="a201" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">避免出于不同目的使用DOM组件属性名</li></ul><p id="b5ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ot ou ov oj b"><strong class="lk jd">Vue.js</strong></code> ( <a class="ae lh" href="https://vuejs.org/v2/style-guide/" rel="noopener ugc nofollow" target="_blank">更多详情在此</a>)</p><ul class=""><li id="983d" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">组件文件名和<code class="fe ot ou ov oj b">name</code>是“pascal大小写”(例如<code class="fe ot ou ov oj b">MyComponent.vue</code>)</li><li id="5ea3" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">Vue实例中的函数或变量以<code class="fe ot ou ov oj b">$</code>(如<code class="fe ot ou ov oj b">this.$route</code>或<code class="fe ot ou ov oj b">this.$emit</code>)开头，因此最好不要添加以该字符开头的自定义函数或变量。</li></ul><h2 id="e7a2" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">生命周期挂钩、数据流和访问器</h2><p id="b3b1" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">JS框架是根据几个控制组件状态和行为的生命周期挂钩构建的。需要恰当地使用它们来避免意外的无限循环或内存泄漏。</p><p id="922f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，在Angular中，您需要在使用<code class="fe ot ou ov oj b">Subscriptions</code>时检查<code class="fe ot ou ov oj b">OnDestroy</code>生命周期挂钩是否通过调用<code class="fe ot ou ov oj b">unsubscribe</code>方法取消了所有订阅。</p><p id="1e87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Vue.js中，<code class="fe ot ou ov oj b">beforeRouteEnter</code>守卫(或任何路线守卫)最终应该调用<code class="fe ot ou ov oj b">next</code>方法来导航。这也关系到棱角分明的防护装置。</p><p id="0c8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在React中，您应该检查一下<code class="fe ot ou ov oj b">componentWillMount</code>和<code class="fe ot ou ov oj b">componentWillUpdate</code>生命周期方法的用法，由于误解，它们现在已经被<a class="ae lh" href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" rel="noopener ugc nofollow" target="_blank">弃用了</a>。</p><p id="b93b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ot ou ov oj b">render</code>方法在类组件中是强制的。它不能修改组件状态。<a class="ae lh" href="https://reactjs.org/docs/react-component.html#render" rel="noopener ugc nofollow" target="_blank">更多详情可在此处找到</a>。</p><p id="3d65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">再次在Vue.js中，您应该检查<code class="fe ot ou ov oj b">computed</code>中的<code class="fe ot ou ov oj b">data</code>属性变化，这是一个主要的反模式实践。计算属性只是数据存取器，而不是更新值。这可以应用于角度<code class="fe ot ou ov oj b">getters</code>。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="4821" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">GitFlow原则</h1><p id="e2bb" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">如果您不熟悉这个术语，那么<em class="or"> GitFlow </em>意味着您已经设置的管理同一代码库的多个版本的策略。有一个参考分支和它的许多副本，有它们的特性。</p><p id="28b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">必须应用关于此策略的通用规则，并且必须遵循这些规则以避免代码丢失或冲突。在每一次代码审查中，必须尊重GitFlow。</p><h2 id="199d" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">每次提交都不应该破坏应用程序</h2><p id="23e1" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">这与其说是对代码审查的检查，不如说是建议。事实上，每一次提交都不能引入构建时间或运行时错误。</p><p id="3dd3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果出于某种原因，您需要回滚到某个特定的提交，而这个会触发故障诊断，那么它会将所有源代码弄得一团糟。</p><p id="e534" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是为什么这是一个更好的方式，以微小但可控和清晰的变化频繁提交。</p><h2 id="bac4" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">检查涉及的分支</h2><p id="4acd" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">合并请求涉及两个分支是不足为奇的:包含变更的分支和引用分支。</p><p id="c40a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">两个都检查一下是个好主意。事实上，由于我们对创建分支没有限制，因此很容易出现错误。这可能来自各种原因:</p><ul class=""><li id="5c10" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">错误的参考分支(例如，如果有子分支)</li><li id="b49b" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">拼写错误</li><li id="a6ac" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">要合并的重复分支(如果出于任何原因已经创建了要合并的分支的副本)</li></ul><p id="e3f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">避免引入不需要的代码片段的两个良好实践是:</p><ul class=""><li id="7abd" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">通过在票号前添加前缀来明确命名特性分支(如果您使用票务平台，如<a class="ae lh" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank"> GitLab </a>、<a class="ae lh" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae lh" href="https://www.atlassian.com/software/jira" rel="noopener ugc nofollow" target="_blank"> JIRA </a>或<a class="ae lh" href="https://azure.microsoft.com/en-us/services/devops/" rel="noopener ugc nofollow" target="_blank">Azure devo PS Services</a>)<br/>例如:<code class="fe ot ou ov oj b">287-add-tracking</code></li><li id="0e38" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">将您的引用分支合并到要先合并的分支中。这将有助于检测本地分支机构中的潜在错误和冲突。因此，引用分支受到保护，合并将受到控制。</li></ul><h2 id="35df" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">在本地测试分支</h2><p id="cdb8" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">这是一种积极的做法，但它应该是一种反射。通过检查来本地测试分支是一个很好的习惯。</p><p id="bbf8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用简单的命令<code class="fe ot ou ov oj b">git checkout my-feature-branch-to-test</code>并运行应用程序将允许您在构建应用程序时在本地检测错误。当然，这将是一种验证规范是否得到满足的简便方法。</p><p id="088d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，让我们诚实地说:这需要时间，在一个上市时间必须尽可能短的世界里，这种做法经常被放弃。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7f1b" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">可访问性(a11y)和国际化(i18n)</h1><p id="000d" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">广泛思考！一个web应用程序可能会被很大一部分人访问，包括来自世界各地的人。通过在代码中添加一些属性来包含有视觉障碍、运动障碍和其他障碍的人，将会改变您为他们提供的体验。</p><p id="d7c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可访问性(a11y)和国际化(i18n)已经成为前端开发的关键概念。如果你对这些特性没有印象，你可以参考我以前的文章“<a class="ae lh" href="https://medium.com/better-programming/the-front-end-features-you-might-have-missed-38f3ad1360a9" rel="noopener">你可能错过的前端特性</a>”用户体验部分。</p><h2 id="d425" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">辅助功能属性</h2><p id="e0a1" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">您应该确保存在a11y属性，例如:</p><ul class=""><li id="3970" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><code class="fe ot ou ov oj b">alt</code>对于图像，一个<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" rel="noopener ugc nofollow" target="_blank"> HTML属性</a>用于替代文本，例如用于非可视浏览器</li><li id="a998" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">ARIA属性，<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA" rel="noopener ugc nofollow" target="_blank">可访问的富互联网应用</a>属性，例如<code class="fe ot ou ov oj b">aria-label</code>、<code class="fe ot ou ov oj b">tab-index</code>、<code class="fe ot ou ov oj b">aria-hidden</code>和<code class="fe ot ou ov oj b">role</code>，这些属性描述了页面的内容</li><li id="4923" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><code class="fe ot ou ov oj b">for</code>与<code class="fe ot ou ov oj b">label</code> HTML标记一起使用(<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label#Accessibility_concerns" rel="noopener ugc nofollow" target="_blank">更多信息请点击</a></li></ul><h2 id="acfa" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">i18n键</h2><p id="93fb" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">一次提交涉及许多方面(包括HTML模板、CSS样式、测试和组件)，可能会忘记翻译—特别是当您管理几种语言时。</p><p id="95c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，不要忘记检查每种语言的每种翻译是否匹配。另外，模板中可能会使用翻译，但它并不对应于现有的键。</p><p id="76a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这似乎是一个无聊的任务，但魔鬼藏在细节中，不是吗？</p><h2 id="4ac7" class="nx nb it bd nc ny nz dn ng oa ob dp nk lr oc od nm lv oe of no lz og oh nq iz bi translated">利用您使用的i18n库</h2><p id="b5b7" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">你可以用你的i18n库做不可思议的事情。</p><p id="ce0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它们变得越来越多价，并提供强大的功能。您可以处理:</p><ul class=""><li id="f632" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">多元化</li><li id="9bb5" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">日期和数字格式</li><li id="4cbd" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">HTML模板化</li><li id="f72b" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">翻译延迟加载</li></ul><p id="75b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不要犹豫过度使用它，尤其是关于变位(<em class="or">是</em>，<em class="or">是</em>，<em class="or">是</em>，<em class="or">是</em>，<em class="or">是</em>，<em class="or">是</em>)，或者在句子的特定单词上添加CSS类。目标是使你的翻译尽可能地可重用。</p><p id="3971" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">利用i18n库将节省您的时间和精力。这是值得的，而不是另起炉灶！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="8994" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">最后</h1><p id="cab1" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">审阅合并请求可能会花费很多时间，但这是一个习惯的好习惯。它允许您了解其他开发人员对代码库进行的更改。此外，这是分享编程语言技巧、前端开发见解和经验的一种不同方式。</p><p id="bf6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，花在审查上的时间将是对未来的一个很好的赌注，因为你越早设定好的编码实践，花在审查上的时间就越早缩短。某种程度上，这是对未来的投资。</p></div></div>    
</body>
</html>