<html>
<head>
<title>Improving Performance in a Hierarchical SQL Table Structure With Column Propagation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过列传播提高分层SQL表结构的性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improving-performance-in-a-hierarchical-sql-table-structure-with-column-propagation-c57754f9c257?source=collection_archive---------12-----------------------#2022-06-02">https://betterprogramming.pub/improving-performance-in-a-hierarchical-sql-table-structure-with-column-propagation-c57754f9c257?source=collection_archive---------12-----------------------#2022-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9f1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">层次结构在数据库中很常见，如果处理不当，可能会导致性能问题和应用程序效率低下</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b8999cf900921a48c592a4626bd1f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fF4-iz8uah2nzC61.png"/></div></div></figure><p id="9d66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将展示在处理分层数据结构时，列传播如何成为提高查询性能的一种简单方法。</p><p id="e1e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将通过一个基于数据驱动项目的真实场景来实现这一点，该项目涉及一个为体育行业的初创公司开发的实时数据网站。您将了解到作为分层SQL表结构中固有的性能问题的解决方案的列传播的所有知识。我们开始吧。</p><h1 id="1f51" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">背景</h1><p id="85e4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我和我的团队最近为足球迷开发了一个有数百万页面的网站。该网站的理念是成为足球支持者的权威资源，尤其是在博彩方面。数据库和应用程序架构并不特别复杂。这是因为调度器负责定期重新计算复杂数据并将其存储在表中，这样查询就不必涉及到<a class="ae mn" href="https://arctype.com/blog/sql-aggregate-functions/" rel="noopener ugc nofollow" target="_blank"> SQL聚合</a>。所以，真正的挑战在于非功能性需求，比如性能和页面加载时间。</p><h1 id="b617" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">应用领域</h1><p id="b147" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">体育行业中有几家数据提供商，每一家都为其客户提供不同的数据集。具体来说，足球行业有四种类型的数据:</p><ol class=""><li id="b9d3" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">传记资料:身高，宽度，年龄，他们为之效力的球队，赢得的奖杯，获得的个人奖项，足球运动员和教练。</li><li id="7026" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">历史数据:过去比赛的结果以及那些比赛中发生的事件，如进球、助攻、黄牌、红牌、传球等。</li><li id="0b2c" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">当前和未来的数据:当前赛季的比赛结果和那些比赛中发生的事件，以及未来比赛的表。</li><li id="c1d8" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">实况数据:正在进行的游戏的实时结果和实况事件。</li></ol><p id="f48a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的网站涉及所有这些类型的数据，特别关注SEO原因的历史数据和支持投注的实时数据。</p><h1 id="ad7d" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">分层表结构</h1><p id="d9ce" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我不能与你分享整个数据结构，因为我签署了一个<a class="ae mn" href="https://en.wikipedia.org/wiki/Non-disclosure_agreement" rel="noopener ugc nofollow" target="_blank"> NDA </a>。与此同时，理解足球赛季的结构就足以理解这个现实世界的场景。</p><p id="89d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">详细地说，足球提供商通常如下组织一个赛季中的比赛数据:</p><ul class=""><li id="a9cf" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp nc mu mv mw bi translated">季节:有开始和结束日期，通常持续一个日历年</li><li id="9faf" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp nc mu mv mw bi translated">比赛:一场比赛所属的联赛。一个竞争的例子存在于一个赛季中。点击了解更多关于足球比赛的内容。</li><li id="33ca" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp nc mu mv mw bi translated">阶段:与比赛相关的阶段(如资格赛阶段、淘汰赛阶段、决赛阶段)。每个比赛都有自己的规则，许多比赛只有一个阶段。</li><li id="aa83" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp nc mu mv mw bi translated">组:与阶段相关联的组(例如，组A、组B、组C等等)。有些比赛，比如T2世界杯，涉及不同的小组，每个小组都有自己的团队。大多数比赛只有一个普通组。</li><li id="4191" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp nc mu mv mw bi translated">回合:从逻辑角度对应一天的比赛。它通常持续一周，并涵盖一个小组中所有球队的比赛(例如，MLS有17场主场比赛和17场客场比赛；因此，它有34匝)。</li><li id="5f50" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp nc mu mv mw bi translated">比赛:两个足球队之间的比赛。</li></ul><p id="65aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如下面的<a class="ae mn" href="https://arctype.com/blog/erd-builder/" rel="noopener ugc nofollow" target="_blank"> ER模式</a>所示，这五个表代表一个分层数据结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/1ff2a742ae5a0f0db114bfa9669c1f78.png" data-original-src="https://miro.medium.com/v2/0*pFilOUOAjJsAF8B3"/></div></figure><h1 id="4255" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">技术、规格和性能要求</h1><p id="0941" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们用<a class="ae mn" href="https://expressjs.com/en/changelog/4x.html#4.17.2" rel="noopener ugc nofollow" target="_blank"> Express 4.17.2 </a>和<a class="ae mn" href="https://sequelize.org/docs/v6/" rel="noopener ugc nofollow" target="_blank"> Sequelize 6.10 </a>开发了Node.js中的后端和TypeScript作为ORM ( <a class="ae mn" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">对象关系映射</a>)。前端是一个用TypeScript开发的<a class="ae mn" href="https://nextjs.org/blog/next-12" rel="noopener ugc nofollow" target="_blank"> Next.js 12 </a>应用。至于数据库，我们决定选择AWS托管的Postgres服务器。</p><p id="b0e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该网站运行在AWS Elastic Beanstalk上，前端有12个实例，后端有8个实例，目前每天有1到5千人观看。我们客户的目标是在一年内达到6万的日浏览量。因此，网站必须准备好在不降低性能的情况下托管数百万的月用户。</p><p id="a461" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该网站应该在性能，搜索引擎优化和可访问性在<a class="ae mn" href="https://developers.google.com/web/tools/lighthouse" rel="noopener ugc nofollow" target="_blank">谷歌灯塔</a>测试得分80+。另外，加载时间应该总是少于两秒，最好是几百毫秒。真正的挑战在于此，因为该网站包含超过200万个页面，预渲染这些页面需要数周时间。此外，大多数页面上显示的内容不是静态的。</p><p id="79ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们选择了<a class="ae mn" href="https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration" rel="noopener ugc nofollow" target="_blank">增量静态再生</a>方法。当访问者点击一个从来没有人访问过的页面时，Next.js用从后端公开的API中检索到的数据生成这个页面。然后，Next.js根据页面的重要性缓存页面30秒或60秒。</p><p id="ef64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，后端必须以极快的速度向服务器端生成过程提供所需的数据。</p><h1 id="6be0" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">为什么查询层次表很慢</h1><p id="3ddc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在让我们来看看为什么分层表结构会对性能构成挑战。</p><h2 id="ac10" class="ne lr it bd ls nf ng dn lw nh ni dp ma ld nj nk mc lh nl nm me ll nn no mg np bi translated">连接查询很慢</h2><p id="c02c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">分层数据结构中的一个常见场景是，您希望根据与层次结构中更高层的对象相关联的参数来过滤树叶。例如，您可能希望检索某个特定赛季的所有比赛。在这种情况下，由于叶表<code class="fe nq nr ns nt b">Game</code>没有直接连接到<code class="fe nq nr ns nt b">Season</code>，所以您必须执行一个查询，该查询涉及的连接数量与层次结构中的元素数量一样多。</p><p id="6c4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，您可能最终会编写以下查询:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="7ff9" class="ne lr it nt b gy ny nz l oa ob">SELECT GA.* FROM `Game` GA<br/>LEFT JOIN `Turn` T on GA.`turnId` = T.`id`<br/>LEFT JOIN `Group` G on T.`groupId` = G.`id`<br/>LEFT JOIN `Phase` P on G.`phaseId` = P.`id`<br/>LEFT JOIN `Competition` C on P.`competitionId` = C.`id`<br/>LEFT JOIN `Season` S on C.`seasonId` = S.`id`<br/>WHERE S.id = 5</span></pre><p id="f65c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样的查询很慢。每个连接执行一个<a class="ae mn" href="https://en.wikipedia.org/wiki/Cartesian_product" rel="noopener ugc nofollow" target="_blank">笛卡尔积</a>操作，这需要时间并可能产生数千条记录。因此，层次数据结构越长，性能就越差。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/321bcd213f6b69a5e0ff7dddde5f0c56.png" data-original-src="https://miro.medium.com/v2/0*4bFlkVdlnOv5wvpL"/></div></figure><p id="2b8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，如果您想检索所有数据，而不仅仅是<code class="fe nq nr ns nt b">Game</code>表中的列，由于笛卡尔积的性质，您将不得不处理数千行数百列的数据。这可能会变得混乱，但这正是ORM发挥作用的地方。</p><h1 id="99c6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">Orm数据解耦和转换需要时间</h1><p id="41fb" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">当通过ORM查询数据库时，您通常对检索应用程序级表示的数据感兴趣。原始的数据库级表示在应用程序级可能没有用。因此，当大多数高级orm执行查询时，它们从数据库中检索所需的数据，并将其转换成应用程序级别的表示。这个过程包括两个步骤:数据解耦和数据转换。</p><p id="46b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在后台，来自连接查询的原始数据首先被解耦，然后在应用程序级别被转换成各自的表示。因此，当处理所有数据时，具有数百列的数千条记录成为一个小型数据集，每条记录都具有在<a class="ae mn" href="https://sequelize.org/docs/v6/core-concepts/model-basics/" rel="noopener ugc nofollow" target="_blank">数据模型类</a>中定义的属性。</p><p id="e79f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，包含从数据库中提取的原始数据的数组将成为一组<code class="fe nq nr ns nt b">Game</code>对象。每个<code class="fe nq nr ns nt b">Game</code>对象将有一个包含其各自的<code class="fe nq nr ns nt b">Turn</code>实例的转弯字段。然后，<code class="fe nq nr ns nt b">Turn</code>对象将有一个组字段存储其各自的<code class="fe nq nr ns nt b">Group</code>对象，依此类推。</p><p id="6d7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成这种转换后的数据是您愿意接受的开销。处理杂乱的原始数据具有挑战性，并且会导致代码味道。另一方面，这个在幕后发生的过程需要时间，你不能忽视它。当原始记录有数千行时尤其如此，因为处理存储数千个元素的数组总是很棘手。</p><p id="120e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，层次表结构上的普通连接查询在数据库层和应用层都很慢。</p><h1 id="32a8" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">作为解决方案的列传播</h1><p id="1562" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">解决方案是在分层结构中将列从父列传播到子列，以避免这种性能问题。我们来了解一下原因。</p><h2 id="67d3" class="ne lr it bd ls nf ng dn lw nh ni dp ma ld nj nk mc lh nl nm me ll nn no mg np bi translated">为什么应该在分层数据库中传播列</h2><p id="b31c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">当分析上面的连接查询时，很明显问题在于对叶表<code class="fe nq nr ns nt b">Game</code>应用过滤器。你必须经历整个层级。但是既然Game是层次结构中最重要的元素，为什么不直接添加<code class="fe nq nr ns nt b">seasonId</code>、<code class="fe nq nr ns nt b">competitionId</code>、<code class="fe nq nr ns nt b">phaseId</code>和<code class="fe nq nr ns nt b">groupId</code>列呢？这就是列传播的意义所在！</p><p id="1a02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将外键列直接传播给子列，可以避免所有的连接。现在，您可以用下面的查询替换上面的查询:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="3aaf" class="ne lr it nt b gy ny nz l oa ob">SELECT * FROM `Game` GA<br/>WHERE GA.seasonId = 5</span></pre><p id="8979" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以想象，这个查询比原来的查询快得多。此外，它直接返回您感兴趣的内容。因此，您现在可以忽略ORM数据解耦和转换过程了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/6774d91550f01ceb14a5843165086d7e.png" data-original-src="https://miro.medium.com/v2/0*RsCO_dY8KmX8Wpfb"/></div></figure><p id="fce1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，列传播涉及到数据复制，应该谨慎使用。但是在深入研究如何优雅地实现它之前，让我们看看应该传播哪些列。</p><h1 id="7d53" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">如何选择要传播的列</h1><p id="5551" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">您应该向下传播层次结构中较高的实体的每一列，这可能对筛选有用。例如，这涉及到外部键。此外，您可能希望传播用于过滤数据的<a class="ae mn" href="https://www.postgresql.org/docs/current/datatype-enum.html" rel="noopener ugc nofollow" target="_blank">枚举列</a>,或者使用来自父代的聚合数据生成列，以避免连接。</p><h1 id="61fd" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">列传播的三大方法</h1><p id="f531" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">当我的团队选择列传播方法时，我们考虑了三种不同的实现方法。下面我们来一一分析。</p><h2 id="1840" class="ne lr it bd ls nf ng dn lw nh ni dp ma ld nj nk mc lh nl nm me ll nn no mg np bi translated">1.创建实体化视图</h2><p id="a410" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们在层次表结构中实现列传播的第一个想法是创建一个包含所需列的<a class="ae mn" href="https://www.postgresql.org/docs/current/sql-creatematerializedview.html" rel="noopener ugc nofollow" target="_blank">物化视图</a>。物化视图存储查询的结果，并且它通常表示复杂查询(例如上面给出的连接查询)的行和/或列的子集。</p><p id="8e04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于物化查询，您可以定义何时生成视图。然后，数据库会将它存储在磁盘上，并使它像普通表一样可用。尽管生成查询可能很慢，但您可以尽量少启动它。因此，物化视图代表了一种快速的解决方案。</p><p id="a170" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，在处理动态数据时，物化视图并不是最好的方法。这是因为实例化视图可能不是最新的。它存储的数据取决于您决定何时生成视图或刷新视图。此外，包含大量数据的物化视图会占用大量的磁盘空间，这可能会带来问题，并增加存储成本。</p><h2 id="1aa8" class="ne lr it bd ls nf ng dn lw nh ni dp ma ld nj nk mc lh nl nm me ll nn no mg np bi translated">2.定义虚拟视图</h2><p id="5071" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">另一个可能的解决方案是使用<a class="ae mn" href="https://www.postgresql.org/docs/9.2/sql-createview.html" rel="noopener ugc nofollow" target="_blank">虚拟视图</a>。同样，虚拟视图是存储查询结果的表。实体化视图的不同之处在于，这次您的数据库不将查询结果存储在磁盘上，而是将其保存在内存中。因此，虚拟视图总是最新的，用实时数据解决问题。</p><p id="45fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，数据库必须在每次访问视图时执行生成查询。因此，如果生成查询需要时间，那么涉及视图的整个过程必然会很慢。虚拟视图是一个强大的工具，但是考虑到我们的性能目标，我们不得不寻找另一个解决方案。</p><h2 id="a6da" class="ne lr it bd ls nf ng dn lw nh ni dp ma ld nj nk mc lh nl nm me ll nn no mg np bi translated">3.使用触发器</h2><p id="09b9" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><a class="ae mn" href="https://arctype.com/blog/learn-sql-triggers/" rel="noopener ugc nofollow" target="_blank"> SQL触发器</a>允许您在数据库中发生特定事件时自动启动查询。换句话说，触发器使您能够跨数据库同步数据。因此，通过在层次结构表中定义所需的列并让自定义触发器更新它们，您可以轻松地实现列传播。</p><p id="1b33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以想象，触发器会增加性能开销。这是因为每次它们等待的事件发生时，您的数据库都会执行它们。但是执行查询需要时间和内存。所以，触发是有代价的。另一方面，这种成本通常可以忽略不计，尤其是与虚拟或物化视图的缺点相比。</p><p id="7259" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">触发器的问题是定义它们可能需要一些时间。同时，您可以只处理这个任务一次，并在需要时更新它们。因此，触发器允许您轻松优雅地实现列传播。此外，由于我们采用了列传播并使用触发器来实现它，我们已经设法满足了客户定义的性能需求。</p><h1 id="337c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">最后的想法</h1><p id="816b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">层次结构在数据库中很常见，如果处理不当，可能会导致应用程序出现性能问题和效率低下。这是因为它们需要长连接查询和ORM数据处理，这既慢又耗时。幸运的是，您可以通过在层次中将列从父列传播到子列来避免这一切。</p><p id="1e0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这个真实的案例研究能够帮助您构建更好更快的应用程序！</p></div></div>    
</body>
</html>