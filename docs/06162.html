<html>
<head>
<title>Here’s A Simpler Alternative to Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这里有一个更简单的替代Redux的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-container-pattern-for-better-state-management-in-react-9351fe4381d1?source=collection_archive---------0-----------------------#2020-09-07">https://betterprogramming.pub/the-container-pattern-for-better-state-management-in-react-9351fe4381d1?source=collection_archive---------0-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ed8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用容器隐喻来提供一个最小的模块化微服务式的状态管理解决方案。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6276b9b8a66b5880100780d48874194d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wele7D1SYoJlDKoeNO4tsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><h1 id="b7bb" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="8f6a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">容器模式是在<a class="ae mm" href="https://www.npmjs.com/package/unstated-next" rel="noopener ugc nofollow" target="_blank">未声明的下一个</a>库中引入的概念。这种模式认为状态是持有全局应用程序状态的模块化部分的各种<code class="fe mn mo mp mq b">Containers</code>。为了提供这种状态，您在应用程序中创建一个上下文，然后通过钩子访问它。</p><p id="e64e" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">与Redux之类的东西相比，这个<code class="fe mn mo mp mq b">Container</code>模式提供了一种以钩子为中心的方式来管理状态。它更容易学习，可以很好地与您的应用程序进行伸缩，并提供了一种直观的方式来考虑全局状态。它是这样工作的。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="0190" class="ky kz it bd la lb nd ld le lf ne lh li jz nf ka lk kc ng kd lm kf nh kg lo lp bi translated">集装箱是什么样的？</h1><p id="5971" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">容器模式是一种方法，在这种方法中，不是将所有的全局状态放在一个外部库或全局存储中，比如Redux，而是将状态分成多个称为容器的块。这些块负责管理它们自己的状态，并且可以使用类似于下面的语法被拉入应用中的任何功能组件:</p><pre class="kj kk kl km gt ni mq nj nk aw nl bi"><span id="9d8c" class="nm kz it mq b gy nn no l np nq">const {user} = Auth.useContainer();</span></pre><p id="7ef2" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这种模式工作得非常好，因为它将状态分成自我管理的块，而不是将所有的东西都交织在一起。每个组件都可以简单地获取它想要使用的状态块，并且只依赖于应用程序状态的一部分。</p><p id="d24b" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">每个州块都很容易推理。它们只是一个连接到上下文提供者的定制钩子——仅此而已。术语“容器”实际上意味着“一个React定制钩子和一个上下文提供者”因此，当有人推荐使用Hooks和useContext进行状态管理时，他们在技术上是在推荐这种容器模式。</p><p id="52a9" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">要使用容器，你只需要导入上下文并使用钩子。从技术上讲，你不需要任何外部库，但是我使用了一个名为<a class="ae mm" href="https://www.npmjs.com/package/unstated-next" rel="noopener ugc nofollow" target="_blank">的库，因为它给了我一些好处，让这个模式变得更加简单。</a></p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="2122" class="ky kz it bd la lb nd ld le lf ne lh li jz nf ka lk kc ng kd lm kf nh kg lo lp bi translated">什么是未声明的-下一个？</h1><p id="c072" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">下一个是一个很小的库，帮助我们更容易地推理这些全局容器。这个库很小(只有200字节)，因为它基本上不做React的上下文API没有做的事情。</p><p id="411e" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这个库对于这个设计模式来说是100%可选的。它只是提供了一些小的API改进，使得上下文更容易使用。一些主要的好处包括:</p><ul class=""><li id="df7f" class="nr ns it ls b lt mr lw ms lz nt md nu mh nv ml nw nx ny nz bi translated"><strong class="ls iu">类型检查:</strong>这为您提供了现成的类型脚本支持。这是我对使用React Context API的不满之一，所以很高兴看到unstated-next解决了这个问题。</li><li id="ca30" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu">错误处理:</strong>如果您试图访问一个在React DOM树中没有上下文提供者的容器，它将抛出一个错误。这是调试的救命稻草。</li><li id="9ed9" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu">更容易思考:</strong>考虑上下文有时看起来很抽象，但是使用这个库和“容器”的概念要容易得多。</li></ul></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="45ea" class="ky kz it bd la lb nd ld le lf ne lh li jz nf ka lk kc ng kd lm kf nh kg lo lp bi translated">这个图案是什么样子的？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6d16e9120189f5d074745bdfd63dfdc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*cGMKSIcqkYFPQuW6YjE8tg.png"/></div></figure><h2 id="5110" class="nm kz it bd la og oh dn le oi oj dp li lz ok ol lk md om on lm mh oo op lo oq bi translated">文件结构</h2><p id="324b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当我使用这种模式时，我将所有的容器放在src目录根目录下的“container”文件夹中。我用单词“container”作为每个容器的后缀，并将所有相关代码放在一个文件中。</p><p id="c242" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这已经比Redux更有优势，在Redux中，一个单独的职责可能被分成三个或四个文件，分别负责动作、reducer、store、选择器等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/2fee3b53809d234903e9fee2248d284a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*7y24LwvXyRg8uSc3htqjBA.png"/></div></figure><h2 id="602a" class="nm kz it bd la og oh dn le oi oj dp li lz ok ol lk md om on lm mh oo op lo oq bi translated">容器文件</h2><p id="e76e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">容器是您的状态片段将存在的地方。这个文件包含了读写这部分状态所需的一切。下面是一个<code class="fe mn mo mp mq b">AuthContainer</code>的容器文件的样子:</p><pre class="kj kk kl km gt ni mq nj nk aw nl bi"><span id="0358" class="nm kz it mq b gy nn no l np nq">// The reducer. This would be very similar to your reducer in Redux.<br/>// This is optional, you can just use useState instead, but this is<br/>// here to show that if you want to use a reducer and do more<br/>// complicated state transitions you can.<br/>function authReducer(state: AuthState, action: Action) {<br/>   ...<br/>}</span><span id="8e36" class="nm kz it mq b gy os no l np nq">// Custom Hook<br/>function useAuth(initialState: AuthState) {<br/>   const [state, dispatch] = useReducer(authReducer, initialState);</span><span id="421c" class="nm kz it mq b gy os no l np nq">const loginWithGoogle = () =&gt; {<br/>      dispatch(loggingIn());<br/>      doGoogleLogin()<br/>         .then(user =&gt; dispatch(success(user)))<br/>         .catch(err =&gt; dispatch(error(err.message)));<br/>   }</span><span id="e205" class="nm kz it mq b gy os no l np nq">const loginWithEmailPassword = (email, password) =&gt; {<br/>      dispatch(loggingIn());<br/>      doEmailPasswordLogin(email, password)<br/>         .then(user =&gt; dispatch(success(user)))<br/>         .catch(err =&gt; dispatch(error(err.message)));<br/>   }</span><span id="fcb9" class="nm kz it mq b gy os no l np nq">const logout = () =&gt; dispatch(logout());</span><span id="7151" class="nm kz it mq b gy os no l np nq">return { <br/>      user: state.data,<br/>      isAuthenticating: state.loading,<br/>      error: state.error,<br/>      loginWithGoogle,<br/>      loginWithEmailPassword,<br/>      logout<br/>   };<br/>}</span><span id="d95c" class="nm kz it mq b gy os no l np nq">// Create the Container (this can be a Context too)<br/>// You just pass in the custom hook that you want to build the<br/>// container for.<br/>export const Auth = createContainer(useAuth);</span></pre><p id="d0c3" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">这真的很干净——它基本上只是一个定制的钩子，然后在底部有一条线，使它成为一个容器。当您在底部添加容器代码时，它会使这个定制钩子具有相同的状态，即使在多个不同的组件中使用。这是因为<code class="fe mn mo mp mq b">Unstated-Next</code>容器只是在幕后使用了<code class="fe mn mo mp mq b">Context</code> API。</p><p id="7613" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">为了完成这项工作，你首先需要在你的应用程序中添加一个<code class="fe mn mo mp mq b">Store</code>来存储所有的容器。这可能看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/9cc4297d8762cb940c98dd4c631b86a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bE4jPCLDi7BImyOaPFB-PA.png"/></div></div></figure><p id="2ea9" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated"><strong class="ls iu"> <em class="ou">注:</em> </strong> <em class="ou">我觉得还有更好的方式来管理这样一个</em> <code class="fe mn mo mp mq b"><em class="ou">Store</em></code> <em class="ou">。如果我们可以基于一组容器或者类似的东西动态地创建这种结构，我想那会干净得多。</em></p><p id="8a45" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">此外，如果有一种方法可以让所有这些加载到DOM的同一个级别，这样任何容器都可以访问任何其他容器，那也将是令人惊奇的。遗憾的是，我认为这是React的局限性。</p><p id="71ce" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">将它放在根组件中，这样根组件看起来就像这样:</p><pre class="kj kk kl km gt ni mq nj nk aw nl bi"><span id="ddd8" class="nm kz it mq b gy nn no l np nq">const App: React.FC = () =&gt; {<br/>   return (<br/>      &lt;Store&gt;<br/>         &lt;ReactRouter&gt;<br/>            &lt;AppRoutes&gt;<br/>         &lt;/ReactRouter&gt;<br/>      &lt;/Store&gt;<br/>   );<br/>}</span></pre><p id="b0ff" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">然后<em class="ou">瞧</em>！如果你做的正确，你现在应该能够进入你的任何React组件，并且像这样使用这个钩子:</p><pre class="kj kk kl km gt ni mq nj nk aw nl bi"><span id="d83c" class="nm kz it mq b gy nn no l np nq">const LoginPage: React.FC = () =&gt; {</span><span id="4882" class="nm kz it mq b gy os no l np nq">   ...</span><span id="947d" class="nm kz it mq b gy os no l np nq">   const {<br/>      formLogin, <br/>      googleLogin, <br/>      isAuthenticating,<br/>      user<br/>   } = Auth.useContainer();</span><span id="9979" class="nm kz it mq b gy os no l np nq">   useEffect(() =&gt; {<br/>      if (user) {<br/>         history.push('/home');<br/>      }<br/>   }, [user]);</span><span id="16e5" class="nm kz it mq b gy os no l np nq">   ...</span><span id="04ff" class="nm kz it mq b gy os no l np nq">   return (<br/>      &lt;div&gt;<br/>         &lt;button onClick={() =&gt; googleLogin()}&gt;<br/>            Login with Google<br/>         &lt;/button&gt;</span><span id="2468" class="nm kz it mq b gy os no l np nq">         ...</span><span id="377c" class="nm kz it mq b gy os no l np nq">      &lt;/div&gt;<br/>   );<br/>}</span></pre><p id="292e" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">如果你做的每件事都是正确的，遵循这个模式应该是可行的！如果您做错了什么，<code class="fe mn mo mp mq b">Unstated-Next</code>可能会抛出一个错误，指出容器的提供者尚未创建。但这很好，因为这是一个显式的错误消息，如果您使用基本的React上下文，将很难跟踪这个错误！</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="ce5c" class="ky kz it bd la lb nd ld le lf ne lh li jz nf ka lk kc ng kd lm kf nh kg lo lp bi translated">为什么不用Redux？</h1><p id="7a50" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Redux非常适合大规模的状态管理。这是管理大型应用程序状态的可靠方法。然而，对于绝大多数应用程序来说，Redux是一个错误的起点。这是非常的样板文件，可能不会给你带来很多好处，除非你已经知道你需要它。</p><p id="ace0" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">所以我提供这种模式作为替代。</p><p id="bd2d" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">您从这种模式中获得的主要好处是，从开发人员的角度来看，它更有意义。Redux获取您的状态并将其从视图层中分离出来。我认为管理状态的更好方法是将它与使用它的视图层放在一起。</p><p id="7ceb" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated"><em class="ou">这就是React钩子存在的原因。</em></p><p id="6503" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">您已经可以看到，随着状态的其他部分从Redux之类的东西转移到hooks中，事情正在朝着这种方法发展:</p><ul class=""><li id="b467" class="nr ns it ls b lt mr lw ms lz nt md nu mh nv ml nw nx ny nz bi translated"><strong class="ls iu">本地状态</strong> = &gt;使用状态/使用用户</li><li id="1b43" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu"> API状态</strong>=&gt;<a class="ae mm" href="https://github.com/tannerlinsley/react-query" rel="noopener ugc nofollow" target="_blank">React-Query</a>/<a class="ae mm" href="https://github.com/vercel/swr" rel="noopener ugc nofollow" target="_blank">useSWR</a>/<a class="ae mm" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">Apollo</a></li><li id="ea1a" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu">表单状态</strong> = &gt; <a class="ae mm" href="https://react-hook-form.com/" rel="noopener ugc nofollow" target="_blank">反应钩子表单</a></li></ul><p id="a5ea" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">因此，构建全球状态来很好地适应钩子生态系统是有意义的。</p><p id="1d5c" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated"><em class="ou">我的大部分状态管理都是由各种钩子库完成的，所以我的全局状态管理也应该是以钩子为中心的。</em></p><p id="9b8c" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">容器模式实现了这个想法。它以很少的时间成本提供了Redux的大部分功能，并且设计时考虑了以钩子为中心的开发。</p><p id="dbe2" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">对于任何中小型项目，这种模式对我来说都是显而易见的。对于一个更大的项目，这取决于用例。</p><p id="9ef9" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">以下是容器模式和Redux之间的一些比较:</p><h2 id="969b" class="nm kz it bd la og oh dn le oi oj dp li lz ok ol lk md om on lm mh oo op lo oq bi translated">容器模式有以下优点:</h2><ul class=""><li id="7bb6" class="nr ns it ls b lt lu lw lx lz ov md ow mh ox ml nw nx ny nz bi translated">比Redux之类的东西更简单。</li><li id="e133" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated">在幕后使用本机上下文API。</li><li id="6dd5" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated">知道<code class="fe mn mo mp mq b">useState</code>、<code class="fe mn mo mp mq b">useContext</code>和自定义钩子的话10分钟就能学会API。</li><li id="2eed" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated">只使用了一个很小的库，甚至这种依赖也是可选的。</li></ul><h2 id="78e1" class="nm kz it bd la og oh dn le oi oj dp li lz ok ol lk md om on lm mh oo op lo oq bi translated">它也有以下缺点:</h2><ul class=""><li id="56d3" class="nr ns it ls b lt lu lw lx lz ov md ow mh ox ml nw nx ny nz bi translated">不支持中间件。</li><li id="f232" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated">没有类似Redux chrome调试器的工具。</li><li id="77cb" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated">如果容器之间存在依赖关系，那么它们必须按照一定的顺序提供。</li></ul><p id="5ea7" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">考虑到这一点，如果您的用例不需要像Redux这样庞大的东西，那么您现在有了一个更好的想法。</p><p id="1329" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">如果你想采用这种模式，但又不能完全离开Redux，另一个选择是使用<a class="ae mm" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux工具包</a>和<a class="ae mm" href="https://medium.com/@matthew.holman/what-is-redux-ducks-46bcb1ad04b7" rel="noopener"> Redux鸭子模式</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/6c407e9a36a1dbaf0e9bb207166f9490.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*H1Gk3KbQQcp86tV0bA0WEQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Redux鸭子</p></figure><p id="cba5" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">如果您正在构建一个大型应用程序，这种Redux Ducks方法非常有效，因为它使用了一种以容器为中心的方法，但仍然让您处于Redux的生态系统中。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="2d32" class="ky kz it bd la lb nd ld le lf ne lh li jz nf ka lk kc ng kd lm kf nh kg lo lp bi translated">结论</h1><p id="26bb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这就是<code class="fe mn mo mp mq b">Container</code>模式。如果你想在应用程序中使用Redux，我会认真考虑这样做的成本，以确定你的应用程序是否真的需要它。不管怎样，我认为这种模式是一个很好的起点，因为它很小而且模块化，所以将来可以很容易地将其移植到Redux中。</p><p id="8418" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">总的来说，这个模式帮我清理了很多代码。它还帮助我在开发应用程序时将状态管理从我的痛点列表中移除。</p><p id="80df" class="pw-post-body-paragraph lq lr it ls b lt mr ju lv lw ms jx ly lz mt mb mc md mu mf mg mh mv mj mk ml im bi translated">让我知道你的想法——希望它能在你的项目中发挥作用。尽情享受吧！</p></div></div>    
</body>
</html>