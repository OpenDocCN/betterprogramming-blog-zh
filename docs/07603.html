<html>
<head>
<title>RxJS Lessons: Understanding Multicasting Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS课程:了解多播运营商</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjs-lessons-understanding-multicasting-operators-9bd5d3ac9a5e?source=collection_archive---------9-----------------------#2021-02-01">https://betterprogramming.pub/rxjs-lessons-understanding-multicasting-operators-9bd5d3ac9a5e?source=collection_archive---------9-----------------------#2021-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="407b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">多播并不像看起来那么难</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/76a2576d920b6d44190ee06fb9b89637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EoAXakb59SQq96Aw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乌古尔·阿克德米尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="9141" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="3aa0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">说到RxJS，多播可能是最令人生畏的特性之一。多播需要现有的RxJS知识库，这本身就是一些程序员难以掌握的一个方面。对此，我们补充说，有相当多的多播运营商，如果我们不了解它们是如何工作的，以及它们解决哪个特定的问题，知道选择哪一个可能是困难的。</p><p id="30c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是RxJS多播运营商的入门指南。在本指南结束时，您将(希望)更好地理解这些操作符，并知道何时以及为什么需要使用它们。我们将从研究热/冷可观测概念开始，然后我们将研究所有多播运营商，讨论它们的特殊性并查看示例，直到我们完全理解它们。</p><p id="07f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我已经为我们将在本指南中看到的每一个示例创建了一个StackBlitz项目，这样您就可以摆弄代码片段了，因为，以我的拙见，这将大大有助于理解操作符是如何工作的。您可以在每个示例下面的标题中找到相应StackBlitz项目的链接。</p><p id="2c83" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们开始之前，这里有一个我们今天要讨论的所有运营商的列表:</p><ul class=""><li id="14ba" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><a class="ae ky" href="https://rxjs.dev/api/operators/multicast" rel="noopener ugc nofollow" target="_blank">组播</a></li><li id="e7ce" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://rxjs.dev/api/operators/publish" rel="noopener ugc nofollow" target="_blank">发布</a></li><li id="8120" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://rxjs.dev/api/operators/publishReplay" rel="noopener ugc nofollow" target="_blank">发布回放</a></li><li id="0d43" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://rxjs.dev/api/operators/publishLast" rel="noopener ugc nofollow" target="_blank">发布最后一次</a></li><li id="a9cc" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://rxjs.dev/api/operators/publishBehavior" rel="noopener ugc nofollow" target="_blank">发布行为</a></li><li id="c4ae" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://rxjs.dev/api/operators/refCount" rel="noopener ugc nofollow" target="_blank">引用计数</a></li><li id="237e" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://rxjs.dev/api/operators/share" rel="noopener ugc nofollow" target="_blank">分享</a></li><li id="5ba9" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://rxjs.dev/api/operators/shareReplay" rel="noopener ugc nofollow" target="_blank">分享回放</a></li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c253" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">热和冷的可观测量</h1><p id="bc78" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">注意:如果你已经熟悉这些概念，可以跳过这一部分，继续下一部分。</p><p id="596c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">默认情况下，大多数可观察物体都是冷的。每次我们订阅一个冷的可观察对象，它的生产者就被重新创建。那么这到底意味着什么呢？首先，我们必须理解生产者是什么:简而言之，它是我们可观察价值的来源。它可以是DOM事件、回调、HTTP请求、迭代器等等。简而言之，任何可以产生价值并传递给观察者的东西。</p><p id="26ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们知道了生产者是什么，就更容易理解前面的陈述，它基本上是说我们的可观察的生产者随着每个订阅被一遍又一遍地创建。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/ee38dfeadbd39ca75950979719be9a31" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/ee 38 dfeadbd 39 ca 75950979719 be 9a 31</a>https://stackblitz.com/edit/cold-observable-example T2</p></figure><p id="871d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如您所见，因为我们的可观察对象是冷的，并且它的生产者随着每个订阅被重新创建，副作用被执行两次，每个订阅一次。如果可观察物是热的，不管我们订阅多少次，副作用都只会发生一次。</p><p id="6fa0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在看到前面的代码后，有些人可能会认为这种行为产生的后果并不特别重要，这就是为什么我总是喜欢用HTTP请求作为例子来解释这个概念及其相当重要的意义。</p><p id="5d52" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们有一个Ajax Observable为我们获取一些数据。因为Ajax Observable是冷的，所以每次我们订阅它时，都会产生一个新的HTTP请求。是的，您没有看错，每个订阅都有一个新的请求。20个订阅= 20个HTTP请求。让我们来看看一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">https://stackblitz.com/edit/cold-observable-ajax-example?<a class="ae ky" href="https://gist.github.com/NyaGarcia/5e2978f151a5f5fe548eaee915e44a1b" rel="noopener ugc nofollow" target="_blank">file=index.html </a></p></figure><p id="cd6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">看到这里，我相信正确处理热/冷可观测量的重要性变得非常明显。在我们的代码中，我们肯定不希望在每次订阅时都重新创建生产者。那么，我们如何解决这个严重的问题呢？通过让我们的寒冷变热。我们如何做到这一点？多播运营商！所以，事不宜迟，让我们从这些操作符开始吧。</p><p id="6a82" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ns">注:有一篇</em><a class="nv nw ep" href="https://medium.com/u/da6839d28258?source=post_page-----9bd5d3ac9a5e--------------------------------" rel="noopener" target="_blank"><em class="ns">Ben Lesh</em></a><em class="ns">的精彩文章，深入探讨了热/冷可观的话题。你可以在这里找到</em><a class="ae ky" href="https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339" rel="noopener"><em class="ns"/></a><em class="ns">。</em></p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="ae0c" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">多播()</h1><p id="c34d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nx ny nz oa b">multicast</code>通过使用主题共享可观察到的源。让我们来看一个使用<code class="fe nx ny nz oa b">multicast</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/433269daa077b4bc4d9a90907edb4298" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/433269 DAA 077 B4 BC 4d 9 a 90907 EDB 4298</a><a class="ae ky" href="https://stackblitz.com/edit/multicasting-multicast-no-connect?file=index.ts" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/multicast-multicast-no-connect？file=index.ts </a></p></figure><p id="f14b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你试过StackBlitz吗？注意到什么奇怪的事了吗？如果我们运行前面的代码，我们根本不会收到任何值！为什么我们的观测源没有发出任何东西？</p><p id="7261" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为组播会返回一种特殊的可观察值:T2。这种特殊类型的可观察对象有一个<code class="fe nx ny nz oa b">connect()</code>方法，当它被调用时，负责订阅带有我们提供的主题的源可观察对象。</p><p id="e842" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着如果我们不打电话给<code class="fe nx ny nz oa b">connect()</code>，这个来源将永远不会被订阅，也永远不会开始释放价值。所以，让我们改变我们之前的代码，添加一个对<code class="fe nx ny nz oa b">connect()</code>的调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/6431815f7e4a7fa2a7cfb2d31bebba2e" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/6431815 f 7 E4 a 7 fa 2 a 7 CFB 2d 31 bebba 2e</a><a class="ae ky" href="https://stackblitz.com/edit/multicasting-multicast?file=index.ts" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/multicasting-multicast?file=index.ts </a></p></figure><p id="ed50" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ns">瞧！我们的代码现在正常工作了。由于<code class="fe nx ny nz oa b">multicast</code>是共享源可观察的，副作用将只执行一次，即使我们订阅1000次。</em></p><h2 id="9a11" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">注销</h2><p id="d390" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与所有可观测量一样，取消订阅我们的多播可观测量以避免内存泄漏非常重要。我们需要记住，当处理返回<code class="fe nx ny nz oa b">ConnectableObservable</code>的多播操作符时，我们需要取消订阅多播订阅。</p><p id="d00d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看看前面的代码片段，从负责结束我们的可观察对象的源代码中删除<code class="fe nx ny nz oa b">take(2)</code>,然后取消订阅:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/e02550c2915680c8da7be0e5d5d8bd01" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/e 02550 c 2915680 c8 da 7 be 0 e 5d 5d 8 BD 01</a><a class="ae ky" href="https://stackblitz.com/edit/multicasting-multicast-unsubscribe?file=index.ts" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/multicast-multicast-unsubscribe？file=index.ts </a></p></figure><p id="5120" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">成功避免内存泄漏！</p><h2 id="a2a1" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">后期订阅者呢？</h2><p id="3802" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在一个完美的沙盒环境中，对多播可观察的所有订阅同时发生。然而，现实生活中发现这种行为的几率有多大？我可以向你保证它们不是很好。让我们看一个更现实的例子，我们有不同的订阅发生在不同的时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/c708e8f54c39113022c29faa9eac390b" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/c 708 E8 f 54 c 39113022 c 29 fa a9 EAC 390 b</a>T12】https://stackblitz.com/edit/multicasting-multicast</p></figure><p id="c41f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">似乎我们的后期观察者错过了在它订阅多播可观察之前发出的值。这可能会导致意想不到的行为和试图找出原因时的大麻烦。</p><p id="9759" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">那么，如何才能解决这个问题呢？这其实很简单，我们所要做的就是用一个<code class="fe nx ny nz oa b"><a class="ae ky" href="https://rxjs.dev/api/index/class/ReplaySubject" rel="noopener ugc nofollow" target="_blank">ReplaySuject</a></code>代替常规的<code class="fe nx ny nz oa b">Subject</code>。由于<code class="fe nx ny nz oa b">ReplaySubject</code> s向新订户重播旧值，我们的问题得到了有效解决:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/29a3ddd98f4a6ab39baace10524459eb" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/29 a3 DDD 98 F4 a6 ab 39 baace 10524459 EB</a><a class="ae ky" href="https://stackblitz.com/edit/multicasting-multicast-replaysubject" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/multicast-multicast-replay subject</a></p></figure><p id="a054" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的后期观察者现在可以访问以前发出的值。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="69ba" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">发布()</h1><p id="8fcc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们都同意<code class="fe nx ny nz oa b">multicast</code>是一个令人惊讶的操作者，但是每次我们想要多播我们的流时都必须键入<code class="fe nx ny nz oa b">multicast(() =&gt; new Subject())</code>会变得有点冗长。</p><p id="6a31" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nx ny nz oa b">publish</code>接线员来救援了！<code class="fe nx ny nz oa b">publish</code>基本上是用<code class="fe nx ny nz oa b">multicast</code>加一个引擎盖下的主语，这样我们就不用费劲去打了。很酷，对吧？让我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/a3a21bd3b0ea87044abf234ebd2eca11" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/a 3a 21 BD 3 b 0 ea 87044 abf 234 EBD 2 ECA 11</a>T16】https://stackblitz.com/edit/multicasting-publish</p></figure><p id="81a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">记住，如果我们想订阅我们的source Observable，我们仍然需要调用<code class="fe nx ny nz oa b">connect()</code>！</p><h2 id="619f" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">发布变体</h2><p id="f7cd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">还记得我们与后期订户和<code class="fe nx ny nz oa b">multicast</code>的问题吗？在这种情况下，我们如何处理他们？由于<code class="fe nx ny nz oa b">publish</code>相当于使用<code class="fe nx ny nz oa b">multicast(() =&gt; new Subject())</code>，我们不能只手动将<code class="fe nx ny nz oa b">Subject</code>换成一个<code class="fe nx ny nz oa b">ReplaySubject</code>。幸运的是，publish有几种变体，每种类型的主题都有一个。让我们来看看它们:</p><h2 id="41f6" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">发布重放()</h2><p id="e9d7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nx ny nz oa b">publishReplay</code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new ReplaySubject())</code>。由于我们已经看到了一个带有<code class="fe nx ny nz oa b">multicast</code> + ReplaySubject的例子，我们知道它允许后期订户在他们订阅之前接收排放:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/12f1afbf3efb4545a485814967625682" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/12 f1 afbf 3 efb 4545 a 485814967625682</a>T20】https://stackblitz.com/edit/multicasting-publishreplay</p></figure><h2 id="1222" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">publishLast()</h2><p id="43f4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nx ny nz oa b"><a class="ae ky" href="https://rxjs.dev/api/operators/publishLast" rel="noopener ugc nofollow" target="_blank">publishLast</a></code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new AsyncSubject())</code>。它将一直等到源可观测值发出最后一个值。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/c10e80c5a6d822d764009a89c08be382" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/c 10 e 80 C5 a6d 822d 764009 a 89 c 08 be 382</a>T24】https://stackblitz.com/edit/multicasting-publishlast</p></figure><h2 id="a200" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">发布行为()</h2><p id="e125" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nx ny nz oa b">publishBehavior</code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new BehaviorSubject())</code>。由于它使用了<code class="fe nx ny nz oa b"><a class="ae ky" href="https://rxjs.dev/api/index/class/BehaviorSubject" rel="noopener ugc nofollow" target="_blank">BehaviorSubject</a></code>，<code class="fe nx ny nz oa b">publishBehavior</code>允许我们指定一个初始值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/c281cca3f8b0f45d274fa7451e8d460f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/c 281 CCA 3 f 8 b 0 f 45d 274 fa 7451 E8 d 460 f</a><a class="ae ky" href="https://stackblitz.com/edit/multicasting-publishbehavior?file=index.ts" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/multicasting-publishbehavior?file=index.ts </a></p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="9e9f" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">refCount()</h1><p id="e39e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们现在知道有几个了不起的运营商分享我们的流。然而，不得不打电话给<code class="fe nx ny nz oa b">connect()</code>很快就变老了。它很罗嗦，如果我们忘记调用它，我们可能会浪费时间去弄清楚为什么我们的观测不发射。那么，没有更好的替代方案吗？</p><p id="7c7b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然有！请允许我介绍一下<code class="fe nx ny nz oa b">refCount</code>操作员。<code class="fe nx ny nz oa b">refCount</code>负责统计内部订阅源的数量，这为我们处理了两件至关重要的事情:</p><ul class=""><li id="9f08" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">如果订阅数大于0，也就是说至少有一个订阅者，<code class="fe nx ny nz oa b">refCount</code>订阅(仅一次)源，调用<code class="fe nx ny nz oa b">connect()</code>。</li><li id="aa1b" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">如果订阅的数量小于1，也就是说没有任何订阅者，<code class="fe nx ny nz oa b">refCount</code>取消订阅源。</li></ul><p id="3776" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们重构我们之前的代码来包含<code class="fe nx ny nz oa b">refCount</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">https://stackblitz.com/edit/multicasting-refcount</p></figure><p id="4032" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如您所见，<code class="fe nx ny nz oa b">refCount</code>负责调用<code class="fe nx ny nz oa b">connect()</code>并为我们取消订阅源Observable。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c32c" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">共享()</h1><p id="1f79" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后但同样重要的是，我们有<code class="fe nx ny nz oa b">share</code>操作符，它相当于使用<code class="fe nx ny nz oa b">multicast(() =&gt; new Subject())</code> + <code class="fe nx ny nz oa b">refCount</code>。它是最简单也是最常用的多播运营商，因为它可以处理所有的事情。这是我们之前的例子，使用了<code class="fe nx ny nz oa b">share</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/acbf46915766768a26969ca324c76254" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/acbf 46915766768 a 26969 ca 324 c 76254</a><a class="ae ky" href="https://stackblitz.com/edit/multicasting-share?file=index.ts" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/multicasting-share?file=index.ts </a></p></figure><p id="8370" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了好玩，让我们来看一个稍微真实一点的例子，它的特点是共享的Ajax可观察对象，而不是枯燥的旧间隔:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/2fa1f8f97337fd9d4419f1ea3f1ddb3f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/2fa 1 F8 f 97337 FD 9d 4419 f1 ea 3 f1 DDB 3 f</a><a class="ae ky" href="https://stackblitz.com/edit/multicasting-share-ajax?file=index.ts" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/multicasting-share-ajax?file=index.ts </a></p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="30fb" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">共享重播()</h1><p id="ccf5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">再次，我们必须记住我们的已故订户。在这种情况下，share只有一个变体，<code class="fe nx ny nz oa b">shareReplay</code>。可以想象，<code class="fe nx ny nz oa b">shareReplay</code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new ReplaySubject())</code> + <code class="fe nx ny nz oa b">refCount</code>。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/NyaGarcia/9e919977c2dd6120566fe13510be6dd1" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/9e 919977 C2 DD 6120566 Fe 13510 be 6 DD 1</a><a class="ae ky" href="https://stackblitz.com/edit/sharereplay-multicasting" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/sharereplay-multicasting</a></p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="9e8e" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">包扎</h1><ul class=""><li id="ebaf" class="ms mt it lt b lu lv lx ly ma on me oo mi op mm mx my mz na bi translated"><code class="fe nx ny nz oa b">publish</code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new Subject())</code>。</li><li id="8db0" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nx ny nz oa b">publishBehavior</code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new BehaviorSubject())</code>。</li><li id="4c2d" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nx ny nz oa b">publishLast</code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new AsyncSubject())</code>。</li><li id="9555" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nx ny nz oa b">publishReplay</code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new ReplaySubject())</code>。</li><li id="82be" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">有了<code class="fe nx ny nz oa b">refCount</code>，我们不再需要手动调用<code class="fe nx ny nz oa b">connect()</code>，也不再需要处理退订。</li><li id="0702" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nx ny nz oa b">share</code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new Subject()), refCount()</code>。</li><li id="6d94" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe nx ny nz oa b">shareReplay</code>相当于<code class="fe nx ny nz oa b">multicast(() =&gt; new ReplaySubject()), refCount()</code>。</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="9f0b" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">结论</h1><p id="3c02" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">那都是乡亲们！我希望这篇文章能帮助你更好地理解多播运营商，并意识到多播并不像最初看起来那么难。</p><p id="a3c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我前面提到的，我已经为本指南中的每一个例子创建了一个StackBlitz项目，所以请随意使用代码，我保证它真的有助于理解操作符是如何工作的。</p><p id="416f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你有任何问题，你可以在评论中提出来，我会尽力回答。</p></div></div>    
</body>
</html>