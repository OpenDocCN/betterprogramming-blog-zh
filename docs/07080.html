<html>
<head>
<title>The Beginner’s Guide to Redis and Caching With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis和Node.js缓存初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-beginners-guide-to-redis-and-caching-with-node-js-5a48eac0929e?source=collection_archive---------7-----------------------#2020-12-04">https://betterprogramming.pub/the-beginners-guide-to-redis-and-caching-with-node-js-5a48eac0929e?source=collection_archive---------7-----------------------#2020-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1433" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过Redis缓存加速您的节点应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9270600e2366e915039b6e8402a7bfbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FegDqm-hq-6r8Xq8p8ks-Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="88bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">近年来，<a class="ae lu" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>已经成为Node.js应用栈中的常事。尽管Redis最受欢迎的用例是缓存，但它还有许多其他用例，您可以在这些用例中利用其超快的内存数据库。</p><p id="ceac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我们将向您快速介绍Redis。我们还将使用Redis为一个节点应用程序创建一个简单的缓存，看看它如何影响其性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="753a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Redis是什么？</h1><p id="b946" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Redis是一个开源的(BSD许可的)、内存中的数据结构存储，用作数据库、缓存和消息代理。</p><p id="a878" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以把它想象成一个NoSQL数据库，在系统内存中以键值对的形式存储数据。如果需要，Redis也支持磁盘持久数据存储。</p><p id="21d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Redis支持存储<a class="ae lu" href="https://redis.io/topics/data-types" rel="noopener ugc nofollow" target="_blank">多种数据结构和数据类型</a>，包括字符串、列表、散列、集合和排序集合。受支持的数据结构为Redis提供了许多用例的通用性。</p><p id="7a14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Redis最适合需要在最短的时间内检索数据并交付给客户机的情况。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bee4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Redis用例</h1><h2 id="618d" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">Redis用于缓存</h2><p id="6c29" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Redis最流行的用例之一是缓存。</p><p id="6279" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">什么是缓存？</strong></p><p id="788f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nl">缓存</em>是在缓存中存储数据副本的过程，以允许应用程序更快地访问和检索数据。缓存的目标是比数据库或远程服务器更好地加速数据访问操作。对于昂贵的(及时的)操作尤其如此。</p><p id="b8c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为后端开发人员，我们的任务是尽快完成客户的请求。有时，查询需要几项操作，如从数据库中检索数据、执行计算、从其他服务中检索附加数据等。，这拖累了我们的表现。</p><p id="8938" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是缓存的优势所在，因为我们可以处理一次数据，将它存储在缓存中，然后直接从缓存中检索它，而无需执行所有那些昂贵的操作。然后，我们会定期更新缓存，以便用户可以看到更新的信息。</p><p id="4080" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">缓存&amp; Redis </strong></p><p id="1f08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为Redis是一个内存数据库，所以它的数据访问操作比任何其他磁盘数据库都要快。这使得Redis成为缓存的完美选择。它的键值数据存储是另一个优势，因为它使数据存储和检索更加简单。</p><p id="2d57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我们将了解如何使用Redis和Node进行缓存。</p><h2 id="2e65" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">Redis用于实时分析</h2><p id="aead" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Redis承诺进行亚毫秒级的数据处理操作。这使得Redis成为依赖实时数据分析的应用程序的完美候选。</p><p id="a9ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，在实现实时欺诈检测服务时，可以使用Redis来存储用户身份及其交易细节。Redis甚至提供了人工智能支持的更快的交易评分系统和更快的统计模型，以更好地执行这一用例。</p><p id="c111" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实时分析的其他用例包括实时库存管理系统和游戏排行榜。</p><h2 id="45b6" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">用于会话管理的Redis</h2><p id="61ce" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果您的应用程序使用会话来跟踪经过身份验证的用户和管理特定于用户的数据，Redis非常适合用作会话存储。使用Redis可以显著提高系统的性能，同时使处理用户数据变得更容易，包括凭证、最近的活动，甚至是类似购物车的系统。</p><h2 id="9ebe" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">Redis作为一个队列</h2><p id="edb2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">您可以使用Redis对需要很长时间才能完成的应用程序任务进行排队。您可以实现FIDO(先进先出)队列或创建延迟队列，以将任务实现延迟到预先安排的时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2128" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用节点和Redis缓存</h1><p id="2c84" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们从本教程的主要焦点开始:在节点应用程序中使用Redis进行缓存。</p><p id="c5fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Redis进行缓存的过程非常简单。当我们收到用户对启用了缓存的路由的请求时，我们首先检查所请求的数据是否已经存储在缓存中。如果是，我们可以快速从Redis检索数据并发送响应。</p><p id="7daf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果数据没有存储在缓存中，我们称之为<em class="nl">缓存未命中</em>，我们必须首先从数据库或外部API检索数据，并将其发送给客户端。我们还确保将检索到的数据存储在缓存中，以便下次收到相同的请求时，我们可以更快地将缓存的数据发送给用户。</p><p id="1425" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你对我们要做的事情有了一个清晰的想法，让我们开始实施吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bcfc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装Redis</h1><p id="94c6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果您还没有安装Redis，那么您需要安装本教程的Redis。</p><p id="0352" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以下载二进制文件，并使用以下命令轻松编译它们。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="35a7" class="mz md it nn b gy nr ns l nt nu">wget https://download.redis.io/releases/redis-6.0.9.tar.gz<br/>tar xzf redis-6.0.9.tar.gz<br/>cd redis-6.0.9<br/>make<br/>make install</span></pre><p id="0687" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了确保Redis服务器运行没有问题，使用<code class="fe nv nw nx nn b">redis-cli</code>向服务器发送一个ping。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="de9c" class="mz md it nn b gy nr ns l nt nu">redis-cli ping</span></pre><p id="ccba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您收到的响应是<code class="fe nv nw nx nn b">pong</code>，那么Redis服务器正在成功运行。</p><p id="6ca5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果出现问题，请阅读<a class="ae lu" href="https://redis.io/topics/quickstart" rel="noopener ugc nofollow" target="_blank">官方快速入门指南</a>以获得更好的想法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="439a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建节点应用程序</h1><h2 id="e63f" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">基本设置</h2><p id="1f81" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">像这样为节点应用程序设置初始样板文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a456" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意我们如何使用另外两个名为<code class="fe nv nw nx nn b">axios</code>和<code class="fe nv nw nx nn b">redis</code>的包。<code class="fe nv nw nx nn b">redis</code>是Node的标准Redis客户端。在本教程中，我们使用<code class="fe nv nw nx nn b">axios</code>从外部API检索数据。</p><p id="aabb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在继续之前，请确保使用npm安装这两个软件包。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="d8a8" class="mz md it nn b gy nr ns l nt nu">npm install axios redis --save</span></pre><h2 id="f301" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">从外部API检索数据</h2><p id="e619" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们将使用<a class="ae lu" href="https://jobs.github.com/api" rel="noopener ugc nofollow" target="_blank"> GitHub Jobs API </a>来获取与世界各地的编程工作相关的数据。</p><p id="83b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以将与您正在寻找的工作相关的搜索词传递给API，并检索一组JSON格式的可用工作。对API的示例请求如下所示。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="1aed" class="mz md it nn b gy nr ns l nt nu"><a class="ae lu" href="https://jobs.github.com/positions.json?search=node.js" rel="noopener ugc nofollow" target="_blank">https://jobs.github.com/positions.json?search=node.js</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/7cc7bda55636889edb418283b8b29ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ytIKyzsPntJZEMfX.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">POSTMAN-GitHub作业API结果</p></figure><p id="e228" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的节点应用程序中，我们定义了一个名为<code class="fe nv nw nx nn b">/jobs</code>的路由，它从上面的API中检索作业数据，并将它们发送回客户端。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4348" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们使用<code class="fe nv nw nx nn b">axios</code>向GitHub Jobs API发送一个GET请求，其中包含用户提供的搜索词。</p><p id="987f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们使用Postman来看看路线是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/7ee9b830240b770899e4e6bbc77c9df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VP5eWZpRmEWSzJIm.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">邮递员—我们的API结果</p></figure><h2 id="5c10" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">缓存结果</h2><p id="55e2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">现在让我们看看如何通过缓存来提高应用程序的性能。</p><p id="4a6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要通过应用程序连接到Redis服务器。我们使用安装的Redis包来完成这项任务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f0dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，Redis服务器监听端口6379。我们传递端口号来连接Redis并创建一个客户机。</p><p id="ef58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后实现从缓存中存储和检索数据的逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="2caf" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated"><strong class="ak">这是怎么回事？</strong></h2><p id="8f0f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">当我们接收到一个客户端对<code class="fe nv nw nx nn b">/jobs</code>路由的请求时，首先我们会收到带有请求查询参数的搜索词。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="821b" class="mz md it nn b gy nr ns l nt nu">const searchTerm = req.query.search;</span></pre><p id="422b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们尝试通过传递搜索词从缓存中检索请求的数据，在缓存中存储数据时，我们将搜索词用作关键字。由于Redis包没有对承诺的本地支持，我们必须传递一个回调来处理检索到的数据。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="f813" class="mz md it nn b gy nr ns l nt nu">client.get(searchTerm, async (err, jobs) =&gt; {<br/>    if (err) throw err;<br/>});</span></pre><p id="58d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果Redis返回的值不为null，这意味着相关数据存在于缓存中，因此很容易在响应中返回该数据。只要确保将字符串转换回JSON就行了。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="6661" class="mz md it nn b gy nr ns l nt nu">if (jobs) {<br/>    res.status(200).send({<br/>        jobs: JSON.parse(jobs),<br/>        message: "data retrieved from the cache"<br/>    });<br/>}</span></pre><p id="6a12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果返回值为null，我们必须向外部API发送请求来检索相关数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b7c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们从API获取数据时，在发送回之前，我们将数据存储在Redis中，以便下次将相同的请求发送到节点服务器时，它可以使用存储在缓存中的数据进行响应，而不是从API请求数据。</p><p id="c73a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意我们如何使用<code class="fe nv nw nx nn b">setex</code>函数在缓存中存储数据。具体使用<code class="fe nv nw nx nn b">setex</code>函数，而不是常规的<code class="fe nv nw nx nn b">set</code>函数，我们可以为存储的键-值对设置一个到期时间。因为我们为过期时间设置了一个值，所以当经过时间过期时，Redis将自动从缓存中删除这个键-值对。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a7dd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">完整源代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0981" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样。我们已经为我们的应用程序创建了一个简单的缓存。这并不难，是吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="33cb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关键时刻:时间对比</h1><p id="ec6f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们将了解缓存的使用如何影响我们应用的性能。我使用Postman向服务器发送请求，并测量请求完成时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/88fbd5118482a687bf5c9e02fcf711f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*237FIjuNamdRmyfO.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表演</p></figure><p id="c7e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一次使用新的搜索词向服务器发送请求时，应用程序需要更长的响应时间(超过7秒)，因为它必须从外部API获取数据。当您第二次发出相同的请求时，服务器的响应速度会更快，因为结果已经存在于缓存中。</p><p id="385f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请求在10毫秒内完成。与我们之前看到的没有缓存的应用程序相比，这是一个巨大的性能提升。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2575" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="480b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在本教程中，我们简要介绍了Redis，并用它为一个节点应用程序创建了一个简单的缓存。现在，您可以使用Redis来缓存应用程序中频繁查询的数据，从而获得可观的性能提升。</p><p id="3c0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以研究如何在其他用例中利用Redis的最佳特性。</p><p id="d384" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div></div>    
</body>
</html>