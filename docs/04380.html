<html>
<head>
<title>SwiftUI Introspect — Accessing UIKit Components Under SwiftUI Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI自省—在SwiftUI视图下访问UIKit组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-access-the-uikit-components-under-swiftui-objects-4a808568014a?source=collection_archive---------8-----------------------#2020-04-09">https://betterprogramming.pub/how-to-access-the-uikit-components-under-swiftui-objects-4a808568014a?source=collection_archive---------8-----------------------#2020-04-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0d32" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何通过访问UIScrollView等来禁用列表中的滚动</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/2d76058f9d67095df186eaaf43a8a0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rTt6B20T-0eNJRo9"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@edonugroho?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">江户努格罗霍</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure><p id="e9c1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI是2019年WWDC期间的热门话题。尽管工具集有限，但它创造了一种欣快感，因为您可以轻松地构建用户界面。令人高兴的是，许多SwiftUI组件都构建在UIKit之上。此外，SwiftUI和UIKit的互操作性允许我们利用<a class="ae kz" href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable" rel="noopener ugc nofollow" target="_blank">UIViewControllerRepresentable</a>和<a class="ae kz" href="https://developer.apple.com/documentation/swiftui/uiviewcontrollerrepresentable" rel="noopener ugc nofollow" target="_blank">UIViewControllerRepresentable</a>——两者都允许您将UIKit组件移植到SwiftUI中。</p><p id="75cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是我们已经知道了！那么这篇文章的目的是什么呢？</p><p id="54d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我们将研究一个令人惊叹的SwiftUI库(<a class="ae kz" href="https://github.com/siteline/SwiftUI-Introspect" rel="noopener ugc nofollow" target="_blank">自省</a>)，它让我们能够访问底层UIKit视图。</p><p id="88cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将讨论以下主题:</p><ul class=""><li id="726a" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">自省库是如何工作的？</li><li id="b80c" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">如何禁用SwiftUI列表的滚动？</li><li id="9fe5" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">如何在SwiftUI列表中添加Pull来刷新控件？</li><li id="b421" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">如何在SwiftUI中自定义分段样式选择器？</li><li id="dacf" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">如何更新NavigationView和TabView的颜色？</li><li id="eae9" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">如何让SwiftUI TextField成为第一响应者？</li></ul></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="925d" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">在后台</h1><p id="b0af" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">自省库的工作方式是向视图层次结构添加一个定制的覆盖图，然后查看UIKit层次结构以找到相关的视图。</p><p id="69b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果上面的几行没有多大意义，让我们看看下面的插图来了解自省库是如何工作的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/2718924ddd9beada43799845e94cb815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WgpmGDqY4mzELAAdoRkjlQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">引擎盖下:检查SwiftUI视图。</p></figure><p id="a319" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本质上，我们在SwiftUI视图上覆盖了一个不可见的<code class="fe np nq nr ns b">UIViewRepresentable</code>。视图将挖掘视图链，并最终找到托管SwiftUI视图的<code class="fe np nq nr ns b">UIHostingView</code>。一旦我们得到了这些，我们就可以在<code class="fe np nq nr ns b">UIHostingView</code>中访问UIKit视图。</p><p id="2a24" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">并非所有SwiftUI视图都可以检查。例如，SwiftUI的<code class="fe np nq nr ns b">Text</code>不是建立在<code class="fe np nq nr ns b">UILabel</code>之上的。同样，<code class="fe np nq nr ns b">Image</code>和<code class="fe np nq nr ns b">Button</code>也不是建立在<code class="fe np nq nr ns b">UIImageView</code>和<code class="fe np nq nr ns b">UIButton</code>之上。因此，我们不能访问它们的底层UIKit视图——因为它们不存在。下表展示了可以检查的SwiftUI视图:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/f1c908b96b96758ae891320a99a02cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pe6kDdOijCVwBW9DvwD6Vw.png"/></div></div></figure><p id="5421" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看一些场景，在这些场景中，检查底层UIKit视图允许我们在SwiftUI当前缺失的特性上进行构建。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="91b3" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">禁用SwiftUI列表滚动</h1><p id="0d25" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">SwiftUI列表目前没有定制滚动能力的<code class="fe np nq nr ns b">isScrollEnabled</code>属性，就像我们在<code class="fe np nq nr ns b">UITableView</code>中做的那样。通过使用<code class="fe np nq nr ns b">VStack + ForEach</code>，我们可以解决这个问题。但是仍然有一个缺点:我们通常在SwiftUI列表或<code class="fe np nq nr ns b">UITableView</code>行中看到的点击效果消失了。</p><p id="d9aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，通过使用<code class="fe np nq nr ns b">introspectTableView</code> viewModifier，我们可以在保留原生列表特性的同时轻松禁用滚动，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/d7535e280d1bb76df0edf261470df256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nEYb5TPZIUF86j4Au2N50g.gif"/></div></div></figure><p id="0136" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，为了隐藏SwiftUI列表元素之间的分隔线，一旦我们获得了底层UIKit视图，我们将简单地调用<code class="fe np nq nr ns b">tableView.separatorColor = .none</code>。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="d780" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">拉动以刷新SwiftUI列表</h1><p id="9e4a" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">SwiftUI List在编写时不提供对刷新的内置支持。在之前的一篇文章中，我们做了一个<a class="ae kz" href="https://medium.com/better-programming/pull-to-refresh-in-swiftui-6604f54a01d5" rel="noopener">变通实现</a>(尽管在使用大型列表时不是最好的)。很高兴，我们可以通过在SwiftUI列表的底层<code class="fe np nq nr ns b">UITableView</code>上设置<code class="fe np nq nr ns b">UIRefreshControl</code>来进一步减少样板代码，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/d2409759ddf1921f235bde3bdf3f6316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IeaVhj8WtL-cfTKjUfJo8Q.gif"/></div></div></figure><p id="8408" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意:我们不能在SwiftUI结构中定义<code class="fe np nq nr ns b">objc</code>函数。所以我们使用一个<a class="ae kz" href="https://github.com/takasek/ActionClosurable" rel="noopener ugc nofollow" target="_blank">库</a>将<code class="fe np nq nr ns b">UIRefreshControl</code>的选择器定义为一个闭包。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="d00e" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">在SwiftUI中自定义分段控件</h1><p id="b987" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">SwiftUI让我们将<code class="fe np nq nr ns b">SegmentedPickerStyle</code>设置为<code class="fe np nq nr ns b">Pickers</code>。但是目前有很多限制:定制边框、半径、标题和背景属性是不可能的。</p><p id="da9b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，通过利用底层视图，我们可以定制SwiftUI中分段控件的外观。在以下示例中，我们从分段控件中移除了圆角半径，并设置了其周围的边框颜色:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/49be0bd4394a8b031c83ea3c07079e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDNjFea6RE7ziWKSaQBjLw.png"/></div></div></figure></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="b385" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">自定义导航视图和选项卡视图样式</h1><p id="74ec" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">改变导航栏中标题文本的颜色并不简单。这同样适用于TabView。虽然有人可能建议使用<code class="fe np nq nr ns b">init</code>方法来改变外观——如下所示——但这并不是一个好的解决方案:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="bb1f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个实现并没有真正定制NavigationView或TabView。相反，它在全球范围内覆盖了它们的外观。</p><p id="9445" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们有一个更好的解决方法。例如，以下代码片段以简洁的方式更新了导航栏标题和背景色:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="b8d8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过检查<code class="fe np nq nr ns b">TabView</code>和<code class="fe np nq nr ns b">NavigationView</code>，我们能够修改它们各自的UIKit视图:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ny"><img src="../Images/b0cf3bb8224f27e299ba2462a9b2cb1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92gUdCEShjVsRR68C5mlUw.png"/></div></div></figure></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="e776" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">使TextField成为SwiftUI中的第一响应者</h1><p id="262a" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">SwiftUI目前不提供自动弹出键盘的方式。除非我们做些什么，否则用户必须手动关注它。我们可以再次访问底层的<code class="fe np nq nr ns b">UITextField</code>并调用<code class="fe np nq nr ns b">becomeFirstResponder</code>函数，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div></figure></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="8b06" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">结束语</h1><p id="c75d" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">我们看到了检查底层UIKit视图如何让我们克服一些SwiftUI组件的限制。我们从列表开始，定制它们的外观并利用scroll view API(swift ui中没有)。我们还讨论了如何定制分段控件、导航视图、标签视图和文本字段的属性。</p><p id="bed7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">展望未来，你可以在SwiftUI中定制<code class="fe np nq nr ns b">Steppers</code>、<code class="fe np nq nr ns b">Sliders</code>和<code class="fe np nq nr ns b">DatePickers</code>，直到苹果将其推出——可能是在2020年的WWDC。</p><p id="80b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个到此为止。感谢阅读。</p></div></div>    
</body>
</html>