<html>
<head>
<title>Understand IDORs To Secure Your Python Web Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解IDORs以保护您的Python Web应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-idors-to-secure-your-python-web-applications-250217b92d48?source=collection_archive---------12-----------------------#2021-05-24">https://betterprogramming.pub/understand-idors-to-secure-your-python-web-applications-250217b92d48?source=collection_archive---------12-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="84f8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以加密货币代码为例，深入探讨最流行的网络攻击技术之一</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7028edbcad7b44ccd5fd044617e963f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*irKvPmUxnO6yJLSe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">利亚姆·塔克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a3b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名安全人员和开发人员，有时我会被问到，我作为安全研究人员的经历是否对我编写web和移动应用程序有所帮助。事实是是的，写代码的时候确实帮了我很多。在我的开发工作流程中，我通常会测试到目前为止我构建的每一个特性，并且我非常自信地说，我编写的大部分都是安全的代码。然而，每个人都会犯错误，最近，我在我正在构建的API中遇到了一些错误，我将在稍后的时间讨论这些错误。</p><h2 id="40b4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">从开发人员的角度来看，IDORs是什么？</h2><p id="aec8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在直接跳到代码示例之前，让我简单地向您介绍一下IDORs。顾名思义，不安全的直接对象引用告诉我们，当web应用程序具有不安全的对象引用结构时，就会出现这种漏洞。简而言之，当用户试图直接访问/修改对象(例如，待办事项列表)时，应用程序不检查认证/授权。这意味着任何未被认证为该待办事项列表所有者的用户都可以访问/修改该待办事项列表，这导致了一个很大的安全问题。</p><h2 id="4013" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">简单的第一个场景</h2><p id="77e2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了更好地理解乍一看的东西，最有效的技术是将理论内容与实际材料相结合。那么，让我们看看一个简单的IDOR是什么样子的。</p><p id="947d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续使用待办事项应用程序，假设用户A创建了一个待办事项列表。创建该对象时，有三个API调用:</p><ul class=""><li id="8978" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">一个到端点<code class="fe nc nd ne nf b">api/v1/todolist/new</code>，返回一个JSON响应，看起来像这样<code class="fe nc nd ne nf b">{"created":true, "ownerUUID":"somelonguuid", "listID":123456, "listName":"Test To-Do-List"}</code></li><li id="0854" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">在第一次调用之后，应用程序使用以下JSON数据调用端点【T2:】</li><li id="c897" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">最后，为了呈现列表中的内容，我们看到一个对<code class="fe nc nd ne nf b">api/v1/todolist/123456</code>的调用，它用一些JSON(listcontent，listname，等等)来响应。)</li></ul><p id="d006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可能会想，通过最后两个API端点，有两种可能的IDOR场景。</p><p id="c640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b"><strong class="lb iu">GET api/v1/todolist/123456</strong></code></p><p id="c3fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们可以通过在用户B的浏览器上打开<code class="fe nc nd ne nf b"><a class="ae ky" href="https://example.com/api/v1/todolist/123456" rel="noopener ugc nofollow" target="_blank">https://example.com/api/v1/todolist/123456</a></code>进行测试，看看我们是否可以访问用户A的待办事项列表。这是一个例子，说明应用程序<strong class="lb iu">如何在没有检查认证的情况下不安全地将<code class="fe nc nd ne nf b">123456</code>待办事项列表引用给用户B(在这种情况下，问题是认证，但也可能是授权)。在现代WebApps中很难找到这样一个低悬的IDOR，但它仍然让您了解了IDOR是如何工作的。</strong></p><h2 id="cbee" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">第二个简单的场景</h2><p id="7d9c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><code class="fe nc nd ne nf b"><strong class="lb iu">PUT api/v1/todolist/edit/123456</strong></code></p><p id="0b02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与第一个场景类似。这里的IDOR可以通过向该端点发出PUT请求来编辑<code class="fe nc nd ne nf b">123456</code>待办事项列表，而不是列表的所有者。</p><p id="ae1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我最近在一个大型应用程序中遇到的一个问题是，该应用程序安全地引用了POST和GET请求，而不安全地引用了PUT请求。这让您大致了解了错过那些使您能够安全引用对象的代码行是多么容易。</p><h1 id="6429" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">代码示例</h1><p id="3944" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">既然您已经了解了IDORs是如何工作的，那么让我们深入研究一下我刚才谈到的代码示例。这些帮助我创建了一个有效的方法来在编写代码时处理所有这些IDORs。</p><p id="5968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将使用Django框架，但如果您不是在您的应用程序中使用它，请不要担心，查找和修复这些bug的过程是相同的。</p><h2 id="4b08" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">认证问题—案例1</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="bf6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">尝试在上面的代码中找出问题。</strong></p><p id="50b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经找到了。看一眼之后，你就能看出哪里出了问题。<code class="fe nc nd ne nf b">index_object</code>函数有两个参数:</p><ul class=""><li id="6e4a" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">response，这是让Django显示响应并从请求中获取数据的请求</li><li id="5181" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">id，该对象的id，稍后将用于获取我们的<code class="fe nc nd ne nf b">ObjectModel</code>中与那个<code class="fe nc nd ne nf b">id</code>匹配的对象。</li></ul><p id="9172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后函数<code class="fe nc nd ne nf b">gets()</code>调用请求的对象，并在响应中将它作为<code class="fe nc nd ne nf b">"object"</code>变量返回。</p><p id="7d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到被请求的对象是用户私有的，这意味着任何用户只要知道<code class="fe nc nd ne nf b">id</code>就可以请求另一个用户私有<code class="fe nc nd ne nf b">object</code>。</p><p id="55a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">为什么？</strong></p><p id="f4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为在请求<code class="fe nc nd ne nf b">object</code>时缺少认证。首先，根据模型(对象)数据库，您需要检查请求<code class="fe nc nd ne nf b">id</code>对象的用户实际上是否可以访问它。</p><p id="7cab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何解决这个问题？</p><p id="8969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加身份验证控制层:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个简单的例子中，一个<code class="fe nc nd ne nf b">if</code>语句将完成这项工作。在第3行，我检查了<code class="fe nc nd ne nf b">requested_object</code>是否包含在<code class="fe nc nd ne nf b">users</code>中。如果满足条件，app会在响应中包含<code class="fe nc nd ne nf b">requested_object</code>；如果不是，响应将包含一个到登录页面的重定向。</p><h2 id="4cf3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">认证问题—案例2</h2><p id="aa82" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我将向您展示一个稍微复杂一些的情况，其中API在URL中接收两个或更多参数。例:<code class="fe nc nd ne nf b">api/v1/portfolio/1/crypto/1</code>。现在，你可能已经猜到我们在谈论一个加密投资组合应用程序。</p><p id="8baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个请求中发生的事情是，用户正在请求带有<code class="fe nc nd ne nf b">id=1</code>的投资组合，而带有<code class="fe nc nd ne nf b">id=1</code>的加密存储了那个投资组合。</p><p id="002f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的安全<strong class="lb iu"> </strong> API处理函数将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c2c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这里我使用一个序列化器来处理Django Rest框架(DRF)</p><p id="03f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下代码，代码看起来相当安全:</p><ol class=""><li id="1c28" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu ny mz na nb bi translated">如果用户“拥有”它，就用<code class="fe nc nd ne nf b">id=1</code>获得投资组合</li><li id="4357" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu ny mz na nb bi translated">使用<code class="fe nc nd ne nf b">id1=1</code>获取属于该投资组合的加密</li></ol><p id="5d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这是可能的，因为<strong class="lb iu"> Crypto </strong> ( <code class="fe nc nd ne nf b">crypto_set</code>)模型(它是Django模型)“<strong class="lb iu">”属于<strong class="lb iu"> Portfolio </strong>模型(使用<code class="fe nc nd ne nf b">models.ForeignKey</code>)，这意味着您可以获得绑定到特定Portfolio的所有加密，而不需要另一个认证控制(<code class="fe nc nd ne nf b">portfolio.crypto_set.get()</code>)。</strong></p><p id="4a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在其他代码片段中看到的一个错误是，在这种情况下，没有将加密模型链接到投资组合模型<strong class="lb iu">和</strong>仅在访问投资组合时执行认证控制。</p><p id="c6af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样说似乎有些含糊，所以让我们深入代码看看到底发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在明白了吗？</p><p id="4133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数仅验证该用户是否拥有所请求的投资组合，但无法检查该用户是否也拥有所请求的加密，因为它与已经请求的投资组合无关。</p><p id="f424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">影响</strong></p><p id="372b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设以下情况:</p><ul class=""><li id="6994" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">受害者拥有投资组合<code class="fe nc nd ne nf b">1</code>和密码<code class="fe nc nd ne nf b">3</code></li><li id="1a61" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">攻击者拥有投资组合<code class="fe nc nd ne nf b">2</code>和密码<code class="fe nc nd ne nf b">2</code></li><li id="2907" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated"><code class="fe nc nd ne nf b">api/v1/portfolio/{id}/crypto/{id1}</code>的处理函数是上面代码片段中的函数，端点返回受害者拥有多少个特定硬币的密码(<code class="fe nc nd ne nf b">id1=2</code></li></ul><p id="2a0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">攻击者可以请求以下内容:<code class="fe nc nd ne nf b">api/v1/portfolio/2/crypto/3</code></p><p id="75e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数将验证攻击者拥有portfolio 2，然后呈现与crypto <code class="fe nc nd ne nf b">3</code>相关的信息:攻击者刚刚获得了受害者信息的访问权。</p><p id="576d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，查找和修复IDORs的过程与POST、PUT、DELETE和GET请求完全相同(至少对于Django是这样)。</p><h2 id="6b80" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">授权问题</h2><p id="4fd5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">IDORs还可以处理应用不当的授权控制。让我们从一个例子开始:受害者以查看者权限与攻击者共享一个文档，但攻击者可以利用某个漏洞(可以是各种bug)以任何方式编辑该文件。这是一个授权问题。</p><p id="eb00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如何将这些应用于IDOR呢？</p><p id="67d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们坚持使用加密组合的例子。投资组合的所有者可以与其他用户共享该投资组合，但只有查看者权限。</p><p id="071b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向投资组合添加加密的PUT请求如下所示:</p><pre class="kj kk kl km gt nz nf oa ob aw oc bi"><span id="50fd" class="lv lw it nf b gy od oe l of og">PUT api/v1/portfolios/</span><span id="22d4" class="lv lw it nf b gy oh oe l of og">{"portfolioID":"12345", "crypto":"MANA"}</span></pre><p id="afd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我想让你快速看一下处理函数是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="960a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个五行代码片段中，我们正在执行我们通常的身份验证控制，如果请求方法被放置，我们就用<code class="fe nc nd ne nf b">id=id</code>将crypto添加到组合中。</p><p id="87de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个文件夹与攻击者共享了查看权限，这意味着攻击者不能将密码添加到该文件夹中，会怎么样？如果<code class="fe nc nd ne nf b">api/v1/portfolios</code>端点使用了上面的函数，攻击者可以在不是编辑者的情况下向该文件夹添加加密。这是因为缺少授权控制。该函数不检查请求PUT请求的用户是否具有编辑权限；它只检查该用户是否有权访问所请求的投资组合。</p><p id="2314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="5e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第5行，我们检查用户是否有编辑权限。如果是，创建添加加密；如果不是，则返回一个授权错误。</p><h1 id="0f29" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">结论</h1><p id="cc46" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我写这篇文章是为了帮助开发者理解他们也应该注意开发一个安全的应用程序。而且开发一个功能性应用和一个<strong class="lb iu">安全</strong>功能性应用是完全不同的两件事。此外，清楚地了解最流行的网络攻击技术是如何工作的，并知道如何预防这些技术，在找工作时会非常有价值，这对你的投资组合也很有帮助。</p></div></div>    
</body>
</html>