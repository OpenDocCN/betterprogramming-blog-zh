<html>
<head>
<title>Pointers, Strings, and (im)mutability in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的指针、字符串和(不)可变性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pointers-strings-and-im-mutability-680b15dd4a70?source=collection_archive---------1-----------------------#2022-05-29">https://betterprogramming.pub/pointers-strings-and-im-mutability-680b15dd4a70?source=collection_archive---------1-----------------------#2022-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b4e0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python中不可思议的功能的故事</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/11b696120ac6ca7588d003087a84c16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KgD8JMZ9PCRafMF6"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://unsplash.com/photos/vpOeXr5wmR4" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="bdb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近有一次有趣的经历，结果证明这是对Python中对象可变性的一次很好的教育，尤其是字符串。这种经历是由于搞砸了两个Python脑筋急转弯，对语言功能中看似矛盾的地方感到恼火，然后掉进了一个迷人的兔子洞。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="3d4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个<a class="ae kv" href="https://twitter.com/driscollis/status/1529014651186454528/" rel="noopener ugc nofollow" target="_blank">脑筋急转弯</a>，由<a class="ae kv" href="https://twitter.com/driscollis" rel="noopener ugc nofollow" target="_blank"> Mike Driscoll </a>在Twitter上提供:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="b94e" class="me mf iq ma b gy mg mh l mi mj">i = j = [3]</span><span id="cda0" class="me mf iq ma b gy mk mh l mi mj">i += j</span><span id="7f97" class="me mf iq ma b gy mk mh l mi mj">print(i, j)</span></pre><blockquote class="ml mm mn"><p id="99d4" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">程序会输出什么？</p></blockquote><p id="34a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来很简单。变量和<code class="fe ms mt mu ma b">i</code>和<code class="fe ms mt mu ma b">j</code>都被赋值指向一个包含数字<code class="fe ms mt mu ma b">3</code>的列表。接下来，通过将变量<code class="fe ms mt mu ma b">j</code>添加到变量<code class="fe ms mt mu ma b">i</code>中，对变量<code class="fe ms mt mu ma b">i</code>进行适当的修改。</p><p id="3989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于列表，Python中的加法运算符将第二个列表的新内容追加到第一个列表的内容上，所以现在是<code class="fe ms mt mu ma b">i == [3, 3]</code>，而<code class="fe ms mt mu ma b">j</code>因为没有被修改所以还是<code class="fe ms mt mu ma b">[3]</code>，所以打印<code class="fe ms mt mu ma b">i</code>、<code class="fe ms mt mu ma b">j</code>应该打印<code class="fe ms mt mu ma b">i</code> ( <code class="fe ms mt mu ma b">[3, 3]</code>)和<code class="fe ms mt mu ma b">j</code> ( <code class="fe ms mt mu ma b">[3]</code>)。因此，最终答案应该是<code class="fe ms mt mu ma b">[3, 3], [3]</code>。</p><p id="a6d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">熟悉Python如何实现变量作为指针的人会认识到我的错误。<code class="fe ms mt mu ma b">i</code>和<code class="fe ms mt mu ma b">j</code>都指向内存中的同一个对象，所以即使<code class="fe ms mt mu ma b">i</code>是唯一被显式修改的对象，当内存中的对象改变时，<code class="fe ms mt mu ma b">j</code>的值也会改变。因此，正确答案是<code class="fe ms mt mu ma b">[3, 3], [3, 3]</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="36bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，吸取教训。因此，当另一个看起来非常相似的<a class="ae kv" href="https://twitter.com/driscollis/status/1530112710146416641" rel="noopener ugc nofollow" target="_blank">脑筋急转弯</a>出现在我的新闻供稿中时(再次感谢迈克·德里斯科尔)，我想我会做对的。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="0643" class="me mf iq ma b gy mg mh l mi mj">x = y = “Python”</span><span id="2bda" class="me mf iq ma b gy mk mh l mi mj">x += “rocks!”</span><span id="46e2" class="me mf iq ma b gy mk mh l mi mj">print(x, y)</span></pre><blockquote class="ml mm mn"><p id="620e" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">程序会输出什么？'''</p></blockquote><p id="c15c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来和前面的问题几乎一样，对吗？Python将字符串实现为类似列表的对象，因此添加两个字符串只是将第二个字符串附加到第一个字符串的末尾。于是，<code class="fe ms mt mu ma b">x</code>应该变成了<code class="fe ms mt mu ma b">“Pythonrocks!”</code>。而且，正如我从之前的脑筋急转弯中了解到的，既然<code class="fe ms mt mu ma b">x</code>和<code class="fe ms mt mu ma b">y</code>在内存中指向同一个对象，<code class="fe ms mt mu ma b">y</code>也应该变异成<code class="fe ms mt mu ma b">“Pythonrocks!”</code>对吧？</p><p id="0ee2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不对！任何Python爱好者都会告诉你Python字符串是“不可变的”，这意味着它们不能被直接修改。相反，当您试图修改一个字符串时，Python会根据您想要应用于原始对象的变化，在内存中创建一个新对象。因此，当<code class="fe ms mt mu ma b">x</code>变成<code class="fe ms mt mu ma b">“Pythonrocks!”</code>时，<code class="fe ms mt mu ma b">y</code>仍然是<code class="fe ms mt mu ma b">“Python”</code>，所以并排打印它们会得到<code class="fe ms mt mu ma b">“Pythonrocks!”, “Python”</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="2cee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧。烦人，但够直白。然而，在我对Python中字符串可变性的研究中，我发现了另一个例子(为了可读性做了修改，这次来自<a class="ae kv" href="https://twitter.com/austinzhenley" rel="noopener ugc nofollow" target="_blank"> Austin Henley </a>),它似乎与我刚刚学到的相矛盾:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="97a5" class="me mf iq ma b gy mg mh l mi mj">a = “Hello”</span><span id="57bb" class="me mf iq ma b gy mk mh l mi mj">id(a)</span><span id="7e40" class="me mf iq ma b gy mk mh l mi mj">140214243255728</span><span id="fe16" class="me mf iq ma b gy mk mh l mi mj">a += “!”</span><span id="1b51" class="me mf iq ma b gy mk mh l mi mj">id(a)</span></pre><p id="6f99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，由于我们刚刚试图改变一个不可变的字符串，内存中应该有一个新的对象在内存中的新位置编码<code class="fe ms mt mu ma b">“Hello!”</code>。因此，调用变量<code class="fe ms mt mu ma b">a</code>的<code class="fe ms mt mu ma b">id</code>应该打印一个与我们之前看到的不同的内存地址，对吗？</p><p id="41d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">又错了！这个真的让我大吃一惊。我已经在努力处理字符串的不变性了，所以现在知道它们显然是可变的让我对计算的确定性失去了信心。这个例子和前一个例子怎么可能都是真的呢？字符串怎么可能前一分钟是不可变的，后一分钟又是可变的呢？</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="fbee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常关注细节或者特别精通Python的读者可能会注意到第二个例子和第三个例子之间的区别。在第二个例子中，两个变量指向内存中的同一个对象，而在第三个例子中，只有一个变量指向该对象。为什么重要？有什么区别？因为，正如奥斯汀·亨利解释的那样，“CPython很聪明。如果没有其他对字符串的引用，那么它将尝试改变字符串，而不是分配一个新的”(强调我的)。在脑筋急转弯二的情况下，<code class="fe ms mt mu ma b">x</code>和<code class="fe ms mt mu ma b">y</code>都指向内存中的同一个对象，因此，不变性得以保留。</p><p id="e9cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确实聪明。或者只是极度沮丧。因为，正如亨利继续指出的那样，即使这种解释也有点过于简单化。如果原始字符串上的突变变得太大，CPython有时会调整缓冲区的大小，在内存中创建一个新的对象，从而保留“不变性”的映像。当他运行基准测试时，他发现调整缓冲区大小会导致内存中的地址在10，000次中改变46次。</p><p id="4545" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的朋友争辩说，即使我们忽略缓冲区大小调整的情况，这难道不是危险的行为吗？对于程序员来说，跟踪两个变量是否都指向同一个对象似乎是不必要的精神负担。</p><p id="42a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过进一步思考，我们意识到，尽管奇怪，这种行为实际上并不危险。毕竟，程序员可以避免假设一个变异的对象会在内存中保留它的地址。如果两个或两个以上的变量指向同一个对象，那么这种变异肯定会为被修改的变量所指向的对象产生一个新的地址。如果未知数量的变量指向同一个对象，您可以假设它将在内存中获得一个新地址，但是如果这个“新地址”恰好与旧地址相同，那就不是问题。</p><p id="6a0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，这是一种令人头疼的困难方式，难以将Python中的指针处理和可变性深入灌输到我的头脑中。希望它能坚持下去。</p></div></div>    
</body>
</html>