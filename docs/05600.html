<html>
<head>
<title>Centralized Logging: Parse Key-Value Logs With FluentD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集中式日志记录:用FluentD解析键值日志</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/centralized-logging-parse-key-value-logs-with-fluentd-9b86140fc5e?source=collection_archive---------12-----------------------#2020-07-21">https://betterprogramming.pub/centralized-logging-parse-key-value-logs-with-fluentd-9b86140fc5e?source=collection_archive---------12-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dee5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用FluentD解析器从日志行中提取键值对</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/034e5ba59e6fe1de766f4ddb5ad34fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*asZyyOXVJKEhQjUn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@davidkovalenkoo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·科瓦连科</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="017a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">“Fluentd是一个跨平台的开源数据收集软件项目，最初在Treasure Data开发。它主要是用Ruby编程语言编写的。”</em></p><p id="076d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Fluentd" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> —维基百科</em> </a></p><p id="e36c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我以前的博客文章中，我解释了如何使用FluentD解析日志并将其发送到一个集中式日志服务器(EFK堆栈)，解析Rails应用程序的多行日志，并概述了一些最常用的使用FluentD解析日志的插件。您可以使用下面的链接查看提到的博客帖子:</p><div class="lw lx gp gr ly lz"><a href="https://levelup.gitconnected.com/centralize-your-docker-logging-with-fluentd-a2b7e0a379ce" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">使用FluentD集中您的Docker日志记录</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">使用FluentD开始将容器日志传送到集中的日志服务器</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a href="https://medium.com/@wshihadeh/7-tips-for-using-fluentd-for-logs-collection-c9613f7a387c" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">使用Fluentd收集日志的七个技巧</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">通过应用一些最佳实践来改进您的FluentD配置和脚本</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn ks lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a href="https://medium.com/faun/parse-ruby-on-rails-logs-with-fluentd-9fca4df6ebfe" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">用FluentD解析Ruby on Rails日志</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">让我们通过使用FluentD解析rails多行日志来减少日志量。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="mp l mk ml mm mi mn ks lz"/></div></div></a></div><p id="dda6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将关注另一个可以用Fluentd解决的问题。这将提高日志的质量，并为基于解析的日志构建可视化提供更好的机会。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="a194" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><strong class="ak">问题</strong></h1><p id="80c6" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">软件应用程序以几种不同的日志格式生成日志，比如纯文本日志、JSON日志、键值以及混合格式，比如纯文本和键值行，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ada1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，FlunetD会将上面的日志行视为一个长文本，您将无法根据响应的<code class="fe nw nx ny nz b">method</code>或<code class="fe nw nx ny nz b">format</code>来过滤Kibana中的日志。可以使用<a class="ae ky" href="https://docs.fluentd.org/parser/regexp" rel="noopener ugc nofollow" target="_blank">正则表达式解析器</a>或<a class="ae ky" href="https://github.com/fluent-plugins-nursery/fluent-plugin-kv-parser" rel="noopener ugc nofollow" target="_blank">键值解析器</a>从日志行中提取键并将它们添加到事件键中。但是，这些解决方案有一些限制，并且只有在您确切知道日志行中将出现的键或者日志行只包含键-值对(没有纯文本)时才有效。</p><p id="6dcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，日志行的键是动态的，取决于请求或事件。因此，我不能使用正则表达式解析器，也不能使用键值解析器，因为日志行包含事件时间的纯文本前缀😢。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="4206" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><strong class="ak">解决方案</strong></h1><p id="b73e" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">因为我找不到现有的库或解析器来帮助我解析键值日志，所以我决定构建自己的FluentD解析器来解析日志并提取日志消息中定义的所有键值对。</p><p id="cb53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所需的FluentD解析器的要求简述如下:</p><ul class=""><li id="acbe" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">源密钥应该是可配置的。解析器应该允许我不仅从消息键中提取键，而且为FluentD事件中定义的任何键提取键。</li><li id="84ae" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">启用/禁用在提取密钥后删除源密钥。</li><li id="26eb" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">启用/禁用忽略找不到关键字的日志行。</li><li id="ef16" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">忽略并且不扫描键值对之前的纯文本。</li><li id="492e" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">支持两种提取键值对的策略。第一个基于预定义的分隔符，第二个基于定义的正则表达式。</li><li id="2f3c" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">支持忽略一些提取的密钥。(我们希望从日志记录系统中隐藏的密钥)</li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="8faa" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><strong class="ak">实施</strong></h1><p id="9582" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">经过一些调查，我发现实现这个解决方案的最好方法是用下面的配置项构建一个<a class="ae ky" href="https://docs.shihadeh.dev/ruby-gems/Key-ValueParser/" rel="noopener ugc nofollow" target="_blank"> FluentD过滤器插件</a>来支持所需的功能。</p><ul class=""><li id="f147" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated"><code class="fe nw nx ny nz b">key</code>:包含待解析消息的源键。默认值是<code class="fe nw nx ny nz b">log</code>。</li><li id="3a7d" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nw nx ny nz b">remove_key</code>:提取键值对后删除源键的布尔指示器。默认值为<code class="fe nw nx ny nz b">false</code>。</li><li id="c5ab" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nw nx ny nz b">filter_out_lines_without_kesy</code>:一个布尔值，用于在日志行不包含任何已定义的键值对的情况下删除日志行。默认值为<code class="fe nw nx ny nz b">false</code>。</li><li id="6bff" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nw nx ny nz b">use_regex</code>:启用/禁用提取键值对的正则表达式。默认值为<code class="fe nw nx ny nz b">false</code>。</li><li id="c04d" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nw nx ny nz b">remove_prefix</code>:用于删除日志消息前缀的正则表达式。默认情况下，此配置项的值为空。</li><li id="75aa" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nw nx ny nz b">keys_delimiter</code>:用于分隔按键的字符。默认值是空格。</li><li id="9a3c" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nw nx ny nz b">kv_delimter_char</code>:用于将键与其值分开的字符。默认值为<code class="fe nw nx ny nz b">=</code>。</li><li id="139b" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nw nx ny nz b">filtered_keys</code>:将包含在FluentD事件中的白名单键。</li><li id="8c75" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nw nx ny nz b">filtered_keys_regex</code>:定义白名单键的正则表达式。</li></ul><p id="3180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将FluentD插件与FluentD配置集成起来非常简单，不需要太多努力。以下步骤总结了成功集成FluentD过滤器和粘贴脚本所需的操作。</p><ul class=""><li id="2c09" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">安装gem并使其可用于您的FluentD脚本。如果您在docker容器中使用FluentD，请确保宝石包含在docker映像中。下面的例子展示了如何用<code class="fe nw nx ny nz b">fluent-plugin-filter-kv-parser</code>构建一个FluentD docker映像。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="d42c" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">扩展FluentD配置，开始解析和过滤日志消息。可以添加的最小配置如下面的代码片段所示。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的过滤器定义，gem将为每个定义的配置使用默认值。你可以在这里找到默认值<a class="ae ky" href="https://github.com/wshihadeh/fluent-plugin-filter-kv-parser/blob/master/lib/fluent/plugin/filter_key_value_parser.rb" rel="noopener ugc nofollow" target="_blank"/>。这意味着<strong class="lb iu"> <em class="lv"> log </em> </strong>键将被用作提取键-值对的源键，并且不会从Fluentd中删除。将使用默认分隔符提取键，而不使用定义的正则表达式，所有提取的键都将添加到fluent事件中。</p><p id="e40c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展FluentD过滤器的配置以改变键提取的行为可以简单地通过在过滤器定义中添加所需的配置项来完成。例如，下面的定义将过滤日志消息，只批准与给定正则表达式匹配的键。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码片段所示，只有匹配定义的正则表达式的键被提取并复制到输出数据中。另一方面，如果您希望将提取的密钥限制为预定义的密钥，您可以使用以下配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">键值FluentD过滤器还支持定义和混合配置。例如，可以将带有正则表达式和精确名称的键同时列入白名单。在这种情况下，过滤器将包括所有匹配正则表达式的键或所提供的精确键。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="81e3" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated"><strong class="ak">结论</strong></h1><p id="734c" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">FlunetD是一个很棒的工具，可以用来解析日志并将它们发送到一个集中的服务器。有很多插件和库可以改进日志解析，解决很多与日志解析相关的问题。此外，通过实现新的FluentD插件或过滤器来扩展日志解析的功能相对简单(你需要一些Ruby经验😆).</p><p id="0924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/wshihadeh/fluent-plugin-filter-kv-parser" rel="noopener ugc nofollow" target="_blank"> Github </a>和我的<a class="ae ky" href="https://docs.shihadeh.dev/ruby-gems/Key-ValueParser/" rel="noopener ugc nofollow" target="_blank">网页</a>上找到键值宝石。非常感谢反馈和改进FluentD过滤器的想法。</p></div></div>    
</body>
</html>