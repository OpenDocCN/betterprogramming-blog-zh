<html>
<head>
<title>You Can’t Loop Over Objects With for-of in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中，不能用for-of循环对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/you-cant-loop-over-objects-with-for-of-in-javascript-a78a308addf2?source=collection_archive---------6-----------------------#2020-02-10">https://betterprogramming.pub/you-cant-loop-over-objects-with-for-of-in-javascript-a78a308addf2?source=collection_archive---------6-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="862d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解对象循环和数组循环的区别</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b440f3dd255de24bcf720dc97218bcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPrJiH-0Qs8qtjsW9nvHkQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@etienneblg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾蒂安·布朗热</a>在<a class="ae ky" href="https://unsplash.com/s/photos/loop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="089b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个小问题。你不能用for-of循环来循环<code class="fe lv lw lx ly b">{x: 1, y:2}</code>。为什么？</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e1b8" class="md me it ly b gy mf mg l mh mi">const obj = { x: 1, y: 2 };</span><span id="17f5" class="md me it ly b gy mj mg l mh mi">for (const key of obj) {<br/>  // ERROR<br/>  console.log(key);<br/>}</span></pre><p id="a713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道确切的原因，你来对地方了！在这篇文章中，我将谈论什么是可迭代的。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3cdc" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">让我们先看看你能循环什么</h1><p id="2a0c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">重要的事情先来。在JavaScript中，有些值可以用for-of循环，有些值不能循环。通常，可以对数组使用for-of。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串也可以循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="368d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这些值不能被映射。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a93d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦执行了产生错误的for-of，就可以看到错误消息很奇怪。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="fb77" class="md me it ly b gy mf mg l mh mi">Uncaught TypeError: 123 is not <strong class="ly iu">iterable</strong></span></pre><p id="b506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有一个变量名是可迭代的，但这意味着什么呢？</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e9a7" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">迭代器是你真正需要的</h1><p id="e33b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">从ES6开始，增加了一个新特性，<code class="fe lv lw lx ly b">Symbol</code>，用于唯一值。在<code class="fe lv lw lx ly b">Symbol</code>函数中，有一个你可以调用的对象，<code class="fe lv lw lx ly b">Symbol.iterator</code>。这是一个为对象返回默认迭代器的函数。</p><p id="aef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建一个对象时，JavaScript在内部创建一个名为<code class="fe lv lw lx ly b">%IteratorPrototype</code>的对象，并将其分配给新创建的对象的迭代器对象。</p><p id="5ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当这个对象被for-of循环使用时，JavaScript检查它是否有iterator对象，该对象继承自JavaScript的内部核心原型<code class="fe lv lw lx ly b">%IteratorPrototype</code>，用于迭代。如果它不存在，您会得到以下错误。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="235a" class="md me it ly b gy mf mg l mh mi">Uncaught TypeError: 123 is not <strong class="ly iu">iterable</strong></span></pre><p id="1808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，<code class="fe lv lw lx ly b">%IteratorPrototype</code>在被创建的时候必须被一个对象使用，这样它才能被循环，一个对象的迭代器对象，比如<code class="fe lv lw lx ly b">[1, 2, 3]</code>，被称为<code class="fe lv lw lx ly b">Symbol.iterator</code>——它在规范中的内部术语是<code class="fe lv lw lx ly b">%%iterator</code>，但是你不能在你的代码中使用这个名字。</p><p id="90ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<a class="ae ky" href="http://ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-data-types-and-values" rel="noopener ugc nofollow" target="_blank">类型</a> (O)不是<code class="fe lv lw lx ly b">Object</code>，抛出<code class="fe lv lw lx ly b">TypeError</code>异常。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8d0a" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">符号迭代器</h1><p id="4215" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">每个可映射对象都有一个<code class="fe lv lw lx ly b">Symbol.iterator</code> —数组、字符串、类型数组、映射和集合。可以显式地使用迭代器函数对其进行循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你得到迭代器对象时，它看起来像这样。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7e20" class="md me it ly b gy mf mg l mh mi">{<br/>  __proto__: {<br/>    next: <em class="np">f next()</em>,<br/>    Symbol(Symbol.toStringTag): "String Iterator"<br/>  }<br/>}</span></pre><p id="9b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有移动对象索引指针头部的<code class="fe lv lw lx ly b">next</code>函数和定义当调用其<code class="fe lv lw lx ly b">toString</code>时如何打印出值的<code class="fe lv lw lx ly b">Symbol.toStringTag</code>方法。</p><p id="d585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你调用<code class="fe lv lw lx ly b">next</code>，它返回这个。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6242" class="md me it ly b gy mf mg l mh mi">{<br/>  value: "h",<br/>  done: false<br/>}</span></pre><p id="a089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">done</code>是显示迭代器是否访问了所有索引的属性，<code class="fe lv lw lx ly b">value</code>是当前索引的值。</p><p id="e9f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果再次调用<code class="fe lv lw lx ly b">next</code>，返回值如下。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2022" class="md me it ly b gy mf mg l mh mi">{<br/>  value: "e",<br/>  done: false<br/>}</span></pre><p id="28a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道为什么<code class="fe lv lw lx ly b">value</code>是<code class="fe lv lw lx ly b">“e”</code>了吧。</p><p id="5515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以继续调用<code class="fe lv lw lx ly b">next</code>并检查<code class="fe lv lw lx ly b">value</code>将是“l”、“l”和“o”，因此它是“hello”。如果你再调用一次<code class="fe lv lw lx ly b">next</code>，返回值会有一点不同。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="97c9" class="md me it ly b gy mf mg l mh mi">{<br/>  value: undefined,<br/>  done: true<br/>}</span></pre><p id="e1a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">value</code>现在未定义，<code class="fe lv lw lx ly b">done</code>为<code class="fe lv lw lx ly b">true</code>。</p><p id="4741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦迭代器遍历了字符串或数组或任何有<code class="fe lv lw lx ly b">Symbol.iterator</code>的东西的所有索引，它一直指向索引的头现在指向空白空间。</p><p id="2a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，<code class="fe lv lw lx ly b">value</code>将是未定义的。并且<code class="fe lv lw lx ly b">done</code>变为<code class="fe lv lw lx ly b">true</code>，因为头部指向空的空间。</p><p id="03ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，你可以继续调用<code class="fe lv lw lx ly b">next</code>，它只会在<code class="fe lv lw lx ly b">value</code>未定义而<code class="fe lv lw lx ly b">done</code>为真时给你相同的响应。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="499a" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使对象可迭代</h1><p id="9fac" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在，让我们使用<code class="fe lv lw lx ly b">Symbol.iterator</code>创建对象iterable。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7ae4" class="md me it ly b gy mf mg l mh mi">const obj = { x: 1, y: 2 };</span></pre><p id="15af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最初的目标。我要做的是添加<code class="fe lv lw lx ly b">[Symbol.iterator]</code>函数，使其可循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="36a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码看起来相当混乱，但我会向您解释这是如何工作的。</p><p id="6e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">next()</code>有<code class="fe lv lw lx ly b">this</code>的范围，是指在<code class="fe lv lw lx ly b">next()</code>之内。所以，<code class="fe lv lw lx ly b">next()</code>中的<code class="fe lv lw lx ly b">this</code>就不看<code class="fe lv lw lx ly b">obj</code>了。</p><p id="ad75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，首先我用<code class="fe lv lw lx ly b">Object.entries()</code>获取了<code class="fe lv lw lx ly b">obj</code>中的每一个条目。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="878c" class="md me it ly b gy mf mg l mh mi">// Object.entries(obj)<br/>[<br/>  0: ["x", 1],<br/>  1: ["y", 2],<br/>  length: 2<br/>]</span></pre><p id="d1ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我创建了index属性来循环访问<code class="fe lv lw lx ly b">entries</code> — <code class="fe lv lw lx ly b">i: 0</code>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="654b" class="md me it ly b gy mf mg l mh mi">if (this.i &gt;= this.entries.length) {<br/>  return { done: true, value: undefined };<br/>}</span></pre><p id="13d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">i</code>等于或大于<code class="fe lv lw lx ly b">entries</code>长度，这意味着迭代器完成了对<code class="fe lv lw lx ly b">entries</code>的循环，它将从下一个迭代器调用开始返回<code class="fe lv lw lx ly b">{ done: true, value: undefined }</code>。</p><p id="ecea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在满足上述条件之前，返回值将为:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="193e" class="md me it ly b gy mf mg l mh mi">{<br/>  done: false,<br/>  value: {<br/>    [this.entries[this.i][0]]: this.entries[this.i++][1]<br/>  }<br/>}</span></pre><p id="b97f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，数据将被成功打印。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d100" class="md me it ly b gy mf mg l mh mi">const (let k of obj) {<br/>  console.log(k);<br/>}</span><span id="b759" class="md me it ly b gy mj mg l mh mi">// { x: 1 }<br/>// { y: 2 }</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="9b81" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="920d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">决定JavaScript中的对象是否可循环的因素是它内部是否有<code class="fe lv lw lx ly b">Symbol.iterator</code>。只有具有<code class="fe lv lw lx ly b">Symbol.iterator</code>的对象才是可循环的——通常是数组。</p><p id="324b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，像<code class="fe lv lw lx ly b">{ x: 1, y: 2 }</code>这样的对象是不可映射的，但是有一种方法可以让它可映射。你可以给它们添加一个定制的<code class="fe lv lw lx ly b">next()</code>方法，我个人不推荐——太费工夫了。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d25a" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><ul class=""><li id="3e05" class="nq nr it lb b lc ni lf nj li ns lm nt lq nu lu nv nw nx ny bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">符号— MDN </a></li><li id="0af8" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator" rel="noopener ugc nofollow" target="_blank"> Symbol.iterator — MDN </a></li><li id="34e0" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="http://ecma-international.org/ecma-262/10.0/index.html#sec-%25iteratorprototype%25-object" rel="noopener ugc nofollow" target="_blank">% iterator prototype %—ECMAScript规范</a></li><li id="9ff8" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://javascript.info/iterable" rel="noopener ugc nofollow" target="_blank">iterable—JavaScript . info</a></li></ul></div></div>    
</body>
</html>