<html>
<head>
<title>Declarative Testing in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的声明式测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/declarative-testing-in-react-4730b16e71ec?source=collection_archive---------20-----------------------#2020-01-07">https://betterprogramming.pub/declarative-testing-in-react-4730b16e71ec?source=collection_archive---------20-----------------------#2020-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="67e3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何为未来编写防重构测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/427444199d1c33eb57e5c07acf14015e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3w7ha4K0Sg3wxp4GWgtpkQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jdent?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰森·登特</a>在<a class="ae kv" href="https://unsplash.com/s/photos/testing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b88a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有开始重构你的React代码，并且在那些测试运行之前你就知道哪些测试会崩溃？</p><p id="6055" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是这样，很有可能你一直在强制性地编写你的测试。相反，通过以声明方式编写测试，可以确保测试仅在行为(而不是特定的实现)发生变化时才会失败，从而改进测试。</p><p id="6b40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，命令式编程范式归结为指定<em class="ls">你想如何</em>完成某事，而声明式编程范式归结为指定<em class="ls">你想完成什么</em>。</p><p id="1edb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在现实世界中，这将是给你的出租车司机一个接一个的方向指示和仅仅给他们你想去的地方的地址之间的区别。</p><p id="1a03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种范式都没有内在的更好或更正确，它们都有各自的优点和缺点。</p><p id="752b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，当使用React时，在编写命令式代码时，尤其是在编写命令式测试时，会出现许多问题。毕竟，React是一个声明式框架。<a class="ae kv" href="https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom" rel="noopener ugc nofollow" target="_blank"> React文档</a>解释道:</p><blockquote class="lt lu lv"><p id="cbc7" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">这种方法[协调虚拟DOM和真实DOM]支持React的声明性API:你告诉React<strong class="ky ir">你希望UI处于什么状态，它确保DOM匹配那个状态。</strong></p><p id="14fc" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">这抽象出了属性操作、事件处理和手动DOM更新，否则您将不得不使用它们来构建您的应用程序。</p></blockquote><p id="9af4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当试图重构代码时，为声明性框架编写命令式测试的一个主要问题变得非常明显。根据定义，重构包括改变代码的编写方式，而不是改变行为的T21。</p><p id="e52a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是命令式测试断言代码是如何编写的，而不是行为是什么。通常，这意味着您的测试断言反对将<code class="fe lz ma mb mc b">props</code>传递给特定的组件，或者确保组件包含给定的<code class="fe lz ma mb mc b">state</code>。</p><p id="b56f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们甚至可能调用你的类组件的实例方法。每当你重构时，结合这些对立的范例必然会导致测试失败。</p><p id="4757" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你知道预测失败时，这看起来并不是什么大不了的事情，但是这种测试真的会让你和你的团队慢下来。今天，你可能确切地知道哪些测试会出错以及如何修复它们，但是随着应用程序的增长以及团队中不同成员对应用程序的工作，你可能会失去这种直觉。</p><p id="ffec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不熟悉您的测试的开发人员永远不会知道如何预测这些失败，所以每次重构都需要花费宝贵的时间来修改或删除失败的测试。在最坏的情况下，命令式测试可能会完全阻碍重构。</p><p id="65a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的测试不能让您确信您没有破坏任何东西，您将会像没有测试一样盲目地重构和添加新特性。</p><p id="c126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遵循下面的步骤不会自动让你的测试变得简单。它们仍然为编写脆弱或难以理解的测试留有足够的空间。</p><p id="115c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这些步骤将引导您编写测试，鼓励对React的最新特性进行实验，同时提供您的用户体验没有改变的信心。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="fc33" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">使用反应测试库代替酶</h1><p id="f1aa" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">冒着被视为赞助帖子的风险，只要切换到<a class="ae kv" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> React测试库</a>，你就已经遵循了下面的大部分建议。</p><p id="24bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但你不必相信我的话。<a class="ae kv" href="https://reactjs.org/docs/test-utils.html#overview" rel="noopener ugc nofollow" target="_blank"> React官方推荐React检测库过酶</a>。</p><p id="02ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酶</a>几乎能做反应测试库能做的一切，但反应测试库做不了酶能做的那么多。</p><p id="2fbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这听起来可能有些违反直觉，但这正是React测试库鼓励您编写更加健壮的测试的方式。他们的<a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/intro" rel="noopener ugc nofollow" target="_blank">文档</a>充分抓住了强制性测试的问题:</p><blockquote class="lt lu lv"><p id="e43c" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">您希望为React组件编写可维护的测试。作为这一目标的一部分，您希望您的测试避免包含组件的实现细节，而是专注于使您的测试给您预期的信心。</p><p id="e4ce" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">作为其中的一部分，您希望您的测试库在长期内是可维护的，这样您的组件的重构(对实现而不是功能的更改)就不会中断您的测试并减慢您和您的团队的速度。</p></blockquote><p id="7275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，Enzyme强大的API经常鼓励编写重实现的测试。使用Enzyme，您可以<a class="ae kv" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank">“操纵、遍历，并以某种方式模拟给定输出的运行时”</a>。</p><p id="2c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是酶可以让你以非常必要的方式做这些事情。有了像<code class="fe lz ma mb mc b"><a class="ae kv" href="https://airbnb.io/enzyme/docs/api/ShallowWrapper/children.html" rel="noopener ugc nofollow" target="_blank">children</a></code>和<code class="fe lz ma mb mc b"><a class="ae kv" href="https://airbnb.io/enzyme/docs/api/ShallowWrapper/state.html" rel="noopener ugc nofollow" target="_blank">state</a></code>这样的方法，你可以窥视组件，看看它们到底是如何编写的。</p><p id="f549" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像<code class="fe lz ma mb mc b"><a class="ae kv" href="https://airbnb.io/enzyme/docs/api/ShallowWrapper/invoke.html" rel="noopener ugc nofollow" target="_blank">invoke</a></code>和<code class="fe lz ma mb mc b"><a class="ae kv" href="https://airbnb.io/enzyme/docs/api/ShallowWrapper/setState.html" rel="noopener ugc nofollow" target="_blank">setState</a></code>这样的方法允许你以一种终端用户永远不会的方式与组件交互。这种类型的互动恰恰突出了两个图书馆之间的核心哲学差异。</p><p id="0182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React测试库努力让你的测试和你的代码交互，就像你的用户那样。它强大的查询API让你看到你的测试，就像你的用户看到你的网站在他们的浏览器上运行一样。</p><p id="e150" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，您的测试可以找到一个输入字段<code class="fe lz ma mb mc b"><a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/api-queries#bylabeltext" rel="noopener ugc nofollow" target="_blank">byLabelText</a></code>并且<a class="ae kv" href="https://github.com/testing-library/dom-testing-library/blob/master/src/events.js#L59" rel="noopener ugc nofollow" target="_blank">触发一个变更事件</a>来模拟在那个字段中的输入。这种方法将被测组件视为一个黑盒。</p><p id="2516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要这个黑盒将预期的内容输出到DOM和用户的屏幕上，开发人员就可以自由地试验新的设计模式或修补React的最新特性，而不会遇到测试失败。</p><p id="ce4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当他们遇到失败时，他们可以肯定他们实际上破坏了应用程序的一个功能。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="f7c9" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">如果我选择不使用React测试库怎么办？</h1><p id="e314" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">无论您不从Enzyme转换的理由或限制是什么，您仍然可以使用该库编写很棒的测试。</p><p id="273f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Enzyme的API不会阻止你编写基于用户交互的声明性测试。但是，为了做到这一点，你需要避免使用很多酶的特性。</p><h2 id="eb0f" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">总是“挂载”而不是“浅层”渲染</h2><p id="2bfa" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Enzyme为您提供了单独渲染正在测试的组件(通过<code class="fe lz ma mb mc b">shallow</code>渲染)或深度渲染该组件及其所有子/孙组件(通过<code class="fe lz ma mb mc b">mount</code>渲染)的选项。</p><p id="222a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://airbnb.io/enzyme/docs/api/shallow.html" rel="noopener ugc nofollow" target="_blank"> Enzyme文档</a>将<code class="fe lz ma mb mc b">shallow</code>渲染的动机解释为“有助于约束自己将组件作为一个单元进行测试，并确保您的测试不会间接断言子组件的行为。”</p><p id="e9ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种动机看起来很合理，但是我已经遇到了这种方法的很多缺点，所以我不再使用它了。</p><p id="8ed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，<code class="fe lz ma mb mc b">shallow</code>渲染已经被证明与React的一些最新功能不兼容。例如，<a class="ae kv" href="https://github.com/airbnb/enzyme/issues/2011" rel="noopener ugc nofollow" target="_blank">它阻止你准确地测试使用钩子</a>的组件。</p><p id="53c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然<code class="fe lz ma mb mc b">shallow</code>渲染很有可能有一天会支持钩子，但是没有说它是否会支持下一组新功能。转移到<code class="fe lz ma mb mc b">mount</code>有助于增强您的信心，相信您已经正确地将这些功能应用到您现有的应用中。</p><p id="3c71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更重要的是，<code class="fe lz ma mb mc b">shallow</code> rendering通过引入可重用组件使重构变得很麻烦。假设您已经创建了下面的表单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2610" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些相当简单的Jasmine测试可能看起来像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="12b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在创建了足够多的文本字段并注意到一些重复之后，您可能会决定创建一个可重用的<code class="fe lz ma mb mc b">TextField</code>组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bace" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">引入新组件后，您的表单看起来会像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="652f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个重构之后，所有三个测试都会失败，因为浅层呈现的酶包装器不会呈现任何<code class="fe lz ma mb mc b">TextField</code>子节点的内容。</p><p id="f2eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是你的应用程序的行为并没有改变。对于最终用户来说，重构前后的DOM看起来完全一样！</p><p id="0c29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浅层呈现的包装器<em class="ls">确实</em>正确地显示了<code class="fe lz ma mb mc b">SomeForm</code>已经呈现了三个<code class="fe lz ma mb mc b">TextField</code>组件，这个有限的组件蓝图可能会鼓励你<code class="fe lz ma mb mc b">find</code>组件包装器并断言它们接收了正确的<code class="fe lz ma mb mc b">labelText</code>属性。</p><p id="b1cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我强烈建议不要这样做，下面会有更详细的介绍。但是，即使我建议了这种替代方法，在重构时，您仍然需要重新访问和编辑失败的测试。相反，通过<code class="fe lz ma mb mc b">mount</code> ing，您的测试将继续看到输出到DOM上的叶节点，并且您可以避免重新访问这些测试。</p><p id="db5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从测试的角度来看，<code class="fe lz ma mb mc b">shallow</code>和<code class="fe lz ma mb mc b">mount</code>分别鼓励编写单元测试和集成测试。由于完全不鼓励<code class="fe lz ma mb mc b">shallow</code>呈现，很自然地，我也不鼓励编写单元测试。</p><p id="b50f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望，它开始变得更清楚为什么。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="2b1a" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">编写更少的单元测试，默认为集成测试</h1><p id="9783" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在我继续之前，有必要简要回顾一下<a class="ae kv" href="https://martinfowler.com/articles/practical-test-pyramid.html" rel="noopener ugc nofollow" target="_blank">测试金字塔</a>，它为开发人员应该编写的测试种类提供了指南。</p><p id="6ec8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最基础的层面上，单元测试是小的和孤立的，所以编写和运行它们相对来说是便宜的。服务测试(通常称为<em class="ls">集成测试</em>)确保两个或更多的单元放在一起时行为正确。</p><p id="d10d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们比单元测试更脆弱，因为多个单元可以包含测试失败的原因。最后，UI测试(有时称为端到端测试)确保您的整个系统正常工作。</p><p id="f245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这类测试通常会在浏览器上运行您的站点，发出实际的HTTP请求，甚至可能会碰到一个真实的数据库(尽管是一个专用于测试的数据库)。</p><p id="b09e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毫无疑问，UI测试是编写和维护成本最高的测试类型。它们也是最无助于准确定位错误来源的。</p><p id="2713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与不同类型的测试相关联的成本/收益比在历史上激励了金字塔形的测试套件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/af63b4e7a413636459fc09e85c6faeb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/0*6yt2W9tgriBbbMec.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://martinfowler.com/articles/practical-test-pyramid.html" rel="noopener ugc nofollow" target="_blank">https://Martin fowler . com/articles/practical-test-pyramid . html</a></p></figure><p id="7b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在React中进行单元测试的最大问题是，对于什么是React单元还没有达成共识。视图组件是一个单元吗？如果它变得太大，你决定把它一分为二，它们现在被认为是两个单元吗？</p><p id="2445" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>或通过<a class="ae kv" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>的组件本身是一个单元吗？如果他们用<a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">钩子</a>怎么办？钩子是一个单位吗？</p><p id="82fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道这可能会被视为对这些非常有效的问题的全盘否定，但是如果您默认编写集成测试，这些问题并不重要。</p><p id="add0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您决定将一个被测试的组件分成两个(或者更多)组件，那么您的默认集成测试将不会关心或者必须改变。如果您决定用<a class="ae kv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>替换渲染道具，以使您的代码不那么冗长，那么您的默认集成测试将不会关心或者必须改变。</p><p id="0406" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你最终引入Formik时，因为你意识到在React中维护你自己的表单是多么令人沮丧，你的默认集成测试不会在意或者必须改变。</p><p id="118c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要您的集成测试总是指定您想在DOM中看到什么，那么您如何到达那里并不重要。这正是React应该被编写的方式，并且我坚信大多数React测试应该被编写成这样。</p><p id="4598" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，单元测试仍然有一个重要的位置。然而，我喜欢将单元测试局限于可重用的组件和任何非反应式的业务逻辑。</p><p id="3888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过对可重用组件进行单元测试，您可以向该组件的任何消费者提供信心，让他们相信它会按预期工作。</p><p id="94df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为那些单元测试直接与可重用组件的API交互，所以它们也记录了那些组件应该如何使用以及它们应该如何表现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kent C. Dodds将这种形式的测试称为测试奖杯。</p></figure></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="a97d" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">不要断言反作用组件</h1><p id="be2f" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">你可能会觉得奇怪，一个旨在测试React的库不应该断言React组件。但是通过React组件的显示名或构造函数将您的测试分别绑定到该组件在您的目录中的具体名称和位置。</p><p id="8b7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使使用IDE工具可以快速查找和替换文件中的文本，并自动更新导入，这些更改也会在拉请求中产生大量噪声。</p><p id="64f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为对React组件进行<code class="fe lz ma mb mc b">find</code>操作和断言的替代方法，您可以用类似于Enzyme的查询API的方式在DOM中查找和断言组件。</p><p id="332b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您发现自己实现这些太难了(或者如果您正在寻找一个快速的解决方案)，您可以从向您断言的元素添加<code class="fe lz ma mb mc b">data-testid</code>属性并<code class="fe lz ma mb mc b">find</code>操作这些元素开始。</p><p id="54b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以这种方式找到您的组件将使以后引入React测试库变得容易，它允许您通过 <code class="fe lz ma mb mc b"><a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/api-queries#bytestid" rel="noopener ugc nofollow" target="_blank">data-testid</a></code>进行<a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/api-queries#bytestid" rel="noopener ugc nofollow" target="_blank">查询，作为一种逃生出口。</a></p><p id="469e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你期望设计和复制经常变化的项目中，<code class="fe lz ma mb mc b">data-testid</code>属性使你的测试对变化更有弹性。随着项目的稳定，您可能希望迁移到用户可以实际看到的查询。</p><p id="e5cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这种迁移可能会使你的测试更加脆弱，但它们有助于确保你的用户能够以一种合理的方式与你的应用程序进行交互。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="df70" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">不要断言反对道具</h1><p id="a55c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">断言反对props会让您的测试套件出现很多假阳性。我经常看到对组件进行单元测试的尝试落入这个陷阱。</p><p id="3ae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您断言props时，您几乎肯定会这样做，因为您的被测组件包含对另一个组件的依赖。为了隔离测试中的组件，您可能决定断言您自己的组件将正确的属性传递给依赖组件。</p><p id="48e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这种策略确实实现了隔离，但它是以牺牲测试信心为代价的。</p><p id="64cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了扩展上面的例子，这样的测试文件可能看起来像下面这样。为了简单起见，他们使用<code class="fe lz ma mb mc b"><a class="ae kv" href="https://airbnb.io/enzyme/docs/api/ShallowWrapper/at.html" rel="noopener ugc nofollow" target="_blank">at</a></code>方法来寻找第一个<code class="fe lz ma mb mc b">TextField</code>节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0a1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员可能会决定改变<code class="fe lz ma mb mc b">TextField</code>，用输入中的占位符文本替换标签标记。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2132" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在缺乏强大的集成和功能测试的情况下，进行这种更改的开发人员可能不会遇到任何测试失败，因此可以放心地推动更改。</p><p id="7ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为，在这种情况下，您应该希望您的测试失败，因为您的最终用户的体验已经发生了变化:他们不知道应该在输入字段中键入什么！</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="6be5" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">不要反对或强迫国家</h1><p id="6eab" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">让您的测试了解组件的内部状态几乎肯定会阻止您保持React代码最新。</p><p id="6f19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">截至<a class="ae kv" href="https://github.com/facebook/react/blob/master/CHANGELOG.md#1680-february-6-2019" rel="noopener ugc nofollow" target="_blank"> React 16.8 </a>，多亏了<a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>，几乎可以完全用功能组件来编写React。功能组件不能像类组件那样使用状态。相反，它们必须使用<a class="ae kv" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> useState </a>钩子。</p><p id="8f13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我开始开发一个特性时，我喜欢先把我遇到的任何类组件转换成功能组件。当我这样做时，我依靠我的测试来指出我是否在转换中犯了错误。</p><p id="e990" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当我不得不在这个过程中解决误导性的测试失败时，这个策略就变得非常慢了。</p><p id="a5b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像最终用户不关心您的实现一样，使用您的可重用组件的开发人员不应该关心它是作为类还是作为功能组件来编写的。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="f34c" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">不要测试实例方法</h1><p id="f818" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">不应该测试私有方法的信念已经变得相当没有争议。毕竟，这些方法没有公开，它们只是实现细节。</p><p id="d0eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这些相同的考虑并不总是扩展到React类组件的实例。Enzyme为您提供了一个<code class="fe lz ma mb mc b"><a class="ae kv" href="https://airbnb.io/enzyme/docs/api/ReactWrapper/instance.html" rel="noopener ugc nofollow" target="_blank">#instance</a></code>函数，充分利用该方法调用实例方法的测试并不少见。</p><p id="f5d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，即使您自信地测试实例方法的行为，这样的测试也不能确保方法实际上被正确地使用。它甚至根本不能确保实例方法正在被使用，这种差距可能会导致死代码的保存。</p><p id="1c78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的代码库最终停止使用实例方法，删除它会导致测试失败。无论是谁遇到这种失败，都可以保持这种方法，以防万一。很快，您的类组件可能会变得难以管理。</p><p id="cdbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过在实例方法中包含业务逻辑，类组件也可以变得很大。如果您对业务逻辑的单元测试有强烈的感觉，那么您可以而且应该以一种功能性的、反应不可知的方式将逻辑抽象出来。</p><p id="5eb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使这些方法具有功能性，您可以使它们可被其他组件重用。通过使它们与React无关，您还可以将您的业务逻辑从UI框架中抽象出来，从而更容易最终迁移到React的新版本甚至新的UI库。</p><p id="9ad3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，不测试实例方法还可以将类组件重构为功能组件(功能组件不能有实例方法),而不会破坏任何测试。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="44c1" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">缺点</h1><p id="984f" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">尽管它们给你的测试套件带来了很多好处，但是我上面概述的策略并不是没有任何缺点的。</p><h2 id="71f2" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">越来越依赖集成测试隐藏了测试失败的根源</h2><p id="aa2c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">随着您的测试套件中单元测试的减少，您的测试失败将不可避免地涉及到许多相连的组件，很可能掩盖了失败的来源。这是一个完全合理的担忧。</p><p id="bae9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是——写得正确——您的测试不会误导您错误可能出现在哪里。当一个单元测试失败时，你会知道错误<em class="ls">必定</em>出现在被测试的单元中。</p><p id="1a4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当集成测试失败时，您将会知道错误<em class="ls">必定</em>出现在DOM的某个地方，从您的测试呈现的组件开始。</p><p id="5891" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">脸书还创建了一套令人惊叹的<a class="ae kv" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" rel="noopener ugc nofollow" target="_blank">开发工具</a>来检查你的React组件，这让调试变得异常愉快。</p><p id="b2aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然它们永远不会取代测试，但是这些工具确实可以让您快速地看到props和上下文值是如何渗透到组件树中的，或者您的组件是如何随着其内部状态的改变而改变的。</p><p id="7e72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用这个快速反馈来帮助您确定测试失败的原因。</p><h2 id="80be" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">失去测试作为文档的好处</h2><p id="a61e" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">作为一个积极的副作用，测试经常为您和您的团队提供与API交互的文档。但是如果你的测试开始关注用户行为，他们就开始失去这种优势。</p><p id="4132" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，你可以通过一些成本不同的策略获得同样的好处。您可以使用轻量级的<a class="ae kv" href="https://reactjs.org/docs/typechecking-with-proptypes.html" rel="noopener ugc nofollow" target="_blank"> PropTypes </a>库来强制传递到组件中的属性的类型。</p><p id="f3fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以使用<a class="ae kv" href="https://flow.org/en/docs/react/" rel="noopener ugc nofollow" target="_blank"> Flow </a>或<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>强类型化你的整个应用。这两种方法都允许您通过快速查看类型定义或PropType签名来记录如何使用组件。</p><p id="0903" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个更加设计者友好的方法，<a class="ae kv" href="https://storybook.js.org" rel="noopener ugc nofollow" target="_blank"> Storybook </a>生动地记录了你的UI组件，允许开发者动态地学习如何使用你的组件。</p><p id="4ee8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">引入这些库确实需要时间和精力。然而，我会权衡维护另一个库所增加的时间和处理脆弱测试所减少的时间。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="d0a4" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">结论</h1><p id="ad2f" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">您可能已经知道React变化极快。我今天写的组件对于我在2017年末学到的React来说非常难以理解。</p><p id="b224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想尽可能轻松地充分利用React的最新功能，你就必须停止测试React的当前功能。React也不会永远是最受欢迎的前端框架。</p><p id="436e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很难预测几年后您将使用哪个新框架，但是您的测试对React了解得越少，以后就越容易移植到另一个测试框架。</p></div></div>    
</body>
</html>