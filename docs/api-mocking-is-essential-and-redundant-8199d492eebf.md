# 为什么我们需要 API 模拟

> 原文：<https://betterprogramming.pub/api-mocking-is-essential-and-redundant-8199d492eebf>

## 单元测试中的 API 嘲讽重要吗，还是什么都不做？答案有点微妙，但我们确实需要这样的测试来减少流失

![](img/90f2724a5084a11361bc865b7197e500.png)

由 [Apeksha Singhwal](https://unsplash.com/@apeksha_singhwal?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

我喜欢两种真实状态同时存在的矛盾。举个例子，前几周关于嘲讽的这条推文:

![](img/26d9e165f1d51fafa97ad9f00d082cb5.png)

如果你使用模拟，你不是在测试。

我的回答是:

![](img/56e2d004b5e7ba4f1d76f63e26a0fe55.png)

```
[Mocks help assert limited fixed functionality, and they do it FAST.](https://twitter.com/debugagent/status/1582919132856864768)[Which is what unit tests are about. Mocks are an essential part of a wider quality strategy. Otherwise you will spend your time in integration test churn.](https://twitter.com/debugagent/status/1582919132856864768)[No, they are not enough. But they do test.](https://twitter.com/debugagent/status/1582919132856864768)
```

似乎我们都在说完全相反的话，但事实未必如此。我明白马克西的意思。他的观点很有道理。模拟是有问题的。

# 模仿的问题

模拟隐藏了对真实 API 的外部依赖，所以它们不测试它们。这将测试的范围限制在一个非常狭窄的硬编码集合中。它依赖于内部实现细节，比如实现测试的依赖关系，这意味着即使契约没有改变，如果实现改变了，测试也可能会失败。让我们看一个例子:

```
public int countUserCities() {
    return db.executeInt(“select count(“city”) from users”);
}
```

我们可以模拟 db 函数 executeInt，因为返回的结果会很差。但是，如果我们将原始 API 调用更改为如下形式，这种情况就会发生:

```
public int countUserCities() {
    return db.count(“city”,”users”);
}
```

这不包括任何东西。一个好得多的方法是将虚假数据添加到临时数据库中，由于有了像`[Testcontainers](https://www.testcontainers.org/)`这样的项目，这非常容易做到。我们可以动态地旋转容器，并用一个类似于生产中的数据库来“正确地”检查方法。这将执行正确的检查；它会因为查询中的输入错误而失败，并且不依赖于内部实现。

不幸的是，这种方法是有问题的。加载一个新的数据库需要时间。即使是集装箱。随着测试范围的扩大，对每个套件都这样做可能会成为一个问题。这就是为什么我们把单元测试和集成测试分开。性能很重要。

# 性能问题

你知道最糟糕的测试是什么吗？

那些你不运行并最终删除的。

频繁测试至关重要。持续测试让我们在开发过程中很快失败。快速失败意味着我们的开发人员模式对于触发失败的变更仍然是新鲜的。你不需要 git 平分；你几乎可以立即解决问题。

为了正常工作，我们需要一直运行测试周期。如果需要一段时间来完成测试工作流并需要一些配置(例如，docker 等)。)也可能与 CPU 架构发生冲突(例如 M1 Mac)，那么我们可能就有问题了。

我们模拟单元测试的外部依赖性，这样性能会提高。但是我们不能放弃对实际 API 的完整调用，因为模仿有问题。但是，这些可以在 CI 流程中运行。我们不需要一直运行它们。这是否滋生了重复:是的。糟透了，我不喜欢。

不幸的是，我现在不知道还有其他方法。我试图想出一种方法，用代码在一次执行中作为单元测试，在 CI 中运行时作为集成测试调用真正的对应部分。但我想不出什么可行的办法，不会让事情变得更糟。

因此，我认为只检查集成测试的覆盖率是很重要的。单元测试覆盖很有趣，但不如集成覆盖重要。我不赞成 100%的保险。但这是一个需要监控的重要统计数据。

# 我们应该嘲笑什么？

我给出了数据库的例子，但不支持模仿数据库。对于 Java，我通常使用一个轻量级的内存数据库，它在大多数情况下都能很好地工作。造假者接受 CSV 格式来填充数据库，甚至可以拿出自己的假数据。这比嘲弄要好，并且让我们接近集成测试质量和单元测试性能。

然而，我们不能不断地连接到 web 服务依赖而不嘲讽。从这个意义上说，我认为嘲笑我们控制之外的一切是个好主意。在这一点上，我们面临着在哪里嘲笑的选择。我们可以使用包含编码请求和响应的模拟服务器。这在处理集成测试时是有意义的。单元测试没有那么多，但是如果服务器是无状态的和本地的，我们可以做。在这种情况下，我更喜欢模拟对 API 端点的调用。它将比实际的 API 更快，但是仍然会引起问题。

过度模仿对太多的 API 调用应用了太多的模仿。开发人员可能会参与进来，以增加令人垂涎的覆盖率。这进一步加强了我的主张，覆盖不应该应用于单元测试，因为它可能导致这样的情况。对于框架访问的大多数本地资源来说，行为不应该被嘲笑。

# 最后

我喜欢嘲讽。它使得一些功能的开发成为可能。没有它，我不能正确地检查插件，API，服务器等。然而，像所有好的糖果一样。太多的“好事”会破坏我们的代码。这也是平衡膳食的一小部分(延伸比喻，但它是有效的)。我们可以构建功能测试，然后就到此为止。不能光靠嘲讽。相反，它们不是我们所寻求的“真正的”质量标志。

集成测试占据了那个位置。当我们有覆盖面时，我们就有重要的、有价值的覆盖面。嘲笑对于缩小问题范围和避免退步是非常好的。当我需要检查一个补丁是否还在时，模拟测试是完美的工具。这种组件的开发是有问题且脆弱的。但这是好事。我们希望代码与实现有一点联系。

如果没有适当的嘲讽，有些操作将很难涵盖。当测试整个系统时，这可能是合理的预期，但对于功能测试来说不是。在这些情况下，我们需要快速响应，实际的 API 可能还不够。