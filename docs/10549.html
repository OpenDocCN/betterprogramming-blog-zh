<html>
<head>
<title>Runtime Data Validation from TypeScript Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自TypeScript接口的运行时数据验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/runtime-data-validation-from-typescript-interfaces-1001ad22e775?source=collection_archive---------4-----------------------#2022-01-14">https://betterprogramming.pub/runtime-data-validation-from-typescript-interfaces-1001ad22e775?source=collection_archive---------4-----------------------#2022-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0860" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我(ab)如何使用TypeScript编译器来启用使用Zod和TypeScript接口的透明运行时数据验证。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7f7ae1af69846e8cf52ec5a5705030de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cyd8JNHcqFTzAEPRYa2lCw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="5bc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在过去一年左右的时间里，我一直在(慢慢地)构建一个名为<a class="ae lr" href="https://extollo.garrettmills.dev/" rel="noopener ugc nofollow" target="_blank"> Extollo </a>的基于TypeScript的Node.js框架。</p><p id="bbb1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Extollo的设计目标之一是只向用户(即开发人员)展示ES/TypeScript的本地概念，以减少启动和运行框架所需的专门知识。</p><h1 id="4338" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运行时模式:DSL的瘟疫</h1><p id="8b70" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我对当前Node.js框架场景最大的不满之一是，当涉及到模式定义时，几乎每个生态系统都必须重新发明轮子。因为JavaScript没有本地的运行时类型规范系统(至少不是一个好的系统)，所以如果您想对数据结构在运行时应该是什么样子的细节进行编码，您需要设计一个在运行时传递这些信息的系统。</p><p id="ea99" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，一个多产的MongoDB ODM for Node.js，Mongoose，让用户能够在定义模型时指定集合中记录的模式。这里有一个来自<a class="ae lr" href="https://mongoosejs.com/docs/guide.html#definition" rel="noopener ugc nofollow" target="_blank">mongose文档</a>的样本模式定义:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b872" class="mu lt iq mq b gy mv mw l mx my">import mongoose from 'mongoose';<br/>const { Schema } = mongoose;</span><span id="6889" class="mu lt iq mq b gy mz mw l mx my">const blogSchema = new Schema({<br/>  title:  String, // String is shorthand for {type: String}<br/>  author: String,<br/>  body:   String,<br/>  comments: [{ body: String, date: Date }],<br/>  date: { type: Date, default: Date.now },<br/>  hidden: Boolean,<br/>  meta: {<br/>    votes: Number,<br/>    favs:  Number<br/>  }<br/>});</span></pre><p id="019c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我目前正在为Extollo构建请求验证系统。因为它必须处理带有动态输入的web请求，所以需要在运行时指定验证器接口，以便可以根据模式检查数据。为此，我使用了由科林·麦克唐奈编写的神奇的<a class="ae lr" href="https://github.com/colinhacks/zod" rel="noopener ugc nofollow" target="_blank"> Zod模式验证器库</a>。</p><p id="cc0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，Zod和Mongoose一样，都是JavaScript运行时模式的基本问题的受害者。因为它的模式需要在运行时可用，所以您必须使用Zod的自定义模式构建器来定义您的接口。以下是可能来自登录页面的一些数据的模式示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b896" class="mu lt iq mq b gy mv mw l mx my">import { z } from 'zod'</span><span id="dfda" class="mu lt iq mq b gy mz mw l mx my">export const LoginAttemptSchema = z.object({<br/>	username: z.string().nonempty(),<br/>	password: z.string().nonempty(),<br/>	rememberMe: z.boolean().optional(),<br/>})</span></pre><p id="8af2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这还不算太糟糕，但是它确实需要开发人员学习Zod的特定模式定义语言。我发现这特别烦人，因为TypeScript已经有了接口定义语言。在这种情况下，如果开发人员已经知道语言内置的系统，我想避免让他们学习一个等价的系统。</p><p id="8a41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们用TypeScript重写这个模式:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6143" class="mu lt iq mq b gy mv mw l mx my">export interface LoginAttempt {<br/>	/** @minLength 1 */<br/>	username: string<br/>	<br/>	/** @minLength 1 */<br/>	password: string<br/>	<br/>	rememberMe?: boolean<br/>}</span></pre><p id="ec82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，这是一个进步！我们可以使用TypeScript的本机类型语法来定义接口，并为任何不能本机表达的属性增加JSDoc注释。因此，要在Zod中使用它，我们需要将它从TypeScript语法转换为Zod语法。幸运的是，杨奇煜·伯纳德领导了优秀的<a class="ae lr" href="https://github.com/fabien0102/ts-to-zod" rel="noopener ugc nofollow" target="_blank"> ts-to-zod项目</a>，该项目检查文件中定义的接口，并为它们输出等价的zod模式。</p><p id="4174" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯（表示踌躇等）..所以现在用户可以用(大部分)本机TypeScript语法编写他们的模式定义，并且，通过一点助手工具，我们可以将它们转换成Zod格式，这样我们就可以在运行时使用它们。完美！嗯，差不多…</p><p id="b0b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们想要在运行时实际上<em class="na"> u </em>阿瑟模式时，我们会遇到一个微妙的问题。让我们看一个例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="dcd9" class="mu lt iq mq b gy mv mw l mx my">import { Validator } from '@extollo/lib'<br/>import { LoginAttempt } from '../types/LoginAttempt.ts'</span><span id="d626" class="mu lt iq mq b gy mz mw l mx my">class LoginController {<br/>	public function getValidator() {<br/>		return new Validator&lt;LoginAttempt&gt;()<br/>	}<br/>}</span></pre><p id="f294" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个类有一个方法，该方法返回一个新的验证器实例，并将LoginAttempt模式作为其类型参数。直观地说，这应该会产生一个验证器，在运行时根据LoginAttempt模式验证数据。让我们看看编译后的JavaScript:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="dd42" class="mu lt iq mq b gy mv mw l mx my">"use strict";<br/>Object.defineProperty(exports, "__esModule", { value: true });<br/>const Validator_1 = require("@extollo/lib").Validator;<br/>class LoginController {<br/>    getValidator() {<br/>        return new Validator_1.Validator();<br/>    }<br/>}</span></pre><p id="454a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">哦哦。忽略样板噪声，我们看到我们漂亮的、类型参数化的验证器实例已经去掉了它的类型信息。为什么？TypeScript是一个<a class="ae lr" href="https://devopedia.org/transpiler" rel="noopener ugc nofollow" target="_blank"> transpiler </a>。因此，它获取类型脚本代码并输出与<em class="na">等价的</em> JavaScript代码。因为JavaScript在运行时没有类型的概念，所以transpiler(在本例中是tsc)将它们剥离出来。</p><p id="f439" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以现在我们有一个问题。我们已经通过只要求开发人员指定TypeScript类型来改进我们的用户界面，但是现在我们不能在运行时使用它们，因为TypeScript类型被去掉了。我们刚刚生成的Zod模式呢？你问得很明智。不幸的是，在接口和它引入的Zod模式之间没有映射，也没有简单的方法来创建这样的映射，因为它必须在编译时完成。</p><h1 id="9cd6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一个很深的兔子洞</h1><p id="ccfc" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">通常，这是故事的结尾。您需要在接口和Zod模式之间建立某种映射(请记住，由于我们的ts-to-zod魔术，开发人员根本不知道这种映射的存在)来使验证器工作。在泛型TypeScript项目中，您必须有某种命名约定，或者以某种方式向用户公开模式来创建映射。</p><p id="c6e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，Extollo有一个独特的优势，我怀疑可以用来透明地解决这个问题:<code class="fe nb nc nd mq b"><a class="ae lr" href="https://code.garrettmills.dev/extollo/cc" rel="noopener ugc nofollow" target="_blank">excc</a></code>。Extollo项目主要是类型脚本项目，但它们也包含其他文件，如视图、资产等，这些文件需要包含在外建的包中。为了标准化所有这些，Extollo使用自己的名为<code class="fe nb nc nd mq b">excc</code>的项目编译器进行构建。<code class="fe nb nc nd mq b">excc</code>主要是围绕tsc 的一个包装器，它做一些额外的预处理和后处理来处理上面的情况。</p><p id="7779" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为Extollo项目都在使用<code class="fe nb nc nd mq b">excc</code>，这意味着我们可以在编译时进行任意处理。我怀疑有一种方法可以在接口和我们为运行时生成的模式之间创建映射。</p><h1 id="7bbc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">zod-定义接口</h1><p id="2bb6" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">第一步是使用<code class="fe nb nc nd mq b">ts-to-zod</code>将TypeScript接口转换成Zod schemata。在<code class="fe nb nc nd mq b">excc</code>中，这被实现为<a class="ae lr" href="https://code.garrettmills.dev/Extollo/cc/src/branch/master/src/phases/ZodifyPhase.ts#L30" rel="noopener ugc nofollow" target="_blank">一个预处理步骤</a>，它将Zod模式附加到。包含接口的ts文件。因此，经过处理的LoginAttempt.ts可能如下所示:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b503" class="mu lt iq mq b gy mv mw l mx my">import { z } from "zod";</span><span id="5634" class="mu lt iq mq b gy mz mw l mx my">export interface LoginAttempt {<br/>	/** @minLength 1 */<br/>	username: string<br/>	<br/>	/** @minLength 1 */<br/>	password: string<br/>	<br/>	rememberMe?: boolean<br/>}</span><span id="03a8" class="mu lt iq mq b gy mz mw l mx my">export const exZodifiedSchema = z.object({<br/>	username: z.string().nonempty(),<br/>	password: z.string().nonempty(),<br/>	rememberMe: z.boolean().optional(),<br/>});</span></pre><p id="c01d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这有一些缺点。也就是说，它假设每个文件只定义了一个接口。然而，Extollo对模型、中间件、控制器和配置文件等其他概念强制执行这种约定，所以在这里做这样的假设是合适的。</p><p id="4cab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这使我们更接近了，但是它仍然没有为运行时模式做映射。第一步是设计一些引用模式的方法，这样我们就可以很容易地修改使用相关接口的TypeScript代码。</p><p id="b018" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我不喜欢我最初的系统，但是现在<code class="fe nb nc nd mq b">excc</code>为它定义的每个接口生成一个唯一的ID号。然后，当它将Zod模式写入接口的文件中时，它添加代码以将其注册到<a class="ae lr" href="https://code.garrettmills.dev/extollo/lib/src/branch/master/src/validation/ZodifyRegistrar.ts" rel="noopener ugc nofollow" target="_blank">全局服务</a>，该服务在运行时将ID号映射到Zod模式。因此，上面的文件实际上会类似于:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8815" class="mu lt iq mq b gy mv mw l mx my">import { z } from "zod";<br/>import { registerZodifiedSchema } from "@extollo/lib";</span><span id="1b37" class="mu lt iq mq b gy mz mw l mx my">export interface LoginAttempt {<br/>	/** @minLength 1 */<br/>	username: string<br/>	<br/>	/** @minLength 1 */<br/>	password: string<br/>	<br/>	rememberMe?: boolean<br/>}</span><span id="4c6d" class="mu lt iq mq b gy mz mw l mx my">/** @ex-zod-id 11@ */<br/>export const exZodifiedSchema = z.object({<br/>	username: z.string().nonempty(),<br/>	password: z.string().nonempty(),<br/>	rememberMe: z.boolean().optional(),<br/>});<br/>registerZodifiedSchema(11, exZodifiedSchema);</span></pre><p id="b49d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能看起来不多，但这是朝着我们的目标迈出的巨大的一步。现在，在编译时，我们有了接口到id的映射，在运行时，有了id到模式的映射。因此，我们可以使用编译时映射来修改所有引用该接口的地方，以便用该接口的模式ID来设置运行时参数。然后，在运行时，我们可以使用ID来查找模式。答对了。不，我们实际上是怎么做的…</p><h1 id="4e37" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">争论AST</h1><p id="aa47" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在我们有了映射，我们需要确保在代码中引用类型时进行查找。也就是说，在我们创建验证器<loginattempt>的任何地方，我们都应该为验证器实例上的LoginAttempt设置Zod模式的ID。</loginattempt></p><p id="3de4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我为TypeScript编写了几个转换器插件。现在，tsc默认不支持插件。(你可能在某个项目的<code class="fe nb nc nd mq b">tsconfig.json</code>里见过插件，但它们是编辑器语言服务器的<a class="ae lr" href="https://www.typescriptlang.org/tsconfig#plugins" rel="noopener ugc nofollow" target="_blank">插件，而不是编译器。幸运的是，有一个很棒的开源包可以解决这个问题。Ron S .维护了一个名为</a><a class="ae lr" href="https://github.com/nonara/ts-patch" rel="noopener ugc nofollow" target="_blank"> ts-patch </a>的包，该包很恰当地为一个项目的<code class="fe nb nc nd mq b">tsc</code>安装打补丁，以允许该项目指定编译器插件。</p><p id="61d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些插件在TypeScript程序的抽象语法树上操作。如果你不熟悉ast，它们基本上是编译器对你正在编译的程序的内部表示。它们是可以操作和优化的数据结构。当您安装一个插件时，它会被AST为您正在编译的TypeScript项目中的每个源文件重复调用。重要的是，插件可以替换AST中的任何节点，或者在文件中返回一个完全不同的节点，<code class="fe nb nc nd mq b">tsc</code>将输出修改后的版本，而不是原来的版本。</p><h1 id="a4ff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">首先，识别</h1><p id="f251" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">第一个插件对项目中每个文件的整个AST进行操作。它的工作是遍历每个文件的AST和<a class="ae lr" href="https://code.garrettmills.dev/Extollo/cc/src/branch/master/src/transformer.ts#L92" rel="noopener ugc nofollow" target="_blank">寻找我们为其生成Zod模式的接口声明</a>。当它找到一个时，它解析出我们先前写入文件的ID号，并存储该ID号和TypeScript用来在内部标识接口的符号之间的映射。</p><p id="eb2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们是将Zod模式写入文件的人，所以我们可以知道它——以及向全局服务注册它的调用——是文件中的最后语句。因此，我们可以快速查找它们，并从注册调用中解析出ID。</p><p id="40b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，扩充文件的类型脚本AST如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/f451ddd6f9485c342af58b3557849dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y0T9vVErhJu3WqsG.png"/></div></div></figure><p id="82aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">(顺便说一下，我使用ts-ast-viewer web应用程序生成了这个层次结构<a class="ae lr" href="https://ts-ast-viewer.com/#code/JYWwDg9gTgLgBAbzgLzgXzgMyhEcBEyEAJvgNwBQoksicUApgObADOMDUAWicJsA2IBlAMYALBiACG6LDjz4AAgwAeMCABsNEAPQbgAI3IUKqmvGAA7DlExSRDOABkILSwEEYHcPAQUAkDoAVEFwiiBWTgyWTDBicACMcEE6AQCurJyWUiAMAFxw7FBWTAEBwaHhkdGx8UkpAWBSrKwA7tDEBUUlZf6MuSAGnACyDAD8BQYQmgxSlhRoJhVhqgC0RMSrwMSJCYrJqWbQ8CIQluxwqjzEfALC4pIyALwoAHQQBgBWDCIwABR+fwZLI5fJvboxP4ASleljOkjAMAAntCADSNZptDoFZCvCFMaGw+E+FFQ9F9SSSIZQUY415TGZzQkQRHAM5SDRohZQyiMFjsTjXW6CUQSaR-BIJVGXFRC-gih7SHkUIA" rel="noopener ugc nofollow" target="_blank">。ts-ast-viewer是由David Sherret </a>发起的一个项目，它允许您可视化和探索任何类型脚本程序的ast。这对我理解这个项目的结构是非常宝贵的。)</p><p id="6420" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过递归遍历AST，我们可以寻找InterfaceDeclaration节点。如果我们在文件中找到一个，我们可以检查文件的根，看看是否定义了一个名为<code class="fe nb nc nd mq b">exZodifiedSchema</code>的标识符。如果是这样，我们获取文件中的最后一条语句(包含对<code class="fe nb nc nd mq b">registerZodifiedSchema</code>的调用的ExpressionStatement)并取出它的第一个参数，即ID号。</p><p id="2110" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦这个转换器完成，我们就已经确定了生成Zod模式的所有接口，并创建了从接口到运行时所需ID号的映射。</p><h1 id="a1ed" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">然后，修改</h1><p id="3596" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">第二个插件在第一个插件检查完项目中的所有文件后运行。这个插件的工作是<a class="ae lr" href="https://code.garrettmills.dev/Extollo/cc/src/branch/master/src/transformer.ts#L7" rel="noopener ugc nofollow" target="_blank">用一个</a><a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">life</a>替换任何NewExpression节点，其中类型参数包含Zod化接口，life将<code class="fe nb nc nd mq b">__exZodifiedSchemata</code>属性设置为一个ID号数组，用于查找这些接口的模式。</p><p id="13cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是说，插件转换了这个:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8b35" class="mu lt iq mq b gy mv mw l mx my">new Validator&lt;LoginAttempt&gt;()</span></pre><p id="621a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">变成这样:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d450" class="mu lt iq mq b gy mv mw l mx my">(() =&gt; {<br/>	const vI = new Validator&lt;LoginAttempt&gt;();<br/>	vI.__exZodifiedSchemata = [11];<br/>	return vI;<br/>})()</span></pre><p id="da98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为<code class="fe nb nc nd mq b">NewExpression</code>是一个表达式，就像<code class="fe nb nc nd mq b">CallExpression</code>一样，任何有<code class="fe nb nc nd mq b">NewExpression</code>的地方都可以用这个<code class="fe nb nc nd mq b">CallExpression</code>代替，用附加的逻辑包装它。</p><p id="e580" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">转换器能够查找与接口相关联的ID号，因为引用<code class="fe nb nc nd mq b">new Validator&lt;LoginAttempt&gt;()</code>中接口的标识符与我们用第一个插件标识的InterfaceDeclaration具有相同的符号集。</p><p id="0931" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些符号是由TypeScript编译器中称为链接器的东西创建的，它解析所有的标识符声明，并将它们与这些标识符的使用相匹配，即使实际的变量在此过程中已经被重命名。因此，我们可以使用这些符号来匹配接口的使用和我们关心的接口的声明。</p><p id="b1ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="na">这种</em>是最终让一切运转起来的神奇调味酱。该插件运行后，程序TypeScript完成编译，根据验证器实例化时指定的接口，将所有运行时类型映射链接到验证器实例。</p><h1 id="6455" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="c547" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这是一个漫长的旅程，有点累，但最终的结果非常好。从开发人员的角度来看，他们可以这样输入:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="387c" class="mu lt iq mq b gy mv mw l mx my">const validator = new Validator&lt;LoginAttempt&gt;();</span></pre><p id="9d64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">并且，在运行时，验证器实例将拥有一个Zod模式，并能够根据该模式解析数据。没有自定义模式定义语言，没有验证器/模式映射，什么都没有。对于开发人员来说，这只是纯粹的类型脚本，这是他们一直以来的目标。</p><p id="533c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这项功能的代码仍在开发中，我必须删除大量未使用的代码，清理我保留的代码，并可能重写其中的一部分，使其不那么…简单。但是，最终，我对这个“神奇”的特性非常满意，它有助于保持Extollo项目的原生类型和易于维护。</p><p id="a573" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在这里找到一个与这个帖子<a class="ae lr" href="https://code.garrettmills.dev/garrettmills/blog-runtime-types" rel="noopener ugc nofollow" target="_blank">相匹配的最小工作示例。</a></p><blockquote class="nf ng nh"><p id="a720" class="kv kw na kx b ky kz jr la lb lc ju ld ni lf lg lh nj lj lk ll nk ln lo lp lq ij bi translated">这篇文章最初出现在我的博客上，<a class="ae lr" href="https://garrettmills.dev/blog/2022/01/14/Runtime-Data-Validation-from-TypeScript-Interfaces/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote></div></div>    
</body>
</html>