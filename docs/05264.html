<html>
<head>
<title>What’s New in Swift From WWDC 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift在WWDC 2020中的新功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-swift-wwdc2020-4c112bbeb8fe?source=collection_archive---------8-----------------------#2020-06-24">https://betterprogramming.pub/whats-new-in-swift-wwdc2020-4c112bbeb8fe?source=collection_archive---------8-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7d3f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">苹果公司今年发布的所有产品的详细介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4cc3d72680603e67ea478561fad59ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a065QVHxEyN6OP3BCIdXYg.png"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="914e" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">内部基准:二进制大小</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lq"><img src="../Images/6c03fd3d82626a9ccc9ff288fcfe1055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-S3fIH4KBIMueDKF.png"/></div></div></figure><p id="f6c3" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">为了跟踪进度，我们对iOS自带的一个应用进行了快速重写。</p><p id="b3c8" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在随后的每个版本中，我们缩小了差异。有了Swift 5.3，我们的代码大小降到了Objective-C版本的1.5倍以下。</p><p id="de1f" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">然而，不同风格的应用程序会产生不同的二进制大小。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="cf3a" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">MovieSwiftUI二进制大小</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/a0a8aba114d59345370783f9e442f69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2_RdA87fBcJaOFnG.png"/></div></div></figure><p id="34c5" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Swift 5.3中，SwiftUI应用程序的代码大小有了重大改进。我们看到它的应用程序登录代码减少了40%以上。</p><p id="2aaa" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">现在，二进制文件的大小对于下载时间是至关重要的。但是当你运行应用程序时，它是我们所谓的<em class="mo">干净记忆的一部分。</em>这是可以清除的内存，因为它可以在需要时重新加载。所以它没有<em class="mo">脏内存、</em>应用程序在运行时分配和操作的内存那么重要。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="08a6" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">肮脏的记忆</h1><h2 id="5fd1" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">内存布局示例</h2><p id="0648" class="pw-post-body-paragraph lr ls iq lt b lu nb jr lw lx nc ju lz ma nd mc md me ne mg mh mi nf mk ml mm ij bi translated"><strong class="lt ir">物镜-C </strong></p><p id="3f1d" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">与基于引用类型的语言相比，Swift使用值类型有一些基本优势。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/a6ec3c07454f6bbd67db12cb847841c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h_wQ6W8fbjI09vOA.png"/></div></div></figure><p id="b3b9" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Objective-C中，对象变量只是指针。所以数组保存了指向模型对象的指针。反过来，这些对象持有指向其属性的指针。您分配的每个对象都有一些开销、性能和内存使用。</p><p id="126f" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">这一点非常重要，Objective-C为微小的ASCII字符串提供了一种特殊的小字符串表示，允许将它们存储在指针中，从而节省了分配额外对象的时间。</p><p id="605b" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated"><strong class="lt ir">雨燕</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/6f42ea2182ee38cefbf1188b249776b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AUpb5oASaBNHSUp_.png"/></div></div></figure><p id="0e94" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">Swift对值类型的使用避免了通过指针访问这些值的需要。因此，UUIDs可以保存在<code class="fe ni nj nk nl b">Mountain</code>对象中，Swift的小字符串可以保存更多的字符，多达15个代码单元，包括非ASCII字符。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/21b21f6d390055a2675915cd82aceacd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dCTlKFHfd2k6bDXO.png"/></div></div></figure><p id="fa12" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">最后，所有的<code class="fe ni nj nk nl b">Mountain</code>对象可以直接在数组存储中分配。所以除了几个字符串之外，所有东西都保存在一个连续的内存块中。像这样使用值类型，Swift程序可以获得显著的内存优势。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="cba7" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">堆使用</h1><h2 id="655b" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated"><em class="nn"> 400个模型对象</em></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/69632817fa747f22c2638c229a652c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ao2V-VPJcEe9IuU8.png"/></div></div></figure><p id="f8bc" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">因此，如果我们检查由400个这些模型对象组成的数组所使用的热内存，我们可以看到Swift模型数据更加紧凑。</p><h2 id="9faf" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated"><em class="nn">模型和语言/库开销</em></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/5bf935759b28b33e60d704fad1382caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aRemZKclGy8KJzcW.png"/></div></div></figure><p id="49a6" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">由于运行时开销，一些Swift程序以前仍然使用更多的热内存。以前，Swift在启动时会创建大量缓存和内存。这些缓存存储了协议一致性和其他类型的信息，以及用于将类型过渡到Objective-C的数据。</p><h2 id="4cc1" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated"><em class="nn"> Swift 5.3 </em></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/381a2ea97ec2dcdf16e374ab853d4cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ToEYMWqdhYzf5XVS.png"/></div></div></figure><p id="146d" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">所有语言运行时都有一些开销，但是在Swift的例子中，开销太大了。在Swift 5.3中，这种开销已经被大幅削减，Swift版本的应用程序现在使用的热内存不到去年版本的三分之一。</p><p id="0946" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">为了充分利用这些改进，应用程序的最低部署目标需要设置为iOS 14。</p><p id="796e" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated"><strong class="lt ir">降低用户空间堆栈中的Swift运行时</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/7c3c03afea903322ab03f17b555637ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ygTeZwjzBqdEGqJ8.png"/></div></div></figure><p id="4189" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在大多数应用程序中，这些差异通常并不明显，但像这样优化Swift的内存对于在苹果系统中进一步推动Swift至关重要——能够在demons和低级框架中使用它，其中使用的每一个字节的内存都很重要。</p><p id="d274" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">Swift的标准库现在位于基础库之下。这意味着它实际上可以用来实现浮动在Objective-C层之下的框架，而以前必须使用C。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="d941" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">诊断学</h1><p id="dd8a" class="pw-post-body-paragraph lr ls iq lt b lu nb jr lw lx nc ju lz ma nd mc md me ne mg mh mi nf mk ml mm ij bi translated">在这个发布周期中，编译器的错误和警告有了很大的改进。</p><h2 id="7b37" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">Swift编译器中的新诊断子系统</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/9533f651399e96c33cf8c8a5f4a90ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*myw6edhP1Z3rS7Ue.png"/></div></div></figure><p id="6a51" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">Swift编译器有一种新的诊断策略，可以产生更精确的错误，指出源代码中出现问题的确切位置。有新的试探法用于诊断导致可操作错误的问题原因，并提供了如何修复问题的指导。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/2eccbaec024f6fbcb4f695040f408012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HW25F3elrIUixbgp.png"/></div></div></figure><p id="e145" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">这是一个一年前Swift 5.1编译器在SwiftUI代码中产生的难以理解的诊断的例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/28156989112dd881be0d082ca66517b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G0XTDhOgLN5Jjjrq.png"/></div></div></figure><p id="1182" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">快进到今天，诊断明显更好了，有一个错误告诉你到底是什么问题。</p><p id="14f7" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在诊断问题时，编译器还会在内部记录更多关于问题的信息，因此它现在会生成附加注释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/4e471b2fd85f35f4ea6258fa7f60b0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bsRKshaBdZqplsNw.png"/></div></div></figure><p id="1c06" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在这种情况下，应用修复自然会引导开发人员为不完整的<code class="fe ni nj nk nl b">TextField</code>初始化提供缺失的部分。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="e8af" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">代码完成</h1><p id="dfa1" class="pw-post-body-paragraph lr ls iq lt b lu nb jr lw lx nc ju lz ma nd mc md me ne mg mh mi nf mk ml mm ij bi translated">这涵盖了从编译器在<code class="fe ni nj nk nl b">SourceKit</code>中提供的代码完成推理，到Xcode代码编辑器中的体验。</p><h2 id="2d5e" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">改进的类型检查推理</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/5d26358aa12bc606155d848d63b4e350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GfvvQXTAbTarMnk_.png"/></div></div></figure><p id="7219" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">首先，候选补全的推断有了显著的改进。这里，当在不完整的字典文字中使用时，编译器推断三元表达式中的值。</p><h2 id="2efa" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">代码完成:KeyPath作为函数</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/279e22f181f544cc2833188544a6441f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7nEoPVcaNYX4VQZO.png"/></div></div></figure><p id="d704" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">代码完成还为语言的一些更动态的特性提供了您所期望的值，比如使用<code class="fe ni nj nk nl b">KeyPath</code>作为函数。</p><h2 id="e451" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">代码完成速度比Xcode 11.5快15倍</h2><p id="fcd1" class="pw-post-body-paragraph lr ls iq lt b lu nb jr lw lx nc ju lz ma nd mc md me ne mg mh mi nf mk ml mm ij bi translated">除了完成结果的质量之外，代码完成性能也得到了极大的提高，在某些情况下提高了15倍。</p><h2 id="b978" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">SwiftUI代码的代码完成性能</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/45959455a2d405b6ab0a9e2bc4cb793b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NtV3acKDADsr2AFj.png"/></div></div></figure><p id="359b" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">这对于编辑SwiftUI代码尤其有益。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="bcdc" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">代码缩进</h1><p id="f2ac" class="pw-post-body-paragraph lr ls iq lt b lu nb jr lw lx nc ju lz ma nd mc md me ne mg mh mi nf mk ml mm ij bi translated">Xcode中的代码缩进也由开源的SourceKit引擎提供支持，已经得到了显著的改进。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/e5562021ee0a12fe0b1076e2900a0170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k1WG8ulfo771bg1E.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/22833caae2f61e86d13cf063c1b435bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*huL3BMg-hYN4JQNF.png"/></div></div></figure><p id="68e4" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在这里，您可以看到来自开源MovieSwiftUI项目的SwiftUI代码中的一项改进。之前你有时会得到一些链式访问的自然缩进。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/20630b5bd1e1203004c1b1ea5d96d5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6eJWlndddNGmB8Pf.png"/></div></div></figure><p id="9284" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">但是现在，它们在视觉上完全对齐了。这些和其他改进将对您的编辑体验产生显著影响。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="7452" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">排除故障</h1><h2 id="e67d" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">针对运行时故障的更好的错误消息</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/60aa50ffc2572d05d2761d8bea351644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1VqbrASUS0OxU_al.png"/></div></div></figure><p id="00fc" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">当调试信息可用时，调试器现在将显示常见Swift运行时故障陷阱的原因，而不只是显示不透明的无效指令崩溃。</p><h2 id="76cb" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">增强了调试的健壮性</h2><p id="8074" class="pw-post-body-paragraph lr ls iq lt b lu nb jr lw lx nc ju lz ma nd mc md me ne mg mh mi nf mk ml mm ij bi translated"><strong class="lt ir">使用模块进行调试的利弊</strong></p><ul class=""><li id="1571" class="oc od iq lt b lu lv lx ly ma oe me of mi og mm oh oi oj ok bi translated">LLDB使用Clangemodules来解析类型</li><li id="f44a" class="oc od iq lt b lu ol lx om ma on me oo mi op mm oh oi oj ok bi translated">LLDB可能会遇到与编译时不同的模块故障</li></ul><p id="cc7a" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">Swift使用Clang模块从Objective-C导入API。为了解析关于类型和变量的信息，LLDB需要导入在当前调试上下文中可见的所有Swift和Clang模块。</p><p id="cbd9" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">虽然这些模块文件有大量关于类型的信息，但由于LLDB有整个程序及其所有动态库的全局视图，导入Clang模块有时会以编译时不会出现的方式失败——例如，当来自不同动态库的搜索过程发生冲突时。</p><h2 id="14a7" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated"><em class="nn">使用Swift中Objective-C类型的DWARF调试信息</em></h2><ul class=""><li id="7282" class="oc od iq lt b lu nb lx nc ma oq me or mi os mm oh oi oj ok bi translated">LLDB现在可以使用调试信息解析Swift中的Objective-C类型</li><li id="d7d0" class="oc od iq lt b lu ol lx om ma on me oo mi op mm oh oi oj ok bi translated">增加核心调试功能的可靠性，如Xcode的变量视图</li></ul><p id="73ff" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">作为后备，当这种情况发生时，LLDB现在还可以从DWARF调试信息中导入C和Objective-C类型，以便快速调试。这极大地提高了Xcode变量视图和表达式计算器等功能的可靠性。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="f6a4" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">官方Swift平台支持</h1><ul class=""><li id="629e" class="oc od iq lt b lu nb lx nc ma oq me or mi os mm oh oi oj ok bi translated">苹果平台</li><li id="5768" class="oc od iq lt b lu ol lx om ma on me oo mi op mm oh oi oj ok bi translated">Ubuntu 16.04，18.04，20.04</li><li id="53db" class="oc od iq lt b lu ol lx om ma on me oo mi op mm oh oi oj ok bi translated">CentOS 8</li><li id="0a2b" class="oc od iq lt b lu ol lx om ma on me oo mi op mm oh oi oj ok bi translated">亚马逊Linux 2</li><li id="7bd3" class="oc od iq lt b lu ol lx om ma on me oo mi op mm oh oi oj ok bi translated">Windows(即将推出！)</li></ul><p id="6588" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">随着这些努力，在更多地方使用Swift的机会越来越多。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="7982" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">AWS Lambda上的Swift</h1><p id="c874" class="pw-post-body-paragraph lr ls iq lt b lu nb jr lw lx nc ju lz ma nd mc md me ne mg mh mi nf mk ml mm ij bi translated">无服务器功能是客户端应用程序开发人员将其应用程序扩展到云中的一种简单方式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/3b43b14d17bde267529530e4c9b52754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WHstTo3VHewXYrBv.png"/></div></div></figure><p id="8835" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">现在在Swift中使用开源的Swift AWS运行时很容易做到这一点。</p><pre class="kg kh ki kj gt ou nl ov ow aw ox bi"><span id="e22b" class="mp kz iq nl b gy oy oz l pa pb">import AWSLambdaRuntime</span><span id="b0ef" class="mp kz iq nl b gy pc oz l pa pb">Lambda.run { (_, evnet: String, callback) in<br/>	callback(.success("Hello, \(event)"))<br/>}</span></pre><p id="26c8" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">所需的代码量就像写“Hello，World！”</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="faeb" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">语言和图书馆</h1><h2 id="a430" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">语言</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/57478da115620feb134550c31cb4db30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uvSO5oW8cXLXVwal.png"/></div></div><p class="pe pf gj gh gi pg ph bd b be z dk translated"><a class="ae pi" href="http://apple.github.io/swift-evolution" rel="noopener ugc nofollow" target="_blank">迅捷进化</a></p></figure><h2 id="7b2c" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">多重结尾结束语法(SE-0279)</h2><pre class="kg kh ki kj gt ou nl ov ow aw ox bi"><span id="b591" class="mp kz iq nl b gy oy oz l pa pb">// Multiple trailing closure syntax</span><span id="e87a" class="mp kz iq nl b gy pc oz l pa pb">UIView.animate(withDuration: 0.3, animations: {<br/>	self.view.alpha = 0<br/>})</span><span id="d87f" class="mp kz iq nl b gy pc oz l pa pb">⬇️⬇️⬇️</span><span id="cb07" class="mp kz iq nl b gy pc oz l pa pb">UIView.animate(withDuration: 0.3) {<br/>	self.view.alpha = 0<br/>}</span></pre><p id="6591" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">从一开始，Swift就支持所谓的尾随闭包语法，当它是一个闭包时，它允许您将方法的最后一个参数弹出括号。</p><p id="6a91" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">它可以更简洁，嵌套更少，但又不失清晰，使得调用点更容易阅读。</p><p id="b117" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">然而，尾随闭包语法仅限于最终闭包的限制限制了它的适用性。</p><pre class="kg kh ki kj gt ou nl ov ow aw ox bi"><span id="6360" class="mp kz iq nl b gy oy oz l pa pb">UIView.animate(withDuration: 0.3, animations: {<br/>	self.view.alpha = 0<br/>}) { _ in<br/>	self.view.removeFromSuperview()<br/>}</span></pre><p id="cc86" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在这种情况下，尾随闭包使得代码更难阅读，因为它的作用不明确。更糟糕的是，它将一个调用点的完成块的含义变成了另一个调用点的动画块。</p><p id="bb3b" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">对调用点混淆的担忧导致Swift风格指南禁止在一个方法调用(比如这个)有多个闭包参数时使用尾随闭包语法。</p><pre class="kg kh ki kj gt ou nl ov ow aw ox bi"><span id="8d4d" class="mp kz iq nl b gy oy oz l pa pb">UIView.animate(withDuration: 0.3, animations: {<br/>	self.view.alpha = 0<br/>}, completion: { _ in<br/>	self.view.removeFromSuperview()<br/>})</span><span id="197c" class="mp kz iq nl b gy pc oz l pa pb">UIView.animate(withDuration: 0.3) {<br/>	self.view.alpha = 0<br/>}<br/>⬇️<br/>UIView.animate(withDuration: 0.3, animations: {<br/>	self.view.alpha = 0<br/>}) { _ in<br/>	self.view.removeFromSuperview()<br/>}</span></pre><p id="c52d" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">因此，如果我们需要添加一个额外的闭包参数，我们中的许多人会发现自己不得不重新调整代码，这似乎是不必要的。</p><p id="e5f4" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated"><strong class="lt ir"> SE-0281 </strong></p><pre class="kg kh ki kj gt ou nl ov ow aw ox bi"><span id="c44d" class="mp kz iq nl b gy oy oz l pa pb">UIView.animate(withDuration: 0.3) {<br/>	self.view.alpha = 0<br/>}<br/>⬇️<br/>UIView.animate(withDuration: 0.3) {<br/>	self.view.alpha = 0<br/>} completion: { _ in<br/>	self.view.removeFromSuperview()<br/>}</span></pre><p id="e348" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">Swift 5.3的新增功能是多结尾闭包语法。这将尾随闭包语法的好处扩展到了具有多个闭包参数的调用，并且不需要重新配置来追加一个闭包参数。</p><p id="af39" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">多结尾闭包语法也非常适合DSL。SwiftUI的新<code class="fe ni nj nk nl b">Gauge</code>视图用于指示某个值相对于某个整体容量的级别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/655163f63794b3d35812c00de193d812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oFtqhw4yAVgMHVZ9.png"/></div></div></figure><p id="9a87" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">通过利用多结尾闭包语法，<code class="fe ni nj nk nl b">Gauge</code>能够优雅地、渐进地揭示is定制点。</p><p id="9488" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated"><strong class="lt ir"> API设计:尾随闭包语法</strong></p><pre class="kg kh ki kj gt ou nl ov ow aw ox bi"><span id="fe3e" class="mp kz iq nl b gy oy oz l pa pb">// API design : trailing closure syntax</span><span id="83a0" class="mp kz iq nl b gy pc oz l pa pb">extension Collection {<br/>	func prefix(while predicate: (Element) -&gt; Bool) -&gt; SubSequence<br/>}</span><span id="403c" class="mp kz iq nl b gy pc oz l pa pb">message.body = "Hello WWDC!\n--Kyle"<br/>let summary = message.body.prefix { !$0.isNewline }<br/>assert(summary, "Hello WWDC!"</span></pre><p id="3cb7" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">对于<em class="mo"> take </em>来说，一个更好的名字可能是类似于<em class="mo"> prefix，</em>的东西，这表明结果被锚定到集合的开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/d94a98aa7affe02790116b842fb28991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AFYSbrm09PQolWMd.png"/></div></div></figure><p id="f04e" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">重要的是，方法的基本名称阐明了第一个结尾闭包的作用，因为它的标签将被删除，即使它不是方法的第一个参数。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="27f0" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">作为函数的关键路径表达式(SE-0249)</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/b6c45eee9273e8075fc73ce6fa7be6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DSs2YVQ9Io_Va4Xc.png"/></div></div></figure><p id="2d7b" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">Swift 4.1引入了智能<code class="fe ni nj nk nl b">KeyPath</code>:类型表示对属性的未调用引用，可用于获取和设置它们的底层值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/31273cc0f90452e7b881288aacb12c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zc8NNM4b_vQP2Yl3.png"/></div></div></figure><p id="e76b" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi">⬇️</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/d6860e61fa18f9ef9d19a690c93af48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*98kXJZ2VDUQrPIyR.png"/></div></div></figure><p id="cee2" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">当你设计一个API时，如果你希望调用点是一个简单的属性访问，那么<code class="fe ni nj nk nl b">KeyPath</code>是一个很有吸引力的函数参数的替代品，因为它们更简洁，嵌套更少。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/6cad57fa7a9e400944d11cd6b3cc2385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NoforG3R_PBOAr47.png"/></div></div></figure><p id="cbe0" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi">⬇️</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/786a2e8b0063e1e38f16ba40813adc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_Ls9uusFkodPQir-.png"/></div></div></figure><p id="0194" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">你可以使用一个<code class="fe ni nj nk nl b">KeyPath</code>表达式作为函数。这意味着您可以将一个<code class="fe ni nj nk nl b">KeyPath</code>参数传递给任何具有匹配签名的函数参数，并且您可以删除过去为了接受<code class="fe ni nj nk nl b">KeyPath</code>而添加的任何重复声明。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="b56d" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">@main (SE-0281)</h1><p id="ce7d" class="pw-post-body-paragraph lr ls iq lt b lu nb jr lw lx nc ju lz ma nd mc md me ne mg mh mi nf mk ml mm ij bi translated">基于类型的程序入口点工具。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/9ced2bd78e4e60b84bce6e1440f20619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Mq15oEjKpvTGukoo.png"/></div></div></figure><p id="703a" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">从Swift 1.0开始，你可以在你的应用委托上使用<code class="fe ni nj nk nl b">UIApplicationMain</code>属性来告诉编译器生成一个运行你的应用的隐式<code class="fe ni nj nk nl b">main.swift</code>。</p><p id="d27e" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Swift 5.3中，这一功能已经普遍化和民主化。</p><p id="a991" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">如果你是一个库的作者，只需要在你希望你的用户从其获得入口点的协议或超类上声明一个静态的main方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/3b00d36e77fb6d0cc8d575e409fdbeb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a7PS23ewdhRdpWqE.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/fe542281a70fc3e677ef4265e1a268ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ERzyxKdTu6t5ay9W.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/cacfc1c7c3fb6c5bb5c0006e86643d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XvaE8jVfedcOOvaj.png"/></div></div></figure><p id="69c9" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">这将使您的用户能够用<code class="fe ni nj nk nl b">@main</code>标记该类型，并且编译器能够代表他们生成一个隐式的<code class="fe ni nj nk nl b">main.swift</code>。</p><p id="c665" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">这种标准化的委托程序入口点的方式应该使启动和运行变得更加容易，无论您是使用命令行工具还是现有的应用程序。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="f028" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">提高闭包中隐含“自我”的可用性(SE-0269)</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/8dadf2c72cf2784cd0cfe8233d088ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uGz6H5MSeHY37g33.png"/></div></div></figure><p id="c39c" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">为了减少对潜在保留周期的关注，Swift要求在转义捕获它的闭包时显式使用<code class="fe ni nj nk nl b">self</code>。</p><p id="1eab" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">但是当你被要求在一行中包含许多<code class="fe ni nj nk nl b">self</code>点时，就会开始觉得有点多余。</p><p id="d5b3" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Swift 5.3中，如果您在捕获列表中包含了<code class="fe ni nj nk nl b">self</code>，那么您可以在闭包的主体中省略它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/a51d1f80fecda056bbdca2a3ca8ac5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AOQUOYAfM93bgPlc.png"/></div></div></figure><p id="add0" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">你仍然需要明确表达你捕捉自我的意图。但是现在，这种明确性的代价只是一个声明。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/1100ec706ac23aa6706274e73d22f52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8k9Zvcg_5eVGLgFC.png"/></div></div></figure><p id="a227" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">然而，有时甚至是单次使用<code class="fe ni nj nk nl b">self</code>。可能觉得没有必要——就像在SwiftUI中,<code class="fe ni nj nk nl b">self</code>倾向于成为值类型，使得引用循环的可能性大大降低。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/a22900ae97f1b4679d4a1a62ec8791e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WIMQCrEoXvoDzu8b.png"/></div></div></figure><p id="45df" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Swift 5.3中，如果<code class="fe ni nj nk nl b">self</code>是一个struct或enum，你可以在闭包中完全省略它。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="6a05" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">多模式捕获子句(SE-0276)</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/653684ac913ebfbb12c5d69837d3f600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kkOzmYv6_VGo1XNz.png"/></div></div></figure><p id="169f" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">从历史上看，<code class="fe ni nj nk nl b">do</code> catch语句没有<code class="fe ni nj nk nl b">switch</code>语句表达能力强，导致人们求助于<code class="fe ni nj nk nl b">catch</code>子句中的嵌套开关。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/7575ace0b588145116bedbf24c8e3d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vfH1-DphSNs0Ck-Z.png"/></div></div></figure><p id="1ee2" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Swift 5.3中，<code class="fe ni nj nk nl b">catch</code>子句的语法得到了扩展，提供了<code class="fe ni nj nk nl b">switch</code>案例的全部功能。这允许您将多克劳斯模式匹配的类型直接展平到<code class="fe ni nj nk nl b">do</code> <code class="fe ni nj nk nl b">catch</code>语句中，使其更易于阅读。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="85ab" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">枚举增强</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/375e4a29488ef39b6ef54f818c85110f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J75v82MAKH-zs5pO.png"/></div></div></figure><p id="9a9a" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">自Swift 4.1以来，编译器已经能够为各种类型合成等价的和散列的一致性。</p><p id="7a6c" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">但是，有时候，您会遇到使用比较运算符非常方便的情况。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/f0dd374b2304718eea0463839f9406ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CJQzAKI9ADiWVlsL.png"/></div></div></figure><p id="87e2" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Swift 5.3中，编译器已经学会了如何为合格的枚举类型合成可比较的一致性。</p><h2 id="77c9" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">将病例枚举为方案见证</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/22c56bc1ab6f92d9e8d80b40bafa5d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tasbaxAiOSwc7LF3.png"/></div></div></figure><p id="6763" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Swift 5.3中，enum cases现在可用于满足<code class="fe ni nj nk nl b">static var</code>和<code class="fe ni nj nk nl b">static func</code>协议要求。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="a349" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">嵌入式DSL增强功能</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/a1641cc700066829530a48a4262a6043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ri9qh9XqaYrpoEz7.png"/></div></div></figure><p id="6c61" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">这包括集体使用子元素的构建器闭包和基本的控制流语句，如<code class="fe ni nj nk nl b">if</code> / <code class="fe ni nj nk nl b">else</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/ebc441be7037438e33aea05ac20b8f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RufFF0UpfgHhfs9O.png"/></div></div></figure><p id="e810" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Swift 5.3中，嵌入式DSL已经扩展到支持模式匹配——像<code class="fe ni nj nk nl b">if let</code>和<code class="fe ni nj nk nl b">switch</code>这样的控制流语句。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/b1167354d9044fb9a173e227b243bfe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6V2Pe5m4vqsB4ota.png"/></div></div></figure><p id="dfce" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">我有一个主要用户界面的主窗口和一个应用程序设置的偏好窗口。</p><p id="0f29" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">以前，要像这样在主体的顶层使用DSL语法，需要用特定的builder属性对其进行标记。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/f8a436ca23b80a9c75517ef567248f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CPneBfl-xfeq6phy.png"/></div></div></figure><p id="b74e" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">在Swift 5.3中，将不再需要builder属性，因为我们正在教编译器如何从协议要求中推断出它。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="0410" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">软件开发工具包(Software Development Kit)</h1><h2 id="010b" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">浮动16</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/9858e670df965add66875e351a5e9700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l7xwfot6RR8O8iJb.png"/></div></div></figure><p id="7b94" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">Float16是IEEE 754标准浮点格式。Float16只占用两个字节的内存，而单精度Float需要四个字节。</p><h2 id="0ed7" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">苹果档案</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/ea5ca006efcc6370f86a75f3a7148c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C8n5HDHpZ7LXa2eJ.png"/></div></div></figure><p id="ae1f" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">一种新的模块化存档格式基于苹果用于提供操作系统更新的久经考验的技术。</p><h2 id="bf8a" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">惯用的Swift API</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/4aaefd54735b396e4b6f089c056ce397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pgY6aknsIbNd2MxF.png"/></div></div></figure><p id="9fcd" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">这包括一个FileStream构造函数，它利用了另一个新库<a class="ae pi" href="https://developer.apple.com/documentation/swift_packages/target/3197895-systemlibrary" rel="noopener ugc nofollow" target="_blank"> Swift System </a>。</p><h2 id="e9e1" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">Swift系统</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/d4b01033f63bfe8b7790066f7fa14b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xMa3kfNM883Guv_v.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/26324ec578ac9740360d30f2116904da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NKblJYSuL_f3YW5P.png"/></div></div></figure><p id="014d" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">通过Darwin overlay导入的原始弱类型接口可能很挑剔，容易出错。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/ea724e7ccfaa95fc3590121fc9f0f76f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mJiyAenuTRIrN7MJ.png"/></div></div></figure><p id="4953" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">Swift System使用强类型<code class="fe ni nj nk nl b">RawRepresentable</code>结构、错误处理、默认参数、名称空间和函数重载等技术包装这些API，为SDK的更惯用的Swift系统层奠定了基础。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="374e" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">OSLog</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/11eadf8d60786d30aeb9498329123127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lGu1GX--GITw0E_G.png"/></div></div></figure><p id="d84f" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">如果您仍然使用<code class="fe ni nj nk nl b">print</code>作为您的日志解决方案，现在是重新考虑的最佳时机。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="366d" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">包装</h1><h2 id="ae3a" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">快速数字</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/16d6f05fda682fefd61eed7837b2e903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nD5SjWLBbG7vcFDB.png"/></div></div></figure><p id="f132" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">Swift Numerics的复数与C语言的复数在布局上是兼容的，但是更快更准确。</p><h2 id="47c2" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">Swift参数解析器</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/abbc1a1e336c74a72fb9257a98967af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8IgKb4VlQtOHvbfE.png"/></div></div></figure><p id="e997" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">一个新的用于命令行参数解析的开源Swift包。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/b3a878d33f3b0150fb128a4fb319fd2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*94UjnZVMEpFPpLzB.png"/></div></div></figure><h2 id="bec0" class="mp kz iq bd la mq mr dn le ms mt dp li ma mu mv lk me mw mx lm mi my mz lo na bi translated">Swift标准库预览</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/ebbb3e301dfef416c0803418310d70fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wo8pLvBq9omInjO9.png"/></div></div></figure><p id="fcb5" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">现在，您可以将<code class="fe ni nj nk nl b">StandardLibrary </code>特性提案的实现作为一个独立的<code class="fe ni nj nk nl b">SwiftPM</code>包来提供。</p></div></div>    
</body>
</html>