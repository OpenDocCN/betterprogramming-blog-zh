<html>
<head>
<title>Better Unit Testing — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的单元测试—第1部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/better-unit-testing-part-1-aeac3c1aea77?source=collection_archive---------9-----------------------#2019-11-28">https://betterprogramming.pub/better-unit-testing-part-1-aeac3c1aea77?source=collection_archive---------9-----------------------#2019-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ae8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在没有任何单元测试知识的情况下阅读这篇文章？那就更好了，我们开始吧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c762a92ce415bd5f404bfb054c597283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiM2Sgb9SeDA-d9S6oGevQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@stanleydai?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">史丹利戴</a>在<a class="ae ky" href="https://unsplash.com/s/photos/project?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="02ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多项目，尤其是Android项目，没有单元测试。嗯，即使是Android开发之初的官方文档也不鼓励/不支持单元测试。如果没有单元测试，我们开发人员不会关心是否有正确的单元测试。</p><p id="55eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多有单元测试的项目大多是在产品代码编写完成后编写的，开发人员被要求按照一些“策略”编写单元测试。</p><p id="e73e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是糟糕的测试案例，没有给任何人对整个平台的完整性的信心。</p><p id="255e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有单元测试比有糟糕的单元测试要好。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e2a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单元测试是什么意思？</h1><p id="aed1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个单元是一个特定功能的容器，它有明确定义的边界，在Android中，可以被包装在一个<code class="fe mz na nb nc b">Class</code>中。</p><p id="3efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试意味着确保某些东西完美地工作。在单元测试中，我们可以说我们确保了我们的类做了它应该做的事情。</p><p id="a743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试确保被测系统按照需求运行。</p><p id="ea44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JUnit是一个流行的框架，我们用它来编写单元测试来测试我们的产品代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8e8d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何编写更好的单元测试</h1><p id="1dc5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通常，我们会看到我们必须编写其单元测试的类，转到所需的方法。看它是怎么写的，了解一些高层逻辑，然后开始写它的单元测试。这是一个大禁忌。</p><p id="2fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到需求，然后编写单元测试来满足这些需求。如果你遵循了批判性思维，那么你应该有一个你可以参考的文档，它包含了你需要编写的所有一致同意的边缘测试用例。</p><p id="6322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您就在测试您的代码，看它是否真的很好地满足了指定的需求。</p><p id="1570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试的简单结构如下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7317" class="nh md it nc b gy ni nj l nk nl">import org.junit.Assert.*<br/>import org.junit.Before<br/>import org.junit.Test</span><span id="b8ab" class="nh md it nc b gy nm nj l nk nl">class ProductionCodeClassTest {</span><span id="7cfc" class="nh md it nc b gy nm nj l nk nl">@Before<br/>    fun setup() {<br/>        // Setup the class dependencies here<br/>        // Which are required to run a successful test<br/>    }</span><span id="6989" class="nh md it nc b gy nm nj l nk nl">@Test<br/>    fun testSomeMethod() {<br/>        // Call the required logic<br/>        // Assert the returned result<br/>    }<br/>    <br/>}</span></pre><p id="f9c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">@Before</code>告诉JVM在每个用<code class="fe mz na nb nc b">@Test</code>标注的测试函数之前运行这个特定的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2119" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何更好地命名单元测试</h1><p id="4974" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您在大型项目中工作时，您有数千个单元测试的报告，并且您得到一条消息:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0280" class="nh md it nc b gy ni nj l nk nl">Test testFunctionFinal() failed</span></pre><p id="9ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f201" class="nh md it nc b gy ni nj l nk nl">Test test_user_click_redirects_to_home() failed</span></pre><p id="3408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哪个更容易调试？</p><p id="3682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试的名称不一定要短，只要你需要写一个描述性的单元测试名称就行。一个快速提示是包括这三件事:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f1e8" class="nh md it nc b gy ni nj l nk nl">UnitOfWork_StateUnderTest_ExpectdBehavior</span></pre><p id="81c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，根据这一点，如果你想写一个反转字符串的方法的名字，它应该是:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2efb" class="nh md it nc b gy ni nj l nk nl">reverse_emptyString_emptyStringReturned</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="53c6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更好的单元测试方法</h1><p id="0a49" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一般来说，在我们写了我们满意的产品代码并且它能工作之后，我们会写单元测试。因此，只需编写一些简单的单元测试，就可以通过我们已经知道正在工作的东西。</p><p id="23fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些测试的问题在于它们并不能真正证明什么。如果它们通过了，我们并不在乎，因为我们知道我们是随便写的，因果单元测试通过并不意味着什么。如果他们失败了，是的，他们肯定能帮上忙。</p><p id="5ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案:如果我们在之前编写单元测试<em class="nn">，我们将编写实际的产品代码，当这些单元测试失败时(编译错误/运行时错误/断言错误),我们将编写一些产品代码使它们通过。</em></p><p id="387b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法被称为测试驱动开发。</p><p id="73cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是不是没有太大意义？让我们写一个简单的测试，好吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c7da" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">遵循TDD编写单元测试用例</h1><p id="fd65" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在测试驱动开发之后，我们将编写字符串反转的代码。</p><p id="4ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.创建一个名为<code class="fe mz na nb nc b">StringReverser</code>的类，一旦完成，使用自动生成选项为同一个类生成一个单元测试文件。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3fb8" class="nh md it nc b gy ni nj l nk nl">package com.sample.example</span><span id="4474" class="nh md it nc b gy nm nj l nk nl">class StringReverser {<br/>    <br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/c20130fbd69aaf359b724c3560806197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lvLlIYax2yDKNN2x-OSN2Q.png"/></div></div></figure><p id="fe2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的单元测试类:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b14b" class="nh md it nc b gy ni nj l nk nl">import org.junit.Assert.*</span><span id="6be4" class="nh md it nc b gy nm nj l nk nl">class StringReverserTest {<br/>    <br/>}</span></pre><p id="0b32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.让我们开始编写我们的第一个单元测试用例。</p><p id="8c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们现在编写产品代码来解决这个错误。</p><p id="3882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们的错误已经解决，根据TDD第二定律，我们不允许再编写任何产品代码。</p><p id="337f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.完成我们的第一个单元测试用例。</p><p id="6a2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们的测试通过了，我们可以继续编写我们的第二个单元测试。</p><p id="32d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.编写第二个单元测试用例。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4f07" class="nh md it nc b gy ni nj l nk nl">@Test<br/>fun reverse_singleCharacter_sameStringReturned() {<br/>    val result = stringReverser.reverse("x")<br/>    assertEquals("x", result)<br/>}</span></pre><p id="9b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们只是添加另一个单元测试用例，它也成功通过。让我们继续写另一个测试用例。</p><p id="21cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.编写第三个单元测试用例。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3fd7" class="nh md it nc b gy ni nj l nk nl">@Test<br/>fun reverse_multipleCharacterString_reversedMultipleCharacterStringReturned() {<br/>    val result = stringReverser.reverse("xyz")<br/>    assertEquals("zyx", result)<br/>}</span></pre><p id="a292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们没有得到编译错误，我们只是继续运行我们的单元测试用例，我们看到它失败了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/6c46cdd18ddf23d7de45c6cfd16a1385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46HltbGoD5IhGgnsCPpmkA.png"/></div></div></figure><p id="900d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们再次被允许编写产品代码，它只是通过了这个失败的单元测试用例。所以，我们继续修改<code class="fe mz na nb nc b">StringReverser</code>类。</p><p id="5822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们回到我们的单元测试并运行它们，它们都通过了。</p><p id="41eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以随意添加更多的测试，所有的测试都应该通过。</p><p id="d307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循TDD之后，我们对我们的<code class="fe mz na nb nc b">StringReverser</code>类很有信心，确信没有错误。它是生产就绪的，支持我们的<code class="fe mz na nb nc b">StringReverser</code>类的单元测试总是在那里证明<code class="fe mz na nb nc b">StringReverser</code>类。</p><p id="d2e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有人想在未来做出任何改变，他们不会害怕破坏东西，因为他们只需要运行单元测试，看看这些改变是否适用于所有的测试用例，而不是他们必须手动检查。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ad0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代码覆盖率呢？</h1><p id="7cd6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你的单元测试应该有多少代码覆盖率？70%?</p><ul class=""><li id="6ff0" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">一个简单的经验法则是:你只需要在你的单元测试中覆盖你想在生产中使用的代码模块，现在这意味着100%。我们不能让80%的模块工作，而另外20%的模块没有在生产中进行测试。因此，总是试图获得100%的代码覆盖率。</li><li id="690c" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">我们所说的100%并不意味着覆盖所有代码行。在我们的系统中可以有多种逻辑，因此，在我们的系统范围内测试所有可能的逻辑组合也在100%的代码覆盖率之下。</li><li id="d0ce" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">还可能有多个输入或输入组合进入您的系统，100%的代码覆盖率也涵盖了这一点。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a896" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="293f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经讲了基础知识，学到了很多东西。如果这个话题让你更感兴趣，这里还有一些关于这个话题的故事值得你花时间去读。</p><div class="oe of gp gr og oh"><a href="https://medium.com/softway-blog/tests-are-your-silver-bullet-for-clean-production-code-60f339183713" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">测试是你清洁生产代码的银弹</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">TDD很酷，但是要知道如何专业地编写测试用例</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://medium.com/better-programming/getting-started-with-test-driven-development-3621a828657e" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">测试驱动开发入门</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">学习用TDD构建坚如磐石的解决方案</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov ks oh"/></div></div></a></div><p id="f275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！DevDeejay</p><p id="c721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘿嘿嘿！第二部分在这里😇<br/><a class="ae ky" href="https://medium.com/better-programming/better-unit-testing-part-2-80d29fc0f4b3" rel="noopener">https://medium . com/better-programming/better-unit-testing-part-2-80d 29 fc 0 F4 b 3</a></p></div></div>    
</body>
</html>