<html>
<head>
<title>Light DOM and Lightning Web Components in Salesforce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Salesforce中的Light DOM和Lightning Web组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/light-dom-and-lightning-web-components-in-salesforce-ce03b2103c7c?source=collection_archive---------10-----------------------#2022-12-14">https://betterprogramming.pub/light-dom-and-lightning-web-components-in-salesforce-ce03b2103c7c?source=collection_archive---------10-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="950c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些奇妙功能的简要指南</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/60c5ab89e000869b7247af5f433f1588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tbj0kEtMFRheoODo"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">马克斯·萨林在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d68e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来自Salesforce的<a class="ae le" href="https://lwc.dev/" rel="noopener ugc nofollow" target="_blank"> Lightning Web组件</a> (LWC)基于使用HTML和JavaScript构建的标准<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>。它们是轻量级的，易于构建，并且在现代浏览器中运行良好。当构建LWC时，您将熟悉<a class="ae le" href="https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.create_components_compose_intro" rel="noopener ugc nofollow" target="_blank">组合</a>的概念，它允许您在更复杂的组件主体内拼凑简单的构建块组件。</p><p id="0601" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于组合，LWC利用了<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">影子文档对象模型</a> (DOM) web标准，该标准封装了web组件的内部结构，使得组件外部的代码和组件无法访问它。这种方法的替代方法是<a class="ae le" href="https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.create_light_dom" rel="noopener ugc nofollow" target="_blank"> Light DOM </a>，Salesforce在测试版中提供了这种方法。</p><p id="5570" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将探讨Salesforce开发中的轻型DOM概念。我们将从DOM概念的概述开始，然后是阴影DOM和光DOM之间的区别。最后，我们将看看这在LWC是如何进行的，以及如何在LWC实现Light DOM。</p><h1 id="4229" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是DOM？</h1><p id="6633" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">根据<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank"> MDN </a>的定义，DOM是<em class="mi">“组成web上文档的结构和内容的对象的数据表示</em>”这意味着:DOM提供了一种在树状结构中将网页表示为节点和对象的方法。这使得开发人员更容易根据需要操作和构建任何逻辑。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/6f3de9626d9befa033f903d31c7740c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/0*IxtALRmgbMCwiC56.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://www.w3schools.com/whatis/whatis_htmldom.asp" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><p id="11f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值得注意的是，DOM独立于任何编程语言。使用任何语言或框架构建的web应用程序通常会以某种方式提供对DOM及其组件的访问。</p><h1 id="4c30" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">影子王国</h1><p id="0c3b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">也许您遇到过“影子DOM”，它是DOM的一个扩展，允许隐藏的DOM树作为元素附加到常规DOM树中。MDN使用这个图形来表示阴影DOM:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mk"><img src="../Images/05ef3323e1c7ef6555c906ec455c763d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uBAzM8mv-Anqso7C.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">图片来源</a></p></figure><p id="5c42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">影子DOM旨在为DOM中的单个组件提供封装，保持该组件的标记结构、样式和行为是隐藏的，并与页面上的其他代码分开。开发人员可以将该组件作为一个完整的DOM树(“影子树”)来共享，确保没有外部代码可以操纵该树。这有助于保持代码的良好分离，避免冲突。</p><h1 id="453c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">光明世界对阴影世界</h1><p id="49c2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">术语“光DOM”只是普通或常规DOM的另一个名称，以区别于阴影DOM。“阴影边界”将光域和阴影域分开。LWC，就像任何Web组件一样，在每个组件上强制执行<a class="ae le" href="https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.create_dom" rel="noopener ugc nofollow" target="_blank">影子DOM </a>。通过使用<a class="ae le" href="https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.create_light_dom" rel="noopener ugc nofollow" target="_blank"> Light DOM </a>方法，该方法目前是beta服务中的一项功能，通常仅适用于Salesforce Experience Builder站点，组件被附加到主机元素而不是其影像树。</p><p id="7029" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们更详细地看看这意味着什么。</p><h1 id="e24f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">LWC的影子王国</h1><p id="9091" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">因为阴影DOM web标准并未在Salesforce支持的所有浏览器中实现，所以LWC使用了一个名为合成阴影DOM的阴影DOM聚合填充。以下标记显示了一个影像树结构示例:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="9b14" class="mq lg it mm b gy mr ms l mt mu">&lt;c-my-app&gt;<br/>  #shadow-root<br/>    &lt;div&gt;<br/>        &lt;p&gt;My Tasks&lt;/p&gt;<br/>    &lt;/div&gt;<br/>    &lt;c-my-item&gt;<br/>      #shadow-root<br/>        &lt;div&gt;<br/>            &lt;p&gt;Item 1&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    &lt;/c-my-item&gt;<br/>&lt;/c-my-app&gt;</span></pre><p id="148b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">影子DOM阻止我们通过使用对<code class="fe mv mw mx mm b">document</code>或<code class="fe mv mw mx mm b">document.body</code>的引用来提取DOM元素。相反，LWC组件需要通过使用<code class="fe mv mw mx mm b">this.template.querySelector()</code>来访问树。</p><p id="ac6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CSS也受到影子DOM封装的影响。组件外部的样式只能影响组件的顶层，而不能影响父级、子级或同级CSS。</p><p id="2d94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LWC架构利用Lightning Locker服务来实施DOM访问控制。组件通过使用名称空间相互隔离，每个组件只能遍历其DOM并访问同一名称空间中的元素。这是一个重大的(尽管是有意的)限制，使得组件无法被编程代码访问。这种方法可以防止脚本注入和样式泄漏。轻量级DOM允许开发人员规避这种安全限制。</p><h1 id="a62c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">LWC的光明王国</h1><p id="9c2b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了解除影子DOM带来的DOM访问限制，Salesforce在LWC引入了使用光DOM的概念。尽管该特性目前还处于测试阶段，但它是for DOM操作的发展方向。</p><p id="4cdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想法是这样的:因为LWC驻留在影子DOM之外，所以影子DOM的任何限制都不适用于该组件。</p><p id="1ffd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是阴影和光照对LWC影响的简单比较。</p><p id="e70d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">亮DOM与阴影DOM的特征</p><ul class=""><li id="3c1d" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nd ne nf ng bi translated">带有主样式表的全局CSS主题。</li><li id="4d5e" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">全力支持与不支持。</li><li id="5015" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">CSS是在组件级别定义的，不会级联。</li></ul><p id="38f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三方工具</p><ul class=""><li id="7072" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nd ne nf ng bi translated">对DOM遍历的完全支持和有限支持，因为第三方工具只能访问它们的父组件。</li><li id="56b5" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">编程DOM访问。</li><li id="a4f9" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">不受名称空间限制与受名称空间限制。</li><li id="8155" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">便携性。便携式，但会导致重大变化，而便携式则具有安全访问功能。</li><li id="fc98" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">高度可定制的用户界面。合适与不合适</li></ul><h1 id="6cd3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">LWC的光DOM:一个例子</h1><p id="e6ba" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们看一个简单的例子，看看Light DOM如何与LWC组件一起工作。这个简单的MyApp LWC模板指令默认使用影子DOM。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="990c" class="mq lg it mm b gy mr ms l mt mu">&lt;template&gt;<br/>    &lt;my-header&gt;<br/>        &lt;p&gt;My Tasks&lt;/p&gt;<br/>    &lt;/my-header&gt;<br/>&lt;/template&gt;</span></pre><p id="e52b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要启用light DOM，我们需要如下设置<code class="fe mv mw mx mm b">renderMode</code>属性:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="2147" class="mq lg it mm b gy mr ms l mt mu">import { LightningElement } from 'lwc';</span><span id="3336" class="mq lg it mm b gy nm ms l mt mu">export default class MyApp extends LightningElement {<br/>    static renderMode = 'light';<br/>}</span></pre><p id="f127" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们更改模板指令，使用光线DOM代替阴影DOM:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="3bea" class="mq lg it mm b gy mr ms l mt mu">&lt;template lwc:render-mode='light'&gt;<br/>    &lt;my-header&gt;<br/>        &lt;p&gt;My Tasks&lt;/p&gt;<br/>    &lt;/my-header&gt;<br/>&lt;/template&gt;</span></pre><h1 id="a709" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在LWC使用Light DOM访问元素</h1><p id="afb3" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">可以使用<code class="fe mv mw mx mm b">document.querySelector()</code>方法在Light DOM中访问元素。这是开发人员根据需要访问和操作元素的一种强大方式。</p><p id="e611" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Light DOM中，我们会使用<code class="fe mv mw mx mm b">this.querySelector</code>。在Shadow DOM中，我们需要使用<code class="fe mv mw mx mm b">this.template.QuerySelector</code>。</p><h1 id="ce64" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在LWC使用光DOM的事件传播</h1><p id="6e51" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">关于事件传播，Light DOM对开发人员来说是一个很大的提升。阴影DOM重定向任何跨越阴影边界的事件。在Light DOM中没有这样的事件重定向，开发人员很容易识别触发事件的确切UI元素，而不是获得对底层组件的引用。</p><h1 id="569b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在LWC使用Light DOM的指南</h1><p id="94c1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Salesforce为使用Light DOM的开发者提供了指南和限制，你可以在这里找到<a class="ae le" href="https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.create_light_dom" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="3e7e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="2cc9" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">LWC为制作复杂的web组件提供了一种简单而强大的方法。到目前为止，虽然Salesforce已经使用了LWC的影子DOM标准进行封装和安全访问，但是开发人员可能会遇到许多适合使用轻量DOM方法的场景。有了现在测试版中提供的Light DOM，Salesforce开发人员可以基于他们的用例为自己选择。</p></div></div>    
</body>
</html>