<html>
<head>
<title>Scale GitHub Workflows With AWS ECS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS ECS扩展GitHub工作流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scale-github-workflows-with-aws-ecs-e7e2854ac100?source=collection_archive---------5-----------------------#2022-05-31">https://betterprogramming.pub/scale-github-workflows-with-aws-ecs-e7e2854ac100?source=collection_archive---------5-----------------------#2022-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="01c7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用没有访问键、复杂lambda函数或Kubernetes集群的自托管运行器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d19b64b531aa95415fba9d8af5f4aa15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SU-eCQayUS-F6evGYqD8jg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于GitHub工作流的ECS上的GitHub自托管运行程序基础架构的架构</p></figure><p id="5c42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>允许CI/CD管道的自动化，以自动化构建和部署。它提供了在<a class="ae lr" href="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners" rel="noopener ugc nofollow" target="_blank"> GitHub托管的虚拟机</a>或<a class="ae lr" href="https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners" rel="noopener ugc nofollow" target="_blank">自托管运行程序</a>上运行流水线操作的能力。</p><p id="cac6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用自托管运行器允许组织实施一些安全控制，如控制代码溢出和构建工件，并且它使用在云中执行操作所需的最低权限的服务角色(AWS ),而不是使用访问密钥(访问密钥具有安全存储和轮换的额外负担)。</p><p id="ef87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GitHub已经发布了<a class="ae lr" href="https://docs.github.com/en/actions/hosting-your-own-runners/autoscaling-with-self-hosted-runners#recommended-autoscaling-solutions" rel="noopener ugc nofollow" target="_blank">两个推荐的自动伸缩</a>方法，它们使用Kubernetes集群和AWS lambda函数与webhook集成来为GitHub自托管运行程序扩展构建基础设施。</p><p id="5fa9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文将介绍一种替代机制，它使用一种更简单的方法，使用相对较新的功能<a class="ae lr" href="https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services" rel="noopener ugc nofollow" target="_blank">OpenID</a>AWS和GitHub之间基于连接的集成，以及<a class="ae lr" href="https://jonico.github.io/awesome-runners/" rel="noopener ugc nofollow" target="_blank"> GitHub自托管运行器</a>容器，这些容器被配置为ECS上的任务，以按需启动短暂的运行器。</p><p id="f1cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该方法使用自由层AWS EC2实例作为ECS容器，但可以很容易地扩展到使用Fargate(或spot)实例来运行容器，以优化成本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d19b64b531aa95415fba9d8af5f4aa15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SU-eCQayUS-F6evGYqD8jg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitHub工作流的自托管runner基础设施架构</p></figure><h1 id="87d5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">GitHub工作流程</h1><p id="2f5e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">下面的示例GitHub工作流文件显示了一个包含两个步骤的工作流:第一步，在ECS上启动GitHub runner容器；第二步，在新启动的runner上构建代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/644437ad6b225932084bf033fe991f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJb5RNXXJVEo0_Cs_AMtlA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitHub工作流的输出，它激活自托管的运行器并在运行器上构建代码</p></figure><p id="68a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相应的工作流程在<a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/.github/workflows/infra-aws-core.yml" rel="noopener ugc nofollow" target="_blank">这里</a>可用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d49b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们浏览代码，了解如何使用ECS任务激活GitHub自托管runner:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="d5d2" class="mx lt iq mt b gy my mz l na nb">name: infra-aws-core<br/>on:<br/>  workflow_dispatch:<br/>    inputs:<br/>      Env:<br/>        ...<br/>      LaunchMode:<br/>        ...</span></pre><p id="e971" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上一节描述了工作流程，并指定可以用<code class="fe nc nd ne mt b">Environment</code>和<code class="fe nc nd ne mt b">LaunchMode</code>作为输入手动调用。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="bd34" class="mx lt iq mt b gy my mz l na nb">jobs:<br/>  activate-github-runner:<br/>    runs-on: ubuntu-latest<br/>    environment: ${{ github.event.inputs.Env }}<br/>    permissions:<br/>      id-token: write<br/>      contents: read<br/>    outputs:<br/>      gitrunner_vm_id: ${{ steps.runner-label.outputs.vm_id }}</span></pre><p id="35d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne mt b">activate-github-runner</code>任务负责启动GitHub自托管运行程序。它将使用最新的ubuntu实例<code class="fe nc nd ne mt b">runs-on</code> GitHub runner基础设施。<code class="fe nc nd ne mt b">environment</code>用于定义输入值:</p><ul class=""><li id="b93b" class="nf ng iq kx b ky kz lb lc le nh li ni lm nj lq nk nl nm nn bi translated"><code class="fe nc nd ne mt b">AWS-REGION</code>其中将提供GitHub自托管runner。</li><li id="de1c" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated"><code class="fe nc nd ne mt b">RUNNER_PAT</code>(个人访问令牌)，能够注册自托管跑步者(详情见下文)</li><li id="b728" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated"><code class="fe nc nd ne mt b">ROLE_TO_ASSUME</code>连接到AWS(查看<a class="ae lr" href="https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services" rel="noopener ugc nofollow" target="_blank"> OpenID连接</a>了解更多详情)</li><li id="6e96" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated">一个网络的<code class="fe nc nd ne mt b">SECURITY_GROUP</code>和<code class="fe nc nd ne mt b">SUBNET</code>，连接到一个运行在Fargate上的容器。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/0a04f640bee73c5f16b5b95b7eb769c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFyJFaJQBHL8Oxo16IQqQw.png"/></div></div></figure><p id="c48c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne mt b">permissions</code>设置提供给作业的GitHub令牌的权限。<code class="fe nc nd ne mt b">id-token: write</code>需要启用OpenID Connect登录AWS。此外，<code class="fe nc nd ne mt b">outputs</code>定义了作业的输出，该输出可被依赖于该作业的其他作业使用。这个作业输出<code class="fe nc nd ne mt b">gitrunner_vm_id</code>，它代表构建作业应该运行的GitHub自托管运行程序。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="26b7" class="mx lt iq mt b gy my mz l na nb">    steps:<br/>      - name: Configure AWS credentials<br/>        uses: aws-actions/configure-aws-credentials@master<br/>        with:<br/>          role-to-assume: ${{ secrets.ROLE_TO_ASSUME }}<br/>          aws-region: ${{ secrets.AWS_REGION }}<br/>      - name: Check identity<br/>        id: validate<br/>        run: |<br/>          aws sts get-caller-identity</span></pre><p id="133c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne mt b">Configure AWS credentials</code>是GitHub执行OpenID Connect登录到AWS的标准步骤，<code class="fe nc nd ne mt b">Check identity</code>打印呼叫者身份以供参考。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="43a2" class="mx lt iq mt b gy my mz l na nb">      - name: Generate Runner label<br/>        id: runner-label<br/>        run: |<br/>          task_vm_id=$(uuidgen)<br/>          echo "::set-output name=vm_id::$task_vm_id"<br/>          echo "VM ID generated $task_vm_id"</span></pre><p id="d2e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一步生成一个标签来惟一地标识将用于运行构建的GitHub runner实例。它使用一种简单的方法，即使用<code class="fe nc nd ne mt b">uuidgen</code>命令来生成一个标签。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8500" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据<code class="fe nc nd ne mt b">LaunchMode</code>是EC2还是Fargate，设置<code class="fe nc nd ne mt b">NET_CONFIG</code>和<code class="fe nc nd ne mt b">TASK_DEF_NAME</code>。Fargate需要<code class="fe nc nd ne mt b">NET_CONFIG</code>,因为一个显式的ENI附加在容器上，用于连接GitHub基础设施(以及其他操作)所需的互联网连接。EC2和Fargate的任务定义主要在网络模式上不同，分别具有<a class="ae lr" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking-bridge.html" rel="noopener ugc nofollow" target="_blank">桥</a>和<a class="ae lr" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking-awsvpc.html" rel="noopener ugc nofollow" target="_blank"> awsvpc </a>的值。有关此主题的其他注意事项，请参见以下内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4001" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此步骤使用上一步中确定的任务定义运行任务。它将<code class="fe nc nd ne mt b">RUNNER_NAME</code>、<code class="fe nc nd ne mt b">GITHUB_PAT</code>和<code class="fe nc nd ne mt b">RUNNER_LABELS</code>传递给容器，以便入口点脚本可以使用它来配置GitHub自托管runner容器。有关该图像的更多详细信息，请参见以下内容。</p><p id="4cda" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该作业完成后，自托管运行程序任务已经启动，下一个要运行的作业是<code class="fe nc nd ne mt b">build-code</code>，可以根据需要进行定制。以下示例显示了打印工作目录的<code class="fe nc nd ne mt b">build-code</code>作业。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="848c" class="mx lt iq mt b gy my mz l na nb">build-code:<br/>    needs: [activate-github-runner]<br/>    runs-on: [self-hosted, "${{ needs.activate-github-runner.outputs.gitrunner_vm_id }}"]<br/>    permissions:<br/>      id-token: write<br/>      contents: read<br/>    steps:<br/>      - name: Testing build<br/>        run: |<br/>          MY_WD=$(pwd)<br/>          echo "Hello world ${MY_WD}"</span></pre><p id="e494" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne mt b">needs</code>设置对<code class="fe nc nd ne mt b">activate-github-runner</code>的依赖，以确保自托管运行程序在该作业运行之前启动。<code class="fe nc nd ne mt b">runs-on</code>明确指出该作业应该在带有标签<code class="fe nc nd ne mt b">self-hosted</code>和生成的<code class="fe nc nd ne mt b">gitrunner_vm_id</code>的转轮上运行。通过<code class="fe nc nd ne mt b">runs-on</code>,我们能够将构建过程与我们在之前的工作中开始的容器绑定在一起。</p><p id="26bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个实现中，因为我们已经将自托管运行器标记为<code class="fe nc nd ne mt b"><a class="ae lr" href="https://docs.github.com/en/actions/hosting-your-own-runners/autoscaling-with-self-hosted-runners#using-ephemeral-runners-for-autoscaling" rel="noopener ugc nofollow" target="_blank">ephemeral</a></code>，所以容器将在构建工作完成后自动退出。</p><h1 id="206e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">ECS基础设施</h1><p id="811c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">GitHub利用ECS基础设施来运行工作流。以下组件构成了ECS基础架构的一部分，旨在利用AWS自由层。还有其他可能的设计，它们更安全(例如，使用NAT、VPC端点等)、w.r.t .成本更优、维护更优(例如，使用Fargate而不是EC2)。</p><h2 id="b688" class="mx lt iq bd lu nu nv dn ly nw nx dp mc le ny nz me li oa ob mg lm oc od mi oe bi translated">网络</h2><p id="e360" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这里使用<code class="fe nc nd ne mt b">terraform</code> <a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/infra/aws/core/tf-network.tf" rel="noopener ugc nofollow" target="_blank">定义的<code class="fe nc nd ne mt b">VPC</code>网络使用简单的公私子网模型。可以通过使用<code class="fe nc nd ne mt b"><a class="ae lr" href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html" rel="noopener ugc nofollow" target="_blank">NAT gateways</a></code>、<code class="fe nc nd ne mt b"><a class="ae lr" href="https://docs.aws.amazon.com/vpc/latest/privatelink/privatelink-access-aws-services.html" rel="noopener ugc nofollow" target="_blank">Private Links</a></code>来增强该模型，以避免计算组件被公开访问，并分别减少互联网流量。</a></p><h2 id="200f" class="mx lt iq bd lu nu nv dn ly nw nx dp mc le ny nz me li oa ob mg lm oc od mi oe bi translated">计算</h2><p id="1ae1" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用<code class="fe nc nd ne mt b">autoscaling group</code>管理的<code class="fe nc nd ne mt b">EC2</code>计算实例，在仅允许出口流量的<code class="fe nc nd ne mt b">security group</code>公共子网中启动，此处使用<code class="fe nc nd ne mt b">terraform</code> <a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/infra/aws/core/tf-runner-ec2.tf" rel="noopener ugc nofollow" target="_blank">描述</a>。</p><p id="5563" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除此之外，遵循最小特权原则，分配给EC2计算实例的<code class="fe nc nd ne mt b">AmazonSSMManagedInstanceCore</code>和<code class="fe nc nd ne mt b">AmazonEC2ContainerServiceforEC2Role</code> IAM角色将分别在EC2实例上启用<code class="fe nc nd ne mt b"><a class="ae lr" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent.html" rel="noopener ugc nofollow" target="_blank">SSM agent</a></code>和<code class="fe nc nd ne mt b"><a class="ae lr" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_agent.html" rel="noopener ugc nofollow" target="_blank">ECS agent</a></code>。</p><p id="395c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用户数据(在模板文件<code class="fe nc nd ne mt b"><a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/infra/aws/core/setup-vm.sh.tpl" rel="noopener ugc nofollow" target="_blank">setup-vm.sh.tpl</a></code>中指定)用于保存配置数据，然后从<code class="fe nc nd ne mt b">codecommit</code> repo中提取<code class="fe nc nd ne mt b"><a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/infra/aws/core/github_runner/build-runner.sh" rel="noopener ugc nofollow" target="_blank">build-runner.sh</a></code>脚本以开始配置过程。这种分两步走的方法减少了用户数据配置的规模，同时确保了灵活性。</p><p id="16d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne mt b">build-runner.sh</code>脚本做以下三件事:</p><ul class=""><li id="ac1d" class="nf ng iq kx b ky kz lb lc le nh li ni lm nj lq nk nl nm nn bi translated">启用<code class="fe nc nd ne mt b">SSM</code>代理</li><li id="762e" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated">安装和配置<code class="fe nc nd ne mt b">ECS</code>代理</li><li id="0299" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq nk nl nm nn bi translated">使用从codecommit中提取的<code class="fe nc nd ne mt b"><a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/infra/aws/core/github_runner/Dockerfile" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code>和<code class="fe nc nd ne mt b"><a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/infra/aws/core/github_runner/entrypoint.sh" rel="noopener ugc nofollow" target="_blank">entrypoint.sh</a></code>脚本为GitHub自托管运行程序构建映像，然后将构建的映像推送到<code class="fe nc nd ne mt b"><a class="ae lr" href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html" rel="noopener ugc nofollow" target="_blank">AWS Elastic Container Registry</a></code>。</li></ul><h2 id="3f71" class="mx lt iq bd lu nu nv dn ly nw nx dp mc le ny nz me li oa ob mg lm oc od mi oe bi translated">代码基础设施</h2><p id="e675" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/infra/aws/core/tf-code-infra.tf" rel="noopener ugc nofollow" target="_blank"> tf-code-infra.tf </a>定义了<code class="fe nc nd ne mt b"><a class="ae lr" href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html" rel="noopener ugc nofollow" target="_blank">CodeCommit</a></code>、<code class="fe nc nd ne mt b">Elastic Container Registry</code>的基础设施和<code class="fe nc nd ne mt b">EC2</code>角色的相关策略，以允许<code class="fe nc nd ne mt b">EC2</code>实例访问这些组件。codecommit的terraform脚本使用脚本和terraform provisioner功能将<code class="fe nc nd ne mt b">docker</code>文件、<code class="fe nc nd ne mt b">entrypoint</code>脚本和<code class="fe nc nd ne mt b">build-runner</code>文件上传到<code class="fe nc nd ne mt b">codecommit</code>。</p><h2 id="e8c8" class="mx lt iq bd lu nu nv dn ly nw nx dp mc le ny nz me li oa ob mg lm oc od mi oe bi translated">ECS配置</h2><p id="4528" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">ECS配置在<code class="fe nc nd ne mt b"><a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/infra/aws/core/tf-runner-ecs.tf" rel="noopener ugc nofollow" target="_blank">tf-runner-ecs.tf</a></code>中可用，创建cloudwatch日志组、ECS集群和ECS任务定义。除此之外，它还定义了执行ECS任务所需的IAM服务角色(即拥有权限<code class="fe nc nd ne mt b">AmazonECSTaskExecutionRolePolicy</code>)。为Fargate定义了两个独立的ECS任务定义，以简化启动流程。</p><h2 id="046f" class="mx lt iq bd lu nu nv dn ly nw nx dp mc le ny nz me li oa ob mg lm oc od mi oe bi translated">开源代码库</h2><p id="e23e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><code class="fe nc nd ne mt b"><a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/infra/aws/core/tf-code-github.tf" rel="noopener ugc nofollow" target="_blank">tf-code-github.tf</a></code>描述了<code class="fe nc nd ne mt b">AWS</code>和<code class="fe nc nd ne mt b">GitHub</code>集成所需的配置。它包含一个新的IAM OpenID连接提供程序，该提供程序代表GitHub，并使用其指纹验证TLS证书。除此之外，还创建了一个具有<code class="fe nc nd ne mt b">AssumeRoleWithWebIdentity</code>权限的IAM角色，对特定用户和回购有限制。这个角色有<code class="fe nc nd ne mt b">run-task</code>、<code class="fe nc nd ne mt b">stop-task</code>、<code class="fe nc nd ne mt b">pass-role</code>的能力。</p><p id="069b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除此之外，它还定义和设置GitHub workflow使用的环境变量。请注意，由于GitHub APIs的限制，运行者注册所需的PAT令牌(<code class="fe nc nd ne mt b">RUNNER_PAT</code>)需要手动添加到环境中。</p><h1 id="acbb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">考虑</h1><p id="072b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用这种方法时，应该记住以下注意事项</p><ol class=""><li id="6f0e" class="nf ng iq kx b ky kz lb lc le nh li ni lm nj lq of nl nm nn bi translated">个人访问令牌(PAT):用于注册自托管跑步者，应限制其访问权限，以减少其受到损害时的影响。需要两个不同的PAT令牌:一个是创建作为Terraform一部分的环境变量，另一个是创建用于注册的自托管runners令牌。</li><li id="ed71" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq of nl nm nn bi translated">GitHub portal的Actions选项卡显示了在repo的默认分支中定义的工作流。</li><li id="c3f3" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq of nl nm nn bi translated">暂时停止与显式停止:如果构建/部署过程在多个作业上执行，暂时容器可能不合适。在这种情况下，可以通过将<code class="fe nc nd ne mt b">—-query “tasks[0].taskArn” --output text</code>添加到<code class="fe nc nd ne mt b">run-task</code>命令中，在第一个作业中提取任务arn，然后在最后一个作业中使用<a class="ae lr" href="https://awscli.amazonaws.com/v2/documentation/api/latest/reference/ecs/stop-task.html" rel="noopener ugc nofollow" target="_blank">停止任务</a>。</li><li id="24e6" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq of nl nm nn bi translated">ECS任务网络模式:对于在自由层EC2实例上运行任务，ECS任务定义网络模式被设置为<code class="fe nc nd ne mt b">bridge</code>而不是<code class="fe nc nd ne mt b">awsvpc</code>。这主要是因为公共IP不能被分配给这样的容器(由于EC2的限制)。同时，如果在公共子网中设置了NAT网关，可以使用<code class="fe nc nd ne mt b">awsvpc</code>模式来定义在EC2上运行的任务。</li><li id="bf8b" class="nf ng iq kx b ky no lb np le nq li nr lm ns lq of nl nm nn bi translated">GitHub runner图像:有<a class="ae lr" href="https://jonico.github.io/awesome-runners/" rel="noopener ugc nofollow" target="_blank">多种图像清晰度</a>可供选择。这里使用的映像脚本基于这里提供的<a class="ae lr" href="https://github.com/SanderKnape/github-runner" rel="noopener ugc nofollow" target="_blank"/>，它使用最新版本的GitHub自托管runner安装程序创建一个映像，以非根模式运行该进程，在容器启动时安装<code class="fe nc nd ne mt b">ADDITIONAL_PACKAGES</code>，支持<code class="fe nc nd ne mt b">GITHUB_TOKEN</code>和PAT，并删除SIG_TERM和SIG_INT信号上的runner。回购中可用的版本没有移除，因为它利用了临时标志。</li></ol><h1 id="df4e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><p id="ded1" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">自动缩放GitHub自托管跑步者:<a class="ae lr" href="https://docs.github.com/en/actions/hosting-your-own-runners/autoscaling-with-self-hosted-runners" rel="noopener ugc nofollow" target="_blank">https://docs . GitHub . com/en/actions/hosting-your-own-runners/auto scaling-with-self-hosted-runners</a></p><p id="f3c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GitHub OpenID Connect与AWS的集成:<a class="ae lr" href="https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services" rel="noopener ugc nofollow" target="_blank">https://docs . GitHub . com/en/actions/deployment/security-hardening-your-deployments/configuring-OpenID-Connect-in-Amazon-web-services</a></p><p id="0236" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GitHub工作流程示例:</p><p id="fa56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://github.com/shekhar-jha/base-demo/blob/infra-core/.github/workflows/infra-aws-core.yml" rel="noopener ugc nofollow" target="_blank">https://github.com/shekhar-jha/base-demo/blob/infra-core/.github/workflows/infra-AWS-core . yml</a></p><p id="0268" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里显示了所有的地形定义:<a class="ae lr" href="https://github.com/shekhar-jha/base-demo/tree/infra-core/infra/aws/core" rel="noopener ugc nofollow" target="_blank">https://github . com/shek har-jha/base-demo/tree/infra-core/infra/AWS/core</a></p><p id="edf6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">参考GitHub runner图片:<a class="ae lr" href="https://github.com/SanderKnape/github-runner" rel="noopener ugc nofollow" target="_blank">https://github.com/SanderKnape/github-runner</a></p><p id="eca3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！敬请关注更多内容。</p></div></div>    
</body>
</html>