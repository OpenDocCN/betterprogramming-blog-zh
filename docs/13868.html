<html>
<head>
<title>Enabling Monorepo With a Simple Single GitHub Repository</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过一个简单的GitHub存储库启用Monorepo</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/enabling-monorepo-with-a-simple-single-github-repository-39bc6347abba?source=collection_archive---------3-----------------------#2022-10-06">https://betterprogramming.pub/enabling-monorepo-with-a-simple-single-github-repository-39bc6347abba?source=collection_archive---------3-----------------------#2022-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7f07" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">学习软件开发</h2><div class=""/><div class=""><h2 id="ac5e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">凑合着在一个GitHub存储库上启用Monorepo</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/439cea2f6ede5d591fbcf044df44f6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FBy3uZJY3pWBAM3_"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">罗曼·辛克维奇·🇺🇦在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2e04" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如今，要启动任何项目，我们都从项目的一个GitHub库开始。项目需要的所有东西都在这个单一的存储库中。我称之为单一项目。</p><p id="9572" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着它的成长，一些人称之为<a class="ae lh" href="https://dictionary.cambridge.org/dictionary/english/monolith" rel="noopener ugc nofollow" target="_blank">巨石</a>，其中一个定义是</p><blockquote class="me mf mg"><p id="3655" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">“一个强大的组织，不愿意改变，似乎对个人不感兴趣。”</p></blockquote><p id="8bd8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于一个软件项目来说，上面的定义在某种程度上也是正确的，特别是从它可能发生变化的角度来看。这可能发生在我们将所有的东西无结构地混杂到同一个存储库中时(如果参与其中的人数随着时间的推移而增加和变化，这可能更容易发生)，并对其进行进一步的更改。</p><h1 id="1d33" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">分成更小的部分和单独的存储库</h1><p id="dce7" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">为了确保我们能够相应地成长和扩展，我们需要为团队独立工作划定清晰的划分和界限。</p><p id="2aad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们将项目分成更清晰的小部分，并将它们放入不同的存储库中。</p><p id="38e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这得益于所有权、监管权和自主权。然而，挑战随之而来，尤其是随着存储库数量的增长。</p><ol class=""><li id="92b2" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">项目的集成变得更加困难，也就是说，要发布变更，集成需要多个步骤。</li><li id="bcd2" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">跨项目的依赖共享现在更难管理了，因为我们需要强制一些舞蹈序列来使其协调一致。</li><li id="1ff3" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">项目代码的可见性降低，使得搜索和调试更加困难。</li></ol><h1 id="bbdc" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">Monorepo来拯救？</h1><p id="a8c7" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">看到这种日益增长的痛苦，许多组织采取的一个主要方法是进行单一回购。</p><blockquote class="me mf mg"><p id="e843" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">monorepo是一个版本控制的代码库，包含许多项目。虽然这些项目可能是相关的，但是它们通常在逻辑上是独立的，并且由不同的团队运行。</p></blockquote><p id="1104" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下图说明了现实生活中的这一点。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e5a307ae07d02d02fe8eee5fa8dbb960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*NE-9Wt2KMKOmCl9xs9cTmA.png"/></div></figure><p id="a1ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于Monorepo的工作，一个主要的关键是，我们如何仍然有一个明确的“分离”定义，以确保每个团队将继续</p><ol class=""><li id="8c3c" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">明确属于每个团队的代码部分的所有权</li><li id="6ddc" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">团队特有的清晰可见性(例如，PR、在制品部分)和执行(CI流程)</li></ol><p id="cac6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是一些关于我们如何在一个简单的GitHub库上实现我们所拥有的东西的想法</p><h1 id="a2bd" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">文件夹机制</h1><p id="446f" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">每个GitHub存储库都有一个根文件夹。按照惯例，谁拥有根文件夹，谁就拥有整个存储库。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/20b3e9495e5307fd2bba00d021977d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*SXnBX4iQi8_XP3pEpjRlCA.png"/></div></figure><p id="d7f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，对于Monorepo，我们现在主持不同的项目。我们需要有能力让每个所有者清楚地拥有它的每一部分。</p><p id="e288" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现这一点，根不再属于任何代码所有者。也许它可以归DevOps团队所有。</p><p id="86d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，下一级文件夹可以被其他人使用。有了这些，我们现在有了一个非常清晰的文件夹结构，每个团队都可以拥有它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/cdbf3432e9fc8da2746256df22dde304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PBSheD05yEUXkOYiSgOEg.png"/></div></div></figure><p id="79ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如图所示，我们还可以将DevOps common infra作为一个单独的文件夹跨项目共享，并共享一些依赖项。</p><p id="87e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这很好，因为所有的项目所有者都在相同的层次级别上，可以在相同的文件夹结构级别上访问更容易组织的项目，如“README”，甚至一些通用的工具文件，使其更易于管理，以便更清晰地管理。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/f712b9ad1ba7a07064b643c48d8df5d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*P5vB24Mg_tIKdbc4Iw6HBA.png"/></div></div></figure><h2 id="198e" class="oa mm it bd mn ob oc dn mr od oe dp mv lr of og mx lv oh oi mz lz oj ok nb iz bi translated">避免分层项目所有权文件夹</h2><p id="f272" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">有时，人们可能会认为Project就像是另一个项目的库，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/7285d02d2610e834e621a10f123e1fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*Vhw-yd83_q48LdzbIv7hEA.png"/></div></figure><p id="e099" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有一种诱惑使文件夹的结构像这样:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/b458562e937f7ee80d79bb40af574c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iikL_QpZaD-Kft_3fVfXvA.png"/></div></div></figure><p id="7623" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可能会产生如下所述的各种问题:</p><ul class=""><li id="f8f5" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md on no np nq bi translated">这意味着子文件夹项目将始终属于父项目。这也妨碍了它将来在其他项目中的可重用性。如果真的很清楚它应该总是属于那个项目，也许它们应该被组合在一起作为一个项目。</li><li id="0256" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md on no np nq bi translated">这将使支持多项目单一回购的工具变得复杂。人们必须浏览分层文件夹以访问和识别不同的项目所有者。</li></ul><h2 id="d065" class="oa mm it bd mn ob oc dn mr od oe dp mv lr of og mx lv oh oi mz lz oj ok nb iz bi translated">“但是，但是…我的移动开发工具只能包含项目子文件夹中的子模块项目”</h2><p id="1a60" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">好消息是，我已经探索了本地移动项目(例如XCode和Android Studio)，人们可能可以从不同根级别的文件夹中导入子模块。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/007baa0bb87b92d84329c23b00e345b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XYNJ09kmnA1i34xd.png"/></div></figure><p id="52ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有关更多详细信息，请查看下面的文章:</p><div class="op oq gp gr or os"><a href="https://medium.com/mobile-app-development-publication/monorepo-for-ios-and-android-project-2fe9eadd9748" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd jd gy z fp ox fr fs oy fu fw jc bi translated">iOS和Android项目Monorepo</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在扩展项目开发的同时，尽可能简化集成和依赖性处理</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg lb os"/></div></div></a></div><h1 id="92ab" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">分支机制</h1><p id="9bc1" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">文件夹分离有助于在同一个存储库中划分实际的代码所有权。然而，还有其他方面没有得到解决。</p><ul class=""><li id="0725" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md on no np nq bi translated">我们可以为不同团队的项目运行不同的CI流程吗？例如，当每个团队编码时，他们只想运行他们较小的项目CI，而不是运行存储库中的整个项目套件！</li><li id="6d21" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md on no np nq bi translated">我是否可以只查看我的团队的PR，而不必列出所有组的PR，并使用团队成员的姓名(会不时更改)手动过滤掉？</li><li id="e5c4" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md on no np nq bi translated">我能轻松地访问我的团队当前正在进行的工作代码吗？</li></ul><p id="abd1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一种可能的方法是为每个团队定义一个合适的分支名称实践。</p><h2 id="8444" class="oa mm it bd mn ob oc dn mr od oe dp mv lr of og mx lv oh oi mz lz oj ok nb iz bi translated">每个项目的分支名称</h2><p id="e671" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">以前我开发的正常做法是创建一个分支名<code class="fe ph pi pj pk b">/feature/&lt;feature-name&gt;</code>。每个人都这样做。这不是问题，因为每个人都在同一个团队。我们队里没有太多的人。</p><p id="e61a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，对于不同的团队，很难区分哪个团队正在开发哪个特性。</p><p id="dae0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，需要一些分支命名约定，如下所示:</p><pre class="ks kt ku kv gt pl pk pm pn aw po bi"><span id="4a6c" class="oa mm it pk b gy pp pq l pr ps">&lt;project-name&gt;/feature/&lt;feature-name&gt;</span></pre><p id="1b8d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样做的好处如下:</p><ol class=""><li id="7772" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">当团队想找出他们拥有的分支时，他们更容易筛选出他们拥有的，并分别做相关的内务处理。</li><li id="d7dd" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">我们的CI流程可以利用分支根名称来确定流程运行(例如，它不需要运行所有项目的CI流程)。这允许团队定制他们自己的CI过程，并且在开发中有更好的周转时间。</li></ol><h2 id="391d" class="oa mm it bd mn ob oc dn mr od oe dp mv lr of og mx lv oh oi mz lz oj ok nb iz bi translated">每个团队的分支主管</h2><p id="a79d" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在一个单独的存储库中，每个团队都有自己的<code class="fe ph pi pj pk b">main</code>分支和<code class="fe ph pi pj pk b">feature</code>分支。通常，他们可能对<code class="fe ph pi pj pk b">main</code>和其他人有不同的CI运行配置。</p><p id="2bb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，为了保持类似的优势，可以考虑引入团队的主要分支。</p><pre class="ks kt ku kv gt pl pk pm pn aw po bi"><span id="c2c3" class="oa mm it pk b gy pp pq l pr ps">&lt;project-name&gt;/main</span></pre><p id="673d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，特色分支，即<code class="fe ph pi pj pk b">&lt;project-name&gt;/feature/&lt;feature-name&gt;</code>可以合并到这个<code class="fe ph pi pj pk b">&lt;project-name&gt;/main</code>分支中。</p><p id="bd8f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在“可发布”之后，团队领导将<code class="fe ph pi pj pk b">&lt;project-name&gt;/main</code>分支合并到实际的<code class="fe ph pi pj pk b">main</code>分支中。</p><p id="682d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当然，这个<code class="fe ph pi pj pk b">&lt;project-name&gt;/main</code>应该总是尽可能有规律地与<code class="fe ph pi pj pk b">main</code>分支同步，也许每当<code class="fe ph pi pj pk b">main</code>分支有新的变化时就自动同步。</p><p id="33eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，对“长期存在的”分支地狱问题的担心在这里将会非常少见，因为文件夹有非常清晰的编码分离。冲突是非常罕见的，因为除了团队本身之外，在<code class="fe ph pi pj pk b">main</code>分支中不会发生影响团队代码的其他代码变更。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/116790c9f483dc826fe1e4dd066b4192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LUqliKLVPhHvldkjpvnOw.png"/></div></div></figure><blockquote class="me mf mg"><p id="74e4" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">有一个例外，当一个共享的依赖项升级或基础设施更新到整个系统时，这将影响所有的项目，因此主分支中的这种变化将影响所有的团队。</p><p id="e14a" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">但是这种情况不会像团队中通常的代码变更那样频繁(也不会对代码产生大的影响),也不会带来好处(下面将会分享)。</p><p id="361c" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">如果它们发生得太频繁，那么项目的划分应该被重新检查。</p></blockquote><p id="3145" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样做的好处如下:</p><h1 id="3bf7" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">对于每次合并，主版本将更有意义</h1><p id="0688" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">期待很正常，任何到了<code class="fe ph pi pj pk b">main</code>的东西都有望随时发布。假设每个签入的<code class="fe ph pi pj pk b">main</code>都是立即释放的。然后，将“发布”的数量最小化为一个组合并特征，而不是不完整特征的单个PRs。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/a3f6a1777c30a6472e1e7f30cf8fb1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wvvi6MxfR3KqCAaA4bXqZQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">此图仅显示了一个项目。随着多个项目的不断合并，这种差异会更加剧烈</p></figure><h1 id="a2e4" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">可以更好地总结主要发布项</h1><p id="34cd" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">假设我们不在每次合并到<code class="fe ph pi pj pk b">main</code>时发布(例如，移动项目，我们在固定的持续时间后将一个“发布”分组到商店)，将一个组合并到<code class="fe ph pi pj pk b">main</code>会更好，因为它可以产生有意义的总结</p><p id="2280" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请看下图:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/c76672cd2c0a5d03c9cb32b29c9e31c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVlUS3IoiXmvZEk9hiI24w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="62f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从那里开始，在发布时，发布说明将看起来像下面这样，合并的组将放在那里。看起来更简洁有意义。</p><ul class=""><li id="accf" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md on no np nq bi translated">有一个完整的功能将与一个有意义的公关一起发布</li><li id="c600" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md on no np nq bi translated">没有任何部分特性(注意，在组PR合并的情况下，项目3/特性1甚至没有发布)</li></ul><blockquote class="me mf mg"><p id="f314" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd">注</strong>:完整特征的定义=要一起发布的预期零件。它可能是切换背后的部分项目，但却是一个有意义的版本</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/b91072c005a39bbda1982c5070346fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbNaigwcMVCLRMYXGNQ2lw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">这个图只显示了三个项目。当有更多的项目时，列表的多样性会更大。</p></figure><h1 id="d8b7" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">当发现问题时，更容易检测到有问题的变更</h1><p id="4946" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">按照上面的思路，发布一个分组合并，附带一个简洁的摘要发布和一个PR列表，这样更容易找到哪个PR引入了一个bug。分组列表可以分开。</p><p id="352c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要浏览的pr列表更快，并且它们有意义地链接在一起。为新的修补程序版本恢复它们也更快。</p><h2 id="c09d" class="oa mm it bd mn ob oc dn mr od oe dp mv lr of og mx lv oh oi mz lz oj ok nb iz bi translated">各自团队的PRs调查结果要容易得多</h2><p id="afd0" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">通过<code class="fe ph pi pj pk b">&lt;project name&gt;/main</code>分支，我们可以很容易地过滤出与被检查集团相关的PR。可以检查要合并到的目标分支。</p><p id="e86c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样做的语法取自<a class="ae lh" href="https://stackoverflow.com/a/32293984/3286489" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出</a>。</p><blockquote class="me mf mg"><p id="59ce" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">搜索短语是:<code class="fe ph pi pj pk b"><em class="it">is:open is:pr base:X</em></code></p><p id="ce50" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">官方描述:<a class="ae lh" href="https://docs.github.com/en/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-by-branch-name" rel="noopener ugc nofollow" target="_blank">基于分行名称的搜索</a></p><p id="ea6d" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">您也可以选择添加<code class="fe ph pi pj pk b"><em class="it">is:merged</em></code>或<code class="fe ph pi pj pk b"><em class="it">is:unmerged</em></code>过滤器。</p></blockquote><h1 id="397c" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">在项目中，多层CI流程沿着“进行中的工作”与“功能完成”进行</h1><p id="cae5" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当一些特性开发正在进行时，我们希望将它合并到一个工作分支中，并让它运行足够的测试以加快CI周转时间。</p><p id="4be2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">开发人员可能不想运行整个繁重的测试功能。但是在完成开发后，人们可能希望通过一个更严格的测试链接来自动运行主项目。</p><p id="7169" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们有一个<code class="fe ph pi pj pk b">&lt;project name&gt;/main</code>分支，那么我们可以在合并到实际的<code class="fe ph pi pj pk b">main</code>之前配置它运行一个更健壮的CI测试。</p><p id="7224" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<code class="fe ph pi pj pk b">&lt;project name&gt;/feature/&lt;feature-name&gt;</code>分支，可以有一个更快周转的CI测试，如果需要，可以选择更健壮的测试。</p><p id="0daa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，我们可以有一个多层的测试来处理阶段合并，同时确保在适当的开发水平上的快速周转时间。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/596407abeec5a842fd02fb3bfc4a5e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ucs1itSegOUM8gfu9YFUtA.png"/></div></div></figure><h1 id="4dd9" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="3a08" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">使用文件夹和分支机制，我们可以将一个普通的GitHub存储库转换成Monorepo。它将在团队之间实现一些清晰的代码和过程划分。</p><p id="942b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">人们可以利用GitHub中的其他功能，例如标记或项目参考级别。</p><p id="c14f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管如此，仍有其他棘手的问题需要解决。以下是其中的一些:</p><ul class=""><li id="e9fa" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md on no np nq bi translated">协调团队间的依赖关系变更——这是谁的责任？每个球队老板？轮换DevOps团队？平台团队？</li><li id="4d9f" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md on no np nq bi translated">我们是否也为跨多个不同平台的项目提供服务，并共享相同的结构？</li><li id="42e7" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md on no np nq bi translated">我们在同一个平台上发布不同的主项目吗？如果是这样，需要什么分支机制？</li><li id="e6ad" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md on no np nq bi translated">假设我们共享同一个GitHub库，那么它会随着大量代码的增长而继续扩展吗？</li></ul><p id="9006" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">嗯，就像一个成长中的家庭生活在一起一样，总会有一些挑战需要一起应对。我相信有办法解决或解决这些问题。我们只需要合作，有时为了在同一屋檐下和谐相处而妥协。</p></div></div>    
</body>
</html>