<html>
<head>
<title>How to Control Class Names in Styled Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何控制样式化组件中的类名</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-control-class-names-in-styled-components-72ed4b165cb9?source=collection_archive---------6-----------------------#2022-07-11">https://betterprogramming.pub/how-to-control-class-names-in-styled-components-72ed4b165cb9?source=collection_archive---------6-----------------------#2022-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7b8d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">样式组件的巴别塔配置</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4aac95b523e9ac5304d98bd789998bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jN3EAzFekgkyyyv9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pakata?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pakata Goh </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2cfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是一个流行的库，用来设计React应用程序。我们已经介绍了<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/styled-components-a-css-in-js-approach-755f6a196c42">是什么以及如何使用</a>。我们还探讨了继承样式的7种方法和12个符号用法的编码示例。</p><p id="9e18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论如何在<code class="fe lv lw lx ly b">styled-components</code>中控制类名。</p><h1 id="b1cc" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">默认类名</h1><p id="3e42" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们在上一篇文章中重用了<a class="ae ky" href="https://medium.com/p/69debaad97e3#16d6" rel="noopener">Create React App工作环境。以下软件包已安装在环境中:</a></p><ul class=""><li id="311e" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">styled-components</code></li></ul><p id="057a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ul class=""><li id="ec36" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">在第1行，<code class="fe lv lw lx ly b">styled</code>从<code class="fe lv lw lx ly b">styled-components</code>导入。<code class="fe lv lw lx ly b">styled</code>是默认的导出，用于创建<code class="fe lv lw lx ly b">styled.tagname</code> helper方法，将样式从JavaScript转换为实际的CSS规则。</li><li id="03c8" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nb nc nd ne bi translated">在第3–13行，样式化组件<code class="fe lv lw lx ly b">Container</code>扩展了<code class="fe lv lw lx ly b">div</code>的样式。它包含了<code class="fe lv lw lx ly b">div</code>元素的CSS属性。<code class="fe lv lw lx ly b">::first-letter</code>伪元素(第8–13行)将样式应用于块级元素第一行的第一个字母。</li><li id="d6a8" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nb nc nd ne bi translated">在第15–20行，样式化组件<code class="fe lv lw lx ly b">Button</code>扩展了<code class="fe lv lw lx ly b">button</code>的样式。它包含了<code class="fe lv lw lx ly b">button</code>元素的CSS属性。</li></ul><p id="55ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行<code class="fe lv lw lx ly b">npm start</code>。我们看到蓝色背景上的一段文字。第一个字母是红色粗体，末尾有两个按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/0f31a378e63daa1acb2364aec46c1461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*x4P2BDNnXoz5zuMx9zME0g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是检查窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6eae3dc74aa47a91d3c3cd3e7cd85235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*DPk5nmOECypUIpWRyTdwzA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在内部，<code class="fe lv lw lx ly b">styled-components</code>为每个组件生成两个类——一个是静态的，一个是动态的。类名由<a class="ae ky" href="https://en.wikipedia.org/wiki/MurmurHash" rel="noopener ugc nofollow" target="_blank"> MurmurHash算法</a>生成。它根据组件id和计算的样式字符串生成一个唯一的标识符，然后将散列值转换为字母类名。</p><p id="900e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态类名是<code class="fe lv lw lx ly b">sc-&lt;hashedStringName&gt;</code>。它用于标识样式化的组件，并且没有附加到它的样式。所有实例的名称都相同。在上面的例子中，<code class="fe lv lw lx ly b">Container</code>的静态类是<code class="fe lv lw lx ly b">sc-bczRLJ</code>，而<code class="fe lv lw lx ly b">Button</code>的静态类是<code class="fe lv lw lx ly b">sc-gsnTZi</code>。</p><p id="31d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据插值的结果，每个实例的动态类名可能不同。上例中，<code class="fe lv lw lx ly b">Container</code>的动态类是<code class="fe lv lw lx ly b">OeNbu</code>。<code class="fe lv lw lx ly b">Button</code>的动态类是<code class="fe lv lw lx ly b">My Button 1</code>的<code class="fe lv lw lx ly b">fiiIWC</code>，和<code class="fe lv lw lx ly b">My Button 2</code>的<code class="fe lv lw lx ly b">ccAjHy</code>。</p><h1 id="141c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">自定义类名</h1><p id="418f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">默认的类名很难识别。我们能在调试时让它们更容易识别吗？</p><p id="1f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我们可以。</p><p id="f94c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它需要<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/styled-components/babel-plugin-styled-components" rel="noopener ugc nofollow" target="_blank">babel-plugin-styled-components</a></code>和定制的巴别塔配置。</p><p id="ba49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">styled-components</code>安装后，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/styled-components/babel-plugin-styled-components" rel="noopener ugc nofollow" target="_blank">babel-plugin-styled-components</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/kentcdodds/babel-plugin-macros" rel="noopener ugc nofollow" target="_blank">babel-plugin-macros</a></code>随<code class="fe lv lw lx ly b">package-lock.json</code>一起出现。</p><p id="c00f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个选项可以设置自定义的babel配置:</p><ul class=""><li id="ffd3" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">弹出创建React应用程序</li><li id="e664" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nb nc nd ne bi translated">使用<code class="fe lv lw lx ly b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/10-fun-facts-about-create-react-app-eb7124aa3785#2d4e">react-app-rewired</a></code></li><li id="0d92" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nb nc nd ne bi translated">使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/dilanx/craco" rel="noopener ugc nofollow" target="_blank">craco</a></code>(创建React应用程序配置覆盖)</li></ul><p id="2162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们通过执行<code class="fe lv lw lx ly b">npm run eject</code>来弹出Create React应用程序。弹出的<code class="fe lv lw lx ly b">package.json</code>有以下巴别塔构型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="05d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了默认名称之外，一个有意义的类名可以由<code class="fe lv lw lx ly b">namespace</code>、<code class="fe lv lw lx ly b">displayName</code>和<code class="fe lv lw lx ly b">fileName</code>组成。我们最多可以配置一个类名为<code class="fe lv lw lx ly b">fileName__displayName-namespace-defaultName</code>。</p><h2 id="2679" class="no ma it bd mb np nq dn mf nr ns dp mj li nt nu ml lm nv nw mn lq nx ny mp nz bi translated">命名空间</h2><p id="4a14" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">命名空间将确保生成的类名是唯一的。这是避免应用程序间名称冲突的简便方法。</p><p id="e7fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe lv lw lx ly b">package.json</code>中试试这个巴别塔配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ul class=""><li id="7d3e" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">在第9行，<code class="fe lv lw lx ly b">namespace</code>被配置为<code class="fe lv lw lx ly b">my-styled-components-project</code>。</li><li id="f29f" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nb nc nd ne bi translated">在第10行，<code class="fe lv lw lx ly b">displayName</code>关闭。</li><li id="532e" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nb nc nd ne bi translated">在第11行，<code class="fe lv lw lx ly b">fileName</code>关闭。</li></ul><p id="bf98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是检查窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8fdc27f124a841064662843039c2ad74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*tifW7fGiqKBWuLRV-ieHLw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e63b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe lv lw lx ly b">Container</code>的静态类变成了<code class="fe lv lw lx ly b">sc-hulcih-0</code>，而<code class="fe lv lw lx ly b">Button</code>的静态类变成了<code class="fe lv lw lx ly b">sc-hulcih-1</code>。所有名称都以名称空间<code class="fe lv lw lx ly b">my-styled-components-project</code>为前缀。</p><h2 id="cd72" class="no ma it bd mb np nq dn mf nr ns dp mj li nt nu ml lm nv nw mn lq nx ny mp nz bi translated">显示名称</h2><p id="4dfe" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">displayName</code>是组件名。这使得在应用程序中更容易找到样式化的组件。</p><p id="6a15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe lv lw lx ly b">package.json</code>中试试这个巴别塔配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ul class=""><li id="f43a" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">在第10行，<code class="fe lv lw lx ly b">displayName</code>开启。</li></ul><p id="e8c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是检查窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ad1ba1ec1c4349274ab72de91f6373b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*A6vn8E9Q2UEKSIumQItUAg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="dfab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">样式化的组件名称<code class="fe lv lw lx ly b">Container</code>和<code class="fe lv lw lx ly b">Button</code>放在名称空间<code class="fe lv lw lx ly b">my-styled-components-project</code>的前面。</p><h2 id="25dc" class="no ma it bd mb np nq dn mf nr ns dp mj li nt nu ml lm nv nw mn lq nx ny mp nz bi translated">文件名</h2><p id="3d25" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">fileName</code>是组件所在的文件名。使用带前缀的文件名，组件名称变得尽可能唯一。</p><p id="302d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试<code class="fe lv lw lx ly b">package.json</code>中的这个巴别塔配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ul class=""><li id="faed" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">在第11行，<code class="fe lv lw lx ly b">fileName</code>开启。</li></ul><p id="e731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是检查窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/0342f399c01531ce759d0a7955f9c2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*wmoLLXt0QHrG6gY5igga2A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fb83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件名<code class="fe lv lw lx ly b">App</code>放在<code class="fe lv lw lx ly b">displayName</code>前面。</p><p id="96ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果和<code class="fe lv lw lx ly b">displayName</code>一样呢？</p><p id="a9e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为这个案例建立一个例子。</p><p id="02cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是放置样式组件<code class="fe lv lw lx ly b">Button</code>的<code class="fe lv lw lx ly b">src/components/Button.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="be96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是<code class="fe lv lw lx ly b">src/components/Components.js</code>，放置样式化组件<code class="fe lv lw lx ly b">Container</code>的地方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c17d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据此，<code class="fe lv lw lx ly b">src/App.js</code>修改为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是检查窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/6733c7b55ae93ff388dd4dbe406c876b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*Rn77xya_FR2ZhEIbCW2bNQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="30c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">Container</code>，由于<code class="fe lv lw lx ly b">fileName</code>和<code class="fe lv lw lx ly b">displayName</code>不同，所以都显示。</p><p id="d4c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">Button</code>，由于<code class="fe lv lw lx ly b">fileName</code>和<code class="fe lv lw lx ly b">displayName</code>相同，所以只显示其中一个名字。</p><h2 id="6fc0" class="no ma it bd mb np nq dn mf nr ns dp mj li nt nu ml lm nv nw mn lq nx ny mp nz bi translated">无意义文件名</h2><p id="3664" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果样式化的组件<code class="fe lv lw lx ly b">Container</code>放在<code class="fe lv lw lx ly b">src/components/index.js</code>而不是<code class="fe lv lw lx ly b">src/components/Components.js</code>中会怎样？</p><p id="7f53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看检查窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/9b03534d77ee42224b6ed4da572f64be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*vEZwQENPhpW2mR88TqjDeQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fc8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目录名<code class="fe lv lw lx ly b">components</code>显示为<code class="fe lv lw lx ly b">fileName</code>，而不是<code class="fe lv lw lx ly b">index</code>。</p><p id="0f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<code class="fe lv lw lx ly b">meaninglessFileNames</code>的默认设置相当于下面第11行的代码。它认为<code class="fe lv lw lx ly b">index</code>是一个无意义的文件名。因此，将显示目录名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="987e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">package.json</code>的babel配置中删除<code class="fe lv lw lx ly b">index</code>这个无意义的文件名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是检查窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/376ba5cdc22a9a9edfa03c4db808403d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*bDFVTh1z0YqpkRw533G3Tg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在文件名<code class="fe lv lw lx ly b">index</code>显示为filename，不管它有多无意义。</p><h2 id="950d" class="no ma it bd mb np nq dn mf nr ns dp mj li nt nu ml lm nv nw mn lq nx ny mp nz bi translated">服务器端渲染</h2><p id="4787" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们正在尝试配置样式化的组件类名。为什么要讲服务器端渲染？</p><p id="ff05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<code class="fe lv lw lx ly b">ssr</code>设置为真。它保证为每个样式化的组件生成一个惟一的标识符，这避免了由于客户机和服务器上不同的类生成而导致的校验和不匹配。</p><p id="a25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关闭它将导致类名更改。让我们在<code class="fe lv lw lx ly b">src/package.json</code>试试吧:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是检查窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/4fdfbaed633677f6efab41ea3d0a2eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*G5DrEmQLFJf1xJHaCIxZ-w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，<code class="fe lv lw lx ly b">namespace</code>丢失，<code class="fe lv lw lx ly b">defaultName</code>没有前缀<code class="fe lv lw lx ly b">sc</code>。在再水合过程中，SSR可能会显示HTML属性不匹配警告。因此，建议将<code class="fe lv lw lx ly b">ssr</code>设为默认值。</p><h1 id="006b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="3d37" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">是一个流行的库，用来设计React应用程序。它被React项目广泛采用。我们已经在<code class="fe lv lw lx ly b">styled-components.</code>中展示了如何控制类名，希望可识别的类名能使您的调试更容易。</p><p id="6782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="0f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ok">如果你有兴趣，可以看看</em> <a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af#266e" rel="noopener"> <em class="ok">其他风格化组件文章</em> </a> <em class="ok">。</em></p></div></div>    
</body>
</html>