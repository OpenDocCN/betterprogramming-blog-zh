<html>
<head>
<title>Working on High-Performance Golang Client Library — Reading Again From Channels?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">致力于高性能Golang客户端库——再读通道？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/working-on-high-performance-golang-client-library-reading-again-from-channels-5e98ff3538cf?source=collection_archive---------3-----------------------#2022-02-11">https://betterprogramming.pub/working-on-high-performance-golang-client-library-reading-again-from-channels-5e98ff3538cf?source=collection_archive---------3-----------------------#2022-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="088f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">自定义环形队列及其问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/be318f6367897722a66604c6900e9592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4-EaDJX1cJMcUAiy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约瑟夫·巴里恩托斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d66e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是我从构建高性能golang Redis客户端库<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>中学到的常见技巧系列的第二个主题。</p><p id="89ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些提示对日常golang编程也很有用:</p><ul class=""><li id="42d2" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><a class="ae kv" href="https://ruian.medium.com/writing-high-performance-golang-client-library-part-1-batching-on-pipeline-97988fe3211?source=friends_link&amp;sk=ff4d0b2200f9416025f6cac6f2c0d117" rel="noopener">第1部分——管道上的配料</a></li><li id="0518" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">第2部分—从频道中再次读取？</li><li id="48a6" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">第3部分——通过同步消除不良繁忙环路。Cond</li><li id="0c53" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">第4部分—优雅地关闭并发编写器的通道</li></ul><p id="4e53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第1部分中，我们讨论了流水线上的批处理如何提高性能，并在golang中仅用<code class="fe ls lt lu lv b">channel</code>和<code class="fe ls lt lu lv b">bufio.Writer</code>实现了<code class="fe ls lt lu lv b">writing</code>功能。</p><p id="0eb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将讨论<code class="fe ls lt lu lv b">reading</code>函数的实现，该函数将来自读取流的响应映射回原始请求。</p><h1 id="6967" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">阅读功能</h1><p id="a0e7" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">如前一部分所述，为了利用管道技术，客户端库应该同时保持写入输出流和读取输入流。因此，<code class="fe ls lt lu lv b">reading</code>功能应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8622" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似于<code class="fe ls lt lu lv b">bufio.Writer</code>，<code class="fe ls lt lu lv b">bufio.Reader</code>自动为我们批量socket read系统调用。我们只需要从缓冲区中提取我们的响应，这就是<code class="fe ls lt lu lv b">readResponse</code>函数所做的。之后，我们需要将响应映射回原始请求，或者更准确地说，通知原始调用者。</p><p id="1cd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个关键点是循环必须由输入流驱动。也就是说，在循环开始时继续从<code class="fe ls lt lu lv b">bufio.Reader</code>读取，因为这样我们不仅可以轻松地处理来自服务器的带外消息，而且一旦套接字关闭，我们还可以立即得到通知。后者对于流水线活性监控是至关重要的。</p><p id="af04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个循环中，有许多方法可以找到最初的调用者。以下部分是关于我尝试过的两种方法及其优缺点。</p><h1 id="fcbc" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">双通道</h1><p id="11b8" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">因为我们正在流水线化请求/响应模型协议，所以我们应该期望服务器也按照我们发送的相同顺序进行响应。但是，我们不允许再次从通道中读取相同的数据。</p><p id="d9a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，保持请求顺序的一个简单方法是，在从<code class="fe ls lt lu lv b">writing</code>通道检索请求后，将它们推到另一个<code class="fe ls lt lu lv b">waiting</code>通道。</p><p id="d61a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在前面的<code class="fe ls lt lu lv b">writing</code>函数中添加下面两行<code class="fe ls lt lu lv b">waiting &lt;-req</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="48fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过读取<code class="fe ls lt lu lv b">waiting</code>通道完成<code class="fe ls lt lu lv b">reading</code>功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ed85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们如何使用这些函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="23ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们调用了<code class="fe ls lt lu lv b">pipelining</code>函数，管道就建立起来了，我们可以并发地调用<code class="fe ls lt lu lv b">makeRequest</code>函数来发送请求和接收响应。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="6fbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法简单而有效。然而，它在两个方面还不够好:</p><ol class=""><li id="4038" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nq mc md me bi translated">将请求从<code class="fe ls lt lu lv b">requests</code>通道移动到<code class="fe ls lt lu lv b">waiting</code>通道看起来效率很低，并且需要两倍大小的通道缓冲区。</li><li id="b239" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">它需要为每个并发请求分配一个<code class="fe ls lt lu lv b">respCh</code>通道，这也是很昂贵的。</li></ol><p id="cda5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的基准测试结果也揭示了上述两个问题。与我在<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>中使用的方法相比，双通道方法只有大约50%的吞吐量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="8ca7" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">自定义环形队列</h1><p id="34de" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">通道不允许我们从通道中再次读取相同的数据。既然他们在内部使用环形队列，为什么我们不能定制环形队列来解决上述问题呢？</p><p id="4360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在web上，有许多文章讨论如何构建无锁的环形队列或环形缓冲区。都值得一读。我还在<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>中使用了他们的一些技巧，包括:</p><ol class=""><li id="b02e" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nq mc md me bi translated">用<code class="fe ls lt lu lv b">&amp;</code>代替<code class="fe ls lt lu lv b">%</code>循环环。</li><li id="19a8" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">计数器之间的填充以减少CPU错误共享。</li><li id="4e55" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">依靠Golang提供的事前保证。</li></ol><p id="21e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一系列的文章中，我不打算一一介绍。如果你对它们感兴趣，你可以查看我放在附录中的参考链接。</p><p id="5b85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的文章中，我们将从构建一个无锁的环形队列开始，就像我在前面的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>中所做的那样，我试图追求最佳的性能。但是在下一篇文章中，我们将放弃无锁环队列，我将向您展示为什么它在我们的例子中也不好。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="17a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了支持管道用例，我们需要一个支持多个并发写者和两个并发读者的环形队列。它们是:</p><ol class=""><li id="acc0" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nq mc md me bi translated">用户可以将请求并发写入队列。</li><li id="8440" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">一个goroutine从队列中读取请求，然后写入套接字。</li><li id="f7e8" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">一个goroutine从套接字读取响应，然后从队列中找到相应的请求。</li></ol><p id="4e76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以从定义队列接口开始，我认为它是一个用于管道化请求/响应协议的通用接口:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ol class=""><li id="4046" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nq mc md me bi translated"><code class="fe ls lt lu lv b">EnqueueRequest</code>由并发写入器使用，并被阻塞，直到返回响应。</li><li id="26cf" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated"><code class="fe ls lt lu lv b">NextRequestToSend</code>被我们的管道编写器goroutine用来向输出流发送下一个请求。</li><li id="fcad" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated"><code class="fe ls lt lu lv b">ReplyToNextRequest</code>由我们的读取器goroutine在管道中使用，用于在收到来自传入流的响应时查找原始调用者。</li></ol><p id="6247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以这样定义我们的环形队列实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ol class=""><li id="5d89" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nq mc md me bi translated"><code class="fe ls lt lu lv b">slots</code>字段是我们存储请求的地方。</li><li id="d3fe" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated"><code class="fe ls lt lu lv b">write</code>字段是由并发写入器递增的原子计数器，以找到它们应该写入哪个槽。</li><li id="2f8e" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated"><code class="fe ls lt lu lv b">read1</code>和<code class="fe ls lt lu lv b">read2</code>字段独立地专用于我们的写线程和读线程，它们不需要成为原子计数器。</li></ol><p id="0508" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对环槽的访问仍然需要同步。那就是:</p><ol class=""><li id="4080" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nq mc md me bi translated">写入者不应该覆盖具有未实现的请求的槽。</li><li id="af3b" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">管道的写线程不应该读取没有被写的槽。</li><li id="6556" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">管道的读取器goroutine不应读取管道的写入器goroutine尚未读取的槽。</li></ol><p id="f771" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，为了避免在每个请求上为调用者分配响应通道，我们将它们预先分配到槽上并重用它们。我们需要找到一种方法来保证一旦调用者获得了通道，其他人就不能同时读取该通道，否则，响应将被传递给错误的调用者。</p><p id="588f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">产生的插槽结构定义如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6692" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用插槽的<code class="fe ls lt lu lv b">mark</code>字段来实现上述要求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="441a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">EnqueueRequest</code>在每次调用时递增<code class="fe ls lt lu lv b">write</code>计数器，它忙于等待<code class="fe ls lt lu lv b">mark</code>字段为零，并保证它是唯一一个在<code class="fe ls lt lu lv b">ch</code>等待由<code class="fe ls lt lu lv b">CompareAndSwap</code>操作的并发调用响应的。将请求放入插槽后，它将<code class="fe ls lt lu lv b">mark</code>更改为下一个值，以允许我们的编写器goroutine读取它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a438" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">NextRequestToSend</code>仅由我们的作家goroutine使用。无需原子操作即可访问<code class="fe ls lt lu lv b">read1</code>计数器。它检查下一个槽的<code class="fe ls lt lu lv b">mark</code>是否为2，然后在将<code class="fe ls lt lu lv b">mark</code>更改为下一个值之前复制req。如果<code class="fe ls lt lu lv b">mark</code>不为2，则返回<code class="fe ls lt lu lv b">ok = false</code>通知写入器刷新输出缓冲区。</p><p id="7f23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe ls lt lu lv b">ReplyToNextRequest</code>与<code class="fe ls lt lu lv b">NextRequestToSend</code>相似，但它仅由我们的阅读器goroutine使用，并递增<code class="fe ls lt lu lv b">read2</code>计数器，并将响应传递回调用者:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b841" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，<code class="fe ls lt lu lv b">s.ch</code>通道应该是<strong class="ky ir">非缓冲的</strong>，以确保在我们将<code class="fe ls lt lu lv b">mark</code>变回零并允许其他<code class="fe ls lt lu lv b">EnqueueRequest</code>调用者通过<code class="fe ls lt lu lv b">CompareAndSwap</code>操作获取<code class="fe ls lt lu lv b">mark</code>之前，调用者已经收到响应。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="75c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。不过，它实际上并不是完全无锁的，因为我们仍然在<code class="fe ls lt lu lv b">s.ch</code>上使用阻塞通道操作。</p><p id="940b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们忽略阻塞的<code class="fe ls lt lu lv b">s.ch</code>通道操作，<code class="fe ls lt lu lv b">EnqueueRequest</code>上的基准测试结果将会令人吃惊。与双通道相比，完全无锁的环形队列本身的吞吐量提高了近6倍:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="27e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在我们的案例中，只对无锁部分进行基准测试会产生误导。将环形队列放入<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>后，并没有显示出大约6倍的性能提升，而只是前面提到的2倍。</p><p id="b27c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且最重要的是，无锁环队列有一个明显的缺点:忙着等待。</p><h1 id="a1a9" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">下一步是什么:去除坏的忙循环</h1><p id="0d1d" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">现在，不仅是<code class="fe ls lt lu lv b">EnqueueRequest</code>有忙等待循环，而且编写器goroutine也有同样的问题，因为我们失去了写通道的阻塞行为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3a86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我将分享它们为什么不好，以及我如何在不影响<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>性能的情况下移除它们。</p><h1 id="9316" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">附录</h1><div class="nr ns gp gr nt nu"><a href="https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">这些年来我一直写错了环形缓冲区</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">所以我实现了一个单元素的环形缓冲区。我相信你会同意，这是一个完全合理的数据…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">www.snellman.net</p></div></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://itnext.io/understanding-the-lmax-disruptor-caaaa2721496" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">了解LMAX干扰器</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">了解LMAX中断器库(线程间通信库)的原理</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">itnext.io</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://go.dev/ref/mem" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">Go记忆模型</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">Go内存模型指定了在什么条件下可以保证在一个goroutine中读取变量…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">go.dev</p></div></div><div class="od l"><div class="oj l of og oh od oi kp nu"/></div></div></a></div></div></div>    
</body>
</html>