<html>
<head>
<title>Character Encoding, Part 3 of 3 — Gotchas While Working With Unicode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">字符编码，第3部分，共3部分—使用Unicode时遇到的问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/character-encoding-part-3-of-2-gotchas-while-working-with-unicode-9f5ec272351d?source=collection_archive---------15-----------------------#2019-10-31">https://betterprogramming.pub/character-encoding-part-3-of-2-gotchas-while-working-with-unicode-9f5ec272351d?source=collection_archive---------15-----------------------#2019-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ebf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个错误在编程中是很常见的，对吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6a6b53aa65e51c239d6de0ed26a0cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpdT8YnfbmAktmXvznFuPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们完了！(摄影:兰迪·欧)</p></figure><p id="4031" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以在我发表了最初的两篇字符编码文章(<a class="ae lu" href="https://medium.com/better-programming/character-encodings-the-pain-that-wont-go-away-part-1-2-non-unicode-dee7650fb6bf" rel="noopener">第一部分</a>和<a class="ae lu" href="https://medium.com/better-programming/character-encodings-the-pain-that-wont-go-away-part-2-2-unicode-4f13a0d2d42d" rel="noopener">第二部分</a>这里)后，几个朋友插话说我遗漏了故事的一个重要部分。Unicode边缘案例和陷阱！他们是对的。虽然使用这种东西表面上很简单，但现实世界充满了惊喜。</p><p id="d567" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个比我自己的个人使用更深入文本技术用法的话题，所以我将依赖许多资源和比我更熟悉文本和字符编码的人。</p><p id="30fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开始吧，不分先后。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be7f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">比较组合字符和预先组合的字符不是一个好主意(除非你规范化)</h1><p id="3227" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Unicode允许组合字符(例如给字母添加重音符号)。它还将包含预先组合的字符(带有重音符号的字母已经作为单个字符附加)。它们看起来完全一样，Unicode认为它们在语义上是相同的。这些东西占用不同的代码点，如果你天真地用字节来比较字符串，你会得到错误的答案。</p><p id="8329" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个字符上也可以有多个重音符号——符号的顺序通常对字符的显示无关紧要，但比较字节的笨计算机会看出不同。所有这些都不好。</p><p id="471a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为Unicode认为这种情况在语义上是等价的，所以它提供了一种规范化字符串的方法，这样任何字符串都可以与相似的规范化字符串进行比较，并产生<strong class="la iu">一致的</strong>结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d5a6a2bfc16166ad0f348c2aeda346fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*s4UL4KKhGas64s7kFoasfw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标准化形式的例子，NFD，NFC，NFKD，NFKC。来源:<a class="ae lu" href="http://unicode.org/reports/tr15/#Canonical_Composites_Figure" rel="noopener ugc nofollow" target="_blank"> Unicode </a></p></figure><p id="ce73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正式来说，有四种形式:分解的NFD-标准规范形式，合成的NFC-标准规范形式，以及NFKD和NFKC是规范形式(k)兼容性版本。兼容性版本将把下标和连字等特征分离出来，并把它们当作单独的字符。</p><p id="15de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在大多数情况下，使用四种规范化形式中的哪一种来比较字符串并不重要，只要两个字符串使用相同的规范化。这些操作是等幂的，所以确保您使用的规范化是正确的不会有什么坏处。当系统对标准化做出矛盾的假设时，各种各样的混乱都会发生。</p><p id="1611" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我发现了一些问题:</p><ul class=""><li id="c841" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">在某些范围没有被正确标准化的情况下，OSX使用自己的标准化风格。iconv工具专门为此提供了UTF-8-mac编码。这里有些<a class="ae lu" href="https://metacpan.org/pod/Encode::UTF8Mac" rel="noopener ugc nofollow" target="_blank">细节</a>。</li><li id="e3f0" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">对于串联来说，标准化可能不稳定。规格化(X+Y)是<em class="no">而不是</em>与规格化(X) +规格化(Y)不一定相同。所以调用规范化时要小心。幸运的是，这个过程是幂等的，所以多次运行它只需要一些计算。<a class="ae lu" href="http://unicode.org/reports/tr15/#Concatenation" rel="noopener ugc nofollow" target="_blank">细节</a>。</li><li id="183c" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">规范化为复合形式(NFC/NFKC)有时可能会使字符串更长！这是因为出于兼容性原因，Unicode将3.1版声明为“复合版本”。不鼓励新的组合，那些确实存在的组合可能会采用一个组合字符，并将其分解为3.1加一个组合字符。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1ea1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Unicode几乎可以编码任何东西——包括Mojibake</h1><p id="c782" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Mojibake是指计算机使用错误的编码将字节转换为人类可读的字符。这意味着mojibake虽然从人类的角度来看是无意义的，但实际上是由某种语言中的有效字符组成的，尽管顺序毫无用处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e63d00a743ece9872388d0da637ebf85.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/0*qMcyzkzeMAa6T6Wz.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些例子mojibake</p></figure><p id="185c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着，如果有人获取一个传入的流，使用错误的编码对其进行解释，然后将其代码转换为Unicode — <strong class="la iu"> Unicode会欣然接受字符序列并按原样存储它们。</strong>由于检测遗留编码方案可能有些容易出错，并且不是每个人都了解文本编码的细微之处，这导致了损坏的不正确Unicode将进入数据集的情况。</p><p id="4088" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，有人发明了一种方法来解决这些问题。Robyn Speer创建了一个名为ftfy 的<a class="ae lu" href="https://github.com/LuminosoInsight/python-ftfy" rel="noopener ugc nofollow" target="_blank"> python库，它使用许多试探法来猜测某些字符序列何时看起来不适合上下文，并试图纠正它们。如果你正在做大量的文本工作，并且不确定数据的质量，这将非常有用。</a></p><p id="a087" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我强烈推荐看一下<a class="ae lu" href="https://github.com/LuminosoInsight/python-ftfy/blob/master/ftfy/badness.py" rel="noopener ugc nofollow" target="_blank">评论良好的源代码</a>，看看它是如何平衡各种考虑的，比如有可能存在有意的数学等式和表情符号的“眼睛状/鼻子状”符号，而不是“真正的mojibake”</p><p id="5a8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢Igor指出有一个包可以修复这种特殊的边缘情况。我不怎么接触文字，也没有意识到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="28c3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Unicode的字符串长度很奇怪</h1><p id="e1d9" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">从概念上讲，字符串的长度是字符串中的字符数。除了因为UTF-8是可变宽度的，UTF-16有代理对，Unicode有组合字符本身不是独立的字符，你不能简单地计算字节块来得到字符串的长度。只不过这是传统字符串长度计算的数量。</p><p id="3d9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除非您特别使用正确的支持Unicode的长度函数，否则您可能会得到奇怪的答案。例如，JavaScript在内部使用UTF-16，但是它可以<a class="ae lu" href="https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length" rel="noopener ugc nofollow" target="_blank">给出有趣的长度结果，因为它是如何计算</a>的。它将单个代理项对字符计为两个字符，而不是一个。你甚至不能指望规范化来最小化字符串的字节长度，因为如上所述，规范化有时会使字符串具有更长的代码单元序列！</p><p id="6d4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，一旦你进入Unicode，字符串长度充其量是一个模糊的概念。你可能会想避开它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9085" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">当心损坏的Unicode实现，它们就在那里</h1><p id="945b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">当开发人员考虑实现Unicode时，第一条建议很简单:<strong class="la iu">不要</strong>。请改用现有的库。所以很少会遇到不可靠的Unicode实现。</p><p id="2049" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，还有MySQL…</p><p id="41de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于MySQL长期以来保持的快速但不一定正确的传统，它在2002年改变了最初的“utf8”(基于T4 RFC 2279中的6字节UTF-8)编码，使其最大为3字节。UTF-8 ( <a class="ae lu" href="https://tools.ietf.org/html/rfc3629" rel="noopener ugc nofollow" target="_blank"> RFC 3629 </a>)最多可以有四个字节，这意味着基本多语言平面(BMP)之外的几乎所有东西都将出错。</p><p id="d830" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，在MySQL 8中，UTF-8仍然被声明为“<a class="ae lu" href="https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-sets.html" rel="noopener ugc nofollow" target="_blank">utfmb 3</a>的别名”。用四个字节工作的UTF-8的正确形式叫做<a class="ae lu" href="https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-sets.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> utfmb4 </strong> </a> <strong class="la iu">。这就是你应该使用的。出于向后兼容的原因，这种情况可能永远不会改变。</strong></p><p id="020f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于整个MySQL(和MariaDB) UTF-8疯狂的更多细节可以在这里找到。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7ef1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">同样，确保“UTF-8”标签确实是UTF-8</h1><p id="2a17" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><a class="ae lu" href="https://docs.oracle.com/database/121/SQLRF/ap_standard_sql015.htm#SQLRF55539" rel="noopener ugc nofollow" target="_blank"> Oracle同样有非直观的字符编码参数</a>，与Unicode 6.2兼容的UTF-8被称为“AL32UTF8”，而他们的“UTF8”实际上是与Unicode 3.0兼容的，符合CESU-8。CESU-8是UTF-8的变体，它使用两个3字节序列来模拟UTF-16代理对，以访问更高的字符平面。这类似于MySQL最初兼容的6字节UTF-8。</p><p id="2b78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Java也有一个“<a class="ae lu" href="https://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8" rel="noopener ugc nofollow" target="_blank">修改的UTF-8 </a>”，它的行为有点像CESU-8，但是围绕空字符有一些不同的逻辑。它还支持标准的UTF-8。通常情况下，你可以正常使用UTF-8，但修改后的UTF-8在某些情况下会让你措手不及。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b3fb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">有时，即使是使用良好的库也会有bug</h1><p id="7931" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Unicode中存在许多不同类型的脚本，但世界上绝大多数使用非常小的子集，这一事实导致即使在非常大的软件公司的库中也存在有趣的错误。</p><p id="2b45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个例子就是影响iOS 的<a class="ae lu" href="https://manishearth.github.io/blog/2018/02/15/picking-apart-the-crashing-ios-string/" rel="noopener ugc nofollow" target="_blank">角色死亡</a><a class="ae lu" href="https://www.unicode.org/mail-arch/unicode-ml/y2018-m02/0103.html" rel="noopener ugc nofollow" target="_blank">。在这种情况下，Unicode本身很好，但是它使用印度文字。这些文字有一些独特的规则来组合字符和音调符号，以代表某些辅音-元音。这导致字体渲染引擎出现问题，从而导致崩溃。不管是哪种情况，特定的字符序列都会导致各处的iPhones崩溃，直到错误被修复。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8de6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">性格检测会以奇怪的方式背叛你</h1><p id="35b4" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">还记得在第1部分中，我展示了字符检测是如何被愚弄的吗，尤其是在短字符串上？在研究这个的时候，我发现了一个很好的例子，维基百科上有一个很搞笑的页面叫做“<a class="ae lu" href="https://en.wikipedia.org/wiki/Bush_hid_the_facts" rel="noopener ugc nofollow" target="_blank">布什隐瞒了事实</a>”这是指字符集检测以某种方式获取记事本中的文本，将其检测为中文，并将其转换为无意义的Unicode。</p><p id="c91e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，Windows很早就支持Unicode，可以追溯到USC-2(它早于UTF-16，但不支持代理对，因此只能表示BMP字符)。围绕UCS-2/UTF-16构建的悠久历史意味着围绕UTF-8会有一些古怪。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="898f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">记住你仍然需要正确的字体</h1><p id="1bd3" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Unicode对字形进行编码，但是通过使用字形向用户显示字形的最后一步是另外一个问题。您可以指定想要显示的任意数量的字符，但是如果您的最终用户没有该字体，或者有一些奇怪的坏字体，他们仍然不会看到您发送给他们的内容。</p><p id="b5ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如今，系统很好地拥有足够的字体选择，能够呈现大多数文本。主要问题是当新角色加入时——通常是表情符号。这就是为什么虽然一个新的表情符号可能会在Unicode标准上声明，但它可能需要一段时间才能进入你的手机。需要用新的字形更新字体。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6fb9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Twitter上FakeUnicode的超级道具</h1><p id="8643" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">直到最近我才熟悉Unicode，我问这个很棒的Twitter帐户是否有什么有趣的问题，天哪，我得到了一堆！我将在这里总结，但你真的应该检查线程，因为我不能真正做到公正，而不只是复制粘贴整个事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="bc97" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated"><a class="ae lu" href="https://twitter.com/FakeUnicode/status/1189366901270568960" rel="noopener ugc nofollow" target="_blank">在密码中使用表情符号会导致奇怪的行为，获得相同符号的顺序已经改变</a>。</li><li id="cdef" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">按代码单元(字节)排序通常不是一个好主意(Unicode特别建议您使用Unicode定义的排序算法)。代理范围在BMP中，有些字符与其他字符相距很远。</li><li id="942a" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">在某些语言中，从大写转换到小写是不可逆的操作。</li><li id="846d" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">Unicode明确规定不能用0填充代码点(它规定代码点必须是唯一的，有效地排除了前导零)一些程序不关心这些“过长的编码”——vim就是这样一个程序。</li><li id="991f" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">不管怎样…这…是:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d9a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">外面有更多的疯狂。我很确定。但是这个列表已经够长了，我可以忍受至少一个月不去想Unicode。所以我要在这里结束它！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fbae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">额外阅读</h1><p id="bf60" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">很难找到关于Unicode的这些不寻常的特性的文档。但是除了我在正文中已经链接过的，这里还有一些:</p><div class="ns nt gp gr nu nv"><a href="http://www.macchiato.com/unicode/globalization-gotchas" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">全球化抓住了你——玛奇朵</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">我正在为三月份的下一次Unicode会议准备一个演示，并且一直在考虑做一个关于…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.macchiato.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://eev.ee/blog/2015/09/12/dark-corners-of-unicode/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">Unicode的黑暗角落</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">我假设，如果你在互联网上阅读书呆子的博客，你知道Unicode是什么。最重要的是…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">eev.ee</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://nukep.github.io/progblog/2015/02/26/some-gotchas-about-unicode-that-every-programmer-should-know.html#characters-that-appear-the-same-might-not-test-equal" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">每个程序员都应该知道的关于Unicode的一些问题</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">编辑描述</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">nukep.github.io</p></div></div><div class="oe l"><div class="ol l og oh oi oe oj ks nv"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1322" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">谢了？</h1><p id="a1f0" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我全心全意地责怪这两个人促使我开始写第三篇文章。都是你的错。</p><div class="ns nt gp gr nu nv"><a href="https://twitter.com/teej_m" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">TJ·墨菲</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">TJ墨菲的最新推文(@teej_m)。数据呆子。之前的@imgur、@minted、@minomonsters、@zynga。我做了一个…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">twitter.com</p></div></div><div class="oe l"><div class="om l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://twitter.com/igorbrigadir" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">伊戈尔·布里格迪尔</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">Igor Brigadir的最新推文(@IgorBrigadir)。PhD @insight_centre @ucddublin。机器学习，自然…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">twitter.com</p></div></div><div class="oe l"><div class="on l og oh oi oe oj ks nv"/></div></div></a></div></div></div>    
</body>
</html>