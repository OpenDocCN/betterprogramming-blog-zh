<html>
<head>
<title>Compiler vs. Interpreter: Know The Difference And When To Use Each Of Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编译器与解释器:了解它们的区别以及何时使用它们</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/compiler-vs-interpreter-d0a12ca1c1b6?source=collection_archive---------0-----------------------#2021-01-19">https://betterprogramming.pub/compiler-vs-interpreter-d0a12ca1c1b6?source=collection_archive---------0-----------------------#2021-01-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="0e10" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">软件工程</a></h2><div class=""/><div class=""><h2 id="530a" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">编译器和解释器的类型和用例</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/6dc983809a4711684f582ad81291da0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UVEJ5pkwGqkiewpm"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@cookiethepom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cookie Pom</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0ea3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我仍然记得和我的一个同事的一次讨论，我说，“那是transpiler，”他回答:“Trans…什么？”</p><p id="d445" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你从未听过这个名字，你并不孤单。作为开发人员，我们都习惯于用人类可以理解的高级语言编写代码。然而，计算机只能理解用二进制系统编写的程序，即机器代码。</p><p id="311b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了用非人类语言与计算机对话，我们提出了两种解决方案:解释器和编译器。讽刺的是，我们大多数人对它们知之甚少，尽管它们属于我们的日常编码生活。</p><p id="752a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在这篇文章中，我将深入探索将高级语言翻译成可执行的机器代码的过程。我将关注这个游戏中两个关键角色的内部工作——编译器和解释器——并分解相关的概念。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="5fe3" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">从高级语言到低级语言的旅程</h1><p id="a906" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">编译器和解释器长期以来被用作转换代码的计算机程序。但是它们以不同的方式工作:</p><ul class=""><li id="8656" class="nj nk iu ll b lm ln lp lq ls nl lw nm ma nn me no np nq nr bi translated">编译器将高级编程语言编写的代码翻译成低级语言，如汇编语言、目标代码和机器代码(二进制1和0位)。它在程序运行之前提前转换代码。</li><li id="7012" class="nj nk iu ll b lm nt lp nu ls nv lw nw ma nx me no np nq nr bi translated">当程序运行时，解释器逐行翻译代码。你可能在工作生涯的某个时候不知不觉地使用过口译员。</li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ny"><img src="../Images/292bec9cf1952071184cfd3825c2ab23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oF6ViJv49IdoaMYR9VYb3Q.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://www.guru99.com/difference-compiler-vs-interpreter.html" rel="noopener ugc nofollow" target="_blank">编译器vs解释器</a></p></figure><p id="0d50" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">编译器和解释器都有优点和缺点:</p><ul class=""><li id="159b" class="nj nk iu ll b lm ln lp lq ls nl lw nm ma nn me no np nq nr bi translated">编译器需要整个程序和大量的时间来分析源代码，而解释器只需要一行代码和很少的时间来分析它。</li><li id="68e4" class="nj nk iu ll b lm nt lp nu ls nv lw nw ma nx me no np nq nr bi translated">编译的代码运行得更快，而解释的代码运行得更慢。</li><li id="54f2" class="nj nk iu ll b lm nt lp nu ls nv lw nw ma nx me no np nq nr bi translated">编译器会在编译后显示所有错误。如果您的代码有错误，它将无法编译。但是解释器会逐个显示每一行的错误。</li><li id="9bc3" class="nj nk iu ll b lm nt lp nu ls nv lw nw ma nx me no np nq nr bi translated">解释并不能完全取代编译。</li><li id="6ebd" class="nj nk iu ll b lm nt lp nu ls nv lw nw ma nx me no np nq nr bi translated">出于优化的原因，编译器可以包含解释器，比如更快的性能和更小的内存占用。</li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj nz"><img src="../Images/b49b0d03e2500013e0c5c1ea77f6d792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*EDrkOzFjlJw1fPVGStomEw.jpeg"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://www.bitforestinfo.com/blog/12/20/subroutine-example-of-assembly-language.html" rel="noopener ugc nofollow" target="_blank">汇编语言</a></p></figure><p id="a3f8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">高级编程语言通常被称为“编译语言”或“解释语言”然而，在实践中，它们可以同时具有编译和解释的实现。例如，C被称为编译语言，尽管存在C解释器。第一个JavaScript引擎是简单的解释器，但出于性能原因，所有现代引擎都使用实时(JIT)编译。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="6341" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">解释器的类型</h1><p id="4d6d" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">早在1952年，解释器就被用来简化编程，还被用来在低级机器语言之间进行翻译。第一种解释型高级语言是Lisp。Python、Ruby、Perl和PHP是使用解释器的其他编程语言的例子。</p><p id="d6d1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下是解释器类型的非排他性列表:</p><h2 id="4028" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated">1.字节码解释程序</h2><p id="2c79" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">字节码解释和即时编译的趋势模糊了编译器和解释器之间的区别。</p><blockquote class="ol om on"><p id="4ca5" class="lj lk ns ll b lm ln ke lo lp lq kh lr oo lt lu lv op lx ly lz oq mb mc md me in bi translated">在字节码解释器中，每条指令都以一个字节开始，因此字节码解释器有多达256条指令，尽管并不是所有的指令都能被使用。一些字节码可能需要多个字节，并且可能是任意复杂的。”</p><p id="d5bb" class="lj lk ns ll b lm ln ke lo lp lq kh lr oo lt lu lv op lx ly lz oq mb mc md me in bi translated">— <a class="ae li" href="https://en.wikipedia.org/wiki/Interpreter_(computing)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><h2 id="48a1" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated"><em class="or"> 2。线程代码解释器</em></h2><p id="1bba" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">与字节码解释器不同，线程代码解释器使用指针而不是字节。每条指令都是指向一个函数或指令序列的一个字，后面可能还有一个参数。不同指令的数量受到可用内存和地址空间的限制。</p><p id="6107" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">第四个代码——用于<a class="ae li" href="https://en.wikipedia.org/wiki/Open_Firmware" rel="noopener ugc nofollow" target="_blank">开放固件</a>系统——是线程代码的经典例子。源代码被编译成称为“F代码”的字节码，然后由虚拟机解释。</p><h2 id="63cf" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated">3.抽象语法树解释程序</h2><p id="9069" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">如果你是一个<a class="ae li" href="https://medium.com/better-programming/typescript-new-release-19f1238c6a68" rel="noopener"> TypeScript </a>开发者，并且对<a class="ae li" href="https://medium.com/better-programming/angular-10-new-features-dbc779061dc8" rel="noopener"> TypeScript架构</a>有一些了解，你可能听说过抽象语法树的缩写AST。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="ab gv cl os"><img src="../Images/1da18f08a0a47be46db22868f3fd97c3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*XByFtwFWgmevLgrka-6DyQ.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://github.com/ikatyang/angular-html-parser/blob/master/packages/compiler/design/architecture.md" rel="noopener ugc nofollow" target="_blank"> TypeScript Transpiler架构</a></p></figure><p id="147a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">AST是一种将源代码转换成优化的抽象语法树的方法，然后按照这种树结构执行程序，或者使用它来即时生成本机代码。</p><p id="ba84" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">AST保持全局程序结构和语句之间的关系。这允许系统在运行时执行更好的分析，并使AST成为实时编译器比字节码表示更好的中间格式。</p><p id="a122" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是，对于解释器来说，AST会导致更多的开销。遍历抽象语法树的解释器比生成字节码的解释器要慢。</p><h2 id="50be" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated">4.即时编译</h2><p id="5226" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">实时编译(JIT)是一种在运行时将中间表示编译成本机代码的技术。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="74ca" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">编译器的类型</h1><h2 id="c4dd" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated"><strong class="ak"> 1。交叉编译器</strong></h2><p id="b17d" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">一种运行在计算机上的编译器，该计算机的CPU或操作系统不同于它所产生的代码运行的计算机。</p><h2 id="1958" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated"><strong class="ak"> 2。本地编译器</strong></h2><p id="22a4" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">一种编译器，它产生的输出可以在与编译器本身相同类型的计算机和操作系统上运行。</p><h2 id="b9c8" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated"><strong class="ak"> 3。引导编译器</strong></h2><p id="f63f" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">用它要编译的语言编写的编译器。</p><h2 id="f339" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated"><strong class="ak"> 4。反编译器</strong></h2><p id="84e4" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">反编译程序将代码从低级语言翻译成高级语言。</p><h2 id="a89c" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated"><strong class="ak"> 5。源到源编译器(Transpiler) </strong></h2><p id="df6e" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">这是一个在高级语言之间翻译的程序。这种类型的编译器也称为转换编译器或传输编译器。</p><p id="0038" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">示例:</p><ul class=""><li id="3623" class="nj nk iu ll b lm ln lp lq ls nl lw nm ma nn me no np nq nr bi translated">Emscripten:将C/C++转换成JavaScript。</li><li id="9c80" class="nj nk iu ll b lm nt lp nu ls nv lw nw ma nx me no np nq nr bi translated">Babel:将JavaScript代码从ES6+传输到ES5。</li><li id="82bb" class="nj nk iu ll b lm nt lp nu ls nv lw nw ma nx me no np nq nr bi translated">cfront:c++的原始编译器(大约从1983年开始)。它使用C作为目标语言，创建了没有缩进风格的C代码，也没有漂亮的C中间代码，因为生成的代码通常不适合人类阅读。</li></ul><h2 id="21c2" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated">6.语言重写者</h2><p id="5a3b" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">这通常是一个不改变语言的程序翻译表达形式。</p><h2 id="3d43" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated">7.字节码编译器</h2><p id="42ed" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">将高级语言翻译成可以被字节码解释器或虚拟机解释的中间简单语言的编译器。</p><p id="9ee1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">例子:Java和Python的字节码编译器。</p><h2 id="5a43" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated">8.实时编译器(JIT编译器)</h2><p id="bc0c" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">JIT编译器将编译推迟到运行时。它通常在解释器中运行。</p><p id="f871" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">示例:</p><ul class=""><li id="a053" class="nj nk iu ll b lm ln lp lq ls nl lw nm ma nn me no np nq nr bi translated">最早出版的JIT编译器归功于1960年的<em class="ns"> LISP </em>。</li><li id="d143" class="nj nk iu ll b lm nt lp nu ls nv lw nw ma nx me no np nq nr bi translated">后一种技术出现在20世纪80年代的Smalltalk等语言中。</li><li id="5557" class="nj nk iu ll b lm nt lp nu ls nv lw nw ma nx me no np nq nr bi translated">然后，JIT编译在Java等现代语言中获得了主流关注。 NET框架、Python和最现代的<a class="ae li" href="https://medium.com/better-programming/javascript-history-and-future-71b0ceb737aa" rel="noopener"> JavaScript </a>实现。</li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ot"><img src="../Images/86014925eb8b08680ecf0616b3ac5a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*ZxNHl9pIaCtRN_6wLxGVig.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://www.guru99.com/difference-between-jdk-jre-jvm.html" rel="noopener ugc nofollow" target="_blank"> JRE (Java运行时环境)功能</a></p></figure><p id="4cec" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在Java中，源文件首先被编译并转换成包含Java字节码(高度优化的指令集)的<code class="fe ou ov ow ox b">.class</code>文件，然后字节码解释器执行字节码，稍后JIT编译器将字节码翻译成机器码。</p><p id="e26f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Java字节码既可以在运行时由虚拟机解释，也可以在加载时或运行时编译成本机代码。现代JVM实现使用编译方法，因此在初始启动时间之后，性能相当于本机代码。</p><h2 id="888a" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated">9.AOT汇编</h2><p id="8a19" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">超前(AOT)编译是在运行时之前编译高级编程语言或Java字节码等中间表示的方法。</p><p id="91dd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">示例:</p><p id="ad7f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Angular框架使用一个<a class="ae li" href="https://angular.io/guide/aot-compiler" rel="noopener ugc nofollow" target="_blank">提前</a> (AOT)编译器在构建期间将HTML和类型脚本代码转换为JavaScript代码，以便在代码运行时在浏览器上提供更快的呈现。</p><h2 id="9c54" class="oa mn iu bd mo ob oc dn ms od oe dp mw ls of og my lw oh oi na ma oj ok nc ja bi translated">10.一名<em class="or">装配员</em></h2><p id="f1c1" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">汇编程序将人类可读的汇编语言翻译成机器代码。这个编译过程称为汇编。将机器代码转换成汇编语言的逆向程序称为反汇编程序。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oy"><img src="../Images/3d04fd5e4ce349a383e46191c38ea9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKN-I-ofcmxIkyTnH-Y1fg.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://www.androidauthority.com/assembly-language-and-machine-code-678230/" rel="noopener ugc nofollow" target="_blank">汇编程序</a></p></figure><p id="0b94" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><a class="ae li" href="https://en.wikipedia.org/wiki/Assembly_language" rel="noopener ugc nofollow" target="_blank">汇编语言</a>(缩写为ASM)是一种依赖机器代码指令的低级编程语言。这就是为什么每一种汇编语言都是为一种特定的计算机体系结构而设计的。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="c25f" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">外卖食品</h1><p id="6884" class="pw-post-body-paragraph lj lk iu ll b lm ne ke lo lp nf kh lr ls ng lu lv lw nh ly lz ma ni mc md me in bi translated">编译器和解释器都是将高级语言编写的代码转换成计算机可以理解的低级代码或机器代码的计算机程序。然而，它们在工作方式和使用时间上有所不同。</p><p id="ae9d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">即使您不打算实现下一个编译器或解释器，这些见解也应该有助于提高您作为开发人员每天使用的工具的知识。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="58e9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的免费电子邮件简讯，独家获取</strong> </a> <strong class="ll je"> </strong>或在此注册Medium <a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener">。</a></p><p id="a78a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="ns">你可以在Udemy上查看我的</em> <strong class="ll je"> <em class="ns">视频课程</em></strong><em class="ns">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="ns">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="ns">。</em></p></div></div>    
</body>
</html>