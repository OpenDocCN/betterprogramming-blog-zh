<html>
<head>
<title>The Complete Guide to State Management in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI状态管理完全指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-guide-to-state-management-in-swiftui-8759add64bcf?source=collection_archive---------0-----------------------#2019-10-11">https://betterprogramming.pub/the-complete-guide-to-state-management-in-swiftui-8759add64bcf?source=collection_archive---------0-----------------------#2019-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e270" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何理解SwiftUI开发的这个组成部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb5cd20f3bff631e53a325fe66ef7aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLbWbUYM17DvJym6Zw-ZBg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泰勒·拉斯托维奇在<a class="ae ky" href="https://unsplash.com/s/photos/iphone-x?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="bad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">更新</strong>:不要像Michael Long说的那样，在ViewModel的init方法中调用网络请求。我录制视频是为了说明问题以及如何修复。你可以在这里看视频:<a class="ae ky" href="https://youtu.be/HJS_yzSihoA" rel="noopener ugc nofollow" target="_blank">https://youtu.be/HJS_yzSihoA</a></p><p id="5069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>是苹果新的声明式框架，用于为所有苹果设备构建用户界面。SwiftUI框架可以分解成两个基本组件:<em class="lv">视图</em>和<em class="lv">状态</em>。</p><p id="581f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于在SwiftUI中维护和理解状态的。状态管理是SwiftUI开发不可或缺的一部分，有许多不同的方式来处理状态。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6493" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">理解状态</h1><p id="6687" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><em class="lv">状态</em>表示与视图相关的数据。它可以用boolean、string、int等基本类型来表示。；或者像视图模型这样的复杂对象。在SwiftUI中，更改状态值会导致视图重新呈现，从而允许它与相关数据同步。</p><p id="4229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae ky" href="https://flutter.dev/" rel="noopener ugc nofollow" target="_blank"> Flutter </a>中也有类似的概念，其中改变状态会导致渲染和构建功能分别启动。</p><p id="651c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个简单的状态例子。在这个例子中，我们将允许用户切换开关。根据开关的状态，图标会在白天和黑夜之间变化。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7095" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">国家的基本说明</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="379f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面例子中的重要部分是在布尔属性上使用属性包装器。我们还用private关键字标记它，表明这个状态是<code class="fe nc nd ne nf b">ContentView</code>组件的本地/私有状态。</p><p id="708a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">Toggle</code>视图接受一个<code class="fe nc nd ne nf b">Binding&lt;Bool&gt;</code>，它通过传递<code class="fe nc nd ne nf b">isOn</code>状态属性来满足。任何时候<code class="fe nc nd ne nf b">Toggle</code>在<code class="fe nc nd ne nf b">isOn</code>或<code class="fe nc nd ne nf b">isOff</code>之间改变状态，状态值就会更新。每当状态更新时，它调用body属性来重新呈现视图。</p><p id="b8b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/976a1991ce18d02ef7a02a67ceb2940a.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/1*KUwDqtx51v9vmuYfy0ZgAQ.gif"/></div></figure><p id="d1ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经对状态有了一些基本的了解，让我们看看如何使用它来捕获多条信息。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="efa0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">添加更多变量</h1><p id="3f23" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">下面我们有一个名为<code class="fe nc nd ne nf b">Register</code>的视图的实现。它包括注册新用户的所有基本要素。为了使这个例子简单，我们使用了基本的SwiftUI元素，如<code class="fe nc nd ne nf b">TextField</code>等。在您的实际应用中，您可以使用SwiftUI框架中可用的<code class="fe nc nd ne nf b">Form</code>视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">Register</code>视图的状态由四个独立变量控制。每个变量捕获状态的一部分。当用户在文本字段中键入内容时，由于绑定的强大功能，状态变量会得到更新。</p><p id="24ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数情况下，这很有效！但是我们必须处理四个独立变量，它们代表一个模型。这可以通过引入表示视图状态的视图模型来简化。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b23a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">斯威夫图伊和MVVM</h1><p id="15c6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">虽然您可以使用任何设计模式来构建您的SwiftUI应用程序，但是推荐的模式是<a class="ae ky" href="https://martinfowler.com/eaaDev/PresentationModel.html" rel="noopener ugc nofollow" target="_blank">表示模型</a>，也称为MVVM。在MVVM设计模式中，您将首先创建一个视图模型，该模型将负责向视图提供数据并管理与视图相关的状态。</p><p id="1d18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">RegistrationViewModel</code>的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以更新<code class="fe nc nd ne nf b">Register</code>视图并利用我们新创建的<code class="fe nc nd ne nf b">RegistrationViewModel</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们的<code class="fe nc nd ne nf b">Register</code>视图现在简单多了，而<code class="fe nc nd ne nf b">RegistrationViewModel</code>负责维护视图的状态。我们已经移除了状态变量的单个片段，并用<code class="fe nc nd ne nf b">RegistrationViewModel</code>代替了它们。现在，每当用户更新<em class="lv">文本字段</em>时，视图模型就会自动更新。MVVM设计模式允许我们清晰地构建SwiftUI应用程序，同时使单元测试变得更容易。</p><p id="8d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您有嵌套的/子视图，并且您希望子视图更新父视图的状态。这是通过使用<em class="lv">捆绑</em>完成的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3d6e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">@绑定</h1><p id="1f95" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">SwiftUI中的单个视图可能由多个子视图组成。有时您希望允许子视图改变父视图的状态。绑定允许您将状态从父视图传递到子视图。一旦子视图改变了状态，父视图将自动获得更新的副本并重新呈现视图。让我们像以前一样实现相同的日/夜示例，但是这次我们将把<code class="fe nc nd ne nf b">Toggle</code>视图放入名为<code class="fe nc nd ne nf b">DayNightView</code>的子视图中。</p><p id="88ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">DayNightView</code>的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="64bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性包装器<code class="fe nc nd ne nf b">@Binding</code>表明<code class="fe nc nd ne nf b">isOn</code>属性将被传递给<code class="fe nc nd ne nf b">DayNightView</code>。一旦<code class="fe nc nd ne nf b">DayNightView</code>更改了<code class="fe nc nd ne nf b">isOn</code>属性，原始发送者将通过重新呈现视图得到通知。</p><p id="75e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分配<code class="fe nc nd ne nf b">isOn</code>属性将导致<code class="fe nc nd ne nf b">render</code>在父视图上被调用。</p><p id="11ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">父视图的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">DayNightView</code>将负责显示<code class="fe nc nd ne nf b">Toggle</code>开关。<code class="fe nc nd ne nf b">DayNightView</code>接受一个<code class="fe nc nd ne nf b">binding</code>作为参数。在上面的代码中，我们已经将<code class="fe nc nd ne nf b">@State</code>属性<code class="fe nc nd ne nf b">isOn</code>传递给了<code class="fe nc nd ne nf b">DayNightView</code>。这意味着当<code class="fe nc nd ne nf b">DayNightView </code>更新可绑定属性时，父视图中的状态属性<code class="fe nc nd ne nf b">isOn </code>也会得到更新。</p><p id="7a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">@Binding</code>的主要目的是将状态传递给子视图，在子视图中可以修改状态。这给了子视图一个与父视图交流和更新的机会。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2ab4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">@可观察到的和@观察到的</h1><p id="0489" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">大多数应用程序从外部获取数据，主要使用JSON Web API。一旦数据被下载，它就被填充到<em class="lv"> DTO对象</em>中，然后被映射到视图模型，最后显示在屏幕上。</p><p id="2fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用异步请求的一个常见问题是如何通知用户界面数据已经下载，视图必须刷新以显示新数据。SwiftUI通过引入<code class="fe nc nd ne nf b">Observable </code>和<code class="fe nc nd ne nf b">Observed</code>属性包装器解决了这个问题。</p><p id="5ec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入<code class="fe nc nd ne nf b">Observable</code>和<code class="fe nc nd ne nf b">Observed</code>之前，我们必须想办法执行一个<code class="fe nc nd ne nf b">async</code>请求来获取数据。为了简单起见，我们将发出一个假请求，并以<code class="fe nc nd ne nf b">async</code>的方式获得一个帖子列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ab37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，你可以看到<code class="fe nc nd ne nf b">Webservice</code>只需等待两秒钟，然后在完成处理程序中向用户发送一个帖子的硬编码列表。</p><p id="6db8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">Webservice</code>类被<code class="fe nc nd ne nf b">PostListViewModel</code>用来执行请求。<code class="fe nc nd ne nf b">PostListViewModel</code>的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">PostListViewModel</code>代表数据，将显示在发布列表屏幕上。需要注意的最重要的事情是使用了<code class="fe nc nd ne nf b">ObservableObject</code>协议，该协议允许类发布事件。<code class="fe nc nd ne nf b">posts</code>属性是用<code class="fe nc nd ne nf b">@Published</code>属性包装器修饰的，这意味着它的行为就像一个发布者。每当一个值被赋给<code class="fe nc nd ne nf b">posts</code>属性时，它就会发布一个事件，表明它已经被更改。</p><p id="e23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nc nd ne nf b">PostListView</code>使用<code class="fe nc nd ne nf b">PostListViewModel</code>获取并在视图中显示帖子，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行该应用程序，<code class="fe nc nd ne nf b">PostListView</code>将使用<code class="fe nc nd ne nf b">PostListViewModel</code>并在<code class="fe nc nd ne nf b">List</code>视图中填充帖子列表。MVVM设计模式以及发布和通知变更的能力使得视图与视图模型的同步变得更加容易。</p><p id="ff7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我们只讨论了本地状态，它表示特定视图维护和可用的状态。如果您需要从另一个视图中改变视图的状态，您可以将其作为一个参数传递，并使用<code class="fe nc nd ne nf b">@Binding</code>属性包装器。如果您只在几个视图之间传递状态，这种方法很有效，但是当涉及到几个视图时，这很快就会变成一个麻烦。</p><p id="ba81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将查看<em class="lv">全局状态</em>，它可以从任何SwiftUI视图中访问。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ff3c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">@环境对象</h1><p id="f5a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe nc nd ne nf b">EnvironmentObject</code>的概念和<code class="fe nc nd ne nf b">Redux</code>很像。<code class="fe nc nd ne nf b">EnvironmentObject</code>的主要目的是维护<em class="lv">全局状态</em>。全局状态是可以从任何视图访问的状态。<code class="fe nc nd ne nf b">EnvironmentObject</code>通常在顶层视图中注入，使全局状态对所有子视图可用。</p><p id="2496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化示例，我们将创建一个名为<code class="fe nc nd ne nf b">UserSettings</code>的类，它将在多个视图之间共享。我们将实现三种不同的视图，即<code class="fe nc nd ne nf b">Facebook</code>、<code class="fe nc nd ne nf b">Twitter</code>和<code class="fe nc nd ne nf b">TotalLikes</code>。<code class="fe nc nd ne nf b">Facebook</code>和<code class="fe nc nd ne nf b">Twitter</code>视图将允许用户增加喜欢和<code class="fe nc nd ne nf b">TotalLikes</code>将负责显示总喜欢。</p><p id="f165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">UserSettings</code>类的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e6b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">UserSettings</code>类正在使用<code class="fe nc nd ne nf b">ObservableObject</code>协议。在<code class="fe nc nd ne nf b">UserSettings</code>类中唯一的属性是<code class="fe nc nd ne nf b">likes</code>，它用一个<code class="fe nc nd ne nf b">@Published</code>属性包装器来修饰，表明它将作为一个发布者，并在值改变时通知订阅者。</p><p id="ad5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用<code class="fe nc nd ne nf b">UserSettings</code>之前，我们需要将其注入到父视图中。打开<code class="fe nc nd ne nf b">SceneDelegate.swift</code>并执行以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c81b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe nc nd ne nf b">UserSettings</code>对象将对<code class="fe nc nd ne nf b">ContentView</code>和<code class="fe nc nd ne nf b">ContentView</code>内部的所有视图可用。接下来，我们将实现如下所示的<code class="fe nc nd ne nf b">Facebook</code>和<code class="fe nc nd ne nf b">Twitter</code>视图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是<code class="fe nc nd ne nf b">@EnvironmentObject</code>属性包装器的用法。将从父视图中自动填充<code class="fe nc nd ne nf b">UserSettings</code>实例。当您增加<code class="fe nc nd ne nf b">likes</code>属性时，它将为所有对<code class="fe nc nd ne nf b">UserSettings</code>全局状态感兴趣的视图全局增加。</p><p id="e314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对全局状态的更新也将导致视图再次自动呈现。</p><p id="0423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">TotalLikes</code>视图负责显示<code class="fe nc nd ne nf b">likes</code>的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ef8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nc nd ne nf b">Twitter</code>和<code class="fe nc nd ne nf b">Facebook</code>视图在<code class="fe nc nd ne nf b">ContentView</code>中使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="02a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/9c5a7013dc3c8017cbca9a717ba3dcbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/1*XX4Qt5uo-YXW_biFLDAaQA.gif"/></div></figure><p id="a693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！</p></div></div>    
</body>
</html>