<html>
<head>
<title>TypeScript: Start a Browser-based Project Using the System.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:使用System.js启动基于浏览器的项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-start-a-browser-based-project-use-the-system-js-b4ddfe63a1b4?source=collection_archive---------0-----------------------#2021-11-27">https://betterprogramming.pub/typescript-start-a-browser-based-project-use-the-system-js-b4ddfe63a1b4?source=collection_archive---------0-----------------------#2021-11-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b26" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建您自己的基于浏览器的web应用程序。不需要服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d25945b8e61f50005bf690fb0462dda0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMF70hcBugHbK0jdXGDbuw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="8634" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">摘要</h1><p id="a543" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">来自其他背景，想快速开始玩TypeScript？您很可能会在尝试创建一个简单的基于浏览器的项目时遇到一些麻烦——对于纯JavaScript世界来说，这看起来就像是小菜一碟:只是一个样式表和一个JavaScript文件，在一个HTML文件中链接起来。</p><p id="b19f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然而，尝试用TypeScript做一些类似的事情需要更多的努力，特别是如果您对如何处理一些非常基本的概念还不够熟悉的话。</p><p id="01bf" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">模块管理系统是非常基本的概念之一，您应该能够在项目的配置设置中做出适当的选择。</p><p id="3368" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">目标是在TypeScript项目中开始使用TypeScript文件(=模块)，使用(新的)标准方式——而不用担心<code class="fe mr ms mt mu b">JavaScript</code>向后兼容性问题。这篇文章的目的是增加一些理解。</p><p id="5321" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这篇文章还为那些有一些编程知识(例如JavaScript)和喜欢从TypeScript (OOP、严格类型等)的功能中受益的人提供了一个最基本的标准解决方案。).</p><p id="fb2e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因此，如果有人想开始玩TypeScript，并且他正在寻找一种快速的方法来实现一个简单的TypeScript项目，它只在浏览器中运行，那么这篇文章对这个过程有一点启发。</p><h1 id="def8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">JavaScript模块中的简介</h1><p id="8b7a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">JavaScript世界中的模块是应用程序开发过程的重要组成部分。</p><p id="1c6a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">对于TypeScript也是如此。如果你有OOP背景(比如Java)，你可能会发现Java中的类和JavaScript/TypeScript中的模块有相似之处(甚至Java中的类应该只存在于一个文件中)。例如，它们都有自己的作用域，并包含函数和属性。</p><p id="814d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然而，在ECMAScript (JavaScript) arena中，当我们想要从另一个文件中访问一个对象(例如一个类)时，我们必须使用<code class="fe mr ms mt mu b">exports</code>和<code class="fe mr ms mt mu b">imports</code>通过<code class="fe mr ms mt mu b">module</code>系统。当我们想要共享代码(变量、类、接口、对象等)时也是如此。)从一个文件到另一个文件。</p><p id="f524" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">由于TypeScript是JavaScript的超集，它还必须处理导出和导入。这是可以的。</p><p id="9faa" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然而，当谈到JavaScript和浏览器的向后兼容性时，挑战就来了。这是因为旧版本的JavaScript不使用“导出”和“导入”,而是分别使用“模块”和“要求”。</p><p id="9e63" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因此，当我们开发TypeScript应用程序时，而且当我们希望它们在旧的浏览器中使用时，我们必须通知<code class="fe mr ms mt mu b">tsc</code>编译器。</p><p id="2fb2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为此，我们必须在<a class="ae mv" href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" rel="noopener ugc nofollow" target="_blank"> tsconfig.json </a>文件中使用适当的设置。一般来说，<code class="fe mr ms mt mu b">tsconfig.json</code>文件是项目的key typescript设置的主要配置文件。(这里可以阅读更多<a class="ae mv" href="https://www.typescriptlang.org/tsconfig" rel="noopener ugc nofollow" target="_blank">)。</a></p><h1 id="b412" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">tsconfig.json中的模块设置</h1><p id="6d78" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为tsconfig.json中的module option (key)设置适当的值，指导<code class="fe mr ms mt mu b">tsc</code>编译器如何处理我们项目的不同模块。</p><p id="b713" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">ECMAScript 2015引入了模块概念。模块在自己的作用域内执行，而不是在全局作用域内执行；这意味着变量、函数、类等。在模块中声明的在模块外部不可见，除非它们被显式导出。</p><p id="ad0d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果另一个模块想要使用从另一个模块导出的函数、变量、类等等，那么它必须导入它。任何包含顶级导入或导出的文件都被视为一个模块。</p><p id="5584" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在内部，在运行时，Node.js使用模块加载机制，该机制负责在执行模块之前定位和执行模块的所有依赖项。<br/>common js模块规范是Node.js中使用模块的默认设置。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="bbfa" class="na kz it mu b gy nb nc l nd ne">"module": "commonjs",                                /* Specify what module code is generated. */</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ce416a11d122e3dcd1f981f3a2802d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IG7efNtmDZ9VH10czDDVIw.png"/></div></div></figure><p id="ba90" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><code class="fe mr ms mt mu b">module</code>选项的其他设置有无、ES6或ES2015、ES2020、UMD、AMD、系统和ESNext。</p><p id="8d96" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">一般来说，<code class="fe mr ms mt mu b">“module”: “commonjs”</code>设置是可以的，它针对任何在浏览器之外运行的Node.js项目，例如，在服务器上。服务器端实际上是Node.js运行时系统的主要环境。</p><p id="ee54" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">你可以在这里找到关于如何在你的Mac <a class="ae mv" href="https://www.devxperiences.com/pzwp1/2021/04/08/installing-typescript-via-node-and-start-using-it-via-vs-code-macos/" rel="noopener ugc nofollow" target="_blank">上“默认(基于服务器的)方式”安装TypeScript的非常基础的介绍。因此，请记住，这些设置不适合运行在客户端(即在浏览器中)的相对简单的项目。</a></p><p id="9723" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我不打算就此谈更多细节。你可以在这里和这里查看官方文档<a class="ae mv" href="https://www.typescriptlang.org/tsconfig#module" rel="noopener ugc nofollow" target="_blank">。当然，你可以谷歌一下，找到数十、数百篇关于上述主题的帖子和文章。</a></p><p id="c7d4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">由于<code class="fe mr ms mt mu b">tsc</code>编译器传输一个<code class="fe mr ms mt mu b">.ts</code>文件，并在一个<code class="fe mr ms mt mu b">.js</code>文件中发出它，可以预期这个过程应该非常简单。</p><p id="e620" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当我们开始添加更多时，这个过程变得越来越复杂。ts或者。js文件，而且当我们将它们作为模块使用，并开始在它们之间导出和导入对象时。除了使用增加数量的(排放)之外。js文件需要许多<code class="fe mr ms mt mu b">&lt;script&gt;</code>标签的副本，还有其他副作用(例如，加载延迟、命名冲突、<a class="ae mv" href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" rel="noopener ugc nofollow" target="_blank"> CORS </a>问题等)。).</p><p id="9663" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">应对这些挑战的工具开始被使用，并被广泛采用。包装器、打包器、迷你器是迄今为止被认为是Node.js项目开发的重要组成部分的工具。<a class="ae mv" href="https://browserify.org/" rel="noopener ugc nofollow" target="_blank">浏览</a>，<a class="ae mv" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">包裹</a>，<a class="ae mv" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank">汇总</a>，<a class="ae mv" href="https://fuse-box.org/" rel="noopener ugc nofollow" target="_blank">保险丝盒</a>，<a class="ae mv" href="https://brunch.io/" rel="noopener ugc nofollow" target="_blank">早午餐</a>，<a class="ae mv" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>，<a class="ae mv" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> ESBuild </a>等。是这些工具的一些著名代表。</p><p id="47a2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">正如我们所说的，我们的目的是让我们的开始项目尽可能简单，我们不打算使用上面提到的捆绑器。你可以在网上搜索，你会找到很多关于他们的详细信息。在这篇文章中没有更多关于这些工具的内容。</p><p id="f2e5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这里我们将使用<code class="fe mr ms mt mu b"><a class="ae mv" href="https://github.com/systemjs/systemjs" rel="noopener ugc nofollow" target="_blank">System.js</a></code>作为我们的节点模块管理机制。</p><p id="9477" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">正如你在GitHub <a class="ae mv" href="https://github.com/systemjs/systemjs" rel="noopener ugc nofollow" target="_blank">这里看到的</a>“<em class="ng">system js是一个可挂钩的、基于标准的模块加载器。它提供了一个工作流，其中为浏览器中的本机es模块的生产工作流编写的代码</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/ffcf56814e84a73d9b35a3bba02d6b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThMVhkXLn2vsVFJKM9vxKQ.png"/></div></div></figure><p id="c5d2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它将(新)标准(ES2015/ES6)通过导入导出格式(以及其他流行的格式，如CommonJS、UMD、AMD)处理模块的方式转换为更老的<code class="fe mr ms mt mu b"><a class="ae mv" href="https://github.com/systemjs/systemjs/blob/main/docs/system-register.md" rel="noopener ugc nofollow" target="_blank">System.register</a></code>模块格式(ES5)。</p><p id="5a92" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">注意，<code class="fe mr ms mt mu b">System.js</code>是一个运行时加载器，这实际上意味着它“动态”加载转换成<code class="fe mr ms mt mu b">System.register</code>格式的模块。它可以被认为是一种模块格式，旨在支持旧版本ES5中ES6模块的精确语义。</p><p id="4db1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">实际上，我们可以通知浏览器我们使用了<code class="fe mr ms mt mu b">System.register</code>格式。我们通过使用最少的JavaScript代码开销通过<code class="fe mr ms mt mu b">&lt;script&gt;</code>标签来实现，这些标签应该在我们加载项目传输文件之前加载。我们将在以后的实践中看到它。</p><p id="b2d2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">除此之外，我们不得不说<code class="fe mr ms mt mu b">System.js</code>也可以被认为是一个<code class="fe mr ms mt mu b">bundler</code>并且它应该被认为是这样的，因为它可以将我们文件的所有导入-导出对象“捆绑”在一起，我们将在后面看到。</p><p id="c2ff" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><code class="fe mr ms mt mu b">System.js </code>可能是一个更好的解决方案，不仅因为允许我们使用发出的TypeScript。js文件(正如我们所知的‘普通’文件。js文件)，但是当我们建立一个新的TypeScript项目(在<code class="fe mr ms mt mu b">tsconfig.json</code>文件中)时，它也是“提供的”选项(值)之一。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/4eb47153e4ee873ec330d5295663c602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B20ytENeOTc1w9ibp1pLjQ.png"/></div></div></figure><p id="6ce8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">所以。我们把它当成自己的选择，继续吧。对于我们的简单项目，应该遵循的主要步骤是:</p><p id="4d20" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="ng">注意:假设您已经在系统中安装了Node.js / npm，并且对npm有所了解。如果你还没有安装，你可以使用这篇文章在你的Mac上安装它。</em></p><h2 id="05a2" class="na kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">A.创建您的工作项目目录</h2><p id="0924" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们将项目文件夹命名为“ts-browser”:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="b2f9" class="na kz it mu b gy nb nc l nd ne">mkdir tsbrowser<br/>cd tsbrowser</span></pre><h2 id="23ae" class="na kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">B.为您的项目创建一个工作文件夹文件结构(脚手架)</h2><p id="824a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">因为我们的目的也是能够使用不同的文件/模块(看一个实用而简单的导出-导入的例子)，一个好的方法是创建和使用项目的一个适当的文件夹/子文件夹结构(支架)。开始时，只需创建经典的index.html和style.css文件。</p><p id="ea97" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="ng">NB:</em><a class="ae mv" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"><em class="ng">VS Code</em></a><em class="ng">是一款优秀、流行、免费的IDE，可以与之合作。在这里我们使用它。</em></p><p id="2a89" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">出于演示目的，在<code class="fe mr ms mt mu b">index.htm</code>文件中添加以下几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="905e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">请注意，带有<code class="fe mr ms mt mu b">id=”app”</code>的div元素将是我们的TypeScript源代码的链接点，稍后会看到这一点。</p><p id="9923" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这里是<code class="fe mr ms mt mu b">style.css</code>文件(选择任何设置，如颜色等。):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e79e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">您可以在浏览器中测试它们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/15f52bee023569f8d4db54d08e31b348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkH9QM5gejizICkBy0RC3Q.png"/></div></div></figure><p id="f80c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">之后，创建一个新的子文件夹，命名为<code class="fe mr ms mt mu b">src</code>。跳进去，创建一个<code class="fe mr ms mt mu b">index.ts</code>文件。这可以认为是我们app的出发点。然后创建一个子文件夹，命名为<code class="fe mr ms mt mu b">app</code>，并在其中创建另一个子文件夹<code class="fe mr ms mt mu b">modules</code>。</p><p id="e834" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">之后，在<code class="fe mr ms mt mu b">modules</code>子文件夹中创建一个新的TypeScript文件，将其命名为<code class="fe mr ms mt mu b">myfunctions.ts</code>。我们稍后会更新它们。</p><p id="49e6" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">项目脚手架应该是这样的:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="434f" class="na kz it mu b gy nb nc l nd ne">.<br/>|-- index.html<br/>|-- src<br/>|   |-- app<br/>|   |   `-- modules<br/>|   |       `-- myfunctions.ts<br/>|   `-- index.ts<br/>`-- style.css</span></pre><h2 id="2d82" class="na kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">C.启动Node.js项目(应用程序)</h2><p id="acb9" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">使用互动方式，让您回答一些关于项目主要选项(名称等)的问题:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="633d" class="na kz it mu b gy nb nc l nd ne">npm init</span></pre><p id="e14d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">或者保留默认值:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="e809" class="na kz it mu b gy nb nc l nd ne">npm init — y</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/eb8be8eccc4fb6d1ff00239273f114b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtEtrKPcxRa9eq0ztwRyHg.png"/></div></div></figure><p id="e90d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这创建了一个非常基本(也是非常初始)的package.json文件。</p><h2 id="ee3d" class="na kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">D.安装TypeScript</h2><p id="6154" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">即使您已经在系统中全局地安装了它，您也可能认为将它作为开发依赖项安装是一个好方法，这也允许您安装和使用更好的或最新版本的TypeScript。</p><p id="8959" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">下面，我们安装最新(默认)版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/65bd51472f59486a9af1804b1351fab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WeVqAzg_t4JZaq9X7aTdlA.png"/></div></div></figure><p id="4918" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">检查全局安装的不同版本的TypeScript:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/e12bba1bb17b3b3aae4e37894e0ed387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U23GAWtgAguXR04Y.png"/></div></div></figure><p id="d80c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">对于我们项目中安装的TypeScript(本地安装):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/dbb249afbec7ae201c47b526821d1437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*96JbmpybQuaHPrR0.png"/></div></div></figure><h2 id="a720" class="na kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">E.启动项目的类型脚本配置</h2><p id="3964" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">您可以使用<code class="fe mr ms mt mu b">npx tsc –init</code>命令创建一个非常基本的带有默认设置的tsconfig.json文件，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/485e24ed77b3879c8bc107adfe8e4d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pjPUDmuD9_S0MxFq.png"/></div></div></figure><p id="92bb" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这将创建项目<code class="fe mr ms mt mu b">tsconfig.json</code>文件。</p><h2 id="a82b" class="na kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">F.调整tsconfig.json设置以反映我们的项目</h2><p id="72c1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">下面是允许我们的项目在浏览器中正确有效运行的最低基本设置。</p><p id="b229" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">正如我们已经说过这是一个基于浏览器的项目，使用系统(而不是默认的<code class="fe mr ms mt mu b">commonjs</code>)。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="b6e2" class="na kz it mu b gy nb nc l nd ne"><strong class="mu iu">“module”:</strong> “System”<strong class="mu iu">,</strong></span></pre><p id="4700" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在库部分添加es2016和DOM，因为我们希望能够使用和操作浏览器的DOM对象</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="0738" class="na kz it mu b gy nb nc l nd ne"><strong class="mu iu">“lib”:</strong> <strong class="mu iu">[</strong>“es2016”<strong class="mu iu">,</strong>”DOM”<strong class="mu iu">],</strong></span></pre><p id="a106" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">将我们之前创建的<code class="fe mr ms mt mu b">src</code>子文件夹定义为保存所有源TypeScript文件的文件夹。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="1e85" class="na kz it mu b gy nb nc l nd ne"><strong class="mu iu">“rootDir”:</strong> “src”<strong class="mu iu">,</strong></span></pre><p id="b65d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">定义transpiled的输出文件夹。js文件。该文件夹将在第一次编译后创建。我们将这个文件夹命名为<code class="fe mr ms mt mu b">build</code>。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="3848" class="na kz it mu b gy nb nc l nd ne"><strong class="mu iu">“outDir”:</strong> “build”<strong class="mu iu">,</strong></span></pre><p id="d0dd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">下面是一个重要的设置，它清楚地表明了<code class="fe mr ms mt mu b">System.js</code>如何捆绑在一个文件中，即整个项目代码。我们将这个文件命名为<code class="fe mr ms mt mu b">bundle.js</code>:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="4e1e" class="na kz it mu b gy nb nc l nd ne"><strong class="mu iu">“outFile”:</strong> “./build/bundle.js”<strong class="mu iu">,</strong></span></pre><p id="89d2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为输出/发射启用源映射也很好。用于调试目的的js文件。</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="1392" class="na kz it mu b gy nb nc l nd ne">“sourceMap”: true,</span></pre><h2 id="47ea" class="na kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">G.添加类型脚本代码</h2><p id="8ad6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将使用下面的片段作为我们如何使用模块导出-导入机制的简单演示。在<code class="fe mr ms mt mu b">src/app/modules/myfunction.ts</code>文件中添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2b79" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">上面的源代码只是演示了我们如何导出一个函数(<code class="fe mr ms mt mu b">capitalizeFirst</code>函数)并使它对其他源文件可用。它只是导出一个将句子的第一个字符大写的函数。</p><p id="734c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在<code class="fe mr ms mt mu b">index.ts</code>文件中添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="678f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">上面的代码使用了<code class="fe mr ms mt mu b">capitalizeFirst</code>函数(导入它)，该函数之前在<code class="fe mr ms mt mu b">./app/modules/myfunctions.ts</code>文件中导出。</p><p id="6be6" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后用<code class="fe mr ms mt mu b">id=”app”</code>创建div元素的一个对象，它是。html文件，正如我们已经提到的。</p><p id="8b19" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">之后，它操纵它(添加一个新的div元素并输出文本)，最后将其输出回浏览器文档(在<code class="fe mr ms mt mu b">index.html</code>文件中)。</p><p id="ee0a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当它运行时，我们期望看到文本<code class="fe mr ms mt mu b">“TypeScript is awesome!</code>，是时候使用它了！白色背景上的红色线条。</p><p id="365c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在我们准备编译。</p><h2 id="ae2d" class="na kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">G.编制</h2><p id="d364" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">只为我们的项目运行<code class="fe mr ms mt mu b">tsc</code>编译器(“本地”):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/418a541c4e0766962fc542272ae7d162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cxh0y9TY-kNMdEiX.png"/></div></div></figure><p id="73f0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">注意，我们使用<code class="fe mr ms mt mu b"><a class="ae mv" href="https://docs.npmjs.com/cli/v7/commands/npx" rel="noopener ugc nofollow" target="_blank">npx</a></code>命令来运行本地安装的<code class="fe mr ms mt mu b">tsc</code>编译器(<code class="fe mr ms mt mu b">tsc</code>包)。(使用<code class="fe mr ms mt mu b">npx</code>的效果与我们使用完整路径<br/> <code class="fe mr ms mt mu b">./node_modules/.bin/tsc</code>运行<code class="fe mr ms mt mu b">tsc</code>命令的效果相同)</p><p id="0488" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">检查生成的输出(构建)文件夹。</p><p id="d031" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">应该是下面这样的:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="fecd" class="na kz it mu b gy nb nc l nd ne">.<br/>|-- build<br/><strong class="mu iu">|</strong>   |-- bundle.js<br/><strong class="mu iu">|</strong>   `-- bundle.js.map<br/>|-- index.html<br/>|-- node_modules<br/>|-- package-lock.json<br/>|-- package.json<br/>|-- src<br/><strong class="mu iu">|</strong>   |-- app<br/><strong class="mu iu">|</strong>   <strong class="mu iu">|</strong>   `-- modules<br/><strong class="mu iu">|</strong>   <strong class="mu iu">|</strong>       `-- myfunctions.ts<br/><strong class="mu iu">|</strong>   `-- index.ts<br/>|-- style.css<br/>`-- tsconfig.json</span></pre><p id="3fd4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在检查构建文件夹中生成的<code class="fe mr ms mt mu b">bundle.js</code>。应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f18d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如你所见，它将我们项目的所有源代码捆绑在一个文件中。请注意这里使用的匿名函数语法:<code class="fe mr ms mt mu b">System.register(…) {}</code>。</p><p id="7d9e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这实际上就是<code class="fe mr ms mt mu b">System.js</code>如何传输我们的模块共享(导出/导入)。</p><h2 id="f17d" class="na kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">一.更新index.html档案</h2><p id="0ed3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在是时候将我们发出的代码应用到我们的HTML文档了。通常，一个模块(类似于纯JavaScript代码文件)可以应用于HTML文档，将它封装在<code class="fe mr ms mt mu b">&lt;script&gt;</code>标签中，并用<code class="fe mr ms mt mu b">type=”module”</code>属性声明它。示例:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="12bc" class="na kz it mu b gy nb nc l nd ne"><strong class="mu iu">&lt;</strong>script <strong class="mu iu">type</strong>=”<strong class="mu iu">module</strong>” src=”myfunction.js”<strong class="mu iu">&gt;&lt;</strong>/script<strong class="mu iu">&gt;</strong></span></pre><p id="1319" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">将我们的<code class="fe mr ms mt mu b">bundle.js</code>文件应用到我们的<code class="fe mr ms mt mu b">index.htm</code>文档离上面的语法不远了。</p><p id="abc0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然而，我们必须设法通知浏览器如何处理<code class="fe mr ms mt mu b">System.register(…) {}</code>。而这正是System.js给我们提供的。</p><p id="f7b4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">“产品”(在大多数简单的情况下)只包含2。<code class="fe mr ms mt mu b">System.js</code>提供的js文件。</p><p id="9ce2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">第一个是系统加载器，第二个是命名寄存器模块(这实际上使得<code class="fe mr ms mt mu b">System.register</code> sysntax“可以理解”)。</p><p id="bb8c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">两者都有“轻量级”版本，非常适合我们的简单项目。这是文件<code class="fe mr ms mt mu b">s.js</code>和<code class="fe mr ms mt mu b">named-register.min.js</code>。</p><p id="eab0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我不打算谈论更多的技术细节，但是如果你愿意，你可以看看官方文档<a class="ae mv" href="https://github.com/systemjs/systemjs" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae mv" href="https://github.com/systemjs/systemjs/blob/main/docs/system-register.md" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="2163" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">所有可用的选项都包含在<code class="fe mr ms mt mu b">system.js</code>包中，可以使用我们的节点包管理器将其安装到我们的项目中，例如:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="5efe" class="na kz it mu b gy nb nc l nd ne">npm i -D systemjs @types/systemjs</span></pre><p id="0a2e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">安装后，您可以检查您的package.json是否已经更新:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/0099f7868580f20f7ed75f111f44c486.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*aufDCTZkkpZeUmYu.png"/></div></figure><p id="00f6" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">并且<code class="fe mr ms mt mu b">systemjs</code>包已经被本地安装在您的项目<code class="fe mr ms mt mu b">node_packages</code>子文件夹中。然后我们可以像这样将它们应用到我们的<code class="fe mr ms mt mu b">index.html </code>文档中:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="924c" class="na kz it mu b gy nb nc l nd ne"><strong class="mu iu">&lt;script</strong> src=”node_modules/systemjs/dist/s.js”<strong class="mu iu">&gt;&lt;/script&gt;<br/>&lt;script</strong> src=”node_modules/systemjs/dist/extras/named-register.min.js”<strong class="mu iu">&gt;&lt;/script&gt;</strong></span></pre><p id="8214" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然而，一种常用的替代方法是在运行时直接从一个免费的节点包<a class="ae mv" href="https://en.wikipedia.org/wiki/Content_delivery_network" rel="noopener ugc nofollow" target="_blank"> CDN </a>服务中获取它们，比如<a class="ae mv" href="https://unpkg.com/" rel="noopener ugc nofollow" target="_blank"> UNPKG </a>或<a class="ae mv" href="https://jspm.org/" rel="noopener ugc nofollow" target="_blank"> JSPM </a>。因此，您可以避免在本地安装<code class="fe mr ms mt mu b">systemjs</code>包。直接从CDN上抓取。这里我使用了UNPKG服务。</p><p id="7b4e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在是时候在我们的index.html文件中添加一些必要的脚本标签了。在主体结束标记<code class="fe mr ms mt mu b">&lt;/body&gt;</code>前添加以下行:</p><pre class="kj kk kl km gt mw mu mx my aw mz bi"><span id="5d9a" class="na kz it mu b gy nb nc l nd ne">. . .<br/><strong class="mu iu">&lt;script</strong> src="https://unpkg.com/systemjs@6.11.0/dist/s.js"<strong class="mu iu">&gt;&lt;/script&gt;<br/>&lt;script</strong> src="https://unpkg.com/systemjs@6.11.0/dist/extras/named-register.min.js"<strong class="mu iu">&gt;&lt;/script&gt;<br/>&lt;script</strong> src="bundle.js"<strong class="mu iu">&gt;&lt;/script&gt;<br/>&lt;script</strong> type="module"<strong class="mu iu">&gt;<br/></strong>System.import('index');<br/><strong class="mu iu">&lt;/script&gt;<br/></strong>. . .</span></pre><p id="ea99" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当然，最后一步是在我们的浏览器中加载<code class="fe mr ms mt mu b">index.html</code>。这是它现在的样子；这也是人们所期望的样子；</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/39d32ce28e44267b8295471a52c1686b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brAgxnpg2XOl26BnVAJSlA.png"/></div></div></figure><p id="03d5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在你的基于浏览器的应用已经准备好了。不需要服务器。您可以“带走”它，将它部署到任何地方。你只需要这些文件:<code class="fe mr ms mt mu b">index.html</code>、<code class="fe mr ms mt mu b">style.css</code>和<code class="fe mr ms mt mu b">build/bundle.js</code>。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h1 id="6e1c" class="ky kz it bd la lb of ld le lf og lh li jz oh ka lk kc oi kd lm kf oj kg lo lp bi translated">包裹</h1><p id="cc74" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">你可以去GitHub <a class="ae mv" href="https://github.com/zzpzaf/tsbrowser" rel="noopener ugc nofollow" target="_blank">的我的repo获取这个项目，这里</a>——你会找到所有的源代码以及配置设置(<code class="fe mr ms mt mu b">tsconfig.json</code>等等。).</p><p id="52d3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">就是这样！如果你发现问题或者缺少什么，请告诉我。尽情享受，敬请关注。感谢阅读！</p></div></div>    
</body>
</html>