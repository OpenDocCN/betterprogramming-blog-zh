<html>
<head>
<title>Learn Angular &amp; RxJS: Countdown Timer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习角度和RxJS:倒计时定时器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lets-build-rxjs-countdown-in-angular-5768c8b158b8?source=collection_archive---------1-----------------------#2019-06-08">https://betterprogramming.pub/lets-build-rxjs-countdown-in-angular-5768c8b158b8?source=collection_archive---------1-----------------------#2019-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fcb5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用RxJS创建一个简单的倒计时app</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff71df21633598150164c0829f84da3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RR8oubeQOm63YN90Uth0CA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae ky" href="https://unsplash.com/search/photos/timer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经用Angular构建了一个示例倒计时应用程序。我们的应用程序将能够使用RxJS维护状态、启动、暂停和重置。这将帮助我们学习RxJS概念，我们可以在其他应用程序中重用这些概念。</p><p id="d249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，下载<a class="ae ky" href="https://github.com/Everduin94/countdown-rxjs" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><blockquote class="lv lw lx"><p id="bc28" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><code class="fe mc md me mf b">master</code>分支是完整的解决方案。在<code class="fe mc md me mf b">follow-along</code>分支中，文章中带标签的代码片段已经被删除。我已经在源代码中放置了每个代码片段标签，因此可以很容易地找到它们。参见<code class="fe mc md me mf b">README.md</code>获取说明。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/434a19eb89de37a42c61385826e81da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71dSXOXIR1n4gEXb6LjgJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用</p></figure><h1 id="f699" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">应用概述</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用组件概述</p></figure><p id="da8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">app-countdown/countdown.component.ts</code>将代表我们的时钟，以及开始、暂停和复位按钮。</p><p id="af71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">app-time-input/time-input.component.ts</code>将代表我们输入秒、分和小时的三个输入。</p><p id="3792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">appInputToCountdown/input-to-countdown.directive.ts</code>将负责<code class="fe mc md me mf b">countdown.component</code>和<code class="fe mc md me mf b">time-input.component</code>之间的通信。这就是我们如何从输入中接收以秒为单位的总时间，并在倒计时中显示它。</p><p id="11c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">time-format.pipe.ts</code>将我们的总秒数转换成时间格式的字符串。</p><h1 id="41bd" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">用行为主体管理状态</h1><p id="96f2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们的指令<code class="fe mc md me mf b">input-to-countdown.directive.ts</code>将利用RxJS行为主体来管理我们的状态。管理状态仅仅意味着记录我们的秒、分、小时和总秒数。</p><h2 id="b4c3" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated"><strong class="ak">关键概念#1:保护受试者免受大量访问/修改</strong></h2><p id="931a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">一个行为主体是一个有初始值的主体<a class="ae ky" href="http://reactivex.io/documentation/subject.html" rel="noopener ugc nofollow" target="_blank">【1】</a>。我们将我们的行为主体<code class="fe mc md me mf b">state</code> <strong class="lb iu">保持私有</strong>，将其可观察的<code class="fe mc md me mf b">obs$</code>公开为<strong class="lb iu">公共</strong>。这保护了<code class="fe mc md me mf b">state</code>免于大规模修改，同时允许其他组件通过<code class="fe mc md me mf b">obs$</code>监听来自<code class="fe mc md me mf b">state</code>的排放。<a class="ae ky" href="https://en.wikipedia.org/wiki/Information_hiding" rel="noopener ugc nofollow" target="_blank">【2】</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.1 | inputtocountdown . directive . ts |跟进</p></figure><p id="16bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe mc md me mf b">time-input.component</code>中的一个输入值改变时，将调用<code class="fe mc md me mf b">updateState(value, command)</code>。更新<code class="fe mc md me mf b">state</code>也会触发<code class="fe mc md me mf b">obs$</code>的发射。这是我们实践中的第一个关键概念。我们将我们的主题限制在最低限度，并开放我们可观察到的森林排放。</p><h2 id="5429" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated"><strong class="ak">关键概念#2:保持受试者数据整洁</strong></h2><p id="b615" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">参数<code class="fe mc md me mf b">command</code>通知我们哪个输入在秒、分钟和小时之间发生了变化。我们将把输入值转换成一个整数，并确保它是一个正数以保持数据干净，然后得到当前值<code class="fe mc md me mf b">state</code>作为<code class="fe mc md me mf b">update</code>。请注意，我们的主题只能通过<code class="fe mc md me mf b">updateState()</code>更新。<strong class="lb iu">我们在输入数据的单个修改点对其进行验证，以确保数据干净。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.2 | inputtocountdown . directive . ts |跟进</p></figure><p id="f970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">update</code>将被修改以包含输入的最新变化，并重新计算<code class="fe mc md me mf b">calculateSeconds(update)</code>中的总秒数。然后我们通过<code class="fe mc md me mf b">this.state.next(update)</code>更新<code class="fe mc md me mf b">state</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.3 | inputtocountdown . directive . ts |跟进</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/3b6ce1248fb5c2ea78ccd1098f3d668c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvWFsRz-VwgdhXBpiz94Yg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新状态</p></figure><h1 id="6f94" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">将事件和状态绑定到输入</h1><p id="ce29" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们将把我们的指令注入到<code class="fe mc md me mf b">time-input.component.ts</code>中。我们所有的逻辑都在<code class="fe mc md me mf b">time-input.component.html</code>中调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">组件注入指令</p></figure><p id="d2af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键细节是我们的变更事件。当我们的一个输入触发一个变更事件时，我们的指令将调用<code class="fe mc md me mf b">updateState(value,command)</code>。换句话说，我们已经绑定了每个输入，以便在一个变更事件上更新我们的状态。</p><p id="ca72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">提示:通过标记我们的输入，我们可以通过</strong> <code class="fe mc md me mf b"><strong class="lb iu">name.value</strong></code>而不是<code class="fe mc md me mf b">$event.target.value</code>访问它的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2.1 | time-input.component.html |后续</p></figure><h1 id="9a1b" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">开始、暂停和重置观察值</h1><p id="9ec5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">下面的代码片段包含了很多信息。我们将通过RxJS操作符的使用来分解它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3.1 | countdown.component.ts |跟进</p></figure><h2 id="2cf3" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">映射到/合并</h2><p id="656f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe mc md me mf b">mapTo</code>获取我们发出的值，并将其转换为我们作为参数传入的任何值。在我们的应用程序中，我们将更改事件和点击事件转换为真/假/空值。<a class="ae ky" href="http://reactivex.io/documentation/operators/map.html" rel="noopener ugc nofollow" target="_blank">【3】</a></p><h2 id="afde" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated"><strong class="ak">关键概念#3:利用单个可观察对象推广简单的订阅管理策略</strong></h2><p id="c4af" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe mc md me mf b">merge</code>将把我们的四个可观测值合并成一个可观测值<a class="ae ky" href="http://reactivex.io/documentation/operators/merge.html" rel="noopener ugc nofollow" target="_blank">【4】</a>。Merge一次只会发出一个值。<code class="fe mc md me mf b">intervalObs$</code>现在将根据发生的事件发出真、假或空。<strong class="lb iu">注意:我们所有的事件观察将由一个订阅和一个异步管道管理。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分解pt 1 | countdown.component.ts</p></figure><h2 id="906d" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">切换地图</h2><p id="db48" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe mc md me mf b">switchMap</code>允许我们根据原始可观察对象的输入，从新的可观察对象开始发射。我们最初的可观测性是所有可能触发变化(开始、暂停、重置、状态变化)的事件的合并。我们新的可观测值要么是零的可观测值，要么是区间，要么是空的可观测值。请注意，当事件发生时，我们的原始可观测值仍然会发出。<a class="ae ky" href="http://reactivex.io/documentation/operators/flatmap.html" rel="noopener ugc nofollow" target="_blank">【5】</a></p><h2 id="5f44" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">扫描</h2><p id="6281" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe mc md me mf b">scan</code>有累加器和电流值。累加器跟踪所有发出的值。在我们的例子中，我们只是使用累加器来记住先前的值并从中减去。如果值为空(重置)或不为空(继续)，我们仅使用当前值来发出信号。<a class="ae ky" href="http://reactivex.io/documentation/operators/scan.html" rel="noopener ugc nofollow" target="_blank">【6】</a></p><h2 id="839e" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated"><strong class="ak">关键概念#4:使用扫描来管理内部状态并避免副作用</strong></h2><p id="0d48" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe mc md me mf b">d</code>就是我们的<code class="fe mc md me mf b">input-to-component.directive</code>。如果<code class="fe mc md me mf b">currentValue</code>为空，或者<code class="fe mc md me mf b">accumulatedValue</code>为假，我们将从<code class="fe mc md me mf b">d</code>返回总秒数。一旦我们返回总秒数，<code class="fe mc md me mf b">accumulatedValue</code>将被设置回总秒数。如果<code class="fe mc md me mf b">accumulatedValue</code>为零，则返回零。换句话说，<code class="fe mc md me mf b"><strong class="lb iu">scan</strong></code> <strong class="lb iu">允许我们在不修改外部数据的情况下，跟踪我们可观察对象内部的内部状态。</strong></p><p id="c363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，当我们从<code class="fe mc md me mf b">switchMap</code>到<code class="fe mc md me mf b">of()</code>时，<code class="fe mc md me mf b">scan</code>不会递减<code class="fe mc md me mf b">accumulatedValue</code>，因为<code class="fe mc md me mf b">of()</code>不会发出一个值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分解pt 2 | countdown.component.ts</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/210be91580245f89e890cb92f1ec689b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lX-atq_uwuM_KHPaTEOtQ.png"/></div></div></figure><h2 id="f3f9" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">我们的倒计时和电脑之间的类比</h2><p id="5303" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">传入true就像启动我们的电脑。如果计算机关闭，我们将从最初的起点开始。如果计算机处于休眠状态，我们将从停止的地方开始。传入false就像让我们的计算机进入睡眠状态。传入null就像关闭我们的计算机。</p><p id="2dc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们的输入改变(秒、分或小时)或我们点击重置，我们希望计算机关闭，直到下一次启动。如果我们点击暂停，我们希望计算机睡眠，直到我们从我们离开的地方再次开始。</p><h1 id="f1ec" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">用管道格式化输入</h1><p id="45ff" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了结束倒计时，我们将使用一个角形管道将总秒数格式化为一个显示值。如果数字小于10，填充函数将填充该数字。比如数字九变成了<code class="fe mc md me mf b">09</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">4.1 |时间格式.管道. ts |跟进</p></figure><h2 id="a7fd" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated"><strong class="ak">关键概念#5:利用异步管道简化订阅管理</strong></h2><p id="1414" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">注意<code class="fe mc md me mf b">else default</code>语法。如果我们的可观察值还没有发出真值，我们将默认为<code class="fe mc md me mf b">00:00:00</code>，而不是什么都不显示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">4.2 | countdown.component.html |跟进结束</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/4648d93c76e4c0a42731e111b2120141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeUK3K64Ex6bQQ3INT5WyQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">倒计时</p></figure><h1 id="0815" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="2fe2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在JavaScript中实现倒计时可能会导致容易出错的代码和意想不到的副作用。使用RxJS，我们能够创建一个有效的倒计时，而不需要大量的代码。感谢阅读！</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><blockquote class="lv lw lx"><p id="1085" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">☁️<a class="ae ky" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank">flotes</a>——尝试演示，不需要登录。或者免费报名。Flotes是我记笔记和高效学习的方式，即使在我很忙的时候。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/8e468f6e74135bbbc2ecbfce7e2db2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGqAj2R16w33dIiKDnHEUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank">漂浮物</a></p></figure><h1 id="415a" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">资源/参考资料</h1><ul class=""><li id="e4fe" class="od oe it lb b lc nb lf nc li of lm og lq oh lu oi oj ok ol bi translated">[1]<a class="ae ky" href="http://reactivex.io/documentation/subject.html" rel="noopener ugc nofollow" target="_blank">http://reactivex.io/documentation/subject.html</a></li><li id="ad20" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">[2]https://en.wikipedia.org/wiki/Information_hiding<a class="ae ky" href="https://en.wikipedia.org/wiki/Information_hiding" rel="noopener ugc nofollow" target="_blank"/></li><li id="6d37" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">[3]http://reactivex.io/documentation/operators/map.html<a class="ae ky" href="http://reactivex.io/documentation/operators/map.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="ebfe" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="http://reactivex.io/documentation/operators/merge.html" rel="noopener ugc nofollow" target="_blank">http://reactivex.io/documentation/operators/merge.html</a></li><li id="8a3d" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="http://reactivex.io/documentation/operators/flatmap.html" rel="noopener ugc nofollow" target="_blank">http://reactivex.io/documentation/operators/flatmap.html</a></li><li id="e643" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="http://reactivex.io/documentation/operators/scan.html" rel="noopener ugc nofollow" target="_blank">http://reactivex.io/documentation/operators/scan.html</a></li><li id="41ae" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">倒计时的最初想法来自韦斯·博斯<a class="ae ky" href="https://javascript30.com/" rel="noopener ugc nofollow" target="_blank">https://javascript30.com/</a>的JavaScript 30</li><li id="94e6" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">我第一次看到维护价值观的扫描是在迈克尔·赫拉迪克的一次演讲中:<a class="ae ky" href="https://www.youtube.com/watch?v=XKfhGntZROQ" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=XKfhGntZROQ</a></li></ul></div></div>    
</body>
</html>