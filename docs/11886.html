<html>
<head>
<title>How to Optimize Images for Usage in Websites</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何优化网站中使用的图像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-optimize-images-for-usage-in-websites-9eaee88c2e6b?source=collection_archive---------3-----------------------#2022-04-25">https://betterprogramming.pub/how-to-optimize-images-for-usage-in-websites-9eaee88c2e6b?source=collection_archive---------3-----------------------#2022-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="76be" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于Lighthouse指标优化网络使用图像的一些方法，并使这一过程自动化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dab66791581a49d1c2ccbbc84fe33554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x7ei8sUHOlWcHNlQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@uxstore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> UX店</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍照</p></figure><p id="a240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图像通常是任何应用程序负载的最大部分，因此这是一个很大的优化领域。在本文中，我们将尝试所有可能的方法来提高应用程序的效率。在本文中，我们将重点关注静态图像的优化，静态图像包含在我们的代码库中，但所有方法都可以转移到任何其他可能存储在任何3d party服务(如Cloudinary)中的图像，我们将在接下来的文章中更深入地了解它们。</p><h1 id="3e53" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">先决条件</strong></h1><p id="335e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所有实际例子都将基于用<code class="fe mp mq mr ms b">create-react-app</code>脚本创建的项目来展示。要创建项目，您只需完成以下命令:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="3b57" class="mx lt iq ms b gy my mz l na nb">npx create-react-app my-app --template typescript<br/>cd my-app<br/>npm start</span></pre></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="d385" class="ls lt iq bd lu lv nj lx ly lz nk mb mc jw nl jx me jz nm ka mg kc nn kd mi mj bi translated"><strong class="ak">简介</strong></h1><p id="3466" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于创建登录页面的开发人员来说，这篇文章很有意思，因为大多数图片都是以静态资产的形式交付的。通常，他们从Figma、Photoshop等设计系统中提取图像。但是我们应该注意图像的必要质量，因为导出的图像对于网络使用来说可能不是很有效。</p><p id="cc10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，我们甚至应该为每个web断点创建一堆不同大小的图片——这是一项相当乏味的工作。在这里，我们看一下如何自动化这个过程，并将其作为一个管道包含在我们的捆绑包中，如Webpack、Rollup等。</p><p id="f1a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能会提出的另一个问题是——我们如何衡量我们网站的有效性？为此，您可以使用<a class="ae kv" href="https://developers.google.com/web/tools/lighthouse" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">灯塔</strong> </a>。Lighthouse是一个开源的自动化工具，用于提高网页质量。它也是Chrome DevTools的内置工具，使用起来非常方便。这是一个非常有价值的工具，因为它不仅突出了问题，还提供了对问题的详细解释以及一系列关于我们如何改进的建议。好，我们开始吧。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="72e3" class="ls lt iq bd lu lv nj lx ly lz nk mb mc jw nl jx me jz nm ka mg kc nn kd mi mj bi translated">1在项目构建期间使用imagemin插件减少光栅图像</h1><p id="2a64" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，让我们将任何图片作为静态资源包含在我们的项目中。我刚刚在谷歌搜索中找到了第一张图片，并将它包含在<code class="fe mp mq mr ms b">src/images</code>文件夹中的一个项目中，并导入到<code class="fe mp mq mr ms b">App.tsx</code>文件中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/94159065a755bacef8d5f5b7934a7382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VJOQC_f_rWZJGC53pfWAA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1 —在项目中导入图像</p></figure><p id="e81e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该图像的大小为1.34 MB。我们来分析一下有没有机会优化一下。为此，我们将使用Chrome DevTools中默认包含的内置<a class="ae kv" href="https://developers.google.com/web/tools/lighthouse" rel="noopener ugc nofollow" target="_blank"> Lighthouse </a>工具。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/2b3a8fb8e5fa8a051828a046d1c8e6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9CmcewFsA8uFNG3DG_RTQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2 —图像优化前的灯塔指标</p></figure><p id="b08a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们对“性能”指标感兴趣，它等于74%，因此我们在这里有一些要改进的地方。向下滚动一点，直到“<em class="nq">机会</em>部分。在这里，Lighthouse强调了所有的改进选项。目前，我们关注的是“<em class="nq">高效编码图像</em>”。</p><p id="ceb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们到Lighthouse文档中查找这个<a class="ae kv" href="https://web.dev/i18n/en/uses-optimized-images/" rel="noopener ugc nofollow" target="_blank">指标</a>并找出它是如何计算的:</p><blockquote class="nr ns nt"><p id="46ae" class="kw kx nq ky b kz la jr lb lc ld ju le nu lg lh li nv lk ll lm nw lo lp lq lr ij bi translated">Lighthouse收集页面上的所有JPEG或BMP图像，将每个图像的压缩级别设置为85，然后将原始版本与压缩版本进行比较。</p></blockquote><p id="7542" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">压缩算法具有<em class="nq">压缩级别(质量)</em>，以1到100的标度表示，其中1为最低，100为最高。你想到的第一个问题可能是——应该为它设置什么样的质量值。实际上，这取决于您的项目标准，但是我们应该意识到，激进的优化会导致图像质量明显下降。如果我们的目标是让Lighthouse metrics获得更好的性能，那么它应该像文档中所说的那样设置为85。同时，如果你看一下NextJS框架的<code class="fe mp mq mr ms b">next/image</code>组件的文档，他们设置了默认的质量值75(<a class="ae kv" href="https://nextjs.org/docs/api-reference/next/image#quality" rel="noopener ugc nofollow" target="_blank">next/image documentation</a>)</p><p id="7430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，让我们试着把这个算法包含到我们的项目中。众所周知，在幕后，<code class="fe mp mq mr ms b">create-react-app</code>使用Webpack作为捆绑器。因此，我们需要搜索合适的Webpack插件。可能是<a class="ae kv" href="https://webpack.js.org/plugins/image-minimizer-webpack-plugin/" rel="noopener ugc nofollow" target="_blank">image-minimizer-web pack-plugin</a>。</p><p id="9330" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在不弹出webpack配置的情况下将这个插件无缝地包含在用<code class="fe mp mq mr ms b">create-react-app</code>创建的项目中，让我们将<code class="fe mp mq mr ms b">craco</code>包含在项目中(只需按照这里<a class="ae kv" href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#installation" rel="noopener ugc nofollow" target="_blank">解释的步骤</a>)。</p><p id="6fda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要安装所有的依赖项:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="e1c8" class="mx lt iq ms b gy my mz l na nb">npm i image-minimizer-webpack-plugin imagemin <!-- -->imagemin-mozjpeg <!-- -->-D</span></pre><p id="57b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">craco的配置如下所示(<code class="fe mp mq mr ms b">craco.config.js</code>在一个根项目文件夹中):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="26be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我想强调的是，我添加<strong class="ky ir"> 6行</strong>只是为了测试，因为在开发模式下，最好排除任何针对快速开发过程的优化，但是因为我想检查运行<code class="fe mp mq mr ms b">npm start</code>的性能指标，所以我考虑到了这一点。让我们再次运行灯塔测试:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/efc6bc59e669e49dab98b36a23b8f0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m98dzD4ZmwJrof6cunsp2g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3 —对图像应用压缩算法后的灯塔指标</p></figure><p id="ed0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们向下滚动到“<em class="nq"> Opportunities </em>”部分，您会看到“<em class="nq">高效编码图像</em>”选项现已取消，我们将性能指标从74%提高到90%。</p><p id="40e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看图像尺寸是如何缩小的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/38faeff8076a00e320c84836e0658c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKJ3nWrOYM25UFlRxGZILg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4—原始/压缩图像对照表</p></figure><p id="42af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，同样的方法将用于PNG和SVG文件，我们只需要包括一个适当的插件，它与<a class="ae kv" href="https://webpack.js.org/plugins/image-minimizer-webpack-plugin/" rel="noopener ugc nofollow" target="_blank">image-minimizer-web pack-plugin</a>:<code class="fe mp mq mr ms b">imagemin-pngquant</code>或<code class="fe mp mq mr ms b">imagemin-svgo</code>一起工作</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="9a69" class="ls lt iq bd lu lv nj lx ly lz nk mb mc jw nl jx me jz nm ka mg kc nn kd mi mj bi translated">2使用WebP编码图像</h1><p id="4428" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">再看一下图片2或图片3，你会发现另一个优化点:“以下一代格式提供图像”。它推荐使用现代的图像格式<em class="nq"> WebP/AVIF </em>，这种格式比它们的老版本JPEG和PNG具有更好的压缩和质量特性。</p><p id="af94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，让我们把它修好。首先，我们需要安装额外的插件<a class="ae kv" href="https://www.npmjs.com/package/imagemin-webp" rel="noopener ugc nofollow" target="_blank"> imagemin-webp </a>:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="4691" class="mx lt iq ms b gy my mz l na nb">npm i imagemin-webp -D</span></pre><p id="395d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将它也包含在我们的网络包中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/c2e0ae68c551683c565374f8623899ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WWUz2Lz9V6tCjDy_GhRTA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5—添加从其他格式生成<code class="fe mp mq mr ms b">webp</code>的生成器。</p></figure><p id="eba4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要说将文件<code class="fe mp mq mr ms b">./images/001.jpg</code>转换成WebP格式的生成器，我们需要为导入的文件加上后缀<code class="fe mp mq mr ms b">?as=webp</code>，就像这样:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="59fa" class="mx lt iq ms b gy my mz l na nb">import imageWebp from './images/001.jpg?as=webp';</span></pre><p id="3457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此我们的<code class="fe mp mq mr ms b">App.tsx</code>看起来会像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/042bb0abfdacfd505e9e3c517256d164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkSb26TinQKdbKe9k2-ErQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片6—将JPG图片转换成WebP格式</p></figure><p id="9224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果使用TypeScript初始化项目，您可能会遇到以下问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/fb77ba9a47b3b949b726c8820ad95ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ldb0iGXMwNMWya5xwWEtvQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图7—当我们在文件导入过程中加入后缀时，模块声明的类型脚本问题，这对于webpack加载器/生成器很重要</p></figure><p id="8bbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">别担心，这很容易解决。让我们在根项目文件夹中添加一个文件<code class="fe mp mq mr ms b">index.d.ts</code>，并为TS声明一个新模块:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c91e" class="mx lt iq ms b gy my mz l na nb">// index.d.ts file<br/>declare module '*.jpg?as=webp';</span></pre><p id="70e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将这个声明也包含在<code class="fe mp mq mr ms b">tsconfig.json</code>文件中:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="5572" class="mx lt iq ms b gy my mz l na nb">// tsconfig.json<br/>{<br/>    "compilerOptions": {....},<br/>    "files": ["index.d.ts"]<br/>}</span></pre><p id="5b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题应该解决了。好了，让我们用Lighthouse再分析一下我们的进度:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/753431c1acd2086813c8b7f3d12a3956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2lB934i3M7bV7Z1h6Rt9dg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图8——JPG图片转换成WebP格式后的灯塔</p></figure><p id="9ee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在性能方面又赢得了4分(与图3相比)，而且“<strong class="ky ir">以新一代格式提供图像</strong>”的机会也已经失去。此外，我们可以确保在Chrome DevTools的“网络”选项卡上更改了图像的格式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/471fdd68523e271404a6f88337191a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhBLVrpKusvILWRdYC0O3Q.png"/></div></div></figure><p id="9146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可惜不是这样。我们需要记住的是，一些旧版本的浏览器不支持WebP，在这些情况下，最好使用备用的PNG/JPEG。在这里，您可以分析WebP支持的可用性:<a class="ae kv" href="https://caniuse.com/?search=webp" rel="noopener ugc nofollow" target="_blank">我可以使用</a>吗？我们可以使用<code class="fe mp mq mr ms b">&lt;picture&gt;</code>标签来实现这一点，它允许我们按优先级顺序列出多个图像目标，这样客户端将请求它可以正确显示的第一个候选图像。它看起来会像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/f1404556f5a4b71b8ad6dbbfbcc751b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQJzRig4HeIw1yu7Z3mTQA.png"/></div></div></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="8b0f" class="ls lt iq bd lu lv nj lx ly lz nk mb mc jw nl jx me jz nm ka mg kc nn kd mi mj bi translated">3个响应图像</h1><p id="d8dd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们有了一张原始尺寸为1600x664像素的图片。嗯，浏览器在上传一张桌面断点原始大小的图片时(视口宽度&gt; 1600 px)，完全没问题。对于所有设备，此图片也可能会缩小，但对于移动断点(视口宽度600 px)上传1600x664 px的图片并依靠浏览器缩放是否有效？我觉得没有。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/29da2774810eb78a4f5321d1bd0eb943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBtXDnWtCDuVrLwrjkDbmw.png"/></div></div></figure><p id="52aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，提供最符合设备需求的图像是有意义的。这意味着我们需要一堆图像，这大大有助于我们减少上传图像的大小。假设我们的网站有五个支持的断点:<em class="nq">特大、小、中、大</em>和<em class="nq">特大</em>。因此，我们应该有五个不同宽度大小的图像，保持相同的纵横比。它如何影响性能，您可以分析下表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/45e1bb92dfc2859d90faa35fd3fd970d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xF1NdW03iMNeSaU94QOUog.png"/></div></div></figure><p id="6a5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从字面上看，这意味着我们可以将移动设备的文件大小从346 kB减少到56kB，从而缩短网站的加载时间。</p><h2 id="4cf6" class="mx lt iq bd lu oj ok dn ly ol om dp mc lf on oo me lj op oq mg ln or os mi ot bi translated">使用srcset</h2><p id="1bdb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">显示响应图像的一种方式是基于<code class="fe mp mq mr ms b">&lt;img&gt;</code>标签的HTML5特性，它带有属性名<code class="fe mp mq mr ms b">srcset</code>。这个可选属性并不取代<code class="fe mp mq mr ms b">src</code>属性，而是对其进行补充:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a768" class="mx lt iq ms b gy my mz l na nb">&lt;img src="image-1600.jpg 1600w"<br/>     srcset="image-600.jpg  600w,<br/>             image-900.jpg  900w,<br/>             image-1200.jpg 1200w<br/>             image-1600.jpg 1600w"<br/>     sizes="100vw"<br/>/&gt;</span></pre><p id="dc9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览器进行计算，并选择最佳大小显示给用户。浏览器不仅会考虑屏幕的宽度(视窗宽度)，还会考虑像素密度。</p><p id="4ba6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在上面强调了浏览器会考虑像素密度，因为我一开始发现这个特性时很困惑。我看到我的视窗宽度等于599像素，但出于某种原因，浏览器选择了宽度= 1200像素的图像。为什么，为什么不是600？为什么它甚至跳过了<code class="fe mp mq mr ms b">srcset</code>的width=900px的图像？</p><p id="0789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为设备的像素密度，我的设备等于2。这意味着当我的视口为599像素时，实际像素数是599像素×2 = 1198像素——这就是为什么我的浏览器选择宽度为1200像素的图片。请记住这一点。</p><p id="f41c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在图9中，我用Chrome DevTools展示了我的实验(如上所述)。Chrome DevTools允许定义设备的宽度/高度和所需的设备像素比率。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/6b746a0e34a29543ecd0e5f8dbca1e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlUjhLA7KBWz7KYfe7oOCQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片9 —浏览器如何根据视窗宽度和设备像素比率计算应显示哪张图片</p></figure><p id="ca9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止一切顺利，但问题是——我们应该为每个断点手动创建一堆图像吗？哦，这将是一项艰巨的工作。幸运的是，我们有一个特殊的Webpack加载器，它的工作方式与<code class="fe mp mq mr ms b">imagemin-webp</code>生成器大致相同，它允许导入带有额外参数的文件，如下所示:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c960" class="mx lt iq ms b gy my mz l na nb">import img from './img.jpg?sizes[]=600,sizes[]=900';<br/>import imgWebp from './img.jpg?sizes[]=600,sizes[]=900&amp;format=webp';</span></pre><p id="ddce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">加载程序可以解析这个后缀，并在项目构建时创建一组具有必要大小和格式的图片。我们将使用<code class="fe mp mq mr ms b">webpack-image-resize-loader</code> ( <a class="ae kv" href="https://www.npmjs.com/package/webpack-image-resize-loader" rel="noopener ugc nofollow" target="_blank"> npm链接</a>)。让我们首先添加所有的依赖项(包括<code class="fe mp mq mr ms b">sharp</code>):</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="1111" class="mx lt iq ms b gy my mz l na nb">npm i <!-- -->webpack-image-resize-loader <!-- -->sharp <!-- -->-D</span></pre><p id="2a8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在包含这个依赖项之后，让我们将它合并到webpack配置中的<code class="fe mp mq mr ms b">craco.config.js</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c814" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我想强调一下，这个配置适用于版本为<code class="fe mp mq mr ms b">5.0.1</code>的<code class="fe mp mq mr ms b">react-scripts</code>，如果你的版本不同，可能你也需要调整它。定义自己的图像加载器，这里的目的是覆盖它。因此，我在<code class="fe mp mq mr ms b">webpackConfig.module.rules</code>中查看了它们包含的加载器，找到了负责图像处理的加载器，并用一个新的来覆盖它。因此，在您的情况下，图像加载器<code class="fe mp mq mr ms b">module.rules[1].oneOf[1]</code>的路径可能会不同——请记住这一点。</p><p id="229c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，让我们用新的加载器将图像导入到我们的<code class="fe mp mq mr ms b">App.tsx</code>文件中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/19979ac3f915f2828b82d68332b49798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ddYXqtkBKBGyz6F3AyRtDg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图10 —响应图像</p></figure><p id="4e94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，如果您的项目已经用Typescript初始化，您会遇到这个问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/51dd7bea14235629a9e2829b37905280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vXrpPvH5ulibIWdt7tkCw.png"/></div></div></figure><p id="7ff0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们需要将图像从JPG转换成WebP格式时，我们看到了同样的问题(图7)。在这里，声明这个新模块并不容易。可能出现在脑海中的第一个想法——让我们这样宣布:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="f9a6" class="mx lt iq ms b gy my mz l na nb">declare "*.jpg?*";</span></pre><p id="e708" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是Typescript不允许定义包含多个<code class="fe mp mq mr ms b">*</code>的模式。幸运的是，在这里，<code class="fe mp mq mr ms b">webpack-image-resize-loader</code>在检查后缀时，它不验证<code class="fe mp mq mr ms b">?</code>之后的属性，这给了我们一个定义新的假参数的机会，例如<code class="fe mp mq mr ms b">useResponsiveLoader=true</code>，然后我们的模块声明将如下所示:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="1a70" class="mx lt iq ms b gy my mz l na nb">declare module '*useResponsiveLoader=true' {<br/>   const value: { srcSet: string; src: string };<br/>   export default value;<br/>}</span></pre><p id="68bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到这一点，我们的文件导入将如下所示:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="99bc" class="mx lt iq ms b gy my mz l na nb">import image from './images/001.jpg?sizes[]=600,sizes[]=900,sizes[]=1200,sizes[]=1600&amp;useResponsiveLoader=true';</span><span id="6f1c" class="mx lt iq ms b gy ox mz l na nb">import imageWebp from './images/001.jpg?sizes[]=600,sizes[]=900,sizes[]=1200,sizes[]=1600&amp;format=webp&amp;useResponsiveLoader=true';</span></pre><p id="a565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们需要记住，每次当我们需要定义这个后缀时，我们需要在末尾加上<code class="fe mp mq mr ms b">&amp;useResponsiveLoader=true</code>——但是不要担心，TS在任何情况下都会强调这个问题。如果你不喜欢这种方法，这里有另一种选择:<br/> -使用<code class="fe mp mq mr ms b">require</code>而不是<code class="fe mp mq mr ms b">import</code> <br/> -只需将<code class="fe mp mq mr ms b">//@ts-ignore</code>放在文件导入下</p><p id="3054" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们继续之前，有什么方法可以检查我们如何改进我们的性能？让我们看看图8。您应该会看到一个名为“<strong class="ky ir">大小合适的图像</strong>”的机会。让我们回顾一下它是如何计算的文档:</p><blockquote class="nr ns nt"><p id="1ed9" class="kw kx nq ky b kz la jr lb lc ld ju le nu lg lh li nv lk ll lm nw lo lp lq lr ij bi translated">对于页面上的每个图像，Lighthouse会将渲染图像的大小与实际图像的大小进行比较。渲染尺寸也考虑了设备像素比率。如果渲染的大小比实际大小至少小4kb，则图像未通过审核。</p></blockquote><p id="8a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们检查我们的图片时，我们应该看到两个参数:“渲染大小”和“内在大小”(图11)，Lighthouse比较了这两个维度的图片文件大小。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/adbdc94f9bf11dc841b88f8ce0fd921e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNiQ6x2o_YFWZF5RIPbc5g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图11 —检查图像尺寸</p></figure><p id="6e4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当我们在<code class="fe mp mq mr ms b">srcSet</code>中为每个断点定义一组图像时，这意味着我们使<strong class="ky ir">“渲染尺寸”</strong>和<strong class="ky ir">“内在尺寸”</strong>彼此接近。让我们仔细检查一下Lighthouse指标是否已经更改:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/a8f9a9245d3641ddcdd8041d2de859ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-ablMTh5yj2d9RH0MhJsQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图12 —下一次优化后的灯塔指标</p></figure><p id="13b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还不错。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="446d" class="ls lt iq bd lu lv nj lx ly lz nk mb mc jw nl jx me jz nm ka mg kc nn kd mi mj bi translated"><strong class="ak">偷懒加载图片</strong></h1><p id="2519" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们需要上传放在页面底部的图片吗？可能没有，用户甚至不能向下滚动到底部。如果用户正在旅行并且开启了漫游，我们应该注意每一点。</p><p id="2f1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最简单的实现方法是给<code class="fe mp mq mr ms b">&lt;img&gt;</code> — <code class="fe mp mq mr ms b">loading="lazy"</code>添加属性，如图10所示。它可用于指示浏览器推迟加载屏幕外的图像，直到用户滚动到它们附近。</p><p id="5085" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，如果你需要支持某些浏览器的旧版本，这可能是一个问题——目前，该功能被测量为71%可供用户使用(<a class="ae kv" href="https://caniuse.com/?search=loading" rel="noopener ugc nofollow" target="_blank">我可以使用</a>)。如果你想改善这一点，你需要自己实现这个特性，例如，基于交叉点观察器API(见本文后续:<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/lazy-loading-images-with-intersection-observer-in-react-ad6135f1ca59">在React </a>中延迟加载图像)</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="8143" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢阅读这篇文章。很高兴看到任何评论或任何项目，应该已经涵盖。感谢任何有助于改进文章的帮助。谢谢你。</p></div></div>    
</body>
</html>