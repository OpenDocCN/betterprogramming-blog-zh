<html>
<head>
<title>Are GitHub’s Workflows Falling Short? Here’s How to Handle Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitHub的工作流程是否存在不足？以下是处理并发性的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/are-githubs-workflows-falling-short-here-s-how-to-handle-concurrency-93a598348333?source=collection_archive---------8-----------------------#2022-10-03">https://betterprogramming.pub/are-githubs-workflows-falling-short-here-s-how-to-handle-concurrency-93a598348333?source=collection_archive---------8-----------------------#2022-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="293b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">GitHub中的数据持久性和工作流通信</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/09ee921c59cadb24f8eb38dc993cb476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BQqmPdikie6fkuI6"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卢克·切瑟在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c807" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经和GitHub合作了一段时间，管道并不总是像我们希望的那样运行。你是否曾经有过这样的一天，所有的特性和用户故事都需要在你的主分支中关闭和合并？您很可能经历过这种世界末日的场景，每个人都急于完成自己的工作，大量的拉取请求触发了验证和部署。</p><p id="b8e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这并不令您担心，毕竟，您的CI/CD流程是自动化的，一切都在顺利运行。</p><p id="7ab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一个理想的世界中，它应该是这样的，但是实际上，随着时间的推移，GitHub中的修复、验证和操作的数量最终可能会产生一个瓶颈。我以前也遇到过这种情况，当时我唯一能打开管道的方法就是寻找窒息流程的流程，并杀死那些过时的和重复的流程。</p><p id="3566" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直截了当地说，并发性是在CI/CD中工作时经常出现的话题。如果你在敏捷项目中工作，或者在sprints中工作，这种场景很可能每两周重复一次。但是，我们能摆脱这种土拨鼠日的局面吗？经过一番挖掘，我得出结论，我们其实可以，管道是有希望的！</p><blockquote class="ls"><p id="829c" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">我们能从这个土拨鼠日挣脱出来吗？</p></blockquote><p id="7ef7" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">我首先从我以前的经历中找出并发性的来源。我能够识别两个可能的并发触发器:</p><ul class=""><li id="013a" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated">在GitHub中，单个拉请求在短时间内触发多个工作流运行。</li><li id="7393" class="mh mi iq ky b kz mq lc mr lf ms lj mt ln mu lr mm mn mo mp bi translated">外部系统中的作业是由一个动作触发的，除了手动之外没有办法取消它们。</li></ul><p id="95f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">知道了原因，我开始在GitHub和那些由动作触发的外部作业中探索并发性。</p><h2 id="2d23" class="mv mw iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">避免GitHub中的并发</h2><p id="ef94" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">第一个问题非常容易解决！您可以配置GitHub动作，在运行任何工作流之前检查<a class="ae kv" href="https://docs.github.com/en/actions/using-jobs/using-concurrency" rel="noopener ugc nofollow" target="_blank">并发性</a>。使用此配置将停止任何正在运行的工作流，并优先考虑最新的工作流。</p><p id="6b13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看下面的示例，了解它的样子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="aa75" class="mv mw iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">使用GitHub避免外部系统中的并发</h2><p id="45ff" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">停止这种类型的并发有点棘手，因为在GitHub中停止动作，在其他系统中不会停止，并且在工作流运行之间没有标准的通信方式。此外，当在另一个系统中触发一个作业时，您很可能只会从那个系统收到一个作业ID，告诉我们执行已经开始。然后，该ID将存储在缓存或临时变量中，一旦工作流运行完成，该变量将消失，但您的外部系统将继续在后台运行。</p><p id="1327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，您有一个正在运行的触发外部作业的工作流，外部系统返回一个引用，该引用存储为临时数据，一旦工作流完成，将无法再访问。幸运的是，我们可以使用像工件这样的容器来存储数据，并在工作流运行之间使用它。</p><p id="a20c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们在工作流运行之间是持久的，通过最新的GitHub API版本，我们可以从我们的操作中访问它们。这正是我所做的沟通工作流程和运行。该流程的基本思想如下，</p><ul class=""><li id="4ddf" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated">对于当前作业，使用外部系统返回的作业ID引用创建一个文件。这里有一个如何做的例子，</li></ul><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="bded" class="mv mw iq nw b gy oa ob l oc od">#replace here the github.run_id by you system's id<br/>- name: Create file with id      <br/>      run: |<br/>         echo "Writing in workflow log file..." <br/>         echo ${{ github.run_id }} &gt;&gt; WorkflowRunLog.txt</span></pre><ul class=""><li id="b608" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated"><a class="ae kv" href="https://medium.com/r?url=https%3A%2F%2Fdocs.github.com%2Fen%2Factions%2Fusing-workflows%2Fstoring-workflow-data-as-artifacts" rel="noopener">使用新文件</a>创建工件，并将其上传到工作流运行。您可以使用actions/upload-artifact@v3来实现这一点。</li></ul><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="c162" class="mv mw iq nw b gy oa ob l oc od">- name: Upload Workflow Artifact<br/>      uses: actions/upload-artifact@v3<br/>      with:          <br/>        name: ${{ github.head_ref }} # source branch of the PR<br/>        path: WorkflowRunLog.txt</span></pre><ul class=""><li id="43b8" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated">验证一个并发作业是否正在GitHub中运行，并使用本文的第一个配置停止它。继续通过<a class="ae kv" href="https://medium.com/r?url=https%3A%2F%2Fdocs.github.com%2Fen%2Factions%2Fmanaging-workflow-runs%2Fdownloading-workflow-artifacts" rel="noopener">检索你正在工作的分支的最新神器</a>，并获得ID。</li></ul><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="510b" class="mv mw iq nw b gy oa ob l oc od">- name: Get artifact for specific branch<br/>  id: get-artifact<br/>  run: |          <br/>   input_file="WorkflowRunLog.txt"<br/>   artifactFile=$(gh run download -n "concurrency-job-level")<br/>   jobId=$( tail -n 1  ${input_file} )<br/>   echo "${jobId}"<br/>   echo ::set-output name=job_id::$(tail -n 1 ${input_file})</span></pre><p id="92d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我直接通过名称来下载工件，但是您可以根据自己的规范进行修改。如果您还没有GitHub API CLI，请不要忘记安装它。</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="15e9" class="mv mw iq nw b gy oa ob l oc od">#retrieve a specific artifact in a branch<br/>gh api -H “Accept: application/vnd.github+json” /repos/&lt;username&gt;/&lt;repo name&gt;/actions/artifacts — jq “.artifacts[] | select(.workflow_run.head_branch == \”concurrency-job-level\”)”</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/185887f99384507cdae265496f15d356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*ap8O3C1azkQGQkrjNAHuRQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitHub API从您的repo返回工件信息。</p></figure><p id="5026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将看到响应返回了URL，我们可以从这里下载实际的工件，并访问它包含的信息。使用下面的命令只检索实际的URL，您可以使用bash或其他脚本语言检查信息。</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="9880" class="mv mw iq nw b gy oa ob l oc od">#retrieve a specific artifact<br/>gh api -H “Accept: application/vnd.github+json” /repos/&lt;username&gt;/&lt;repo name&gt;/actions/artifacts — jq “.artifacts[] | select(.workflow_run.head_branch == \”concurrency-job-level\”) | {archive_download_url}”</span></pre><p id="32bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经走了这么远，谢谢你！我希望它是有用的。</p></div></div>    
</body>
</html>