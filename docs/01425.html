<html>
<head>
<title>How to Prevent HTTP Request Caching with Angular HttpClient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Angular HttpClient阻止HTTP请求缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-prevent-http-request-caching-with-angular-httpclient-e82abf8b157d?source=collection_archive---------1-----------------------#2019-09-09">https://betterprogramming.pub/how-to-prevent-http-request-caching-with-angular-httpclient-e82abf8b157d?source=collection_archive---------1-----------------------#2019-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d60b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用拦截器来避免缓存HTTP请求的奇怪行为</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5dce616535838d0d5931e36091ea980c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I2slOWUWH8UKqd5k"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="3818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近在Internet Explorer的Angular应用程序中发现了一个问题。在浏览应用程序时，我看到一些来自后端的错误数据。使用浏览器开发工具，我注意到我们得到了GET请求的缓存结果。这种行为至少可以说是令人惊讶的。显然，这个问题可能发生在任何web项目中，而不仅仅是Angular应用程序。</p><p id="734e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以在HTTP请求中添加某些头来防止缓存。例如:<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" rel="noopener ugc nofollow" target="_blank"> Cache-Control </a>头，当HTTP 1.1服务器指定了非缓存值时，它会阻止对特定Web资源的所有缓存。虽然向HTTP请求添加新的头很容易，但是在任何发出HTTP请求的地方都需要这样做，这意味着有很多文件需要添加这些头。</p><p id="802b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Angular有一个方便的概念叫做<a class="ae ky" href="https://angular.io/guide/http#http-interceptors" rel="noopener ugc nofollow" target="_blank">拦截器</a>，它适合这种任务。拦截器可以转换传出的请求。自从Angular团队在Angular 4.3中引入了<a class="ae ky" href="https://angular.io/api/common/http/HttpClient#description" rel="noopener ugc nofollow" target="_blank"> HttpClient </a>以取代旧的Http模块以来，Angular拦截器就一直可用。请注意，只有使用HttpClient发出的HTTP请求才能以这种方式被拦截。例如，用标准的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>或<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest </a>发出的HTTP请求就不能以这种方式被拦截。然而，没有什么理由不在Angular应用程序中使用Angular HttpClient，所以这不是问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f81f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何创建一个拦截器来禁用HTTP请求缓存</h1><ol class=""><li id="0399" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">创建一个实现<code class="fe nf ng nh ni b"><a class="ae ky" href="https://angular.io/api/common/http/HttpInterceptor" rel="noopener ugc nofollow" target="_blank">HttpInterceptor</a></code>接口的拦截器类。</li><li id="f97b" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated">通过向请求对象添加必要的头来修改<code class="fe nf ng nh ni b"><a class="ae ky" href="https://angular.io/api/common/http/HttpInterceptor#intercept" rel="noopener ugc nofollow" target="_blank">intercept</a></code>函数中的请求。</li><li id="706c" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated">将拦截器添加到AppModule中，为整个Angular应用程序注册一次。</li></ol><pre class="kj kk kl km gt no ni np nq aw nr bi"><span id="1848" class="ns md it ni b gy nt nu l nv nw">import { HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';<br/>import { Injectable } from '@angular/core';</span><span id="0d93" class="ns md it ni b gy nx nu l nv nw">@Injectable()<br/>export class NoCacheHeadersInterceptor implements HttpInterceptor {</span><span id="9913" class="ns md it ni b gy nx nu l nv nw">intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {<br/>    const authReq = req.clone({<br/>      // Prevent caching in IE, in particular IE11.<br/>      // See: <a class="ae ky" href="https://support.microsoft.com/en-us/help/234067/how-to-prevent-caching-in-internet-explorer" rel="noopener ugc nofollow" target="_blank">https://support.microsoft.com/en-us/help/234067/how-to-prevent-caching-in-internet-explorer</a><br/>      setHeaders: {<br/>        'Cache-Control': 'no-cache',<br/>        Pragma: 'no-cache'<br/>      }<br/>    });<br/>    return next.handle(authReq);<br/>  }<br/>}</span></pre><p id="bb57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在AppModule的<a class="ae ky" href="https://angular.io/api/core/NgModule#providers" rel="noopener ugc nofollow" target="_blank"> providers </a>部分注册拦截器一次。现在，拦截器应该在每次使用HttpClient发出HTTP请求时自动追加必要的请求头。</p><pre class="kj kk kl km gt no ni np nq aw nr bi"><span id="3fae" class="ns md it ni b gy nt nu l nv nw">providers: [<br/>  {<br/>    provide: HTTP_INTERCEPTORS,<br/>    useClass: <em class="ny">NoCacheHeadersInterceptor</em>,<br/>    multi: true<br/>  },<br/>  ...<br/>]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="61c9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="d908" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">感谢您阅读这篇短文。正如您所看到的，在进行HTTP请求时，Angular HTTP拦截器是一个简单易用但功能强大的工具。此外，拦截器不仅仅可以用于添加头部。</p></div></div>    
</body>
</html>