<html>
<head>
<title>Small Navigators for Scene Transitions in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中用于场景过渡的小导航器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/small-navigators-for-scene-transitions-in-ios-9645392e800a?source=collection_archive---------14-----------------------#2019-08-16">https://betterprogramming.pub/small-navigators-for-scene-transitions-in-ios-9645392e800a?source=collection_archive---------14-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/33a4f9a5705971f8644a30893626376a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6VtCY_z2VCTHWcEWRz81Q.jpeg"/></div></div></figure><h2 id="1461" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">可扩展iOS应用架构的组成部分</h2><div class=""/><div class=""><h2 id="6b5e" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">没有序列，没有协调器，只有简单的导航</h2></div><p id="6f4a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">您是否顺应潮流，使用新的协调员模式进行过渡？或者你的心还在为情节和故事板而跳动？那就让我摧毁你的幻想吧！😈</p><p id="eea9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">顺便说一下，这是一篇来自“可扩展的iOS应用架构”系列的文章。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a022" class="mg mh je bd mi mj mk ml mm mn mo mp mq kt mr ku ms kw mt kx mu kz mv la mw mx bi translated">塞格斯</h1><p id="1c5a" class="pw-post-body-paragraph lc ld je le b lf my ko lh li mz kr lk ll na ln lo lp nb lr ls lt nc lv lw lx im bi translated">谁还记得2012年WWDC奥运会？在那个时候，故事板和续集是一个热门话题。最后，你可以在<em class="nd"> InterfaceBuilder、</em>中看到整个应用程序流程，哪个屏幕通向哪里，屏幕看起来如何，如果你用一个按钮直接在故事板中连接一个连续过渡，就不再需要编码了。卓越的视觉编码！🤩</p><blockquote class="ne"><p id="88f7" class="nf ng je bd nh ni nj nk nl nm nn lx dk translated">那些七年后仍在使用segues和故事板的人正在做一些错误的事情。</p></blockquote><p id="c122" class="pw-post-body-paragraph lc ld je le b lf no ko lh li np kr lk ll nq ln lo lp nr lr ls lt ns lv lw lx im bi translated">片段和故事板包含一些与可扩展架构相矛盾的问题:</p><ol class=""><li id="d3c3" class="nt nu je le b lf lg li lj ll nv lp nw lt nx lx ny nz oa ob bi translated">如果所有的屏幕都在一个故事板中，并行处理会导致很难解决<strong class="le jo">合并冲突</strong>。</li><li id="2157" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated">即使你为每个屏幕使用一个单独的故事板，对这些故事板视图执行有意义的<strong class="le jo">代码审查</strong>仍然是非常困难的。</li><li id="a7f7" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated">如果你在故事板中分配颜色或其他常量值，当一个值需要改变时，你需要找到所有的<strong class="le jo">硬编码值</strong>。</li><li id="b106" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated">然后，如果代码中的值被覆盖，由于<strong class="le jo">碎片</strong>的原因，找出故事板中的变化不起作用的原因可能会非常耗时。</li><li id="75ea" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated">故事板定义了一个带有segues的<strong class="le jo">硬编码导航</strong>，这使得导航不灵活。</li><li id="8f94" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated">Segues通常需要标识符，这些标识符在故事板中被冗余地定义一次，然后作为代码常量再次定义，这很容易出错。</li><li id="bcff" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated">依赖注入和segues不能很好地协同工作。</li><li id="90ea" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated">另外，<strong class="le jo">界面也不是很干净</strong>。</li></ol><p id="4545" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你当然可以在这里列出更多的缺点，但是我只想快速地看一下代码，特别是进一步阐明最后一点。</p><figure class="oh oi oj ok gt iv"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7221" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">例如，从第3行开始，这里定义了一个典型的<em class="nd"> ViewController1 </em>。</p><p id="c8a0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通常，segue是通过<code class="fe on oo op oq b">performSegue</code>启动的，如第12行所示。作为一个标识符，你必须传递一个字符串，希望这个字符串在某个地方被定义为常量。</p><p id="1fc3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这里以第4行为例。作为第二个参数，然后传递一个类型为<code class="fe on oo op oq b">Any</code>的<code class="fe on oo op oq b">sender</code>——两个参数和两个缺陷。</p><p id="0f4e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">首先，使用字符串作为导航的常量不是类型安全的。没有什么能阻止我传递字符串“Foobar”并得到一个运行时异常。由于您必须在故事板中再次定义相同的字符串，这种情况比您想象的更常见。😨</p><p id="4174" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">第二个批评是<code class="fe on oo op oq b">sender: Any?</code>参数。如果一个动作链接到一个值，就像这里用一个<code class="fe on oo op oq b">selectedData</code>对象演示的那样，你通常希望在转换过程中将它传递给下一个<em class="nd"> ViewController </em>。在实践中，通常归结为这样一个事实，您在这里将这个值作为一个<code class="fe on oo op oq b">sender</code>传递，然后在第21行的<code class="fe on oo op oq b">prepare</code>方法中将它转换回来。</p><p id="9310" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">看到<code class="fe on oo op oq b">sender</code>被错误地用作目的地<em class="nd">视图控制器</em>的传递参数是很痛苦的。“发送者”的界面实际上说的是完全不同的东西。</p><p id="fb91" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">摘自Apple的文档:</p><blockquote class="or os ot"><p id="a2d9" class="lc ld nd le b lf lg ko lh li lj kr lk ou lm ln lo ov lq lr ls ow lu lv lw lx im bi translated">发送方:要用来启动序列的对象。</p></blockquote><p id="bab3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><code class="fe on oo op oq b">selectedData</code>真的启动了这个序列吗？</p><p id="4b94" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">向任何一个<em class="nd">和返回任何一个</em>转换都会让任何对“漂亮代码”有一点点感觉的人感到厌烦。🤢</p><p id="5f05" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在第25行中，<em class="nd"> ViewController2 </em>需要的参数由<em class="nd"> ViewController1 </em>通过属性注入进行赋值。然而，这需要<em class="nd"> ViewController1 </em>知道<em class="nd"> ViewController2 </em>，这意味着直接依赖。</p><p id="39d7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">您可以通过使用<em class="nd">view controller 2 interface</em>协议轻松地解决这种直接依赖，但是如果您不能交换实际的<em class="nd"> ViewController2 </em>实例，因为它是由故事板硬编码的，那还有什么意义呢？😑</p><p id="6e92" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果您查看<em class="nd"> ViewController2 </em>，您可以看到这个属性注入也导致了第33行中的force unwrapped属性。</p><p id="8611" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">例如，如果您忘记了第25行中的赋值，那么只有在值也被访问时，您才会注意到运行时的崩溃。您可以通过在第38行中进行相应的<code class="fe on oo op oq b">precondition</code>测试来提前做这件事，但是它仍然不太好。</p><p id="f8cd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">顺便说一句，如果你问为什么你应该使用一个<code class="fe on oo op oq b">precondition</code>，我强烈推荐保罗·哈德森的帖子“<a class="ae ly" href="https://medium.com/@johnsundell/picking-the-right-way-of-failing-in-swift-e89125a6b5b5" rel="noopener">选择在Swift </a>中失败的正确方式”。</p><p id="c720" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，使用第43行的<em class="nd"> ViewController3 </em>所示的可选值并不会更好，因为接口中的可选值意味着<em class="nd"> ViewController3 </em>并不真正依赖于这个值，所以它也可能为零。</p><p id="6169" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，在实践中，这只会导致未定义状态的变通方法，因为接口就是错误的。</p><p id="1471" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你看到了吗？情节和故事板有很多问题，所以请不要使用它们！🙏<br/>(除非你正在破解一个原型。)</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6f69" class="mg mh je bd mi mj mk ml mm mn mo mp mq kt mr ku ms kw mt kx mu kz mv la mw mx bi translated">协调者</h1><p id="beca" class="pw-post-body-paragraph lc ld je le b lf my ko lh li mz kr lk ll na ln lo lp nb lr ls lt nc lv lw lx im bi translated">2015年，<a class="ox oy ep" href="https://medium.com/u/1dd85cec9280?source=post_page-----9645392e800a--------------------------------" rel="noopener" target="_blank"> Soroush Khanlou </a>提出了“<a class="ae ly" href="http://khanlou.com/2015/01/the-coordinator/" rel="noopener ugc nofollow" target="_blank">协调员</a>”的概念。</p><p id="b058" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><a class="ox oy ep" href="https://medium.com/u/94d4e9a9abab?source=post_page-----9645392e800a--------------------------------" rel="noopener" target="_blank"> Andrey Panov </a>在他的文章<a class="ae ly" href="https://medium.com/blacklane-engineering/coordinators-essential-tutorial-part-i-376c836e9ba7" rel="noopener">Coordinators Essential tutorial</a>中详细描述了coordinator模式。另一个有趣的博文和视频是保罗·哈德森<a class="ox oy ep" href="https://medium.com/u/76b0105a5cfb?source=post_page-----9645392e800a--------------------------------" rel="noopener" target="_blank">的“</a><a class="ae ly" href="https://www.hackingwithswift.com/articles/71/how-to-use-the-coordinator-pattern-in-ios-apps" rel="noopener ugc nofollow" target="_blank">如何在iOS应用</a>中使用协调器模式”。</p><p id="6c0d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">中心思想是<em class="nd">视图控制器</em>不再负责转换。现在它是一个新类的责任，协调者。这可以用一个协议来抽象，这样就不再有直接的依赖性了。</p><figure class="oh oi oj ok gt iv"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1cd1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="nd"> ViewController1 </em>和<em class="nd"> ViewController2 </em>是通过<em class="nd"> FirstCoordinator </em>实例化的，因此彼此一无所知。他们对FirstCoordinator也一无所知，因为依赖关系是通过协调协议抽象出来的。</p><p id="afa2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">虽然这是基于一个<em class="nd"> UINavigationController </em>，但这并不意味着需要使用<em class="nd"> UINavigationController </em>。您可以自己定义过渡最终如何实现。这甚至可以通过故事板和连续镜头来完成！🤣<br/>(不过说真的，不要用它们！🤨)</p><p id="aea8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">实例化后，协调器总是被分配给<em class="nd">视图控制器</em>。这样，进一步的过渡是可能的。</p><p id="365c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，导航到第11行中的另一个<em class="nd"> ViewController </em>是没有问题的。或者该导航也可以在<em class="nd">视图控制器2 </em>中进行。</p><p id="bfb3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，当<em class="nd"> ViewController2 </em>调用协调器上的<code class="fe on oo op oq b">controller2</code>时，就变得有趣了，因为接口允许这样做。😏</p><p id="ebd3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，这有时是有意义的，例如，在类似于文件夹的内容结构中，但对于文件/叶来说就不是这样了。</p><p id="5437" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">每一个其他的<em class="nd">视图控制器</em>也可以从任何地方调用<code class="fe on oo op oq b">controller2</code>真的有意义吗？</p><p id="edcb" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，如果接口也为树叶和所有其他没有意义的情况提供这些转换，那么接口就是错误的。</p><blockquote class="ne"><p id="e3a9" class="nf ng je bd nh ni nj nk nl nm nn lx dk translated">不要提供错误的接口！</p></blockquote><p id="e93b" class="pw-post-body-paragraph lc ld je le b lf no ko lh li np kr lk ll nq ln lo lp nr lr ls lt ns lv lw lx im bi translated">如果要应用不同的过渡或动画，例如，通过推送从<em class="nd"> ViewController1 </em>到<em class="nd"> ViewController3 </em>，但是在模式上从<em class="nd"> ViewController2 </em>到<em class="nd"> ViewController3 </em>，这也可能是有趣的。</p><p id="242b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然后，协调器将需要像<code class="fe on oo op oq b">controller3from1</code>和<code class="fe on oo op oq b">controller3from2</code>或类似的方法。这看起来很奇怪，不是吗？</p><p id="1f3d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你可能会想到类似<code class="fe on oo op oq b">controller3(showModal: Bool)</code>的东西，但是我们又回到了糟糕的界面。<strong class="le jo">真的是</strong>想要<strong class="le jo">每一个</strong>控制器包括<em class="nd"> ViewController3 </em>都能通过推送显示<em class="nd"> ViewController3 </em>模态<strong class="le jo">和</strong>吗？</p><p id="15fc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">现在你可能会问:为什么这是一个问题？如果从<em class="nd">视图控制器1 </em>导航到<em class="nd">视图控制器3 </em>没有意义，就不要调用<em class="nd">视图控制器1 </em>中的<code class="fe on oo op oq b">controller3</code>！🤔</p><p id="8333" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">是的，这就是为什么你应该把所有东西都标记为<em class="nd">私有</em>并且只在必要的时候打开为<em class="nd">公共</em>的原因。这是封装和良好的API设计的核心概念:<strong class="le jo">只提供真正必要的东西</strong>。</p><p id="a343" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，你可以将你的框架的所有100个方法作为<em class="nd"> public </em>提供，但是这将会淹没你的框架的新用户，因为本质上只有三个方法是真正需要使用的。</p><p id="37a8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过<em class="nd">私有</em>和<em class="nd">内部</em>访问修饰符隐藏其他97个，你不仅使可见的API更小更清晰，还降低了误用框架的风险。</p><p id="cbe4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这同样适用于你的导航界面。如果不打算从<em class="nd"> ViewController1 </em>移动到<em class="nd"> ViewController3 </em>，那么干脆不要提供这种可能性。</p><p id="be91" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果设计改变了，而且从某一点来说是有意义的，那么就增加这种可能性但不要提前打开潘多拉的盒子。😉</p><p id="e04f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你可以通过建立1:1的关系来解决这个问题。每个<em class="nd"> ViewController </em>都有自己的协调器，每个协调器只提供那些对这个<em class="nd"> ViewController </em>有意义的过渡。然而，它让我们更接近一个<em class="nd">导航仪</em>。😁</p><p id="7a46" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">协调模式现在似乎非常流行。所以，谁对它满意，当然就应该使用它。然而，我想重新介绍一个老方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d808" class="mg mh je bd mi mj mk ml mm mn mo mp mq kt mr ku ms kw mt kx mu kz mv la mw mx bi translated">航海家</h1><p id="533f" class="pw-post-body-paragraph lc ld je le b lf my ko lh li mz kr lk ll na ln lo lp nb lr ls lt nc lv lw lx im bi translated">一艘<em class="nd">航海家</em>级的任务是什么？当然是为了从一个场景导航到另一个场景。</p><p id="0afd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在我的文章《<a class="ae ly" href="https://medium.com/@sven.korset/the-perfect-ios-app-architecture-24259417843f" rel="noopener">完美的iOS应用架构</a>》中，我写了关于<em class="nd">场景</em>的概念和<em class="nd">导航器</em>的具体角色。简而言之:场景= app屏幕(包括View、ViewController、Navigator等)。在下面的例子中，为了简单起见，我使用一个<em class="nd">场景</em>作为<em class="nd">视图控制器</em>。</p><p id="ad3e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">每个场景都有自己的<em class="nd">导航器</em>，告诉你可以从这个场景导航到哪些场景。</p><p id="a69d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">根据环境(iPad/iPhone)或测试场景，具体实现可能会导致不同的<em class="nd"> ViewControllers </em>或不同的动画。</p><figure class="oh oi oj ok gt iv"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="2ea2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在第3行中，首先定义了一个<em class="nd"> BaseViewController </em>，所有<em class="nd">场景</em>类都是从它派生的，而不是直接从<em class="nd"> UIViewController </em>派生的。这是为了简化<code class="fe on oo op oq b">init</code>方法，同时也是为了挫败任何使用情节和故事板的企图。😇</p><p id="5825" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">第35行和第24行定义了<em class="nd">场景1 </em>及其关联的<em class="nd">场景1导航器</em>。<em class="nd">导航器</em>需要一个<em class="nd"> UIViewController </em>来执行场景的过渡。这是通过<em class="nd">场景1 </em>的<code class="fe on oo op oq b">init</code>方法中第43行的属性注入来分配的。</p><p id="4580" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然后在第47行触发导航(为简单起见，省略了<em class="nd">导航界面</em>)。通常，这将由<em class="nd">逻辑</em>来完成，而不是由<em class="nd">视图控制器</em>来完成，但是原理是相同的。</p><p id="01d4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">逻辑知道应用程序应该导航到一个新的场景。还必须知道并传递任何参数。然而，转换实际上如何工作对于逻辑来说并不重要。这就是<em class="nd">导航器</em>负责的事情。</p><p id="cd6e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">具体的过渡最终看起来如何，只有第27行的<em class="nd">导航员</em>知道。</p><p id="7cb0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">无论是通过push或modal，还是通过特殊动画，甚至是针对测试场景的完全不同的<em class="nd"> ViewController </em>，这些都是当前<em class="nd"> Navigator </em>实例的具体实现细节。</p><p id="29f4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，正如第54行中的<em class="nd">场景2 </em>所暗示的那样，依赖注入是一条可行之路。</p><p id="b840" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="nd">导航仪</em>不应该直接依赖于其他场景，可以用一个<em class="nd">工厂</em>来解决这个。如何做到这一点在我的文章“<a class="ae ly" href="https://medium.com/@sven.korset/resolving-dependencies-in-swift-ee0f8f2dfbe3" rel="noopener">在Swift </a>中手动完成的依赖管理”中有所描述，或者你可以在我的<a class="ae ly" href="https://github.com/indieSoftware/DemoArchitecture" rel="noopener ugc nofollow" target="_blank"> DemoApp项目</a> (DAP)中进行调查。🧐</p><p id="3ec5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">基本上，一个<em class="nd">导航器</em>不会做任何特别的事情。片段被省略，先前在<em class="nd">视图控制器</em>中的内容现在在<em class="nd">导航器</em>中。一个简单的界面提供了场景的所有过渡。仅此而已！😁</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0b09" class="mg mh je bd mi mj mk ml mm mn mo mp mq kt mr ku ms kw mt kx mu kz mv la mw mx bi translated">差别</h1><p id="4f4f" class="pw-post-body-paragraph lc ld je le b lf my ko lh li mz kr lk ll na ln lo lp nb lr ls lt nc lv lw lx im bi translated">但是与协调模式的最大区别是什么呢？</p><ol class=""><li id="7663" class="nt nu je le b lf lg li lj ll nv lp nw lt nx lx ny nz oa ob bi translated">每个场景都有自己的<em class="nd">导航器</em>。有了这个，开发人员就可以立即看到这个场景中所有的过渡，这些过渡不仅是可能的，而且是允许的。当查看一个<em class="nd">协调器</em>时，开发人员仍然需要知道所有可能的转换中哪些是有意义的，因而是允许的。在一个<em class="nd">航海家</em>看来，这是显而易见的。所有提供的过渡都有意义。</li><li id="5d55" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated">不需要一个<code class="fe on oo op oq b">start</code>方法。当然，在某个地方，应用程序必须被启动，但是一个<em class="nd"> AppDelegate </em>实际上并不执行转换，它只是设置一个<code class="fe on oo op oq b">rootViewController</code>，仅此而已。为此，你不需要<em class="nd">导航器</em> / <em class="nd">协调器</em>。</li><li id="b9ee" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated"><em class="nd">导航器</em> / <em class="nd">协调器</em>不需要传递给其他<em class="nd">视图控制器</em>。当然，必须注入其他依赖，每个场景都要创建自己的<em class="nd">导航器</em>，但是<em class="nd">协调器</em>的元级“协调所有<em class="nd">视图控制器</em>”就被去掉了。</li><li id="709d" class="nt nu je le b lf oc li od ll oe lp of lt og lx ny nz oa ob bi translated">在一些文章中，他们更详细地讨论了流以及流与流之间的返回值。在某种程度上，他们引入了子协调器和特殊嵌套，使得协调器变得非常复杂和难以理解。相比之下，<em class="nd">导航器</em>概念简单、清晰、易于理解。</li></ol><p id="908f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">本质上，一个<em class="nd">协调器</em>代表一个<em class="nd"> n </em> : <em class="nd"> n </em>的关系，而<em class="nd">导航器</em>代表一个1: <em class="nd"> m </em>的关系，其中<em class="nd"> m </em> ≤ <em class="nd"> n </em>和<em class="nd"> n </em>等于你的app或者某个特定流程中<em class="nd">view controller</em>/<em class="nd">场景</em>的数量。这样你就有了一个巨大的、整体式的<em class="nd">协调器</em>和<em class="nd"> n </em>小型的、易于维护的<em class="nd">导航器</em>。</p><p id="aece" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">但是等等，有时候我想有一个<em class="nd"> n </em> :1的关系，应该可以从应用程序中的每一个其他场景导航到<em class="nd">场景2 </em>。有了<em class="nd">协调器</em>，我就只需要编写一次这个方法。有了<em class="nd">导航器</em>，我不得不一遍又一遍地写，甚至更糟，使用复制粘贴。你会怎么解决这个问题？🤔</p><p id="012c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">没问题，只需使用<strong class="le jo">协议和协议扩展</strong>。</p><figure class="oh oi oj ok gt iv"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="0662" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在第1行中，定义了一个<em class="nd">场景2导航</em>协议。该协议提供了到<em class="nd">场景2 </em>的转换，但是需要<em class="nd"> ViewController </em>来执行转换。所以，这不是导航<strong class="le jo">或</strong>，而是导航<strong class="le jo">部分</strong>。这个协议使一个类能够<strong class="le jo">导航到场景2 </strong>。</p><p id="91a6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在第6行，协议通过<code class="fe on oo op oq b">scene2</code>的实现被扩展。这是应该为所有到<em class="nd">场景2 </em>的过渡执行的过渡代码，无论从哪个场景。至少对于实现这个协议的所有场景是这样。</p><p id="4774" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在第15行，我们又有了我们的<em class="nd">导航器</em>，但是在这种情况下，它没有为<em class="nd">场景2 </em>转换提供自己的实现。这是通过扩展<em class="nd">场景1导航</em>自动添加的，以应用于第19行的<em class="nd">场景2导航</em>。</p><p id="5ffc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在你所有的<em class="nd">导航器</em>中，你所要做的就是添加一行像这样的内容。如果从<em class="nd">场景2 </em>导航到<em class="nd">场景2 </em>或者从其他特定场景导航没有意义，那么干脆不要扩展相应的<em class="nd">导航器</em>，也不要为那个<em class="nd">导航器</em>写这样一行。</p><p id="833d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">现在你可以轻松控制了，界面保持清晰和正确，仍然没有重复的代码。😊</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="619c" class="mg mh je bd mi mj mk ml mm mn mo mp mq kt mr ku ms kw mt kx mu kz mv la mw mx bi translated">结论</h1><p id="a1b9" class="pw-post-body-paragraph lc ld je le b lf my ko lh li mz kr lk ll na ln lo lp nb lr ls lt nc lv lw lx im bi translated">你是使用<em class="nd">协调器</em>还是<em class="nd">导航器</em>由你决定。差别没那么大。我喜欢简单干净的，而不是复杂庞大的。所以我更倾向于<em class="nd">导航仪</em>的概念，但是每个人都有自己的看法。</p><p id="ed73" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">最重要的是，它不再是由<em class="nd">视图控制器</em>完成的，无论过渡看起来像什么，请<strong class="le jo">不要使用连续镜头和故事板</strong>！😉</p></div></div>    
</body>
</html>