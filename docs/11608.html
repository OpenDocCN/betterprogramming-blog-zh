<html>
<head>
<title>How Does Shallow Comparison Work In React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浅层比较在React中是如何工作的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-does-shallow-comparison-work-in-react-74b018fd39ac?source=collection_archive---------5-----------------------#2022-04-03">https://betterprogramming.pub/how-does-shallow-comparison-work-in-react-74b018fd39ac?source=collection_archive---------5-----------------------#2022-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8faa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">还有一些你不知道的有趣外卖。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e3e59839e06ea680df7d919ec918be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1GySmgmosol4r1uuwoBTtg.png"/></div></div></figure><p id="abb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">浅薄的比较作为一个概念是完全反动的发展。它在不同的流程中起着关键作用，也可以在React组件生命周期的几个地方找到。想想决定类组件是否应该更新的机制，React钩子的依赖数组，通过<code class="fe lq lr ls lt b">React.memo</code>的记忆，等等。</p><p id="22f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您曾经通读过React官方文档，那么您很可能已经看到过经常提到的术语“浅层比较”。但大多数时候，它只是一个关于其存在的小说明，很少涉及到其他内容。因此，这篇文章将探究浅层比较的概念，它到底是什么，它是如何工作的，并以一些你很可能还不知道的有趣的要点结束。</p><h1 id="810b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">陷入肤浅的比较</h1><p id="1f0c" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">理解浅层比较最直接的方法是深入研究它的实现。相应的代码可以在<code class="fe lq lr ls lt b">shared</code>子包中的<a class="ae mr" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank"> React Github项目</a>中找到。在那里，您将找到包含我们正在寻找的代码的<code class="fe lq lr ls lt b">shallowEqual.js</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b363" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事情还挺多的，我们把它拆分一下，一步一步的过函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="fd58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从函数定义开始，该函数接受两个相互比较的实体。与TypeScript相反，这段代码使用Flow作为类型检查系统。这两个函数参数都是使用特殊的<code class="fe lq lr ls lt b">mixed</code>流类型键入的，类似于TypeScript的<code class="fe lq lr ls lt b">unknown</code>。它表明参数可以是任何类型的值，函数会找出其余的并使其工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="214e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，首先使用React内部的<code class="fe lq lr ls lt b">objects</code>函数<code class="fe lq lr ls lt b">is</code>比较函数参数。导入的函数只不过是JavaScript的<code class="fe lq lr ls lt b"><a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank">Object.is</a></code> <a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank">函数</a>的多填充版本。这个比较函数基本上等同于普通的<code class="fe lq lr ls lt b">===</code>运算符，但有两个例外:</p><ul class=""><li id="5f0d" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><code class="fe lq lr ls lt b">Object.is</code>认为相反的带符号零(<code class="fe lq lr ls lt b">+0</code>和<code class="fe lq lr ls lt b">-0</code>)不相等，而<code class="fe lq lr ls lt b">===</code>认为它们相等。</li><li id="f233" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated"><code class="fe lq lr ls lt b">Object.is</code>认为<code class="fe lq lr ls lt b">Number.NaN</code>和<code class="fe lq lr ls lt b">NaN</code>相等，而<code class="fe lq lr ls lt b">===</code>认为它们不相等。</li></ul><p id="0dde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，第一个条件语句处理了所有简单的情况:如果两个函数参数对于基本类型具有相同的值，或者对于数组和对象引用相同的对象，那么通过浅层比较，它们被认为是相等的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0bfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在处理了两个函数参数的值相等或引用同一个对象的所有简单情况之后，我们想进入更复杂的结构(对象和数组)。然而，如果任一参数是原始值，前面的条件语句仍然可以留给我们原始值。</p><p id="e928" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，为了确保我们从现在开始处理两个复杂的结构，代码检查任一参数是否不属于类型<code class="fe lq lr ls lt b">object</code>或者是否等于<code class="fe lq lr ls lt b">null</code>。前一个检查确保我们处理的是对象或数组，而后一个检查是过滤掉<code class="fe lq lr ls lt b">null</code>值，因为它们的类型也是<code class="fe lq lr ls lt b">object</code>。如果任何一个条件成立，我们肯定是在处理不相等的参数(否则前面的条件语句会把它们过滤掉)，所以浅层比较返回<code class="fe lq lr ls lt b">false</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="69e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然已经确定我们只处理数组和对象，我们就可以把重点放在浅层比较那些数据结构上了。为此，我们必须深入复杂数据结构的值，并在两个函数参数之间进行比较。</p><p id="1efe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在这之前，我们可以做一个简单的检查，确保两个参数有相同的值。如果不相等，通过浅层比较，它们肯定不相等，这样可以节省我们一些精力。为此，我们使用参数的关键字。对于对象，键数组将由实际的键组成，而对于数组，键数组将由字符串中原始数组中被占用的索引组成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4c55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一步，我们通过键迭代两个函数参数的值，并逐个验证它们，以确定它们是否等价。为此，代码使用上一步中生成的键数组，使用<code class="fe lq lr ls lt b">hasOwnProperty</code>检查键是否实际上是参数的属性，并在比较值之前使用相同的<code class="fe lq lr ls lt b">Object.is</code>函数。</p><p id="b6fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果结果是任何键在两个参数之间没有相等的值，那么通过浅层比较可以肯定它们不相等。因此，我们缩短了for循环，从<code class="fe lq lr ls lt b">shallowEqual</code>函数返回<code class="fe lq lr ls lt b">false</code>。如果所有的值都相等，那么我们可以通过浅层比较来调用相等的函数参数，并从函数中返回<code class="fe lq lr ls lt b">true</code>。</p><h1 id="9101" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">有趣的外卖</h1><p id="60fe" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">既然我们理解了浅层比较及其背后的实现，我们可以从这些知识中获得一些有趣的东西:</p><ul class=""><li id="b818" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">浅层比较不使用严格的等式操作符<code class="fe lq lr ls lt b">===</code>，而是使用<code class="fe lq lr ls lt b">Object.is</code>函数。</li><li id="5718" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">通过浅层比较，空对象和数组是等价的。</li><li id="2a90" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">通过浅层比较，以索引作为键的对象相当于在各个索引处具有相同值的数组。例如<code class="fe lq lr ls lt b">{ 0: 2, 1: 3 }</code>相当于<code class="fe lq lr ls lt b">[2, 3]</code>。</li><li id="8eba" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">由于<code class="fe lq lr ls lt b">Object.is</code>的用法超过了<code class="fe lq lr ls lt b">===</code>，<code class="fe lq lr ls lt b">+0</code>和<code class="fe lq lr ls lt b">-0</code>不等价，同样<code class="fe lq lr ls lt b">NaN</code>和<code class="fe lq lr ls lt b">Number.NaN</code>也不等价。如果在一个复杂的结构内部进行比较，这同样适用。</li><li id="53fb" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">当两个内联创建的对象(或数组)通过浅比较相等时(<code class="fe lq lr ls lt b">{}</code>和<code class="fe lq lr ls lt b">[]</code>是浅相等的)，具有嵌套内联对象的内联对象不相等(<code class="fe lq lr ls lt b">{ someKey: {} }</code>和<code class="fe lq lr ls lt b">{ someKey: [] }</code>不是浅相等的)。</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt np lt nq nr aw ns bi"><span id="5d8a" class="nt lv it lt b gy nu nv l nw nx"><strong class="lt iu">Want to Connect?</strong></span><span id="56c1" class="nt lv it lt b gy ny nv l nw nx">If you liked this article, consider checking out the other entries in the <a class="ae mr" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">Uncommon React</a> newsletter and my <a class="ae mr" href="https://twitter.com/keraito" rel="noopener ugc nofollow" target="_blank">Twitter</a> for future updates.</span></pre></div></div>    
</body>
</html>