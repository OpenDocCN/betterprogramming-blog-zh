<html>
<head>
<title>The Importance of Writing WASM-Compatible Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写WASM兼容代码的重要性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-importance-of-writing-wasm-compatible-code-7916519fa30e?source=collection_archive---------11-----------------------#2022-08-30">https://betterprogramming.pub/the-importance-of-writing-wasm-compatible-code-7916519fa30e?source=collection_archive---------11-----------------------#2022-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ebd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这不需要太多的努力，而且它可能是分发它的关键</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db878914c055a2dcd4d2cce7f8c9886c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XFRxRt5J6mn9IWr4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@labunsky?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Artem Labunsky </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经写了几篇关于WebAssembly和Rust的文章，但是这篇文章应该对那些用可以编译成WASM的语言编写代码的人有用，尤其是如果你使用的是一流的WebAssembly公民，比如Rust、C、C++或Zig。</p><p id="7ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你没有读过WASM的介绍性资源，比如本帖中的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/get-started-with-wasm-in-rust-2347056bab4">，WebAssembly是一种二进制语言，由它的VM转换成机器代码。你没听错，是VM，也就是说你只需要一个支持WASM的VM就可以运行任何以<code class="fe lv lw lx ly b">.wasm</code>结尾的可执行文件。此外，在大多数情况下，将您的代码编译成WASM只需很少的努力。</a></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c894" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">WASM应用程序的工作流</h1><p id="827c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在解释为什么您应该拥有wasm兼容版本的代码之前，让我们来看看您开发和部署WASM应用程序的流程是什么样的:</p><ol class=""><li id="c883" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">将代码/现有代码移植到wasm兼容的分支中</li><li id="972b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">将其编译为WebAssembly</li><li id="0278" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">发布<code class="fe lv lw lx ly b">.wasm</code>二进制文件</li><li id="7933" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">有人管理它，例如:<code class="fe lv lw lx ly b">wasmer run your_code.wasm</code></li></ol><p id="d17d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样:一个不需要安装和跨平台(是的，还有移动)的解决方案，只需要你编译<code class="fe lv lw lx ly b">your_code</code>到WebAssembly。</p><p id="596c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这几乎让我想起了docker，它们有着相似的特征，正如这里的<a class="ae ky" href="https://www.docker.com/blog/why-containers-and-webassembly-work-well-together/" rel="noopener ugc nofollow" target="_blank">所解释的那样</a>，Docker可以运行wasm容器，它们甚至可能成为最流行的容器。</p><h1 id="a590" class="mg mh it bd mi mj nr ml mm mn ns mp mq jz nt ka ms kc nu kd mu kf nv kg mw mx bi translated">编译到WASM意味着什么</h1><p id="07cf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">构建面向WebAssembly的代码意味着任何人都可以运行它，而无需安装、依赖冲突和强制安全性，尤其是在使用Rust等语言编写代码时，Rust以在编译时强制执行安全实践而闻名。</p><p id="7b28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为用户，您可能更愿意运行WASM二进制程序，因为您知道只要虚拟机是安全的，它就可以运行在沙盒中，例如，如果它无法检查变量的边界，就不会容易发生转义，在本例中，这是解释器的问题。</p><p id="68c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使WASM是一项相对较新的技术，像Cloudflare这样的服务已经提供了一个<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/rust-for-the-fastest-serverless-experience-80530acdd4d4">环境来将Rust无服务器</a>功能部署到Cloudflare网络，就像它们是JavaScript功能一样。</p><p id="0bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种多功能性是每个开发人员在编写代码时都应该考虑的，特别是当它不需要花费太多精力来实施本段中描述的特征时。</p><h1 id="f63a" class="mg mh it bd mi mj nr ml mm mn ns mp mq jz nt ka ms kc nu kd mu kf nv kg mw mx bi translated">+1如果不依赖Rust的标准库</h1><p id="c2ad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于大多数用例来说,<code class="fe lv lw lx ly b">std</code>工作得很好，但是目标WASM的构建更有可能在<code class="fe lv lw lx ly b">#[no_std]</code>环境中运行，因为它们可能是嵌入式系统，或者在一般环境中,<code class="fe lv lw lx ly b">.wasm</code>二进制文件中的每个字节在成本和性能方面都有所不同。</p><p id="b73a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust标准库包含了很多东西，所以如果你能依靠<code class="fe lv lw lx ly b">core</code>库来构建你的应用，那对你来说就是+1。你可能仍然需要在<code class="fe lv lw lx ly b">std</code>中使用类型，比如向量。然而，你可以<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/rust-should-you-work-on-your-own-types-yes-and-heres-how-5214c61300b0">创建你自己的</a> <code class="fe lv lw lx ly b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/rust-should-you-work-on-your-own-types-yes-and-heres-how-5214c61300b0">Vec</a></code> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/rust-should-you-work-on-your-own-types-yes-and-heres-how-5214c61300b0">类型</a>或者用你需要的基本类型创建你自己的<code class="fe lv lw lx ly b">std</code>库，而不是使用整个std及其prelude导入。</p><h1 id="8f20" class="mg mh it bd mi mj nr ml mm mn ns mp mq jz nt ka ms kc nu kd mu kf nv kg mw mx bi translated">编译到WASM</h1><p id="c419" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我只用过Rust的WebAssembly，我不认为我需要为此切换到另一种语言。如果你不知道Rust/C/C++/Zig或任何其他支持编译到WASM的语言，你可以使用AssemblyScript (AS ),但它很可能会导致内存使用效率较低，这并不一定意味着它会运行得更慢，但在一些情况下，如智能合同开发，你需要小心内存的去向，因为你要支付费用，我总是建议使用高效的语言。</p><p id="60d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这部分只是关于编译Rust到WASM，因为我没有用其他语言编译的经验。然而，其中一些提示可能对其他语言也有用，因为它们引用了更广泛的WASM二进制。</p><p id="88a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将库编译成WebAssembly(在Rust中)非常简单:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="8184" class="oa mh it ly b gy ob oc l od oe">cargo build —-target wasm32-unknown-unknown</span></pre><p id="0238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是您可能会看到一些错误，这些错误是您在不针对WebAssembly进行测试或构建时看不到的，尤其是如果库很大并且依赖于许多依赖项(这些依赖项通常依赖于许多依赖项本身)。以下是一些常见错误和相应的修复方法。</p><h1 id="7603" class="mg mh it bd mi mj nr ml mm mn ns mp mq jz nt ka ms kc nu kd mu kf nv kg mw mx bi translated">库不兼容性</h1><p id="7c42" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最常见的错误很可能是库不兼容，这给你留下了四个选项:</p><ul class=""><li id="b480" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu of nj nk nl bi translated">有时候，你只需要启用特性；一些库可能支持WASM，但只有特定的特性标志。在这种情况下，您可能想要检查库的<code class="fe lv lw lx ly b">Cargo.toml</code>文件并查看可用的特性。</li><li id="469c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu of nj nk nl bi translated">在库的存储库中打开一个问题，询问WASM支持，最好的情况是，维护者可以添加它。</li><li id="8f91" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu of nj nk nl bi translated">叉库加WASM支持自己</li><li id="a6f6" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu of nj nk nl bi translated">使用另一个WASM兼容的库</li></ul><h1 id="59b7" class="mg mh it bd mi mj nr ml mm mn ns mp mq jz nt ka ms kc nu kd mu kf nv kg mw mx bi translated">避免文件系统</h1><p id="66c7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">web上没有文件系统。因此，WebAssembly中没有。如果需要读写文件，可以将内容作为参数提供。一些虚拟机还允许您提供输入和输出作为CLI参数。</p><p id="502a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，你可以看看WASI的<a class="ae ky" href="https://github.com/bytecodealliance/wasi" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="6eef" class="mg mh it bd mi mj nr ml mm mn ns mp mq jz nt ka ms kc nu kd mu kf nv kg mw mx bi translated">避免系统库</h1><p id="9b41" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">WASM没有系统库(很明显)，绑定到系统库的板条箱不会工作。</p><h2 id="b4a1" class="oa mh it bd mi og oh dn mm oi oj dp mq li ok ol ms lm om on mu lq oo op mw oq bi translated">对依赖std的库持怀疑态度</h2><p id="4436" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用Rust标准库的库更有可能执行非法的wasm操作，比如访问文件系统。</p><h2 id="79b1" class="oa mh it bd mi og oh dn mm oi oj dp mq li ok ol ms lm om on mu lq oo op mw oq bi translated">如果您正在与JS通信，请使用<code class="fe lv lw lx ly b">wasm-bindgen</code></h2><p id="c5ac" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这里不多说了，<code class="fe lv lw lx ly b">wasm-bindgen</code>是Rust和JavaScript之间的桥梁。如果你在浏览器上使用WASM，你可能需要使用这个箱子。例如，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/get-started-with-wasm-in-rust-2347056bab4">我在本文</a>中使用了它。</p><h1 id="a12e" class="mg mh it bd mi mj nr ml mm mn ns mp mq jz nt ka ms kc nu kd mu kf nv kg mw mx bi translated">不要做同步输入输出的事情</h1><p id="bb8e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">网络是异步的。您不能同步执行I/O，但必须使用期货。例如，编译到WASM的rust Cloudflare工作程序就是这样设法等待它收到的请求内容的:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="6c1f" class="oa mh it ly b gy ob oc l od oe">router.post_async("/wasm", |mut req, ctx| async move {     <br/>    ...<br/>    let json_string = req.text().await?;<br/>    ...<br/>}</span></pre><p id="b938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到我们多么需要一个异步方法来产生结果。</p><h1 id="982e" class="mg mh it bd mi mj nr ml mm mn ns mp mq jz nt ka ms kc nu kd mu kf nv kg mw mx bi translated">分配器投诉</h1><p id="7f3a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你使用的是分配函数，并且想在没有标准库的情况下编译成wasm，你需要使用<code class="fe lv lw lx ly b">wee_alloc</code>作为<a class="ae ky" href="https://heytdep.github.io/comp_posts/1)--Rust:-wasm-with-no-std-allocator/post.html" rel="noopener ugc nofollow" target="_blank">，我在我的第二篇博客中解释了</a>。</p><p id="c4d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="or">如果你觉得我在这一部分遗漏了什么，请在评论部分随意添加内容。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="4f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的代码，使其与WASM兼容会有不同的难度。在某些情况下，这是不值得的，例如，如果代码严重依赖于文件系统，并且您不打算创建一个与WASI一起工作的fork。</p><p id="a1f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文并不是要告诉开发人员总是要编写WASM兼容的代码，而是要考虑web assembly实施的一些策略，以及它们是否很适合他们的应用程序或工具。即使我强烈支持WebAssembly并试图用WASM兼容的语法来思考，我最近还是创建了自己的静态博客，使用不兼容WASM的Rust脚本将LaTeX文档转换成我的帖子。和所有事情一样，这都是关于取舍的。</p><p id="bed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>