# 在 Python 中使用正则表达式之前应该知道的 7 件事

> 原文：<https://betterprogramming.pub/7-things-you-should-know-before-using-regular-expressions-in-python-c79305e117d9>

## 利用这个强大的工具

![](img/efc5c1609ffd7e651df30e4fbe5b1ebe.png)

由[文森特·索罗门](https://unsplash.com/@vincentiu?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

# 介绍

除了数字，文本是最常见的数据形式。几乎在任何 Python 项目中，我们都需要处理文本数据。尽管 Python 在 String 类中提供了有用的方法，但是一些使用场景超出了这些基本方法所能解决的范围，尤其是在复杂的模式匹配方面。在这些情况下，我们应该考虑使用正则表达式。

正则表达式通常简称为 regex 或 regexp，是定义文本中特定搜索模式的字符序列。应该注意的是，正则表达式可以被认为是一个独立的实体，尽管每种编程语言支持正则表达式的方式有所不同。由于它的相对独立性，好消息是一旦你学会了正则表达式，你就可以用最小的学习曲线在任何其他编程语言中应用这种文本处理技术。

事不宜迟，我们开始吧。

# 1.使用方式概述

作为标准库的一部分，`re`模块专门提供 Python 中与正则表达式相关的特性。

使用这个模块有两种常见的方式。

第一种方式属于 Python 的面向对象编程方面。本质上，您首先创建一个模式，它是一个 Python 对象。该模式有一系列您可以使用的方法，例如搜索和替换。考虑这种风格的以下代码:

使用正则表达式的 OOP 风格

另一种风格或多或少采用了功能性方法。不是创建一个模式，而是直接调用函数，此时指定模式。这种风格如下所示。

使用正则表达式的函数风格

在幕后，Python 为我们创建了模式，并调用相应的方法。因此，这个中间步骤强调了这两种风格之间的关键区别，尽管可用的方法和它们的调用签名几乎是相同的。当您使用 compile 函数创建模式对象时，编译后的模式将被缓存，这样，如果您多次使用该模式，它们会更有效。如果只使用一次，就不需要担心这两种方法的区别。

# 2.原始字符串

正则表达式使用具有特殊含义的特殊字符。例如，我们用`\d`表示数字，用`\w`表示 Unicode 单词字符。您会注意到，我们使用反斜杠来表示这些字符有特殊的含义。巧合的是，Python 使用反斜杠来表示特殊字符，比如用`\t`表示制表符，用`\n`表示换行符。同时，反斜杠用于转义一些特殊字符，包括反斜杠本身。例如，如果您想匹配字符串中的`\`，您可以指定`\\`。

当这两个需求结合在一起时，你最终不得不使用看起来很奇怪的模式。假设我们想在字符串中搜索`\toe`。因为`\t`在这里是一个文字，而不是文字制表符，所以我们必须使用`\\toe`，这样 Python 字符串就会搜索`\toe`。让事情变得复杂的是，在编译正则表达式模式时，必须对两个反斜杠进行转义，这产生了四个反斜杠`\\\\toe`来在字符串中搜索`\toe`。看看下面的一些相关代码:

正则表达式中的反斜杠

请注意，match 方法将在字符串的开头执行搜索。你觉得会配什么？上述代码将生成以下打印结果:

```
Match '\toe': None
Match '\\toe': <re.Match object; span=(0, 4), match='\\toe'>
Match '\\\toe': None
Match '\\\\toe': None
```

如您所见，只有`“\\toe”`被匹配，因为两个连续的反斜杠被解释为一个文字反斜杠，这使得字符串有效地`“\toe”`，匹配正则表达式。

显然，使用这么多反斜杠会让其他人感到困惑。为了解决这个问题，我们使用原始字符串符号，它要求 Python 不处理反斜杠。应用这种技术，我们可以更新上面的代码来达到同样的效果。请注意，我们现在使用原始字符串来创建模式。

原始字符串的使用

所以，你想用原始字符串创建正则表达式是个好主意。

# 3.正则表达式的一般语法

前两节更具体地针对 Python。它们应该相对简单。我猜让很多程序员困惑的是正则表达式本身的语法。如前所述，正则表达式被认为是一种独立的语言，Python 主要采用它们的语法。

掌握正则表达式的核心语法需要大量的实践——反复试验。但是在我们开始尝试之前，我们需要对重要的类别有一个概述。

第一类是关于定义搜索字符串的边界，有时称为锚点:

```
**#1 Boundary Anchors****^hi**        starts with hi
**hey$**       ends with hey
**^hi hey$**   starts and ends with "hi hey" (exact matching)
```

以下代码片段显示了一些 Python 示例:

正则表达式的锚

第二类是关于定义搜索字符串的数量。

```
**#2 Quantifiers****hi?**       h followed by zero or one i
**hi***       h followed by zero or more i
**hi+**       h followed by one or more i
**hi{3}**     h followed by iii
**hi{1,3}**   h followed by i, ii, or iii
**hi{2,}**    h followed by 2 or more i
```

下面的代码片段向您展示了一些关于量词的 Python 示例。需要注意的一点是，使用使用`*`、`+`和`?`的正则表达式进行搜索是“贪婪的”，这意味着它将尽可能尝试匹配最长的序列。要修改这种默认行为，您可以在这些量词后面添加后缀`?`(即`*?`、`+?`和`??`)。这将采用一种非贪婪的方法来搜索尽可能具有最短长度的匹配序列。

正则表达式的量词

第三类是定义一个宽泛的类别或字符集。

```
**3\. Character Classes/Sets****\d**       any decimal digit
**\D**       any character that is not a decimal digit
**\s**       any whitespace, including space, \t, \n, \r, \f, \v
**\S**       any character that isn't a whitespace
**\w**       any word character, including underscores
**\W**       any character that is not a word character
**.**        any character except a newline
**[]**       a set of characters
```

我们用方括号来定义一组字符。对于这种用法，有几点需要注意:

*   该集合可以是单个字符。例如，`[abc]`将匹配`“a”`、`“b”`，或者`“c”`、`[3c]`将匹配`“3”`或`“c”`。
*   该集合可以是一系列字符。例如，`[a-z]`将匹配`“a”`和`“z”`之间的任何字符，`[A-Z]`将匹配`“A”`和`“Z”`之间的任何字符。

下面的代码片段向您展示了一些相关的使用示例。

字符类/正则表达式集

第四类是关于定义逻辑操作。

```
**4\. Logical Operators**
**a|b**       a or b
**(abc)  **   abc as a group
[^a]      any character other than a
```

*   严格地说，分组本身并不是一种逻辑操作。
*   可以使用插入符号将字符集创建为补码，插入符号“否定”指定的字符集。

下面显示了一些 Python 示例。

正则表达式的逻辑运算符

# 4.编译标志

编译正则表达式时，我们可以选择指定标志。这些将修改给定正则表达式的含义。以下是常用标志的列表:

```
re.A (re.ASCII)       match ASCII-only for character sets (e.g., \w)
re.I (re.IGNORECASE)  ignore cases
re.M (re.MULTILINE)   each line is considered with ^ and $
re.S (re.DOTALL)      . will match newline too
re.X (re.VERBOSE)     allow comments
```

相关的 Python 示例如下所示:

正则表达式的标志

*   这些例子中的每一个都包括一个不使用相应标志的直接对比。
*   该标志不仅在创建正则表达式模式时设置，还可以通过调用模块级函数来指定。
*   标志可以组合，比如`flags=re.I|re.M`，如下例所示。

```
>>> re.findall("^hi", "hi\nHi\nhI", flags=re.I|re.M)
['hi', 'Hi', 'hI']
```

# 5.匹配对象的多个方面

当您使用正则表达式时，在许多情况下，您将处理`Match`对象。关于 Match 类的详细信息当然可以在官方文档中找到。在这里，我将强调一下`Match`对象的一些常用方面。

让我们首先看看正则表达式搜索中的一个`Match`对象的默认表示。

```
>>> match = re.match(r"(.\d)*", "a1b2c3dd")
>>> print(match)
<re.Match object; span=(0, 6), match='a1b2c3'>
```

关于`Match`对象的最基本信息是匹配的字符串及其跨度(开始和结束)。以下是检索这些信息的方法。

匹配对象的基本信息

`Match`对象被评估为`True`。当搜索相关的函数(如`search`、`match`)没有找到匹配时，将返回`None`。因此，我们通常采用以下模式进行条件求值。

```
match = re.match("pattern", "string to match")
if match:
    print("do something with the matched")
else:
    print("found no matches)
```

匹配的字符串可以有多个组。您可能已经注意到，我们使用`group`方法来检索匹配的字符串。还有一个密切相关的方法——`groups`，观察下面这个例子。

访问正则表达式组

在上面的例子中，模式包括两组，如使用两对括号所示。识别的匹配将创建与模式的组相对应的单独的组。如您所见，默认情况下，组 0 是整个匹配。随后的组将向您展示根据每个组中的指定模式确定的内容。

与分组相关，跨度可以按组检索。下面是一些例子。

```
>>> float_match.span(0)
(0, 5)
>>> float_match.span(1)
(0, 2)
>>> float_match.span(2)
(3, 5)
```

## 6.命名组

在上一节中，我们看到了`Match`对象中的组。具体来说，我们使用索引来检索适当的组，以便进一步检查。然而，索引很容易出错。

为了解决这个问题，我们可以利用命名组特性，这是与分组相关的最重要的特性之一。最好用一个例子来说明这个特性:

命名的正则表达式组

这段代码中有几件事值得注意。

*   要命名一个组，我们使用语法(？P <name>…)。该名称应该是有效的 Python 标识符，因为它必须能够在以后被检索以供参考。</name>
*   命名的组可以通过它们各自的名称来引用。例如，为了检索`last_name` 组，我们使用`matched.group(‘last_name’)`。
*   虽然最好使用组名来检索它们的信息，但是也可以使用它们各自的索引来检索它们。
*   `Match`对象有一个名为`groupdict`的方法，它将检索指定组的信息。请注意以下特征:

```
>>> matched.groupdict()
{'last_name': 'Robinson', 'first_name': 'Zoe', 'age': '37'}
```

正如您可能看到的，当您需要处理由模式识别的子组时，命名组可能特别有用。这些名称可以显著提高代码的可读性。

# 7.常用方法概述

使用正则表达式处理字符串数据有不同的方法。您可以在官方文档中找到受支持方法的完整列表。在这里，我只回顾一些常用的方法:

*   `search`，如果在字符串中的任何地方发现匹配，它将返回一个`Match`对象。
*   `match`，如果在字符串开头识别出匹配，则返回一个`Match`对象。

以下代码向您展示了与这两种搜索方法相关的几个示例:

使用正则表达式搜索

*   `findall`，返回与模式匹配的字符串列表。请注意，当模式中有多个组时，列表项将是一个匹配组的元组。
*   `finditer`，返回产生`Match`对象的迭代器。

使用正则表达式查找所有内容

*   `split`，按模式拆分字符串。您可以选择设置最大允许拆分。

```
>>> text_to_split = 'a1b2c3d4e555f99'
>>> re.split(r"\d+", text_to_split, maxsplit=5)
['a', 'b', 'c', 'd', 'e', 'f99']
```

*   `sub`，根据定义的模式和替换，通过替换第一个匹配的字符串来创建一个字符串。值得注意的是，替换可以是一个字符串或一个函数，后者将接受一个单独的`Match`对象作为它的参数。

```
>>> text_to_sub = '123,456,789_012_345/678'
>>> re.sub(r"\D", "-", text_to_sub)
'123-456-789-012-345-678'
```

# 结论

在本文中，我们回顾了 Python 中正则表达式的基本方面。作为总结，我推荐你掌握正则表达式的三个步骤。

*   理解正则表达式本身的基本语法，它们相对独立于您使用的编程语言。一旦你学会了它们，你几乎可以在任何支持正则表达式的语言中使用它们。
*   使用正则表达式作为编译模式或直接使用模块级函数。可用的函数应该简单明了，提供常见的文本操作技术，包括搜索、拆分和替换。
*   学习一些高级技术，比如分组。本文也没有涉及其他一些高级正则表达式，比如使用`lookahead`和`lookbehind`断言，这些可以在官方文档中找到。