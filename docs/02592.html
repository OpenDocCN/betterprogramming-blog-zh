<html>
<head>
<title>How To Never Have to Track a UITableView’s IndexPath Ever Again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何再也不用跟踪UITableView的索引路径</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-never-have-to-track-a-uitableviews-indexpath-ever-again-a727be52003a?source=collection_archive---------10-----------------------#2019-12-10">https://betterprogramming.pub/how-to-never-have-to-track-a-uitableviews-indexpath-ever-again-a727be52003a?source=collection_archive---------10-----------------------#2019-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f66" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">索引超出范围，不再有</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1c67d6f1b8bc3865122cde2fd9f55a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6M6CjZ8ApuoGvERMRaOKoQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/photos/YSZS_nDU8js?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">思想目录</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="68c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多少次您不得不处理手动跟踪UITableView的索引路径的麻烦？或者，你以前调试过多少次？</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="7c78" class="lx ly iq lt b gy lz ma l mb mc">Invalid update: invalid number of rows in section...</span></pre><p id="c918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有一种方法可以解决这个问题呢？</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="6c1b" class="mk ly iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">引入视图模型驱动的UITableViews</h1><p id="4047" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">每个UITableViewCell都有自己的等价视图模型，在设置时传递给它。下面是一个简单的标题单元格示例，它接受一个包含标题的标签并将其设置在单元格上。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="79d5" class="lx ly iq lt b gy lz ma l mb mc">Helpful tip: The view model's equatable function doesn't need to be implemented if all the properties in the struct are Equatable.</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/66fad6e74b12ac8e7e75267034f9c02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjnvCgVB8mZrao8hXQWk2g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个UITableViewCell，它接受一个相等的视图模型结构并设置它</p></figure><p id="deec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们构建一个要在屏幕上显示的视图模型列表时，我们可能想要支持不止一种类型。在这种情况下，我们可以利用带有关联值的枚举。</p><p id="2108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我有两个想要显示的单元格。因此，我用两个枚举来表示每个单元格。相关联的值包含等价的视图模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/6112c9b99108385d8e02c3da86a08ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PsCu7TJy_sMoyb5fJCtOFA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">表示将在UITableView中显示的每个单元格的等价枚举</p></figure><p id="32a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，如果我们使用MVC，我们可以从我们的控制器创建视图模型，如果我们使用MVP，我们可以从presenter创建视图模型。显然，这将根据您的应用程序的架构而有所不同。在我们的例子中，我们从presenter调用UIViewController上的一个函数，以便在数据加载后向它提供数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/c3904eb4813d505a7c26f6027873c32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6GDL1CAMUegnaSN59xzcg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建和设置视图的视图模型的函数</p></figure><p id="4095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们需要实现reloadTableView(..)功能。这将获取当前视图模型的快照，将其更新为新的视图模型，并调用我们通过UITableView上的扩展添加的函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/88443326aa6e64a7fb4f67c172fffc9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTkDTkwScRwnWJBB_gynqg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">UIViewController上的Reload函数来重新加载UI。</p></figure><p id="e6f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用以下文件将tableView上调用的reloadWithAnimation函数添加到您的项目中:</p><div class="nk nl gp gr nm nn"><a href="https://github.com/aduuub/uitableviewdataflowtutorial/blob/master/Extensions/UITableView%2BReload.swift" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">aduub/uitableviewdataflow教程</h2><div class="nu l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kp nn"/></div></div></a></div><p id="ece6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您不需要理解扩展的工作方式，但是它本质上区分了当前快照和新视图模型之间的差异，然后适当地插入、更新和重新加载视图。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="f0b6" class="mk ly iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">实现UITableViewDataSource</h1><p id="56ba" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">对于部分中的行数，我们可以简单地返回数组中视图模型的数量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/3939aee751513b87bef07795359fb2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v03Itvs3ndGWWehUxFs_sQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">numberOfRowsInSection的UITableViewDataSource实现</p></figure><p id="040a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们将单元格出队时，我们不需要担心它是用于什么索引，因为它完全是由视图模型驱动的。我们还防止了会默认返回空的UITableViewCell的意外失败。注意，dequeueCell函数是一个定制的扩展，您可以在这里将它添加到您的项目<a class="ae kv" href="https://github.com/aduuub/uitableviewdataflowtutorial/blob/master/Extensions/UITableView%2BExtensions.swift" rel="noopener ugc nofollow" target="_blank">中。或者，可以使用标准的tableView dequeueCell。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/d4783098a50fe49d4a4540a91edfb94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6L0T3XSvXFlykH_6nsBYg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">cellForRowAt的UITableViewDataSource实现</p></figure><p id="9bc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于处理点击事件，我们可以很容易地根据选择的IndexPath进行切换，以确定相应的视图模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/d78a5e79f9face8ffbca3c0f09ecc343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0PC8ckNXw92iNLZQ6ZXXg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">didSelectRowAt的UITableViewDelegate实现</p></figure></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="b24c" class="mk ly iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">多个部分</h1><p id="f258" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">轻松点。您所需要做的就是使视图模型阵列2D。第一个数组表示节，内部数组表示节中的行。reloadTableViewWithAnimation有两个支持这两种方法的实现。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="80fc" class="mk ly iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">演示</h1><p id="6049" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">下面的例子来自我最近创建的一个学习驾驶的应用程序。我只是将项目从一个部分移动到另一个部分，或者完全删除它。这使用了本文中演示的RowAnimation.fade和自定义删除逻辑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/01c9c0e35d746f98e670163c35a08c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*0Pj0UOCqBjWXl1NMjEoWtA.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从视图模型中删除项目</p></figure></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="ae29" class="mk ly iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">想看看这个项目吗？</h1><p id="9c21" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">你可以在下面的我的Github上查看这个项目的所有代码。</p><div class="nk nl gp gr nm nn"><a href="https://github.com/aduuub/uitableviewdataflowtutorial" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">aduub/uitableviewdataflow教程</h2><div class="of l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">有多少次你不得不处理手动跟踪UITableView的索引路径的麻烦？或者有一个…</h3></div><div class="nu l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="og l nx ny nz nv oa kp nn"/></div></div></a></div></div></div>    
</body>
</html>