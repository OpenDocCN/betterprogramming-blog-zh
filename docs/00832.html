<html>
<head>
<title>WebGL enhanced drag slider tutorial with curtains.js (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebGL增强拖动滑块教程(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/webgl-enhanced-drag-slider-tutorial-with-curtains-js-part-1-17a11431fb94?source=collection_archive---------8-----------------------#2019-07-18">https://betterprogramming.pub/webgl-enhanced-drag-slider-tutorial-with-curtains-js-part-1-17a11431fb94?source=collection_archive---------8-----------------------#2019-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4e62" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">HTML、CSS和JavaScript入门</h2></div><h1 id="85c7" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">概观</h1><p id="357a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本教程中，我们将学习如何用javascript构建一个拖动滑块，并用强大的WebGL功能增强它。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/4be96d471e3ede5017613e07afbfe95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*Z_N7JlI5O4CZyeDJh-2O7A.gif"/></div></figure><p id="58c0" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">滑块将由三部分组成。在第一部分中，我们将编写一个Slider类，它将创建一个简洁的响应拖动滑块。在第二部分中，我们将扩展它以添加WebGL效果。在第三部分，也是最后一部分，我们将学习如何通过删除所有不必要的回流或布局调用来提高整体性能。</p><p id="bef6" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">WebGL部分将由开源的香草javascript库<a class="ae mg" href="https://www.curtainsjs.com/" rel="noopener ugc nofollow" target="_blank">currents . js</a>处理。它在这里特别有用，因为它的主要目的是用WebGL效果增强DOM元素。只需几行javascript，您就可以创建WebGL纹理平面，绑定到我们的滑块项目的HTML元素，并对整个场景进行后期处理。</p><p id="c89f" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">我们很容易看出使用窗帘的好处。js:</p><ul class=""><li id="607a" class="mh mi iq kz b la mb ld mc lg mj lk mk lo ml ls mm mn mo mp bi translated">干净和搜索引擎友好的HTML代码</li><li id="a0fc" class="mh mi iq kz b la mq ld mr lg ms lk mt lo mu ls mm mn mo mp bi translated">您不必担心WebGL对象的大小和位置</li><li id="8bbe" class="mh mi iq kz b la mq ld mr lg ms lk mt lo mu ls mm mn mo mp bi translated">大多数事情(比如调整大小)将由库在幕后处理。</li><li id="4a9b" class="mh mi iq kz b la mq ld mr lg ms lk mt lo mu ls mm mn mo mp bi translated">在任何情况下，如果在WebGL初始化期间或在您的着色器中出现错误，滑块仍将工作！</li></ul><p id="3699" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">我们将在第二部分中讨论所有这些内容。现在，让我们来看看javascript拖动滑块。</p><p id="47e9" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">这是我们在第一部分结束时看到的:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="3cc0" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">第一部分。HTML和CSS</h1><h2 id="4750" class="mx kg iq bd kh my mz dn kl na nb dp kp lg nc nd kr lk ne nf kt lo ng nh kv ni bi translated">超文本标记语言</h2><p id="d0b1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">HTML非常简单。我们将在主体结束标记之前添加一个slider.steup.js javascript文件，这是放置javascript代码的地方。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj mw l"/></div></figure><h1 id="fdb8" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h1><p id="ad62" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">CSS也很简单。我们的#planes div使用flexbox来显示它的子元素。我们根据幻灯片的宽度和数量来设置横向模式的宽度。在纵向模式下，我们重置其宽度，并将伸缩方向改为列。</p><p id="d9ca" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">我们将在拖动过程中添加一些CSS属性，防止文本选择和一些动画。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj mw l"/></div></figure><h1 id="1b29" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">第二部分。拖动滑块Javascript</h1><p id="4e88" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在让我们建立我们的滑块。</p><p id="9c45" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">总而言之，这个滑块有三个步骤:</p><ul class=""><li id="b019" class="mh mi iq kz b la mb ld mc lg mj lk mk lo ml ls mm mn mo mp bi translated"><em class="nk">在鼠标按下</em>时，我们将开始拖动我们的滑块，并得到我们的拖动开始位置。滑块开始平移。</li><li id="5aeb" class="mh mi iq kz b la mq ld mr lg ms lk mt lo mu ls mm mn mo mp bi translated"><em class="nk">在鼠标抬起时</em>，我们将得到鼠标拖动的结束位置，用于下一次拖动。请注意，滑块仍在平移，直到我们的线性插值完成。</li><li id="c2dd" class="mh mi iq kz b la mq ld mr lg ms lk mt lo mu ls mm mn mo mp bi translated">我们将<em class="nk">在滑块的当前平移和鼠标拖动位置之间连续插入滑块的位置。我们将建立一个请求动画帧循环来处理这个问题。</em></li></ul><p id="a48d" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">我们将首先创建一个slider类来处理我们的Slider并初始化它的变量。</p><p id="9a42" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">我们编写了三个辅助函数来插值、检索鼠标和触摸位置，以及设置滑块方向和边界。然后我们添加几个钩子——稍后当我们扩展Slider类来添加WebGL部分时，这些钩子会很有用:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj mw l"/></div></figure><p id="b275" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">接下来，我们负责动画和翻译。我们使用一个请求动画帧循环来更新滑块在每个tick的平移，并设置所需的钩子。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj mw l"/></div></figure><p id="e74b" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">在下一部分中，我们将编写绑定到事件侦听器的方法。我们将在这里编写我们已经看到的三个主要步骤。我们还将添加一个在调整大小时调用的方法。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj mw l"/></div></figure><p id="e4d7" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">好了，我们差不多完成了拖动滑块。</p><p id="307a" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">我们只需要创建一个设置函数来注册我们所有的事件监听器并开始动画循环。我们将在构造函数中调用它。</p><p id="df4a" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">我们还将创建一个函数来彻底销毁我们的滑块，这意味着删除所有事件侦听器并取消我们的请求动画帧:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nj mw l"/></div></figure><p id="4573" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">暂时就这样了。我希望到目前为止你喜欢它。</p><p id="29d7" class="pw-post-body-paragraph kx ky iq kz b la mb jr lc ld mc ju lf lg md li lj lk me lm ln lo mf lq lr ls ij bi translated">在下一部分中，我们将修改HTML和CSS，然后通过扩展Slider类添加到WebGL部分。</p></div></div>    
</body>
</html>