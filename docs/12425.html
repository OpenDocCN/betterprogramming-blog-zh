<html>
<head>
<title>Hitless TLS Certificate Rotation in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的无中断TLS证书轮换</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hitless-tls-certificate-rotation-in-go-8f24a26ec267?source=collection_archive---------9-----------------------#2022-06-05">https://betterprogramming.pub/hitless-tls-certificate-rotation-in-go-8f24a26ec267?source=collection_archive---------9-----------------------#2022-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb96" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本教程中，我们将讨论如何在Golang中不停机地处理证书轮换。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/359bcc1c03582f787cb90ca1a42365a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zoXYVe2K3211cwsw"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">乔安娜·科辛斯卡在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="603f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">什么是证书轮换，为什么需要证书轮换？</strong></h1><p id="3de7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">证书轮换意味着用新证书替换现有证书。</p><p id="f5be" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有一句古老的TLS格言说:</p><blockquote class="mp mq mr"><p id="c12f" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">如果颁发了证书，则必须对其进行轮换。</p></blockquote><p id="080b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">嗯，在以下情况下需要:</p><ul class=""><li id="9be5" class="mw mx iq lq b lr mk lu ml lx my mb mz mf na mj nb nc nd ne bi translated">任何证书都会过期。</li><li id="2785" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">新的CA机构取代了旧的机构；因此需要为所有服务替换根证书。</li><li id="c3e8" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">需要对一个或多个证书施加新的或修改的约束。</li><li id="a155" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">出现安全漏洞，现有证书链不再可信。</li></ul><p id="3946" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">手动轮换TLS证书可能会很快失去控制，特别是当您必须管理数百个证书时，如果您颁发的证书在几小时内而不是几个月内过期，就会变得完全无法管理。</p><p id="1b22" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nk nl nm nn b"><a class="ae kv" href="https://github.com/shaj13/tlsreconciler" rel="noopener ugc nofollow" target="_blank">tlsreconciler</a></code>通过重新加载包括根CA在内的循环证书，并实时为连接提供TLS协调，无需重启应用程序，来帮助解决这一问题。</p><h1 id="7b28" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">代码</strong></h1><p id="1014" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将从创建我们的项目开始。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="f061" class="ns kx iq nn b gy nt nu l nv nw">mkdir medium &amp;&amp; cd medium &amp;&amp; go mod init medium &amp;&amp; touch main.go</span></pre><p id="52d0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这将创建一个名为“medium”的新目录，并用<code class="fe nk nl nm nn b">go.mod</code>初始化项目。</p><p id="ca5d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还需要安装<code class="fe nk nl nm nn b"><a class="ae kv" href="https://github.com/shaj13/tlsreconciler" rel="noopener ugc nofollow" target="_blank">tlsreconciler</a></code>。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="26c4" class="ns kx iq nn b gy nt nu l nv nw">go get github.com/shaj13/tlsreconciler</span></pre><p id="c57e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们写任何<strong class="lq ir">证书轮换</strong>代码之前，我们需要写一些描述我们的教程程序的强制代码。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="ef74" class="ns kx iq nn b gy nt nu l nv nw">package main<br/><br/>import (<br/>	"crypto/tls"<br/>         "log"<br/>	"net/http"</span><span id="41ba" class="ns kx iq nn b gy nx nu l nv nw">)<br/><br/>func HelloMedium(w http.ResponseWriter, req *http.Request) {<br/>	w.Header().Set("Content-Type", "text/plain")<br/>	w.Write([]byte("Hello Medium.\n"))<br/>}<br/><br/>func main() {<br/><br/>	config := new(tls.Config)<br/>	server := http.Server{<br/>		Addr:      ":443",<br/>		Handler:   http.HandlerFunc(HelloMedium),<br/>		TLSConfig: config,<br/>	}<br/><br/>  	err := server.ListenAndServeTLS("", "")<br/>        if err != nil {<br/>            log.Fatal(err)<br/>        }</span><span id="4f12" class="ns kx iq nn b gy nx nu l nv nw">}</span></pre><p id="6fe0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">运行该程序将返回以下错误。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="f50b" class="ns kx iq nn b gy nt nu l nv nw">open : no such file or directory</span></pre><p id="96f2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">基本上，这个错误从<code class="fe nk nl nm nn b">http.ListenAndServeTLS</code>返回，因为我们已经用空的<code class="fe nk nl nm nn b">tls.Config</code>初始化了服务器，所以它退回到未定义的证书路径参数，稍后将修复它。</p><p id="30a7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们需要让我们的程序捕捉<code class="fe nk nl nm nn b">SIGHUB</code>，这样我们就可以重新加载旋转后的证书。</p><p id="cd81" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是可以做到的，就像这样:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="75d3" class="ns kx iq nn b gy nt nu l nv nw">sigc := make(chan os.Signal, 1)<br/>defer close(sigc)<br/><br/>signal.Notify(sigc, syscall.SIGHUP)</span></pre><p id="4253" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们需要配置<code class="fe nk nl nm nn b">tlsreconciler</code>，就像这样。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="83bd" class="ns kx iq nn b gy nt nu l nv nw">sig := tlsreconciler.WithSIGHUPReload(sigc)<br/>certs := tlsreconciler.WithCertificatesPaths("./cert", "./key", "")<br/>cb := tlsreconciler.WithOnReload(func(c *tls.Config) {<br/>      log.Println("TLS certificates rotated !!")<br/>})</span></pre><p id="c871" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面的代码创建了一个<code class="fe nk nl nm nn b">tlsreconciler</code>配置，在收到一个<code class="fe nk nl nm nn b">SIGHUB</code>时重新加载证书，并调用我们的回调函数打印一个漂亮的日志条目，从给定的路径重新加载证书。</p><p id="9393" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">是时候把这些点连接起来了，我们需要替换下面这条线:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="67b7" class="ns kx iq nn b gy nt nu l nv nw">config := new(tls.Config)</span></pre><p id="dbad" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从<code class="fe nk nl nm nn b">tlsreconciler</code>返回<code class="fe nk nl nm nn b">tls.Config</code>:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="bbad" class="ns kx iq nn b gy nt nu l nv nw">config := tlsreconciler.TLSConfig(sig, certs, cb)</span></pre><p id="192a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您的文件现在应该看起来像这样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="1b4c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">测试我们的代码</strong></h1><p id="7724" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先让我们生成一个证书和私钥:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="912b" class="ns kx iq nn b gy nt nu l nv nw">openssl genrsa -out ./key 2048<br/>openssl req -new -x509 -sha256 -key ./key -out ./cert -days 3650</span></pre><p id="65c6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在让我们运行我们的程序:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="a130" class="ns kx iq nn b gy nt nu l nv nw">go build main.go<br/>./main </span></pre><p id="6562" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们从不同的shell发送一个HTTPS请求:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="55c6" class="ns kx iq nn b gy nt nu l nv nw">curl -k https://127.0.0.1:443/</span></pre><p id="654c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在程序日志中，你会发现下面的日志条目“<code class="fe nk nl nm nn b">TLS certificates rotated !!</code>”。</p><p id="11d0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">出现这种情况是因为<code class="fe nk nl nm nn b">tlsreconciler</code>第一次重新加载了证书，运行更多的curls将不再打印上面的日志条目。</p><p id="2efa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在让我们检查旋转，为此我们将使用<code class="fe nk nl nm nn b">openssl</code>来显示证书</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="600b" class="ns kx iq nn b gy nt nu l nv nw">openssl s_client -showcerts -connect 127.0.0.1:443 2&gt;&amp;1|openssl x509 -noout -serial</span></pre><p id="2f23" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上述命令将打印证书序列号。</p><p id="4d57" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们通过使用<code class="fe nk nl nm nn b">openssl</code>生成新的证书并将<code class="fe nk nl nm nn b">SIGHUP</code>发送到我们的程序来轮换证书</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="e9c3" class="ns kx iq nn b gy nt nu l nv nw">rm -rf ./key ./cert <br/>openssl genrsa -out ./key 2048<br/>openssl req -new -x509 -sha256 -key ./key -out ./cert -days 3650 <br/>kill -SIGHUP &lt;PID&gt;</span></pre><p id="5327" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，让我们验证序列号是否与之前的序列号不同</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="0833" class="ns kx iq nn b gy nt nu l nv nw">openssl s_client -showcerts -connect 127.0.0.1:443 2&gt;&amp;1|openssl x509 -noout -serial</span></pre></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="1058" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望这篇文章对你有所帮助。更多关于<code class="fe nk nl nm nn b">tlsreconciler</code>的内容可以在<a class="ae kv" href="https://github.com/shaj13/tlsreconciler" rel="noopener ugc nofollow" target="_blank"><em class="ms">GitHub</em></a><em class="ms"/>和<a class="ae kv" href="https://pkg.go.dev/github.com/shaj13/tlsreconciler" rel="noopener ugc nofollow" target="_blank"> <em class="ms"> GoDoc </em> </a> <em class="ms">上找到。</em></p></div></div>    
</body>
</html>