<html>
<head>
<title>Why the MVC Architecture is Impossible to Implement in SwiftUI?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么MVC架构不可能在SwiftUI中实现？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-why-mvc-architecture-became-totally-inviable-aeeab4570d79?source=collection_archive---------7-----------------------#2022-09-07">https://betterprogramming.pub/swiftui-why-mvc-architecture-became-totally-inviable-aeeab4570d79?source=collection_archive---------7-----------------------#2022-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4776" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">SwiftUI MVC？我不这么认为。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/803f9bda580fee0454a39e1f9550ed5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZGTDQTtoL0p3BK5N"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://unsplash.com/backgrounds/art/aquarium" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/backgrounds/art/aquarium</a></p></figure><p id="e7f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">苹果并没有平白无故地构建它的核心UI框架。UIKit和SwiftUI在概念上都侧重于前端项目的一些特定架构，甚至一些设计模式。</p><p id="d21d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们之间的核心区别是UIKit的目标是MVC架构，而SwiftUI是为MVVM设计的。</p><p id="b182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管99%的开发人员认为MVC在2022年的项目中没有用，而且MVVM的设计要好得多，但我应该说我们仍然有一些MVC的优势，但由于这篇文章的目的是不同的，我将把它作为一个练习留给读者。</p><h1 id="313f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">UIKit和MVC</h1><p id="5dff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如我之前所说的，苹果创建UIKit框架完全是考虑模型-视图-控制器。</p><p id="e5a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">甚至它的本地类也是这样编码的。在MVC中，所有的流都是围绕着<code class="fe mp mq mr ms b">ViewControllers</code>构建的，它管理一个<code class="fe mp mq mr ms b">View</code>的生命周期(你可以把它们看作一个屏幕单元，尽管它们并不完全是这样)，每个流都包含一个根视图和控制器控制的逻辑(很抱歉是冗余的)<code class="fe mp mq mr ms b">View</code>把一个数据模型作为参数:</p><ol class=""><li id="e67e" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated"><code class="fe mp mq mr ms b">Model</code>:管理你的场景状态，保持所有逻辑数据不变。</li><li id="22e6" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe mp mq mr ms b">Controller</code>:通过监听一些核心事件(加载、出现等)来管理屏幕(或者子组件)的生命周期。)并根据模型输出更新视图。所有控制器都继承自<code class="fe mp mq mr ms b">UIViewController</code>类。</li><li id="3f9d" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe mp mq mr ms b">View</code>:是一块粗糙的画布，里面放置了一些其他的组件。这里没有任何逻辑，每一个变化都是由它的ViewController委托的。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/145c4992530cd9bd3718a571aeea099e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OOsmIptXS2UpDEErtB9q4Q.png"/></div></div></figure><p id="bdad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的架构:我们有一个<code class="fe mp mq mr ms b">Model</code>，它包含了场景的所有逻辑，这些逻辑将反映到我们的<code class="fe mp mq mr ms b">View</code>外观中。我们在<code class="fe mp mq mr ms b">View</code>和<code class="fe mp mq mr ms b">Controller</code>之间有一条虚线，因为尽管我们的控制器有它自己监听视图的方式，但是视图没有(也不能)引用它的ViewController，因为它违反了我们的MVC原则。</p><p id="64d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，<code class="fe mp mq mr ms b">Controller</code>如果不能引用<code class="fe mp mq mr ms b">ViewController</code>又怎么能听我们的<code class="fe mp mq mr ms b">View</code>呢？这背后的关键概念是我们的组件所代表的引用类型。你应该知道我们的<code class="fe mp mq mr ms b">Controller</code>和我们的<code class="fe mp mq mr ms b">View</code>是完全耦合的。<code class="fe mp mq mr ms b">UIViewController</code>引用了从<code class="fe mp mq mr ms b">loadView</code>方法中的xib(或<code class="fe mp mq mr ms b">ViewCode</code>)加载的UIView类型。视图只是作为一个根组件来保存UI的所有部分。</p><p id="92db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe mp mq mr ms b">View</code>有对其子组件的引用，但是<code class="fe mp mq mr ms b">Controller</code>通过<code class="fe mp mq mr ms b">IBOutlet</code>属性有相同的引用(或者惰性变量？)并通过<code class="fe mp mq mr ms b">IBAction</code>事件(或处理方法)监听其事件。由于此<code class="fe mp mq mr ms b">UIViews</code>在<code class="fe mp mq mr ms b"><strong class="ky ir">View</strong></code>和<code class="fe mp mq mr ms b"><strong class="ky ir">Controller</strong></code>之间共享，控制器可以知道事件而不需要<code class="fe mp mq mr ms b"><strong class="ky ir">View</strong></code>告知。</p><p id="fde5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只是一个观察，如果你使用<code class="fe mp mq mr ms b">ViewCode</code>并通过委托或完成在<code class="fe mp mq mr ms b">ViewController</code>和<code class="fe mp mq mr ms b">View</code>之间建立一些通信，现在就停止它，<code class="fe mp mq mr ms b">View</code>不会有任何关于控制器的线索，这与MVVM的情况不同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/df0b448e445c307435ff63137f032250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azrHFfQeh8SK_TjoCuRiBQ.png"/></div></div></figure><p id="1391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为引用类型的视图类允许在两层之间共享内存，所以<code class="fe mp mq mr ms b">Controller</code>管理一个<code class="fe mp mq mr ms b">View</code>，而它对此一无所知。</p><h1 id="558c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">斯威夫图伊和MVVM</h1><p id="bdf2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我认为MVC和MVVM的一个核心区别是我们的逻辑和用户界面的交互方式。</p><p id="257e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们在MVC中的控制器管理一个<code class="fe mp mq mr ms b">View</code>时，就像它是一个照顾产品的制造商一样，在MVVM的<code class="fe mp mq mr ms b">ViewModel</code>充当了我们的视图(现在是<code class="fe mp mq mr ms b">UIView</code> + <code class="fe mp mq mr ms b">UIViewController</code>)应该依赖的所有行为和数据的蓝图。</p><p id="ab27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管我们的ViewModel对视图一无所知，但是视图知道关于我们的ViewModel的一切作为参考。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/0cd60be95dcf5e7b98b43130c4530090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jABDaE4Xda_UDkXQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">谢尔盖·佐尔金在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c20a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">UIKit项目允许MVVM与最初的想法有所不同:我们的<code class="fe mp mq mr ms b">ViewModel</code>能够通过访问协议更新<code class="fe mp mq mr ms b">View</code>，但你可以通过使用共享内存以及通知中心、RxSwift和Combine来扭转这一局面。关键是我们的<code class="fe mp mq mr ms b">View</code>根据我们的<code class="fe mp mq mr ms b">ViewModel</code>状态采取所有的动作，但是ViewModel层并不知道。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/742c90aef711cd7b71be86e9acd56b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9Q0mq47T5-DfzucAQKKsg.png"/></div></div></figure><p id="58cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在SwiftUI中，真正发生的是我们的视图结构依赖于一个<code class="fe mp mq mr ms b">ObservedObject</code> / <code class="fe mp mq mr ms b">StateObject</code>，它对应于我们实现<code class="fe mp mq mr ms b">ObservableObject</code>协议的视图模型，因此在数据更新时重新呈现我们的视图。这样，我们的视图可以将其所有数据参数化到<code class="fe mp mq mr ms b">ViewModel</code>属性，它不需要知道视图，因为当再次渲染并查看<code class="fe mp mq mr ms b">ViewModel</code>时，它会自行更新。</p><h1 id="5917" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">SwiftUI MVC？我想并非如此</h1><p id="985d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如我们之前讨论的，真正使MVC在UIKit中成为可能的是<code class="fe mp mq mr ms b">UIView</code>和<code class="fe mp mq mr ms b">UIViewController</code>之间的共享内存，这依赖于一些UI属性，如按钮、表格视图、子视图等。这样，我们的控制器可以对任何事件做出响应，并自行更新各个组件，而不需要任何组件知道控制器，因此建立了逻辑隔离。让我们在SwiftUI场景中尝试同样的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2d37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有一个<code class="fe mp mq mr ms b">ContentView</code>对应于我们的<strong class="ky ir">视图</strong>层。如你所见，我们有两个对应于<code class="fe mp mq mr ms b">TextFields</code>的注入属性和两个将填充我们下面标签的状态。文本字段将由我们的控制器保存，就像我们在UIKit中所做的一样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个<code class="fe mp mq mr ms b"><strong class="ky ir">Controller</strong></code>层，它有一个可选的<code class="fe mp mq mr ms b">ContentView</code>类型的属性，并创建了两个我们需要监听的文本字段，以便更新我们的UI。由于SwiftUI类型不依赖于委托，我们创建了一个<code class="fe mp mq mr ms b">ContentModel</code>并将其属性绑定到文本字段。</p><p id="2d1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MVC的M不是白代表的。让我们创建我们的模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="37d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，每当我们的模型通过文本字段改变时，我们都使用一个observer <code class="fe mp mq mr ms b">didSet</code>闭包，它将更新我们的视图。剧透:不会的！</p><p id="61a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在创建一个工厂枚举来实例化我们的<code class="fe mp mq mr ms b">ContentView</code>并包装所有其他层:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0c44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们创建一个模型实例，并将其注入到新的<code class="fe mp mq mr ms b">Controller</code>类中。之后，我们用相同的textField值创建一个新的<code class="fe mp mq mr ms b">ContentView</code>，并将其值赋给我们的控制器，然后我们返回我们的视图。</p><h1 id="6546" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运行我们的样本</h1><p id="3e27" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们试着运行我们的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/688f2b0d0bbd473a9a77be0abe5e2d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*y4b0ctBF66hSoHGkfl099w.gif"/></div></figure><p id="04ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，两个标签没有被更新，原因很简单:我们在控制器中“引用”的视图不是引用类型，所以当我们注入视图时，我们实际上是传递了一个副本给<code class="fe mp mq mr ms b">Controller</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/76aec1c159df53440fdfab09d0b6d475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKpNrxwX9ViArYD6TCj9wQ.png"/></div></div></figure><p id="5ad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在UIKit中，所有的UI实例都是类，而不是结构，这使得我们可以使用MVC原则。现在我们没有任何机制来处理来自<code class="fe mp mq mr ms b">Controller</code>的视图以反映<code class="fe mp mq mr ms b">Model</code>数据，因为所有的东西都是副本。</p><h1 id="2c82" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="0b90" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本文中，我们展示了<strong class="ky ir"> MVC </strong>模式由一个中央控制器组成，它通过一个逻辑模型和一个视图进行操作，以保持它们彼此同步。核心是只有控制器知道每个层，并通过共享内存监听它们的变化，这只有引用类型才有可能。我们证明了这种架构不可能在SwiftUI中实现，因为它的声明性本质完全依赖于值类型。如果你们中的任何一个读者可以证明我是错的，并且确实有一种跨SwiftUI设计一个<strong class="ky ir"> MVC </strong>的方法，请对这篇文章发表评论，我将很乐意学习一些新的东西。</p></div></div>    
</body>
</html>