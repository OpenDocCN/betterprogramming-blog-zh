<html>
<head>
<title>Learn Go by Building a Bus Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建总线服务来学习围棋</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-go-by-building-a-bus-service-6c11e7b81b92?source=collection_archive---------0-----------------------#2020-09-04">https://betterprogramming.pub/learn-go-by-building-a-bus-service-6c11e7b81b92?source=collection_archive---------0-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8173" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">和Golang一起坐公共汽车</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ef44315d0cf9055d4039bb1cd3ab2ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HcaHQe0V5RsucPL2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@teddyosterblom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰迪·奥斯特罗姆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c5c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们和Golang一起乘坐公共汽车，同时探索如何以及何时恰当地应用设计模式。</p><p id="86b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">围棋是一种实用的语言。而是把事情做好。这允许一种更直接的编码风格，我个人认为这是对“经典的”面向对象编码风格的一种解脱，因为它们的类层次结构越来越多。使用Go，我们仍然可以利用许多相关的设计模式，而不会因为必须编写getters、setters、factory类和复杂的类层次结构而分心。</p><p id="a881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计模式从根本上来说只是解决某些问题的方法——或最佳实践。但是当在Go中应用时，这些模式实现起来变得简单，或者几乎微不足道。也许部分是由于关键词极简主义(<code class="fe lv lw lx ly b">public static void main</code>)，有人吗？)，部分原因是与带有构造函数和析构函数的类相比，结构更简单，或者是因为缺少继承性，从而妨碍了代码解耦的尝试。但最重要的是，这是因为Go对函数式编程有极好的支持。这些品质结合起来使得设计模式在Go中变得简单而简洁。记住这一点，让我们通过乘坐公共汽车来演示一下吧！一路上，我们将把乘客送到他们的目的地，同时也应用一些设计模式。一路上会有大量的Go代码，所以至少要对这门语言有基本的了解。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="22db" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">公共汽车服务</h1><p id="8ad5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们先来定义一下以运送乘客为目的的公交车。为了处理机票，我们需要识别每个乘客，我们将使用他们的社会安全号(SSN)来识别。这些都将在一个<code class="fe lv lw lx ly b">busservice</code>包中定义。</p><p id="b178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nd">注意:感谢Reddit </em>  <em class="nd">的</em> <a class="ae ky" href="https://www.reddit.com/r/golang/comments/iml937/i_wrote_a_piece_about_lightweight_design_patterns/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank"> <em class="nd">回复指出，在现实世界的应用程序中，我们不应该在我们的数据结构中使用SSN作为引用，因为在许多国家，SSN是一条敏感的私有信息。然而，出于演示的目的，我们做了一个例外。</em></a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段01</p></figure><p id="cad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太棒了！我们有一辆载有一些乘客的公共汽车。先添加几个<code class="fe lv lw lx ly b">Passengers</code>后，观察我们如何获得一个清单(乘客列表)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段02</p></figure><p id="96f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很可爱。但是有个问题！我们已经向外界公开了<code class="fe lv lw lx ly b">Passengers</code>数据结构。我们可以在我们的<code class="fe lv lw lx ly b">busservice</code>包中自由使用任何我们想要的数据结构，但是当它涉及到包的外部接口时，我们必须采取措施隐藏实现细节。否则，我们将失去对自己包的控制，并且以后不可能在不影响应用程序其余部分的情况下更改<code class="fe lv lw lx ly b">Passengers</code>片。但是我们为什么要改变它呢？</p><p id="3707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，我们的<code class="fe lv lw lx ly b">Bus</code>增长(功能方面)到了一个点，我们发现自己经常需要找到一个特定的SSN的<code class="fe lv lw lx ly b">Passenger</code>。每次都必须迭代<code class="fe lv lw lx ly b">Passengers</code>切片是次优的，我们想用一张地图来代替它，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段03</p></figure><p id="7bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这影响了一切，包括我们如何将<code class="fe lv lw lx ly b">Passengers</code>添加到<code class="fe lv lw lx ly b">Bus</code>。我们已经知道了解决方案:使<code class="fe lv lw lx ly b">Passengers</code>数据结构不被导出(私有),并导出一些使用它的方便方法。但是如何迭代一个任意的数据结构，就像我们为了生成一个清单需要做的那样？</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8527" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">访问者模式</h1><p id="247a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这就是访问者模式的由来。我们将定义一个方法<code class="fe lv lw lx ly b">VisitPassengers</code>，它接受一个为每个乘客调用的函数。为了更好地衡量，让我们也内在化增加乘客的功能。观察下面的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段04</p></figure><p id="f8ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们再来看看我们的主函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段05</p></figure><p id="926b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那好多了！我们已经成功地对外界隐藏了数据结构，这意味着如果我们以后有改变它的自由，我们应该这么想。如果我们想的话，我们甚至可以用二叉查找树来代替它，而不会影响应用程序的其他部分。为了实现这一点，我们必须改变<code class="fe lv lw lx ly b">VisitPassengers</code>方法的逻辑，但是它仍然会以完全相同的方式被调用。此外，现在我们可以使用常数时间查找<em class="nd"> O(1) </em>快速有效地找到特定的<code class="fe lv lw lx ly b">Passenger</code>，而不是在线性时间<em class="nd"> O(n) </em>中循环遍历一个切片。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段06</p></figure><p id="1838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe lv lw lx ly b">VisitPassengers</code>用类型<code class="fe lv lw lx ly b">Passenger</code>的值调用<code class="fe lv lw lx ly b">visitor</code>，这意味着访问者正在接收<em class="nd">一个乘客的副本</em>，因此不能改变<code class="fe lv lw lx ly b">Passenger</code>上的任何东西——至少就<code class="fe lv lw lx ly b">Bus</code>而言不能。关于这个话题的更多信息，Yury Pitsishin有一个很好的解释。传递一个<code class="fe lv lw lx ly b">Passenger</code>的副本是很好的保护，因为一个普通的访问者可能没有修改它的选项，但是如果我们愿意，我们可以很容易地添加对更新乘客的支持。见下文。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段07</p></figure><p id="f303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们没有在<code class="fe lv lw lx ly b">b.passengers</code>中使用指向乘客的指针，我们必须用更新后的<code class="fe lv lw lx ly b">Passengers</code>创建一个新地图，并将其分配回<code class="fe lv lw lx ly b">Bus</code>，因为我们不能获取地图条目的地址。但这只是当前实现的细微差别，因为您也可以使用带有指针的类型。</p><p id="9b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么不能取地图会员的地址？想了解更多原因，请看这篇文章。</p><p id="e164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个实现，如果我们想的话，我们可以开始分配座位号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段08</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8d92" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">立面图案</h1><p id="e37a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">随着我们的应用程序的增长，我们希望与<code class="fe lv lw lx ly b">Passengers</code>的集合进行更多的交互(比如在获取清单时)，我们可以进一步将<code class="fe lv lw lx ly b">Passengers</code>的映射转换成它自己的数据类型，用它自己的专用方法集来处理整个集合。这是完全可行的，同时尊重数据结构本身的隐私。观察。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段09</p></figure><p id="f07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们如何在实现中使用我们自己的<code class="fe lv lw lx ly b">Visit</code>方法。此时，我们还引入了一个构造函数(<code class="fe lv lw lx ly b">NewPassengerSet</code>)，以确保<code class="fe lv lw lx ly b">Bus</code>不必知道我们在实现中使用了哪种数据结构。这是现在的<code class="fe lv lw lx ly b">Bus</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段10</p></figure><p id="0ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于构造函数的原因，<code class="fe lv lw lx ly b">func main</code>有些变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段11</p></figure><p id="a164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意处理乘客的责任是如何从<code class="fe lv lw lx ly b">Bus</code>转移到<code class="fe lv lw lx ly b">Passengers</code>的。这很好，因为<code class="fe lv lw lx ly b">Bus</code>真的应该更关心从<em class="nd"> A </em>到<em class="nd"> B </em>获取有效载荷的责任。此外，从<code class="fe lv lw lx ly b">Bus</code>的角度来看，所有关于乘客的逻辑都得到了简化，<code class="fe lv lw lx ly b">Bus</code>甚至可以选择不公开更新其<code class="fe lv lw lx ly b">Passengers</code>的功能。通过将<code class="fe lv lw lx ly b">Passengers</code>转换成它自己的类型，然后嵌入到<code class="fe lv lw lx ly b">Bus</code>上未导出的字段中，我们还演示了Facade模式，其中<code class="fe lv lw lx ly b">Bus</code>向它的乘客提供接口，并完全控制公开哪些方法，不公开哪些方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="aff9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">观察者模式</h1><p id="9de8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们看看公共汽车站。那里有人在等着登上<code class="fe lv lw lx ly b">Bus</code>，但他们还没有登上<code class="fe lv lw lx ly b">Passengers</code>——直到他们真正登上<code class="fe lv lw lx ly b">Bus</code>。在那之前，我们称他们为<em class="nd">潜在客户</em>。</p><p id="5138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公交车站本身可以仅仅是(车站的)名称、潜在客户列表以及路线上有该车站的已知公交车列表。让我们来定义它们。对于<code class="fe lv lw lx ly b">Prospect</code>，我们可能也需要知道它们要去哪里，所以让我们为<code class="fe lv lw lx ly b">BusStop</code>添加一个<code class="fe lv lw lx ly b">Destination</code>和一些样板代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段12</p></figure><p id="1080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Prospects</code>如何知道<code class="fe lv lw lx ly b">Bus</code>何时到达<code class="fe lv lw lx ly b">BusStop</code>？需要有某种事件来通知<code class="fe lv lw lx ly b">Bus</code>的到来，并启动登机算法。虽然<code class="fe lv lw lx ly b">Bus</code>可以简单地搜索合适的<code class="fe lv lw lx ly b">BusStop</code>并在其上调用一个<code class="fe lv lw lx ly b">NotifyArrival</code>方法，但这不会成功。可能有数百个站点，其中许多是空的，为每个<code class="fe lv lw lx ly b">Bus</code>维护这样一个列表是不可行的。相反，当一个<code class="fe lv lw lx ly b">Prospect</code>到达一个<code class="fe lv lw lx ly b">BusStop</code>时，<code class="fe lv lw lx ly b">BusStop</code>将<em class="nd">向其路线上的总线注册自己</em>。这更有效，因为<code class="fe lv lw lx ly b">Bus</code>不需要维护可能登上它的每个<code class="fe lv lw lx ly b">Prospect</code>的列表，也不需要在更多的<code class="fe lv lw lx ly b">Prospects</code>到达时接收更新，因为<code class="fe lv lw lx ly b">Bus</code>正在途中。最重要的是，<code class="fe lv lw lx ly b">Bus</code>提前知道它可以跳过哪个<code class="fe lv lw lx ly b">BusStops</code>是一个优势。</p><p id="27c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">Prospect</code>的到来本身就是一个事件，需要<code class="fe lv lw lx ly b">Prospects</code>去了解<code class="fe lv lw lx ly b">BusStops</code>，但是让我们把重点放在<code class="fe lv lw lx ly b">BusStop</code>和<code class="fe lv lw lx ly b">Bus</code>之间的动态上。当一个<code class="fe lv lw lx ly b">Prospect</code>到达时，方法<code class="fe lv lw lx ly b">NotifyProspectArrival</code>被调用。可能看起来是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段13</p></figure><p id="19f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要实现<code class="fe lv lw lx ly b">NotifyBoardingIntent</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段14</p></figure><p id="6fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及相关的通知程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段15</p></figure><p id="2b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与观察者模式的典型例子相比，这个例子有点不典型，但是原理是一样的:模式的核心是<code class="fe lv lw lx ly b">NotifyBoardingIntent</code>，它允许<code class="fe lv lw lx ly b">BusStop</code>向<code class="fe lv lw lx ly b">Bus</code>和<code class="fe lv lw lx ly b">NotifyArrival</code>注册自己为<em class="nd">观察者</em>，其中<em class="nd">主题</em> ( <code class="fe lv lw lx ly b">Bus</code>)通知观察者它的到来。由于<code class="fe lv lw lx ly b">Bus</code>只在一个<code class="fe lv lw lx ly b">BusStop</code>到达，我们通过调用<code class="fe lv lw lx ly b">b.currentStop</code>找到那个确切的<code class="fe lv lw lx ly b">BusStop</code>，然后通过调用<code class="fe lv lw lx ly b">curr.NotifyBusArrival</code>通知它我们的到达。关于<em class="nd">观察者</em>和<em class="nd">主体</em>角色的更多信息可以在<a class="ae ky" href="https://en.wikipedia.org/wiki/Observer_pattern." rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="6e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几个方法我们还没有实现，但是它们很琐碎。我们将在内部保存一个<code class="fe lv lw lx ly b">BusStops</code>的切片和该切片的索引，该索引告诉我们哪个是当前的<code class="fe lv lw lx ly b">BusStop</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段16</p></figure><p id="66ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">停靠点的类型是指针，因此我们确保通知的是实际的<code class="fe lv lw lx ly b">BusStops</code>而不是它们的副本。因为<code class="fe lv lw lx ly b">stops</code>是一个内部数据结构，我们在这里不需要任何花哨的访问者模式；我们无意公开这个列表，至少不是为了本文的目的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段17</p></figure><p id="994e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用-1的<code class="fe lv lw lx ly b">currentStop</code>初始化<code class="fe lv lw lx ly b">Bus</code>，上面的工作会好一点，所以让我们改变构造函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段18</p></figure><p id="e0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面实现了通知程序和对<code class="fe lv lw lx ly b">BusStop</code>的相等性检查，前者的目的是登上它的前景。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段19</p></figure><p id="5eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以让一个<code class="fe lv lw lx ly b">Prospect</code>把自己变成一个<code class="fe lv lw lx ly b">Passenger</code>，或者让<code class="fe lv lw lx ly b">Bus</code>承担那个责任。第一种方法的优点是<code class="fe lv lw lx ly b">Bus</code>永远不需要知道什么是<code class="fe lv lw lx ly b">Prospect</code>，所以我个人认为这是一个更好的实现。将一个<code class="fe lv lw lx ly b">Prospect</code>转换成一个<code class="fe lv lw lx ly b">Passenger</code>很简单，因为它们在结构上是相似的，所以我们只需要转移SSN。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段20</p></figure><p id="e49d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是观察者模式的全部内容。</p><p id="14cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们实际上可以实现让公交车绕圈行驶并搭载乘客的算法了。我们将在<code class="fe lv lw lx ly b">main</code>中用几个<code class="fe lv lw lx ly b">BusStops</code>和<code class="fe lv lw lx ly b">Passengers</code>来使它变得有趣。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段21</p></figure><p id="039e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行模拟应该产生以下输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段22</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9fed" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">战略模式</h1><p id="03c8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">是时候向乘坐我们公交车的乘客收费了！</p><p id="f041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向乘客收费是不可选择的——没有免费的公交车！因此，向乘客收费的功能是登机算法的一部分，但是向每位乘客收取多少费用的决定最好留给<code class="fe lv lw lx ly b">BusCompany</code>来决定。</p><p id="d365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免让每辆巴士承担票价决策的负担，我们将使用策略模式。我们来看看登车算法，目前很简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段23</p></figure><p id="3541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们不再只是在<code class="fe lv lw lx ly b">Bus</code>上增加一个<code class="fe lv lw lx ly b">Passenger</code>，让我们将<code class="fe lv lw lx ly b">Bus.Add</code>的名字改为<code class="fe lv lw lx ly b">Bus.Board</code>，并与向乘客收取票价的方法一起实现。观察。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段24</p></figure><p id="0aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们没有将<code class="fe lv lw lx ly b">chargeFn</code>直接传递给<code class="fe lv lw lx ly b">Passenger</code>:<code class="fe lv lw lx ly b">Passenger</code>没有责任知道<code class="fe lv lw lx ly b">BusCompany</code>如何处理门票定价的任何细节，他们知道如何收取一定金额的费用就足够了。但是此时，另一个问题出现了:谁负责将<code class="fe lv lw lx ly b">chargeFn</code>传递给<code class="fe lv lw lx ly b">Board</code>？</p><p id="6ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">BusCompany</code>可能会提供这两种政策。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段25</p></figure><p id="bc9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后由<code class="fe lv lw lx ly b">BusCompany</code>为每个<code class="fe lv lw lx ly b">Bus</code>提供当天的正确策略。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段26</p></figure><p id="cdf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个可以提供价格的<code class="fe lv lw lx ly b">BusCompany</code>—和两个定价策略——我们可以重构<code class="fe lv lw lx ly b">BusStop.NotifyBusArrival</code>来使用新的<code class="fe lv lw lx ly b">Board</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段27</p></figure><p id="bdf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，我们只需要知道乘客是不是老年人。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段28</p></figure><p id="ffc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能已经将<code class="fe lv lw lx ly b">SeniorAge</code>与<code class="fe lv lw lx ly b">BusCompany</code>联系起来，因此它可能会因每个公司的政策而异，但我们只能说这是一项国家法律，因此对所有人都是平等的。在这种情况下，使用常量<em class="nd">就可以了。此外，为了简单起见，我们将使用SSN的最后两位数作为年龄，如果年龄提取失败，就惊慌失措。在真实的程序中，我们会传播错误或在包边界检查有效的SSN，这样我们就不必每次都检查它。</em></p><p id="f875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe lv lw lx ly b">main</code>函数，我们会立即注意到这些变化已经使<em class="nd">贝蒂</em>成为了一名资深者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段29</p></figure><p id="a139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以运行该程序并验证<em class="nd"> Betty </em>确实为老年人收取了较低的票价(在本例中为周末价格)。输出如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段30</p></figure><p id="6695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种策略模式让我们能够让<code class="fe lv lw lx ly b">Bus</code>专注于向<code class="fe lv lw lx ly b">Passenger</code>收取乘车费用，而不是实现的技术细节:是否是工作日，以及<code class="fe lv lw lx ly b">BusCompany</code>在多大程度上决定让乘客的特征影响定价。方法<code class="fe lv lw lx ly b">Bus.Board</code>接收一个简单的<code class="fe lv lw lx ly b">PriceCalculator</code>函数，并让<code class="fe lv lw lx ly b">BusCompany</code>来分析情况并提供正确的定价策略。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6102" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="ea98" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这次总线之旅的过程中，我们应用了visitor模式来避免向其他包公开内部数据结构(<code class="fe lv lw lx ly b">Bus.Passengers</code>)。然后，我们继续使用facade模式对相同的数据结构进行抽象，这允许我们编写方便的方法，可以轻松地对乘客集合进行操作，我们通过实现一个获取乘客清单的解决方案来演示这一点。</p><p id="f015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们开始在乘客上车和下车时访问不同的公交车站，这是通过使用观察者模式实现事件驱动的通知系统来实现的。这使我们能够将责任保持在它们应该在的地方，而不是拥有一个无所不知的算法来联系其他一切。</p><p id="67da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在验证了我们的算法有效之后，我们应用了策略模式，以便向乘客收取不同的票价，而不产生对特定实现的依赖性，同时将计算细节的责任排除在公共汽车如何运行的细节之外。</p><p id="a559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们运行了完成的模拟，并带着几个乘客在城市里转了一圈。</p><p id="ed87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读，甚至可能学到一些东西。</p><p id="f84b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，还有比这里描述的更多的设计模式，我可能会在以后的续篇中介绍更多的设计模式。</p><p id="7c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nd">整个巡演代码都在我的</em> <a class="ae ky" href="https://github.com/mkock/busproject" rel="noopener ugc nofollow" target="_blank"> <em class="nd"> GitHub资源库</em> </a> <em class="nd">中。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c9bc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参考</h1><p id="ff0b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有关每个主题的更多信息，请搜索<em class="nd">！但是这里有一些链接可以帮助你开始。</em></p><ul class=""><li id="47c5" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><a class="ae ky" href="https://www.tutorialspoint.com/design_pattern/visitor_pattern.htm" rel="noopener ugc nofollow" target="_blank">了解更多关于访客模式的信息</a></li><li id="eff0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Facade_pattern" rel="noopener ugc nofollow" target="_blank">关于立面图案的更多信息</a></li><li id="3783" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">关于观察者模式的更多信息</a></li><li id="c745" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">了解更多关于战略模式的信息</a></li><li id="f6f3" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">在<a class="ae ky" href="https://golangbyexample.com/all-design-patterns-golang." rel="noopener ugc nofollow" target="_blank"> Go中有更多设计模式的例子(带代码)，Golang By Example </a>是一个很棒的网站</li><li id="e582" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">Packt Publishing有一个漂亮的小仓库，展示了Go 中的各种设计模式</li><li id="48c3" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">关于提供许多设计模式背后的基本理念的坚实原则的信息</a></li><li id="a93a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://golang.org/pkg/" rel="noopener ugc nofollow" target="_blank">这里记录了优秀的标准库</a></li><li id="2078" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">要获得更多的灵感，请看我关于围棋轻量级模式的文章</li></ul></div></div>    
</body>
</html>