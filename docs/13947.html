<html>
<head>
<title>Functional Dependency Injection in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的功能依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/factory-and-functional-dependency-injection-2d0a38042d05?source=collection_archive---------2-----------------------#2022-10-18">https://betterprogramming.pub/factory-and-functional-dependency-injection-2d0a38042d05?source=collection_archive---------2-----------------------#2022-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f226" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">面向协议编程的替代方案。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2fc0fae6d02ba15d557780f95655263f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DnEbso2lVLr47faBko7ppg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sarabakhshi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莎拉·巴克西</a>在<a class="ae ky" href="https://unsplash.com/s/photos/injection?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c0cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎我们所有人都创建了基于服务的协议，以便在我们的应用程序中进行单元测试。在SwiftUI中开发时，我们还实现了预览功能。</p><p id="d738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模式很简单。创建一个描述你想要做什么的协议。然后创建实现该协议的类或结构。接下来，实现一些方法，将协议实例注入到依赖它的类、服务或视图中。</p><p id="1843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以使用传统的依赖注入技术来完成，比如构造函数或属性注入，或者可以使用现代的基于容器的系统，比如<a class="ae ky" href="https://github.com/hmlongco/Factory" rel="noopener ugc nofollow" target="_blank"> Factory </a>。</p><p id="82b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，最后，我们实现一个或两个mock或stub来实现协议的虚拟版本，并在我们想要编写测试或实现预览时注入<em class="lv">和</em>。</p><p id="325b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:下面的例子使用了工厂，但是同样的技术可以用于几乎任何依赖注入模式。</em></p><h2 id="bcb7" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">一个例子</h2><p id="896d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">说得够多了，让我们定义一个可以实现的非常简单的服务，这样我们就可以查看一些代码，看看我们在这里谈论的是什么。</p><p id="f63c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择的例子是一个打开URL的简单协议。在经典的POP风格中，为了使事情更简单，我们将在现有的<code class="fe mu mv mw mx b">UIApplication</code>上可用的<code class="fe mu mv mw mx b">openURL</code>函数上建模我们的协议。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="fb99" class="lw lx it mx b gy nc nd l ne nf">protocol URLOpening {<br/>    func openURL(_ url: URL) -&gt; Bool<br/>}</span></pre><p id="3e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们确保<code class="fe mu mv mw mx b">UIApplication</code>符合我们的协议。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="8cb4" class="lw lx it mx b gy nc nd l ne nf">extension UIApplication: URLOpening {}</span></pre><p id="3ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了协议，我们可以创建一个工厂来提供它。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="37d7" class="lw lx it mx b gy nc nd l ne nf">extension Container {<br/>    static let urlOpening = Factory&lt;URLOpening&gt; {<br/>        UIApplication.shared<br/>    }<br/>}</span></pre><p id="625c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe mu mv mw mx b">UIApplication</code>符合我们的协议，所以只要需要依赖，我们就可以获取共享实例。</p><p id="2ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们终于可以使用我们新发明的服务了。这是我们的视图模型。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="baf1" class="lw lx it mx b gy nc nd l ne nf">class MyViewModel {<br/>    @Injected(urlOpening) var urlOpener<br/>    func open(site: String) {<br/>        _ = urlOpener.openURL(URL(string: site)!)<br/>    }<br/>}</span></pre><p id="2c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都好。我们还可以创建一个URL打开服务的模拟版本，并使用它进行测试和预览。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2807" class="lw lx it mx b gy nc nd l ne nf">class URLOpenningMock: URLOpening {<br/>    var openedURL: URL?<br/>    func openURL(_ url: URL) -&gt; Bool {<br/>        openedURL = url<br/>        return false<br/>    }<br/>}</span></pre><p id="afd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">mock只是记录要求它打开的任何网站的URL。如果<em class="lv">应该</em>已经打开了一些东西，但是站点仍然是空的，那么我们知道我们有一个问题。下面是使用它的测试。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5cc8" class="lw lx it mx b gy nc nd l ne nf">func testOpenFuctionality() throws {<br/>    let mock = URLOpenningMock()<br/>    Container.urlOpening.register { mock }<br/>    let viewModel = MyViewModel()<br/>    viewModel.open(site: "<a class="ae ky" href="https://google.com" rel="noopener ugc nofollow" target="_blank">https://google.com</a>")<br/>    XCTAssert(mock.openedURL != nil)<br/>}</span></pre><p id="3ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都不是新的，只是面向协议编程的工作方式。</p><p id="af33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是…我们能做得更好吗？</p><h2 id="68f1" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">功能注射</h2><p id="8f2b" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为了给提供单一功能的服务创建一个协议，我们费了很大的劲。仔细想想，我们可能会问几个简单的问题:</p><ol class=""><li id="5aad" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">我们真的需要服务容器吗？</li><li id="d8a0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们能在需要的地方注入<em class="lv">功能</em>吗？</li></ol><p id="c332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明我们可以。观察下面的typealias和工厂定义。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="069c" class="lw lx it mx b gy nc nd l ne nf">typealias OpenURLFunction = (_ url: URL) -&gt; Bool</span><span id="09a2" class="lw lx it mx b gy nu nd l ne nf">extension Container {<br/>    static let openURL = Factory&lt;OpenURLFunction&gt; {<br/>        UIApplication.shared.openURL<br/>    }<br/>}</span></pre><p id="504a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们之前的协议一样，typealias与<code class="fe mu mv mw mx b">openURL</code>函数签名完全匹配，这样我们就可以创建一个设计为<em class="lv">而不是</em>返回服务对象的工厂，而是一个<em class="lv">函数</em>。</p><p id="10f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在工厂内部，我们将<code class="fe mu mv mw mx b">openURL</code> <em class="lv">函数</em>引用传递给我们的工厂，以备需要时使用，而不是使用<code class="fe mu mv mw mx b">UIApplication</code>的实例。这个工厂可以像我们以前一样通过注射来消耗。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ce9c" class="lw lx it mx b gy nc nd l ne nf">class MyViewModel: View {<br/>    @Injected(Container.openURL) private var openURL<br/>    func open(site: String) {<br/>        _ = openURL(URL(string: site)!)<br/>    }<br/>}</span></pre><p id="2699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相同的<code class="fe mu mv mw mx b">Injected</code>属性包装器。但是请注意，现在我们的open函数直接调用函数，而不是调用服务上的方法。</p><p id="71ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，这看起来干净多了。测试呢？</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="88f2" class="lw lx it mx b gy nc nd l ne nf">func testOpenFuctionality() throws {<br/>    var openedURL: URL?<br/>    Container.openURL.register {<br/>        { url in<br/>            openedURL = url<br/>            return false<br/>        }<br/>    }<br/>    let viewModel = MyViewModel()<br/>    viewModel.open(site: "https://google.com")<br/>    XCTAssert(openedURL != nil)<br/>}</span></pre><p id="436a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，为了验证我们的open函数是否被正确调用，我们的代码所做的工作与我们之前在mock和原始测试中所做的工作基本相同。</p><p id="fbdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们确实用typealias替换了我们的协议，我们不再需要类符合那个协议，并且我们不再需要创建模拟对象。</p><p id="ce10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">底线是我们节省了几行代码，但是总的来说<em class="lv">可能</em>看起来这种技术是一种浪费。</p><p id="38ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再试一次，看看是否有一个案例，它的优势可能会更明显。</p><h2 id="34bb" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">网络请求</h2><p id="bdfd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">看看下面的typealias和registration。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="8261" class="lw lx it mx b gy nc nd l ne nf">typealias AccountProviding = () async throws -&gt; [Account]</span><span id="ecd5" class="lw lx it mx b gy nu nd l ne nf">extension Container {<br/>    static let accountProvider = Factory&lt;AccountProviding&gt; {<br/>        { try await Network.get(path: "/accounts") }<br/>    }<br/>}</span></pre><p id="3aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种注入依赖于一个通用的网络函数，该函数自动从服务器获取数据，并将其解码为适当的类型。那里的代码并不重要，我将把它留给读者作为练习。</p><p id="0d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是现在，让我们来看一看使用这种依赖关系的视图模型上的一个测试。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="66cd" class="lw lx it mx b gy nc nd l ne nf">func testAllAccounts() async throws {<br/>    Container.accountProvider.register {{ Account.mockAccounts }}<br/>    do {<br/>        let viewModel = AccountViewModel()<br/>        try await viewModel.load()<br/>        XCTAssert(viewModel.accounts.count == 5)<br/>    } catch {<br/>        XCTFail("Account load failed")<br/>    }<br/>}</span></pre><p id="65dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们用一个简单的函数替换了注册，该函数用于返回一组五个预定义的模拟帐户。</p><p id="e7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们可以返回更多的帐户。或者一个。或者没有。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="0f85" class="lw lx it mx b gy nc nd l ne nf">func testEmptyAccounts() async throws {<br/>    Container.accountProvider.register {{ [] }}<br/>    ...<br/>}</span></pre><p id="0532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者编写一个测试来确保我们的错误处理能够胜任工作。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="fc61" class="lw lx it mx b gy nc nd l ne nf">func testErrorLoadingAccounts() async throws {<br/>    Container.accountProvider.register {{ throw APIError.network }}<br/>    ...<br/>}</span></pre><p id="c1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，以这种方式使用函数依赖使得<em class="lv">非常容易返回边缘情况，如空的帐户列表，或者模拟特定的错误情况，以确保它们得到正确处理。</em></p><p id="88cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做到了这一切，却没有编写大量代码来创建一组必须遵守特定协议的模拟服务类或存根。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="1d4c" class="lw lx it mx b gy nc nd l ne nf">struct MockNoAccounts: AccountLoading {<br/>    func loadAccounts() async throws -&gt; [Account] {<br/>        []<br/>    }<br/>}</span><span id="165a" class="lw lx it mx b gy nu nd l ne nf">Container.accountLoading.register { MockNoAccounts() }</span></pre><h2 id="ffb2" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">网络容器</h2><p id="50e5" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我现在也在考虑在<code class="fe mu mv mw mx b">NetworkContainer</code>的一个工厂中使用它，在那里我可以放置我的大部分API调用存根。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="0d3c" class="lw lx it mx b gy nc nd l ne nf">class NetworkContainer: SharedContainer {</span><span id="90ed" class="lw lx it mx b gy nu nd l ne nf">    typealias AccountProviding = () async throws -&gt; [Account]</span><span id="139f" class="lw lx it mx b gy nu nd l ne nf">    static let accountProvider = Factory&lt;AccountProviding&gt; {<br/>        { try await Network.get(path: "/accounts") }<br/>    }</span><span id="d085" class="lw lx it mx b gy nu nd l ne nf">    typealias UserProviding = () async throws -&gt; User</span><span id="79af" class="lw lx it mx b gy nu nd l ne nf">    static let userProvider = Factory&lt;UserProviding&gt; {<br/>        { try await Network.get(path: "/user") }<br/>    }</span><span id="3b56" class="lw lx it mx b gy nu nd l ne nf">}</span></pre><p id="1e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我获得了注入的优势，而不需要在每种情况下都创建特定的协议、实现对象和一组模拟对象。</p><p id="be78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还没有决定是继续使用typealias，还是工厂名就足够了，我应该直接指定工厂的函数签名。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="c42c" class="lw lx it mx b gy nc nd l ne nf">class NetworkContainer: SharedContainer {<br/>    <br/>    static let accounts = Factory&lt;() async throws -&gt; [Account]&gt; {<br/>        { try await Network.get(path: "/accounts") }<br/>    }<br/>    <br/>    static let user = Factory&lt;() async throws -&gt; User&gt; {<br/>        { try await Network.get(path: "/user") }<br/>    }</span><span id="47ad" class="lw lx it mx b gy nu nd l ne nf">}</span></pre><p id="bf00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决定，决定。</p><h2 id="e521" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">完成块</h2><p id="fdd4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">原来如此。</p><p id="54ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这项技术最大的优势不在于标准的应用程序功能，而在于我们现在可以轻松地测试这些功能。</p><p id="0dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您已经看到了我们如何简单地为视图模型提供一个新的函数，该函数返回我们需要的边缘情况或错误，而不需要定义协议，也不需要创建符合该协议的新存根或模拟服务。</p><p id="3bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我的角度来看，任何使编写测试和预览代码更快更容易的东西都值得重新审视。还有第三个。第四个也是如此。</p><p id="c21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是否在所有情况下都取代了面向协议编程的需要？显然不是。复杂的服务和存储库仍然存在，我们仍然需要复杂的协议来帮助管理它们。</p><p id="3e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于简单的服务和依赖来说，功能注入可能是最好的选择。</p><p id="1318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你觉得怎么样？打算在你的代码中尝试一下吗？</p><p id="7b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在下面的评论中告诉我，如果你想看更多，请点击“喜欢”按钮几次。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="8c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">本文是</em> <a class="ae ky" href="https://medium.com/p/365ce5038ef7/edit" rel="noopener"> <em class="lv">雨燕依赖注入系列</em> </a> <em class="lv">的一部分。</em></p></div></div>    
</body>
</html>