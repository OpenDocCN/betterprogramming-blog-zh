<html>
<head>
<title>Insights for Dealing With PHP OOP Limitations When Keeping Specific Implementations at the Edges of a Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当在软件的边缘保持特定的实现时，处理PHP OOP限制的见解</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/insights-for-dealing-with-php-oop-limitations-when-keeping-specific-implementations-at-the-edges-of-22321bfcd3ac?source=collection_archive---------14-----------------------#2022-05-25">https://betterprogramming.pub/insights-for-dealing-with-php-oop-limitations-when-keeping-specific-implementations-at-the-edges-of-22321bfcd3ac?source=collection_archive---------14-----------------------#2022-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3b88" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帮助您的代码更进一步的简短指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8262adfa96f77073403871c6da8fb555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e0rpAkF72MWCFumr"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">本·格里菲斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="25c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将特定的实现放在软件的边缘是软件开发中众所周知的最佳实践，它通常可以作为构建强大的面向对象结构和易于维护的代码的启发。</p><p id="930a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般的想法是指让类知道彼此的接口(例如，可以在每个接口上调用哪些操作)，而不知道它们的具体实现或“数据类型”例如，对象属于哪个特定的类或子类)。</p><p id="5bb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，这种设计实践是通过根据接口定义软件依赖关系来实现的，因此留下一些依赖注入机制来确定在整个执行线程中应该使用哪些特定的实现。</p><p id="b7d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在进入核心组件之前，特定的实现通常在执行线程的开始，在软件的第一层被定义。我们将这些地方称为“软件的边缘”，它们符合每次执行的实际入口点。</p><p id="aaf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在做了一个无聊的理论OOP介绍后，在我作为PHP开发人员的几年工作经历中，我多次面对一个特定的有问题的模式。在这里，我描述了它，并提供了一些见解，帮助我在不同的场景中处理它，同时试图坚持上面的设计实践。</p><h1 id="caa9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题是</h1><p id="9ae7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有问题的模式可以描述为有一个类利用了另一个类提供的结果。结果是根据通用接口定义的，因此我们可能知道可以在实例上调用的一些操作。但是，结果中也有一些特定的操作和数据片段，是结果消费者想要使用的。</p><p id="45c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据每个结果的类型，消费者应该能够通过实现不同的结果处理算法来处理不同的可能结果实例。我们如何在不将实现细节分散到所有代码中的情况下实现这一点呢？</p><p id="f3c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道理解起来有点乏味，所以让我们用一个使用命令设计模式设置的具体例子来解决这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d02e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管文件数量很多，但这种设置很容易理解:有一个<code class="fe mr ms mt mu b">Command</code>接口，它返回一个<code class="fe mr ms mt mu b">CommandResult</code>实例作为执行特定命令的结果。我们有一个<code class="fe mr ms mt mu b">ExecutionContext</code>类，它定义了特定上下文的一般结构。</p><p id="caee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上下文将负责处理(执行和处理其结果)每个命令。我们可以看到每个特定的命令结果子类持有不同的操作，但是<code class="fe mr ms mt mu b">ExecutionContex</code> t类只知道<code class="fe mr ms mt mu b">CommandResult</code>接口。我们如何相应地处理每个命令结果类型？</p><p id="7c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在很多场合都是我的克星。PHP中缺少多态类型提示和泛型，这使得在这些场景下工作很困难；不像Java，对于这种情况有很好的本地解决方案。无论如何，我可以找出三种有用的方法，让我在过去成功地解决了这个问题:</p><ul class=""><li id="7050" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">将泛型结果强制转换为预期的类型</li><li id="71fa" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">使用<code class="fe mr ms mt mu b">Visitor</code>模式</li><li id="48ea" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">重组组件设计</li></ul><h1 id="667c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将泛型结果转换为预期的类型</h1><p id="da8a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">老实说，这是我最不喜欢的解决方案。因为我们确实知道在一个<code class="fe mr ms mt mu b">CommandResult</code>实例后面会有一个特定的类实例，我们可以尝试为每个特定的实例提供不同的实现，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6bbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">processResult</code>实现询问结果的具体类型，以便对其进行相应的处理。由于每个私有的<code class="fe mr ms mt mu b">processCommandResultX</code>方法都期望接收一个在其签名上定义的<code class="fe mr ms mt mu b">CommandResultX</code>实例，我们的IDE可以帮助我们在这些方法中自动完成和类型提示。</p><p id="d2b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">processResult</code>方法可以直接在基类<code class="fe mr ms mt mu b">ExecutionContext</code>中定义，将每个“<code class="fe mr ms mt mu b">processCommandResultX</code>”方法的定义留给每个子类。</p><p id="79a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，基类可以为每个特定方法提供默认实现，以及在没有<code class="fe mr ms mt mu b">instanceof</code>语句捕获到特定命令结果的情况下执行的默认实现(尽管在这种情况下，我们可能希望抛出一个错误，警告我们忘记处理它)。</p><p id="b256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个更强大、更灵活的版本将利用<em class="nj">责任链</em>模式将每个特定的处理定义为一个链条钢。这样，一个钢可以只处理<code class="fe mr ms mt mu b"><em class="nj">CommandResultA</em></code>实例，将所有其他结果类型留给后面的钢，依此类推。</p><p id="5aeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在链的开始或结尾使用steels对所有类型的结果进行额外的处理，例如，为每个结果启用数据记录，而不管它是哪种类型。</p><p id="12d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管有许多<code class="fe mr ms mt mu b">instanceof</code>检查和处理方法可能有点棘手和冗长，但是第一种方法将特定的实现代码保持在软件的边缘，只要我们将执行上下文类视为边缘的一部分。因此，添加新的命令结果类型需要:</p><ul class=""><li id="7472" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">在<code class="fe mr ms mt mu b"><em class="nj">ExecutionContext</em></code>层次中添加一个新的特定处理方法，并在子类中实现它</li><li id="21ee" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">在<code class="fe mr ms mt mu b"><em class="nj">processResult</em> </code>方法中增加了新的<code class="fe mr ms mt mu b">instanceof</code>检查</li><li id="a388" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">当使用一个责任链时，增加一个新的链钢和可能修改一些现有的</li></ul><h1 id="3ac4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用访问者设计模式</h1><p id="6eed" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通过<code class="fe mr ms mt mu b">Visitor</code>设计模式，我们可以得到一个更优雅的组件设置，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们让每个特定的结果控制它应该如何被处理:每个<code class="fe mr ms mt mu b">ExecutionContext</code>都有一个特定处理方法的集合。具体结果要通过实现<code class="fe mr ms mt mu b">processOnContext</code>方法来选择合适的。</p><p id="63a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">优雅是因为不必使用<code class="fe mr ms mt mu b">instanceof</code>语句检查每个结果的类类型。然而，这种方法与前一种方法并没有太大的不同。添加新命令和新命令结果类型将需要:</p><ul class=""><li id="7401" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">在<code class="fe mr ms mt mu b"><em class="nj">ExecutionContext</em></code>基类中添加一个新的<code class="fe mr ms mt mu b">processCommandResultX</code>方法，并在每个具体的上下文子类中实现它。</li></ul><h1 id="2972" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">重构设计</h1><p id="d0da" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果我们再次打开理论模式，我们可能会认为这个问题仅仅是一个设计问题，因此，由于一些错误的概念和假设，当前的设置不能很好地工作。</p><p id="ff27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，<code class="fe mr ms mt mu b">ExecutionContext</code>被设计用来处理<code class="fe mr ms mt mu b">CommandResult</code>实例。但是我们正在尝试处理<code class="fe mr ms mt mu b">CommandResultA</code>和<code class="fe mr ms mt mu b">CommandResultB</code>实例。因此，我们在同一个类中混合了两个不同层次的抽象。在代码的任何一点上，我们都应该在低层次或者高层次的抽象上工作，但是不能同时使用这两种抽象。</p><p id="e505" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，<code class="fe mr ms mt mu b">CommandResultA</code>定义了一个名为<code class="fe mr ms mt mu b">getString</code>的全新方法，它不是在父类级别定义的。<code class="fe mr ms mt mu b">CommandResultB</code>也是如此。此外，这两种命令结果类型不能互换。</p><p id="f378" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们违反了Likskow的替代原理，这来自于假设<code class="fe mr ms mt mu b">CommandResultA</code>和<code class="fe mr ms mt mu b">CommandResultB</code>是某种<code class="fe mr ms mt mu b">CommandResult</code>，这反过来是不正确的，因为它们没有任何共同点。既不共享相同的数据字段，也不进行相同的操作。</p><p id="7516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意这些设计错误可能会给重构和重新设计当前解决方案带来很好的见解。但是，因为我假设两个命令可以返回不同的数据字段作为结果，所以我肯定希望对它们进行不同的处理。命令结果类型随着处理算法的不同而不同。因此，我们可以尝试将它们都放在软件的最边缘，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="94a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我添加了一组<code class="fe mr ms mt mu b">ProcessingStrategy</code>类，它们定义了应该如何处理每种特定的结果类型。<code class="fe mr ms mt mu b">ExecutionContext </code>现在是一个核心组件，必须在向它发送命令之前将其设置为处理策略。我们使用这种方法在系统边缘保持结果类型处理，因为它们只在<code class="fe mr ms mt mu b">index.php</code>文件中定义。</p><p id="a240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法假设每个命令结果类型有一个特定的处理策略，尽管<code class="fe mr ms mt mu b"> processResult</code>方法期望一个<code class="fe mr ms mt mu b">CommandResult</code>实例而不是特定的结果类型(比如<code class="fe mr ms mt mu b">CommandResultA</code>)。</p><p id="69aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我显式检查传入结果的类型是否是我期望接收的类型。我使用两种方法:<code class="fe mr ms mt mu b">ProcessingStrategyA</code>将结果转换为<code class="fe mr ms mt mu b">CommandResultA</code>，而<code class="fe mr ms mt mu b">ProcessingStrategyB</code>显式检查给定结果的类型，并依赖PHPDoc进行自动完成和类型提示。</p><p id="9c56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，也可以提供处理这两种结果的处理策略。因此，这是一种比其他方法更灵活的方法。还要注意，如果我们将一个意外的命令结果类型传递给执行上下文，它将抛出一个错误。一个更安全的替代方案将包括一些错误处理和默认行为机制。</p><p id="9fbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的一种类型宽松的变体是，<code class="fe mr ms mt mu b">ExecutionContext</code>类使用一个<code class="fe mr ms mt mu b">processingStrategy</code>而没有显式定义它的预期类型，您可以在下面看到:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a8ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个版本允许<code class="fe mr ms mt mu b">ExecutionContext</code>使用任何具有<code class="fe mr ms mt mu b">processResult</code>方法的东西作为有效的处理策略。通过放宽类型要求，我们可以删除<code class="fe mr ms mt mu b">ProcessingStrategy</code>的继承，从而明确地说一个<code class="fe mr ms mt mu b">ProcessingStrategyA </code>实例将只能处理<code class="fe mr ms mt mu b">CommandResultA </code>实例，而不能处理<code class="fe mr ms mt mu b">CommandResult </code>实例。这里的主要好处是我们摆脱了<code class="fe mr ms mt mu b">instanceof</code>检查和类型转换，处理策略如何处理结果的限制变得显而易见。</p><p id="0dd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种布局添加新的命令结果类型需要:</p><ul class=""><li id="cf6b" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">添加一个新的处理策略，可以处理新的结果类型，尽管可以重用现有的处理策略。</li></ul><p id="5696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章是有帮助的。感谢您的阅读，敬请期待更多内容！</p></div></div>    
</body>
</html>