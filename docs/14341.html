<html>
<head>
<title>We Rewrote Our Project With Rust… and It’s Almost 40X Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们用Rust重写了我们的项目…速度快了将近40倍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/40x-faster-we-rewrote-our-project-with-rust-120b006c6abe?source=collection_archive---------0-----------------------#2022-12-01">https://betterprogramming.pub/40x-faster-we-rewrote-our-project-with-rust-120b006c6abe?source=collection_archive---------0-----------------------#2022-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fc63" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以下是我们选择Rust的原因，我们遇到的障碍，以及重写收入比率</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3fbaf345d3e89c97420ed9b6c64235ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FpV3afTyvh2lv0kF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">戈兰·艾沃斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4d80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rust已经悄悄地成为最流行的编程语言之一。作为一种新兴的系统语言，Rust有很多特点，比如内存安全机制、接近C/C++的性能优势、优秀的开发者社区、工具链和ide。</p><p id="a5e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将介绍我们使用Rust重写项目并逐步在生产环境中实现它的过程——以及选择Rust的原因、遇到的问题和结果。</p><p id="7f2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在利用Rust开发的项目叫做<a class="ae kv" href="https://github.com/KusionStack/KCLVM" rel="noopener ugc nofollow" target="_blank"> KCL </a>。(KCL)是一种开源的基于约束的记录和函数式语言。它通过成熟的编程语言堆栈改进了复杂配置的编写。它致力于围绕配置、更简单的逻辑编写、快速自动化和良好的生态扩展性来构建更好的模块化、可伸缩性和稳定性。更多具体的KCL使用场景，请访问<a class="ae kv" href="https://kcl-lang.github.io/" rel="noopener ugc nofollow" target="_blank"> KCL网站</a>。</p><p id="d5f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">KCL之前是用Python写的。考虑到用户体验、性能和稳定性，我们决定在Rust中重写它，并获得了以下好处:</p><ul class=""><li id="905b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">由于Rust强大的编译检查和错误处理，错误更少。</li><li id="027a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">语言端到端编译和执行性能提升66%。</li><li id="d638" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">语言前端解析器的性能提升了20倍。</li><li id="d72e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">语言语义分析器的性能提高了40倍。</li><li id="7b34" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">语言编译器在编译期间的平均内存使用量是原始Python版本的一半。</li></ul><h1 id="4c7f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">我们遇到的问题<a class="ae kv" href="http://localhost:3000/blog/2022-kcl-rewrite-with-rust#what-problems-have-we-encountered" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="3b01" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">编译器、构建系统和运行时使用Rust在相同类型的项目中做类似的事情——像<a class="ae kv" href="https://github.com/denoland/deno" rel="noopener ugc nofollow" target="_blank"> deno </a>、<a class="ae kv" href="https://github.com/swc-project/swc" rel="noopener ugc nofollow" target="_blank"> swc </a>、<a class="ae kv" href="https://github.com/vercel/turbo" rel="noopener ugc nofollow" target="_blank"> turbopack </a>、<a class="ae kv" href="https://github.com/rust-lang/rust" rel="noopener ugc nofollow" target="_blank"> rustc </a>。我们使用Rust来构建编译器的前端、中间和运行时——但我们直到大约一年前才这样做。</p><p id="bb3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一年前，我们使用Python构建了KCL编译器的整个实现。虽然最初运行良好，但由于Python易于使用，团队的研发效率也非常高。然而，随着代码的扩展和工程师数量的增加，代码维护变得更加困难。</p><p id="f0e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们被迫在项目中编写Python类型的注释，采用了更严格的lint工具——代码测试行覆盖率也达到了90%以上——但还是有很多运行时错误，比如Python None空对象、找不到属性等等。重构Python代码一定要慎重，严重影响用户体验。</p><p id="730f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，当KCL用户构成开发人员的大多数时，编程语言或编译器内部实现中的任何错误都变得无法容忍，从而导致影响我们用户体验的问题。用Python编写的程序起步较慢，它们的性能需要满足我们的自动化系统所需的在线编译和执行的效率需求。在我们的场景中，用户需要能够在修改KCL代码后快速显示编译结果。用Python编写的编译器不能有效地满足这些要求。</p><h1 id="a64d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">为什么生锈？</h1><p id="eadb" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们选择Rust的原因如下:</p><ul class=""><li id="2b5d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我们使用Python、Go和Rust实现了一个简单的编程语言栈虚拟机，并比较了它们的性能。在这种情况下，Go和Rust具有相似的性能，而Python表现出显著的性能差距。经过慎重考虑，我们选择了铁锈。三种语言实现的栈虚拟机代码详情在这里:<a class="ae kv" href="https://github.com/Peefy/StackMachine" rel="noopener ugc nofollow" target="_blank">https://github.com/Peefy/StackMachine</a>。</li><li id="86ba" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">越来越多的编程语言的编译器或运行时，尤其是前端基础设施项目，是使用Rust编写或重构的。此外，Rust还出现在基础设施、数据库、搜索引擎、网络、云原生、UI、嵌入式等领域。至少，实现编程语言的可行性和稳定性得到了验证。</li><li id="a715" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">考虑到后续项目开发会涉及到区块链和智能合约的方向，而且社区里大量的区块链和智能合约项目都是Rust写的。</li><li id="cd7a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过Rust可以实现更好的性能和稳定性，使系统更容易维护，更健壮。同时，C APIs可以通过FFI公开，用于多语言使用和扩展，便于生态扩展和集成。</li><li id="4645" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">铁锈以友好的方式支持WASM。Rust在社区中建立了大量的WASM生态系统。KCL语言和编译器可以在Rust的帮助下编译成WASM，并在浏览器中运行。</li></ul><p id="f044" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于以上原因，我们选择了Rust而不是Go。在整个重写过程中，我们发现Rust的综合素质真的很优秀(高性能，足够抽象)。虽然在一些语言特性上有一些代价，特别是生命周期，但在生态上可以更丰富。</p><h1 id="b2f1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用铁锈的困难</h1><p id="c9db" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">虽然我们决定用Rust重写整个KCL项目，但大多数团队成员都没有用Rust编写某个项目的经验，我只学过<a class="ae kv" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">Rust编程语言</a>。依稀记得在了解到<code class="fe nd ne nf ng b">Rc</code>、<code class="fe nd ne nf ng b">RefCell</code>等智能指针的时候就放弃了。当时没想到Rust里会有类似C++的东西。</p><p id="42c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Rust的风险主要是语言学习的成本，在各种博客中也确实有提及。因为KCL项目的整体架构并没有太大的变化，而且一些模块设计和代码编写已经针对Rust进行了优化，所以整个重写都是在边学边练的过程中进行的。</p><p id="1d0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">刚开始用Rust写整个项目的时候，我们花了很多时间在知识查询、编译、调试上。但是随着项目的推进，我们在使用Rust的体验中遇到的困难主要是心智改造和开发效率。</p><h1 id="f679" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">精神转换<a class="ae kv" href="http://localhost:3000/blog/2022-kcl-rewrite-with-rust#mental-transformation" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="3d48" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">首先，Rust的语法和语义很好地吸收和整合了函数式程序中与类型系统相关的概念，比如抽象代数类型(ADT)。</p><p id="27c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，Rust中没有与“继承”相关的概念。如果你需要帮助理解它，即使是普通的结构定义在Rust中也可能比在其他语言中花费更多的时间。例如，以下Python代码在Rust中将有不同的定义:</p><ul class=""><li id="54ab" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">计算机编程语言</li></ul><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="2a21" class="nl mh iq ng b be nm nn l no np">from dataclasses import dataclass<br/><br/>class KCLObject:<br/>    pass<br/><br/>@dataclass<br/>class KCLIntObject(KCLObject):<br/>    value: int<br/><br/>@dataclass<br/>class KCLFloatObject(KCLObject):<br/>    value: float</span></pre><ul class=""><li id="c4df" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">锈</li></ul><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="f3b9" class="nl mh iq ng b be nm nn l no np">enum KCLObject {<br/>    Int(u64),<br/>    Float(f64),<br/>}</span></pre><p id="45c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，更多的时间花在了对抗Rust编译器本身的错误报告上。例如，Rust编译器经常会导致开发人员在借用检查错误时“碰壁”。特别是对于KCL编译器，其核心结构是抽象语法树(AST)，一种递归嵌套的树结构。</p><p id="4666" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Rust中有时很难考虑变量可变性和借用检查之间的关系，就像KCL编译器中定义的作用域结构<code class="fe nd ne nf ng b">Scope</code>，对于循环引用的场景，在大量使用Rust中常用的智能指针结构如<code class="fe nd ne nf ng b">Rc</code>、<code class="fe nd ne nf ng b">RefCell</code>、<code class="fe nd ne nf ng b">Weak</code>的同时，用来显示需要注意的数据的相互依赖关系。</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="ee64" class="nl mh iq ng b be nm nn l no np">/// A Scope maintains a set of objects and links to its containing<br/>/// (parent) and contained (children) scopes. Objects may be inserted<br/>/// and looked up by name. The zero value for Scope is a ready-to-use<br/>/// empty scope.<br/>#[derive(Clone, Debug)]<br/>pub struct Scope {<br/>    /// The parent scope.<br/>    pub parent: Option&lt;Weak&lt;RefCell&lt;Scope&gt;&gt;&gt;,<br/>    /// The child scope list.<br/>    pub children: Vec&lt;Rc&lt;RefCell&lt;Scope&gt;&gt;&gt;,<br/>    /// The scope object mapping with its name.<br/>    pub elems: IndexMap&lt;String, Rc&lt;RefCell&lt;ScopeObject&gt;&gt;&gt;,<br/>    /// The scope start position.<br/>    pub start: Position,<br/>    /// The scope end position.<br/>    pub end: Position,<br/>    /// The scope kind.<br/>    pub kind: ScopeKind,<br/>}</span></pre><h1 id="e9d7" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">开发效率<a class="ae kv" href="http://localhost:3000/blog/2022-kcl-rewrite-with-rust#development-efficiency" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="926f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">锈的发展效率可以用“先抑后扬”来形容。在一个手写项目的初期，如果团队成员没有接触过函数式编程和相关的编程习惯，开发速度会明显慢于Python、Go、Java等语言。</p><p id="e32a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，一旦他们熟悉了Rust标准库的常用方法和最佳实践，以及Rust编译器的常见错误修改，开发效率将会大大提高，他们可以原生地编写出高质量、安全、高效的代码。</p><p id="0579" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我遇到了一个Rust lifetime错误，如下面的代码所示。排查了很久，发现寿命不匹配是忘记标注寿命参数造成的。</p><p id="b23d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，Rust的生命周期与类型系统、范围、所有权和借用检查等概念相关联，导致理解的高成本和复杂性。错误报告信息通常不像类型错误那样明显。</p><p id="30a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生存期不匹配错误报告信息有时不灵活，这可能会导致高成本的故障排除。当然，在更熟悉相关概念后，效率会提高。</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="b567" class="nl mh iq ng b be nm nn l no np">struct Data&lt;'a&gt; {<br/>    b: &amp;'a u8,<br/>}<br/><br/>// func2 omit lifecycle parameters, and func2 does not.<br/>// The lifecycle of func2 will be deduced as '_ by the Rust compiler by default,<br/>// which may lead to lifetime mismatch error.<br/>impl&lt;'a&gt; Data&lt;'a&gt; {<br/>    fn func1(&amp;self) -&gt; Data&lt;'a&gt; {Data { b: &amp;0 }}<br/>    fn func2(&amp;self) -&gt; Data {Data { b: &amp;0 }}<br/>}</span></pre><h1 id="398e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用Rust <a class="ae kv" href="http://localhost:3000/blog/2022-kcl-rewrite-with-rust#rewrite-revenue-ratio-using-rust" rel="noopener ugc nofollow" target="_blank">重写收入比率</a></h1><p id="10b8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在几个团队成员花了几个月的时间使用Rust完全重写并稳定地投入生产环境几个月后，我们回顾了整个过程，觉得非常有收获。</p><p id="137f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从技术角度来说，重写过程训练我们快速学习新的编程语言和编程知识，并付诸实践。整个重写过程让我们反思了KCL编译器的不合理设计，并对其进行了修改。对于一门编程语言来说，这是一个长周期的项目。我们了解到，编译器系统更加稳定和安全，代码清晰，错误更少，性能更好。</p><p id="52c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然不是所有模块都能获得40倍的性能(因为有些模块的性能瓶颈，比如KCL运行时，就是内存深度复制操作)，但我觉得还是值得的。而当Rust使用到一定时期，心智和开发效率就不再是限制因素了。</p><h1 id="3488" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论<a class="ae kv" href="http://localhost:3000/blog/2022-kcl-rewrite-with-rust#conclusion" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="6aef" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">使用Rust重写项目的最重要的结果不仅仅是我学会了一种新的编程语言，或者Rust是一种非常流行的语言，允许我们编写花哨的代码。相反，使用Rust使KCL语言和编译器更加稳定，消除了启动速度和自动化效率问题，并提高了KCL在类似领域中的性能。这些好处都归功于Rust的no-GC、高性能、更好的错误处理、内存管理、零抽象和其他特性。简而言之，用户是主要受益者。</p><p id="e278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，如果您喜欢KCL项目，想将KCL用于您自己的场景，或者想使用Rust参与一个开源项目，欢迎您访问https://github.com/KusionStack/community<a class="ae kv" href="https://github.com/KusionStack/community" rel="noopener ugc nofollow" target="_blank"/>加入我们的社区，参与讨论和共建。</p><h1 id="07ca" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">参考<a class="ae kv" href="http://localhost:3000/blog/2022-kcl-rewrite-with-rust#reference" rel="noopener ugc nofollow" target="_blank"> </a></h1><ul class=""><li id="7e9a" class="ls lt iq ky b kz my lc mz lf nq lj nr ln ns lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/KusionStack/KCLVM" rel="noopener ugc nofollow" target="_blank">https://github.com/KusionStack/KCLVM</a></li><li id="739d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/Peefy/StackMachine" rel="noopener ugc nofollow" target="_blank">https://github.com/Peefy/StackMachine</a></li><li id="121c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/book/</a></li><li id="ccf0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/sunface/rust-course" rel="noopener ugc nofollow" target="_blank">https://github.com/sunface/rust-course</a></li><li id="4ca4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/" rel="noopener ugc nofollow" target="_blank">https://www . influx data . com/blog/rust-can-be-different-to-learn-and-fairful-it-it-as-it-it-it-in-a-long-time软件开发中最令人兴奋的事情/ </a></li></ul></div></div>    
</body>
</html>