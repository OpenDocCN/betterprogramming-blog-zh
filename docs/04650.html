<html>
<head>
<title>Build a WhatsApp Chatbot With Ruby, Sinatra, and Twilio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ruby、Sinatra和Twilio构建一个WhatsApp聊天机器人</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-whatsapp-chatbot-with-ruby-sinatra-and-twilio-69482ea1e8e8?source=collection_archive---------17-----------------------#2020-04-27">https://betterprogramming.pub/build-a-whatsapp-chatbot-with-ruby-sinatra-and-twilio-69482ea1e8e8?source=collection_archive---------17-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a75" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建您自己的聊天机器人</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/09d33b8dbceca93972a433c889b1e2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qt2yHlQrjNuBsuq9.png"/></div></div></figure><p id="8214" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">聊天机器人是以某种方式与人类交流的程序。它们可以非常基本，对关键词或短语做出反应，或者使用类似于<a class="ae lq" href="https://www.twilio.com/docs/autopilot" rel="noopener ugc nofollow" target="_blank"> Twilio Autopilot </a>的东西来利用自然语言理解(NLU)来提供更丰富的体验，并构建更复杂的对话。</p><p id="dc35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将看到使用<a class="ae lq" href="https://www.twilio.com/docs/sms/whatsapp/api" rel="noopener ugc nofollow" target="_blank"> Twilio API for WhatsApp </a>和Ruby web framework <a class="ae lq" href="http://sinatrarb.com/" rel="noopener ugc nofollow" target="_blank"> Sinatra </a>开始为WhatsApp构建聊天机器人是多么容易。这是我们要建立的对话的一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/aa39167d98bba32155c3a06bd900b787.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/0*eEGBnby_7c56VJnK"/></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="a576" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">你需要什么</h1><p id="e8a7" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">要在本教程中构建自己的WhatsApp bot，您需要以下内容:</p><ul class=""><li id="1f19" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><a class="ae lq" href="https://www.ruby-lang.org/en/downloads/" rel="noopener ugc nofollow" target="_blank">安装红宝石</a>和<a class="ae lq" href="https://bundler.io/" rel="noopener ugc nofollow" target="_blank">捆扎机</a></li><li id="9092" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>这样我们就可以<a class="ae lq" href="https://www.twilio.com/blog/2015/09/6-awesome-reasons-to-use-ngrok-when-testing-webhooks.html" rel="noopener ugc nofollow" target="_blank">以风格</a>向世界公开我们的本地webhook端点</li><li id="f8c8" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">一个<a class="ae lq" href="https://www.whatsapp.com/" rel="noopener ugc nofollow" target="_blank"> WhatsApp账户</a></li><li id="95ca" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">一个Twilio帐户(如果你还没有，请在这里注册一个新的Twilio帐户，升级后可以获得10美元的信用点数</li></ul></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="9b6d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">配置您的WhatsApp沙盒</h1><p id="f87e" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">要在WhatsApp上启动一个机器人，你必须<a class="ae lq" href="https://www.twilio.com/whatsapp/request-access" rel="noopener ugc nofollow" target="_blank">通过WhatsApp的审批流程</a>，但Twilio允许你<a class="ae lq" href="https://www.twilio.com/console/sms/whatsapp/learn" rel="noopener ugc nofollow" target="_blank">使用沙盒</a>构建和测试你的WhatsApp应用。让我们从配置你的WhatsApp账户使用的沙盒开始。</p><p id="7beb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Twilio控制台会引导您完成整个过程，但您需要做的是:</p><ol class=""><li id="cfac" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nk nc nd ne bi translated">前往Twilio控制台的WhatsApp沙盒<a class="ae lq" href="https://www.twilio.com/console/sms/whatsapp/learn" rel="noopener ugc nofollow" target="_blank">区域，或者从控制台</a><a class="ae lq" href="https://www.twilio.com/console/" rel="noopener ugc nofollow" target="_blank">导航到</a><a class="ae lq" href="https://www.twilio.com/console/sms" rel="noopener ugc nofollow" target="_blank">可编程短信</a>然后<a class="ae lq" href="https://www.twilio.com/console/sms/whatsapp/learn" rel="noopener ugc nofollow" target="_blank"> WhatsApp </a>。</li><li id="3929" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nk nc nd ne bi translated">页面上会有WhatsApp沙盒号。打开你的WhatsApp应用程序，给那个号码发一条新消息。</li><li id="3a43" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nk nc nd ne bi translated">该页面还有你需要发送的信息，即“加入”加上两个随机的单词，比如“加入明目张胆的鸽子”。发送您的消息到沙盒号码。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f9a844001c13051c9d6d7b90b8b8814c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*R2mN3RwOIx5wTmR8.png"/></div></figure><p id="03dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您收到一条消息时，您就已经设置好了，可以开始使用沙盒了。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="c5d8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创建Ruby应用程序</h1><p id="67cb" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">让我们开始一个新的Ruby应用程序，在其中构建我们的机器人。首先创建一个新的工作目录。然后，在应用程序中初始化一个新的<code class="fe nm nn no np b">Gemfile</code>,并创建几个我们需要的文件:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="c60d" class="nu ma it np b gy nv nw l nx ny">mkdir whatsapp-bot<br/>cd whatsapp-bot<br/>bundle init<br/>mkdir config<br/>touch bot.rb config.ru config/env.yml</span></pre><p id="0974" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">添加我们将用于构建该应用程序的gem:</p><ul class=""><li id="1fd7" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><a class="ae lq" href="http://sinatrarb.com/" rel="noopener ugc nofollow" target="_blank"> Sinatra </a>，一个简单的web框架。</li><li id="4219" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">twilio-ruby宝石这样我们就可以生成<a class="ae lq" href="https://www.twilio.com/docs/sms/twiml" rel="noopener ugc nofollow" target="_blank"> TwiML </a>。</li><li id="b1fe" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://github.com/httprb/http" rel="noopener ugc nofollow" target="_blank"> http.rb </a>，帮我们以后做一些http请求</li><li id="7141" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://github.com/philnash/envyable" rel="noopener ugc nofollow" target="_blank">envable</a>，to <a class="ae lq" href="https://www.twilio.com/blog/2015/02/managing-development-environment-variables-across-multiple-ruby-applications.html" rel="noopener ugc nofollow" target="_blank">管理应用</a>中的环境变量。</li></ul><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="9596" class="nu ma it np b gy nv nw l nx ny">bundle add sinatra twilio-ruby http envyable</span></pre><p id="e0da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nm nn no np b">config/env.yml</code>将存储我们的应用程序配置，Envyable将为我们将其加载到环境中。我们只需要为这个应用程序存储一个配置:您的Twilio auth令牌，您可以在您的<a class="ae lq" href="https://www.twilio.com/console" rel="noopener ugc nofollow" target="_blank"> Twilio控制台仪表板</a>上找到它。将您的授权令牌添加到<code class="fe nm nn no np b">config/env.yml</code>:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="07e0" class="nu ma it np b gy nv nw l nx ny">TWILIO_AUTH_TOKEN: YOUR_TWILIO_AUTH_TOKEN</span></pre><p id="c2f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用<code class="fe nm nn no np b">config.ru</code>来加载应用程序和配置，并运行它。将以下内容复制到<code class="fe nm nn no np b">config.ru</code>:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="3e43" class="nu ma it np b gy nv nw l nx ny">require 'bundler'<br/>Bundler.require</span><span id="4b59" class="nu ma it np b gy nz nw l nx ny">Envyable.load('./config/env.yml')</span><span id="983d" class="nu ma it np b gy nz nw l nx ny">require './bot.rb'<br/>run WhatsAppBot</span></pre><p id="629b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过创建一个“Hello World！”来测试一切是否按预期运行辛纳特拉应用。打开<code class="fe nm nn no np b">bot.rb</code>并输入以下代码:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="dc33" class="nu ma it np b gy nv nw l nx ny">require "sinatra/base"</span><span id="ab02" class="nu ma it np b gy nz nw l nx ny">class WhatsAppBot &lt; Sinatra::Base<br/>  get '/' do<br/>    "Hello World!"<br/>  end<br/>end</span></pre><p id="4c60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在命令行上，使用以下命令启动应用程序:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="2480" class="nu ma it np b gy nv nw l nx ny">bundle exec rackup config.ru</span></pre><p id="36b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应用程序将在<a class="ae lq" href="http://localhost:9292" rel="noopener ugc nofollow" target="_blank"> localhost:9292 </a>上启动。在你的浏览器中打开它，你会看到“Hello World！”。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="f492" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">构建聊天机器人</h1><p id="bbfc" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">现在我们的应用程序已经设置好了，我们可以开始构建我们的机器人了。在这篇文章中，我们将构建一个简单的机器人，当有人向我们的WhatsApp号码发送消息时，它会响应两个关键字。我们要在消息中寻找的单词是“狗”或“猫”，我们的机器人会用一张随机的图片和关于狗或猫的事实来回应。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="6a09" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Webhooks</h1><p id="12d6" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">使用WhatsApp的Twilio API，当您的号码(或沙盒帐户)收到一条消息时，Twilio会向您定义的URL发出一个<a class="ae lq" href="https://www.twilio.com/docs/usage/webhooks" rel="noopener ugc nofollow" target="_blank"> webhook请求</a>。该请求将包括关于消息的所有信息，包括消息的正文。</p><p id="be9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的应用程序需要定义一个路由，我们可以将其设置为webhook请求URL来接收这些传入的消息，解析出消息是否包含我们正在寻找的单词，并使用<a class="ae lq" href="https://www.twilio.com/docs/sms/twiml" rel="noopener ugc nofollow" target="_blank"> TwiML </a>进行响应。TwiML是一组描述应用程序如何与Twilio通信的XML元素。</p><p id="59a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，我们构建的应用程序可以响应根路径上的webhook，但是它所做的只是响应“Hello World！”所以让我们开始更新它。</p><p id="70e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们去掉“Hello World！”路线并添加一条<code class="fe nm nn no np b">/bot</code>路线。默认情况下，Twilio webhooks是<code class="fe nm nn no np b">POST</code>请求，所以我们也将设置路由来处理它。为此，我们将一个块传递给Sinatra定义的<code class="fe nm nn no np b">post</code>方法。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="c076" class="nu ma it np b gy nv nw l nx ny">require "sinatra/base"</span><span id="7dde" class="nu ma it np b gy nz nw l nx ny">class WhatsAppBot &lt; Sinatra::Base<br/>  post '/bot' do</span><span id="bdf1" class="nu ma it np b gy nz nw l nx ny">  end<br/>end</span></pre><p id="e39a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们从请求参数中提取消息体。因为我们要尝试将消息的内容与单词“狗”和“猫”进行匹配，所以我们还要将正文翻译成小写。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="9a84" class="nu ma it np b gy nv nw l nx ny">class WhatsAppBot &lt; Sinatra::Base<br/>  post '/bot' do<br/>    body = params["Body"].downcase<br/>  end<br/>end</span></pre><p id="465a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用TwiML来响应消息，而<code class="fe nm nn no np b">twilio-ruby</code>库为我们提供了一个有用的类来构建我们的响应:<code class="fe nm nn no np b">Twilio::TwiML::MessagingResponse</code>。在下一行初始化新的响应:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="36c5" class="nu ma it np b gy nv nw l nx ny">class WhatsAppBot &lt; Sinatra::Base<br/>  post '/bot' do<br/>    body = params["Body"].downcase<br/>    response = Twilio::TwiML::MessagingResponse.new<br/>  end<br/>end</span></pre><p id="f613" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nm nn no np b">MessagingResponse</code>对象使用构建器模式来生成响应。我们将构建一条消息，然后向其中添加正文和媒体。我们可以将一个块传递给<code class="fe nm nn no np b">Twilio::TwiML::MessagingResponse#message</code>方法，这将在结果中的<code class="fe nm nn no np b"><a class="ae lq" href="https://www.twilio.com/docs/sms/twiml/message" rel="noopener ugc nofollow" target="_blank">&lt;Message&gt;</a></code> <a class="ae lq" href="https://www.twilio.com/docs/sms/twiml/message" rel="noopener ugc nofollow" target="_blank">元素</a>中嵌套这些元素。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="b9f6" class="nu ma it np b gy nv nw l nx ny">class WhatsAppBot &lt; Sinatra::Base<br/>  post '/bot' do<br/>    body = params["Body"].downcase<br/>    response = Twilio::TwiML::MessagingResponse.new<br/>    response.message do |message|<br/>      # nested in a &lt;Message&gt;<br/>    end<br/>  end<br/>end</span></pre><p id="254d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们需要开始构建我们的实际响应。我们将检查正文是否包含单词“狗”或“猫”，并添加相关的响应。如果消息体不包含任何单词，我们还应该添加一个默认响应来告诉用户机器人可以响应什么。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="8d69" class="nu ma it np b gy nv nw l nx ny">class WhatsAppBot &lt; Sinatra::Base<br/>  post '/bot' do<br/>    body = params["Body"].downcase<br/>    response = Twilio::TwiML::MessagingResponse.new<br/>    response.message do |message|<br/>      if body.include?("dog")<br/>        # add dog fact and picture to the message<br/>      end<br/>      if body.include?("cat")<br/>        # add cat fact and picture to the message<br/>      end<br/>      if !(body.include?("dog") || body.include?("cat"))<br/>        message.body("I only know about dogs or cats, sorry!")<br/>      end<br/>    end<br/>  end<br/>end</span></pre><p id="d240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们目前没有办法获得狗或猫的事实。幸运的是，我们可以使用一些API来实现这一点。对于狗，我们将使用<a class="ae lq" href="https://dog.ceo/dog-api/" rel="noopener ugc nofollow" target="_blank">狗CEO API用于图片</a>和<a class="ae lq" href="https://kinduff.github.io/dog-api/" rel="noopener ugc nofollow" target="_blank">这个狗API用于事实</a>。对于猫来说，有<a class="ae lq" href="https://thecatapi.com/" rel="noopener ugc nofollow" target="_blank">图片API</a>和<a class="ae lq" href="https://catfact.ninja/" rel="noopener ugc nofollow" target="_blank">猫事实API</a>。我们将使用之前安装的http.rb库向这些API中的每一个发出请求。</p><p id="2f06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个API处理<code class="fe nm nn no np b">GET</code>请求。要使用http.rb发出get请求，您可以在<code class="fe nm nn no np b">HTTP</code>模块上调用<code class="fe nm nn no np b">get</code>,将URL作为字符串传递。<code class="fe nm nn no np b">get</code>方法返回一个响应对象，您可以通过调用<code class="fe nm nn no np b">to_s</code>来读取其内容。</p><p id="315b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使应用程序美观整洁，让我们将对这些服务的API调用打包到一个<code class="fe nm nn no np b">Dog</code>和<code class="fe nm nn no np b">Cat</code>模块中，每个模块都有一个<code class="fe nm nn no np b">fact</code>和<code class="fe nm nn no np b">picture</code>方法。</p><p id="b21a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将这些模块添加到底部<code class="fe nm nn no np b">bot.rb</code>:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="acc5" class="nu ma it np b gy nv nw l nx ny">module Dog<br/>  def self.fact<br/>    response = HTTP.get("https://dog-api.kinduff.com/api/facts")<br/>    JSON.parse(response.to_s)["facts"].first<br/>  end</span><span id="4001" class="nu ma it np b gy nz nw l nx ny">  def self.picture<br/>    response = HTTP.get("https://dog.ceo/api/breeds/image/random")<br/>    JSON.parse(response.to_s)["message"]<br/>  end<br/>end</span><span id="a6f0" class="nu ma it np b gy nz nw l nx ny">module Cat<br/>  def self.fact<br/>    response = HTTP.get("https://catfact.ninja/fact")<br/>    JSON.parse(response.to_s)["fact"]<br/>  end</span><span id="b246" class="nu ma it np b gy nz nw l nx ny">  def self.picture<br/>    response = HTTP.get("https://api.thecatapi.com/v1/images/search")<br/>    JSON.parse(response.to_s).first["url"]<br/>  end<br/>end</span></pre><p id="9163" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以像这样在webhook响应中使用这些模块:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="40cd" class="nu ma it np b gy nv nw l nx ny">class WhatsAppBot &lt; Sinatra::Base<br/>  post '/bot' do<br/>    body = params["Body"].downcase<br/>    response = Twilio::TwiML::MessagingResponse.new<br/>    response.message do |message|<br/>      if body.include?("dog")<br/>        message.body(Dog.fact)<br/>        message.media(Dog.picture)<br/>      end<br/>      if body.include?("cat")<br/>        message.body(Cat.fact)<br/>        message.media(Cat.picture)<br/>      end<br/>      if !(body.include?("dog") || body.include?("cat"))<br/>        message.body("I only know about dogs or cats, sorry!")<br/>      end<br/>    end<br/>  end<br/>end</span></pre><p id="14fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要通过Twilio将消息返回给WhatsApp，我们需要将响应的内容类型设置为“text/xml”并返回xml字符串。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="2cf2" class="nu ma it np b gy nv nw l nx ny">class WhatsAppBot &lt; Sinatra::Base<br/>  post '/bot' do<br/>    body = params["Body"].downcase<br/>    response = Twilio::TwiML::MessagingResponse.new<br/>    response.message do |message|<br/>      if body.include?("dog")<br/>        message.body(Dog.fact)<br/>        message.media(Dog.picture)<br/>      end<br/>      if body.include?("cat")<br/>        message.body(Cat.fact)<br/>        message.media(Cat.picture)<br/>      end<br/>      if !(body.include?("dog") || body.include?("cat"))<br/>        message.body("I only know about dogs or cats, sorry!")<br/>      end<br/>    end<br/>    content_type "text/xml"<br/>    response.to_xml<br/>  end<br/>end</span></pre><p id="4cac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是webhook的所有代码，但是还有一点需要考虑。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="458d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Webhook安全性</h1><p id="d992" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">这可能不是在webhook请求中返回的最关键的数据，但是保护您的web hook以确保您只响应来自您期望的服务的请求是一个很好的实践。<a class="ae lq" href="https://www.twilio.com/docs/usage/webhooks/webhooks-security#validating-signatures-from-twilio" rel="noopener ugc nofollow" target="_blank"> Twilio使用您的auth token </a>对所有webhook请求进行签名，您可以验证该签名来验证请求。</p><p id="f15b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nm nn no np b"><a class="ae lq" href="https://www.twilio.com/blog/2014/09/securing-your-ruby-webhooks-with-rack-middleware.html" rel="noopener ugc nofollow" target="_blank">twilio-ruby</a></code> <a class="ae lq" href="https://www.twilio.com/blog/2014/09/securing-your-ruby-webhooks-with-rack-middleware.html" rel="noopener ugc nofollow" target="_blank">库提供了rack中间件，使得验证来自Twilio </a>的请求变得容易:让我们也将它添加到应用程序中。在你的<code class="fe nm nn no np b">WhatsAppBot</code>类的顶部，包含带有<code class="fe nm nn no np b">use</code>方法的中间件。将以下三个参数传递给<code class="fe nm nn no np b">use</code>:中间件类<code class="fe nm nn no np b">Rack::TwilioWebhookAuthentication</code>、认证令牌和保护路径(在本例中为“/bot”)。)</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="4c72" class="nu ma it np b gy nv nw l nx ny">class WhatsAppBot &lt; Sinatra::Base<br/>  use Rack::TwilioWebhookAuthentication, ENV['TWILIO_AUTH_TOKEN'], '/bot'<br/> <br/>  post '/bot' do</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="328f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">将机器人连接到WhatsApp</h1><p id="6225" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在命令行上，用<code class="fe nm nn no np b">ctrl/cmd + c</code>停止应用程序，并用以下命令重新启动:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="4a44" class="nu ma it np b gy nv nw l nx ny">bundle exec rackup config.ru</span></pre><p id="c09b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在需要确保Twilio webhooks能够到达我们的应用程序。这就是为什么我在这个应用程序的需求中包含了<a class="ae lq" href="https://ngrok.com" rel="noopener ugc nofollow" target="_blank"> ngrok </a>。ngrok允许我们将一个公共URL连接到运行在我们机器上的应用程序。如果您还没有安装ngrok，请按照说明下载并安装ngrok 。</p><p id="dc5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令启动ngrok，通过隧道到达端口9292:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="b089" class="nu ma it np b gy nv nw l nx ny">ngrok http 9292</span></pre><p id="1063" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将为您提供一个ngrok URL，您现在可以将它添加到WhatsApp沙盒中，以便传入的消息将被定向到您的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ba3d8dc34647fc7b6842c479aacc79c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*UwyKMtkrBbaYW-G7.png"/></div></figure><p id="6a84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获取ngrok URL并添加bot的路径，看起来像这样:<code class="fe nm nn no np b">https://YOUR_NGROK_SUBDOMAIN.ngrok.io/bot</code>。在WhatsApp沙盒管理中标记为“当有消息时”的输入中输入该URL，并保存配置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3966f2da4077556b4c88e7f83aaafa34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*nfwnutATDuVsQA1W.png"/></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="783d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">测试你的机器人</h1><p id="6010" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">现在，你可以向WhatsApp沙盒号码发送一条消息，你的应用程序就会开始运行，向你返回狗或猫的图片和事实。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/9c2868493b353b77837f3480735aee43.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/0*D7Jv9nJCQ2YSg_Nx"/></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="247b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">制造更多的机器人</h1><p id="8067" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在这篇文章中，我们看到了如何为WhatsApp配置Twilio API，并将其连接到Ruby应用程序，以返回狗或猫的图片和事实。你可以在GitHub 上获得这个bot的所有<a class="ae lq" href="https://github.com/philnash/ruby-whatsapp-bots" rel="noopener ugc nofollow" target="_blank">代码。</a></p><p id="b4ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个简单的机器人，但它为构建更多机器人提供了良好的基础。你可以研究一下<a class="ae lq" href="https://www.twilio.com/blog/celebrity-spotting-twilio-api-whatsapp-aws-rekognition-ruby" rel="noopener ugc nofollow" target="_blank">从WhatsApp接收图像，制作一个视觉机器人</a>或<a class="ae lq" href="https://www.twilio.com/docs/sms/whatsapp/api#location-messages-with-whatsapp" rel="noopener ugc nofollow" target="_blank">发送或接收位置，作为信息</a>的一部分。我们还可以在此基础上使用Twilio Autopilot创建更智能的机器人。</p><p id="607b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你造过什么有趣的机器人吗？你还希望探索哪些其他功能？请在评论中告诉我。</p></div></div>    
</body>
</html>