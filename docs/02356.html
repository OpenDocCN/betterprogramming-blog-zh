<html>
<head>
<title>The Elegant Context Pattern in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中优雅的上下文模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-elegant-context-pattern-in-react-a32dda91f46a?source=collection_archive---------12-----------------------#2019-11-25">https://betterprogramming.pub/the-elegant-context-pattern-in-react-a32dda91f46a?source=collection_archive---------12-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4adc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">组合React上下文提供者和useContext挂钩，以便它们可以方便地使用和重用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e927c3027c9046c6267571f0695fe32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zq0xoZhoTy_REiSM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@paulius005?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Paulius Dragunas </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fd70" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="e2b1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">React中的上下文用于共享组件树的全局数据，比如经过身份验证的用户或首选主题，而无需将这些数据作为道具传递。这里我们不会讨论React Context API的基础知识，而是看看如何优雅地使用它。</p><h2 id="07be" class="mu lh it bd li mv mw dn lm mx my dp lq mh mz na ls ml nb nc lu mp nd ne lw nf bi translated">我们将开发的应用程序</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f72f6101926eb5aba3b4b5d01622b989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*dGLx1-qJzs9f8BifW0u14Q.gif"/></div></figure><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="43b6" class="mu lh it ni b gy nm nn l no np">function App(props) {<br/>  const [number, setNumber] = useState(0);<br/>  const changeNumberHandler = () =&gt; {<br/>  setNumber(c =&gt; c + 1)<br/>  }<br/>  return (<br/>   &lt;div className="App"&gt;<br/>    The Main App Component {number}<br/>    &lt;UserProvider&gt; {/* Our Custom Provider */}<br/>      &lt;Comp1 /&gt;<br/>    &lt;/UserProvider&gt;<br/>    &lt;button onClick={changeNumberHandler}&gt;<br/>      Changing Main Component Number<br/>    &lt;/button&gt;<br/>   &lt;/div&gt;<br/>  );<br/> <!-- -->}<br/><br/>// comp1 renders<br/>&lt;Comp2 /&gt;<br/>// ... which renders ...<br/>&lt;Comp3 /&gt;<br/>&lt;Comp4 /&gt;</span></pre><p id="0a33" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">这里我们将使用<code class="fe nv nw nx ni b"><a class="ae ky" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users</a>/{userId}</code>来获取<code class="fe nv nw nx ni b">userId</code>的用户。我们将使用<code class="fe nv nw nx ni b">Math.random()</code>生成一个从1到10的随机数，我们将把它用作<code class="fe nv nw nx ni b">userId</code>。获取结果后，我们将把结果提供给<code class="fe nv nw nx ni b">Comp3</code>和<code class="fe nv nw nx ni b">Comp4</code>。除此之外，我们还将提供一个函数来改变<code class="fe nv nw nx ni b">userId</code>并获取新<code class="fe nv nw nx ni b">userId</code>的结果。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="737b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">浏览上下文</h1><h2 id="fbba" class="mu lh it bd li mv mw dn lm mx my dp lq mh mz na ls ml nb nc lu mp nd ne lw nf bi translated">React.createContext上下文</h2><p id="3f70" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">创建一个新的上下文对象，用于在不使用props的情况下将值传递给组件树。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9b36" class="mu lh it ni b gy nm nn l no np">const MyContext = React.createContext(<em class="ny">defaultValue</em>);</span></pre><h2 id="4e8f" class="mu lh it bd li mv mw dn lm mx my dp lq mh mz na ls ml nb nc lu mp nd ne lw nf bi translated"><strong class="ak">语境。提供商</strong></h2><p id="888e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">提供者允许消费React组件订阅上下文更改。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="60d6" class="mu lh it ni b gy nm nn l no np">&lt;MyContext.Provider value={<em class="ny">someValue</em>}&gt;</span></pre><p id="3335" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">每当值属性更改时，作为提供者后代的所有使用者都将重新呈现。</p><h2 id="7898" class="mu lh it bd li mv mw dn lm mx my dp lq mh mz na ls ml nb nc lu mp nd ne lw nf bi translated">使用上下文挂钩</h2><p id="95a8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">它可以用于接受上下文对象并返回当前上下文值的功能组件中。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3166" class="mu lh it ni b gy nm nn l no np">const value = useContext(MyContext);</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="68e2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">自定义提供程序和挂钩</h1><p id="fcd0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们将创建一个自定义提供者(<code class="fe nv nw nx ni b">UserProvider</code>)，它将用于向每个后代提供值。为了使用这个值，我们将创建一个定制钩子(<code class="fe nv nw nx ni b">useUser</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">user.js</p></figure><p id="c3bb" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">这里我们给了<code class="fe nv nw nx ni b">undefined</code>作为上下文的默认值。一般来说，只要我们试图在组件中使用上下文对象的值，而该组件不是该上下文对象的提供者的后代，就会使用该默认值。</p><p id="675d" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">我们给<code class="fe nv nw nx ni b">UserContext.Provider</code>的<code class="fe nv nw nx ni b">value</code>道具一个数组。这个数组有<code class="fe nv nw nx ni b">user</code>状态的值和一个函数<code class="fe nv nw nx ni b">changeUser</code>，这个函数计算一个从1到10的随机数，并把它存储在一个叫做<code class="fe nv nw nx ni b">random</code>的状态中。</p><p id="8a7e" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">我们在<code class="fe nv nw nx ni b">useEffect</code>钩子中对端点进行Ajax调用，该钩子在其依赖数组中只有<code class="fe nv nw nx ni b">random</code>状态。这意味着这个效果只有在我们的<code class="fe nv nw nx ni b">random</code>状态改变时才会执行。</p><p id="36e2" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">在return语句中，我们正在编写主要的上下文提供者逻辑，它将把值传递给作为其后代的所有消费者。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e417" class="mu lh it ni b gy nm nn l no np">&lt;UserContext.Provider value={data}&gt;<br/>  {children}<br/>&lt;/UserContext.Provider&gt;</span></pre><p id="1c0f" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">在我们的定制提供者之后，我们创建了我们的定制钩子。在这个钩子中，首先我们使用一个<code class="fe nv nw nx ni b">useContext</code>钩子来获取上下文对象的值。之后，为了防止在任何非后代组件中意外使用我们的自定义钩子，我们将检查使用<code class="fe nv nw nx ni b">useContext</code>获得的值是否等于在创建上下文对象期间给定的<code class="fe nv nw nx ni b">defaultValue</code>。在我们的例子中，这个默认值是<code class="fe nv nw nx ni b">undefined</code>。如果值是<code class="fe nv nw nx ni b">undefined</code>，那么我们可以说我们的定制钩子用于任何非后代组件。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f27b" class="mu lh it ni b gy nm nn l no np">//undefined is given as default value<br/>const UserContext = React.createContext(undefined);</span></pre><p id="ab70" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">然后，从我们的自定义钩子，我们返回获得的上下文值。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d450" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">逮到你了</h1><p id="6d4d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们知道，Provider的所有后代组件将随着value prop的更改而重新呈现，并且即使它们已经使用了<code class="fe nv nw nx ni b">PureComponent</code>、<code class="fe nv nw nx ni b">shouldComponentUpdate</code>或<code class="fe nv nw nx ni b">React.memo</code>，它们也不能退出更新。</p><p id="c062" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">此外，当提供者的父级重新呈现时，消费者中可能会有一些无意的呈现。</p><p id="e89b" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">让我们在Comp1中使用<code class="fe nv nw nx ni b">React.memo</code>,这样就不会因为App组件的变化而在Comp3及其子组件中出现意外的渲染。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">comp1.js</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">app.js</p></figure><p id="1fc9" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">App组件有一个按钮。点击它更新<code class="fe nv nw nx ni b">number</code>状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/544668591f00beb014ffaba163039254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*wo8gRub9CJYwHUvlhraCUQ.gif"/></div></figure><p id="06ac" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">现在我们可以在上面的图像中观察到，Comp3和Comp4正在被重新渲染，尽管我们在Comp1中使用了<code class="fe nv nw nx ni b">React.memo</code>，而Comp2没有被重新渲染。</p><p id="588f" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">这是因为我们在Provider中使用数组作为价值支柱。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a130" class="mu lh it ni b gy nm nn l no np">const data = [user, changeUser]<br/>return (<br/>  &lt;UserContext.Provider value={data}&gt;<br/>    {children}<br/>  &lt;/UserContext.Provider&gt;<br/>)</span></pre><p id="83a6" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">因此，每当App组件被重新呈现时，我们的<code class="fe nv nw nx ni b">UserProvider</code>组件也会被重新呈现。这将为我们的<code class="fe nv nw nx ni b">changeUser</code>函数和<code class="fe nv nw nx ni b">data</code>数组创建新的引用，这将触发所有消费者的重新呈现。</p><p id="2fd2" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">为了克服这个问题，我们将使用<code class="fe nv nw nx ni b">useCallback</code>作为我们的<code class="fe nv nw nx ni b">changeUser</code>函数，使用<code class="fe nv nw nx ni b">useMemo</code>作为我们的<code class="fe nv nw nx ni b">data</code>数组。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2b71" class="mu lh it ni b gy nm nn l no np">const changeUser = useCallback(() =&gt; {<br/>  const randomNumber = Math.floor(Math.random() * 10 + 1);<br/>  setRandom(randomNumber);<br/>}, [])</span><span id="302c" class="mu lh it ni b gy ob nn l no np">const data = useMemo(() =&gt; ([<br/>  user,<br/>  changeUser<br/>]), [user, changeUser])</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="11d9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">使用</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">user.js</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">comp3.js</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">comp4.js</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">comp2.js</p></figure><p id="943c" class="pw-post-body-paragraph ly lz it ma b mb nq ju md me nr jx mg mh ns mj mk ml nt mn mo mp nu mr ms mt im bi translated">Comp3和Comp4正在使用<code class="fe nv nw nx ni b">useUser</code>钩子。另外，当点击按钮时，Comp4正在调用<code class="fe nv nw nx ni b">changeUser</code>函数。当<code class="fe nv nw nx ni b">changeUser</code>被调用时，Comp3和Comp4中的数据都被改变。由于React上下文，这一切都是可能的。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="825e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">参考</h1><div class="oc od gp gr oe of"><a href="https://reactjs.org/docs/context.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">上下文反应</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">上下文提供了一种通过组件树传递数据的方法，而不必每次都手动传递属性</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">reactjs.org</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">钩子API参考-反应</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">reactjs.org</p></div></div><div class="oo l"><div class="ou l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>