<html>
<head>
<title>You Don’t Know useState Until You’ve Used Functional Updates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在使用功能更新之前，您不知道使用状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/you-dont-know-usestate-until-you-ve-used-functional-updates-5da52117620f?source=collection_archive---------4-----------------------#2021-01-13">https://betterprogramming.pub/you-dont-know-usestate-until-you-ve-used-functional-updates-5da52117620f?source=collection_archive---------4-----------------------#2021-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">何时我们可能需要使用状态功能更新以及如何使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cdd64682ace0cc122826ebb5400cf80f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpTb5APWfJuObeFpvk-Hjw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">找到合适的工具通常是成功的一半。作者照片。</p></figure><p id="e5d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们需要保持任何状态时，<code class="fe lu lv lw lx b">useState</code>是现今React中最常见的解决方案。它返回当前状态值和更新它的方法:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="9c35" class="mc md it lx b gy me mf l mg mh">const [state, setState] = useState(initialValue);</span></pre><p id="8ed4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数情况下，<code class="fe lu lv lw lx b">setState</code>是以一种简单的方式使用的，当我们调用它时，我们希望状态值作为参数传递:<code class="fe lu lv lw lx b">setState(newState)</code>。<br/>大多数情况下很简单也很充分。</p><p id="519f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这并不是用<code class="fe lu lv lw lx b">setState</code>修改状态的唯一方法。在关于<code class="fe lu lv lw lx b">useState</code>的React文档中，有一段解释了更新状态的函数方式:<a class="ae mi" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">函数更新</a>。</p><p id="c9fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，它们让你传递一个函数给<code class="fe lu lv lw lx b">setState</code>而不是一个值。该函数将接收当前状态作为第一个参数，返回值将变成一个新状态，如下所示:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="d235" class="mc md it lx b gy me mf l mg mh">setState(currentState =&gt; {<br/>  const newState = modify(currentState);<br/>  return newState;<br/>});</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="544d" class="mq md it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">什么时候我可能需要使用功能更新？</h1><p id="64e7" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">如果我们在同步环境中操作，大多数时候，一个常规的<code class="fe lu lv lw lx b">setState</code>就足够了。当应用程序的多个部分共享状态，并且我们必须使用异步函数时(例如，当发出API请求时)，事情就变得复杂了。</p><p id="3d66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，当我们调用一个异步函数并到达调用<code class="fe lu lv lw lx b">setState</code>的点时，我们用来计算新状态的其他变量可能已经过时了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ba21" class="mq md it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">例子</h1><p id="5a3a" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">出于本文的目的，让我们假设我们正在构建一个简单的计数器。当点击按钮时，它将增加。</p><p id="77a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将有两个按钮:一个只是立即增加计数器，另一个超时(例如，模仿正在进行的API调用)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4bc1bfca8408803c7186e040daa4b733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*q8vYKNCQJRALRfd4qqxbLA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们将要建造的柜台</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b64c" class="mq md it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">履行</h1><h2 id="5829" class="mc md it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">常规设置状态</h2><p id="f37e" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">让我们从一个简单的同步按钮开始增加计数器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b089" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是这样工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b660691cb0477b733ee191386ebb2123.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/1*pbHBry5asMATB7Xk-L7rmg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的计数器。</p></figure><h2 id="ddf2" class="mc md it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">添加异步调用</h2><p id="ad6b" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">现在，让我们添加第二个按钮，它将异步递增计数器。我们将使用下面的<code class="fe lu lv lw lx b">wait</code>辅助函数来模拟一个异步函数调用，该调用在指定的时间段后结束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bb6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建递增函数<code class="fe lu lv lw lx b">async</code>，等待一段时间，然后像我们对第一个按钮所做的那样递增计数器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8b83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使函数异步，我们可能认为这应该做的工作。但是让我们来看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/84dce2aa0867c745ad682b144be2c0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/0*UUxkyCqmwZJ-SBu0.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有直接异步增量的计数器</p></figure><p id="0416" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们递增计数器，然后点击异步计数器，再递增几次。为什么计数器的最终状态是<code class="fe lu lv lw lx b">2</code>？</p><p id="8108" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当调用<code class="fe lu lv lw lx b">handleIncrementAsync</code>时，<code class="fe lu lv lw lx b">counter</code>值为<code class="fe lu lv lw lx b">1</code>。该值将在函数的整个生命周期中被记住。这就是为什么我们最后得到了<code class="fe lu lv lw lx b">2</code>。当<code class="fe lu lv lw lx b">await wait()</code>结束时，我们仍然引用旧值(<code class="fe lu lv lw lx b">1</code>)并递增该值。</p><h2 id="0be3" class="mc md it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">是否使用帮助回调？</h2><p id="9d69" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">起初，我们可能认为<code class="fe lu lv lw lx b">useCallback</code>会有助于解决这种情况。将<code class="fe lu lv lw lx b">counter</code>作为一个依赖项应该会使函数引用成为最新的值。让我们试试下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8a698e9b3e1d82cf58f5281eff45397d.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/0*Q_-lvnjyXw-GcP34.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用基于回调的异步增量的计数器</p></figure><p id="e14f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样的情况仍然会发生，即使<code class="fe lu lv lw lx b">counter</code>在依赖数组中。每当它改变时，<code class="fe lu lv lw lx b">handleIncrementCallback</code>确实被更新，但是只有“新的”函数调用利用了这一点。如果我们有一个已经运行的函数(就像我们一样，因为对“Increment useCallback”处理程序的第一次调用仍在等待<code class="fe lu lv lw lx b">wait</code>完成)，这没有什么区别。</p><h2 id="3435" class="mc md it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">功能更新</h2><p id="8e06" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">现在让我们探索另一种调用<code class="fe lu lv lw lx b">setCounter</code>的方法。正如开头提到的，它可以接受一个函数而不是一个值。React将调用该函数，并将状态的当前版本作为参数传递。这种方式被称为<a class="ae mi" href="https://reactjs.org/docs/hooks-reference.html#functional-updates" rel="noopener ugc nofollow" target="_blank">功能更新</a>让我们回顾一下:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="69ad" class="mc md it lx b gy me mf l mg mh">setState(currentState =&gt; {<br/>  const newState = modify(currentState);<br/>  return newState;<br/>});</span></pre><p id="435c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的例子中，<code class="fe lu lv lw lx b">currentState</code>将代表计数器的实际值。让我们修改代码并使用功能更新方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="49c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们这样调用<code class="fe lu lv lw lx b">setCounter</code>:<code class="fe lu lv lw lx b">setCounter(_counter =&gt; _counter + 1)</code>。<br/><code class="fe lu lv lw lx b">_counter</code>值将代表调用<code class="fe lu lv lw lx b">setCounter</code>时计数器的最新值。我们来看看效果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/f6d5c4a2fbfa5a61f8dc667e21758f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/0*Hjh9RCQIYHcyl5R_.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有异步功能更新的计数器</p></figure><p id="441e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总共有六次点击:</p><ul class=""><li id="11bc" class="oc od it la b lb lc le lf lh oe ll of lp og lt oh oi oj ok bi translated">两秒钟后第一个异步递增的</li><li id="9079" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">当我们等待<code class="fe lu lv lw lx b">wait</code>解决时，点击五次实例化“增量”。</li></ul><p id="9e54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当<code class="fe lu lv lw lx b">wait</code>结束时，计数器值为<code class="fe lu lv lw lx b">5</code>。该值被传递给函数更新调用。作为一个效果，我们正确地计算了所有的点击。</p><h2 id="ef0b" class="mc md it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">小奖励</h2><p id="df4b" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">当我们使用函数更新时，首先重用状态变量名是有意义的。例如:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="afb1" class="mc md it lx b gy me mf l mg mh">const [counter, setCounter] = useState(0);<br/>// ...<br/>function handleIncrement() {<br/>  setCounter(counter =&gt; counter + 1);<br/>}</span></pre><p id="e637" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是从外部范围隐藏(重用)变量并不是一个好的做法。我们可以使用<code class="fe lu lv lw lx b">_</code>或者——更好的是——<code class="fe lu lv lw lx b">current</code>作为变量的前缀，但是以我的拙见，它看起来还是不够好:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="b8db" class="mc md it lx b gy me mf l mg mh">setCounter(_counter =&gt; counter + 1);<br/>setCounter(currentCounter =&gt; currentCounter + 1);</span></pre><p id="2e66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就我个人而言，我建议将增量操作提取到一个单独的函数中，并将其传递给<code class="fe lu lv lw lx b">setCounter</code>:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="3033" class="mc md it lx b gy me mf l mg mh">function increment(value) {<br/>  return value + 1;<br/>}</span><span id="408f" class="mc md it lx b gy oq mf l mg mh">// ...</span><span id="50b7" class="mc md it lx b gy oq mf l mg mh">setCounter(increment);</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1c74" class="mq md it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">摘要</h1><p id="e899" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">我们已经学习了使用功能更新来更新状态的不同方法。我们还强调了为什么使用<code class="fe lu lv lw lx b">useCallback</code>的类似方法在这种情况下不是正确的解决方案。</p><p id="6e55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，每当您需要多个异步函数共享一个状态时，您就有了一个解决方案来以方便的方式处理这种情况。</p><p id="675d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像往常一样，整个项目都在一个<a class="ae mi" href="https://github.com/tfiechowski/use-state-functional-updates-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中。</p><p id="665c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢你坚持到文章的结尾。欢迎在评论中发表你的观点。我非常开放，渴望听到你的反馈，无论是积极的还是消极的！</p></div></div>    
</body>
</html>