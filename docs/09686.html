<html>
<head>
<title>How a Practical Testing Approach Can Speed Up the Coding Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用的测试方法如何加速编码过程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-a-practical-testing-approach-can-speed-up-the-coding-process-29f20f461df8?source=collection_archive---------6-----------------------#2021-09-27">https://betterprogramming.pub/how-a-practical-testing-approach-can-speed-up-the-coding-process-29f20f461df8?source=collection_archive---------6-----------------------#2021-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f9ef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">更快编码、更快交付和无压力产品发布的秘诀</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3f696494afd19791646888b0368e5e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_62IajCWBVoSAD9DbK43Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Marc-Olivier Jodoin 在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用测试用例覆盖代码并交付相同的功能实际上比没有测试更快？怎么可能呢？是的，我想说理解它是我作为软件工程师职业生涯中最好的经历。</p><p id="efc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我和我的团队最近在相对较短的时间内构建了一些PoC，并将其用于一个现场活动。很酷，但这真的没什么特别的。现在有趣的部分来了——在现场活动期间，在客户使用我们系统的同时，我们做了十几个有新变化的后端生产发布，没有任何质量保证——每次我们都确信不会破坏任何东西。</p><p id="7008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这怎么可能呢？我们所有的功能都包含了适当的测试用例。所以你们有很棒的QA，他们之前准备了适当的测试？我们实际上有很好的QA，但是这次他们没有参与准备那些测试用例。哦，所以你有足够的时间在活动之前进行测试覆盖？不，我们很匆忙，不得不从我们的解决方案中删除很多东西，实际上，现在我们不得不在事件发生后再花几天时间来修复一些不符合我们质量标准的代码。</p><p id="6978" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，编写测试不需要我们任何额外的时间。关键是编写适当的测试，不要手动测试代码。</p><h1 id="f3ac" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关于测试的常见误解</h1><ol class=""><li id="9ae3" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated"><em class="mv">我们赶时间；我们没时间写测试用例:</em> <br/>所以你没时间写测试用例，但你确实有时间在每次改动后手动测试你的app，重现错误进行调试，每次发布后抽测？对我来说，如果你可以一遍又一遍地手动做那些事情，看起来你有足够的时间。当引入一个变更时，我更喜欢编写一次自动化测试用例，而不是那些手动过程。</li><li id="34a8" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated">测试和实现是分开的事情。我可以稍后准备测试:<br/> 在这种情况下，您如何确保您的代码首先工作？通过手动检查？如果您已经首先准备了测试用例，您就不需要这样做了——那么有什么理由在此期间做一些不必要的手工工作呢？此外，根据我的经验，在代码出现之前设计测试用例要容易得多。你只是写下你接下来想要检查的内容，而不是在一切都已经就绪的情况下考虑应该测试什么。</li></ol><h1 id="0509" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">好吧，那我该怎么做？</h1><blockquote class="nb nc nd"><p id="4b55" class="kw kx mv ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">“写测试。不太多。大多是融合。”— <em class="iq">吉列尔莫·劳赫</em></p></blockquote><p id="f153" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我最喜欢的一句与软件开发相关的名言。</p><p id="42d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为什么要写测试？这是一个基本问题，我希望你已经知道了。</p><p id="66b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mv">为什么没有那么多？</em>因为你写的测试越多，你以后需要维护的时间就越多。更不用说，执行放在首位。懒惰是一种美德！</p><p id="8e6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mv">为什么大多是一体化？这一点不太明显，也不是每个人都同意。它来自<em class="mv">测试钻石</em>的想法，是著名的<em class="mv">测试金字塔</em>的替代方案。我们有三个基本级别的测试:</em></p><ol class=""><li id="1fe7" class="mk ml iq ky b kz la lc ld lf nh lj ni ln nj lr mr ms mt mu bi translated"><strong class="ky ir"> E2E测试</strong>——提供一切正常运行的最佳信心，但是运行它们需要更多的时间，而且它们很容易受到任何变化的影响</li><li id="57d8" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated"><strong class="ky ir">集成测试</strong> —可信度较低(我们测试了一些部分，但不是整个堆栈)。当引入变更时，这些更新更快更容易</li><li id="11e1" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated"><strong class="ky ir">单元测试</strong>——最快，对变化最有弹性，但也给出最少的信心(即使所有单元都工作正常，那些可能以错误的方式组合)</li></ol><p id="ea88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">集成测试基本上是可靠性和执行速度之间的折衷。此外，通常，设计集成测试要比单元一测试容易得多，因为你不需要设计一个指定了一些单元的代码结构。</p><p id="f433" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解更多，你可以查看伟大的<a class="ae kv" href="https://kentcdodds.com/blog/write-tests" rel="noopener ugc nofollow" target="_blank"> Kent C. Dodds post </a>，它更详细地描述了它(从前端上下文)。</p><h1 id="2378" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">有哪些成本？</h1><ol class=""><li id="bc24" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated"><strong class="ky ir">你必须改变你的思维模式</strong>——只要你把手工检查当作验证你的代码的好方法，你就不会得到自动化测试的全部好处。一次手动检查可能会更快，但是检查一次是远远不够的。这就是为什么从自动化开始可以节省您的时间。就我个人而言，我只在两种情况下进行人工检查:验证外观和从最终用户的角度测试解决方案，尤其是在验证总体用户体验是否可以改善的时候。</li><li id="19c1" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated"><strong class="ky ir">练习</strong>——一如既往，它造就一个大师。对我来说，困难的部分是停止考虑一些实现细节，而专注于期望的结果。从时间的角度来看，我可以说，测试实现细节不仅无关紧要，而且通常要困难得多。我失去了很多时间才得到那个。</li><li id="280d" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated">你必须对这种方法保持一致——你在没有测试的情况下实现的代码越多，回到正轨的代价就越大。根据我的经验，当应用程序的重要部分没有被测试覆盖时，编写回归测试要困难得多。在您的发布管道中，您仍然需要昂贵的手动过程。在这种情况下，首先用E2E测试覆盖您的关键路径将是一个很好的起点。</li></ol><h1 id="2fa3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我的过程:一个例子</h1><p id="4b9b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">这里的所有示例代码都是用NodeJS编写的——但是如果这不是您的技术，请不要气馁。这种方法对所有技术都是通用的——包括前端和后端——你只需要使用和我不同的工具。</p><h2 id="074a" class="nn lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">1.设计并确认客户端界面</h2><p id="6175" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">对于通常使用API格式的后端应用程序。任何文档都可以工作，只要确保它在客户端和服务器端都可以工作。</p><h2 id="f29d" class="nn lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated"><strong class="ak"> 2。描述测试用例</strong></h2><p id="c168" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">在API被确认后，我试图找出所有(或大多数)用例，并为它们编写测试描述。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="47f8" class="nn lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">3.编写第一个测试用例</h2><p id="26a5" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">提醒你一下，这些是综合测试。在这种情况下，我不会试图嘲笑一切，这使得许多事情变得更容易——例如，我可以使用数据库。对于NodeJS集成/API级测试，我推荐<a class="ae kv" href="https://www.npmjs.com/package/supertest" rel="noopener ugc nofollow" target="_blank"> supertest </a>。也需要做一些准备，但是不要担心——这对于许多测试用例来说是很常见的，所以编写代码只是在第一次的时候比较耗时。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="9871" class="nn lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">4.写一些代码通过第一个测试用例</h2><p id="99fd" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">实现细节与此无关，所以我将跳过示例代码。</p><p id="66e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，当业务逻辑要求您通过更复杂的特定集成测试时，那么在这一点上编写一些单元测试也是一个好主意。我的方法在这里是一样的——首先，设计单元的公共API，描述用例，实现第一个测试用例，最后，编写一些代码。纯TDD。</p><p id="eea8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的逻辑非常标准，并且您可以实现一些代码来顺利通过集成测试——尽管去做，跳过单元测试。你会注意到什么时候你会真正需要它们。</p><h2 id="586d" class="nn lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">5.提交并推送代码</h2><p id="d7fd" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">这可能会发生得早一点/晚一点，但是一般来说，进行原子提交是一个非常好的实践。推送触发了一些到暂存环境的自动部署，我的同事可以开始使用已经完成的部分。</p><p id="2c24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的代码由于任何原因甚至在一个登台环境中也不能工作，请将它隐藏在一个特性标志后面。</p><h2 id="8822" class="nn lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">6.重复直到它准备好</h2><p id="7055" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">当特性准备好了，我通常会准备一些冒烟和性能测试，在已经部署的应用程序上运行。这可能是你组织中QA的职责。如果不是，并且您没有编写任何冒烟和性能测试，我鼓励您尝试一下。</p><p id="c0c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，有一些真正对开发人员友好的工具在做这些事情，比如<a class="ae kv" href="https://k6.io/" rel="noopener ugc nofollow" target="_blank">K6 . io</a>——这是一个性能测试工具，测试用例是用JS编写的。我实际上也用它在部署后对我的API进行冒烟测试——或者用<a class="ae kv" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress </a>进行E2E测试，包括前端应用。</p><h2 id="a7ab" class="nn lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">7.等待反馈</h2><p id="db9a" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">反馈可以来自你的同行(另一个开发人员消费你的API，QA，PM)，你的客户，或者一些自动化的报告工具。不管它来自哪里，如果有任何问题，我都会继续相同的过程，并确保我的测试案例和代码都涵盖了之前遗漏的案例。</p><p id="9d3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果从技术角度来看一切正常，就可以上线了！</p><h1 id="a932" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="1c9d" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">令人难以置信的是，如果你专注于测试，以确保你的应用程序实际工作，而不仅仅是“一些”测试或x%的测试覆盖率，你的工作流会变得多么强大和健壮。对我来说，最大的发现是它可以变得非常简单(如果你做得对，就应该如此！).你唯一需要的是正确的工具和正确的心态。</p><p id="965b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。如果你从未尝试过这样的工作，我希望你会受到鼓励去尝试。欢迎留下任何意见或问题！</p></div></div>    
</body>
</html>