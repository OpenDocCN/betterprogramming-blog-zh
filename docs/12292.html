<html>
<head>
<title>Code Complexity and the Bin Packing Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码复杂性和装箱问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/code-complexity-and-the-bin-packing-problem-928538d72a29?source=collection_archive---------15-----------------------#2022-05-25">https://betterprogramming.pub/code-complexity-and-the-bin-packing-problem-928538d72a29?source=collection_archive---------15-----------------------#2022-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a98a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">软件系统设计的心理工具</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/bbdd1af2456122ae426a849a5607bc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*sF2siczClL_G_2Ln1QCymw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">在火锅. ai生成，授权本人使用。对于所有围绕人工智能创造艺术的炒作，这看起来不太像提示“连续十个箱子”，不是吗？</p></figure><p id="1fc4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们都知道宁滨问题是NP——确切地说是NP难的。如果这个问题也描述了创建软件的一个潜在问题呢？我想探讨这样一个观点，即装箱是研究导致代码复杂性的一些问题的一个很好的模型。这将需要硬数学和软类比的混合(硬是指“明确”，而不是困难)。这很危险，我欢迎评论区的任何反对意见。</p><p id="dae3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，从<a class="ae ln" href="https://www.geeksforgeeks.org/bin-packing-problem-minimize-number-of-used-bins/" rel="noopener ugc nofollow" target="_blank">geeksforgeeks.org</a>快速总结一下箱柜包装问题:</p><blockquote class="lo lp lq"><p id="2e59" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">给定不同重量的<code class="fe lv lw lx ly b">n</code>件物品和每个容量为<code class="fe lv lw lx ly b">c</code>的箱子，将每件物品分配到一个箱子中，以使使用的箱子总数最少。可以假设所有物品的重量都小于箱柜容量。”</p></blockquote><p id="e3fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的，我们有几个变量来进行类比。</p><ol class=""><li id="0020" class="lz ma iq kt b ku kv kx ky la mb le mc li md lm me mf mg mh bi translated"><code class="fe lv lw lx ly b">W</code>:从<code class="fe lv lw lx ly b">1…N</code>开始需要装箱的砝码组。以至于<code class="fe lv lw lx ly b">∑ W = w₁+w₂ + … + wₙ</code>。</li><li id="e113" class="lz ma iq kt b ku mi kx mj la mk le ml li mm lm me mf mg mh bi translated"><code class="fe lv lw lx ly b">c</code>:每个仓的容量。</li></ol><p id="b23c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，让我们从假设创建我们的系统所需的最少代码量开始。这在问题中表现为<em class="lr"> </em> <code class="fe lv lw lx ly b"><em class="lr">∑ W</em></code> <em class="lr">。</em>让我们称之为箱柜模块。这可以保持非常通用。一个模块可能是微服务架构中的一个服务，一个<code class="fe lv lw lx ly b">Actor</code>(有点像微服务)，一个OOP系统中的一个类，或者可能是一个大类(一个集合了许多小类来完成一个大目标的类)。</p><p id="bcde" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着任何模块的增长，其内部复杂性也在增长，因此我们希望限制其大小。这个模块大小的限制是我们的变量<code class="fe lv lw lx ly b">c</code>，因为我们已经用bin标识了模块。</p><p id="bb83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">原则上，一个模块可以与任何其他模块通信。因此，这些潜在交互的复杂性是<code class="fe lv lw lx ly b">O(n!)</code>。</p><p id="98e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这留下了组成模块的更小的代码片段。这些是我们的小<code class="fe lv lw lx ly b">w</code>(<code class="fe lv lw lx ly b">w₁</code>到<code class="fe lv lw lx ly b">wₙ</code>)。所以现在我们有了下面的模型。</p><ol class=""><li id="6057" class="lz ma iq kt b ku kv kx ky la mb le mc li md lm me mf mg mh bi translated">一个程序是其所有模块的总和，在变得太大和复杂之前，这些模块的大小受到<code class="fe lv lw lx ly b">c</code>的限制。</li><li id="933b" class="lz ma iq kt b ku mi kx mj la mk le ml li mm lm me mf mg mh bi translated">模块的子组件增加了模块的复杂性。</li><li id="fe93" class="lz ma iq kt b ku mi kx mj la mk le ml li mm lm me mf mg mh bi translated">如果一个模块的复杂度大于<code class="fe lv lw lx ly b">c</code>，它必须被分解成更小的模块。</li><li id="846a" class="lz ma iq kt b ku mi kx mj la mk le ml li mm lm me mf mg mh bi translated">模块越多，模块之间潜在的交互就越多。以因子的方式增加架构的复杂性。</li></ol><p id="23e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们接受这些假设，我们就把代码复杂性的问题映射到装箱问题上了。我们必须得出结论，设计一个最优的简单软件系统是NP问题。</p><p id="b1a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">显而易见，软件设计是困难的。你怀疑这一点，但现在你有数学来支持你的怀疑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/0f1a70a5066e0ca91925a077e34f519d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MAu8VedhyXahoqL3fy2I2g.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">照片由<a class="ae ln" href="https://unsplash.com/@gvz42?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> GVZ 42 </a>在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄|图片被裁剪</p></figure><h1 id="4464" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">那又怎样？</h1><p id="ae47" class="pw-post-body-paragraph kr ks iq kt b ku nk jr kw kx nl ju kz la nm lc ld le nn lg lh li no lk ll lm ij bi translated">我们可以用宁滨问题来描述软件设计的问题。然后呢。我们当然不能用宁滨算法来设计我们的软件，那么这是怎么回事呢？</p><p id="546b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">再看看上面我们做的工作。我们将复杂度分为模块间复杂度和模块内复杂度。我们还表明，这两种类型的复杂性是相互矛盾的。</p><p id="36f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了降低模块内部的复杂性，我们可以通过缩小模块来简化我们的模块(减少<code class="fe lv lw lx ly b">c</code>)。然而，模块的数量随之增加。如果我们增加我们的模块大小(增加<code class="fe lv lw lx ly b">c</code>，我们得到相反的效果。</p><p id="b9eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">透过这个镜头来看系统设计，我们可以根据它们平衡这两个约束的程度来评估我们的设计决策。虽然这并没有涵盖系统设计的所有考虑因素，但它是一个必不可少的组成部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi np"><img src="../Images/82a4f18824367eb0c70e128ffde36f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WDA3N0fPxGFu6iQZ"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Stephen Kraakmo 在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e873" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个镜头也告诉我们，我们应该警惕像坚实的原则这样的东西。将五条规则机械地应用到我们的设计中，不太可能产生令人满意的复杂性平衡的最佳解决方案。这并不是说他们不能成为像样的向导，而是过滤你两耳之间的一切。</p><h1 id="697b" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">应用模型</h1><p id="55be" class="pw-post-body-paragraph kr ks iq kt b ku nk jr kw kx nl ju kz la nm lc ld le nn lg lh li no lk ll lm ij bi translated">为了简单起见，让我们把上面的一切都称为“模型”我们可以看看不同的软件开发实践，看看他们如何试图处理模块内和模块间复杂性之间的紧张关系。这将是探索模型的一个健康的最后练习。</p><h2 id="53d2" class="nq mt iq bd mu nr ns dn my nt nu dp nc la nv nw ne le nx ny ng li nz oa ni ob bi translated"><strong class="ak">独石和模型</strong></h2><p id="7c64" class="pw-post-body-paragraph kr ks iq kt b ku nk jr kw kx nl ju kz la nm lc ld le nn lg lh li no lk ll lm ij bi translated">单一的程序通常让人想起设计糟糕的旧程序。这种刻板印象甚至可能是真的。如果在谈论软件变更时，人们会提到某个功能或类的名字，那么你的公司可能是一个庞然大物。</p><p id="62c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们从模型的角度来审视独石时，我们看到它们是降低某种复杂性的一种方法。单片电路以模块内的复杂性为代价来减少模块的数量。按照模型的变量来说，独石使得<code class="fe lv lw lx ly b">c</code>的值非常大。原则上，如果<code class="fe lv lw lx ly b">c &gt; ∑ W</code>，只有一个模块，装箱问题消失。你不必担心模块之间是如何相互作用的，但是理解一个模块的内部工作方式几乎是不可能的。</p><p id="fd6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能真的写了独石。我写的大多数内部实用程序都没有考虑软件架构，因为代码总量很小，复杂性无关紧要。</p><h2 id="a007" class="nq mt iq bd mu nr ns dn my nt nu dp nc la nv nw ne le nx ny ng li nz oa ni ob bi translated">微服务和模型</h2><p id="478d" class="pw-post-body-paragraph kr ks iq kt b ku nk jr kw kx nl ju kz la nm lc ld le nn lg lh li no lk ll lm ij bi translated">微服务采取与Monoliths相反的策略。它们保持你的c值很小，以减少模块内部的复杂性，同时让模块的数量变得很大。这似乎是一场灾难。正如我们在模型描述中所述，模块通信的复杂性随着模块数量的增加而增加。微服务通常有限制这种损害的规则。例如:</p><blockquote class="lo lp lq"><p id="ecd4" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">微服务可以回答内部或外部的请求。</p><p id="d19a" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">回答内部请求的微服务可能不会向其他微服务发出请求。</p><p id="acbc" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">回答外部请求的微服务可能只向处理内部请求的微服务发出请求。</p></blockquote><p id="4639" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你能遵循这个约束，它确实限制了你的模块级复杂度。给定<code class="fe lv lw lx ly b">N</code>模块，你有内部或外部类型的模块。如果我们称这两组为<code class="fe lv lw lx ly b">i</code>和<code class="fe lv lw lx ly b">e</code>，那么<code class="fe lv lw lx ly b">N = i+e</code>。交互次数限制为<code class="fe lv lw lx ly b">i </code>乘以<code class="fe lv lw lx ly b">e</code>。由于<code class="fe lv lw lx ly b">i</code>和<code class="fe lv lw lx ly b">e</code>必须小于<code class="fe lv lw lx ly b">N</code>，那么你的模块级复杂度以<code class="fe lv lw lx ly b">N²</code>而不是<code class="fe lv lw lx ly b">N!</code>的速率增长。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oc"><img src="../Images/44bb55eff983d1f3b45595cb6fe1a8fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qhGlCETmL-tg_IDd"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">照片由<a class="ae ln" href="https://unsplash.com/@yassine_khalfalli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yassine Khalfalli </a>在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="2a33" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">结论</h1><p id="98df" class="pw-post-body-paragraph kr ks iq kt b ku nk jr kw kx nl ju kz la nm lc ld le nn lg lh li no lk ll lm ij bi translated">这篇文章是实验性地写的。我想尝试证明软件设计从根本上来说是很难使用离散数学的。你可以决定我是否成功。然而，我有信心，我已经证明了离散数学可以用来获得对软件设计和架构的洞察力。这是我希望将来再次探讨的话题。</p><p id="e40d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想听更多我对软件设计的想法，请看看我关于<a class="ae ln" href="https://medium.com/codex/legacy-code-2cb94a33dcd0" rel="noopener">遗产代码</a>的一篇读得很少的文章。</p><p id="86d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">再次感谢您的阅读。</p></div></div>    
</body>
</html>