<html>
<head>
<title>You Are Doing SQL Pagination Wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你做错了SQL分页</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/you-are-doing-sql-pagination-wrong-739a700acbd0?source=collection_archive---------1-----------------------#2022-05-09">https://betterprogramming.pub/you-are-doing-sql-pagination-wrong-739a700acbd0?source=collection_archive---------1-----------------------#2022-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">几乎所有使用SQL的应用程序都陷入了这个常见的性能陷阱。现在就避开！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39cddea241d733bd1b47d602683a44a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etQWZrC4R0Gon5Ullo-Xhg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谷歌底部分页部件</p></figure><p id="5789" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个应用程序在其早期阶段都会面临这些问题:您必须限制发送给客户端的请求数据量，以防止服务质量下降。我们发现这种模式无处不在:</p><p id="2cc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">微妙的部分变成了“我们如何实现这个解决方案？”。</p><p id="9804" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在这里看一个简单的用例，用1000000行的表对象进行分页。我们正在考虑两种不同的分页情况:一种是按照惟一的主键id，另一种是按照租户名称(带有索引的varchar字段)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/c1a847afc16065ccf79536c48a0cc63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vaaKJTqyTvYuzFAez4xSuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对象表描述—使用mariadb 10.5.8</p></figure><h1 id="a3f4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">天真的实现</h1><p id="8314" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">最简单的分页方法是使用<code class="fe mt mu mv mw b">LIMIT</code>和<code class="fe mt mu mv mw b">OFFSET</code> <em class="mx">，在互联网上随处可见<a class="ae ms" href="https://www.ibm.com/support/pages/how-use-sql-pagination-using-limit-and-offset" rel="noopener ugc nofollow" target="_blank"/>。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/dd606d72826f2f5d9f664c77b3665023.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*OKHZveUZAMJmyI8eL7LbUQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">偏移分页查询示例</p></figure><p id="4150" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们针对两个索引列(<code class="fe mt mu mv mw b">id</code>和<code class="fe mt mu mv mw b">tenant</code>)，针对不同的<code class="fe mt mu mv mw b">OFFSET</code>值，尝试这个查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/b0bd0aea91e64cad05a6c837c6c3202d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*CfaZUop4uubmp_xRAsvDwg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同偏移值的分页响应时间</p></figure><p id="ceb8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们检查分页查询的数据库优化器查询计划时:我们注意到数据库使用文件排序操作对非索引列进行排序，并对租户和id列使用索引。基于此，我们可以得出结论:</p><ol class=""><li id="3450" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">对非索引排序列使用offset对数据库来说是一项繁重的任务，必须不惜一切代价避免。</li></ol><blockquote class="nj nk nl"><p id="b0d4" class="ky kz mx la b lb lc ju ld le lf jx lg nm li lj lk nn lm ln lo no lq lr ls lt im bi translated"><em class="it"> MySQL必须进行额外的传递，以找出如何按排序顺序检索行。排序是通过根据连接类型遍历所有行，并为匹配</em> <code class="fe mt mu mv mw b"><em class="it">WHERE</em></code> <em class="it">子句的所有行存储排序关键字和指向该行的指针来完成的。</em></p></blockquote><p id="d965" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.使用<code class="fe mt mu mv mw b">OFFSET</code>，即使是在主键上，对于高数据库容量来说，随着时间的推移会变得越来越慢，因为为了跳过而需要加载的行数变得越来越多。</p><p id="9da4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.在带有大<code class="fe mt mu mv mw b">key_length</code>的索引字段上使用偏移量比在小<code class="fe mt mu mv mw b">key_length</code>字段上慢。</p><p id="f855" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，<code class="fe mt mu mv mw b">OFFSET</code>分页有一些缺点:</p><ul class=""><li id="c63c" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt np ng nh ni bi translated">对于较大的数据库容量，结束页比开始页更难检索，因为要加载和跳过的行数很大。</li><li id="cc4e" class="na nb it la b lb nq le nr lh ns ll nt lp nu lt np ng nh ni bi translated">对于不断增长的数据库，随着时间的推移，到达起始行的效率会越来越低。(4，54s或160s的查询对于拥有数千用户的网站变得不可用)</li><li id="3151" class="na nb it la b lb nq le nr lh ns ll nt lp nu lt np ng nh ni bi translated">当用户从一页滚动到另一页时，如果插入一行，根据列的排序，用户可能会错过一个新项目，并看到一个重复的对象(上一页的最后一个项目)。</li></ul><p id="e1bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于在项目开始时实现<code class="fe mt mu mv mw b">OFFSET</code>分页很方便(您不必预测查询计划、UI排序用例以及索引创建)，所以经常会看到应用程序性能缓慢下降，随着时间的推移变得不可用。然而，由于指定<code class="fe mt mu mv mw b">OFFSET</code>的方式，数据库必须迭代所有的<code class="fe mt mu mv mw b">OFFSET</code>行，这使得这个解决方案非常低效。</p><h1 id="8fde" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Seek方法分页</h1><p id="24ac" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如前所述，即使我们尝试使用索引，<code class="fe mt mu mv mw b">OFFSET</code>也会使效率低下，因为必须加载所有相关的行，我们将不得不构建一个使用索引的查询来检索我们的目标页面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d2ca8e9af383f3cde5516512e4dad48b.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*NOJxMoVZztA7TnqSFF7uFw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索分页查询示例</p></figure><p id="3339" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看这个查询在迭代最后一次看到的<code class="fe mt mu mv mw b">id</code>T6时需要多长时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/434e06e605a5e2efdfc6b8e04763fff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*-z1GzniUGht0Re9iLRkhog.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索分页查询响应时间</p></figure><p id="34d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果表明，我们在用例中获得了许多数量级的优势，使得响应查询时间对数据库大小的依赖性降低。然而，当移动到<strong class="la iu"> Seek pagination </strong>方法时，一些变化是值得注意的:</p><ul class=""><li id="941b" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt np ng nh ni bi translated">我们不能再依赖页码UI行为，因为我们现在依赖一个令牌来返回给应用程序以获取下一页(上一页的最后一个id)。</li><li id="7e6e" class="na nb it la b lb nq le nr lh ns ll nt lp nu lt np ng nh ni bi translated">我们必须考虑哪一列将用于分页，因为我们需要相应的索引。</li><li id="b287" class="na nb it la b lb nq le nr lh ns ll nt lp nu lt np ng nh ni bi translated">如果我们希望按非唯一列排序，我们必须创建多列索引(使用主键作为其中一列)并调整我们的查询，以便按照我们的索引导航:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/21e6b7d2c01ce92e0d7f081d773d4497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkppuWWenrG70HFyK8Dy2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于搜索分页的多列索引</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/269645f0f4105201c03828ffcbbf6a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*MagADFsPMwNyoH4gD9Z9Kg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">寻找多列索引分页查询</p></figure><p id="1634" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种解决方案使分页非常有效，但增加了开发的复杂性:我们需要考虑分页和数据库模式中允许的排序列。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="3d63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常在软件工程中，性能是一个权衡。</p><p id="625d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们已经看到了如何在性能非常关键的情况下，在SQL数据库中使用<code class="fe mt mu mv mw b">OFFSET</code>分页。</p><p id="a258" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">seek方法提供了一种与SQL供应商无关的最快的数据分页方式，但代价是增加了一点复杂性并损失了一些功能。</p></div></div>    
</body>
</html>