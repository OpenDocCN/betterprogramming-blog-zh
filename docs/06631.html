<html>
<head>
<title>Angular Testing Series: Why Your Angular Tests Probably Smell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度测试系列:为什么你的角度测试可能有味道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-testing-series-why-your-angular-tests-probably-smell-ebab93c59e0?source=collection_archive---------5-----------------------#2020-10-20">https://betterprogramming.pub/angular-testing-series-why-your-angular-tests-probably-smell-ebab93c59e0?source=collection_archive---------5-----------------------#2020-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="49b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">测试角度项目时遇到的常见陷阱</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7f2eb1bb0754a25250e7ce3a5a3602df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4nE9TCy8pU2VG3g4YXlJQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@aaronburden?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚伦·伯顿</a>在<a class="ae kv" href="https://unsplash.com/s/photos/relax?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="5dfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试角度应用本来就很简单。Angular框架是从头开始构建的，所以它们的抽象很容易测试。默认的松散架构，将逻辑分割成组件、指令、服务、模块或管道——所有这些都在测试过程中极大地帮助了我们。如果我们遵循经过验证的模式，并产生真正可测试的代码，测试就不应该是一件麻烦的事情——它应该是促进可靠代码开发的事情。</p><h2 id="590e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">你永远不会独行</h2><p id="5cf4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">此外，Angular并没有让我们在战场上孤军奋战——它为我们提供了一套强大的工具来简化和加速编写测试。</p><p id="9cf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为Angular用户，彻底学习这些工具是我们的责任。在这个Angular Testing系列文章中，我将基于准备好的例子，展示Angular中内置单元测试机制的典型和正确的用法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/cb7bddccf195b984f94650b81887ba9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*oUXa5poUvq936fSUkNcpkA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">兰迪·法特在<a class="ae kv" href="https://unsplash.com/s/photos/team?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="edf4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">不良测试习惯</h2><p id="cfb2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">坏习惯往往来自诱惑。我注意到我们(开发人员)也经常屈服于一种诱惑:<em class="mr">为单元测试复制代码</em>。这项技术有两个方面:</p><ul class=""><li id="23c8" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><em class="mr">我们可以坚持一致的测试方式，提高我们的生产力并带来价值。</em></li></ul><p id="8684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，如果我们不知道我们实际复制的是什么:</p><ul class=""><li id="3f12" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">在项目的所有测试中，我们可以为涂抹有异味的代码片段做出贡献。</li></ul><p id="59cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我想把重点放在我在各种Angular项目中遇到的单元测试中那些发臭的代码片段上。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="29d7" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">组件测试</h1><p id="bb4f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们假设这是我们正在测试的组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bb90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想要验证<code class="fe nv nw nx ny b">Full Names</code>是否被渲染到<code class="fe nv nw nx ny b">&lt;header&gt;</code>标签中。让我们来看看下面的测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b6b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们运行<code class="fe nv nw nx ny b">jest</code>时，一切正常:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/cfbfdd083f957bf40d708edcd4cf72cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*GYJ1Y-RpeduP_QOJPA8yRg.png"/></div></figure><p id="bd7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有东西闻起来——你能说出是什么吗？</p><p id="bf80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看最后一次测试，看看那里发生了什么。调用<code class="fe nv nw nx ny b">ngOnInit</code>，在<code class="fe nv nw nx ny b">fixture</code>中模拟变化检测，当夹具模板准备好时进行断言。显然，一切都很好，但这是对事实的歪曲，是对组件生命周期的糟糕模拟。在这个例子中，一切都会如预期的那样进行。然而，方法<code class="fe nv nw nx ny b">ngOnInit</code>被调用了两次。变化检测也被再执行一次。</p><h2 id="5160" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">应该怎么处理？</h2><p id="182a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了让我们的测试反映现实，我们应该做些什么来摆脱<code class="fe nv nw nx ny b">ngOnInit</code>调用？实例化的<code class="fe nv nw nx ny b">fixture:ComponentFixture&lt;AppComponent&gt;</code>有适当的职责，当我们调用它的<code class="fe nv nw nx ny b">detectChanges</code>方法时，我们可以相信单个组件生命周期方法会自动执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c9d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的主旨里，我又改了一点。<code class="fe nv nw nx ny b">async</code>功能被替换为<code class="fe nv nw nx ny b">waitForAsync</code>。为什么？因为在Angular 10中，<code class="fe nv nw nx ny b">async</code>函数最终被标记为不推荐使用，我们可以预计在Angular 12中我们根本看不到它。</p><h2 id="b1ff" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">不关心测试中的渲染</h2><p id="3246" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们经常发现并编写组件测试，其中检查DOM中是否生成了实际值并不重要。这种方法是好是坏只取决于你的测试结果和目标，但是我想提一下与这种类型的测试相关的另一个常见错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6f21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们只想验证字段<code class="fe nv nw nx ny b">title</code>是否分配了期望值。看起来一切都很好，测试本身是确定性的，但是所提出的解决方案有些问题。</p><p id="4f6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，<code class="fe nv nw nx ny b">fixture</code>用生成的DOM模型反映模板。在上面的测试中，我们不检查DOM中的任何内容。真的值得用资源去创造<code class="fe nv nw nx ny b">fixture</code>吗？这是隔离测试的一个典型例子。如果收集在<code class="fe nv nw nx ny b">spec</code>集合中的所有测试都是隔离的，那么整个<code class="fe nv nw nx ny b">spec</code>都应该被实现，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="ca41" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">在独立测试中，我们必须记住调用适当的生命周期方法，比如<code class="fe nv nw nx ny b">ngOnInit</code></li><li id="d9e6" class="ms mt iq ky b kz oa lc ob lf oc lj od ln oe lr mx my mz na bi translated">使用<code class="fe nv nw nx ny b">ComponentFixture</code>的孤立测试明显比浅层测试快。即使对于这样简单的测试，资源使用和总测试时间的差异也是显著的。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/911330efb0a5c87efe1c7d08dd65a1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*uyDT_032HLTMQ-h4gQe9hg.png"/></div></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="eb69" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">异步服务和事件</h1><p id="1d50" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在Angular的项目开发中，我们大部分时间都在处理异步操作。XHR请求、渲染/浏览器事件的处理、用户输入的去抖都是异步任务，所以测试应该适当地处理它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/53f8791aaf47f87cb05e4ad9dce4ac4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvoOP_fhRWToiVIhC1BH1g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@harryxsandhu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈里·桑德胡</a>在<a class="ae kv" href="https://unsplash.com/@harryxsandhu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3d74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用一个简单的服务来分析这个示例场景，这个服务以xhr的形式获取数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c424" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">智能域组件<code class="fe nv nw nx ny b">FullNameListComponent</code>使用上述服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4fe3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想要测试<code class="fe nv nw nx ny b">fullNames$</code>流。这一次，我们使用<code class="fe nv nw nx ny b">ComponentFixture</code>，因为这是向Angular DI提供存根的一种便捷方式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9185" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个基本测试如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试通过了。可以吗？显然，不是！为了找出我稍微修改第二个测试的原因:</p><pre class="kg kh ki kj gt oh ny oi oj aw ok bi"><span id="11c8" class="ls lt iq ny b gy ol om l on oo">it('should fullNames be triggered on name change', () =&gt; {<br/>  const expectedFullNames = <em class="mr">FAKE_NAMES</em>;<br/><br/>  component.fullNames$.subscribe((fullNames) =&gt; {<br/>    expect(fullNames).toEqual(<strong class="ny ir">null</strong>);<br/>  });<br/><br/>  component.name = 'John';<br/>});</span></pre><p id="5cd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我修改了断言，期望<code class="fe nv nw nx ny b">fullNames</code>为<code class="fe nv nw nx ny b">null</code>，这是不正确的。测试仍然通过。怎么了?</p><h2 id="2930" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">fakeAsync求助</h2><p id="56c2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">除了所谓的<code class="fe nv nw nx ny b">subscribe-assert</code>不是我们可以用于流测试的最佳方法这一事实之外，我们经常忘记一件事。如果流异步运行，测试应该考虑这个事实。幸运的是，Angular为我们提供了有用的工具:一个特殊的<code class="fe nv nw nx ny b">fakeAsync</code>区域。</p><pre class="kg kh ki kj gt oh ny oi oj aw ok bi"><span id="ee31" class="ls lt iq ny b gy ol om l on oo">it('should fullNames be triggered on name change', fakeAsync(() =&gt; {<br/>  const expectedFullNames = <strong class="ny ir"><em class="mr">FAKE_NAMES</em></strong>;<br/><br/>  component.fullNames$.subscribe((fullNames) =&gt; {<br/>    expect(fullNames).toEqual(null);<br/>  });<br/><br/>  component.name = 'John';<br/>  tick();<br/>}));</span></pre><p id="9a50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，测试运行人员能够识别出断言是不正确的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/7a84f16e92db0a187baaa4ad00557f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjPSErydpqX8HGcKjCa7Fw.png"/></div></div></figure><p id="48f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不想在这里解释<code class="fe nv nw nx ny b">fakeAsync</code>到底是什么，因为这不是本文的目的。然而，我们必须永远记住，如果我们处理异步，那么我们也应该在测试中考虑它。</p><p id="4380" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的测试方法还有一个很臭的东西。让我们看看我们的存根:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们模拟用假数据返回<code class="fe nv nw nx ny b">Observable</code>。这是一种流行的方法，但它正确吗？一点也不。</p><p id="729d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我这里指的是<a class="oq or ep" href="https://medium.com/u/b889ae02aa26?source=post_page-----ebab93c59e0--------------------------------" rel="noopener" target="_blank"> Netanel Basal </a>的一篇很好的<a class="ae kv" href="https://netbasal.com/testing-observables-in-angular-a2dbbfaf5329" rel="noopener ugc nofollow" target="_blank">文章</a>。他很好地解释了为什么<code class="fe nv nw nx ny b">of</code>不是用来伪造API响应的合适函数。</p><p id="071e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，<code class="fe nv nw nx ny b">of</code>函数提供同步数据，而对XHR的响应是异步的，被视为宏任务。用同步调用伪造异步数据是欺骗，而且很糟糕。它增加了代码覆盖率，但是这种测试的质量是有问题的。</p><p id="fb43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于为<code class="fe nv nw nx ny b">of</code>函数提供一个合适的调度器是不可取的，我推荐以下方法:</p><pre class="kg kh ki kj gt oh ny oi oj aw ok bi"><span id="2145" class="ls lt iq ny b gy ol om l on oo">import { <strong class="ny ir"><em class="mr">asyncScheduler</em></strong>, Observable, scheduled } from 'rxjs';</span><span id="6251" class="ls lt iq ny b gy os om l on oo">getFullNames(name: string): Observable&lt;FullName[]&gt; {<br/>  return scheduled([<strong class="ny ir"><em class="mr">FAKE_NAMES</em></strong>], <strong class="ny ir"><em class="mr">asyncScheduler</em></strong>);<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/0dd1e1e5893d18bc6aeff6730642ed02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NjubR0EEZl9wTpicqtpaQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/s/photos/island?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@j_cobnasyr1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> jcob nasyr </a>拍摄</p></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="0363" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">摘要</h1><p id="d383" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如何在测试中避免此类事故:</p><ul class=""><li id="5eb6" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">尝试遵循红/绿/重构技术。如果你不使用TDD方法，试着故意让你的测试失败。</li><li id="3dab" class="ms mt iq ky b kz oa lc ob lf oc lj od ln oe lr mx my mz na bi translated">查看并了解Angular给我们的两个特性:<code class="fe nv nw nx ny b"><a class="ae kv" href="https://angular.io/api/core/testing/waitForAsync" rel="noopener ugc nofollow" target="_blank">waitForAsync</a></code>和<code class="fe nv nw nx ny b"><a class="ae kv" href="https://angular.io/api/core/testing/fakeAsync" rel="noopener ugc nofollow" target="_blank">fakeAsync</a></code>。要意识到它们之间的区别。</li><li id="b043" class="ms mt iq ky b kz oa lc ob lf oc lj od ln oe lr mx my mz na bi translated">不要用<code class="fe nv nw nx ny b">of</code>伪造数据。在大多数情况下，你不会注意到任何差异。但是，有一个框架黑客。信任提供的<code class="fe nv nw nx ny b">fakeAsync</code>区域来模拟同步执行。</li><li id="cf98" class="ms mt iq ky b kz oa lc ob lf oc lj od ln oe lr mx my mz na bi translated">所有的例子都收集在我的Github上的<a class="ae kv" href="https://github.com/marcinmilewicz/angular-testing" rel="noopener ugc nofollow" target="_blank">库</a>中。</li></ul></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="3227" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">角度测试系列</h1><p id="7ca6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="mr">本文是角度测试系列的一部分，该系列收集了在角度框架中进行测试的有用技巧。我将非常感谢您的反馈。请不要犹豫，留下你喜欢或不喜欢的评论。</em></p><p id="b058" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mr">如果您能告诉我您对角度测试的恐惧是什么，我将不胜感激。我将很乐意准备一个务实的解决方案，并协助你。</em></p></div></div>    
</body>
</html>