<html>
<head>
<title>Clean Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净的班级</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-classes-43b46da37f39?source=collection_archive---------5-----------------------#2019-10-09">https://betterprogramming.pub/clean-classes-43b46da37f39?source=collection_archive---------5-----------------------#2019-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6858" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"># 100日代码的第22天</h2><div class=""/><div class=""><h2 id="44fe" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">应该和哎呀一起教的东西</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7944ba7f03db82b273dc3d94e7fb03cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kz8UCvlScrM3JyaHNOqygg.png"/></div></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="6e25" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">Clean Code系列进展非常顺利！我们已经了解了如何编写代码行和代码块，如何编写函数，以及如何实现模块化。</p><p id="b567" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">所有这些代码块组合在一起形成了更高级别的代码组织，我们称之为<strong class="lh jd">类</strong>。</p><pre class="ks kt ku kv gt mb mc md me aw mf bi"><span id="844c" class="mg mh it mc b gy mi mj l mk ml">// Structuring a Standard Java Class</span><span id="02ad" class="mg mh it mc b gy mm mj l mk ml">public class ClassName {<br/>  <br/>  // Static constants</span><span id="58a5" class="mg mh it mc b gy mm mj l mk ml">  // Static variables</span><span id="7262" class="mg mh it mc b gy mm mj l mk ml">  // Private constants</span><span id="6701" class="mg mh it mc b gy mm mj l mk ml">  // Private instance variables</span><span id="3416" class="mg mh it mc b gy mm mj l mk ml">  // Public functions()</span><span id="a56f" class="mg mh it mc b gy mm mj l mk ml">  // Private utilities functions()</span><span id="d2ed" class="mg mh it mc b gy mm mj l mk ml">}</span></pre><p id="809c" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们希望尽可能保持我们的功能“私密”，但是<em class="mn">并不意味着每次都这样！我们有时希望我们的功能可以通过测试来访问。我们使用这些访问修饰符来实现封装。为了让测试可以访问你的函数而放弃封装应该是最后的选择。</em></p><h2 id="ca6c" class="mg mh it bd mo mp mq dn mr ms mt dp mu lo mv mw mx ls my mz na lw nb nc nd iz bi translated"><strong class="ak">写作课的两条规则</strong></h2><p id="1d17" class="pw-post-body-paragraph lf lg it lh b li ne kd lk ll nf kg ln lo ng lq lr ls nh lu lv lw ni ly lz ma im bi translated">1.班级要小<br/> 2。班级应该比那个小！</p><p id="dde7" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在编写类时，较小是主要的规则，而在函数中，我们追求“多小？”</p><p id="1f4e" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们通过<strong class="lh jd"> <em class="mn">行数</em> </strong>来衡量功能，而我们通过<strong class="lh jd"> <em class="mn">职责数</em> </strong>来衡量<strong class="lh jd"> <em class="mn">类</em> </strong>。</p><p id="f124" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们还应该能够用25个字左右的篇幅写一篇关于这门课的简短描述，不要使用“如果”“但是”之类的词语。</p><p id="53f6" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们看一个例子:</p><pre class="ks kt ku kv gt mb mc md me aw mf bi"><span id="df22" class="mg mh it mc b gy mi mj l mk ml">public class GodClass extends JFrame implements MetaDataUser{<br/>    <br/>    public Component getLastFocusedComponent()<br/>    <br/>    public void setLastFocused(Component lastFocused)<br/>    <br/>    public int getMajorVersionNumber()<br/>    <br/>    public int getMinorVersionNumber()<br/>    <br/>    public int getBuildNumber()</span><span id="9bb1" class="mg mh it mc b gy mm mj l mk ml">}</span></pre><p id="6a5a" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这个班级看起来很小，但是有不同的职责:管理焦点和获得构建号。</p><h2 id="8bed" class="mg mh it bd mo mp mq dn mr ms mt dp mu lo mv mw mx ls my mz na lw nb nc nd iz bi translated"><strong class="ak">还记得SRP——单一责任原则吗？</strong></h2><p id="d8df" class="pw-post-body-paragraph lf lg it lh b li ne kd lk ll nf kg ln lo ng lq lr ls nh lu lv lw ni ly lz ma im bi translated">类或模块应该只有一个责任——一个改变的理由。SRP是面向对象设计中比较重要的概念之一。这也是理解和坚持的更简单的概念之一。</p><p id="fde9" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">然而奇怪的是，SRP经常是最被滥用的类设计原则，因为<em class="mn">让软件工作和让软件干净是两个非常不同的活动。</em></p><p id="b21d" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">不管怎样，让我们把这个类分成两个独立的类:</p><pre class="ks kt ku kv gt mb mc md me aw mf bi"><span id="c132" class="mg mh it mc b gy mi mj l mk ml">public class Version {<br/>    <br/>    public int getMajorVersionNumber()<br/>    <br/>    public int getMinorVersionNumber()<br/>    <br/>    public int getBuildNumber()</span><span id="042c" class="mg mh it mc b gy mm mj l mk ml">}</span></pre><p id="336b" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">另一个…</p><pre class="ks kt ku kv gt mb mc md me aw mf bi"><span id="4469" class="mg mh it mc b gy mi mj l mk ml">public class FocusedComponent {</span><span id="39bc" class="mg mh it mc b gy mm mj l mk ml">public Component getLastFocusedComponent()</span><span id="3f72" class="mg mh it mc b gy mm mj l mk ml">public void setLastFocused(Component lastFocused)<br/>    <br/>}</span></pre><p id="36d9" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">那里！看起来又干净又小巧！</p><p id="0474" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">问题在于，当程序运行时，我们中有太多的人认为我们已经完成了。我们没有转移到另一个关注点:组织和清洁。 </p><p id="def1" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们继续处理下一个问题，而不是回到过去，把过多的类分解成具有单一职责的独立单元。 </p><p id="cacf" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jd"> <em class="mn">你想把你的工具整理到有很多小抽屉的工具箱里，每个抽屉里都装着定义明确、标签明确的组件吗？还是想要几个抽屉，把所有东西都放进去？</em> </strong></p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="9aea" class="nq mh it bd mo nr ns nt mr nu nv nw mu ki nx kj mx kl ny km na ko nz kp nd oa bi translated">内聚力</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/782ea920bc6a73fce16a1d6c0be4f09a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lumli6LRHbIEg_sS"/></div></div></figure><p id="59c0" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们的类中会有实例变量，也会有函数来操作这些实例变量。一个方法处理的变量越多，这个方法对类的凝聚力就越强。</p><p id="3c0b" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">一个每个实例变量都被每个方法操作的类是<em class="mn">最大内聚的。</em>因此，内聚性只是变量和方法在逻辑上相互关联程度的一种度量。</p><p id="dc76" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">当内聚性很高时，意味着类的方法和变量是相互依赖的，并且作为一个逻辑整体挂在一起。</p><p id="8b5f" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mn">衔接越好，程序设计越好。</em></p><pre class="ks kt ku kv gt mb mc md me aw mf bi"><span id="143f" class="mg mh it mc b gy mi mj l mk ml">public class Stack {<br/>    <br/>    private int topOfStack = 0;</span><span id="9e9f" class="mg mh it mc b gy mm mj l mk ml">    List&lt;Integer&gt; elements = new LinkedList&lt;Integer&gt;();<br/>    <br/>    public int size() { <br/>        return topOfStack;<br/>    }<br/>    <br/>    public void push(int element) { <br/>        topOfStack++; <br/>        elements.add(element);<br/>    }<br/>    <br/>    public int pop() throws PoppedWhenEmpty { if (topOfStack == 0)<br/>        throw new PoppedWhenEmpty();<br/>        int element = elements.get(--topOfStack); <br/>        elements.remove(topOfStack);<br/>        return element;<br/>    }</span><span id="861c" class="mg mh it mc b gy mm mj l mk ml">}</span></pre><p id="5621" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在这个例子中，<code class="fe oc od oe mc b">push()</code>和<code class="fe oc od oe mc b">pop()</code>都在变异两个实例变量元素和<code class="fe oc od oe mc b">topOfStack</code>。因此它很有凝聚力。</p><p id="4673" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">保持内聚性需要将你的类分成许多更小的原子类。每当班级失去凝聚力时，那就是你分裂他们的暗示。</p><p id="087f" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">衔接有多种类型。</p><ul class=""><li id="faef" class="of og it lh b li lj ll lm lo oh ls oi lw oj ma ok ol om on bi translated"><strong class="lh jd">伴随内聚</strong>——无计划的、随机的，这是代码模块化的结果。因为它是无计划的，所以它是不可接受的，因为它会让程序员感到困惑。</li><li id="2ce7" class="of og it lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated"><strong class="lh jd">逻辑衔接</strong> —当你在一个模块中计划和放置逻辑相关的语句和指令。</li><li id="ea1c" class="of og it lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated"><strong class="lh jd">过程内聚</strong> —当一个模块的元素被放在一起执行一个任务时。</li><li id="b3f7" class="of og it lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated"><strong class="lh jd">通信内聚</strong> —当元素被分组在一起时，这些元素被顺序执行并对相同的数据进行操作。</li><li id="8412" class="of og it lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated"><strong class="lh jd">时态衔接</strong> —当元素被构造成在相似的时间点被处理时，它被称为时态衔接。</li><li id="e84c" class="of og it lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated"><strong class="lh jd">顺序衔接</strong>——当一个元素的输出作为下一个元素的输入，它们被组织在一起，这被称为顺序衔接。</li><li id="7e7d" class="of og it lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated"><strong class="lh jd">功能内聚</strong>——当元素有助于形成一个单一的明确定义的功能。</li></ul><p id="e037" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">有兴趣了解更多关于干净代码的知识吗？请务必查看之前撰写的关于干净代码的文章。</p><div class="ot ou gp gr ov ow"><a href="https://medium.com/swlh/what-is-clean-code-463d25fa6e0b" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">什么是干净代码？</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">编程课上没人教的东西</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk lb ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://medium.com/@devDeeJay/clean-code-give-meaning-to-your-code-to-exist-f966b3f00848" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">表达清晰的代码</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">用美丽的节目讲美丽的故事</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk lb ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://medium.com/@devDeeJay/dont-comment-your-code-rewrite-it-a145d655f87b" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">不要评论你的代码，重写它！</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">不要花时间写注释，花时间清理你的代码</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pm l ph pi pj pf pk lb ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://medium.com/@devDeeJay/writing-clean-code-to-avoid-pain-3217f89d81c6" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">编写干净的代码以避免痛苦</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">如何格式化你的代码和处理错误？</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pn l ph pi pj pf pk lb ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://medium.com/@devDeeJay/tests-are-your-silver-bullet-for-clean-production-code-60f339183713" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">测试是你清洁生产代码的银弹</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">TDD很酷，但是要知道如何专业地编写测试用例</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="po l ph pi pj pf pk lb ow"/></div></div></a></div><p id="3992" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jd"> <em class="mn">那是#100DaysOfCode </em> </strong>的第22天</p><p id="6a2a" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jd"> <em class="mn">记住，如果你想让这次学习物有所值:</em> </strong></p><ul class=""><li id="956f" class="of og it lh b li lj ll lm lo oh ls oi lw oj ma ok ol om on bi translated">勇往直前，运用你的知识，做点好事吧！ </li><li id="ef80" class="of og it lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated"><strong class="lh jd"> <em class="mn">把这个教给别人，然后再去学这个！</em> </strong></li><li id="1383" class="of og it lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated"><strong class="lh jd"> <em class="mn">把这篇文章分享给一个你认为应该学习更多干净代码的朋友</em> </strong></li></ul><p id="2ba5" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mn">感谢您的阅读，您一如既往地令人敬畏！</em></p></div></div>    
</body>
</html>