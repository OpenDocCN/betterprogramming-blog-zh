<html>
<head>
<title>Scaling Your Redux App with Ducks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用鸭子扩展你的Redux应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scaling-your-redux-app-with-ducks-6115955638be?source=collection_archive---------2-----------------------#2017-01-23">https://betterprogramming.pub/scaling-your-redux-app-with-ducks-6115955638be?source=collection_archive---------2-----------------------#2017-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">长期组织您的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/132b0723985551681089cce7eec2c146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uceu9f-p_A2H2-2xD-6MiQ.jpeg"/></div></div></figure><p id="6e4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的前端应用程序如何扩展？你如何确保你正在编写的代码在六个月后是可维护的？</p><p id="face" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="http://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>在2015年席卷了前端开发领域，并确立了自己的标准——甚至超出了React的范围。</p><p id="0a95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我工作的公司，我们最近完成了一个相当大的React代码库的重构，增加了Redux而不是<a class="ae lq" href="https://github.com/reflux/refluxjs" rel="noopener ugc nofollow" target="_blank">回流</a>。</p><p id="e0b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们这样做是因为如果没有一个结构良好的应用程序和一套好的规则，前进是不可能的。</p><p id="4fb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码库有两年多了，<code class="fe lr ls lt lu b">reflux</code> <em class="lv"> </em>从一开始就有了。我们不得不修改已经一年多没碰过的代码，这些代码与React组件纠缠在一起。</p><p id="8e73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基于我们在这个项目上所做的工作，我整理了这个报告，解释了我们组织Redux代码的方法。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="76f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您学习Redux以及actions和reducers的角色时，您会从非常简单的例子开始。今天大多数可用的教程不会进入下一个级别。但是如果你正在用Redux构建比任务列表更复杂的东西，你将需要一种更智能的方式来扩展你的代码库。</p><p id="3411" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有人曾经说过<em class="lv">命名事物</em>是计算机科学中最难的工作之一。我完全同意。但是构建文件夹和组织文件是第二位的。</p><p id="f2ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们探索一下过去我们是如何处理代码组织的。</p><h1 id="92ae" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">功能与特性</h1><p id="a745" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">有两种构建应用程序的既定方法:<em class="lv">功能优先</em>和<em class="lv">功能优先</em>。</p><p id="5ce8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在左下方，你可以看到一个功能优先的文件夹结构。在右边，你可以看到一个功能优先的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/0380e00f77c73cae50017c0253dd7076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HM8M2Agd_TBfU4Zm1_lEJA.png"/></div></div></figure><p id="d891" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">功能优先意味着你的顶层目录是根据里面文件的用途来命名的。所以你有:<em class="lv">容器</em>，<em class="lv">组件</em>，<em class="lv">动作</em>，<em class="lv">减速器</em>等。</p><p id="fe5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这根本不可扩展。随着应用的增长和功能的增加，文件也会添加到相同的文件夹中。所以你不得不在一个文件夹里滚动来找到你的文件。</p><p id="c8eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">问题还在于将文件夹耦合在一起。通过应用程序的单个流程可能需要所有文件夹中的文件。</p><p id="0c92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法的一个优点是它将React与Redux隔离开来。所以如果你想改变状态管理库，你知道你需要接触哪些文件夹。如果更改视图库，可以保持Redux文件夹不变。</p><p id="9e11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Feature-first是指顶级目录以app的主要特性命名:<em class="lv">产品</em>、<em class="lv">购物车</em>、<em class="lv">会话</em>。</p><p id="03db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法的伸缩性更好，因为每个新特性都有一个新的文件夹。但是React组件和Redux之间没有分离。从长远来看，改变其中一个是非常棘手的工作。</p><p id="806d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，您还有不属于任何功能的文件。您最终会得到一个名为<em class="lv"> common </em>或<em class="lv"> shared </em>的文件夹，因为您希望在应用程序的许多功能中重用代码。</p><h1 id="8854" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">两个世界中最好的</h1><p id="f815" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">虽然不在本文讨论范围之内，但我想接触一下这个单一的想法:<strong class="kw iu">永远把状态管理文件和UI文件分开。</strong></p><p id="8cb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从长远考虑你的应用。想象一下当您从<code class="fe lr ls lt lu b">React</code>切换到另一个库时，代码库会发生什么。或者想想你的代码库将如何在web版本中并行使用<code class="fe lr ls lt lu b">ReactNative</code>。</p><p id="6cba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://github.com/FortechRomania/react-redux-complete-example" rel="noopener ugc nofollow" target="_blank">我们的方法</a>从需要将React代码隔离到一个文件夹——称为视图——并将Redux代码隔离到一个单独的文件夹——称为Redux开始。</p><p id="d7fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一级别的划分给了我们完全不同地组织应用程序的两个独立部分的灵活性。</p><p id="ca8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在视图文件夹中，我们倾向于使用功能优先的方法来组织文件。这在React的上下文中感觉非常自然:<em class="lv">页面</em>、<em class="lv">布局</em>、<em class="lv">组件、增强器、</em>等等。</p><p id="b0c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了不被一个文件夹中的文件数量所困扰，我们可以在每个文件夹中进行基于特征的分割。</p><p id="4b97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在Redux文件夹中…</p><h1 id="4453" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">输入重鸭</h1><p id="8baa" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">应用程序的每个特性都应该映射到单独的动作和减少器，所以采用特性优先的方法是有意义的。</p><p id="a1d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最初的<a class="ae lq" href="https://github.com/erikras/ducks-modular-redux" rel="noopener ugc nofollow" target="_blank"> ducks模块化方法</a>是Redux的一个很好的简化，并提供了一种结构化的方式在你的应用中添加每个新功能。</p><p id="0563" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们想探索一下当应用程序扩展时会发生什么。我们意识到，从长远来看，一个特性的单个文件会变得过于混乱，难以维护。</p><p id="dbb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://github.com/alexnm/re-ducks" rel="noopener ugc nofollow" target="_blank"> <em class="lv">重鸭</em>就是这样诞生的</a>。解决方案是将每个特征拆分到一个<em class="lv"> duck </em>文件夹中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d164" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">鸭子文件夹必须:</p><ul class=""><li id="a0f4" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp ni nj nk nl bi translated">在你的应用程序中只包含处理一个概念的完整逻辑，例如:<em class="lv">产品</em>、<em class="lv">购物车</em>、<em class="lv">会话</em>等。</li><li id="231c" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated">有一个<code class="fe lr ls lt lu b">index.js</code>文件，按照原来的鸭子规则导出。</li><li id="96fe" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated">将类似用途的代码放在同一个文件中，如<em class="lv">减速器</em>、<em class="lv">选择器</em>和<em class="lv">动作</em></li><li id="c4a6" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated">包含与鸭子相关的<em class="lv">测试</em>。</li></ul><p id="81a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个例子，我们没有使用任何建立在Redux之上的抽象。构建软件时，从最少量的抽象开始很重要。通过这种方式，您可以确保抽象的成本不会超过收益。</p><p id="7672" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你需要说服自己抽象可能是不好的，看看程露的精彩演讲。</p><p id="c9ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看每个文件都包含了什么。</p><h2 id="80cc" class="nr me it bd mf ns nt dn mj nu nv dp mn ld nw nx mp lh ny nz mr ll oa ob mt oc bi translated">类型</h2><p id="3051" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated"><em class="lv">类型</em>文件包含您在应用程序中调度的动作的名称。作为一种良好的做法，您应该尝试根据名称所属的特性来确定名称的范围。这有助于调试更复杂的应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="0c21" class="nr me it bd mf ns nt dn mj nu nv dp mn ld nw nx mp lh ny nz mr ll oa ob mt oc bi translated">行动</h2><p id="fc52" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">这个文件包含了所有的动作创建函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1ca7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意所有的动作是如何被函数表示的，即使它们没有被参数化。在大型代码库中，一致的方法是非常必要的。</p><h2 id="6bc8" class="nr me it bd mf ns nt dn mj nu nv dp mn ld nw nx mp lh ny nz mr ll oa ob mt oc bi translated">操作</h2><p id="a0be" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">为了表示链式操作，您需要一个Redux中间件来增强调度功能。一些流行的例子有:<a class="ae lq" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>、<a class="ae lq" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>或<a class="ae lq" href="https://github.com/redux-observable/redux-observable" rel="noopener ugc nofollow" target="_blank"> redux-observable </a>。</p><p id="d960" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，我们使用<code class="fe lr ls lt lu b">redux-thunk</code>。我们希望将thunks从动作创建者中分离出来，甚至不惜花费额外的代码。所以我们将操作定义为动作的包装器。</p><p id="bb0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果操作只调度一个动作——实际上不使用<code class="fe lr ls lt lu b">redux-thunk</code>——我们转发动作创建者函数。如果操作使用thunk，它可以分派许多动作，并用承诺将它们连接起来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7ae6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">称它们为行动、思考、传奇、史诗——这是你的选择。只要找到一个命名约定并坚持下去。</p><p id="0476" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，当我们讨论<em class="lv">索引</em>时，我们会看到这些操作是duck的公共接口的一部分。动作被封装；操作是暴露的。</p><h2 id="0cfb" class="nr me it bd mf ns nt dn mj nu nv dp mn ld nw nx mp lh ny nz mr ll oa ob mt oc bi translated">还原剂</h2><p id="3358" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">如果一个特征有更多的面，你应该明确地使用多个缩减器来处理状态形状的不同部分。此外，不要害怕根据需要使用<code class="fe lr ls lt lu b">combineReducers</code>。这为您在处理复杂的状态形状时提供了很大的灵活性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2e78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在一个大规模的应用程序中，你的状态树至少有三层。Reducer函数应该尽可能小，并且只处理简单的数据结构。构建灵活且可维护的状态形状只需要使用<code class="fe lr ls lt lu b">combineReducers</code>实用函数。</p><p id="77ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看<a class="ae lq" href="https://github.com/FortechRomania/react-redux-complete-example" rel="noopener ugc nofollow" target="_blank">完整的示例项目</a>并了解如何使用<code class="fe lr ls lt lu b">combineReducers</code>:一次在<code class="fe lr ls lt lu b">reducers.js</code>文件中，然后在<code class="fe lr ls lt lu b">store.js</code>文件中，我们将整个状态树放在一起。</p><h2 id="f0b1" class="nr me it bd mf ns nt dn mj nu nv dp mn ld nw nx mp lh ny nz mr ll oa ob mt oc bi translated">选择器</h2><p id="7ca1" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">与操作一起，选择器是duck的公共接口的一部分。操作和选择器之间的划分类似于<a class="ae lq" href="https://martinfowler.com/bliki/CQRS.html" rel="noopener ugc nofollow" target="_blank"> CQRS模式</a>。</p><p id="d6b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">选择器函数获取应用程序状态的一部分，并基于此返回一些数据。它们不会给应用程序状态带来任何变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="c3f0" class="nr me it bd mf ns nt dn mj nu nv dp mn ld nw nx mp lh ny nz mr ll oa ob mt oc bi translated">索引</h2><p id="0fa3" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">该文件指定了从duck文件夹中导出的内容。它将:</p><ul class=""><li id="92f1" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp ni nj nk nl bi translated">默认导出鸭的减速器功能；</li><li id="fa99" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated">export as named导出选择器和操作；</li><li id="e3e7" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated">如果其他鸭需要这些类型，请将其导出。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="fff3" class="nr me it bd mf ns nt dn mj nu nv dp mn ld nw nx mp lh ny nz mr ll oa ob mt oc bi translated">试验</h2><p id="8b54" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">使用Redux和ducks结构的一个好处是，您可以在正在测试的代码旁边编写您的测试。</p><p id="a7d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">测试Redux代码相当简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4ac7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个文件中，你可以为缩减器、操作、选择器等编写测试。</p><p id="4fa4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我可以写一篇完全不同的关于测试你的代码的好处的文章；他们太多了。去做吧！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="d631" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">re-ducks的好处在于，您可以对所有Redux代码使用相同的模式。</p><p id="392e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着应用程序代码库的增长，Redux代码的基于特性的分割更加灵活和可伸缩。当您构建跨应用程序共享的小组件时，基于函数的视图分割是有效的。</p><p id="b92f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在GitHub查看完整的<code class="fe lr ls lt lu b">react-redux-example</code> <a class="ae lq" href="https://github.com/FortechRomania/react-redux-complete-example" rel="noopener ugc nofollow" target="_blank">代码库</a>。请记住，回购仍在积极发展中。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="2a92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你是如何构建Redux应用的？我期待着听到一些关于我提出的这个方法的反馈。</p></div></div>    
</body>
</html>