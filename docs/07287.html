<html>
<head>
<title>Learn How to Scale Your Kubernetes Deployments Dynamically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解如何动态扩展您的Kubernetes部署</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-how-to-scale-your-kubernetes-deployments-dynamically-d6c11344ec08?source=collection_archive---------9-----------------------#2020-12-29">https://betterprogramming.pub/learn-how-to-scale-your-kubernetes-deployments-dynamically-d6c11344ec08?source=collection_archive---------9-----------------------#2020-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ff7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">根据您收到的流量负载，了解扩展平台的不同选项</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e1ec6ee3db4a6fa80e83599ad8e5043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mwu_pL1UoEuiuRa2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>拍摄的照片。</p></figure><p id="b53b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到Kubernetes时，你总是在谈论它提供的灵活性选项。通常，讨论的话题之一是平台附带的弹性选项，尤其是在公共云提供商上工作时。但是怎么才能真正落实呢？</p><p id="30f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始展示如何扩展我们的Kubernetes平台之前，我们需要快速回顾一下我们可用的选项:</p><ul class=""><li id="b715" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">集群自动缩放:当整个基础设施的负载达到峰值时，我们可以通过创建新的工作节点来托管更多的服务实例，从而对其进行改进。</li><li id="205a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">水平单元自动伸缩:当一个特定单元或一组单元的负载达到峰值时，我们部署一个新的实例，以确保我们可以获得所需的全局可用性。</li></ul><p id="1c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用最流行的Kubernetes托管服务之一，亚马逊的弹性Kubernetes服务(EKS)来实现这些。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="43e4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设置</h1><p id="5be3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们要做的第一件事是创建一个具有单个工作节点的集群，以轻松演示可伸缩性行为。为此，我们将使用命令行工具eksctl来轻松管理EKS集群。</p><p id="c8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够创建集群，我们将使用以下命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="68eb" class="ns mr it no b gy nt nu l nv nw">eksctl create cluster --name=eks-scalability --nodes=1 --region=eu-west-2 --node-type=m5.large --version 1.17 --managed --asg-access</span></pre><p id="b691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几分钟后，我们将拥有自己的Kubernetes集群，其中有一个节点可以在其上部署应用程序。</p><p id="d3c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将创建一个样例应用程序来生成负载。我们将使用TIBCO BusinessWorks应用程序容器版来生成一个简单的应用程序。这将是一个REST API，它将执行100，000次迭代的循环，充当计数器并返回结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/f37206b23e7e230302aefcd109746781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajsgcd8nInzL-pgIfTDROA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示可伸缩性选项的BusinessWorks示例应用程序</p></figure><p id="882a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用GitHub资源库中的可用资源:</p><div class="ny nz gp gr oa ob"><a href="https://github.com/alexandrev/testeks" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">亚历山德罗夫/泰斯特克斯</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><p id="f729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将构建容器映像并将其推送到容器注册中心。在我的例子中，我将使用我的Amazon ECR实例来这样做，我将使用以下命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="45cd" class="ns mr it no b gy nt nu l nv nw">docker build -t testeks:1.0 .<br/>docker tag testeks:1.0 938784100097.dkr.ecr.eu-west-2.amazonaws.com/testeks:1.0<br/>docker push 938784100097.dkr.ecr.eu-west-2.amazonaws.com/testeks:1.0</span></pre><p id="cc66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦映像被推送到注册中心，我们将使用以下命令在Kubernetes集群上部署应用程序:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b717" class="ns mr it no b gy nt nu l nv nw">kubectl apply -f .\testeks.yaml</span></pre><p id="3f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们将在那里部署我们的应用程序，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/41604be79c5508eb2193d0867a78c4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*feAbJxYgLu7CgkyY76nI1A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部署在Kubernetes集群上的映像</p></figure><p id="4943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，现在我们可以测试应用程序了。为此，我将使用如下端口转发命令使端口8080可用:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="dc73" class="ns mr it no b gy nt nu l nv nw">kubectl port-forward pod/testeks-v1-869948fbb-j5jh7 8080:8080</span></pre><p id="4846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我可以使用浏览器查看并测试示例应用程序，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/22b4664d814a4e3962f82cbc5f642f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfs994sQnUdEZBfllmJE6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes示例应用程序的Swagger UI测试器</p></figure><h2 id="13b9" class="ns mr it bd ms os ot dn mw ou ov dp na li ow ox nc lm oy oz ne lq pa pb ng pc bi translated"><strong class="ak">水平pod自动缩放</strong></h2><p id="4260" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在，我们需要开始定义自动缩放规则，我们将从水平窗格自动缩放(HPA)规则开始。我们将需要选择我们想要用来扩展我们的pod的资源。在这个测试中，我将使用CPU利用率来完成这项工作，我将使用以下命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="a368" class="ns mr it no b gy nt nu l nv nw">kubectl autoscale deployment testeks-v1 --min=1 --max=5 --cpu-percent=80</span></pre><p id="6676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当CPU利用率高于80%时，该命令会将副本集<em class="pd"> testeks </em>从一个(<code class="fe pe pf pg no b">1</code>)实例扩展到五个(<code class="fe pe pf pg no b">5</code>)实例。</p><p id="6b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果现在我们检查组件的状态，我们将得到类似下图的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/8de2cd035147d4f8f06c40d7fd7ecb1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83TEN_0oS0rvQb6reX6W4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用CPU利用率作为关键指标的应用程序的HPA规则定义</p></figure><p id="ae9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们检查<em class="pd">目标</em>列，我们将看到这个值:<em class="pd"> &lt;未知&gt; /80% </em>。这意味着80%是触发新实例的目标，而当前使用情况是<em class="pd"> &lt;未知&gt;。</em></p><p id="5d93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们没有在群集上部署任何东西来获取每个单元的指标。为了解决这个问题，我们需要部署度量服务器。为此，我们将遵循亚马逊AWS文档:</p><div class="ny nz gp gr oa ob"><a href="https://docs.aws.amazon.com/eks/latest/userguide/metrics-server.html" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">安装Kubernetes度量服务器</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">Kubernetes Metrics服务器是集群中资源使用数据的聚合器…docs.aws.amazon.com没有部署iton.com</h3></div></div></div></a></div><p id="90a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，运行以下命令，我们将安装度量服务器。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d665" class="ns mr it no b gy nt nu l nv nw">kubectl apply -f https:<em class="pd">//github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.7/components.yaml</em></span></pre><p id="b330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这样做之后，如果我们再次检查，我们可以看到当前用户已经替换了未知的<em class="pd">&lt;&gt;</em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/92f91ca5c6331fc1041f6283ab593c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFriu0aieqCPXqFpawYSOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Kubernetes集群上安装度量服务器后的当前资源利用率</p></figure><p id="30f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可以的话，我将开始在集群内部使用负载测试发送请求。我将使用下面定义的示例应用程序:</p><div class="ny nz gp gr oa ob"><a href="https://schoolofdevops.github.io/ultimate-kubernetes-bootcamp/10_kubernetes_autoscaling/#load-test" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">通过HPA - Ultimate Kubernetes Bootcamp自动扩展容量</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">通过水平Pod自动扩展，Kubernetes可以自动扩展复制控制器中的Pod数量…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">schoolofdevops.github.io</p></div></div></div></a></div><p id="782e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进行部署，我们将使用包含以下内容的YAML文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="779c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用以下命令部署它:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="72c3" class="ns mr it no b gy nt nu l nv nw">kubectl apply -f tester.yaml</span></pre><p id="4df7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做之后，我们将看到当前的利用率正在增加。几秒钟后，它将开始旋转新的实例，直到它满足HPA规则中定义的最大pod数量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/81054583da7775fa57bbcb41a3199e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5F07m5R4S2r_BNFPppou-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当负载超过前面步骤中定义的目标时，pod增加。</p></figure><p id="a409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，一旦负载也降低，实例的数量将被删除。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/19945ef27366e72056e5a5abdd5d71db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A673NiiUpJYeg5s7LtbjwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">负载一减少，pod就被删除。</p></figure><h2 id="eb61" class="ns mr it bd ms os ot dn mw ou ov dp na li ow ox nc lm oy oz ne lq pa pb ng pc bi translated">聚类自动缩放</h2><p id="c287" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在，我们需要看看如何使用EKS实现集群自动伸缩。我们将使用亚马逊提供的信息:</p><div class="ny nz gp gr oa ob"><a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-autoscaler.html" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">集群自动缩放器</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">当pod无法启动时，Kubernetes集群自动缩放器会自动调整集群中的节点数量…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">docs.aws.amazon.com。</p></div></div></div></a></div><p id="3227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是部署集群自动扩展，我们将使用以下命令来完成:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="add5" class="ns mr it no b gy nt nu l nv nw">kubectl apply -f https://raw.githubusercontent.com/kubernetes/autoscaler/master/cluster-autoscaler/cloudprovider/aws/examples/cluster-autoscaler-autodiscover.yaml</span></pre><p id="0a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将运行以下命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="bd5b" class="ns mr it no b gy nt nu l nv nw">kubectl -n kube-system annotate deployment.apps/cluster-autoscaler cluster-autoscaler.kubernetes.io/safe-to-evict=”false”</span></pre><p id="289b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将编辑部署，以提供我们正在管理的群集的当前名称。为此，我们将运行以下命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7239" class="ns mr it no b gy nt nu l nv nw">kubectl -n kube-system edit deployment.apps/cluster-autoscaler</span></pre><p id="c74b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的默认文本编辑器打开并显示文本内容时，您需要进行以下更改:</p><ul class=""><li id="5ccf" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在可用的占位符中设置集群名称。</li><li id="ad0d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">添加这些附加属性:</li></ul><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f8e0" class="ns mr it no b gy nt nu l nv nw">- --balance-similar-node-groups<br/>- --skip-nodes-with-system-pods=false</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/a951252d7a044f12ea141104bbd4da41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vhq1Kvv7NBOIic5ksZXGow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">配置集群自动缩放器所需的部署编辑</p></figure><p id="4c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要运行以下命令:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d19c" class="ns mr it no b gy nt nu l nv nw">kubectl -n kube-system set image deployment.apps/cluster-autoscaler cluster-autoscaler=eu.gcr.io/k8s-artifacts-prod/autoscaling/cluster-autoscaler:v1.17.4</span></pre><p id="8e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一剩下的事情就是定义自动缩放策略。为此，我们将使用AWS服务门户:</p><ul class=""><li id="d42c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">进入我们部署了集群的地区的EC服务页面。</li><li id="05e2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">选择自动缩放组选项。</li><li id="7f3c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">选择在EKS集群创建过程中创建的自动扩展组。</li><li id="f69b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">转到自动缩放选项卡，并单击可用的添加策略按钮。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/25f3efd4a090a9c69bb352c51c7fd5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCsnAWH4Ryvz3SI1bRZDZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">EC2服务控制台中的自动缩放策略选项</p></figure><p id="a915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们应该定义政策。我们将使用平均CPU利用率作为指标，并将目标值设置为50%:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/a098e14f39651bf247dd1f80d83624e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9xhOv3yBik_76URwT9F8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动缩放策略创建对话框</p></figure><p id="c68f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了验证行为，我们将使用测试器生成负载，正如我们在前面的测试中所做的那样，并使用以下命令验证节点负载:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="398d" class="ns mr it no b gy nt nu l nv nw">kubectl top nodes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/47df4ba63daed7cfa6feffd1705d72aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*VvB5opu7mu9FUIL10lUfJQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">kubectl顶级节点的示例输出</p></figure><p id="8445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们再次部署测试器。由于我们已经在该集群中部署了它，我们需要先删除它，以便再次部署它:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b89a" class="ns mr it no b gy nt nu l nv nw">kubectl delete -f .\tester.yaml<br/>kubectl apply -f .\tester.yaml</span></pre><p id="74a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加载开始后，会立即创建新节点，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/a116d605a3c947ea15ce48c545a5de2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*SiDnznX4m9AfmrWSHr0cIA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">kubectl top nodes展示了节点是如何向上扩展的</p></figure><p id="865c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加载完成后，我们回到之前的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/63d78c21adcb6c757d372f660c10fdb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*nLzITxc2ZsbScHpb6__RxQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">kubectl top nodes显示了节点是如何缩减的</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4092" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="ce6a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我们展示了如何使用集群自动缩放功能在工作节点级别和使用水平pod自动缩放功能在Pod级别动态地缩放Kubernetes集群。这为我们提供了创建真正有弹性和灵活性的环境所需的所有选项，能够以最有效的方式适应每时每刻的需求。</p></div></div>    
</body>
</html>