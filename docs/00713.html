<html>
<head>
<title>Creating a REST API in Node.js with Express, TypeScript, MongoDB and Docker — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Express、TypeScript、MongoDB和Docker在Node.js中创建REST API第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-2-38b48af52860?source=collection_archive---------2-----------------------#2019-07-04">https://betterprogramming.pub/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-2-38b48af52860?source=collection_archive---------2-----------------------#2019-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c21b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个MongoDB容器和一个Mongoose模型</h2></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/2412e6bececa735d1588750633e9d62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0MSEI9BpIi7uXaWOj3CLQ.png"/></div></div></figure><p id="833f" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是一系列文章的第二部分，将向您展示如何使用Express、TypeScript、Docker和MongoDB在Node.js中创建REST API。以下是本系列的其余部分:</p><ul class=""><li id="3269" class="lx ly it ld b le lf lh li lk lz lo ma ls mb lw mc md me mf bi translated"><a class="ae mg" href="https://medium.com/@nyablk97/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-1-8428b0cd05d" rel="noopener">用Express、TypeScript、MongoDB和Docker在NodeJS中创建REST API第1部分</a></li><li id="ea8a" class="lx ly it ld b le mh lh mi lk mj lo mk ls ml lw mc md me mf bi translated"><a class="ae mg" href="https://medium.com/@nyablk97/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-3-1b173fc2a482" rel="noopener">使用Express、TypeScript、MongoDB和Docker在NodeJS中创建REST API第3部分</a></li></ul><p id="a914" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">你可以在这里找到<a class="ae mg" href="https://github.com/puntotech/pokeAPI/" rel="noopener ugc nofollow" target="_blank">的完整代码</a>。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h1 id="cec0" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">介绍</h1><p id="7357" class="pw-post-body-paragraph lb lc it ld b le ne ju lg lh nf jx lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">在前一篇文章中，我们设置了我们的服务器并实现了我们的第一个GET route，它返回了一个可爱的欢迎消息。因为我们的目标是对口袋妖怪数据执行基本的CRUD操作，所以我们需要一个数据库来存储我们的信息。</p><p id="c526" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本文中，我们将为我们的<a class="ae mg" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>数据库创建并部署一个<a class="ae mg" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器。我们还将使用<a class="ae mg" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>来定义我们的口袋妖怪数据模型。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h1 id="e811" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">让我们编码</h1><h2 id="f173" class="nj mn it bd mo nk nl dn ms nm nn dp mw lk no np my lo nq nr na ls ns nt nc nu bi translated">试映</h2><p id="3048" class="pw-post-body-paragraph lb lc it ld b le ne ju lg lh nf jx lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">再一次，在我们开始之前，先预览一下我们的目录树在本文结束时的样子:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2d56746a41151f763f6fd20aebbb8a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*c1JlRB6ebQrQbRLG8xDwwg.png"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">PokeAPI第2部分目录树</p></figure><p id="b735" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">提醒一下:为了运行我们的项目，我们目前使用以下命令:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="ff1a" class="nj mn it ob b gy of og l oh oi">npm run start</span></pre><p id="91de" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">说完了，我们开始吧。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h1 id="26a3" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">创建Docker-Compose文件</h1><p id="8944" class="pw-post-body-paragraph lb lc it ld b le ne ju lg lh nf jx lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我们要做的第一件事是创建一个<code class="fe oj ok ol ob b">docker-compose.yml</code>文件，与我们的<code class="fe oj ok ol ob b">src</code>目录在同一层，也就是说，在<code class="fe oj ok ol ob b">src</code>目录的<strong class="ld iu"> </strong>之外。</p><p id="ca24" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">完成后，将以下代码复制并粘贴到新创建的文件中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">docker-compose.yml文件</p></figure><p id="d853" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我将简要解释这些配置选项的含义:</p><ul class=""><li id="eb6e" class="lx ly it ld b le lf lh li lk lz lo ma ls mb lw mc md me mf bi translated"><code class="fe oj ok ol ob b">version</code>:指定我们将要使用的docker-compose版本。</li><li id="b6e8" class="lx ly it ld b le mh lh mi lk mj lo mk ls ml lw mc md me mf bi translated"><code class="fe oj ok ol ob b">services</code>:我们可以指定一个服务列表，这些服务将与我们的容器一起部署。在我们的例子中，我们需要一个数据库，这就是为什么我们使用下面的属性:</li><li id="a982" class="lx ly it ld b le mh lh mi lk mj lo mk ls ml lw mc md me mf bi translated"><code class="fe oj ok ol ob b">db</code>:我们表示将部署一个数据库。</li><li id="75b4" class="lx ly it ld b le mh lh mi lk mj lo mk ls ml lw mc md me mf bi translated"><code class="fe oj ok ol ob b">container_name</code>:这是可选的。它允许我们指定一个自定义的容器名。如果我们忽略这个选项，将会生成一个默认的容器名。</li><li id="4083" class="lx ly it ld b le mh lh mi lk mj lo mk ls ml lw mc md me mf bi translated"><code class="fe oj ok ol ob b">image</code> <strong class="ld iu"> : </strong>指定构建容器的图像。在我们的例子中，最新的MongoDB图像。</li><li id="d02b" class="lx ly it ld b le mh lh mi lk mj lo mk ls ml lw mc md me mf bi translated"><code class="fe oj ok ol ob b">restart</code> <strong class="ld iu"> : </strong>如果容器停止，总是重启容器。如果它被手动停止，只有当Docker守护进程重新启动或容器本身被手动重新启动时，它才会重新启动。</li><li id="4b25" class="lx ly it ld b le mh lh mi lk mj lo mk ls ml lw mc md me mf bi translated"><code class="fe oj ok ol ob b">volumes</code> <strong class="ld iu"> : </strong>这是一个非常有趣的选项。它允许我们拥有数据持久性。这是什么意思？我们所有的数据都将存储在Docker容器中。然而，Docker容器可以被停止、重启等。在这种情况下，我们的数据会怎么样？它会消失吗？答案是，如果我们使用卷选项，它不会消失。我们可以在本地机器上指定一个存储数据的目录。在我们的例子中，这个目录被命名为<code class="fe oj ok ol ob b">pokeData</code>。</li><li id="f58d" class="lx ly it ld b le mh lh mi lk mj lo mk ls ml lw mc md me mf bi translated"><code class="fe oj ok ol ob b">environment</code> <strong class="ld iu"> : </strong>我们可以指定环境变量。在我们的例子中，当容器启动时，我们正在创建一个名为<em class="oo"> Pokemon </em>的数据库。</li><li id="55f8" class="lx ly it ld b le mh lh mi lk mj lo mk ls ml lw mc md me mf bi translated"><code class="fe oj ok ol ob b">ports</code> <strong class="ld iu"> : </strong>指定将要暴露的端口(主机端口:集装箱端口)。在我们的例子中，我们将本地端口27017映射到容器端口27017 (27017是MongoDB的默认端口)。</li></ul><p id="8d54" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><em class="oo">提示:关于docker-compose文件的更多信息，可以查看</em> <a class="ae mg" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank"> <em class="oo">这个链接</em> </a> <em class="oo">。</em></p><p id="533d" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我们已经准备好了docker-compose文件，让我们启动容器。启动您的终端，键入以下命令进行部署:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="4c4e" class="nj mn it ob b gy of og l oh oi">docker-compose up </span></pre><p id="f7b6" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果您做的一切都正确，您应该会在终端上看到类似如下的输出:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi op"><img src="../Images/e5940790973432fcbae56311337b32c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gd48Ro0-0Eiw0a-ny-vfOg.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">docker-撰写输出</p></figure><p id="506b" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">您还应该看到一个名为<code class="fe oj ok ol ob b">pokeData</code>的新目录出现在您的目录树中。这是我们之前在docker-compose文件中使用“volumes”属性指定的目录。</p><p id="4668" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们的<code class="fe oj ok ol ob b">pokeData</code>目录将负责存储我们所有的数据库数据(一旦我们插入一些)，并保持其安全可靠。</p><p id="19fa" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Docker是不是很牛逼很好用？一个简单、直观、文档丰富的配置文件和一个命令是我们启动和运行数据库实例所需要的。太美了。</p><h2 id="a005" class="nj mn it bd mo nk nl dn ms nm nn dp mw lk no np my lo nq nr na ls ns nt nc nu bi translated"><strong class="ak">故障排除</strong></h2><p id="7e20" class="pw-post-body-paragraph lb lc it ld b le ne ju lg lh nf jx lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">如果您在执行<code class="fe oj ok ol ob b">docker-compose up</code>命令后得到以下输出:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="5ebe" class="nj mn it ob b gy of og l oh oi">ERROR: Couldn’t connect to Docker daemon at http+docker://localhost — is it running?</span></pre><p id="a9cd" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这意味着你的Docker守护进程没有运行。运行以下命令启动Docker守护程序:</p><pre class="kq kr ks kt gt oa ob oc od aw oe bi"><span id="d4ed" class="nj mn it ob b gy of og l oh oi">sudo systemctl start docker</span></pre><p id="1a85" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">并再次尝试<code class="fe oj ok ol ob b">docker-compose up</code>命令。错误应该消失了。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h1 id="be3c" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">将我们的应用程序连接到我们的Dockerized MongoDB数据库</h1><p id="0d70" class="pw-post-body-paragraph lb lc it ld b le ne ju lg lh nf jx lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我们已经部署并运行了数据库容器，所以我们现在需要将应用程序连接到它。为此，我们需要在我们的<code class="fe oj ok ol ob b">app.ts</code>文件中创建一个<code class="fe oj ok ol ob b">setMongoConfig</code>方法，它将负责配置和连接到Mongo数据库。这个方法应该是这样的:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">app.ts中的setMongoConfig方法</p></figure><p id="f59e" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">您可能已经注意到，我们再次硬编码了一个变量:Mongoose连接字符串。为了避免这种情况，让我们打开我们的<code class="fe oj ok ol ob b">pokeapi.constants</code>文件，并存储在那里:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">pokeapi.constants版本2</p></figure><p id="7e79" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">回到我们的<code class="fe oj ok ol ob b">app.ts</code>，我们现在可以为新定义的常量更改硬编码的字符串:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪控制器第5版</p></figure><p id="33f1" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果我们做的一切都正确，我们现在应该在运行<code class="fe oj ok ol ob b">docker-compose up</code>命令的终端中看到如下所示的输出。如果出于某种原因，您之前停止了docker-compose，请再次运行该命令。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oq"><img src="../Images/e1e06a74c747988943d1303484746c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xBG3_0SmHc4m303UtKqtw.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">docker-compose终端输出</p></figure><p id="c913" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如您所见，我们的Docker容器已经接受了我们从应用程序中创建的连接。到目前为止，一切顺利。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h1 id="718f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">创建我们的数据模型</h1><p id="f789" class="pw-post-body-paragraph lb lc it ld b le ne ju lg lh nf jx lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">既然我们已经连接到了数据库，我们需要一种与它交互的方式。为了实现这一点，我们将使用Mongoose，它为我们提供了几个数据建模工具，比如模式和模型。Mongoose使得与MongoDB的交互变得非常容易和简单。</p><blockquote class="or os ot"><p id="f6ea" class="lb lc oo ld b le lf ju lg lh li jx lj ou ll lm ln ov lp lq lr ow lt lu lv lw im bi translated">“模型是根据s <strong class="ld iu"> chema </strong>定义编译的奇特构造函数。一个模型的实例被称为<strong class="ld iu">文档</strong>。模型负责从底层MongoDB数据库创建和读取文档。”——猫鼬文件</p></blockquote><p id="00ee" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">然而，在我们创建我们的模型之前，我们首先要创建一个接口，它将允许我们键入我们的模型。</p><h2 id="644a" class="nj mn it bd mo nk nl dn ms nm nn dp mw lk no np my lo nq nr na ls ns nt nc nu bi translated">创建口袋妖怪界面</h2><p id="a777" class="pw-post-body-paragraph lb lc it ld b le ne ju lg lh nf jx lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">我们将从在<code class="fe oj ok ol ob b">src</code>中创建一个接口目录和一个<code class="fe oj ok ol ob b">pokemon.interface.ts</code>文件开始。在文件内部，我们将定义我们的Pokemon接口，它需要扩展mongose<code class="fe oj ok ol ob b">Document</code>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">IPokemon接口</p></figure><p id="7602" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如您所见，代码非常简单。我们所做的就是定义我们希望模型拥有的属性及其类型。一旦我们创建了模型，我们将利用这个接口来输入它。</p><h2 id="4b80" class="nj mn it bd mo nk nl dn ms nm nn dp mw lk no np my lo nq nr na ls ns nt nc nu bi translated">创建口袋妖怪模式和模型</h2><p id="5f2a" class="pw-post-body-paragraph lb lc it ld b le ne ju lg lh nf jx lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">为了存储我们的数据模型，我们将在<code class="fe oj ok ol ob b">src</code>中创建一个模型目录，其中包含一个名为<code class="fe oj ok ol ob b">pokemon.model.ts</code>的文件。在这个文件中，我们将导入Mongoose并创建一个<code class="fe oj ok ol ob b">PokemonSchema</code>，然后用它来创建我们的数据模型。我们的模式看起来是这样的:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪模式</p></figure><p id="f1d2" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如您所见，除了定义我们的模型将拥有的属性，我们还定义了它们的类型，并指定它们都是必需的。我们还添加了一个通用的“Field is required”错误消息，如果我们试图创建一个缺少任何属性的模型，就会显示该消息。</p><p id="5182" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">既然我们已经创建了Pokemon模式，我们需要用它来创建一个Mongoose模型。因此，在同一文件中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">导出口袋妖怪模型</p></figure><p id="0afe" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在上面的代码中，我们使用<code class="fe oj ok ol ob b">PokemonSchema</code>创建了一个Mongoose模型，并且使用我们之前创建的<code class="fe oj ok ol ob b">IPokemon</code>接口对它进行了类型化。</p><p id="c296" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><strong class="ld iu"> <em class="oo">注意:</em> </strong> <em class="oo">我完全知道我们在同一个文件中定义了我们的模式和模型，这个文件名为</em> <code class="fe oj ok ol ob b"><em class="oo">pokemon.model</em></code> <em class="oo">。我认为拥有两个独立的文件——一个用于模式，一个用于模型——有点太多了，因为我们可以用一行代码创建模型。当然，如果您愿意，可以为您的模式创建一个单独的文件。</em></p><p id="a3d8" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们刚刚创建了口袋妖怪模型，现在是时候将它导入<code class="fe oj ok ol ob b">PokemonService</code>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="om on l"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">口袋妖怪服务第3版</p></figure><p id="c80f" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一旦我们创建了CRUD路径和它们各自的<code class="fe oj ok ol ob b">db</code>查询函数，Pokemon模型稍后将用于查询我们的MongoDB数据库。</p><p id="fb08" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">不过，这一点，我们将留待后面的帖子来说。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h1 id="aa49" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="8a30" class="pw-post-body-paragraph lb lc it ld b le ne ju lg lh nf jx lj lk ng lm ln lo nh lq lr ls ni lu lv lw im bi translated">在这篇文章中，我们学习了如何使用docker-compose部署MongoDB的实例，以及如何将我们的应用程序连接到它。我们还使用Mongoose为数据库创建了模式和模型。</p><p id="d26a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果你想看这篇文章的完整代码，你可以在PokeAPI项目的这个分支<a class="ae mg" href="https://github.com/puntotech/pokeAPI/tree/02-database" rel="noopener ugc nofollow" target="_blank">中看到。</a></p><p id="3858" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本系列的下一部分中，我们将实现创建基本CRUD所必需的其余路径，以及它们各自的数据库查询功能。这是下一个的链接:</p><div class="ox oy gp gr oz pa"><a href="https://medium.com/@nyablk97/pokeapi-rest-in-nodejs-with-express-typescript-mongodb-and-docker-part-3-1b173fc2a482" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">PokeAPI REST在NodeJS中包含Express、Typescript、MongoDB和Docker —第3部分</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">序</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">medium.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po kz pa"/></div></div></a></div><p id="0f0f" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">非常感谢你的阅读，我希望你能喜欢这篇文章并觉得有用。请随意与您的朋友和/或同事分享，如果您有任何意见，请随时联系我！</p></div></div>    
</body>
</html>