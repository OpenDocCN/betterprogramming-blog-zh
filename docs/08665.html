<html>
<head>
<title>Create Your Own HTML5 Canvas Toolkit With Vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用普通的JavaScript创建你自己的HTML5画布工具包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-your-own-html5-canvas-toolkit-with-vanilla-javascript-1d2ad1047219?source=collection_archive---------5-----------------------#2021-05-27">https://betterprogramming.pub/create-your-own-html5-canvas-toolkit-with-vanilla-javascript-1d2ad1047219?source=collection_archive---------5-----------------------#2021-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee1f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">帮助创作者画出令人惊叹的形状的工具包</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a3df98ae2eca53bd496507c3d3f8e16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgkOcPhX3mCw5QsVJzzGGg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1683134" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/coyot-2009089/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1683134" rel="noopener ugc nofollow" target="_blank">尤拉杰·沃尔高</a></p></figure><p id="f058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">艺术和技术是一个硬币的两面。在web开发中，HTML5 <code class="fe lv lw lx ly b">&lt;canvas&gt;</code>元素体现了这种双重性——这是一个强大的工具，为高性能web交互、游戏、复杂动画和数据可视化打开了大门。也就是说，使用canvas的入门感觉很陡，因为即使创建简单的形状也需要很多行代码。</p><p id="41c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然HTML5 canvas库和框架可以使使用canvas更加简单，但如果您发现自己希望使用canvas而不必依赖第三方工具，也可以为自己的项目创建自定义工具包。</p><p id="44c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程将向你展示如何创建一个在HTML5画布上绘制形状的工具包。我们将创建两个方法——一个用于画圆，一个用于画正多边形——并将它们封装在一个函数包装器中，该包装器可以在整个应用程序中引用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f71c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">设置工作区</h1><p id="f8fe" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于HTML，让我们有一个包含一个<code class="fe lv lw lx ly b">canvas</code>元素的<code class="fe lv lw lx ly b">div</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6f8a" class="nh mh it ly b gy ni nj l nk nl">&lt;div id="root"&gt;<br/>  &lt;canvas id="myCanvas" width="200" height="200"&gt;<br/>  &lt;/canvas&gt;<br/>&lt;/div&gt;</span></pre><p id="cf72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加一些CSS来突出这个元素的中心和轮廓。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="34c6" class="nh mh it ly b gy ni nj l nk nl">body {<br/>  text-align: center;<br/>}<br/>canvas {<br/>  border: 1px solid #000;<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="744f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">介绍绘图环境</h1><p id="31fd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，让我们看看在没有现成方法的情况下，如何使用canvas绘制一个圆。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b579" class="nh mh it ly b gy ni nj l nk nl">var canvas = document.getElementById("myCanvas");<br/>var ctx = canvas.getContext("2d");<br/>ctx.beginPath();<br/>ctx.arc(100, 100, 50, 0, 2 * Math.PI);<br/>ctx.stroke();</span></pre><p id="64df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来分析一下。</p><ul class=""><li id="4c52" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">我们首先使用其ID获得对<code class="fe lv lw lx ly b">&lt;canvas&gt;</code>元素的引用。</li><li id="defb" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">调用<code class="fe lv lw lx ly b">getContext("2d")</code>为这个<code class="fe lv lw lx ly b">&lt;canvas&gt;</code>元素提供了一个渲染上下文，所有的绘图命令都通过它传递。</li><li id="c974" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">调用<code class="fe lv lw lx ly b">beginPath()</code>开始一个新的绘图路径。</li><li id="65e2" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe lv lw lx ly b">arc</code>功能用于绘制一个在起点结束的圆弧，形成一个圆。</li><li id="7fef" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">调用<code class="fe lv lw lx ly b">stroke</code>绘制圆形路径。</li></ul><p id="c946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里对<code class="fe lv lw lx ly b">arc</code>函数的调用有五个参数。</p><ul class=""><li id="b7c8" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">前两个是<em class="oa"> x </em>和<em class="oa"> y </em>坐标，都是<code class="fe lv lw lx ly b">100</code>。</li><li id="d7a5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">第三个是半径，也就是<code class="fe lv lw lx ly b">50</code>。</li><li id="f041" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">然后我们就有了<code class="fe lv lw lx ly b">0</code>的起始角度。</li><li id="51df" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">最终角度为<code class="fe lv lw lx ly b">Math.PI*2</code>弧度，转换为360度。</li></ul><p id="b439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要很多行代码，可能很难读懂，所以让我们创建一个方法，使绘制这个圆更加有效和直观。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8313" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们的工具包应该如何工作</h1><p id="3c32" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们看看应该如何使用我们将要编写的实用方法。为了尽量减少全局名称空间中的东西，让我们将这些方法附加到一个名为<code class="fe lv lw lx ly b">drawJS</code>的对象上。</p><p id="386a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe lv lw lx ly b">drawCircle</code>方法的工作方式。我们将调用该方法，传入一个具有以下属性的对象文字，并让它在<code class="fe lv lw lx ly b">&lt;canvas&gt;</code>元素上画一个圆。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3c6a" class="nh mh it ly b gy ni nj l nk nl">drawJS.drawCircle({<br/>  id:'myCanvas',<br/>  radius:50,<br/>  cx:100,<br/>  cy:100,<br/>  stroke:'#622569',<br/>  strokeWidth:5,<br/>  fill:'#98d1d6'<br/>});</span></pre><p id="0fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们编写了方法，上面对<code class="fe lv lw lx ly b">drawCircle</code>的调用应该会在画布上绘制这个图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/da600fc7a5357210b5fd4a2b69ca8f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*kp5PMbFNizuZ7aLBKtryXw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用我们的画布方法画的圆。</p></figure><p id="207d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也希望不传递任何参数，仍然让它工作。在这种情况下，它会在DOM中找到第一个canvas元素并绘制到它。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="10c3" class="nh mh it ly b gy ni nj l nk nl">drawJS.drawCircle();</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5e89" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建主对象</h1><p id="ca4d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们将从一个空的<code class="fe lv lw lx ly b">drawJS</code>对象开始。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3c21" class="nh mh it ly b gy ni nj l nk nl">let drawJS = {};</span></pre><h2 id="9cb9" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">包装纸</h2><p id="a065" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们创建一个立即调用的函数表达式(IIFE ),作为我们逻辑的包装器。IIFE包装器会将<code class="fe lv lw lx ly b">drawJS</code>作为一个参数，在内部将其称为<code class="fe lv lw lx ly b">pen</code>，并为其注入方法。在包装器中，这个参数被称为<code class="fe lv lw lx ly b">pen</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="233b" class="nh mh it ly b gy ni nj l nk nl">(function(pen) {</span><span id="2059" class="nh mh it ly b gy on nj l nk nl">// methods will go here</span><span id="3147" class="nh mh it ly b gy on nj l nk nl">}(drawJS)</span></pre><h2 id="65fc" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">随便你怎么称呼它</h2><p id="df1e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">请注意，除了<code class="fe lv lw lx ly b">drawJS</code>之外，您可以使用任何其他名称，只要您在整个代码中保持一致。包装器中不使用对象的特定名称，这使得它很灵活。</p><p id="7625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">里面的函数会自动执行，而不需要被调用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a878" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">画一个圆</h1><p id="541b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这个包装器中，让我们给我们的<code class="fe lv lw lx ly b">pen</code>对象一个<code class="fe lv lw lx ly b">drawCircle</code>方法。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="53fb" class="nh mh it ly b gy ni nj l nk nl">(function(pen) {</span><span id="abf2" class="nh mh it ly b gy on nj l nk nl">   pen.drawCircle = function(o={}) {</span><span id="7df8" class="nh mh it ly b gy on nj l nk nl">      // logic goes here.</span><span id="7c40" class="nh mh it ly b gy on nj l nk nl">   };</span><span id="ede4" class="nh mh it ly b gy on nj l nk nl">}(drawJS)</span></pre><p id="f872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法有一个名为<code class="fe lv lw lx ly b">o</code>的参数。<code class="fe lv lw lx ly b">o</code>的属性将作为画圆的指令。因为我想让它在没有对象传入的情况下工作，所以我默认将<code class="fe lv lw lx ly b">o</code>参数设置为等于<code class="fe lv lw lx ly b">{}</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6a4d" class="nh mh it ly b gy ni nj l nk nl">pen.drawCircle = function(<strong class="ly iu">o={}</strong>) {</span></pre><h2 id="cd4b" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">获取绘图上下文</h2><p id="1d01" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们编写获得画布及其绘图上下文的代码。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3174" class="nh mh it ly b gy ni nj l nk nl">(function(pen) {<br/>    pen.drawCircle = function(o={}) {</span><span id="d161" class="nh mh it ly b gy on nj l nk nl">       let selector = '#'+o.id;<br/>       let canvas = document.querySelector(selector);<br/>       let context = canvas.getContext("2d");<br/>    }</span><span id="5ac6" class="nh mh it ly b gy on nj l nk nl">});</span></pre><p id="1ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们分解每一个新行。</p><ul class=""><li id="12a2" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe lv lw lx ly b">selector</code>命名我们想要的元素。</li><li id="4109" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe lv lw lx ly b">canvas</code>成为对该元素的引用。</li><li id="eed4" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe lv lw lx ly b">context</code>是接受绘图命令的渲染上下文。</li></ul><h2 id="179e" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">设置默认画布</h2><p id="6402" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了让它在没有ID的情况下工作，让我们使用一个三元运算符来检查<code class="fe lv lw lx ly b">o.id</code>是否存在。如果没有，我们将选择器设置为<code class="fe lv lw lx ly b">canvas</code>，这将最终得到DOM中的第一个<code class="fe lv lw lx ly b">&lt;canvas&gt;</code>元素。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="78f0" class="nh mh it ly b gy ni nj l nk nl">let selector = (o.id) ? '#'+o.id : 'canvas';</span></pre><p id="e864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是目前为止使用默认画布逻辑的<code class="fe lv lw lx ly b">drawCircle</code>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/30af6454baa3f0a04eeba07fc274777c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlgavs8qzmtL302WTI25wg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们画圈法的开始。</p></figure><h2 id="162a" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">使用默认值设置形状属性</h2><p id="c2c4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来，让我们定义形状的中心坐标和半径，如果没有定义值，使用OR ( <code class="fe lv lw lx ly b">||</code>)选择器指定默认值。这种方法允许我们选择想要定制的属性。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="21d6" class="nh mh it ly b gy ni nj l nk nl">let x = o.cx || 0;<br/>let y = o.cy || 0;<br/>let radius = o.radius || 100;</span></pre><p id="74a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，如果<code class="fe lv lw lx ly b">cx</code>不是一个属性，那么我们默认为<code class="fe lv lw lx ly b">0</code>的一个<em class="oa">x</em>-坐标。</p><h2 id="88e3" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">设置笔触样式、线条宽度和填充</h2><p id="671e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来，让我们定义线条宽度和钢笔的笔画颜色。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f861" class="nh mh it ly b gy ni nj l nk nl">context.lineWidth = o.lineWidth || 1;   <br/>     <br/>context.strokeStyle = o.stroke || '#000';</span></pre><p id="b909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们画圆。为了做到这一点，我们开始路径，规划路径，并绘制路径。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c366" class="nh mh it ly b gy ni nj l nk nl">context.beginPath();</span><span id="8117" class="nh mh it ly b gy on nj l nk nl">context.arc(x, y, radius, 0, 2*Math.PI);<br/>       <br/>context.stroke();</span></pre><p id="d553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以添加填充圆的功能。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="490e" class="nh mh it ly b gy ni nj l nk nl">if (o.fill) {<br/>     context.fillStyle = o.fill;<br/>     context.fill();<br/>}</span></pre><p id="4159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是迄今为止的方法。</p><h2 id="7eb9" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">整个画圆方法</h2><p id="4e1e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是画圆的完整方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/14cef3002018e1614cc928c7c461cf26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRiohy7iT9qVMTwTrKlLeg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">画圆的方法。</p></figure><p id="bcc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们应该发现，无论有没有对象参数，这都应该可以工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/890f23abedc6e38ed5fafc60a53fd98c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dyXUQXZ6H76DOyUi3q4-iA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用和不使用属性调用drawCircle方法。</p></figure><p id="f68a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的示例中，左上角的圆是在没有object参数的情况下创建的，而带有紫色边框的浅绿色圆是使用传入的对象创建的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ac90" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">画一个多边形</h1><p id="ac6d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以使用这种方法为其他形状创建其他方法。让我们为一个正多边形再创建一个，它可以接受我们用于圆形的属性，以及一个用于边数的新属性。</p><p id="3935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们完成时，下面的方法调用应该会画出一个六边形。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8913" class="nh mh it ly b gy ni nj l nk nl">drawJS.drawPolygon({<br/>  cx:100,<br/>  cy:100,<br/>  radius:40,<br/><strong class="ly iu">  numSides:6,</strong><br/>  lineWidth:4,<br/>  stroke:'#622569',<br/>  fill:'#b8a9c9'<br/>});</span></pre><h2 id="a031" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">获取画布、上下文和属性</h2><p id="bc7d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以从同样的一般方法开始。注意包含了<code class="fe lv lw lx ly b">numSides</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/903f9b92d25f8a038b7dd1365181ec16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3oyF5Lxtm98jOOXUm9FKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们drawPolygon方法的开始。</p></figure><h2 id="e0c8" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">放置笔</h2><p id="b720" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">像上次一样，让我们开始路径，并使用半径将笔移动到形状的3点钟位置。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f116" class="nh mh it ly b gy ni nj l nk nl">context.beginPath();</span><span id="3dfd" class="nh mh it ly b gy on nj l nk nl">context.moveTo(cx + radius, cy);</span></pre><p id="0d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到以下内容:</p><ul class=""><li id="68d2" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><em class="oa"> x </em>最终得到<em class="oa">x</em>-中心点加上半径的值。</li><li id="d34d" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><em class="oa"> y </em>最终得到中心点的<em class="oa"> y </em>值。</li></ul><p id="d197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们从下面这一点开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/618b0e35879f1e1a4e3032be1cc5c5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*_Fopq7a7rWGpxbRXCpaYaQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的起点。</p></figure><h2 id="cb54" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">求多边形的圆心角</h2><p id="957f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了让我们的笔到达六边形的角，我们需要知道它的<em class="oa">中心角，</em>它是由从中心到任意两个相邻角的线形成的。其中一个圆心角在下面用橙色显示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/b23353e08481a1775fda687493f3f7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*k02gllbE3J199foq5COvUQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">圆心角位于每对直线的中心。</p></figure><p id="51cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何多边形中，圆心角的数量等于边的数量，圆心角的总和必须等于360度，即2π弧度。</p><p id="7fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们的代码可以通过将2π弧度除以边数来找到圆心角。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="da36" class="nh mh it ly b gy ni nj l nk nl">let angle = 2*Math.PI / numSides;</span></pre><h2 id="6e95" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">穿过侧面</h2><p id="b224" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们有了中心角和边数，让我们使用一个<code class="fe lv lw lx ly b">for</code>-循环来让我们的笔到达多边形的每个角。基本想法是这样的:</p><ul class=""><li id="3eae" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">对于每一面，我们都找到一个新的角度。</li><li id="0460" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">然后我们使用那个角度的<code class="fe lv lw lx ly b">cos</code>和<code class="fe lv lw lx ly b">sin</code>分别得到新的角的<code class="fe lv lw lx ly b">x</code>和<code class="fe lv lw lx ly b">y</code>坐标。</li><li id="6fb5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">然后，我们使用<code class="fe lv lw lx ly b">lineTo</code>将笔移动到这些坐标。</li></ul><p id="b41f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在下面看到它是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/68110d2de3bfd2f2526c352965f5453b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCWCmr_5FltQnkVicp0IxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们用来画多边形的循环。</p></figure><h2 id="d3ed" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">整个drawPolygon方法</h2><p id="9267" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">下面是整个<code class="fe lv lw lx ly b">drawPolygon</code>方法。在我们刚刚编写的循环下面，我们还有在circle方法中使用的笔画和填充逻辑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/d3c5ed9181a57cfe1bf98fc0efb9ee42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBbL9Ap7sxUNnWvVUp-WSQ.png"/></div></div></figure><p id="259f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用下面的方法，用我们的新兴工具包画一个圆和一个多边形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/c2eefb807a8ed6dfb63364f86ca4ce26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSJXFJhEuLirJiFo7Mynsg.png"/></div></div></figure><p id="06b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码应该会产生以下形状。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/884f94495af4620e1334eecf1269ce48.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*LWgmFwWLfrPZNbuROJ97xw.png"/></div></figure><p id="c704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一支笔，你可以用它来检查你的工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">drawCircle和drawPolygon方法</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3716" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最后的想法</h1><p id="be4d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">虽然使用Canvas API涉及很多细节，但是将代码封装在可重用的方法中可以使您编写的代码更加高效和直观。除了绘制形状，我们还可以添加放置图像、绘制复杂图案、使用多个画布元素以及创建可以响应用户输入的动画的方法。</p><p id="996e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>