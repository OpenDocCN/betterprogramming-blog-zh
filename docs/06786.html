<html>
<head>
<title>Why “Yield” Is an Excellent Python Keyword — Generators and Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么“Yield”是一个优秀的Python关键字—生成器和协程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-yield-is-an-excellent-python-keyword-generators-and-coroutines-d0d9d9403171?source=collection_archive---------6-----------------------#2020-11-04">https://betterprogramming.pub/why-yield-is-an-excellent-python-keyword-generators-and-coroutines-d0d9d9403171?source=collection_archive---------6-----------------------#2020-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="25b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">屈服还是不屈服</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc272fb8c732315b29791fcbf0418fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2xY_NJqPRyaWY_WE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kurt Cotoaga 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="c8f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的<a class="ae ky" href="https://github.com/leighmcculloch/keywords" rel="noopener ugc nofollow" target="_blank">没有其他几种主流编程语言的</a> ( <em class="lv"> n=35 </em>)那么多关键词，比如Swift ( <em class="lv"> n=89 </em>)、Java ( <em class="lv"> n=51 </em>)、JavaScript ( <em class="lv"> n=49 </em>)。更短的关键字列表并没有阻止Python成为机器学习、web开发和许多其他领域的流行语言。在Python的关键字中，<code class="fe lw lx ly lz b">yield</code>是最有趣的一个——也是我个人非常喜欢的一个。</p><p id="d949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在英语中,“yield”这个词作为动词有两个基本意思:</p><ol class=""><li id="94df" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">生产或提供。</li><li id="427a" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">让路。</li></ol><p id="2f11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">巧合的是(或者可能根本不是)，Python中的关键字<code class="fe lw lx ly lz b">yield</code>有与这两种含义相关的使用上下文。在本文中，我想讨论利用<code class="fe lw lx ly lz b">yield</code>的特定Python特性。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="8766" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">在生成器函数中生成值</h1><p id="c5ce" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">您第一次在Python中看到使用<code class="fe lw lx ly lz b">yield</code>可能是在一个生成器函数中。大概是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个简单的生成器函数</p></figure><p id="8b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数的调用是为了创建一个生成器。生成器是Python中一种特殊的迭代器。它们具有惰性评估的优势，即在迭代需求出现之前生成适用的值。下面的代码片段展示了一个简单的例子，它在一个<code class="fe lw lx ly lz b">for</code>循环中利用这个生成器函数来执行迭代工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用发电机的For循环</p></figure><p id="dec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地说明<code class="fe lw lx ly lz b">yield</code>的作用，让我们在原来的生成器函数中添加一些<code class="fe lw lx ly lz b">print</code>函数调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能知道，当我们有一个生成器时，我们可以使用<code class="fe lw lx ly lz b">next()</code>函数来检索生成器的下一项，这允许我们仔细检查<code class="fe lw lx ly lz b">yield</code>的用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发电机的逐步运行</p></figure><ul class=""><li id="6a6f" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu nu mg mh mi bi translated">当我们通过调用<code class="fe lw lx ly lz b">generator</code>函数获得生成器时，函数本身并不立即执行。相反，它只是创建了<code class="fe lw lx ly lz b">generator</code>对象，而没有运行代码。这是发电机的初始状态。</li><li id="ca6b" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">当我们得到生成器的第一项时，函数开始执行。当执行遇到<code class="fe lw lx ly lz b">yield</code>语句时，它产生该项(即字符串值)。</li><li id="4acd" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">重要的是，<code class="fe lw lx ly lz b">generator</code>函数在产生值后停止执行。当我们再次调用<code class="fe lw lx ly lz b">next()</code>函数时，执行从停止的地方继续。在我们的例子中，您会注意到<code class="fe lw lx ly lz b">After yielding…</code>被打印出来。</li><li id="bebb" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">当生成器产生所有的项目(三个项目)并且我们第四次调用<code class="fe lw lx ly lz b">next()</code>函数时，尽管<code class="fe lw lx ly lz b">generator</code>函数继续从它停止的地方运行，它将引发<code class="fe lw lx ly lz b">StopIteration</code>异常。值得注意的是，当我们在<code class="fe lw lx ly lz b">for</code>循环中使用生成器时，我们看不到这一点，因为Python为我们处理了这一点。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="e28b" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">在协程中暂停和恢复执行</h1><p id="d584" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><em class="lv">注意:重要的是要知道Python正在逐步淘汰使用生成器作为协程的基础。查看</em> <a class="ae ky" href="https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines" rel="noopener ugc nofollow" target="_blank"> <em class="lv">官方文档</em> </a> <em class="lv">。但是，如果我们知道</em> <code class="fe lw lx ly lz b"><em class="lv">yield</em></code> <em class="lv">有“让路”的意思，那么协程的概念就很容易理解了。</em></p><p id="9fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个用法中，它适用于<code class="fe lw lx ly lz b">yield</code>的第二个意思:让路。这很像现实生活中的交通“让行”标志。你暂时停下你的车，让其他有先行权的车辆先行。将这种模拟应用于编程，这是<a class="ae ky" href="https://en.wikipedia.org/wiki/Coroutine" rel="noopener ugc nofollow" target="_blank">协程</a>的基本思想。</p><p id="cab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，协程的关键是执行被暂时挂起，以后在适用的时候可以继续执行。你不觉得这听起来很熟悉吗？<code class="fe lw lx ly lz b">generator</code>函数运行并产生元素(暂停执行)，当请求下一个元素时，它从暂停的地方继续运行(恢复执行)。</p><p id="0c35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我们可以使用<code class="fe lw lx ly lz b">yield</code>关键字来实现一个协程。让我们看看下面的代码片段，这是一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><ul class=""><li id="5467" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu nu mg mh mi bi translated">我们首先使用关键字<code class="fe lw lx ly lz b">yield</code>定义一个协程函数。可以看到，整体结构类似于<code class="fe lw lx ly lz b">generator</code>函数。然而，你会注意到<code class="fe lw lx ly lz b">yield</code>关键字出现在赋值操作符(即等号)之后。</li><li id="923d" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">这种分配是可能的，因为除了与生成器一起工作的典型的<code class="fe lw lx ly lz b">next()</code>功能之外，生成器还支持<code class="fe lw lx ly lz b">send()</code>功能。</li><li id="ce3d" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">在示例中，我们将一个字符串数据(即<code class="fe lw lx ly lz b">“Here’s the data that your requested.”</code>)发送回协程。具体来说，我们发送的数据被设置为变量<code class="fe lw lx ly lz b">x</code>，我们能够按预期打印出<code class="fe lw lx ly lz b">x</code>的值。</li><li id="a070" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated"><code class="fe lw lx ly lz b">StopIteration</code>异常是意料之中的，因为<code class="fe lw lx ly lz b">generator</code>函数已经到达末尾，这与生成器的行为一致(如上一节所示)。</li></ul><p id="de64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe lw lx ly lz b">send()</code>函数，还有几个与Python生成器相关的显著特性。请查看<a class="ae ky" href="https://medium.com/better-programming/python-7-advanced-features-that-you-may-not-know-about-generators-574a65fd6e45" rel="noopener">这篇关于发电机高级特性的文章</a>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="490c" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">在你走之前</h1><p id="18da" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在本文中，我们回顾了在Python中使用<code class="fe lw lx ly lz b">yield</code>关键字的两个重要含义——生成器和协程。这里有一个快速回顾:</p><ul class=""><li id="0f86" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu nu mg mh mi bi translated">生成器是延迟求值的迭代器。使用<code class="fe lw lx ly lz b">yield</code>关键字主要意味着<code class="fe lw lx ly lz b">generator</code>函数可以根据需要产生元素。</li><li id="1e4b" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">协程是一种特殊的编程技术，在异步编程(如HTTP请求)中特别有用。所示的例子只是为了让您了解协程在概念上是如何工作的。本质上，关键词<code class="fe lw lx ly lz b">yield</code>主要意思是“让路”。执行被暂时挂起，这允许其他任务运行(例如HTTP请求)。当我们取回数据时，执行可以继续，数据被发送回协程(例如，来自请求的数据)。</li></ul></div></div>    
</body>
</html>