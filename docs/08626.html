<html>
<head>
<title>4 Best Practices To Create Command-Line Interfaces in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python创建命令行界面的4个最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-best-practices-to-create-command-line-interfaces-in-python-5043fbb7c52b?source=collection_archive---------2-----------------------#2021-05-24">https://betterprogramming.pub/4-best-practices-to-create-command-line-interfaces-in-python-5043fbb7c52b?source=collection_archive---------2-----------------------#2021-05-24</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9ada" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">展示如何用Python实现命令行接口的真实例子</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/5b891a800be8675287e2b50f9e4627d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipJYVn4URxV_ipH1W5a-pQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用VSCode为您的Python脚本创建命令行界面</p></figure><p id="4742" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你像我一样，你可能有很多Python脚本来自动完成无聊的任务。我的大多数脚本使用硬编码的路径和选项。如果我需要它们，我会在代码编辑器中打开它们，并进行必要的修改。</p><p id="1c19" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是，有更好的办法。通过投入更多的时间来参数化这些脚本，您可以重用它们，而不必每次都修改它们。</p><p id="b898" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们将通过添加命令行界面来参数化这些脚本。</p><p id="44f6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们将讨论并构建以下四个选项:</p><ol class=""><li id="fc05" class="lv lw iu lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">手动解析和处理命令行参数</li><li id="96c0" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用内部Python库argparse</li><li id="3f15" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用外部Python库Click</li><li id="9caf" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用Typer，另一个外部Python库</li></ol><p id="ac00" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">你可以在Github库中找到这些解决方案的源文件。</p><h1 id="2084" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">脚本，生成软件许可证</h1><p id="f724" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">我们将使它变得更有趣，而不是使用另一个hello world演示。我们将使用一个真实的例子。我们将创建一个脚本，您可以使用它来创建软件许可证。</p><p id="d020" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以使用软件许可证来保护软件的使用或再分发。软件许可证可以采取多种形式。我们将使用一个文件，您必须在使用它的软件旁边分发该文件。</p><p id="2b10" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有两部分。首先，是生成软件许可证的应用程序。其次，应用程序只有在能够访问软件许可证的情况下才能运行。</p><p id="68b5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在本文中，我们将讨论第一部分:生成包含软件许可证的文件的Python脚本。</p><p id="31a2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该程序需要以下信息来生成软件许可证。</p><ul class=""><li id="5ef6" class="lv lw iu lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated">MAC地址—运行程序的机器的MAC地址</li><li id="150e" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">开始日期—许可证开始生效的日期</li><li id="d2e7" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">结束日期—许可证有效的截止日期</li><li id="6883" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">功能—客户可以使用的功能列表</li><li id="6d10" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">版本—使用此许可证的应用程序的版本</li><li id="5aad" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu nh mb mc md bi translated">系统Id —系统的标识</li></ul><p id="8329" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">许可证文件以加密方式存储这些信息。加密密钥是MAC地址和固定密码的组合。</p><p id="d13a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当应用程序启动时，它获取系统的MAC地址并解密许可证。然后，它验证信息，如开始和结束日期。</p><h2 id="a60b" class="ni ml iu bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated">脚本的实现</h2><p id="e55c" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">该脚本的第一个实现没有命令行界面。如果你想创建一个许可证，改变参数<code class="fe nu nv nw nx b">create_license_file</code>并运行脚本。</p><p id="b72a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该脚本在第7行创建了一个包含必要信息的字典。然后我们把这本字典翻译成JSON。</p><p id="06b9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">应用程序使用由MAC地址和固定令牌组成的加密密钥对JSON进行加密。最后，我们将加密字符串写入许可证文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">用于生成软件许可证的Python脚本</p></figure><h1 id="38f1" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">手动解析和处理命令行参数</h1><p id="1b3e" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">我们将要构建的第一个命令行界面不会使用任何外部模块；我们将自己进行解析和验证。</p><p id="c126" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我们开始之前，我们首先要谈一谈<code class="fe nu nv nw nx b">sys.argv</code>。这个全局变量包含传递给Python脚本的命令行参数列表。索引0处的第一项<code class="fe nu nv nw nx b">sys.argv[0]</code>，包含您的脚本的名称。</p><p id="73ca" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们来看一个小例子。我们像Python中的其他列表一样遍历<code class="fe nu nv nw nx b">sys.argv</code>,并打印每一项。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">展示sys.argv的小演示</p></figure><p id="df83" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当我们运行这个程序时，我们得到以下结果。你看到<code class="fe nu nv nw nx b">sys.argv</code>中的第一项是脚本本身的名字。以下是传递的参数。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oa"><img src="../Images/53d26ded909aa5c87dd7d06eac64d179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GmRisNELN2lHK71fHcqR6A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">显示sys.argv的内容</p></figure><p id="83c7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">需要记住的一点是<code class="fe nu nv nw nx b">sys.argv</code>是全球性的。一个好的做法是在更改它之前制作一个副本。</p><h2 id="8c05" class="ni ml iu bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated">命令行界面的结构</h2><p id="caa4" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">在开始解析和验证命令行参数之前，我们必须考虑结构。我们需要什么参数，如何给它们命名？我们将使用最佳实践，而不是提出我们自己的版本。</p><p id="26c1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们将使用<a class="ae mj" href="https://clig.dev/" rel="noopener ugc nofollow" target="_blank">命令行界面指南</a>中描述的结构。这是一个帮助编写更好的命令行程序的开源指南。</p><p id="416d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">指南中描述的一些准则。</p><h2 id="6ec4" class="ni ml iu bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated">基本准则</h2><p id="800d" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">您的脚本应该在成功时返回一个零退出代码。如果失败，它应该返回一个非零退出代码。</p><p id="157e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您应该将所有主要输出发送到<code class="fe nu nv nw nx b">stdout</code>。日志消息和错误应发送到<code class="fe nu nv nw nx b">stderr</code>。</p><h2 id="ce6a" class="ni ml iu bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated">显示帮助</h2><p id="c22a" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">CLI指导方针声明的另一件事是，当没有传递选项或使用了<code class="fe nu nv nw nx b">-h</code>或<code class="fe nu nv nw nx b">--help</code>标志时，您的程序应该显示帮助文本。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/426b5f7ed4c5b84bcbf5478724645c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BECJB3fmge-PKev3rXbZ1A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用-h或-help时显示帮助</p></figure><h2 id="65ca" class="ni ml iu bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated">解析命令行参数并遵守准则</h2><p id="e121" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">现在是时候实现解析参数并应用指导方针了。</p><p id="8418" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面你可以看到接受<code class="fe nu nv nw nx b">sys.argv</code>并返回LicenseInformation类的方法。该类的成员拥有程序存储在许可证文件中的所有信息。</p><p id="b43a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果不提供任何参数，该函数将打印帮助字符串，并以退出代码0退出程序。</p><p id="1d66" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果有争论，我们用<code class="fe nu nv nw nx b">collection.deque</code>。Deque是一个双端队列。双端意味着您可以从队列的任意一端弹出项目。在我们的例子中，我们想从左边开始，所以我们使用<code class="fe nu nv nw nx b">popleft</code>。代码如下:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用collections.deque解析命令行参数</p></figure><p id="1abc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们使用<code class="fe nu nv nw nx b">parse</code>返回的类来创建实际的许可证文件。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用LicenseInformation类创建许可证文件</p></figure><p id="1143" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">只有系统id和MAC地址是必需的。其他参数将获得默认值。默认值被添加到<code class="fe nu nv nw nx b">LicenseInformation</code>类的构造函数中。代码如下:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">保存可选参数默认值的LicenseInformation类</p></figure><h2 id="8cd3" class="ni ml iu bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated">确认</h2><p id="5462" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">直到现在，我们还没有验证给定的论点。例如，我们可以验证用户是否提供了两个必需的参数——系统id和MAC地址。我们还可以确保MAC地址的格式正确。</p><p id="06c5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">此外，我们可以确保开始和结束日期的格式正确，并且结束日期在开始日期之后。</p><p id="2b9a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我不会添加这些验证，因为如您所见，源代码的数量会迅速增加。添加验证会使代码更加复杂。</p><p id="87b9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们将把验证留到下一个例子中，在那里我们将使用Python模块。这让生活变得容易多了。</p><h1 id="7792" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">使用内部Python库argparse</h1><p id="a01a" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">Python在3.2版中引入了<code class="fe nu nv nw nx b">argparse</code>模块。这是一个内部模块，可以轻松编写用户友好的命令行界面。</p><p id="4128" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要使用它，您必须执行以下步骤:</p><ol class=""><li id="4ea8" class="lv lw iu lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">导入Python <code class="fe nu nv nw nx b">argparse</code>库</li><li id="3d81" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建解析器</li><li id="d9c5" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">向解析器添加可选参数和位置参数</li><li id="d673" class="lv lw iu lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">执行<code class="fe nu nv nw nx b">.parse_args()</code></li></ol><p id="3c8c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们看看如何使用<code class="fe nu nv nw nx b">argparse</code>为软件许可程序创建命令行界面。</p><p id="9464" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">首先，我们创建一个<code class="fe nu nv nw nx b">argparse.ArgumentParser</code>的实例，给出用法和描述。然后，我们通过调用解析器上的<code class="fe nu nv nw nx b">add_argument</code>逐个添加所有参数。我们告诉它参数的类型，以及是否需要。代码如下:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">创建ArgumentParser来解析软件许可证的选项</p></figure><p id="58f9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe nu nv nw nx b">parse_args</code>返回的对象可用于获取解析后的参数值。我们将这个<code class="fe nu nv nw nx b">args</code>对象传递给<code class="fe nu nv nw nx b">create_license</code>函数。然后，我们通过指定像<code class="fe nu nv nw nx b">args.m</code>这样的字段来获得各个参数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用args对象创建许可证文件</p></figure><p id="386e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在，当我们在没有参数的情况下运行程序时，我们会得到下面的输出。它显示用法信息，并显示一条错误消息，指出没有给出所有必需的参数。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oc"><img src="../Images/96c2c13a33f8e164c804d0d04c28c4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJJgeKEwp-5xxBL8GhZ6PA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">当没有参数时，argparse显示所需的参数</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj od"><img src="../Images/4e8b8396d38886ef92841e11296f6180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5419HAX4m-J-bPMtch7DQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">—帮助显示应用程序的用法和帮助</p></figure><p id="7f71" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是对我们手工解析器的一个很大的改进。这个程序更容易扩展和修改。它使用您给<code class="fe nu nv nw nx b">add_argument</code>的参数来自动执行验证</p><h1 id="9d50" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">使用外部Python库Click</h1><p id="0f85" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">虽然<code class="fe nu nv nw nx b">argparse</code>是一个内部库，但是<a class="ae mj" href="https://click.palletsprojects.com/en/8.0.x/" rel="noopener ugc nofollow" target="_blank"> Click </a>是一个Python包，你必须使用<code class="fe nu nv nw nx b">pip</code>来安装。这是使用外部库的缺点之一。</p><p id="ba85" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Click是一个包，它可以帮助您用尽可能少的代码创建漂亮的命令行界面。这是<a class="ae mj" href="https://clig.dev/" rel="noopener ugc nofollow" target="_blank">命令行界面指南</a>推荐用于Python的包之一。</p><p id="5389" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Click使用decorators来定义命令和参数。因此，我们更改了<code class="fe nu nv nw nx b">create_license_file</code>，并在函数中添加了装饰器。</p><p id="0814" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们将<code class="fe nu nv nw nx b">required=True</code>添加到MAC地址和系统Id中，以确保这些参数是必需的。代码如下:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">向create_license_file函数添加click decorators</p></figure><p id="0c38" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当我们在没有任何参数或<code class="fe nu nv nw nx b">--help</code>的情况下执行脚本时，我们会得到下面的结果。单击报告缺少的参数，并在询问时显示帮助控制台。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/a845759aa2dfc2f6c577bb087f6d33cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bqc6EaLo-ZUfIJGlinvARg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用Click实现时运行脚本</p></figure><p id="a9f7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果我们将点击实现的代码行数(34行)与手动实现的代码行数(90行)进行比较，我们会发现我们将其减少了一半——这是一个相当大的改进。</p><h1 id="990c" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">使用外部Python库Typer</h1><p id="be7c" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">命令行界面指南推荐用于Python的另一个外部库是<a class="ae mj" href="https://typer.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> Typer </a>。有趣的是Typer是建立在点击之上的。</p><p id="856d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面你会看到一个简单的例子。Click和Typer的区别在于Typer使用类型提示。所以，你必须添加参数的类型。您可以在第3行看到<code class="fe nu nv nw nx b">name</code>参数的<code class="fe nu nv nw nx b">str</code>类型:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">一个使用Typer的小例子</p></figure><h2 id="70ef" class="ni ml iu bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated">使用Typer转换软件许可证脚本</h2><p id="d2c0" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">下面是使用Typer创建软件许可证的完整脚本。我更改了<code class="fe nu nv nw nx b">create_license_file</code>的参数名，使它们更具描述性。Typer在命令行中使用这些名称作为参数。代码如下:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用Typer的完整实现</p></figure><p id="70a1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在，这是您使用Typer创建命令行界面唯一需要更改的内容。如果我们不带任何参数运行脚本，我们会得到以下结果。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj of"><img src="../Images/fc190e978d1963d4b3a7129ff2f8d5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MTXnN8QgQWK16h0Pfj-QTQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">运行使用不带参数的Typer创建的软件许可脚本</p></figure><p id="10c2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果没有为参数提供默认值，Typer会认为它们是必需的。命令行上不需要任何选项。Typer假设第一个参数是MAC地址，第二个参数是系统id。</p><p id="b670" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当我们使用<code class="fe nu nv nw nx b">--help</code>时，Typer也会生成一个漂亮的用法/帮助界面，如下图所示。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/40e94ab4f803c5fcdc14ada346e82317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dC0JqQPs8yaaXJJZRFYCgw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">帮助屏幕，键入为软件许可证脚本生成的内容</p></figure><h1 id="56f3" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">结论</h1><p id="d14a" class="pw-post-body-paragraph kz la iu lb b lc nc jv le lf nd jy lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">本文向您展示了如何将用于自动化枯燥任务的脚本转换成具有成熟且用户友好的命令行界面的优秀的全功能程序。</p><p id="fc6d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你不想给你的脚本添加一个外部依赖，你应该使用<code class="fe nu nv nw nx b">argparse</code>。这个内部Python库使得向脚本添加命令行界面变得很容易。</p><p id="0131" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你不介意有一个外部依赖，那么<a class="ae mj" href="https://click.palletsprojects.com/en/8.0.x/" rel="noopener ugc nofollow" target="_blank">点击</a>包是一个很好的选择。通过向函数中添加装饰器，可以快速地向脚本中添加用户友好的命令行界面。</p><p id="522a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们最后展示了<a class="ae mj" href="https://typer.tiangolo.com/" rel="noopener ugc nofollow" target="_blank">打字机</a>。Typer也是一个外部库。它基于点击，使用打字来创建命令行界面，甚至更容易。</p><p id="8fa2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">你可以在Github库中找到这些例子的源代码。</p><p id="8cf1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>