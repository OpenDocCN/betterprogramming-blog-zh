<html>
<head>
<title>How to Guide the Compiler to Speed up Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何引导编译器加速你的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/guide-the-compiler-to-speed-up-your-code-655c1902b262?source=collection_archive---------3-----------------------#2022-04-09">https://betterprogramming.pub/guide-the-compiler-to-speed-up-your-code-655c1902b262?source=collection_archive---------3-----------------------#2022-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">现代编译器相当聪明。但有时，他们很难找到最佳的优化方案。这对我们有好处，我们可以在这方面进一步指导他们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a790bbac5f5118b0ae12527c309029d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DFhd_UuGPS8dh2-C"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/photos/ioYwosPYC0U" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@betagamma" rel="noopener ugc nofollow" target="_blank"> Daniil Sitantev </a>拍摄的照片。</p></figure><p id="c29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现代编译器不只是编译我们的代码，从某种高级语言到汇编语言(或机器可读指令)都是如此。他们花费大量的时间和精力来优化我们的代码，以达到最佳性能。</p><p id="5fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当正确的标志被提供给编译器时，这当然是允许的。相反，您可以指示编译器针对二进制文件大小或编译延迟进行优化(<a class="ae ky" href="https://stackoverflow.com/a/15548189/2614250" rel="noopener ugc nofollow" target="_blank">阅读更多信息</a>)。</p><p id="1b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将重点关注优化运行时性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><blockquote class="mc md me"><p id="50c6" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">免责声明:</p><p id="5ff4" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">本文中的大多数例子都使用C++，但我相信内容对每个人都有用。</p><p id="7a80" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">这篇文章的内容并不反映我工作的组织，而是我自己的。</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dbbd" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">现代CPU</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/832ad8c4b1cebe95c154e1e4ebe76063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RNz3BkKp6CFjYMd9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Francesco Vantini 在<a class="ae ky" href="https://unsplash.com/photos/ZavLsrP4CDI" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="79e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说一点现代的CPU。这是学校经常教的，但我们往往会忘记。</p><h2 id="483a" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">SIMD对SISD</h2><p id="a198" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/SISD" rel="noopener ugc nofollow" target="_blank"> SISD </a>代表<strong class="lb iu">单指令流，单数据流</strong>。通常，程序代码是按顺序执行的，即一个接一个地执行。假设我们有两个数组<code class="fe ns nt nu nv b">a</code>和<code class="fe ns nt nu nv b">b</code>，我们想写一个程序，用下面的操作转换<code class="fe ns nt nu nv b">a</code>中的每个元素:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="31ad" class="nb mk it nv b gy oa ob l oc od">a[i] = a[i] + b[i];</span></pre><p id="f064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于数组中的每个索引<code class="fe ns nt nu nv b">i</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/048e449667d96782dac0e3edbb486361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/0*MvjTB1PzwCXv3YKP.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何交换算法的可视化将在SISD CPU上工作。来源:Github上的开源库—<a class="ae ky" href="https://github.com/Wunkolo/qreverse" rel="noopener ugc nofollow" target="_blank">Wunkolo/qreverse</a>(MIT许可证)。</p></figure><p id="223b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们经常看到的代码在CPU上执行的方式。我们倾向于优化大欧米茄-是的，这是正确的做法。</p><p id="59d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是现代的CPU可以做的更好！</p><p id="d4f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现代CPU具备支持<a class="ae ky" href="https://en.wikipedia.org/wiki/SIMD" rel="noopener ugc nofollow" target="_blank"> SIMD </a>的能力，后者代表单指令多数据。这样的机器可以表现出数据级的并行性(不同于并发性)。他们可以一次对多个数据执行相同的指令。</p><p id="53c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于上面的示例，SIMD CPU可以分组并在一个批处理中执行操作，如下所示:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="5326" class="nb mk it nv b gy oa ob l oc od">a[0] = a[0] + b[0];<br/>a[1] = a[1] + b[1];<br/>a[2] = a[2] + b[2];<br/>a[3] = a[3] + b[3];</span></pre><p id="ed3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">+的SIMD指令在<a class="ae ky" href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" rel="noopener ugc nofollow" target="_blank"> SSE </a>中被称为<code class="fe ns nt nu nv b"><em class="mf">addps</em></code>或者在<a class="ae ky" href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions" rel="noopener ugc nofollow" target="_blank"> AVX </a>中被称为<code class="fe ns nt nu nv b"><em class="mf">vaddps</em></code>，它们分别支持4元素和8元素的分组(整型)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9eb5bd2bd2cf09b3e54947c5b8be5b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/0*G28i9d6A6rvWr9_b.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何交换算法的可视化将在SIMD CPU上工作。来源:Github上的开源库—<a class="ae ky" href="https://github.com/Wunkolo/qreverse" rel="noopener ugc nofollow" target="_blank">Wunkolo/qreverse</a>(MIT许可证)。</p></figure><blockquote class="of"><p id="c195" class="og oh it bd oi oj ok ol om on oo lu dk translated">你看，如果你能告诉CPU以这种方式运行算法，你的代码运行速度会提高K倍。</p></blockquote><p id="c7e2" class="pw-post-body-paragraph kz la it lb b lc op ju le lf oq jx lh li or lk ll lm os lo lp lq ot ls lt lu im bi translated">不要担心！你可以——有一些内部函数允许你告诉机器去做向量运算(SIMD ),而不是标量运算。</p><p id="eedf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个代码示例</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Neon内部函数将两个数组的和计算到“target”数组中的代码示例。</p></figure><p id="e03d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">告诉我谁不想这样写代码——看起来绝对可爱！</p><p id="4a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我没有！</p><p id="30ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要获得更多的领域知识，并且通常不容易维护。有一种方法既可以编写可维护的代码，又可以编写高性能的代码——但这是另一个晚上的主题(将在此更新)！</p><p id="1814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的一面是，通常你不需要直接用向量内部函数来编写代码来实现性能目标。这就把我带到了下一个话题——“向量化<strong class="lb iu"/>”。</p><h2 id="222a" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">…向量化…</h2><p id="99db" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">SIMD支持可以对向量数据类型进行操作的指令。在上面的例子中，一组像<code class="fe ns nt nu nv b">a[0...3]</code>或<code class="fe ns nt nu nv b">b[4...7]</code>这样的数组元素可以称为向量。</p><p id="6809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向量化是使用向量指令来加速程序执行。</p><p id="0398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">矢量化既可以由程序员通过显式编写矢量指令来完成，也可以由编译器直接完成。后一种情况被称为<code class="fe ns nt nu nv b">Auto Vectorization</code>。</p><p id="b91f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自动矢量化可以由提前(AOT)编译器在编译时完成，也可以由实时(JIT)编译器在执行时完成。</p><h2 id="07c9" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">循环展开</h2><p id="5db5" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Loop_unrolling" rel="noopener ugc nofollow" target="_blank">循环展开</a>或循环展开是一种循环转换技术，试图以二进制大小为代价优化程序的执行速度。</p><p id="9d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环展开的目标是通过减少或消除控制循环的指令来提高程序的速度，例如指针算法和每次迭代的循环结束测试。</p><p id="0270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环展开的一个简单示例是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">循环展开——展开的循环看起来很糟糕，对吗？它们通常有助于提高性能！</p></figure><p id="6b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的后半部分，我将分享这两个方面的一些性能数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c356" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">现代编译器</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/ffb72aaf3e1b80f0f924dcfee3e2a26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o80JtuIle7x3Bvs1RYLK2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Mac上的gcc图片由作者提供。</p></figure><p id="caae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现代C++编译器拥有代码优化技术，如<a class="ae ky" href="https://llvm.org/docs/Vectorizers.html#loop-vectorizer" rel="noopener ugc nofollow" target="_blank">循环矢量器</a>，它允许编译器为以标量格式编写的代码生成矢量指令。</p><p id="658a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的标量代码经常在CPU中作为向量指令运行！Phewww！</p><p id="4948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这取决于代码是如何编写的——让编译器理解它是否能<code class="fe ns nt nu nv b">auto-vectorize</code>代码。有时，编译器无法确定对某个循环进行矢量化是否安全。循环展开也是如此。</p><p id="710a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，不用担心！有一些方法可以指导你的编译器使用这些优化进行编译是安全的。</p><p id="cdd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的技术应该适用于能够生成Neon代码的特定编译器组(阅读下文更多内容)，如<a class="ae ky" href="https://gcc.gnu.org/onlinedocs/" rel="noopener ugc nofollow" target="_blank"> GCC </a>、<a class="ae ky" href="https://clang.llvm.org/" rel="noopener ugc nofollow" target="_blank"> LLVM-clang </a>(用于Android NDK)和<a class="ae ky" href="https://developer.arm.com/documentation/101458/2100" rel="noopener ugc nofollow" target="_blank"> Arm C/C++编译器</a>。</p><h1 id="c2fa" class="mj mk it bd ml mm ox mo mp mq oy ms mt jz oz ka mv kc pa kd mx kf pb kg mz na bi translated">指导编译器更好地自动矢量化</h1><p id="d00b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了演示，我将使用问题陈述—将YUV图像格式的图像转换为ARGB图像格式。为了评估性能，我将使用<a class="ae ky" href="https://www.gsmarena.com/google_pixel_4a-10123.php" rel="noopener ugc nofollow" target="_blank"> Pixel 4a </a>(一个Android设备)。</p><p id="6231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将YUV图像转换为ARGB的代码示例。默认情况下，该算法以行为主的方式迭代图像上的每个像素。</p></figure><p id="b2a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Pixel 4a设备上，对于一个8 MP的图像(<code class="fe ns nt nu nv b">3264x2448 = ~8 million pixels</code>)——运行上面的代码，我得到了以下数字作为平均运行时延迟。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/e33b54d0056e9507df49ffc6b618785c.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*jxBWhPxVdmhkxnfS6zTDXA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在800万像素图像的像素4A上运行上述代码的平均延迟。</p></figure><p id="ec58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，编译器已经在尝试优化代码了。它使用<code class="fe ns nt nu nv b">-O3</code>编译标志运行(即针对二进制大小或编译时间的速度进行了优化)。此标志启用了自动矢量化。</p><h2 id="81b1" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">杂注声明— <code class="fe ns nt nu nv b">loop vectorize</code></h2><p id="eaa3" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在for循环之前使用下面的<code class="fe ns nt nu nv b">#pragma</code>声明向编译器表明，下面的循环不包含会阻止自动向量化的数据依赖:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="17e2" class="nb mk it nv b gy oa ob l oc od">#pragma clang loop vectorize(assume_safety)</span></pre><blockquote class="mc md me"><p id="cec9" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated"><em class="it">重要提示:确保仅在安全的情况下使用此编译指示，否则可能会导致争用情况。</em></p></blockquote><p id="f6eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以如果我们像这样把它放到上面的例子中</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何在循环顶部添加#pragma指令的示例</p></figure><p id="5716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下平均延迟数字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/f490a23d2af86fc83822b1d3c5a5e501.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*bKv6uj7UMCO2M01Sm_809g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过在循环顶部添加这条单行指令，速度提高了11.4%。</p></figure><h2 id="7f4e" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">杂注声明— <code class="fe ns nt nu nv b">loop unroll</code></h2><p id="2d7e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">类似地，我们可以指示编译器在用下面的语句编译时展开循环:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="aba8" class="nb mk it nv b gy oa ob l oc od">#pragma clang loop unroll_count(2)</span></pre><p id="2ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以如果我们像这样把它放到上面的例子中</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何在for循环的不同阶段添加#pragma指令的示例。</p></figure><p id="455e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下平均延迟数字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/5dd58b75ca01de76be9157f0d7abd2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*uGRKVymTV-xR_2TPDcyOUA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过添加循环向量化和循环展开指令(增加2行代码)，速度提高了18.5%。</p></figure><p id="03b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">unroll_count(N)</code>中的整数基本上指导编译器展开多少——你可以用不同的数字进行基准测试，找出最好的一个。</p><p id="73c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，用2行代码和不到1个小时的努力，整体速度提高了18+%!生成的代码易于阅读和维护。</p><h2 id="899a" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">其他一些提示:</h2><ol class=""><li id="8e21" class="pe pf it lb b lc nn lf no li pg lm ph lq pi lu pj pk pl pm bi translated">与<code class="fe ns nt nu nv b">&lt;=</code>或<code class="fe ns nt nu nv b">!=</code>相比，更喜欢使用<code class="fe ns nt nu nv b">&lt;</code>来构建循环。</li><li id="cbd3" class="pe pf it lb b lc pn lf po li pp lm pq lq pr lu pj pk pl pm bi translated">使用<code class="fe ns nt nu nv b">-ffast-math</code>选项可以显著提高生成代码的性能，只要算法能够容忍潜在的不准确性，因为它违反了IEEE和ISO数学运算标准。</li></ol><h2 id="44b9" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">TL；DR；</h2><p id="1506" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">通过使用这些指导编译器更好地优化代码的指令，您可以在代码中获得有意义的全面加速。</p><p id="d6e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所用的例子中，我可以用2行额外的代码获得大约<code class="fe ns nt nu nv b">18%+</code>的加速，并且代码比直接使用矢量语法的代码更容易阅读和维护。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe53" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结束语</h1><p id="2984" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这种方法的最终加速取决于数据相对于算法的独立性。</p><p id="8972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好的方法是总是尝试和基准。性能提升(如果有的话)绝对值得工程时间成本。</p><p id="77cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我计划写更多关于在不牺牲代码可维护性的情况下提高性能的方法。其中很多都来自于我在谷歌学到的东西和我的爱好项目。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b80" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">【额外奖励】附加阅读！</h1><p id="adb9" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在这一节中，我将对一些无法解释的概念进行更多的描述。</p><h2 id="07cd" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">氖</h2><p id="be30" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><em class="mf">不是我们的贵气哥们！</em> Neon是Arm高级SIMD架构的实现。Neon的目的是通过提供以下功能来加速数据操作:</p><ol class=""><li id="b914" class="pe pf it lb b lc ld lf lg li ps lm pt lq pu lu pj pk pl pm bi translated">32个128位向量寄存器，每个能够包含多个数据通道。</li><li id="8dd3" class="pe pf it lb b lc pn lf po li pp lm pq lq pr lu pj pk pl pm bi translated">SIMD指令来同时操作这些多路数据。</li></ol><p id="9579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.arm.com/documentation/102467/0100/What-is-Neon-" rel="noopener ugc nofollow" target="_blank">来源:developer.arm.com</a></p><p id="f7bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据文档，有多种方法可以利用该技术:</p><ol class=""><li id="3228" class="pe pf it lb b lc ld lf lg li ps lm pt lq pu lu pj pk pl pm bi translated">使用支持Neon的开源库。我们都喜欢这个！</li><li id="4ec0" class="pe pf it lb b lc pn lf po li pp lm pq lq pr lu pj pk pl pm bi translated">编译器中的自动向量化特性可以利用Neon。</li><li id="9d81" class="pe pf it lb b lc pn lf po li pp lm pq lq pr lu pj pk pl pm bi translated">使用<a class="ae ky" href="https://developer.arm.com/architectures/instruction-sets/intrinsics/" rel="noopener ugc nofollow" target="_blank"> Neon内部函数</a> —编译器会用适当的Neon指令替换它们。这给了我们从<code class="fe ns nt nu nv b">C/C++</code>代码中直接低级访问我们想要的Neon指令的机会。</li><li id="9509" class="pe pf it lb b lc pn lf po li pp lm pq lq pr lu pj pk pl pm bi translated">直接用Neon写汇编代码，只对真正有经验的程序员有效。</li></ol><h1 id="7512" class="mj mk it bd ml mm ox mo mp mq oy ms mt jz oz ka mv kc pa kd mx kf pb kg mz na bi translated">参考</h1><ol class=""><li id="0768" class="pe pf it lb b lc nn lf no li pg lm ph lq pi lu pj pk pl pm bi translated"><a class="ae ky" href="https://developer.arm.com/documentation/102467/0100/What-is-Neon-" rel="noopener ugc nofollow" target="_blank">霓虹是什么？</a></li><li id="f6f6" class="pe pf it lb b lc pn lf po li pp lm pq lq pr lu pj pk pl pm bi translated"><a class="ae ky" href="https://developer.arm.com/documentation/102525/0100/Coding-best-practices-for-auto-vectorization" rel="noopener ugc nofollow" target="_blank">自动矢量化的编码最佳实践</a></li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="883d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mf">原发布于</em><a class="ae ky" href="https://blog.minhazav.dev/guide-compiler-to-auto-vectorise/" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://blog . minhazav . dev</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>