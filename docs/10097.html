<html>
<head>
<title>Patch Gaps in Current Compose API Using Reflection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用反射修补当前合成API中的缺口</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-reflection-to-patch-gaps-in-current-compose-apis-4c5aabc363b3?source=collection_archive---------0-----------------------#2021-11-28">https://betterprogramming.pub/using-reflection-to-patch-gaps-in-current-compose-apis-4c5aabc363b3?source=collection_archive---------0-----------------------#2021-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="16d0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">修正了一个小问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6c841617bdff8daf421c7fa0698d7ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TII3Cf0V8QKOvSSS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">谢尔盖·库图佐夫在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="b546" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我决定用Jetpack Compose重新设计一个旧的Android应用程序。新的合成系统是对以前的视图系统的重大改进，但它仍然是相当新的，有一些缺失的功能。我遇到的一个这样的缺口是在<code class="fe ls lt lu lv b">androidx.compose.material</code>库中的<code class="fe ls lt lu lv b">OutlinedTextField</code> composable中，它没有提供修改轮廓默认宽度的方法。当然，这没什么大不了的，但它不符合我的应用程序的整体主题，所以我决定使用反射来解决这个小问题。我已经记录了我的方法和最终的函数，我在应用程序启动时调用它来进行修改。</p><p id="8195" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有许多支持和反对使用反射的论点，我在这里不打算深入讨论，但是像我在这里描述的这种琐碎的使用并不危险，也没有任何显著的运行时性能成本。当然，如果有一种替代的方式来实现同样的行为，我会选择那种方式，但在这种情况下没有，因为<code class="fe ls lt lu lv b">OutlinedTextField</code>是图书馆的一部分。</p><h1 id="fec7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">反射基础</h1><p id="f805" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们将在JVM平台的上下文中讨论反射，但是在Android上使用Kotlin和Java来执行。</p><p id="69a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，反射允许我们在运行时自省我们的程序，并修改属性、字段、方法和其他语言结构。这不仅包括<code class="fe ls lt lu lv b">public</code>属性，还包括标记为<code class="fe ls lt lu lv b">internal</code>或<code class="fe ls lt lu lv b">private</code>的字段。</p><p id="1d01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管Kotlin有自己的额外功能来处理反射，但我们将使用标准的Java反射函数来代替这一特殊的更改，因为在编写本文时Kotlin特定的反射仍然相当有限，我们想要进行的更改实际上是不可能的。当然，这不是问题，因为Kotlin可以完美地与Java互操作。</p><h1 id="e50d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">做出改变</h1><p id="2ee4" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">所以我们要修改文本字段轮廓的宽度。首先要做的是找到这个宽度实际设置的位置。如果我们遵循<code class="fe ls lt lu lv b">OutlinedTextField</code>的定义，我们很快就会遇到<code class="fe ls lt lu lv b">androidx.compose.material.TextFieldImplKt.class</code>，它包含了<code class="fe ls lt lu lv b">TextFieldImpl</code>的JVM字节码。</p><p id="53ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，如果你正在Android Studio中查看这个，并且你已经正确地设置了一切，你应该能够直接看到源代码。我们可以快速浏览一下代码，我们看到<code class="fe ls lt lu lv b">IndicatorUnfocusedWidth</code>和<code class="fe ls lt lu lv b">IndicatorFocusedWidth</code>是在文件底部定义的私有变量。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="fcfd" class="mx lx iq lv b gy my mz l na nb">private val IndicatorUnfocusedWidth = 1.<strong class="lv ir">dp<br/></strong>private val IndicatorFocusedWidth = 2.<strong class="lv ir">dp</strong></span></pre><p id="01a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望非聚焦的宽度和聚焦的宽度一样，这样我就能得到一致的线宽。在我的例子中，2.dp是完美的，所以我将通过设置非聚焦宽度为聚焦宽度来稍微简化一下。</p><p id="29a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想将这些值设置为您想要的值，请记住这些变量实际上是浮点型的，试图直接设置dp值是行不通的。这可以通过直接查看字节码来确认。如果我们看看为<code class="fe ls lt lu lv b">TextFieldImplKt</code>生产的Smali，我们会看到这两行字:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="7f5c" class="mx lx iq lv b gy my mz l na nb">.field private static final IndicatorFocusedWidth:F <br/>.field private static final IndicatorUnfocusedWidth:F</span></pre><p id="45e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显示它们被编译成Float类型的私有静态字段(这是最后的<code class="fe ls lt lu lv b">F</code>)。</p><p id="0029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以从获取对我们正在修改的类的引用开始。正如我们在上面看到的，这是<code class="fe ls lt lu lv b">TextFieldImplKt</code>:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="513a" class="mx lx iq lv b gy my mz l na nb">val textFieldImpl = Class.forName("androidx.compose.material.TextFieldImplKt")</span></pre><p id="4025" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要得到田地。我们可以通过使用<code class="fe ls lt lu lv b">getDeclaredField()</code>方法来做到这一点:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="6860" class="mx lx iq lv b gy my mz l na nb">val indicatorUnfocusedWidth = textFieldImpl.getDeclaredField("IndicatorUnfocusedWidth")<br/>val indicatorFocusedWidth = textFieldImpl.getDeclaredField("IndicatorFocusedWidth")</span></pre><p id="7fad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我们现在有了想要修改的字段，但是我们现在还不能设置它们。这是因为标准修饰符仍然存在，我们在上面看到这些字段被标记为<code class="fe ls lt lu lv b">private</code>。此时尝试读取或写入我们的字段将导致一个<code class="fe ls lt lu lv b">IllegalAccessException</code>。我们需要首先使这些字段可访问:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="787c" class="mx lx iq lv b gy my mz l na nb">indicatorUnfocusedWidth.<strong class="lv ir">isAccessible </strong>= true<br/>indicatorFocusedWidth.<strong class="lv ir">isAccessible </strong>= true</span></pre><p id="16c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们终于可以随心所欲地设置它们了。要将非聚焦宽度设置为聚焦宽度，我们只需:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="3abf" class="mx lx iq lv b gy my mz l na nb">indicatorUnfocusedWidth.set(null, indicatorFocusedWidth.get(null))</span></pre><p id="2954" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这两个字段都是静态的，所以没有关联的对象，这意味着我们可以将<code class="fe ls lt lu lv b">null</code>传递给这两个参数。如果您正在修改的字段是一个类成员，那么您将需要传入应该更改该属性的对象。</p><p id="8663" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想直接设置一个dp值，你可以这样使用<code class="fe ls lt lu lv b">.value</code>:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="d819" class="mx lx iq lv b gy my mz l na nb">indicatorUnfocusedWidth.set(null, 3.dp.value)</span></pre><p id="763f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">带有一些基本异常处理的完整功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3601" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你的应用程序启动时，你可以在某个地方调用它一次，在执行过程中，这个改变将是永久的。这是一个相当安全的使用反射的方法，因为失败的唯一后果是你想要的改变将是一个正常的轮廓宽度。此外，该函数只被调用一次，因此与反射相关的典型性能开销变得无关紧要。</p><p id="af57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果很微妙，但在我看来确实有明显的不同。</p><div class="kg kh ki kj gt ab cb"><figure class="ne kk nf ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/e5f6ea878192e4682f37bb27842dae50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*1pjFubzPKmdhTJaq2DrcJw.jpeg"/></div></figure><figure class="ne kk nf ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/f3eac9b9623e4ffc52ac73e5eb2c1821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*f3crmiGkVVcH2tuVmn_KeA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk nk di nl nm translated">更改TextInput轮廓大小之前和之后</p></figure></div><h1 id="67be" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">摘要</h1><p id="44a7" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">本文展示了如何使用反射来微妙地修改Android应用程序中的UI，但是这里展示的技术可以用于许多其他更复杂的修改。也就是说，我不会对太复杂的东西使用反射，因为这会影响性能。</p><p id="4b04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果修改失败，将它用于不会有任何实际效果的微妙的事情，并且您最多只需要调用几次。最后，总是将你的更改封装在一个<code class="fe ls lt lu lv b">try/catch</code>块中，以确保你不会使你的应用崩溃。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="968f" class="lw lx iq bd ly lz nu mb mc md nv mf mg jw nw jx mi jz nx ka mk kc ny kd mm mn bi translated">编辑(2022年7月7日):</h1><p id="910f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">本文使用的示例<code class="fe ls lt lu lv b">OutlinedTextField</code>，自从本文撰写以来，已经改变了它描绘轮廓的方式。上述方法仍然有效，但边界厚度现在在<code class="fe ls lt lu lv b">TextFieldDefault.kt</code>中定义为<code class="fe ls lt lu lv b">UnfocusedBorderThickness</code>。它现在也是<code class="fe ls lt lu lv b">TextFieldDefault.BorderBox</code>中的一个实际选项，所以不使用反射应该更容易使用。</p><p id="43eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最初，我也没有提到需要对你的Proguard规则进行修改以使其生效。如果你使用Proguard/R8混淆你的应用程序，大多数，如果不是所有的类将失去他们的名字。如果你使用反射，这不是你想要的，因为你必须在运行时通过名字找到你想要修改的类。因此，您必须为所有通过名称引用的类添加如下规则:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="ab8d" class="mx lx iq lv b gy my mz l na nb">-keepclasseswithmembernames class androidx.compose.material.TextFieldImplKt {<br/>     public <strong class="lv ir">&lt;methods&gt;</strong>;<br/>}</span></pre><p id="55f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不是Proguard的专家，所以可能有更好的规则，但这在过去对我有效。</p></div></div>    
</body>
</html>