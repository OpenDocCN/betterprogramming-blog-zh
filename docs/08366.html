<html>
<head>
<title>Asynchronous Programming in Python for Making More API Calls Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的异步编程可以更快地调用更多API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asynchronous-programming-in-python-for-making-more-api-calls-faster-419a1d2ee058?source=collection_archive---------1-----------------------#2021-04-22">https://betterprogramming.pub/asynchronous-programming-in-python-for-making-more-api-calls-faster-419a1d2ee058?source=collection_archive---------1-----------------------#2021-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce0f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用aiohttp、asyncio、event loops和其他任何东西来更快地获取我们的金融科技数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4805b98c46fb6a993cd5a7d6fb96cad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SPuDp3HkOF5xJ01TdwlTQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Getty Images Pro的monsitj的原始图像。</p></figure><p id="1843" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前几天，我试图从网上找到的一个API下载1600万种颜色。我最初的想法是“当然，我可以用请求库做到这一点。大概用不了<em class="lu">那么</em>长时间。”</p><p id="c17e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">八个小时后，我完成了大约0.5%，所以我决定是时候重构代码以实现异步了。这也是帮助其他人的时候了。从Python 3开始，<a class="ae lv" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">异步编程</a>现在得到了支持，但是我遇到了一些问题，我相信其他人也会遇到，所以让我们从头到尾了解一下。</p><p id="e8d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个演示/教程的所有代码和例子都可以在<a class="ae lv" href="https://github.com/PatrickAlphaC" rel="noopener ugc nofollow" target="_blank"> my GitHub </a>的<a class="ae lv" href="https://github.com/PatrickAlphaC/async-python" rel="noopener ugc nofollow" target="_blank"> async-python </a> repo中找到。它有一个很好的小自述文件，所以你可以跟随！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="10c0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">请求库</h1><p id="e142" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">通常，当Pythoners程序想要进行API调用时，它们会查看<a class="ae lv" href="https://realpython.com/python-requests/" rel="noopener ugc nofollow" target="_blank">请求</a>库。这个语法是我最喜欢的，因为如果我想进行API调用，我只需运行:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="47b4" class="nf me it nb b gy ng nh l ni nj">import requests</span><span id="3930" class="nf me it nb b gy nk nh l ni nj">response = requests.get("<a class="ae lv" href="http://example.com/" rel="noopener ugc nofollow" target="_blank">http://example.com/</a>")<br/>print(response)</span></pre><p id="e438" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅此而已。我喜欢这样小而有效的例子。</p><p id="b235" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我想经常这样做，我可以做一个<code class="fe nl nm nn nb b">for</code>循环:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="36e0" class="nf me it nb b gy ng nh l ni nj">import requests</span><span id="6571" class="nf me it nb b gy nk nh l ni nj">for i in range(10):<br/>    response = requests.get("<a class="ae lv" href="http://example.com/" rel="noopener ugc nofollow" target="_blank">http://example.com/</a>")<br/>    print(response)</span></pre><p id="45d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不得不等待更长的时间。每次我对<code class="fe nl nm nn nb b">example.com</code>进行API调用时，我必须:</p><ol class=""><li id="2832" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">将请求发送给<code class="fe nl nm nn nb b">example.com</code>。</li><li id="0179" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">等待回应。</li><li id="e6fb" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">得到回应。</li></ol><p id="dbef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我试图获取大量数据，这尤其令人沮丧(例如，如果我想从<a class="ae lv" href="https://www.alphavantage.co/documentation/" rel="noopener ugc nofollow" target="_blank"> Alpha Vantage API </a>中提取fintech数据)。你需要一个可以用<code class="fe nl nm nn nb b">api_key = your_key_here</code>设置的<a class="ae lv" href="https://www.alphavantage.co/support/#api-key" rel="noopener ugc nofollow" target="_blank">自由键</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="bb88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我必须等待5个API调用大约1.5秒，然后50个API调用需要11秒，135个API调用需要50秒…</p><p id="b19b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哎呀…如果我想获得2，000家公司或1，600万种颜色的数据，这就不太合适了。</p><p id="9bfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们需要做一些更聪明的事情。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="77ec" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">异步代码与同步代码</h1><p id="0795" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">当我们运行Python代码时，代码被我们的进程逐行读取，一次一行。当一行被执行时，没有其他代码可以运行。这就是所谓的同步代码——一切按顺序进行。</p><p id="c0b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Concepts" rel="noopener ugc nofollow" target="_blank">异步代码</a>中，我们可以在一个任务完成之前转移到另一个任务。例如，如果我们考虑同步烹饪汉堡和蔬菜的晚餐，我们的“代码”应该是这样的:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c306" class="nf me it nb b gy ng nh l ni nj">cook_burger()<br/>cook_vegetables()</span></pre><p id="8a80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们不能开始蔬菜，直到汉堡做好，因为它是同步的。然而，我们并不总是想等到汉堡做好了才开始煮蔬菜。我们可以同时煮它们。一旦做好了，我们可以停下手头的工作去处理完成的蔬菜或汉堡。在异步代码中，它看起来像这样:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ce14" class="nf me it nb b gy ng nh l ni nj">async def cook_meal():<br/>     await asyncio.gather(cook_burger(), cook_vegetables())</span><span id="2934" class="nf me it nb b gy nk nh l ni nj">asyncio.run(cook_meal())</span></pre><p id="2e6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们“收集”我们要做的任务，并让他们两个完成。我们在一个事件循环中运行这些函数，该循环跟踪它们完成时如何处理它们。您可以将事件循环视为不断检查某个流程是否完成。</p><p id="27c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你可能听说过多线程，这些是不同的。多线程是为了拥有多个工作线程。Async只有一个工作线程。想象一下，当一堆东西在烹饪时，一个工人在厨房里跑来跑去，而许多工人在厨房里。我在<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/which-should-you-use-asynchronous-programming-or-multi-threading-7435ec9adc8e">之前的一篇文章</a>中分析了这些差异。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a7b9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">事件循环</h1><p id="6814" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">回到我们的Alpha Vantage API调用示例。在我们现在的代码中，我们:</p><ol class=""><li id="dce7" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">提出第一个要求。</li><li id="d403" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">等等。</li><li id="5c4a" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">得到第一个回应。</li><li id="7041" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">提出第二个要求。</li><li id="d3bf" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">等等。</li><li id="0c71" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">得到第二次回应。</li></ol><p id="a6d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于每个符号。如果我们有五个符号，我们就“等待”了五次。这是我们第五次无所事事！如果我们有100个API调用，我们就有100次什么都没做！与其这样做，不如开始一个API调用，而不是等待，开始其他API调用，然后稍后处理响应。</p><p id="e477" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们可以不做上述工作，而是:</p><ol class=""><li id="f4eb" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">提出第一个要求。</li><li id="49e4" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">提出第二个要求。</li><li id="c200" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">等等。</li><li id="158d" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">得到第一个回应。</li><li id="43c2" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">得到第二次回应。</li></ol><p id="cce0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第二个例子中，我们只有一段等待时间！现在，当响应返回时，这可能发生在我们发出请求时，所以我们需要一些东西来处理返回的响应。这被称为<a class="ae lv" href="https://docs.python.org/3/library/asyncio-eventloop.html" rel="noopener ugc nofollow" target="_blank">事件循环</a>。</p><p id="a9ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事件循环定期检查我们的异步操作是否已经返回，并相应地调度它们进行处理。当我们正常运行Python时，没有运行事件循环来处理这种情况，所以我们需要设置事件循环，以便可以按顺序处理响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/cf6b389d55ca98489e11edabe2107ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OKa5zxWeTorZSR8w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae lv" href="https://eng.paxos.com/python-3s-killer-feature-asyncio" rel="noopener ugc nofollow" target="_blank"> Paxos </a>。</p></figure><p id="9319" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们可以异步运行我们的代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6c40" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">输入asyncio和aiohttp</h1><p id="97ba" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">所以我们现在知道，当我们异步运行代码时，我们不必总是马上等待它完成。我们可以使用<a class="ae lv" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> asyncio </a>和<a class="ae lv" href="https://docs.aiohttp.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> aiohttp </a>来实现这一点。</p><p id="2bf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看如何编写与Alpha Vantage请求示例几乎完全相同的代码，但是使用了asyncio和aiohttp:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="6b68" class="nf me it bd mf of og dn mj oh oi dp mn lh oj ok mp ll ol om mr lp on oo mt op bi translated">分解它</h2><p id="b304" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">我们用<code class="fe nl nm nn nb b">asyncio.run(get_symbols())</code>启动底部的功能。这启动了我们的事件循环，并允许我们使用异步代码。您会注意到，在许多较早的示例中，它们更明确地说明了如何开始事件循环:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="dc37" class="nf me it nb b gy ng nh l ni nj">loop = asyncio.get_event_loop()<br/>results = loop.run_until_complete(get_symbols())<br/>loop.close()</span></pre><p id="1eb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码做的事情和<code class="fe nl nm nn nb b">asyncio.run(get_symbols())</code>完全一样。</p><p id="605e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们的切入点。然后我们转到函数:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="58d1" class="nf me it nb b gy ng nh l ni nj">async def get_symbols():<br/>    async with aiohttp.ClientSession() as session:<br/>        for symbol in symbols:<br/>            response = await session.get(url.format(symbol, api_key), ssl=False)</span></pre><p id="1d3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们必须以关键字<code class="fe nl nm nn nb b">async</code>开始。这让Python知道这个函数将是异步的，我们可以使用事件循环。</p><p id="dc6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们与<code class="fe nl nm nn nb b">aiohttp</code>开启一个会话。<code class="fe nl nm nn nb b">aiohttp</code>是<code class="fe nl nm nn nb b">requests</code>的异步版本。然后我们遵循同样的模式，遍历每个符号并调用aiohttp版本的<code class="fe nl nm nn nb b">request.get</code>，也就是<code class="fe nl nm nn nb b">session.get</code>。我发现你经常需要为此添加<code class="fe nl nm nn nb b">ssl=False</code>。</p><p id="aa33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe nl nm nn nb b">session.get</code>是一个异步函数，也称为协程，我们必须用<code class="fe nl nm nn nb b">await</code>来响应。有几种<a class="ae lv" href="https://docs.python.org/3/library/asyncio-task.html#awaitables" rel="noopener ugc nofollow" target="_blank">可用对象</a>可以/必须等待使用。否则，它们只返回协程本身。</p><p id="e19d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了。我们基本上已经将请求代码复制到异步语法中了，但是等等…我们每次都还在等待！</p><p id="da5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键字<code class="fe nl nm nn nb b">await</code>意味着我们仍在循环，等待每个响应的返回。我们希望从一开始就启动所有的API调用，然后再等待。我们如何做到这一点？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8397" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">收集任务</h1><p id="1453" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">我们怎样才能像这样一次启动所有的API调用呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c57d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有一个全新的功能叫做<code class="fe nl nm nn nb b">get_tasks</code>。这个函数将所有的协程合并到一个列表中，让我们立刻开始。请记住，这个列表中的所有函数都必须是异步函数或者是已经放在事件队列中的任务(现在不要担心第二部分)。</p><p id="a53f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以通过以下方式完成所有任务:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="145e" class="nf me it nb b gy ng nh l ni nj">tasks = [session.get(URL.format(symbol, API_KEY), ssl=False) for symbol in symbols]</span></pre><p id="7134" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我想包含<code class="fe nl nm nn nb b">get_tasks</code>函数，以防混淆。</p><p id="0eca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们有了想要开始的功能/任务的列表，我们就可以在我们的<code class="fe nl nm nn nb b">get_symbols</code>函数中使用以下命令来开始它们:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ce89" class="nf me it nb b gy ng nh l ni nj">responses = await asyncio.gather(*tasks)</span></pre><p id="0c29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一行表示我们将等待所有任务完成，并将它们放入<code class="fe nl nm nn nb b">responses</code>对象中。我们也可以这样写:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8135" class="nf me it nb b gy ng nh l ni nj">responses = await asyncio.gather(session.get(URL.format('IBM', API_KEY), ssl=False), session.get(URL.format('AAPL', API_KEY), ssl=False), session.get(URL.format('MSFT', API_KEY), ssl=False))</span></pre><p id="b96e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为<code class="fe nl nm nn nb b">*tasks</code>只是一种将列表<a class="ae lv" href="https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/" rel="noopener ugc nofollow" target="_blank">解引用到变量中的方法。</a></p><p id="0fde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们“收集”所有的任务，然后将它们发送出去。当它们响应时，事件循环会将它们捡起来，放入队列中，在我们发送完所有任务后进行处理。</p><h2 id="6eef" class="nf me it bd mf of og dn mj oh oi dp mn lh oj ok mp ll ol om mr lp on oo mt op bi translated">协程与任务</h2><p id="6ad6" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">现在，在上面的例子中，我们向<code class="fe nl nm nn nb b">asyncio.gather</code>函数传递了一个异步协程列表，这样它们就可以被调度到事件循环中，但是我们实际上可以更快地将它们调度到事件循环中！</p><p id="5bfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的<code class="fe nl nm nn nb b">get_tasks</code>函数中，我们调用:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0b75" class="nf me it nb b gy ng nh l ni nj">tasks.append(session.get(url.format(symbol, api_key), ssl=False))</span></pre><p id="8576" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将<code class="fe nl nm nn nb b">session.get</code>函数添加到任务列表中，并且只在调用<code class="fe nl nm nn nb b">gather</code>时将它们添加到事件循环中。实际上，您可以使用<code class="fe nl nm nn nb b">asyncio.create_task</code>更快地将其添加到事件循环中:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9396" class="nf me it nb b gy ng nh l ni nj">tasks.append(<!-- -->asyncio.create_task(<!-- -->session.get(url.format(symbol, api_key), ssl=False)))</span></pre><p id="d87b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将把<code class="fe nl nm nn nb b">session.get</code>函数添加到事件循环中，而<code class="fe nl nm nn nb b">asyncio.gather</code>函数将等待该任务完成。</p><p id="844f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是请记住，它们是不同的。协程是一个函数，而任务是在事件循环中被调度的东西。<code class="fe nl nm nn nb b">asyncio.gather</code>将等待任务返回和/或将协程调度到事件循环上，并等待它们返回。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="221c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="7373" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">希望我已经澄清了很多关于Python中异步编程的困惑。如果你想看到更多，有些事情没有意义，或者你现在在做的任何项目都没有被阻止，请留下评论让我知道！</p><p id="d3fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还制作了两个关于这个主题的视频。一个比另一个更古怪。一如既往，我期待这两方面的反馈！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq od l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq od l"/></div></figure></div></div>    
</body>
</html>