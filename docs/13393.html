<html>
<head>
<title>Containerize Your Go Unit and Integration Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的Go单元和集成测试容器化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-7c916ce2816a?source=collection_archive---------6-----------------------#2022-08-23">https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-7c916ce2816a?source=collection_archive---------6-----------------------#2022-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="074a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Go构建现代REST API第5部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/210f1e261d55d9f921f56697b82747d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bcy1RcN5qtzkOYTW.jpg"/></div></div></figure><p id="1e04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文是系列文章的第五篇，也是最后一篇，涵盖了逐步实现现代REST API微服务的所有方面:</p><ol class=""><li id="2e00" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-c765d571b9e7" rel="noopener">使用sqlc定义SQL优先数据模型</a></li><li id="b88f" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-39b0e966534a" rel="noopener">用Gin实现REST API</a></li><li id="55cf" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-1d48767a813" rel="noopener">配置毒蛇</a></li><li id="6a11" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-e0070aa1b383" rel="noopener">在容器中构建和运行</a></li><li id="a305" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><strong class="kt ir">集装箱测试</strong></li></ol><p id="0265" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该系列的所有代码都可以在<a class="ae lw" href="https://github.com/bquenin/modern-go-rest-api-tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="8984" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">我们应该实现什么样的测试？</h1><p id="9c1c" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">既然我们已经构建了API微服务，我们希望实施测试来确保它正常工作。我们有一个两层的服务设计:数据库层和它上面的HTTP API。那么我们要如何测试它呢？</p><p id="2a7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过测试每一个生成的SQL查询来进行全面的单元测试，并通过模拟实际数据库来确保它的行为符合预期。然后，我们将通过模拟数据库层和测试每个API处理程序来测试HTTP API。这是一种常见的方法，很有意义。</p><p id="ed37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一种方法是进行集成测试。集成测试的想法是只使用应用程序的公共API来测试应用程序。因此，在我们的案例中，我们将:</p><ol class=""><li id="3d1a" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">启动数据库和微服务，就像上一篇文章中的生产堆栈一样，</li><li id="388f" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">然后我们将实现一个REST API测试客户端，它将调用微服务API来测试所有提供的方法。</li></ol><p id="0c9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这也通常用于测试基于微服务的架构，并确保整个应用程序或其子系统的行为符合预期。</p><p id="bb0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这两种方法都存在一些挑战。一方面，进行全面的单元测试需要编写大量的测试代码，在我们的例子中，测试数据库层就是测试Postgres SQL驱动程序和sqlc生成的代码。本着同样的精神，独立测试HTTP层，需要模仿数据库层，这需要维护大量的代码。</p><p id="325c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一方面，仅依赖于API的集成测试很好，但是我们可以实现的检查仅限于API公开公开的内容。我们不想实现一个用于测试目的的私有API！</p><h2 id="0a41" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">两全其美？</h2><p id="56d2" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">因此，在本文中，我们将取两者之长，实现介于单元测试和集成测试之间的东西:</p><ul class=""><li id="637d" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm nl lt lu lv bi translated">为了避免嘲弄数据库，我们将启动一个容器化的数据库来支持我们的测试，</li><li id="6c82" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm nl lt lu lv bi translated">我们不会将客户端和服务器解耦来实现细粒度的检查，而是绕过网络层，直接在服务器上执行请求。</li></ul><p id="72b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，这是一种非常固执己见的方法。它的效率很高，一定会为你节省很多时间。</p><h1 id="a524" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">套件下的分组测试</h1><p id="289d" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">为了编写我们的测试，我们将使用<a class="ae lw" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">stretchr/evidence</a>库将我们的测试分组到<a class="ae lw" href="https://github.com/stretchr/testify#suite-package" rel="noopener ugc nofollow" target="_blank">测试套件</a>下。使用套件允许我们在整个套件和每个测试之前执行初始化步骤:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ecb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> SetupSuite </strong>方法在整个Suite执行之前执行一次。我们设置服务器的方式与设置主函数的方式相同。这里唯一的区别是我们不启动服务器。其他一切都是相同的:我们使用相同的配置机制，以相同的方式实例化数据库连接，并注册相同的处理程序。</p><p id="9203" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在套件的每个测试之前，执行<strong class="kt ir"> SetupTest </strong>方法。在我们的例子中，我们截断了作者数据库，重新开始。</p><h1 id="eb87" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">实施测试</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">测试创建</p></figure><p id="cf35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用<code class="fe ns nt nu nv b">httptest</code>标准测试库来测试我们的API。这个库可以测试任何HTTP应用程序，尤其是REST APIs。它能够“记录”请求和响应。</p><p id="a5db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们构建HTTP请求并解析HTTP响应，就像为真实的服务器一样。唯一的区别是我们通过直接调用路由器的<code class="fe ns nt nu nv b">ServeHTTP</code>方法绕过了网络栈。除此之外，我们测试代码的方式与在生产中执行的方式相同。</p><p id="8cf9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">调用服务器后，我们通过断言每个字段都有预期值来验证响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">TestFullUpdate</p></figure><p id="8df9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的测试中，我们想要测试更新处理程序，但是要更新一个作者，我们首先需要创建一个。因为我们没有将客户机和服务器分开，所以我们可以很容易地在数据库中创建所需的作者，如上所示。</p><h1 id="415b" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">在容器中运行测试</h1><p id="ee2e" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我们还将使用Docker Compose来运行容器化测试，就像我们在上一篇文章中所做的那样。为了实现这一目标，我们将:</p><ol class=""><li id="36d9" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">构建一个包含测试的映像</li><li id="8cd1" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">运行这个测试容器映像作为我们测试堆栈的一部分</li></ol><h2 id="5b8f" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">构建测试容器</h2><p id="08a1" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">第一步是构建一个测试容器。请注意<strong class="kt ir">在此步骤</strong>中不执行测试。我们只是构建一个容器，其中包含将在下一步中执行的测试代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5c90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将源代码复制到容器中，并指定容器启动时要执行的命令。这个命令就是简单的"<strong class="kt ir"> go test。/… </strong>"来执行所有的测试。</p><h2 id="7460" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">运行测试堆栈</h2><p id="fb41" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">既然我们已经准备好了测试容器，我们必须定义我们的测试堆栈。我们将使用与生产堆栈相同的堆栈，只是我们将运行测试本身，而不是运行微服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">Docker编写测试堆栈</p></figure><p id="07e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">测试的构建部分告诉Docker Compose在启动堆栈之前构建容器。我们也正在配置我们的测试来使用容器化的数据库。</p><p id="becd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以更新Makefile来添加一个测试目标:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">Makefile测试目标</p></figure><p id="fd54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Compose命令具有以下参数:</p><ul class=""><li id="a5fb" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm nl lt lu lv bi translated"><code class="fe ns nt nu nv b">--build</code>强制构建测试容器映像</li><li id="9a94" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm nl lt lu lv bi translated"><code class="fe ns nt nu nv b">--abort-on-container-exit</code>当容器退出时，强制堆栈停止。它允许在我们的测试容器运行完测试后停止堆栈。测试容器的退出状态被传播到撰写命令，即，如果测试失败，撰写命令也失败。这在CI/CD管道中运行测试时很有帮助。</li><li id="a1fb" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm nl lt lu lv bi translated"><code class="fe ns nt nu nv b">--force-recreate</code>强制重新创建容器，即使它们的配置和图像没有改变。</li><li id="57d8" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm nl lt lu lv bi translated"><code class="fe ns nt nu nv b">--remove-orphans</code>删除合成文件中未定义的服务容器。</li></ul><h1 id="0c8c" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结论</h1><p id="45d6" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">这个关于使用Go的现代REST API的系列到此结束。祝贺你走到了这一步！我希望你和我一样喜欢它，并发现它很有帮助！玩得开心！</p></div></div>    
</body>
</html>