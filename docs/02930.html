<html>
<head>
<title>Practical Svelte: The use-directive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用苗条:使用指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/practical-svelte-the-use-directive-60635671335f?source=collection_archive---------6-----------------------#2020-01-09">https://betterprogramming.pub/practical-svelte-the-use-directive-60635671335f?source=collection_archive---------6-----------------------#2020-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1b71" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用一个鲜为人知但极其强大的苗条特征:动作，编写更好的组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b754dc3cb15bb35f943524bff5ac9c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgykdllyo26IZrqlW3CgaQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@nordwood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">诺德伍德主题</a>在<a class="ae kv" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cf2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">苗条是一个很好的框架。这感觉就像夏天的一缕新鲜空气。然而，特别是在开始时，很容易陷入“这是我在以前的框架中做事情的方式”的陷阱。</p><p id="0bc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想我们每个人都会遇到这种情况。绝对发生在我身上。我不希望这发生在你身上。这就是这篇文章的目的。</p><p id="bc44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您希望一些输入字段自动选择焦点上的所有文本。尤其是当来自React这样的框架时，开始创建一个围绕输入的组件包装器(例如，<code class="fe ls lt lu lv b">&lt;input&gt;</code>变成了<code class="fe ls lt lu lv b">&lt;Input/&gt;</code>)并在其中添加您的自定义事件处理程序可能会很有诱惑力。</p><p id="de76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个很好的反应方式，但不太苗条。你会问为什么？</p><p id="1917" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，当您拥有原生DOM元素时，Svelte(至少在其当前的版本v3中)确实大放异彩。您可以使用转换指令，有条件地切换CSS类，轻松绑定到当前值，等等。</p><p id="2467" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了一个设计良好的CSS样式系统，您可以在保持代码可读性和可维护性的同时，按照您喜欢的方式对组件进行一致的样式化。</p><p id="06aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，唉，有时候你想要更多。有时，您可能想写那个包装器。因为你所有的(React or Vue or<em class="lw">insert your reactive framework here</em>)本能都是这么告诉你的。</p><p id="9b13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抵制诱惑。有更好的方法。一种独特的方式。介绍:<a class="ae kv" href="https://svelte.dev/tutorial/actions" rel="noopener ugc nofollow" target="_blank">使用指令</a>(也称为“动作”)。</p><p id="98cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然它们是标准教程的一部分，但我已经很久没有使用它们了。部分问题可能是教程中的例子感觉相当具体，似乎并不适用于通常的问题集。</p><p id="bf65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是一旦我理解了他们的全部潜力，我就完全爱上了他们。</p><p id="e1f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是这样工作的:你取任何一个本地组件(比如一个输入、一个按钮或一个div)并给它分配一个<strong class="ky ir"> </strong> f <em class="lw">函数，当组件被挂载</em>时，这个函数在组件的DOM节点上执行。</p><p id="b287" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看上面的用例(选择聚焦的文本)。假设我们有一个基本输入，就像这样:</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="5cb5" class="mb mc iq lv b gy md me l mf mg">&lt;input type="text" class="ui-input" placeholder="Name" title="Name"&gt;</span></pre><p id="e1e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步。我们定义了一个函数，它接受一个HTML节点<strong class="ky ir"> </strong>(将应用指令的组件的节点)，并将我们的事件侦听器添加到该节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">selectTextOnFocus指令</p></figure><p id="469b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二步。<strong class="ky ir"> </strong>我们用“use-directive”把这个函数分配给组件。</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="9bdb" class="mb mc iq lv b gy md me l mf mg">&lt;input type="text" class="ui-input" placeholder="Name" title="Name <strong class="lv ir">use:selectTextOnFocus</strong>&gt;</span></pre><p id="d777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。是的，就这么简单。现在，只要输入获得焦点，它就会选择所有包含的文本。</p><p id="03e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个重要的部分——在标准教程中也有解释——是确保在组件被销毁(即从DOM中卸载)时运行必要的清理代码。</p><p id="7c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是返回值<code class="fe ls lt lu lv b">{destroy:…}</code>的用途。否则，您可能会给应用程序带来内存泄漏。</p><p id="bda6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您为一个元素分配了多个指令。因此，我们可以创建一个名为<code class="fe ls lt lu lv b">blurOnEscape</code>的新函数，并对其赋值。</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="5349" class="mb mc iq lv b gy md me l mf mg">&lt;input type="text" class="ui-input" placeholder="Name" title="Name use:selectTextOnFocus <strong class="lv ir">use:blurOnEscape</strong>&gt;</span></pre><p id="4c48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这条指令的代码也非常简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">蓝光景观指令</p></figure><p id="9c37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是上面在一个<a class="ae kv" href="https://svelte.dev/repl/b4db6313dfeb4b50871a9b43398a6952?version=3.16.7" rel="noopener ugc nofollow" target="_blank">交互式REPL </a>中的例子。</p><p id="d309" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子确实很基础，但是潜力是巨大的。例如，在Faden，我们编写了带有使用指令的多级拖放树处理，显著地减少了组件本身。</p><p id="37e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，简单的模块化修改器就像上面的一样，通常感觉是最大的生产力助推器。</p><p id="7c72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很想知道您的使用案例。此外，如果您想了解更多高级用例，请告诉我，例如，如何将props传递给指令，并使其与组件状态保持同步。</p><p id="362a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然你一直读到最后，这里还有一个例子。这一次在交互式的苗条REPL中:<a class="ae kv" href="https://svelte.dev/repl/0ace7a508bd843b798ae599940a91783?version=3.16.7" rel="noopener ugc nofollow" target="_blank"> <em class="lw">监听元素外部的点击，并分派一个定制事件</em> </a>。</p><p id="9dfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在菜单和下拉菜单的浮动元素上使用非常方便。</p></div></div>    
</body>
</html>