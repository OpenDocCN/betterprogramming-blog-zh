<html>
<head>
<title>Chaos Engineering: Chaos Testing Your HTTP Micro-Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混沌工程:混沌测试你的HTTP微服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/chaos-engineering-chaos-testing-your-http-micro-services-acc99d145515?source=collection_archive---------3-----------------------#2019-05-20">https://betterprogramming.pub/chaos-engineering-chaos-testing-your-http-micro-services-acc99d145515?source=collection_archive---------3-----------------------#2019-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="917a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">失败中的成功和失败中的成功</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b5f7e71ae991bc68bd1b15bc397bbba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2MCl-kl1duA99sRc.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">网飞的<a class="ae ky" href="https://medium.com/netflix-techblog/tagged/chaos-monkey" rel="noopener">混沌猴</a>主要负责普及<a class="ae ky" href="https://en.wikipedia.org/wiki/Chaos_engineering" rel="noopener ugc nofollow" target="_blank">混沌工程</a>的概念。</p></figure><p id="a89d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TLDR:如果微服务所依赖的服务以某种方式出现故障(而你没有处理好)，那么你的微服务很容易出现意外故障。使用“混沌代理”对你的HTTP微服务进行故障测试。</p><p id="bb81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我之前做的一个:</p><div class="lv lw gp gr lx ly"><a href="https://github.com/clusterfk/chaos-proxy" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">cluster fk/混沌代理</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">ClusterF** Chaos代理是一个不可靠的HTTP代理，您可以依赖它；一个为混沌测试设计的轻量级工具…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><h1 id="259f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">混沌工程——它是什么？</h1><p id="7061" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">混沌工程是一个伟大的想法——建立一个自动化的解决方案/工具，随机尝试以某种方式破坏一个系统；最终了解系统在这种情况下的行为。然后，您可以使用新获得的知识来寻找方法，使系统在将来的这些故障条件下具有更强的容错能力。</p><h1 id="a777" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">什么是混沌代理？</h1><p id="8d89" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">混沌代理是一种你的微服务可以连接的服务。</p><p id="5d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将流量路由到真正的目的地微服务，并通过代理将响应返回给微服务，但这种方式非常不可靠。</p><p id="8fab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过代理，请求会以意想不到的方式随机延迟和/或随机失败——所有这些都是为了帮助您了解微服务如何响应这些不同的失败条件。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="e9f1" class="mn mo it bd mp mq nr ms mt mu ns mw mx jz nt ka mz kc nu kd nb kf nv kg nd ne bi translated">为什么会有人想要一个不可靠的HTTP代理？</h1><p id="95a0" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">一切终将失败。一切。</p><p id="f9d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接受它，拥抱失败。为失败设计。<em class="nw">在失败中成功。</em></p><p id="1c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">微服务经常通过REST和HTTP与其他服务通信。当微服务所依赖的服务不可避免地以某种不可预测的方式失败时，您的微服务如何应对？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/20372029d67e8429d39c4dd0036d80ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ed6KY3RMAXvZSEfl.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">承蒙:<a class="ae ky" href="https://blog.algorithmia.com/introduction-to-microservices/" rel="noopener ugc nofollow" target="_blank">https://blog.algorithmia.com/introduction-to-microservices/</a></p></figure><p id="96d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果微服务所依赖的服务发生故障<em class="nw"> ( </em>)，并且您没有考虑到故障或者定义您的服务应该如何运行<em class="nw"> ) </em>，那么您的微服务很容易出现意外故障。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="4d80" class="mn mo it bd mp mq nr ms mt mu ns mw mx jz nt ka mz kc nu kd nb kf nv kg nd ne bi translated">这为什么有用？</h1><p id="a1a7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">最近我在调查一个微服务中的JDBC连接泄漏。</p><p id="7068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着现代框架将JDBC操作抽象化，连接泄漏现在不应该真的发生，但是唉，连接泄漏确实发生了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/ed6baa3eca4f32ae79897b46bcbddd8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4NFe3gipY-N1-FVk.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提供:<a class="ae ky" href="https://jsherz.com/leak/memory/connection/database/graphing/plotly/python/linux/2017/02/16/finding-connection-leak.html" rel="noopener ugc nofollow" target="_blank">https://jsherz . com/leak/memory/connection/database/graphing/plotly/python/Linux/2017/02/16/finding-connection-leak . html</a></p></figure><p id="4c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想评估微服务(A)对它所依赖的另一个微服务(B)的故障和延迟的恢复能力。</p><p id="b8c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要一种方法来模拟微服务“B”中的周期性故障和延迟，同时在本地对微服务“A”执行请求和自动回归测试。</p><p id="3d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以在远程环境中访问微服务“B ”,但由于各种限制，我无法在本地运行“B”来尝试修改它以发出故障。</p><p id="15c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我真的找不到轻量级的、相当容易设置的、能实现我希望实现的东西。</p><p id="9c22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一番折腾之后，<a class="ae ky" href="https://github.com/clusterfk/chaos-proxy" rel="noopener ugc nofollow" target="_blank"> ClusterFk混沌代理</a>的第一次迭代诞生了！</p><p id="4f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了ClusterFk Chaos Proxy，我才能够识别出，如果微服务‘B’的响应有足够的延迟，微服务‘A’中的JDBC连接就会堆积起来，只要HTTP请求处于活动状态，就会一直存在——即使JDBC事务实际上早就提交了。</p><p id="95bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已知原因后，这为该问题提供了一系列可能的解决方案(以及通过混沌代理测试其有效性的简单方法)，例如:</p><ul class=""><li id="ebaf" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">对从“A”到“B”的请求实施受控超时。</li><li id="259e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">实现JDBC连接的超时并返回连接池。</li><li id="e96f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">使处理元素异步，以便请求线程更快地退出。</li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="b222" class="mn mo it bd mp mq nr ms mt mu ns mw mx jz nt ka mz kc nu kd nb kf nv kg nd ne bi translated"><strong class="ak"> ClusterFk混沌代理</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d22ff1a5b8b8cc3a352e9a75189635c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/0*gzNsbuQ8LgYw_4rE"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/clusterfk/chaos-proxy" rel="noopener ugc nofollow" target="_blank">https://github.com/clusterfk/chaos-proxy</a></p></figure><p id="0a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前提很简单:</p><ul class=""><li id="8251" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">配置本地运行的被测服务指向混沌代理，配置混沌代理指向真正运行的依赖目的地服务。</li><li id="b5e8" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">打开<strong class="lb iu"> </strong> ClusterFk混沌代理，配置一个“混沌策略”。</li><li id="c5f0" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">使用你的微服务(向它开火)。</li><li id="6757" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">观察世界燃烧(通过监控日志或通过应用程序行为)。</li><li id="dfec" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">可选—从混乱中学习并实施更改，以提高您的微服务的弹性。</li><li id="02be" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">重复一遍。</li></ul><p id="0909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一次把混沌代理放在一起的时候，我并没有真正意识到混沌代理的概念，但是我决定完成第一次迭代。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="bce6" class="mn mo it bd mp mq nr ms mt mu ns mw mx jz nt ka mz kc nu kd nb kf nv kg nd ne bi translated"><strong class="ak">入门</strong></h1><p id="0c0e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">ClusterFk混沌代理在<a class="ae ky" href="https://hub.docker.com/r/andymacdonald/clusterf-chaos-proxy" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>上。要简单安装:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="4983" class="ot mo it op b gy ou ov l ow ox">docker pull andymacdonald/clusterf-chaos-proxy</span></pre><p id="fd50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后用目的地服务细节配置一个<code class="fe oy oz pa op b">docker-compose</code>文件——例如，如果您的‘B’服务运行于<code class="fe oy oz pa op b"><a class="ae ky" href="http://10.0.0.231:8098:" rel="noopener ugc nofollow" target="_blank">http://10.0.0.231:8098</a></code> <a class="ae ky" href="http://10.0.0.231:8098:" rel="noopener ugc nofollow" target="_blank"> : </a></p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="dab3" class="ot mo it op b gy ou ov l ow ox">version: "3.7"<br/>services:<br/>  user-service-chaos-proxy:<br/>    image: andymacdonald/clusterf-chaos-proxy<br/>    environment:<br/>      JAVA_OPTS: "-Dchaos.strategy=RANDOM_HAVOC -Ddestination.hostProtocolAndPort=http://10.0.0.231:8098"<br/>    ports:<br/>      - "8080:8080"</span></pre><p id="95d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据项目的README.md <strong class="lb iu"> : </strong>配置混沌策略</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="3692" class="ot mo it op b gy ou ov l ow ox"><strong class="op iu">NO_CHAOS</strong> - Request is simply passed through</span><span id="eb5d" class="ot mo it op b gy pb ov l ow ox"><strong class="op iu">DELAY_RESPONSE</strong> - Requests are delayed but successful (configurable delay)</span><span id="c275" class="ot mo it op b gy pb ov l ow ox"><strong class="op iu">INTERNAL_SERVER_ERROR</strong> - Requests return with 500 INTERNAL SERVER ERROR</span><span id="0c86" class="ot mo it op b gy pb ov l ow ox"><strong class="op iu">BAD_REQUEST</strong> - Requests return with 400 BAD REQUEST</span><span id="22e0" class="ot mo it op b gy pb ov l ow ox"><strong class="op iu">RANDOM_HAVOC</strong> - Requests generally succeed, but randomly fail with random HTTP status codes and random delays</span></pre><p id="97e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后干脆:<code class="fe oy oz pa op b">docker-compose up</code></p><p id="777a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦应用程序启动，您就可以将您想要测试的微服务指向您的ClusterFk Chaos Proxy <strong class="lb iu"> </strong>实例(而不是真正的目标服务)。然后启动微服务，开始测试和使用它。</p><p id="21ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您选择的策略，代理将根据您发送给它的请求来影响策略。</p><p id="1e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能最有用的策略是<code class="fe oy oz pa op b">RANDOM_HAVOC</code>和<code class="fe oy oz pa op b">DELAY_RESPONSE</code>——但是你仍然会发现其他策略也很有用。</p><p id="eed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将来会添加更多的功能和更多的可配置选项！</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="81d5" class="mn mo it bd mp mq nr ms mt mu ns mw mx jz nt ka mz kc nu kd nb kf nv kg nd ne bi translated">建议</h1><p id="9cd3" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">如果你能对这个项目给出一些反馈，如果你觉得有用，我将不胜感激。</p><h1 id="569c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">感谢阅读！😃</h1><p id="e83f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">希望您喜欢这篇文章以及对混沌代理概念的介绍。</p><p id="1c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我在这里使用了我自己的项目，但是这个概念实现起来非常简单。请随意接受我的项目，叉它或只是做你自己的实现！</p></div></div>    
</body>
</html>