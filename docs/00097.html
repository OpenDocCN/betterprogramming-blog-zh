<html>
<head>
<title>Evolving Patterns in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的进化模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/evolving-patterns-in-react-116140e5fe8f?source=collection_archive---------0-----------------------#2018-02-04">https://betterprogramming.pub/evolving-patterns-in-react-116140e5fe8f?source=collection_archive---------0-----------------------#2018-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="705a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">组合和重用功能的无限可能性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/26f0b5ed1bb07905d088f43cded2e514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJr_bOm3mD5V8_C5JaPrsQ.jpeg"/></div></div></figure><p id="49fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们仔细看看React生态系统中出现的一些模式。这些模式提高了可读性、代码清晰性，并将您的代码推向组合和可重用性。</p><p id="9dd0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大约3年前，我开始与<a class="ae lq" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> React </strong> </a>合作。当时，没有现成的实践可供学习以利用其功能。</p><p id="f3fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个社区花了大约两年的时间确定了一些想法。我们从<code class="fe lr ls lt lu b">React.createClass</code>转向ES6 <code class="fe lr ls lt lu b">class</code>和纯功能组件。我们放弃了mixins，简化了API。</p><p id="7717" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，随着社区比以往任何时候都大，我们开始看到一些好的模式在发展。</p><p id="7330" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了理解这些模式，您需要对React概念及其生态系统有一个基本的了解。但是，请注意，我不会在本文中涉及它们。</p><p id="2eec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f58c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">条件渲染</h1><p id="30c4" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我在很多项目中见过下面的场景。</p><p id="ec54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当人们想到React和JSX时，他们仍然会想到HTML和JavaScript。</p><p id="c19b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以自然的步骤是将条件逻辑从实际返回代码中分离出来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="33e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这往往会失去控制，在每个<code class="fe lr ls lt lu b">render</code>函数的开头有多个<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">三元组</a>。您必须不断地在函数内部跳转，以了解某个元素何时呈现或不呈现。</p><p id="b24f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，尝试下面的模式，在这种模式中，您可以从语言的执行模型中获益。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5032" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe lr ls lt lu b">condition</code>为假，则不计算<code class="fe lr ls lt lu b">&amp;&amp;</code>运算符的第二个操作数。如果为真，则返回第二个操作数，即我们希望渲染的JSX。</p><p id="f531" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这允许我们以声明的方式将UI逻辑与实际的UI元素混合在一起！</p><p id="e6a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对待JSX就像它是你的代码不可分割的一部分！毕竟只是JavaScript。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9125" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">传承道具</h1><p id="1ec8" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">当您的应用程序增长时，您有更小的组件作为其他组件的容器。</p><p id="c7b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当这种情况发生时，您需要通过组件传递大量的道具。组件不需要它们，但是它的子组件需要。</p><p id="e841" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">绕过这一点的一个好方法是使用道具解构和JSX传播，正如你在这里看到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9c78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以现在，你可以改变<code class="fe lr ls lt lu b">Details</code>所需的道具，并确保那些道具不会在多个组件中被引用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5d9f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">破坏道具</h1><p id="f88f" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">一个应用程序会随着时间而变化，你的组件也是如此。您两年前编写的组件可能是有状态的，但现在它可以转换成无状态的。反过来也发生了很多次！</p><p id="21ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们讨论了道具解构，这里有一个我用来让我的生活长期更轻松的好技巧。对于这两种类型的组件，你可以用相似的方式来析构你的道具，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8bd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意到线<code class="fe lr ls lt lu b">2–4</code>和<code class="fe lr ls lt lu b">11–13</code>是<strong class="kw iu">一样的。</strong>使用这种模式转换组件要容易得多。此外，您还限制了组件中<code class="fe lr ls lt lu b">this</code>的使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b4c5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">提供商模式</h1><p id="e421" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们看了一个例子，其中道具需要通过另一个组件向下发送。但是如果你必须把它分成15个部分呢？</p><p id="e4b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进入<a class="ae lq" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">反应上下文</a>！</p><p id="ec47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这不一定是React最值得推荐的特性，但它可以在需要时完成工作。</p><p id="9fcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最近<a class="ae lq" href="https://twitter.com/acdlite/status/956390180637650944" rel="noopener ugc nofollow" target="_blank">宣布</a>上下文正在获得一个新的API，它实现了开箱即用的提供者模式。</p><p id="92ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你正在使用像<a class="ae lq" href="https://github.com/reactjs/react-redux" rel="noopener ugc nofollow" target="_blank"> React Redux </a>或<a class="ae lq" href="https://github.com/apollographql/react-apollo" rel="noopener ugc nofollow" target="_blank"> Apollo </a>这样的东西，你可能对这个模式很熟悉。</p><p id="85ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">了解它如何与当今的API一起工作，也将有助于您理解新的API。你可以玩下面的沙盒。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nb l"/></div></figure><p id="c0ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顶层组件(称为Provider)在上下文中设置一些值。子组件(称为消费者)将从上下文中获取这些值。</p><p id="358c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当前的上下文语法有点奇怪，但是即将到来的版本正在实现这种模式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4a6d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">高阶组件</h1><p id="9d4a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">再来说说复用性。React团队在放弃旧<code class="fe lr ls lt lu b">React.createClass()</code>工厂的同时，也放弃了对<a class="ae lq" href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" rel="noopener ugc nofollow" target="_blank"> mixins </a>的支持。在某种程度上，它们是通过简单对象组合来组合组件的标准方式。</p><p id="371a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>——HOCs从现在开始——被淘汰，以满足跨多个组件重用行为的需求。</p><p id="42eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">HOC是一个函数，它接受一个输入组件并返回该组件的增强/修改版本。你会在不同的名字下找到hoc，但是我喜欢把他们想成装饰者。</p><p id="a9cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你正在使用Redux，你会发现<code class="fe lr ls lt lu b">connect</code>函数是一个特设函数——它接受你的组件，并向它添加一堆<em class="mz">道具</em>。</p><p id="da01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们实现一个可以向现有组件添加道具的基本HOC。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0742" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢函数式编程，你会喜欢使用高阶组件。<a class="ae lq" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank"> Recompose </a>是一个很棒的包，它给了你所有这些漂亮的实用程序，比如<code class="fe lr ls lt lu b">withProps</code>、<code class="fe lr ls lt lu b">withContext</code>、<code class="fe lr ls lt lu b">lifecycle</code>等等。</p><p id="08f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一个非常有用的重用功能的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ad4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你想渲染路线中的敏感内容时，你可以使用<code class="fe lr ls lt lu b">withAuthentication</code>。该内容仅对已登录的用户可用。</p><p id="e7ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个<a class="ae lq" href="https://en.wikipedia.org/wiki/Cross-cutting_concern" rel="noopener ugc nofollow" target="_blank">横切关注点</a>您的应用程序在一个地方实现，并可在整个应用程序中重用。</p><p id="5736" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，HOCs也有不好的一面。每个HOC都会在DOM/vDOM结构中引入一个额外的React组件。随着应用程序的扩展，这可能会导致潜在的性能问题。</p><p id="ff2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">迈克尔杰克逊<a class="ae lq" href="https://twitter.com/mjackson" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae lq" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank">这篇伟大的文章</a>中总结了HOCs的一些其他问题。他主张用我们接下来要讨论的模式来代替HOCs。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7a9f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">渲染道具</h1><p id="36ca" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">虽然渲染道具和技能是可以互换的，但我并不偏爱其中一个。这两种模式都用于提高可重用性和代码清晰度。</p><p id="76f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其思想是将渲染函数的控制权交给另一个组件，然后该组件通过函数属性将控制权传递给你。</p><p id="3c45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些人更喜欢使用动态道具；有的只是用<code class="fe lr ls lt lu b"><strong class="kw iu">this.props.children</strong></code>。</p><p id="9064" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我知道，这仍然很混乱，但是让我们看一个简单的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8ba4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们使用<code class="fe lr ls lt lu b">children</code>作为渲染道具。在<code class="fe lr ls lt lu b"><em class="mz">&lt;ScrollPosition&gt;</em></code>组件中，我们将发送一个接收<code class="fe lr ls lt lu b">position</code>作为参数的函数。</p><p id="75f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">渲染道具可用于需要在组件中使用一些可重用的逻辑，并且不想将组件包装在一个HOC中的情况。</p><p id="16bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React-Motion 是一个提供一些使用渲染道具的例子的库。</p><p id="519f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们看看如何将异步流与渲染道具集成在一起。这里有一个创建可重用<code class="fe lr ls lt lu b">Fetch</code>组件的好例子。</p><p id="b84d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我正在分享一个沙盒链接，所以你可以玩它，并看到结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nb l"/></div></figure><p id="b55b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同一个组件可以有多个渲染道具。有了这种模式，您就有无限的组合和重用功能的可能性。</p><p id="fbfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你用什么样的模式？他们中的哪一个适合这篇文章？</p></div></div>    
</body>
</html>