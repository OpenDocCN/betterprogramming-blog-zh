<html>
<head>
<title>Avoid Writing Another For-Loop in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免在JavaScript中编写另一个For循环</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/never-write-another-for-loop-in-javascript-9db11afa6445?source=collection_archive---------2-----------------------#2019-10-13">https://betterprogramming.pub/never-write-another-for-loop-in-javascript-9db11afa6445?source=collection_archive---------2-----------------------#2019-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dcaa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高代码可读性的七个高阶函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0eb35677cd05dbfde2e1adb0dfc8db6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gPjrw0W9s19yE03N"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为初级工程师，我们大多数人都有一种从零开始构建东西并对代码进行更多控制的内在愿望。在JavaScript中处理数组和对象时，我们中的一些人可能更喜欢使用for循环来遍历元素或键，同时执行某种形式的逻辑。嗯，这样做并不一定是错误的——控制回路是我们在计算机科学课上学到的最初几样东西之一。但重要的是要注意Javascript中内置的高阶函数，我们都可以利用它们来使我们的代码更加优雅、可读和简洁。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="38ac" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是高阶函数？</h1><p id="067d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">以防我们可能已经忘记，这里是定义:</p><blockquote class="na nb nc"><p id="b9ba" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">高阶函数是一个函数，它接受一个函数作为参数，或者返回一个函数。</p></blockquote><p id="bc6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将讨论我最常用的七个高阶Javascript函数。在每一节中，我将尝试解释<em class="lv">何时</em>和<em class="lv">如何</em>使用这些功能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="567e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.forEach()</h1><p id="ea7e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">forEach()</code>方法接受一个函数，并对数组中的每个元素执行该函数。</p><h2 id="99db" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">何时使用它</h2><p id="2c71" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">forEach()</code>是一个通用工具，可用于许多情况，包括其他高阶函数所涵盖的情况。然而，我们应该记住，如果有更具体的高阶函数可以使用，我们应该总是使用它们而不是<code class="fe ng nh ni nj b">forEach().</code>我将更深入地研究这一部分，以便我们可以更好地理解本文后面的其他函数。</p><h2 id="9578" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">句法</h2><p id="ec10" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">arr.forEach(callback(currentValue [, index [, array]])[, thisArg]);</code></p><p id="17a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最基本的层面上，传递给<code class="fe ng nh ni nj b">forEach</code>的函数需要有被迭代的<code class="fe ng nh ni nj b">currentValue</code>，在下面的例子中被恰当地命名为<code class="fe ng nh ni nj b">elem</code>。其他可选参数用方括号标出。</p><h2 id="2308" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">例子</h2><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="a74a" class="nk me it nj b gy oa ob l oc od">const array = ['a', 'b', 'c'];<br/>array.forEach(function(elem) {<br/>    // using template literals here<br/>    console.log(`Printing ${elem}`); <br/>});</span><span id="4c59" class="nk me it nj b gy oe ob l oc od">// Printing a<br/>// Printing b<br/>// Printing c</span></pre><p id="44c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明我们如何使用<strong class="lb iu"> </strong>这个可选参数，我们来看一个类似的例子:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="460d" class="nk me it nj b gy oa ob l oc od">const array = ['a', 'b', 'c'];<br/>array.forEach(function(elem, index, array) {<br/>    console.log(`${elem} is at position ${index} of [${array}]`);<br/>});</span><span id="b4f7" class="nk me it nj b gy oe ob l oc od">// a is at position 0 of the array [a, b, c]</span></pre><p id="55d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们甚至可以传入<code class="fe ng nh ni nj b">this</code>的值，以便在我们传入<code class="fe ng nh ni nj b">forEach</code>的函数范围内使用:</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="e307" class="nk me it nj b gy oa ob l oc od">const array = ['a', 'b', 'c'];<br/>array.forEach(function(elem, index, array) {<br/>    console.log(array == this); // checking for pointer equality<br/>}, array); // pass in `this` as optional param</span><span id="d931" class="nk me it nj b gy oe ob l oc od">// true</span></pre><h1 id="6709" class="md me it bd mf mg of mi mj mk og mm mn jz oh ka mp kc oi kd mr kf oj kg mt mu bi translated">2.减少()</h1><h2 id="87c2" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">何时使用</h2><p id="681d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">reduce()</code>是一个非常强大的方法，可以通过执行<strong class="lb iu"> reducer </strong>函数从数组中导出<strong class="lb iu">单值</strong>。</p><p id="0d3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来可能有点复杂，但其思想是使用正在迭代的当前值，并以某种方式将其与在每次迭代中逐步处理的累加器集成。如果这个概念对你来说听起来仍然模糊不清，下面的例子应该会给你更多的启发。</p><p id="1a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个对象按部分存储考试分数，我们想得到总分。因为我们想要一个单一的值，<code class="fe ng nh ni nj b">reduce()</code>是我们在这里应用的一个很好的方法。</p><h2 id="666c" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">句法</h2><p id="5373" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code></p><h2 id="d222" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">例子</h2><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="cf3c" class="nk me it nj b gy oa ob l oc od">const scoresBySection = {<br/>    math: 60,<br/>    reading: 70,<br/>    writing: 87,<br/>};</span><span id="4f85" class="nk me it nj b gy oe ob l oc od">const sectionNames = Object.keys(scoresBySection); // get array<br/>const marks = sectionNames.reduce(function(accumulator, sectionName) {<br/>    // the return value will be the accumulator for next iteration<br/>    return accumulator + scoresBySection[sectionName];<br/>}, 0) // initial value</span><span id="cfe0" class="nk me it nj b gy oe ob l oc od">console.log(marks) // 217</span></pre><p id="ce96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇文章中，我还写了如何使用<code class="fe ng nh ni nj b">reduce()</code>安全地访问对象中的值。</p><h1 id="5b34" class="md me it bd mf mg of mi mj mk og mm mn jz oh ka mp kc oi kd mr kf oj kg mt mu bi translated">3.地图()</h1><h2 id="25be" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">何时使用它</h2><p id="25eb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果我们需要对数组进行修改，我们仍然可以使用<code class="fe ng nh ni nj b">forEach()</code>以如下方式完成:</p><h2 id="b07d" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">句法</h2><p id="73eb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">var new_array = arr.map(function callback(currentValue[, index[, array]]) {<br/> // Return element for new_array<br/>}[, thisArg])</code></p><h2 id="a833" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">例子</h2><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="6560" class="nk me it nj b gy oa ob l oc od">const array = [1, 2, 3];<br/>array.forEach(function(elem, index, array) {<br/>    array[index] = elem * 2;<br/>});</span><span id="01fb" class="nk me it nj b gy oe ob l oc od">console.log(array); // [2,4,6]</span></pre><p id="27bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我们应该总是尽可能使用另一个高阶函数而不是<code class="fe ng nh ni nj b">forEach()</code>吗？如果我们想对现有数组进行一对一的转换，我们应该使用<code class="fe ng nh ni nj b">map().</code>对每个当前值执行传入的函数，并返回一个<strong class="lb iu">新数组</strong>。</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="7191" class="nk me it nj b gy oa ob l oc od">let array = [1,2,3];<br/>array = array.map(function(elem) {<br/>    return elem * 2;<br/>});</span><span id="eaae" class="nk me it nj b gy oe ob l oc od">console.log(newArray); // [2,4,6]</span></pre><p id="4190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的一件重要事情是，我们使用了声明符<code class="fe ng nh ni nj b">let</code>而不是<code class="fe ng nh ni nj b">const</code>，因为我们从<code class="fe ng nh ni nj b">map(),</code>获得了一个新数组，因此我们需要用一个新值给变量<code class="fe ng nh ni nj b">array</code>重新赋值。</p><h1 id="a86b" class="md me it bd mf mg of mi mj mk og mm mn jz oh ka mp kc oi kd mr kf oj kg mt mu bi translated">4.过滤器()</h1><h2 id="14d6" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">何时使用它</h2><p id="e00e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可以想象，我们并不总是希望所有的值都在一个数组中。有时我们只想要那些符合特定资格条件的。我们可以用<code class="fe ng nh ni nj b">filter</code>筛选出那些我们想要得到的原始数组的子集。与<code class="fe ng nh ni nj b">map()</code>类似，<code class="fe ng nh ni nj b">filter()</code>返回一个新的数组。</p><h2 id="a0a4" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">句法</h2><p id="cd26" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</code></p><h2 id="ea7f" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">例子</h2><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="5e2c" class="nk me it nj b gy oa ob l oc od">const array = [1,2,3,4,5];<br/>const evenNumbers = array.filter(function(elem) {<br/>   // expressions that return 'true' are retained<br/>   return elem % 2 == 0;<br/>});</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1433" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">5.查找()</h1><h2 id="c59c" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">何时使用它</h2><p id="1f2b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在数组中搜索一个元素并不一定是大海捞针。<code class="fe ng nh ni nj b">find()</code>返回满足条件的<strong class="lb iu">第一个元素，</strong>如果有的话。一旦找到该元素，就会立即返回。</p><h2 id="f641" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">句法</h2><p id="5c60" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">arr.find(callback(element[, index[, array]])[, thisArg])</code></p><h2 id="14cc" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">例子</h2><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="0863" class="nk me it nj b gy oa ob l oc od">const array = [1,4,4,5];<br/>const result = array.find(function(elem, index) {<br/>   console.log(`Index: ${index}`);<br/>   return elem === 4;<br/>});<br/>console.log(`Result: ${result}`);</span><span id="32d5" class="nk me it nj b gy oe ob l oc od">// Index: 0<br/>// Index: 1<br/>// Result: 4</span></pre><h1 id="e44a" class="md me it bd mf mg of mi mj mk og mm mn jz oh ka mp kc oi kd mr kf oj kg mt mu bi translated">6.一些()</h1><h2 id="0e06" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">何时使用它</h2><p id="aff3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有时，我们可能想要找出在数组中是否有至少一个满足条件的<em class="lv">元素。<code class="fe ng nh ni nj b">some()</code>返回一个布尔值，告诉我们这样的元素是否存在。</em></p><h2 id="b8d8" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">句法</h2><p id="4986" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">arr.some(callback(element[, index[, array]])[, thisArg])</code></p><h2 id="53b3" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">例子</h2><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="c972" class="nk me it nj b gy oa ob l oc od">const array = [1,4,4,5];<br/>const hasAtLeastAFour = array.some(function(elem) {<br/>   return elem === 4;<br/>});<br/>console.log(hasAtLeastAFour);</span><span id="d918" class="nk me it nj b gy oe ob l oc od">// true</span></pre><h1 id="2050" class="md me it bd mf mg of mi mj mk og mm mn jz oh ka mp kc oi kd mr kf oj kg mt mu bi translated">7.每隔()</h1><h2 id="8a03" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">何时使用它</h2><p id="2f80" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最后，我们可能想要找出数组中的每个 <strong class="lb iu"> </strong>元素是否都满足某个条件。同样，<code class="fe ng nh ni nj b">every()</code>如果所有元素都满足条件，则返回true，否则返回false。</p><h2 id="745c" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">句法</h2><p id="5df6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe ng nh ni nj b">arr.every(callback(element[, index[, array]])[, thisArg])</code></p><h2 id="747e" class="nk me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">例子</h2><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="4f2b" class="nk me it nj b gy oa ob l oc od">const array = [1,4,4,5];<br/>const allFours = array.every(function(elem) {<br/>   return elem === 4;<br/>});<br/>console.log(allFours);</span><span id="b4dc" class="nk me it nj b gy oe ob l oc od">// false</span></pre><h1 id="afed" class="md me it bd mf mg of mi mj mk og mm mn jz oh ka mp kc oi kd mr kf oj kg mt mu bi translated">最终注释</h1><p id="9ca0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在上面的例子中，我使用了<code class="fe ng nh ni nj b">function</code>关键字，但是在ES6中，我们可以使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头函数</a>来获得更简洁的语法。除了简洁之外，arrow函数没有绑定到<code class="fe ng nh ni nj b">this,</code>，这可能根据您的情况有所帮助(例如，使用外部作用域的<code class="fe ng nh ni nj b">this</code>)。</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="70f0" class="nk me it nj b gy oa ob l oc od">array.forEach((elem, index) =&gt; {<br/>    ...<br/>});</span></pre><p id="5b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我已经谈到了我经常使用的七个高阶函数，但是您可以在<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"> MDN web文档</a>中找到更多。你通常不需要花时间从头开始写代码，因为已经有本地函数为我们做了。在从头开始编写代码之前，我们应该总是尝试利用现有的资源。</p><p id="689e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能有所帮助。如果你注意到一些不正确的地方，或者可以解释得更好的地方，请随意留言。感谢阅读！</p></div></div>    
</body>
</html>