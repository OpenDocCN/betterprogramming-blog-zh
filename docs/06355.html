<html>
<head>
<title>The State of Typed Vuex: The Cleanest Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型化Vuex的状态:最干净的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-state-of-typed-vuex-the-cleanest-approach-2358ee05d230?source=collection_archive---------0-----------------------#2020-09-24">https://betterprogramming.pub/the-state-of-typed-vuex-the-cleanest-approach-2358ee05d230?source=collection_archive---------0-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8188" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你避免使用Vuex是因为有太多的样板文件还是因为它不完全提供类型脚本支持？继续读</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e7335bb73ce8a6575c020c362766b802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tIfnn50whmoLsEg6kU4WA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="3b3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你尝试过将<a class="ae lr" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>与<a class="ae lr" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>一起使用，你会意识到这不是一个简单的任务。Vuex不提供现成的处理TypeScript的工具。TypeScript对我们许多人来说都很重要，因为它允许我们编写静态类型的JavaScript，主要好处是通过IDE类型点击改善了开发体验。</p><p id="49a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们想要实现的是类型安全的Vuex模块，当我们传递错误的突变/getter/action类型或错误的参数时，它会通知我们——这可以通过几种不同的方式实现。我们将看看如何在没有外部库的情况下实现这一点，然后我们将评估目前存在的选项。最后，我们将做出一个相当主观的决定，哪个是最干净的。</p><p id="a528" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些是我们将尝试的选项:</p><ul class=""><li id="7c72" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><a class="ae lr" href="https://dev.to/3vilarthas/vuex-typescript-m4j" rel="noopener ugc nofollow" target="_blank">平原</a></li><li id="28d0" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="https://github.com/ktsn/vuex-class" rel="noopener ugc nofollow" target="_blank"> vuex级</a></li><li id="c143" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="https://github.com/mrcrowl/vuex-typex" rel="noopener ugc nofollow" target="_blank"> vuex-typex </a></li><li id="b33a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="https://github.com/ktsn/vuex-smart-module" rel="noopener ugc nofollow" target="_blank"> vuex智能模块</a></li><li id="f305" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="https://github.com/michaelolof/vuex-class-component" rel="noopener ugc nofollow" target="_blank"> vuex-class-component </a></li><li id="3e1a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="https://github.com/gertqin/vuex-class-modules" rel="noopener ugc nofollow" target="_blank"> vuex类模块</a></li><li id="9ea5" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="https://github.com/championswimmer/vuex-module-decorators" rel="noopener ugc nofollow" target="_blank"> vuex模块装饰器</a></li></ul><p id="5fd9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使Vue 3即将到来，与相应的Vuex 4一起，使用情况也不会从Vuex方面发生变化，因为它的变化主要与Vue 3的兼容性有关。为了澄清任何混淆，Vue 3的<a class="ae lr" href="https://composition-api.vuejs.org/api.html#reactivity-apis" rel="noopener ugc nofollow" target="_blank">反应API </a>并不意味着取代Vuex。它只是提供了更好的工具来处理那些已经不需要Vuex的情况。</p><p id="ad08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是说，在Vue.js全球在线会议上有一个<a class="ae lr" href="https://www.youtube.com/watch?v=ajGglyQQD0k&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">演讲</a>概述了Vuex 5的路线图。它将没有突变，只有动作，以及定义/注册存储的新方法，包括常规组合API。有了这些更改，这里列出的选项都不是TypeScript集成所必需的。不幸的是，它不太可能在2021年的某个时候发布，因为它甚至还没有RFC。</p><p id="7c57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">说够了，让我们写点代码吧。您可以直接进入实例，亲自查看这个<a class="ae lr" href="https://codesandbox.io/s/vuex-typescript-solutions-comparison-lw4rn" rel="noopener ugc nofollow" target="_blank">沙盒</a>中的不同选项，或者看一看这个<a class="ae lr" href="https://github.com/cuzox/vuex-typescript-solutions-comparison" rel="noopener ugc nofollow" target="_blank">回购</a>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="a0b4" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">设置</h1><p id="7725" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">需要注意的是，Vuex在模块中分离功能。这些模块彼此独立地定义，并且用于表示信息和相应功能的逻辑组。让我们定义一些常见的类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0e8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个模块都有一个<code class="fe nm nn no np b">persons</code>属性，它是这个人的<code class="fe nm nn no np b">id </code>和他的<code class="fe nm nn no np b">Person</code>之间的映射。我们将有一个用静态数据填充这个属性的动作，以及一个聚集一个人的<code class="fe nm nn no np b">name</code>和<code class="fe nm nn no np b">lastName.</code>的getter</p><p id="850c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们的<code class="fe nm nn no np b">stores</code>文件在Vue 2/Vuex 3中的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cfb9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Vue 3/Vuex 4:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2bd8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在这里有两个存储，因为<code class="fe nm nn no np b">plainStore</code>将被完全类型化，传递给Vue构造函数，并被直接或通过Vue组件实例中的<code class="fe nm nn no np b">$store</code>属性访问。但是<code class="fe nm nn no np b">modulesStore</code>不会注册，它的模块会单独导入。向<code class="fe nm nn no np b">Vuex.Store</code>构造函数/ <code class="fe nm nn no np b">createStore</code>方法传递空对象，因为我们将动态注册模块<a class="ae lr" href="https://vuex.vuejs.org/guide/modules.html#dynamic-module-registration" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b7f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的<code class="fe nm nn no np b">main.ts</code>在Vue 2/Vuex 3中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="71b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Vue 3/Vuex 4:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="07c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我稍后会解释<code class="fe nm nn no np b">PlainStore</code>类型的来源。出于演示的目的，Vue组件定义将使用<a class="ae lr" href="https://github.com/kaorun343/vue-property-decorator" rel="noopener ugc nofollow" target="_blank"> vue-property-decorator </a>，它依赖于<a class="ae lr" href="https://github.com/vuejs/vue-class-component" rel="noopener ugc nofollow" target="_blank"> vue-class-component </a>，尽管使用与组合API相同。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="eda6" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">1.平原</h1><p id="2422" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">您确实可以在没有外部库的情况下完成一个完全类型化的Vuex存储。我们需要为普通商店定义这些类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ca6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no np b">PersonModule</code>:将是<code class="fe nm nn no np b">plain</code> Vuex模块<br/> <code class="fe nm nn no np b">RootState</code>的类型:将是根状态的类型(<code class="fe nm nn no np b">plainStore</code>的状态)。我们将普通模块粘贴到根状态的<code class="fe nm nn no np b">plain</code>属性中。</p><p id="0055" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以写出突变:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2bcf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no np b">MutationTypes</code>:带有突变名称的<code class="fe nm nn no np b">enum</code>。我们这样做是为了避免在应用程序中手动输入变异名称，并在IDE中获得自动完成功能。</p><p id="508e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no np b">Mutations</code>:突变类型签名的定义。只有这些已定义的突变的类型安全实现需要这一点，以便我们可以在以后构造更复杂的<code class="fe nm nn no np b">PlainStore</code>类型。</p><p id="1d96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no np b">mutations</code>:突变名称到它们的实现的映射。此时，由于Vuex的内置类型<code class="fe nm nn no np b">MutationTree</code>和我们的<code class="fe nm nn no np b">Mutations</code>类型之间的联合，我们将对参数<code class="fe nm nn no np b">state</code>和<code class="fe nm nn no np b">persons</code>进行类型检查。</p><p id="da56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">getters遵循类似的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1d8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在行动，有一个额外的组成部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="884b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您在Vuex中定义一个动作函数时，第一个参数是包含一个<code class="fe nm nn no np b">commit</code>函数的<code class="fe nm nn no np b">ActionContext</code>类型。此功能允许您触发当前模块(或任何其他模块，如果指定了<code class="fe nm nn no np b">{root: true}</code>)中定义的突变。这个提交函数的默认类型允许您用任何字符串调用<code class="fe nm nn no np b">commit</code>。我们想对此加以限制，这样<code class="fe nm nn no np b">commit</code>只能用我们模块中定义的突变来调用。</p><p id="d2d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是通过增加默认的<code class="fe nm nn no np b">ActionContext</code>并相应地修改<code class="fe nm nn no np b">commit</code>函数的类型来实现的。请记住，如果您想要调用全局突变或来自其他模块的突变，在动作内的<code class="fe nm nn no np b">commit</code>函数中指定<code class="fe nm nn no np b">{root: true}</code>，您必须聚集所有的突变，并使用它来增加<code class="fe nm nn no np b">ActionContext</code>，而不是像我们在这里所做的那样，仅仅是来自这个模块的突变。(下面我这样做是为了创建<code class="fe nm nn no np b">PlainStore</code>类型。)</p><p id="119a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们已经成功定义了Vuex模块，我们必须在商店中注册它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1208" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要做的最后一件事是构造<code class="fe nm nn no np b">PlainStore</code>类型，这是您访问<code class="fe nm nn no np b">state</code>、<code class="fe nm nn no np b">commit</code>、<code class="fe nm nn no np b">dispatch</code>和<code class="fe nm nn no np b">getters</code>的实际商店的类型。如果我们试图访问不存在的<code class="fe nm nn no np b">state</code>或<code class="fe nm nn no np b">getters</code>，或者使用错误的<code class="fe nm nn no np b">type</code>或参数调用<code class="fe nm nn no np b">commit</code>或<code class="fe nm nn no np b">dispatch</code>，我们希望对这些属性进行类型检查并得到错误。</p><p id="d23b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了定义<code class="fe nm nn no np b">PlainStore</code>，我们希望从我们所有的模块中收集所有的突变、getters和动作<strong class="kx ir"> </strong>，并通过与TypeScript的<code class="fe nm nn no np b">&amp;</code>操作符的联合将它们合并。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d668" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经完成了对<code class="fe nm nn no np b">Plain</code>人员模块的定义和注册。关于如何在组件中访问它，我们有两个选项。我们可以通过<code class="fe nm nn no np b">this.$store</code>(注入)来访问它，也可以直接在每个组件中导入存储(导入)。</p><h2 id="bb88" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated">注射</h2><p id="d362" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">要通过<code class="fe nm nn no np b">this.$store</code>访问我们的类型化存储，我们需要覆盖Vuex的默认<code class="fe nm nn no np b">$store</code>类型定义，这目前只在Vuex 4(和Vue 3一起)中受支持，所以如果是你，你需要做的就是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="be89" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是如果你使用Vuex 3(和Vue 2一起)，你需要创建另一个属性，因为你不能覆盖<code class="fe nm nn no np b">$store</code>类型。我们可以称之为<code class="fe nm nn no np b">$vuex</code>(或者别的什么):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5275" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们需要定义实际的属性，它只是<code class="fe nm nn no np b">$store</code>的一个getter:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4453" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后你可以像这样访问<code class="fe nm nn no np b">$store</code>或<code class="fe nm nn no np b">$vuex</code>(取决于你在上面做了什么):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="c8f9" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated">进口</h2><p id="0318" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">这种用法要简单得多，因为我们用它的<code class="fe nm nn no np b">PlainStore</code>类型导出了商店，所以我们可以直接导入并使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0164" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您所料，<code class="fe nm nn no np b">$store</code>(或者您称之为商店属性的任何东西)将在<strong class="kx ir">注入</strong>和<strong class="kx ir">导入</strong>场景中被完全键入。</p><h2 id="8df1" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated">命名空间模块</h2><p id="e8bb" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">如果我们想将我们的普通模块命名为<a class="ae lr" href="https://vuex.vuejs.org/guide/modules.html#namespacing" rel="noopener ugc nofollow" target="_blank"/>,这会是什么样子呢？我们需要为我们的每个突变、获取器和动作定义单独的枚举和类型签名。</p><p id="6515" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">主要的问题是，在我们的模块定义中，所有的名称常量都不使用名称空间前缀，因为它们是本地化的。在模块定义之外，它们有前缀。所以在命名空间模块的动作内部，你可以提交<code class="fe nm nn no np b">nameOfMutation</code>，但是如果你想从一个组件提交它，你必须提交<code class="fe nm nn no np b">prefix/nameOfMutation</code>。</p><p id="7790" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近<a class="ae lr" href="https://github.com/microsoft/TypeScript/pull/40336" rel="noopener ugc nofollow" target="_blank">合并了</a> (dev branch) TypeScript特性，理论上允许我们通过模板文字类型动态构造命名空间签名。不幸的是，我无法做到这一点，所以我们不得不一个接一个地重新定义签名。</p><p id="9aea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将只针对突变实现这一点，因此您会有一个想法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="97f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们必须为不同的变异定义单独的枚举，包括有和没有名称空间前缀的(内部的不带前缀，用于定义这个模块，外部的带前缀，用于导出和在其他地方使用)。</p><h2 id="4e58" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated"><strong class="ak">印象</strong></h2><p id="943d" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">那是相当痛苦的。如果这是一首歌，那么它将会在69个国家被禁止。对于大型模块，这种方法会很快失控。不是愉快的经历。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f9aa" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">2.vuex级</h1><p id="47ee" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">我们要看的第一个第三方解决方案是<a class="ae lr" href="https://github.com/ktsn/vuex-class" rel="noopener ugc nofollow" target="_blank"> vuex-class </a>。尽管它在技术上是一个类型脚本库，但它并没有真正提供任何工具来实现类型安全。因此，不幸的是，它仍然需要付出巨大的努力才能大规模实现。您不需要类型化的存储定义来使用它，因为vuex-class无论如何都不会访问它。该类型将直接位于组件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b953" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样做的问题是，您需要手动定义每个资源的类型。如果您在不同的组件中使用相同的资源，您将在每个组件中定义相同的类型。这在规模上并不理想，因为组件之间的类型可能不同，所以更改任何这些资源的实现或类型，而不成功地更新访问它的每个组件，可能会导致不会立即变得明显的错误，而这些错误正是TypeScript旨在防止的。</p><p id="5314" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了有效地实现vuex-class，我们最好用与上面简单方法相同的方式定义存储资源及其类型签名。如果我们这样做了，我们就可以构造一个类型来聚集相关的资源以便于访问:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6c6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们可以在组件中使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="260d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但在这一点上，果汁绝对不值得挤。</p><h2 id="ee7c" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated"><strong class="ak">观感</strong></h2><p id="2762" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">为了有效地使用vuex-class，我们仍然需要大量的手工劳动。因此，与仅使用普通方法类型化的导入存储相比，它没有任何优势。我不建议任何球队使用vuex-class。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="4447" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak"> 3。vuex-typex </strong></h1><p id="70d8" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">我们要看的第一个真正为我们节省击键次数的库是<a class="ae lr" href="https://github.com/mrcrowl/vuex-typex" rel="noopener ugc nofollow" target="_blank"> vuex-typex </a>。它有一个可组合的API，提示我们分别定义所有的东西，然后把它们放在一起进行模块定义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a69b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">变异和动作像普通函数一样被定义，但是getters是通过模块构建器定义的，要么通过<code class="fe nm nn no np b">b.read</code>要么通过<code class="fe nm nn no np b">b.state</code>。所有的东西都被放入一个常量中，然后我们将它导出。这个API相当混乱，因为我们注册的普通Vuex模块或者我们关联的商店不是我们刚刚放在一起的模块，而是模块构建器。我们直接使用Vuex商店注册模块，然后将模块构建器与商店相关联。</p><p id="d023" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们在组件中使用它的方式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="cf9b" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated">印象</h2><p id="371d" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">API有点奇怪，到处都是，看起来不太干净。模块构建器API不太直观，似乎我们必须调用一堆函数来正确注册。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b7b8" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">4.vuex智能模块</h1><p id="d4d4" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">我们现在将探索由Vuex的核心贡献者之一制作的库，<a class="ae lr" href="https://github.com/ktsn/vuex-smart-module" rel="noopener ugc nofollow" target="_blank"> vuex智能模块</a>。它尽可能接近Vuex API。默认情况下，本库命名空间模块。这就是事情开始变得有趣的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6fe1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到，这与我们通常定义Vuex模块的方式非常接近。不是每种类型的资源都有一个对象，而是有一个以资源作为类函数/访问器的类。</p><p id="2999" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们完成了对它们的定义，我们就将它们传递给提供的<code class="fe nm nn no np b">Module</code>函数，该函数组装资源。我们正在用vuex-smart-module自己的<code class="fe nm nn no np b">registerModule</code>函数注册该模块。它将存储、这个模块在根<code class="fe nm nn no np b">state</code>中的路径名、名称空间的路径以及我们正在注册的模块作为参数。</p><p id="0476" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了导出一个现成的Vuex模块，<code class="fe nm nn no np b">Module</code>实例有一个<code class="fe nm nn no np b">context</code>方法，该方法返回与传入的存储相关联的模块。我们可以在组件中直接导入该模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="f6a3" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated">印象</h2><p id="174e" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">这是固溶体。它建立在原始Vuex API之上，并尊重它，利用类的力量，包含类型签名和实现。它是由Vuex的作者制作的，所以我们知道它很健壮。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b899" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">5.vuex类组件</h1><p id="ba7c" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated"><a class="ae lr" href="https://github.com/michaelolof/vuex-class-component" rel="noopener ugc nofollow" target="_blank"> vuex-class-component </a>也使用类语法来定义vuex模块，但它更进一步，允许我们在一个类中定义所有内容。然后，这个类被转换成Vuex模块对象定义，可以像任何其他类一样使用。默认情况下，本库命名空间模块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b654" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那是一股新鲜空气。如您所见，我们提供了<code class="fe nm nn no np b">mutation</code>和<code class="fe nm nn no np b">action</code>装饰器，用于从函数中创建同名的资源。类属性变成了状态属性，而<code class="fe nm nn no np b">get</code>访问器变成了传统的类获取器。</p><p id="95c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一次我们使用Vuex自己的<code class="fe nm nn no np b">registerModule</code>来动态地将它注册到store实例<code class="fe nm nn no np b">modulesStore</code>。<code class="fe nm nn no np b">createProxy</code>只是返回一个代理给我们关联到<code class="fe nm nn no np b">modulesStore</code>的模块。</p><p id="eb93" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它可以导入并直接使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e8c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模块直接导入，确保类型安全。</p><h2 id="e4f9" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated">印象</h2><p id="0382" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">这就是我们一直想要的:一种清晰的方式来定义我们的Vuex模块，以及访问它们时的完全类型安全。这个能顶吗？我们必须继续观察。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="0ed3" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">6.vuex类模块</h1><p id="938a" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated"><a class="ae lr" href="https://github.com/gertqin/vuex-class-modules" rel="noopener ugc nofollow" target="_blank"> vuex-class-modules </a>是<a class="ae lr" href="https://github.com/michaelolof/vuex-class-component" rel="noopener ugc nofollow" target="_blank"> vuex-class-component </a>的分支。它改进的只是类的定义方式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="28ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们将其与vuex-class-component的模块定义进行比较时，我们可以看到我们现在有了一个<code class="fe nm nn no np b">Module</code> decorator，并且我们可以使用我们定义的同一个类来创建一个新的实例，它将做两件事:在存储中注册模块并返回一个可用的命名空间模块(默认情况下命名空间)。</p><p id="b48e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">组件的使用与vuex-class-componen <code class="fe nm nn no np b">t</code>完全相同。</p><h2 id="234d" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated">印象</h2><p id="0204" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">和vuex-class-component差不太多。我们只是得到了更多的工具来节省我们的击键次数。相当可靠。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="3daf" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">7.vuex-模块-装饰者</h1><p id="7af1" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated"><a class="ae lr" href="https://github.com/championswimmer/vuex-module-decorators" rel="noopener ugc nofollow" target="_blank"> vuex-module-decorators </a>实现了与之前库相同的概念(类语法)。然而，我们得到了一些更有用的装饰器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="25f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">vuex-module-decorator提供了一个<code class="fe nm nn no np b">Module</code>装饰器来包装我们的类并接受一些选项。<code class="fe nm nn no np b">store</code>选项将负责将这个模块关联到我们的<code class="fe nm nn no np b">modulesStore</code>，而<code class="fe nm nn no np b">name</code>将是这个模块在状态中的属性，以及它的名称空间(默认情况下是这个库名称空间)。</p><p id="090b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">vuex-module-decorators提供了<code class="fe nm nn no np b">getModule</code>函数，该函数将返回一个类型化的可用模块，该模块的使用方式与我们的组件中的vuex-class-component完全相同。</p><p id="9217" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一直是Vuex的一个痛点，事实上我们需要为状态中我们想要改变的每个属性创建突变。通过非常有趣的装饰器<code class="fe nm nn no np b">MutationAction</code>，如果我们只想直接分配一个或多个状态属性，我们不需要创建一个突变。</p><p id="a40e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从修饰函数返回的对象中包含的属性将通过在幕后创建的变异直接分配给相应的状态属性。这是一个有影响力的助手装饰器，显著改善了Vuex体验。</p><h2 id="af1e" class="nq mo iq bd mp nr ns dn mt nt nu dp mx le nv nw mz li nx ny nb lm nz oa nd ob bi translated">印象</h2><p id="3ed4" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">它为定义和使用Vuex模块提供了最简洁和紧凑的API，利用了类，并提供了额外的decorators选项，使开发更容易。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="1af8" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">清洁的</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cca7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是毫无疑问的。在我们讨论的所有选项中，vuex-module-decorators独占鳌头。它的API很简单，让我们可以访问一个直到Vuex 5发布时才会出现的特性(尽管是模拟的):动作和突变的合并。它允许我们编写最少的代码，同时不影响可读性和可用性。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="fcb3" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="00f7" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">当希望将TypeScript集成到您的存储中时，如果您不想使用任何外部库，简单的方法已经满足了您的要求(如果您喜欢这类东西；虽然不知道你为什么要这样对自己)。如果你想要更好的开发体验，我们这里有很多很好的选择。</p><p id="7b89" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我个人不推荐普通、vuex-class或vuex-typex，因为它们会很快失控。但是vuex-smart-module、vuex-class-decorator、vuex-class-modules和vuex-module-decorator都是很好的替代品，得到了不错的社区认可，其中最受欢迎的是vuex-module-decorator(也是我最干净的头衔的获得者)。它们也是非常即插即用的，所以你不必重写所有的存储模块，你可以定义和动态注册新的模块。</p><p id="af06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，你可以看到他们生活在这个<a class="ae lr" href="https://codesandbox.io/s/vuex-typescript-solutions-comparison-lw4rn" rel="noopener ugc nofollow" target="_blank">沙盒</a>中，或者看一看<a class="ae lr" href="https://github.com/cuzox/vuex-typescript-solutions-comparison" rel="noopener ugc nofollow" target="_blank">代码</a>。</p><p id="bc9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">性能对这些库来说都不是问题，因为最终，它们都构建并注册了一个常规的旧Vuex模块。</p><p id="0368" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以不要害怕Vuex。使用它可以是愉快而简单的，并且您可以受益于强大的<a class="ae lr" href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en" rel="noopener ugc nofollow" target="_blank">开发工具</a>支持，以及实时检查和时间旅行调试。</p><p id="33bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们开始编写一些干净的、类型检查过的Vuex模块吧！</p></div></div>    
</body>
</html>