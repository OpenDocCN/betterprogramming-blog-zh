<html>
<head>
<title>Subscribing to Observables in Ongoing Angular Lifecycle Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">订阅正在进行的角度生命周期钩子中的可观测量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/subscribing-observables-in-ongoing-angular-lifecycle-hooks-473224afda?source=collection_archive---------8-----------------------#2020-09-03">https://betterprogramming.pub/subscribing-observables-in-ongoing-angular-lifecycle-hooks-473224afda?source=collection_archive---------8-----------------------#2020-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="86ba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您应该如何对待正在进行的生命周期挂钩中的订阅，例如<strong class="ak"> OnChanges，而不会导致性能问题</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f0d87d8e8c638cb5fdcb2413b10b5894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQi6IXasI8x2sJZgPRFRsA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="9f5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们开始之前，让我们弄清楚:组件生命周期挂钩中的手动订阅是处理可观察性的最差方式。如果没有其他选择，并且使用<code class="fe ls lt lu lv b">async</code>管道不能像预期的那样工作，那么您可以继续阅读以了解如何安全地实现这一点，并避免您的应用程序周围的僵尸订阅，这最终会导致意外的内存泄漏。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="f706" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">一个真实的案例</h1><p id="ddf6" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">在我们的例子中，我选择实现一个指令，将它的主机元素事件记录到某个用户分析提供者。为了简单起见，我将不描述服务是如何实现的，而是将重点放在我们的指令中的事件注册上。</p><p id="aaa7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，让我们看看指令是什么样子的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="96f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您所看到的，这个指令提供了几个可配置的输入，比如<code class="fe ls lt lu lv b">events</code>(指示应该监听哪些事件)和<code class="fe ls lt lu lv b">properties</code>(允许我们为记录的事件附加一些额外的属性)。<code class="fe ls lt lu lv b">properties</code>不是问题演示所必需的，但我承诺了一个真实世界的例子，不是吗？</p><p id="8676" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们回顾一下可用的方法。<code class="fe ls lt lu lv b">ngOnChanges</code>使用的方法有两种:</p><ul class=""><li id="6691" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated"><code class="fe ls lt lu lv b">registerEvents</code>注册给定列表中的所有事件，并返回一个当其中一个事件发生时发出的可观察值。</li><li id="12ab" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated"><code class="fe ls lt lu lv b">logEvent</code>使用用户分析服务记录给定的事件类型和属性。</li></ul><p id="f85c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们当中的明眼人大概都注意到了，我在我们的指令会被销毁的时候，使用了<code class="fe ls lt lu lv b"><a class="ae nq" href="https://github.com/ngneat/until-destroy" rel="noopener ugc nofollow" target="_blank">untilDestroyed</a></code> <strong class="kx ir"> </strong>运算符(by<a class="nr ns ep" href="https://medium.com/u/b889ae02aa26?source=post_page-----473224afda--------------------------------" rel="noopener" target="_blank"><strong class="kx ir">Netanel Basal</strong></a>)来退订注册的事件订阅，但是这样就足够好了吗？</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="e1de" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">问题是</h1><p id="d7a0" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">用一句话来说，<code class="fe ls lt lu lv b">OnChanges</code>是一个正在进行的生命周期挂钩，任何输入更改都会调用它。在我们的例子中，每次改变<code class="fe ls lt lu lv b">events</code>输入都会导致新的订阅。</p><p id="b1b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们通过下面的使用示例来浏览一下指令流，并看看当前<code class="fe ls lt lu lv b">OnChanges</code>实现中偷偷摸摸的问题的结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><ol class=""><li id="12da" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nt ni nj nk bi translated">我们在应用程序中的某个地方使用了该指令来记录我们想要记录的事件。</li><li id="991b" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">最初，<code class="fe ls lt lu lv b">isEditMode === false</code>，所以<code class="fe ls lt lu lv b">events</code>输入现在是<code class="fe ls lt lu lv b">['focus']</code>。</li><li id="b1f1" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated"><code class="fe ls lt lu lv b">OnChanges</code>调用，我们的指令注册到<code class="fe ls lt lu lv b">‘focus’</code>事件。</li><li id="d5dc" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">用户关注我们的<code class="fe ls lt lu lv b">text-editor</code>组件，并且<code class="fe ls lt lu lv b">‘focus’</code>事件被记录到分析提供商。</li><li id="0797" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">用户点击某个编辑按钮，然后<code class="fe ls lt lu lv b">(editModeChange)</code>发射，现在<code class="fe ls lt lu lv b">isEditMode === true</code>发射。</li><li id="807d" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated"><code class="fe ls lt lu lv b">events</code>输入变为<code class="fe ls lt lu lv b">[‘contextmenu’, ‘focus’]</code>，再次调用<code class="fe ls lt lu lv b">OnChanges</code>，指令重新注册到新事件列表。</li><li id="bbef" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nt ni nj nk bi translated">用户关注于<code class="fe ls lt lu lv b">text-editor</code>组件，并且<code class="fe ls lt lu lv b">‘focus’</code>事件被再次记录。</li></ol><p id="5390" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果我们记录已注册的事件订阅排放，您将看到<code class="fe ls lt lu lv b">‘focus’</code>事件被记录了三次，而我们预期它只被记录了两次。这是因为在注册到新的传入事件列表之前，我们没有取消订阅第一个注册的可观察事件。</p><p id="51bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么如何才能修复呢？让我们打开工具箱，卷起袖子，更新这个指令！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="473e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">解决方案1:取消订阅</h1><p id="9091" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">对，就这么简单！在订阅新的订阅之前，请先取消订阅以前的订阅。同样，当您在指令销毁之前取消订阅observables时，您需要在这种情况下做同样的事情，以便抛出以前的订阅。</p><p id="ba60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看它是如何在我们的指令中实现的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="ce1e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">解决方案2:主题+ takeUntil</h1><p id="7bd5" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">大多数时候，手动取消订阅可观测量是一个很好的解决方案，但是当一个指令/组件变得更加复杂，可观测量的数量增加时，拥有大量的订阅引用会很快弄乱我们的逻辑。在这种情况下，我们希望找到一种有效的方法来一次取消订阅我们所有的可观测量。</p><p id="b41f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过一个通知程序<code class="fe ls lt lu lv b">Subject</code>告诉我们<code class="fe ls lt lu lv b">OnChanges</code>生命周期钩子发生了，来实现这一点。然后，我们可以通过使用<code class="fe ls lt lu lv b">takeUntil</code>完成之前的可观测值来停止获取新的排放。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="c1df" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">解决方案3:rehomotive+take until</h1><p id="6855" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">这个主题解决方案促使我寻找一个更简单、更通用的替代方案，它将适用于Angular中的任何其他生命周期钩子。因此，我接受了挑战，实现了一个完全装饰性的解决方案，对有角度的生命周期挂钩做出反应。向<a class="ae nq" href="https://github.com/ngze/rehooktive" rel="noopener ugc nofollow" target="_blank">rehoktive</a>问好！</p><p id="c7b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是它在我们的指令中是如何容易地工作的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="621a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您不应该担心取消对<code class="fe ls lt lu lv b">OnDestroy</code>的订阅。即使你正在使用其他生命周期挂钩，rehoktive也会自动为你完成工作。</p><p id="fb64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完全反应式解决方案的另一个选项是使用<code class="fe ls lt lu lv b">switchMap</code>操作符并映射<code class="fe ls lt lu lv b">OnChanges</code>的任何发射，包括在指令的构造函数内将事件输入更改为新注册的事件可观察值。结果如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><div class="nu nv gp gr nw nx"><a href="https://github.com/ngze/rehooktive" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">@ ngze/re hoktive</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">Rehooktive是一个轻量级的库，它让你在角度生命周期钩子上拥有反应式编程的能力！</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a497" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">摘要</h1><p id="5955" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">处理订阅的正确方式因情况而异。一次性生命周期挂钩的行为将不同于正在进行的生命周期挂钩，因此我们需要意识到这一点并采取相应的行动。</p><p id="f004" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论您选择哪种解决方案，都要确保无论您在哪里订阅observables，都要正确地取消订阅。</p><p id="1fa4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>