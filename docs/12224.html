<html>
<head>
<title>Writing and Testing a Smart Contract With Hardhat and Ethers.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Hardhat和Ethers.js编写和测试智能合同</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-and-testing-a-smart-contract-with-hardhat-and-ethersjs-2b0dbd450997?source=collection_archive---------3-----------------------#2022-05-20">https://betterprogramming.pub/writing-and-testing-a-smart-contract-with-hardhat-and-ethersjs-2b0dbd450997?source=collection_archive---------3-----------------------#2022-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2a53" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何使用Hardhat环境和Ethers.js库编写和测试智能合约的基本概述</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9c89971b3d07524a1c5d8fba8d0efa97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JU2CFhz1cdfw3p7IDJdnLg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@dengxiangs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">钟登祥</a>在<a class="ae kv" href="https://unsplash.com/s/photos/ethereum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6395" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://hardhat.org/" rel="noopener ugc nofollow" target="_blank"> Hardhat </a>是一个以太坊开发环境，就像Truffle一样，我们将使用它来开发我们的契约并将其部署在我们的本地网络上，而<a class="ae kv" href="https://docs.ethers.io/v5/#:~:text=What%20is%20Ethers%3F,a%20more%20general%2Dpurpose%20library." rel="noopener ugc nofollow" target="_blank"> EthersJs </a>是一个用于与以太坊区块链交互的库，我们将在我们的测试套件中使用它来与部署的契约进行交互。</p><h1 id="0237" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">安装和设置</h1><p id="699e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Hardhat环境的完整安装指南可以在<a class="ae kv" href="https://hardhat.org/getting-started/" rel="noopener ugc nofollow" target="_blank">官方网站</a>上找到，但是让我们来回顾一下我们这个小项目的必要步骤。</p><p id="80e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们运行以下命令</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c51d" class="mu lt iq mq b gy mv mw l mx my">npm install --save-dev hardhat &amp;&amp; npx hardhat</span></pre><p id="c132" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将安装软件包并启动交互式界面来创建项目。我们将选择<code class="fe mz na nb mq b">&gt; Create an advanced sample project that uses TypeScript</code>并继续。</p><p id="2f53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Hardhat将生成几个文件和文件夹，但我们只对其中的几个感兴趣。</p><p id="48f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb mq b">contracts</code>文件夹将托管我们的智能契约，<code class="fe mz na nb mq b">test</code>文件夹托管我们的测试，<code class="fe mz na nb mq b">hardhat.config.ts</code>托管从hardhat生成的配置——为此，我们需要确保这里定义的solidity版本与我们契约的指定版本相匹配。</p><h1 id="e49f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">撰写智能合同</h1><p id="902d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">想象一下，你一直没能存下你的硬币，因为你忍不住要花钱，最终你打破了你的储蓄目标。好吧，如果你能把你的存款锁在一个金库里，只有在特定的日期过后，它才会把你的硬币还给你。这是我们将要写的智能合同背后的想法。</p><p id="8c75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在合同文件夹中创建一个名为<code class="fe mz na nb mq b">LockSave.sol</code>的文件。</p><p id="1ad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个简单的契约，我们需要三个基本函数:</p><ol class=""><li id="83ad" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">为最小取款日期保存ETH的功能</li><li id="0768" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">一个在指定日期过后撤销的函数</li><li id="7880" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">从所有者的地址中检索所有储蓄的功能</li></ol><p id="e08b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不会过多关注合同的细节，但它看起来是这样的。</p><p id="8c43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要定义我们储蓄的形式</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8bdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要声明几个变量，这些变量有助于存储和将节省映射到它们的创建时间戳，并将所有者映射到保存时间戳。这种映射有助于操作和访问我们的数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="00f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要几个自定义错误来处理不需要的行为，比如当储蓄的金额等于零时，或者当一个地址想要在日期过去之前撤销时。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="e98c" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">储蓄功能</h2><p id="e75c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">saving函数接收取款时间戳，向地址保存添加新的保存，并返回数据。我们使用<code class="fe mz na nb mq b">isValidSaving</code>修饰符来检查金额和取款时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="ae9d" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">撤回功能</h2><p id="3656" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们使用储蓄时间戳来查找储蓄，将其从储蓄中删除，然后最终将储蓄金额转移回所有者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4ad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在提取之前，我们首先检查地址是否有储蓄以及提取时间，并将这些修饰符传递给上面的<code class="fe mz na nb mq b">withdraw</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将添加一个函数来检索属于请求地址的所有储蓄。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="ccc4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试智能合约</h1><p id="1b8f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如上所述，我们将在<code class="fe mz na nb mq b">test</code>文件夹中创建一个名为<code class="fe mz na nb mq b">index.ts</code>的文件，然后从<code class="fe mz na nb mq b">chai</code>、<code class="fe mz na nb mq b">ethers</code>和<code class="fe mz na nb mq b">hardhat</code>导入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0d81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将在<code class="fe mz na nb mq b">beforeEach</code>中声明我们的测试套件并部署我们的契约。这将在我们每次运行一个新的测试用例时部署一个新的契约，这样我们总是有一个空白的契约来处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="ead2" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">保存和检索保存的内容</h2><p id="b367" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了测试保存功能，我们将在定义取款时间戳后进行保存，然后使用<code class="fe mz na nb mq b">getSavings</code>函数获取保存。之后，我们将使用返回的保存来断言值和时间戳。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0dda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe mz na nb mq b">ethers.getSigners</code>来获取签名者地址，并提取第一个地址<code class="fe mz na nb mq b">[sender]</code>，这是Hardhat使用的默认地址。</p><p id="d1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb mq b">ethers.utils.parseEther</code>是一个将值从ETH转换为WEI的实用函数，这是我们在调用payable方法<code class="fe mz na nb mq b">save</code>时要发送给合同的值。</p><p id="1897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自契约的响应由EthersJs以迭代器的形式返回，通过执行<code class="fe mz na nb mq b">savings.value().next().value</code>，我们能够以数组的形式访问值。</p><p id="8dd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，使用<code class="fe mz na nb mq b">chai</code>中的<code class="fe mz na nb mq b">expect</code>进行断言。</p><h2 id="7930" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">提取存款</h2><p id="7dc3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于下面的测试，我们首先进行保存，然后进行提取，最后调用<code class="fe mz na nb mq b">getSavings</code>方法来断言金额被成功提取。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="de72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们测试用例的全部内容，但是对于不愉快的路径可以做更多的断言，比如试图在日期过去之前撤回或者为已经过去的日期保存。</p><p id="60e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为参考，我在GithubGist上托管了两个文件，分别是<a class="ae kv" href="https://gist.github.com/gracelungu/d9c7e6ed4c1749dc975ee0451241675f" rel="noopener ugc nofollow" target="_blank">智能合约</a>和<a class="ae kv" href="https://gist.github.com/gracelungu/4a0e1a2fea90c3677fe41fcb974795c0" rel="noopener ugc nofollow" target="_blank">测试</a>。</p></div></div>    
</body>
</html>