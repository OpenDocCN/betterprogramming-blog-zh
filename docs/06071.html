<html>
<head>
<title>The Power of reduce()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减少的力量()</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-reduce-87bfdb7de04?source=collection_archive---------10-----------------------#2020-08-31">https://betterprogramming.pub/the-power-of-reduce-87bfdb7de04?source=collection_archive---------10-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5a6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重构JavaScript:收集管道(第2部分)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac0d2a9b9b43f0e188bc750ea726ac64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxK8R9YvYBC9UpniV1aaqQ.png"/></div></div></figure><p id="6e87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是“重构Javascript:收集管道”系列的一部分。<em class="lq"> </em>这里可以看介绍<a class="ae lr" href="https://medium.com/@Michael_Timbs/refactoring-javascript-collection-pipelines-3ebc2e63abee" rel="noopener">。</a></p><p id="7efe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上一篇文章中，我用一个IP验证的例子展示了简单的收集管道如何简化代码的可读性。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="edb3" class="lx ly it lt b gy lz ma l mb mc"><em class="lq">const </em>validateIP = (ip: <em class="lq">string</em>): <em class="lq">boolean </em>=&gt; {<br/>  <em class="lq">const </em>numbers = ip.split('.');<br/>  <em class="lq">return </em>numbers.length === 4<br/>    &amp;&amp; numbers<br/>      .filter((x) =&gt; <strong class="lt iu"><em class="lq">Number</em></strong>(x).toString() === x)<em class="lq"><br/>      </em>.map((x) =&gt; parseInt(x, 10))<em class="lq"><br/>      </em>.filter((x) =&gt; x &gt;= 0 &amp;&amp; x &lt;= 255)<em class="lq"><br/>      </em>.length === 4;<em class="lq"><br/></em>};</span></pre><p id="b40e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码很好，因为它将验证的每一步都分解成了一个步骤。每一步都通过管道将新的集合传递到管道的下一阶段。这使得推断数据流以及它在每一步是如何变化的变得非常容易。</p><p id="1766" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过，这种方法也有缺点。管道的每一步都需要迭代上一步通过的整个集合。</p><p id="0408" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的第一个过滤器需要过滤原始集合中的四个项目；得到的数组被传递给<code class="fe md me mf lt b">map()</code>，它也需要在传递给另一个<code class="fe md me mf lt b">filter()</code>之前对整个集合进行操作，而后者又对整个集合进行操作。我们在这里做了多达12个操作(每个贴图/过滤器最多4个)。如果我们能把所有这些结合成一个单一的步骤呢？</p><p id="f7bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">reduce函数的典型示例是获取一组数字并对它们求和。它看起来像这样:</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="16b6" class="lx ly it lt b gy lz ma l mb mc"><em class="lq">const </em>total = (arr) =&gt; arr.reduce((total, val) =&gt; total + val, 0);</span></pre><p id="c7d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个很好理解但是用处不大。</p><p id="4b8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe md me mf lt b">reduce()</code>比数字相加要强大得多。<code class="fe md me mf lt b">reduce()</code>对集合进行一次迭代，并允许您应用回调——同时提供对每次迭代累积结果的访问。然后，它返回一个值。仔细想想，这给了你很大的力量。比如可以用<code class="fe md me mf lt b">reduce()</code>代替<code class="fe md me mf lt b">map()</code>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9690" class="mn ly it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">用reduce()实现map()</h1><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="c33d" class="lx ly it lt b gy lz ma l mb mc">[1, 2, 3, 4].map((x) =&gt; x.toString());<br/>// result [ "1", "2", "3", "4" ]</span><span id="542b" class="lx ly it lt b gy ne ma l mb mc">[1, 2, 3, 4].reduce((acc, item) =&gt; [...acc, item.toString()], []);<br/>// result [ "1", "2", "3", "4" ]</span></pre><p id="cfa0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我们已经展示了我们可以使用<code class="fe md me mf lt b">reduce()</code>来复制<code class="fe md me mf lt b">map()</code>,只需转换每个项目，并使用ES6 spread语法将其合并到一个累加器数组中。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f778" class="mn ly it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">用reduce()实现filter()</h1><p id="a3d7" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">显然<code class="fe md me mf lt b">filter()</code>可以以类似的方式实现。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="f950" class="lx ly it lt b gy lz ma l mb mc">[1, 2, 3, 4].filter((x) =&gt; x % 2 === 0);<br/>// result [ 2, 4 ]</span><span id="1af9" class="lx ly it lt b gy ne ma l mb mc">[1, 2, 3, 4].reduce((acc, item) =&gt; item % 2 === 0<br/>  ? [...acc, item]<br/>  : acc<br/>,[]);<br/>// result [ 2, 4 ]</span></pre><p id="9d98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们简单地检查我们的谓词，如果我们得到一个真值结果，我们将这个项目分散到一个累加器数组中；否则，我们将累加器原封不动地传递给下一次迭代。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5b27" class="mn ly it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用reduce()组合map()和filter()</h1><p id="99e6" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">假设一个数组有一百万个条目，而不是四个——那么将连续的贴图/过滤器链接在一起可能会有点慢。令人欣慰的是，你可以使用一个简单的<code class="fe md me mf lt b">reduce()</code>将过滤器和贴图合并到一个步骤中。</p><p id="6017" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，这里我们对偶数使用一个过滤器，并将数字映射到一个字符串。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="9404" class="lx ly it lt b gy lz ma l mb mc"><em class="lq">const </em><strong class="lt iu"><em class="lq">arr </em></strong>= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br/><br/><strong class="lt iu"><em class="lq">arr</em></strong>.reduce((acc, item) =&gt; (<br/>  item % 2 === 0<br/>    ? [...acc, item.toString()]<br/>    : acc<br/>), []);<br/>['2', '4', '6', '8', '10'];</span></pre><p id="ab07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先应用过滤器，然后如果谓词匹配，我们在扩展到累加器数组时进行转换。如果没有，我们返回先前的累加器。</p><p id="35ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以让我们的<code class="fe md me mf lt b">reduce()</code>函数变得无限复杂，从而在一次迭代中优化我们的管道；然而，我认为，随着我们在我们的<code class="fe md me mf lt b">reduce()</code>函数中加入越来越多的逻辑，我们剩下的并不比使用一个简陋的<code class="fe md me mf lt b">for</code>循环更干净。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="3c14" class="mn ly it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">不错的把戏，但那又怎样？</h1><p id="e108" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">我的整个系列文章的目标是说服人们开始用<code class="fe md me mf lt b">map()</code>、<code class="fe md me mf lt b">filter()</code>和<code class="fe md me mf lt b">reduce()</code>来思考。这会让你90%或更多的代码更容易阅读。</p><p id="2066" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我的目的是向您展示多个映射和过滤步骤可以合并到一个reduce函数中，该函数允许您只对一个集合迭代一次，而不是多次。不过，这在实践中几乎从来都不是问题——也不总是更快！</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="a813" class="lx ly it lt b gy lz ma l mb mc"><em class="lq">const </em><strong class="lt iu"><em class="lq">smallArray </em></strong>= [...<strong class="lt iu"><em class="lq">Array</em></strong>(100)].map((_, i) =&gt; i);<br/>// [0,1,2,3,4,... 100]</span><span id="ca1b" class="lx ly it lt b gy ne ma l mb mc"><em class="lq">const </em><strong class="lt iu"><em class="lq">bigArray </em></strong>= [...<strong class="lt iu"><em class="lq">Array</em></strong>(1e4)].map((_, i) =&gt; i);<br/><em class="lq">// [0,1,2,3,4, .... 9999]</em></span><span id="be52" class="lx ly it lt b gy ne ma l mb mc"><em class="lq">const </em>time = (f) =&gt; {<br/>  <em class="lq">const </em>s = <em class="lq">new </em><strong class="lt iu"><em class="lq">Date</em></strong>();<br/>  f();<br/>  <em class="lq">console</em>.log(`${(<em class="lq">new </em><strong class="lt iu"><em class="lq">Date</em></strong>()) - s}ms`);<br/>};</span><span id="4d28" class="lx ly it lt b gy ne ma l mb mc"><br/>// For small arrays there is no difference</span><span id="a98f" class="lx ly it lt b gy ne ma l mb mc">time(() =&gt; <strong class="lt iu"><em class="lq">smallArray<br/>  </em></strong>.filter((x) =&gt; x % 2 === 0)<br/>  .map((x) =&gt; x.toString()));<br/>// 0ms</span><span id="2e43" class="lx ly it lt b gy ne ma l mb mc">time(() =&gt; <strong class="lt iu"><em class="lq">smallArray<br/>  </em></strong>.reduce((acc, item) =&gt; (<br/>  item % 2 === 0<br/>    ? [...acc, item.toString()]<br/>    : acc<br/>), []));<br/>// 0ms</span><span id="cb20" class="lx ly it lt b gy ne ma l mb mc">// For larger arrays</span><span id="6501" class="lx ly it lt b gy ne ma l mb mc">time(() =&gt; <strong class="lt iu"><em class="lq">bigArray<br/>  </em></strong>.filter((x) =&gt; x % 2 === 0)<br/>  .map((x) =&gt; x.toString()));<br/>// 8ms 🏎 still pretty fast!</span><span id="25fe" class="lx ly it lt b gy ne ma l mb mc">time(() =&gt; <strong class="lt iu"><em class="lq">bigArray<br/>  </em></strong>.reduce((acc, item) =&gt; (<br/>  item % 2 === 0<br/>    ? [...acc, item.toString()]<br/>    : acc<br/>), []));<br/>//32ms 🤯 wait... what!</span></pre><p id="500a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们有10，000个条目的<code class="fe md me mf lt b">bigArray</code>示例中，将<code class="fe md me mf lt b">map()</code>和<code class="fe md me mf lt b">filter()</code>组合成一个<code class="fe md me mf lt b">reduce()</code>比链接<code class="fe md me mf lt b">filter()</code>和<code class="fe md me mf lt b">map()</code>慢四倍！使用<code class="fe md me mf lt b">reduce()</code>对性能的影响实际上来自于通过spread操作符合并数组。</p><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="f4ba" class="lx ly it lt b gy lz ma l mb mc">[...acc, item.toString()]</span></pre><p id="226f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的性能损失比我们连续链接<code class="fe md me mf lt b">filter()</code>和<code class="fe md me mf lt b">map()</code>得到的要大得多。</p><p id="7a17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们没有一条简单的➡管道，而是有一条通往➡、➡、➡、➡、➡和T22的管道，会怎么样？</p><p id="64bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">难道<code class="fe md me mf lt b">reduce()</code>仍然比链接所有这些步骤慢吗？没有侧写谁知道呢——这在大多数情况下也无关紧要。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="46c4" class="mn ly it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">那么使用Reduce方法而不是Map/Filter有什么意义呢？</h1><p id="7ad4" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">首先，我想向您展示用<code class="fe md me mf lt b">reduce()</code>替换<code class="fe md me mf lt b">map()</code>和<code class="fe md me mf lt b">filter()</code>的<em class="lq">是可能的，但也强调它并不总是有用的(尽管它经常有用)，并且最好进行剖析以进行检查。</em></p><p id="066b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其次，现在熟悉了<code class="fe md me mf lt b">reduce()</code>之后，我们就可以引入可组合的高阶减速器<em class="lq">(传感器)的概念。</em>转换器是将一个缩减器作为输入并返回另一个缩减器的函数。传感器<em class="lq"> </em>让我们建立更高效的数据处理管道。</p><p id="6bdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想要一个使用reduce()的真实例子，<a class="ae lr" href="https://medium.com/@Michael_Timbs/solving-canvas-technical-challenge-with-a-single-reduce-function-731245b80101" rel="noopener">在这里阅读我的后续文章</a>，在那里我使用一个reduce函数解决了Canva的技术难题！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="858a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解更多关于重构你的JS代码以利用集合管道的知识，你可以在这里预订我的书，只需10美元<a class="ae lr" href="https://gum.co/nolxO" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>