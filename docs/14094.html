<html>
<head>
<title>Tauri vs. Electron for Tray Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tauri与电子托盘应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tauri-vs-electron-for-tray-apps-ed15974f35ce?source=collection_archive---------1-----------------------#2022-11-05">https://betterprogramming.pub/tauri-vs-electron-for-tray-apps-ed15974f35ce?source=collection_archive---------1-----------------------#2022-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4a97" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Tauri、Rust和JavaScript构建一个桌面托盘初学者应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/18f3745b51c0ac04a305beaab93bc033.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*p-h3dPGW_kgLIfO3s-7Wlw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="5a5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://tauri.app/" rel="noopener ugc nofollow" target="_blank"> Tauri </a>大体类似于电子。原理是一样的:通过使用JavaScript完成大部分应用程序/ UI工作来快速构建应用程序。</p><p id="c411" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，Tauri在实现上采取了完全不同的方法，因此，在几乎所有可能的标准上都取得了更好的结果。</p><h1 id="91c7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">尺寸比较</h1><p id="28dc" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们已经知道，基于电子的应用程序有两个主要问题:</p><ul class=""><li id="a115" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">捆绑包大小(下载大小)</li><li id="db86" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">RAM的使用和随时间的增长</li></ul><p id="9f59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了电子版，你开始时只有85MB的包大小，几乎没有任何功能，大多数应用程序可以轻松下载到150MB。</p><p id="a58c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在内存使用方面，一个电子应用程序一开始几乎什么都不用，就占用了你500MB的内存。这也是我不使用任何电子app(所谓的“原生app”)用于Slack等各种流行的Web apps的原因。我只是使用Chrome，希望它能以更好的方式优化选项卡间的RAM使用。</p><p id="f8ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对Tauri来说:8MB的包大小支持大量的功能，峰值内存使用量为150-200 MB，这主要是因为浏览器就是浏览器。浏览器往往会耗尽内存(它使用每个操作系统的原生Web视图)。</p><p id="4098" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就特性而言，好吧，Electron花了几年才达到的(我在这里是作为一个电子开发者说的)——你现在可以在Tauri中获得它，它的第一个稳定版本。从高质量的捆绑器和开发工具，到内置的更新程序，到托盘图标支持，等等。</p><h1 id="1622" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">设计和架构比较</h1><p id="9466" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">你从Tauri apps得到的另一个好处直接来自它的工程思维，我猜Rust帮助推动了这一点。</p><h2 id="a190" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">作为一等公民的安全</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/e34efeccad9c75ed2fcbd35ef2e21daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LpACUmV2hh5PSZPC7RPJJA.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae ln" href="https://tauri.app/v1/references/architecture/security/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="a1fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一等公民的安全感。没有多少应用平台(实际上:据我所知没有)一开始就详细描述它们内置的安全特性，以及高级特性的<a class="ae ln" href="https://tauri.app/v1/references/architecture/security/" rel="noopener ugc nofollow" target="_blank">实现供您使用，重点是JS端、IPC等。这是Rust作为一种语言所提供的安全性和稳定性的补充。更令人印象深刻的是</a><a class="ae ln" href="https://tauri.app/v1/references/security/" rel="noopener ugc nofollow" target="_blank">包含了威胁建模</a>以及如何进行防御性操作背后的思想:安全源于设计。</p><h2 id="b85e" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">作为一等公民的表现</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nq"><img src="../Images/7f9ed6aa9eeb0268c0a630516114085e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6g8lP7HqcQb2X9XGW5-7g.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae ln" href="https://tauri.app/v1/references/benchmarks/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="3571" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一等公民的基准。同样，没有多少平台以这个主题开始，提供高度详细、<a class="ae ln" href="https://tauri.app/v1/references/benchmarks/" rel="noopener ugc nofollow" target="_blank">自动化和透明的基准测试</a>。当这发生在一个库、工具或平台中时，你知道性能是一个主线KPI。当您构建应用程序时，您希望确保您所使用的平台保持出色的性能，以便您基于该平台构建的应用程序保持出色。如果平台有性能问题，这自然意味着你的应用有性能问题，而且——作为开发者，你可能没有办法解决它。</p><h2 id="3647" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">完全的后端和前端分离</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nr"><img src="../Images/62935cd55c83ff7fc4dea7517c32f248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t55uYzr8mGcGRqEkoBPr-g.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae ln" href="https://tauri.app/v1/references/architecture/process-model/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="0894" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然与electronic相比，这最初可能被认为是一个缺点，但后端流程构建在Rust中，前端构建在JavaScript中，这一事实实际上非常有益:</p><ul class=""><li id="f7dd" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">它迫使我们真正思考鼓励安全和稳定的IPC</li><li id="3cfe" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">就Rust而言，它提供了您在后端过程中所需要的一切:性能、安全性、稳定性，以及当您需要与底层系统紧密操作时的系统方法。使用基于Node.js的后端流程无法做到这一点(在这种情况下，您必须使用原生API)</li></ul><p id="a9f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Tauri是如何用Rust宏和开发者经验抽象IPC的，即使你不懂Rust，你也不会有问题。</p><h1 id="53c7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">保持简单的理由</h1><p id="1ee1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">构建电子应用程序绝不简单。和许多JavaScript应用一样，这实际上是选择悖论的顶峰，但在这里——甚至更是如此。虽然您在电子应用的前端有标准的JavaScript疲劳，但在后端“主”进程中也有同样的问题:您必须选择您的JavaScript工具、库和原则，但仅限于一个纯Node.js进程(因此有些库无法工作，有些库只能<em class="ns">工作)。</em></p><p id="6431" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Tauri，后端是用Rust编写的，Rust生态系统很简单，通常有一个很好的库来做一件事。所以你避开了选择的悖论，有了更多的时间去构建。</p><p id="ef97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于前端部分，你会得到和电子应用程序一样的体验。你需要选择你的捆绑器、应用框架、样式框架、状态管理框架、linter等等——不管你用JavaScript还是TypeScript。</p><p id="b64f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从这个意义上说，在Tauri上构建更简单。</p><h1 id="32af" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">如何用Tauri搭建托盘App？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/c8780f56132608f18ecb60c112809cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*tms0qmW_Ur-ba5OFm2qFJQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="86e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个练习中，我们来看看“托盘应用程序”是什么意思。突然，它实际上是许多事情。这是一个:</p><ul class=""><li id="22ea" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">桌面应用程序</li><li id="365c" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">操作系统部件或附件</li><li id="80c3" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">一个长期的后台进程</li><li id="6ded" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">开窗练习(例如，在正确的位置弹出)</li></ul><p id="d451" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，对于一个新的应用平台来说，这可能是一个很难的练习，这是理解Tauri如何处理它的完美方式。我们已经知道许多托盘应用程序是在今天的电子版中实现的，那么Tauri进展如何呢？</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="31d5" class="lo lp iq bd lq lr ob lt lu lv oc lx ly jw od jx ma jz oe ka mc kc of kd me mf bi translated">示例案例:Docker桌面应用程序</h1><p id="2803" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们来分解一下Docker桌面app。我们将尝试在Tauri重建它的大部分部件，看看什么有效。</p><p id="2cf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Docker桌面要求或规范遵循以下原则:</p><ul class=""><li id="0453" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">带有更新图标的托盘(当Docker加载时)</li><li id="fefd" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">更新托盘中的动态菜单项，例如在打开托盘菜单时显示状态“Docker正在运行”和当前登录的用户名</li><li id="0cc9" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">打开的桌面窗口(仪表板)，具有特定的行为:</li><li id="a32e" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">当显示窗口时(托盘→打开仪表板)，窗口应该弹出到您当前的工作区和监视器</li><li id="a606" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">当点击窗口，或者要做别的事情时，窗口应该隐藏起来</li><li id="a67f" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">这是一个品味问题，我们可以让窗口停留，用户应该通过点击关闭来显式隐藏它(事实上，关闭应该退出，但我们正在防止这一点，而是隐藏)</li><li id="dbe5" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">应用程序不应该出现在你的任务栏/跳板上。它应该只存在于您的托盘中。</li><li id="6c53" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">这是一个偏好的味道，我们可以切换到开/关。</li><li id="33b7" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">有特定的大小，不能调整大小</li><li id="1c92" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">可以四处移动，有一个窗口外壳(这可以被删除，但让我们有外壳)</li></ul><p id="022d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在基础设施和机制方面，我们需要:</p><ul class=""><li id="be0a" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">JavaScript应用程序和Rust main进程之间的某种状态轮询。我们可以去:</li><li id="aaea" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">JavaScript轮询信任setInterval并调用Tauri命令，或者</li><li id="7859" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">Rust端通过在主窗口上执行<code class="fe og oh oi oj b">emit</code>来推送周期性事件，以便JavaScript端监听</li><li id="1524" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">无论哪种方式，我们双方都有一个持续的沟通渠道，这很好。</li><li id="c4a2" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">我们正在把一个桌面应用变成一个长期运行的强大的过程。</li><li id="29dd" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">我们还需要从JavaScript到Rust的特别调用代码，Tauri的<code class="fe og oh oi oj b">command</code>抽象神奇地解决了这个问题</li><li id="b38c" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">最后，我们需要一个成熟的桌面应用框架和基础设施。在这里，我们将使用React、Chakra-UI、React Router和Zustand或Redux来实现状态，特别是状态持久性(例如在存储用户设置时)。</li></ul><p id="cf38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在这里尝试已完成的初学者项目:</p><p id="d549" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/jondot/tauri-tray-app" rel="noopener ugc nofollow" target="_blank">https://github.com/jondot/tauri-tray-app</a></p><h1 id="4577" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Tauri拥有唯一稳定的系统托盘实现</h1><p id="bd8c" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这可能令人惊讶，但与Go或Node.js相比，Rust没有很好的系统托盘库，而Tauri实际上是目前最好的实现。我们所拥有的如下:</p><ul class=""><li id="8a77" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated"><a class="ae ln" href="https://github.com/Ciantic/trayicon-rs" rel="noopener ugc nofollow" target="_blank">https://github.com/Ciantic/trayicon-rs</a>—仅在windows上运行，设计用于与<code class="fe og oh oi oj b">winit</code>一起工作</li><li id="f960" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated"><a class="ae ln" href="https://github.com/qdot/systray-rs" rel="noopener ugc nofollow" target="_blank">https://github.com/qdot/systray-rs</a>——不再维护了，作者指出这不是一件容易的事情</li><li id="0d19" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">Tauri制作了<a class="ae ln" href="https://github.com/tauri-apps/tao" rel="noopener ugc nofollow" target="_blank">https://github.com/tauri-apps/tao</a>，它实现了系统托盘功能，实际上是<a class="ae ln" href="https://crates.io/crates/winit" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/winit</a>的一个分支</li></ul><h1 id="e3d0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">演示应用程序:概述</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/bbdc3f1b27ba074d4be3b25bc0ff7ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*nekIngN_n_gst5joGCRakw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae ln" href="https://tauri.app/v1/references/architecture/inter-process-communication/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="5f47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">设置并携带入门应用程序(您将需要<code class="fe og oh oi oj b">pnpm</code>并且您可能希望<a class="ae ln" href="https://tauri.app/v1/guides/getting-started/prerequisites" rel="noopener ugc nofollow" target="_blank">运行入门指南</a>以获得基本的先决条件)</p><pre class="kg kh ki kj gt ol oj om on aw oo bi"><span id="acef" class="mz lp iq oj b gy op oq l or os">$ git clone https://github.com/jondot/tauri-tray-app<br/>$ cd tauri-tray-app<br/>$ pnpm install<br/>$ cargo tauri dev</span></pre><h1 id="61e6" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">前端</h1><p id="cf47" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">每个Tauri应用程序都分为前端和主进程(Tauri核心)。在starter项目中，前端有以下主要组件:</p><ul class=""><li id="fc74" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated"><a class="ae ln" href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank">建筑用Vite </a></li><li id="4e35" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">作为UI框架做出反应</li><li id="9add" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated"><a class="ae ln" href="https://chakra-ui.com/" rel="noopener ugc nofollow" target="_blank"> Chakra UI </a>作为组件框架并用于造型</li><li id="0c53" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated"><a class="ae ln" href="https://github.com/remix-run/react-router" rel="noopener ugc nofollow" target="_blank"> React Router </a>作为通用路由框架，用于应用程序加载和卸载“屏幕”时</li><li id="d8e5" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated"><a class="ae ln" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux Toolkit </a>或<a class="ae ln" href="https://github.com/pmndrs/zustand" rel="noopener ugc nofollow" target="_blank"> Zustand </a>用于状态管理和数据持久化(两者都是有线的，选择您喜欢的)</li></ul><h1 id="6895" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">主流程</h1><p id="6925" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这里是我们的愿望列表中的一些机制，我们希望在Rust和Tauri的API中实现的核心/主要流程部分中实现。</p><ul class=""><li id="0c64" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">避免从窗口关闭，因为它是一个托盘应用程序</li><li id="f87a" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">从任务栏隐藏</li><li id="cc5d" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">确保窗口出现在用户面前</li><li id="c74f" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">状态—为了熟悉起见，我们可以使用这两者中的任何一个(我们将在JavaScript端使用状态)</li><li id="fbda" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">JavaScript端(照常管理状态)。</li><li id="de16" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">rust side—<a class="ae ln" href="https://docs.rs/tauri/1.1.1/tauri/trait.Manager.html#method.state" rel="noopener ugc nofollow" target="_blank">Tauri中的状态管理器</a>可以用于通用的状态存储。</li><li id="bbc7" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">后台进程运行和触发</li><li id="b763" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">JavaScript方面——我们将回答这个问题——天真的setInterval循环会永远存在并ping Rust core吗？(是)</li><li id="82da" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">此外，启动这样一个永久循环的最佳方式是什么？</li><li id="e2de" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">从JavaScript端控制原生特性，比如设置原生菜单项</li></ul><h1 id="2e8a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">从JavaScript动态设置菜单项</h1><p id="edac" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这很容易做到，以下是它的配方:</p><p id="0acb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建一个项目并给它一个唯一的ID:</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="e1aa" class="ow lp iq oj b be ox oy l oz os">.add_item(CustomMenuItem::new("dynamic-item".to_string(), "Change me"))</span></pre><p id="680a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建一个命令，并在函数签名中请求应用程序句柄:</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="ff2b" class="ow lp iq oj b be ox oy l oz os">#[tauri::command]<br/>fn set_menu_item(app_handle: tauri::AppHandle, title: &amp;str) {<br/>    let item_handle = app_handle.tray_handle().get_item("dynamic-item");<br/>    item_handle.set_title(title).unwrap();<br/>}</span></pre><p id="45a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用下面这段代码注册它:</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="1e8e" class="ow lp iq oj b be ox oy l oz os">.invoke_handler(tauri::generate_handler![greet, set_menu_item])</span></pre><p id="51a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并使用invoke从JS端调用它:</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="ab4c" class="ow lp iq oj b be ox oy l oz os">const setMenuItem = () =&gt; {<br/>  invoke('set_menu_item', { title: `count is ${count}` })<br/>}<br/>//...<br/>&lt;button onClick={setMenuItem}&gt;Set menu item&lt;/button&gt;</span></pre><h1 id="dfb0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">长期运行的流程</h1><p id="880b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们有两种方法可以做到这一点，在下面的序列图中，两种方法都被绘制出来:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pa"><img src="../Images/2c03933d7c2fe3feb9c9cceae8b09cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnuXr9jCYCb2KsLg23pggw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><h2 id="3d92" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">JavaScript端的长期运行流程</h2><p id="ae4d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们想运行一个普通的JavaScript <code class="fe og oh oi oj b">setInterval</code>，并希望它保持活力，能够通过IPC(一个Tauri <code class="fe og oh oi oj b">command</code>)驱动Rust进程。</p><p id="ca11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，它有效:</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="b83a" class="ow lp iq oj b be ox oy l oz os">// Note: setInterval is firing off a promise and does not wait for it to resolve.<br/>// depending on what you want to get done, it may be smarter to use a different<br/>// scheduling technique for an async call that may take longer than the interval<br/>// from time to time.<br/>useEffect(() =&gt; {<br/>  const interval = setInterval(() =&gt; {<br/>    invoke('interval_action', { msg: `count is ${count}` }).then((s: any) =&gt; {<br/>      setMsg(s)<br/>    })<br/>  }, 5000)<br/>  return () =&gt; clearInterval(interval)<br/>}, [count])</span></pre><p id="59fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，要小心一些陷阱:</p><ul class=""><li id="2112" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">当JavaScript部分感觉到在后台时，注意计时器变慢<a class="ae ln" href="https://stackoverflow.com/questions/23506103/setinterval-slows-down-with-tab-window-inactive" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/23506103/setinterval-slows-with-tab-window-inactive</a></li><li id="34bc" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">像往常一样，区间中的异步内容可能会漂移。因为如果异步操作由于某种原因被延迟，我们真的没有办法保持时间间隔</li></ul><h2 id="4a72" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">生锈一侧的长时间运行流程</h2><p id="7bb4" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们可以在Rust端有一个长时间运行的进程，启动一个线程，让它在迭代之间有一个短暂的睡眠，做一个永远的循环。</p><p id="389c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有几个问题:</p><ul class=""><li id="5157" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">如何以及何时开始？</li><li id="e230" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">什么是并发模型？既然一个Rust线程想要通过IPC ping JavaScript端，那么这里一定有什么原因</li></ul><p id="eaba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了开始这样一个过程，我们可以有一个<code class="fe og oh oi oj b">command</code>,并在JavaScript端准备好的时候调用它。这里没有对错，是你需要什么的问题。</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="8ed6" class="ow lp iq oj b be ox oy l oz os">#[tauri::command]<br/>fn init_process(window: tauri::Window) {<br/>    std::thread::spawn(move || loop {<br/>        window<br/>            .emit(<br/>                "beep",<br/>                format!("beep: {}", chrono::Local::now().to_rfc3339()),<br/>            )<br/>            .unwrap();<br/>        thread::sleep(Duration::seconds(5).to_std().unwrap())<br/>    });<br/>}</span></pre><p id="3c71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者，在Tauri设置阶段开始一个永久循环，我们仍然可以访问应用程序。对于发出事件，我们必须通过<code class="fe og oh oi oj b">Window</code>来完成，因为<code class="fe og oh oi oj b">App</code>不是线程安全的。</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="85ff" class="ow lp iq oj b be ox oy l oz os">.setup(|app| {<br/>        let window = app.get_window("main").unwrap();<br/>    std::thread::spawn(move || loop {<br/>        window<br/>            .emit(<br/>                "beep",<br/>                format!("beep: {}", chrono::Local::now().to_rfc3339()),<br/>            )<br/>            .unwrap();<br/>        println!("beep");<br/>        thread::sleep(Duration::seconds(5).to_std().unwrap())<br/>    });<br/>    Ok(())<br/>})</span></pre><h1 id="765a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">运行异步命令</h1><p id="c540" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们尝试启动一个网络请求，由Rust端执行。这里，我们使用request，它使用async，而<code class="fe og oh oi oj b">tokio</code>作为运行时。</p><p id="95e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们知道这需要在我们生产的任何可执行文件中有一个初始化的<code class="fe og oh oi oj b">tokio</code>运行时。我们将会发现，Tauri使用了<code class="fe og oh oi oj b">tokio</code>，所以一切都是开箱即用的。就像平常一样让函数异步，但是记住:你必须返回一个可序列化的错误。</p><p id="a45f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了有趣起见，我们还返回了一个<code class="fe og oh oi oj b">Vec</code>(可序列化的)或<code class="fe og oh oi oj b">Content</code>(可序列化的)。</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="7bc4" class="ow lp iq oj b be ox oy l oz os">#[tauri::command]<br/>async fn api_request(msg: &amp;str) -&gt; Result&lt;Vec&lt;Content&gt;, String&gt; {<br/>    let res = reqwest::get("https://example.com")<br/>        .await<br/>        .map_err(|e| e.to_string())?;<br/>    let out = res.text().await.map_err(|e| e.to_string())?;<br/>    Ok(vec![Content { body: out }])<br/>}</span></pre><p id="f730" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成之后，我们将高兴地在JS端接收到作为JavaScript数据对象的序列化内容。</p><h1 id="342e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">航行</h1><p id="23c4" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">当在具有长时间运行间隔的窗口之外导航时，它被卸载并清除。React路由器开箱即用。</p><ul class=""><li id="fd9f" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">记住:我们并不是真的在一个网站中导航。因此，使用像React路由器这样的路由器成为一种特殊的需求。不使用路由器，你可以使用某种标签控件，包含你需要的应用程序的所有屏幕。</li></ul><p id="aeba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总而言之，对于长时间运行的，processes最好把它们放在react-router根中，对于改变的UI部分，把它们放在根中的一个<code class="fe og oh oi oj b">&lt;Outlet/&gt;</code>中。</p><h1 id="cd9a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">防止模糊时退出和隐藏</h1><p id="e956" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Rust和Tauri的API中模式匹配的混合简直太棒了:</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="fe09" class="ow lp iq oj b be ox oy l oz os">.on_window_event(|event| match event.event() {<br/>            tauri::WindowEvent::CloseRequested { api, .. } =&gt; {<br/>                // don't kill the app when the user clicks close. this is important<br/>                event.window().hide().unwrap();<br/>                api.prevent_close();<br/>            }<br/>            tauri::WindowEvent::Focused(false) =&gt; {<br/>                // hide the window automaticall when the user<br/>                // clicks out. this is for a matter of taste.<br/>                event.window().hide().unwrap();<br/>            }<br/>            _ =&gt; {}<br/>        })</span></pre><h1 id="7d1b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">更新本地菜单</h1><p id="14be" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">总的来说，你对事物固有的一面有很高的控制力。您可以对现有菜单做任何您想做的事情。然而，添加或删除项目变得复杂，因为无法访问菜单的当前“状态”。</p><p id="d759" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要添加项目，您需要重新构建包含新项目的完整菜单，并通过本机API重新设置它:</p><pre class="kg kh ki kj gt ol oj ot bn ou ov bi"><span id="6dd9" class="ow lp iq oj b be ox oy l oz os">// there's no way to grab the current menu, and add to it, creating<br/>// an evergrowing menu. so, we rebuild the initial menu and add an item.<br/>// this means we'll only add one item, but to add an arbitrary number,<br/>// make this command accept an array of items.<br/>// also, you probably would want to inject the new items in a specific place,<br/>// so you'd have to split the initial menu to [start] [your content] [end],<br/>// where 'end' contains things like "show" and "quit".<br/>#[tauri::command]<br/>fn add_menu_item(app_handle: tauri::AppHandle, id: &amp;str, title: &amp;str) {<br/>    let mut menu = build_menu();<br/>    let item = CustomMenuItem::new(id.to_string(), title);<br/>    menu = menu.add_item(item);<br/>    app_handle.tray_handle().set_menu(menu).unwrap();<br/>}</span></pre></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="8c1b" class="lo lp iq bd lq lr ob lt lu lv oc lx ly jw od jx ma jz oe ka mc kc of kd me mf bi translated">结论</h1><p id="5e5c" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Tauri还有很多东西。我们刚刚触及了几个案例，Tauri 1.1处理得非常好——平台是成熟的；比电子在进化过程中的相似阶段更成熟。</p><p id="28aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然我还没有把它推送到苹果官方商店，但你现在可以用Tauri构建完全捆绑和随时发布的应用程序，并以你喜欢的方式发布它们。</p><p id="be58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要构建你的下一个托盘应用，你绝对可以从<a class="ae ln" href="https://github.com/jondot/tauri-tray-app" rel="noopener ugc nofollow" target="_blank">https://github.com/jondot/tauri-tray-app</a>开始。如果你发现你可以改进它，请随时提交拉动请求！</p></div></div>    
</body>
</html>