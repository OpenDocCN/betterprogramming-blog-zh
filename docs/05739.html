<html>
<head>
<title>Everything You Need to Know About iOS 14 Widgets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于iOS 14 Widgets你需要知道的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-you-need-to-know-about-ios-14-widgets-10856eb76d2a?source=collection_archive---------1-----------------------#2020-08-03">https://betterprogramming.pub/everything-you-need-to-know-about-ios-14-widgets-10856eb76d2a?source=collection_archive---------1-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9ced" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">静态与动态部件、智能部件、意向捐赠等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c0d057db3c6afc3ce046528331e17e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAjZx-ljghstVfmr_PQyxA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.macrumors.com/guide/home-screen/" rel="noopener ugc nofollow" target="_blank"> MacRumors </a>。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3efd" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="c775" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在用户年复一年地要求它，多次越狱提供这一功能，以及Android从一开始就支持它们之后，苹果终于跳上了widget列车。在WWDC20上宣布之后，用户松了一口气，开发人员很高兴下载Xcode 12测试版并开始编码。</p><p id="ef26" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">本教程将涵盖:</p><ul class=""><li id="d4bb" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">简单介绍一下Today扩展及其在iOS 14中的作用。</li><li id="bd56" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">静态小部件:快照、时间轴、占位符等等。</li><li id="aaa2" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">微件捆绑包或如何在应用中支持多个微件。</li><li id="b144" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">深层链接:从你的小工具打开一个特定的应用程序屏幕。</li><li id="c70d" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">动态部件:让你的用户通过意图定制你的部件。</li><li id="fa36" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">智能部件:捐赠和相关性。让您的widget符合智能堆栈的条件。</li></ul><p id="1348" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于本文，我将使用TripsCalendar，这是我开发的一个用于测试小部件的示例应用程序。您可以在我的存储库中找到代码:</p><div class="nn no gp gr np nq"><a href="https://github.com/fermoya/TripsCalendar" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">费尔莫亚/特里斯卡伦达</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><p id="c449" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><strong class="ma iu">注:</strong>本教程是用Xcode 12 beta 3编写的。官方Xcode 12中的实现保持不变，只需要做一些改动。请参阅本文末尾的“更新”部分。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="651d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">今日扩展及其在iOS 14中的作用</h1><p id="cf12" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在widgets之前，苹果提供了开发者所谓的“今日扩展”或“今日widgets”基本上，很少有人使用它们，甚至不知道它们的存在。他们就是这么受欢迎的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9f0dbd56b9ff75fda239b76d28f4b81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*3GDh5-VaepQmI_oP9NhxvA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旧的部件或今天的扩展</p></figure><p id="63ff" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">他们会从iOS 14中消失吗？根据Xcode 12b3，如果您已经用旧版本的Xcode添加了Today扩展，那么它可以与widgets共存。这使得停留在iOS 13或更低版本的用户仍然可以使用你的“旧”widget。但是，请注意Xcode 12b3不会让您从头开始创建新的Today widget。老实说，你为什么要这么做？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/7394e813aa5c242485635f165e663fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJqjIYsPBE9t3VcKX5W_Hw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Xcode 12b3中可用的应用程序扩展</p></figure><p id="7a21" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">今日扩展将显示在所谓的今日视图中的小部件下。很明显，苹果偏爱widgets，希望你放弃你的Today扩展。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6b1e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">静态小部件</h1><p id="9386" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">让我们创建一个新的小部件。前往Xcode，“新目标”，然后“Widget扩展”我们将创建一个静态小部件，所以不要选中“包含配置意图”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/de0839434de55e81bf2095086f7803ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Es94k8H4JPb7xq6svPOpQ.png"/></div></div></figure><p id="cdd1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这将创建一堆样板文件。让我们来看看:</p><ul class=""><li id="4801" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">小部件——您将看到它标有新的<code class="fe oi oj ok ol b">@main</code>包装器，表明这是扩展的起点。在这里，您可以定制小部件的显示名称和描述，并使用<code class="fe oi oj ok ol b">supportedFamilies</code>修饰符指定您支持的大小。</li><li id="523a" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">条目视图—小部件的UI内容。这是纯粹的SwiftUI，我们不会覆盖它，但<a class="ae ky" href="https://medium.com/better-programming/how-to-create-fun-animations-in-swiftui-1c08adcb93ce" rel="noopener">有</a>好的教程<a class="ae ky" href="https://medium.com/better-programming/swipe-the-page-with-swiftuipager-981e379e3bbd" rel="noopener">在那里</a>。</li><li id="ea31" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">入口—入口视图的模型。必须符合<code class="fe oi oj ok ol b">TimelineEntry</code>。在这里包装成功显示小部件所需的所有数据。例如，TripsCalendar将包装行程。</li><li id="24de" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">提供者—将为系统提供小部件时间线的实体，即在特定时间显示的一组条目。请注意，不要让系统每分钟都显示不同的条目。这很可能行不通。</li></ul><p id="6479" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">请注意，您的小部件默认使用<code class="fe oi oj ok ol b">StaticConfiguration</code>。这很好。这只是意味着它不可由用户配置或定制。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/bb97beab11b6026c81e07bb009d44a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDG23kkuD3N67-QfjfVX2Q.png"/></div></div></figure><h2 id="36a3" class="on lh it bd li oo op dn lm oq or dp lq mh os ot ls ml ou ov lu mp ow ox lw oy bi translated">支持家庭</h2><p id="9eb0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">小部件支持三种不同的大小:</p><ul class=""><li id="f64a" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">小(主屏幕中四个应用程序图标的空间)</li><li id="1b1b" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">中等(主屏幕中八个应用程序图标的空间，水平延伸)</li><li id="8494" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">大(主屏幕中16个应用程序图标的空间或半个屏幕)</li></ul><p id="2177" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于我们的第一个小部件<code class="fe oi oj ok ol b"><a class="ae ky" href="https://github.com/fermoya/TripsCalendar/tree/master/TripsCalendarWidget/Calendar" rel="noopener ugc nofollow" target="_blank">CalendarWidget</a></code>，我想列出我的下一次旅行，我需要空间，所以我选择<code class="fe oi oj ok ol b">systemLarge</code>作为我支持的家庭:</p><pre class="kj kk kl km gt oz ol pa pb aw pc bi"><span id="3c19" class="on lh it ol b gy pd pe l pf pg">StaticConfiguration {<br/>    ...<br/>}<br/>.supportedFamilies([.systemLarge])</span></pre><h2 id="ef94" class="on lh it bd li oo op dn lm oq or dp lq mh os ot ls ml ou ov lu mp ow ox lw oy bi translated">快照</h2><p id="7ab0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这是在尝试将您的小部件添加到设备的主屏幕时显示的一个条目。在这里使用你的默认配置，甚至一些虚拟数据，这样用户就可以看到你的小部件看起来有多漂亮。</p><pre class="kj kk kl km gt oz ol pa pb aw pc bi"><span id="d7a4" class="on lh it ol b gy pd pe l pf pg">let entry = CalendarEntry(date: Date(), trips: nextTrips)</span></pre><p id="ba6f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这是我的快照的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/b13c3dca4e8e044db5365c7a7228e185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*7WW0NLN1gbVNPt7ffVxyWQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加小部件模式的快照</p></figure><h2 id="cecc" class="on lh it bd li oo op dn lm oq or dp lq mh os ot ls ml ou ov lu mp ow ox lw oy bi translated">时间表</h2><p id="3758" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">与今天的扩展类似，小部件受到系统的高度限制，并且资源非常少。他们的工作方式是通过时间线。这意味着我们将向系统传递将在特定时间填充小部件UI的条目/模型。这在提供程序中完成。请注意时间轴通过完成块返回的方式。这允许我们执行异步任务(例如，API调用或从您的应用程序沙箱加载文件)。</p><p id="0679" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意:不要试图从你的小部件的UI(某个<code class="fe oi oj ok ol b">View</code>主体)加载远程图像。没用的。我发现<a class="ae ky" href="https://www.vadimbulavin.com/asynchronous-swiftui-image-loading-from-url-with-combine-and-swift/" rel="noopener ugc nofollow" target="_blank">是一个关于创建<code class="fe oi oj ok ol b">AsyncImage</code>并从远程URL加载图像的很好的教程</a>。虽然这对于应用程序代码中的<code class="fe oi oj ok ol b">View</code>来说很好，但在小部件代码中却不行，实际上可能会使它崩溃。从小部件执行异步任务的唯一方法是:</p><ul class=""><li id="37d1" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">在构建时间轴条目时。</li><li id="9e32" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">通过使用后台任务。然而，这并不是一个真正的选择。后台任务不会立即执行，而是在系统决定时执行，您很可能希望尽快下载并显示该图像。</li></ul><p id="51aa" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">创建时间线的最后一步是指定重新加载策略(即，当您希望系统请求新条目时)。您可以选择:</p><ul class=""><li id="ff6b" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated"><code class="fe oi oj ok ol b">.atEnd</code> —一旦系统条目用完。</li><li id="3abb" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe oi oj ok ol b">.never</code> —应用程序将“手动”请求更新。</li><li id="427b" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe oi oj ok ol b">.after(_ date: Date)</code> —一定时间后更新。</li></ul><p id="a8c4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">正如我提到的，<code class="fe oi oj ok ol b"><a class="ae ky" href="https://github.com/fermoya/TripsCalendar/tree/master/TripsCalendarWidget/Calendar" rel="noopener ugc nofollow" target="_blank">CalendarWidget</a></code>将显示一个旅行列表。这些不会改变，除非用户删除/添加一个行程，所以在我们的例子中，我们可以选择<code class="fe oi oj ok ol b">.never</code>:</p><pre class="kj kk kl km gt oz ol pa pb aw pc bi"><span id="eb55" class="on lh it ol b gy pd pe l pf pg">let store = TripsStore()<br/>let entry = CalendarEntry(date: Date(), trips: store.trips)<br/>let timeline = Timeline(entries: [entry], policy: .never)<br/>completion(timeline)</span></pre><p id="b8ba" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">尽管如此，我还是想展示一下未来的旅程。如果用户几天没有添加或删除旅行，我的小部件可能会过时。因此，我将选择<code class="fe oi oj ok ol b">.after</code>策略:</p><pre class="kj kk kl km gt oz ol pa pb aw pc bi"><span id="d63c" class="on lh it ol b gy pd pe l pf pg">let tomorrow = ...<br/>let store = TripsStore()<br/>let entry = CalendarEntry(date: Date(), trips: store.trips)<br/>let timeline = Timeline(entries: [entry], policy: .after(tomorrow))<br/>completion(timeline)</span></pre><p id="8509" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后，每当用户删除或添加旅行时，我希望我的小部件得到相应的更新:</p><pre class="kj kk kl km gt oz ol pa pb aw pc bi"><span id="858a" class="on lh it ol b gy pd pe l pf pg">import WidgetKit</span><span id="9ad6" class="on lh it ol b gy pi pe l pf pg">func remove(trip: Trip) {<br/>    ...<br/>    WidgetCenter.shared.reloadAllTimelines()<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/6037f3dd226611d4601acae0f3cd79c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*zkk9Sk7KEk6vkEXFj55RDw.gif"/></div></figure><p id="fd82" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这里，我同时重新加载所有的时间线，但是你也可以用<code class="fe oi oj ok ol b">reloadTimelines(of:)</code>重新加载某种类型的时间线，或者用<code class="fe oi oj ok ol b">getCurrentConfigurations</code>检查你的小部件的特定意图配置。</p><p id="3c9b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">重要提示:如果您正在检索存储在您的应用程序沙箱或<code class="fe oi oj ok ol b">UserDefaults</code>中的信息，请不要忘记将<a class="ae ky" href="https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_application-groups" rel="noopener ugc nofollow" target="_blank">应用程序组</a>添加到您的“Widget扩展”功能中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/5740fdf34d300ec99930dd0aeced4dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGgz9NaN_0EdoL01iwQvyw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“应用程序组”功能</p></figure><h2 id="cab7" class="on lh it bd li oo op dn lm oq or dp lq mh os ot ls ml ou ov lu mp ow ox lw oy bi translated">占位符</h2><p id="cc04" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">您可以在系统加载您的小部件时指定一个占位符视图。SwiftUI提供了一个名为<code class="fe oi oj ok ol b">.redacted(reason: .placeholder)</code>的新修改器，它将用褪色的矩形替换<code class="fe oi oj ok ol b">Text</code>和<code class="fe oi oj ok ol b">Image</code>等:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="d445" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">WWDC20视频显示的是<code class="fe oi oj ok ol b">isPlaceholder(true)</code>，但这已经被弃用，而支持<code class="fe oi oj ok ol b">redacted(reason: .placeholder)</code>。然后在小部件的主体中:</p><pre class="kj kk kl km gt oz ol pa pb aw pc bi"><span id="6763" class="on lh it ol b gy pd pe l pf pg">StaticConfiguration(..., placeholder: CalendarPlaceholderView()) {<br/>    ... <br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/dfef0c54a37c4469b592077016c6fc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*4j4u7D5ZA_gg-r2vwf8Ahg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">NextTripPlaceholder</p></figure><p id="bd28" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意，这个初始化器在Xcode 12b3中似乎已经被否决了。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a92b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">支持多个小部件</h1><p id="78d8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">谁说你只能有一个部件？为了在你的应用中支持多个小部件，你只需要创建一个<code class="fe oi oj ok ol b">WidgetBundle</code>并在那里列出所有可用的小部件。</p><p id="0e93" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">首先，从小部件定义的顶部删除<code class="fe oi oj ok ol b">@main</code>。其次，创建一个小部件包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="722e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，当您尝试将一个小部件添加到主屏幕时，您的包中列出的所有小部件都会显示出来以供选择:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/cc2df4ea2aec1d8d126604bee0fb7423.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*VcNkrGfI7GPsdM_viqK1Qw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Widget捆绑包</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3bee" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">深层链接</h1><p id="c1b0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如前所述，小部件在资源和空间上都非常有限。你不能真的把你的小部件设计成有很多交互，比如按钮、手势等等。这意味着你的部件设计得很差，因为这不是它们的本意。根据<a class="ae ky" href="https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets#" rel="noopener ugc nofollow" target="_blank">苹果</a>:</p><blockquote class="po pp pq"><p id="92b5" class="ly lz pr ma b mb mu ju md me mv jx mg ps mw mj mk pt mx mn mo pu my mr ms mt im bi translated">“虽然人们可以点击一个小部件来查看你的应用或在你的应用中做更多事情，但小部件的主要目的是显示少量及时的个人相关信息，人们可以在不打开你的应用的情况下查看这些信息。在设计过程中，确定一个小部件的单一想法并确定要显示的信息范围是至关重要的第一步。”</p></blockquote><p id="54f7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们能做的是有有限数量的链接(不超过四个，因为他们建议)来深度链接到我们的应用程序。为此，他们提供了两种选择:</p><ul class=""><li id="49b1" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">将使你的整个部件可点击，并将深度链接到指定的网址。默认情况下，点击一个微件将会在它所在的屏幕上打开你的应用程序。</li><li id="9d4a" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe oi oj ok ol b">Link(destination: URL)</code>将一些内容包装成可点击的深度链接。</li></ul><p id="ec40" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">例如，<code class="fe oi oj ok ol b"><a class="ae ky" href="https://github.com/fermoya/TripsCalendar/blob/master/TripsCalendarWidget/Calendar/Views/CalendarWidgetEntryView.swift" rel="noopener ugc nofollow" target="_blank">CalendarWidgetEntryView</a></code>将在没有内容显示时链接到主屏幕(空视图)，并在点击一行时链接到特定的旅行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/86cae47c577311b08defcafe737cd15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*eK35We5XWDeU-lKOTPQjNQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">小部件中的深层链接</p></figure><p id="0f12" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你想了解更多SwiftUI应用周期中的深层链接，请查看本文。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3edf" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">动态(意图)部件</h1><p id="ce37" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">以前的小部件是“静态”的，因此用户无法定制。我们将构建一个新的小部件<code class="fe oi oj ok ol b"><a class="ae ky" href="https://github.com/fermoya/TripsCalendar/tree/master/TripsCalendarWidget/NextTrip" rel="noopener ugc nofollow" target="_blank">NextTripWidget</a></code>，并学习如何使小部件可配置。</p><p id="3359" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">第一步是创建意图扩展(Xcode，“新目标”，“意图扩展”)。确保您选择“无”作为起点，并且不选中“包括UI扩展”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/be2006e8552b65cab738350dd8da55de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUOFUN0lTVbx8f6URY8RBQ.png"/></div></div></figure><p id="711b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">也可以使用现有的意图扩展(如果有的话)。转到您的项目文件夹检查器，创建一个新文件(<code class="fe oi oj ok ol b">SiriKit Intent Definition File</code>)，并确保它在您的所有目标中都可用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/1b49c5b9f0a64c07e4cc035b7022939b.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*8NfZGCHKys6UqzTHzr4IVQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/5ea3ad0fca337ae58de692f8f96b0335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzezYsiLgAxd4u5LAUAskQ.png"/></div></div></figure><p id="b8d0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于<code class="fe oi oj ok ol b">NextTripWidget</code>、<em class="pr">、</em>我希望能够选择显示什么样的行程。为此，我将在我的意图定义文件中创建一个名为<code class="fe oi oj ok ol b">IntentTrip</code>的新类型，并将它作为参数添加到我的意图中。点击+添加一个新的意图，选择一个名称，并确保“意图适用于小部件”和“选项动态提供”都被选中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/aeac9795d314794a955e3cdf7a07824a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hyZ1LMZM6zCOdppERpXXUA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/581216389b31e45a23fb7dacb543188f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvjGz_uVx6OhUSu1HaTG3w.png"/></div></div></figure><p id="3fc0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你现在编译，Xcode会生成一个<code class="fe oi oj ok ol b">IntentHandling</code>协议和一个<code class="fe oi oj ok ol b">Intent</code>类，并带有一个属性来保存你的自定义类型参数。我在我的意图定义文件中调用了我的意图<code class="fe oi oj ok ol b">NextTrip</code>，所以Xcode生成了一个<code class="fe oi oj ok ol b">NextTripIntentHandling</code>协议。使<code class="fe oi oj ok ol b">IntentHandler</code>符合该协议:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/c5a041240718595bc6ffa723d7cf1020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhDokmpRCEf3qMwpEkGfOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">NextTripHandling的实现</p></figure><p id="5687" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后，您所要做的就是让您的小部件使用一个<code class="fe oi oj ok ol b">IntentConfiguration</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/5728192a6be318725a8d411a51e6024c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bcu8qogkD01QG5GWuvpqHQ.png"/></div></div></figure><p id="f19e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">并使您的提供商符合<code class="fe oi oj ok ol b">IntentTimelineProvider</code>而不是<code class="fe oi oj ok ol b">TimelineProvider</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/198996dfb07bdbb79adfca284a65ec72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qsZMC0C-tE0eCoA33t3rQQ.png"/></div></div></figure><p id="fc15" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，您可以从您的意向中检索选定的行程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/19d7b24ccedf21acb618420ef9cc039c.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*rBp_oYp2-KgI6To9uTIiOg.gif"/></div></figure><p id="f777" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">请注意iOS是如何为对话框使用自定义颜色的。为此，您只需在您的<code class="fe oi oj ok ol b">Widget Extension Assets</code>目录中定义一个<code class="fe oi oj ok ol b">AccentColor</code>和一个<code class="fe oi oj ok ol b">WidgetBackgroundColor</code>。如果您想要使用不同的名称，您可以在widget的目标构件设置中更改它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/7815706d8878ee1582285530fe12bb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEnk-3UENjAbohwR0_FHsA.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fb8c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">智能部件:捐赠和相关性</h1><p id="e677" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">iOS 14附带了一个智能堆栈，可以根据用户的兴趣和他们在任何时候最有可能做的事情来旋转用户的小工具。我们怎样才能使我们的小部件适合这样的旋转，并告诉系统一些时间轴条目是重要的？有两种方法可以做到。</p><h2 id="16f1" class="on lh it bd li oo op dn lm oq or dp lq mh os ot ls ml ou ov lu mp ow ox lw oy bi translated">关联</h2><p id="19f8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe oi oj ok ol b">TimelineEntry</code>协议带有一个变量<code class="fe oi oj ok ol b">var relevance</code> : <code class="fe oi oj ok ol b">TimelineEntryRelevance?</code>。默认情况下，这个值是<code class="fe oi oj ok ol b">nil</code>，所以您需要在条目中声明它。</p><p id="2798" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">例如，<code class="fe oi oj ok ol b"><a class="ae ky" href="https://github.com/fermoya/TripsCalendar/tree/master/TripsCalendarWidget/NextTrip" rel="noopener ugc nofollow" target="_blank">NextTripWidget</a></code>显示了任何未来的旅行，但是一个正在进行的旅行比另一个两周后的旅行更有意义。在<code class="fe oi oj ok ol b"><a class="ae ky" href="https://github.com/fermoya/TripsCalendar/blob/master/TripsCalendarWidget/NextTrip/Provider/NextTripProvider.swift" rel="noopener ugc nofollow" target="_blank">NextTripProvider</a></code>中创建时间线时，我们可以为正在进行的旅行指定一个高于非当前旅行的分数:</p><pre class="kj kk kl km gt oz ol pa pb aw pc bi"><span id="46e6" class="on lh it ol b gy pd pe l pf pg">let score: Float = (trip?.isOngoing ?? false) ? 1 : 0<br/>let relevance = TimelineEntryRelevance(score: score)</span><span id="8f4b" class="on lh it ol b gy pi pe l pf pg">let entry = NextTripEntry(date: now, trip: trip, relevance: relevance)</span></pre><p id="6878" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这种情况下，我使用从0到1的范围。正在进行的旅行将获得比其他旅行(0)更高的相关性(1)。</p><h2 id="4d1a" class="on lh it bd li oo op dn lm oq or dp lq mh os ot ls ml ou ov lu mp ow ox lw oy bi translated">意向捐赠</h2><p id="53a1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Siri意图是在iOS 12中引入的，并且已经用于建议、快捷方式等。在这种情况下，可以使用相同的实现。</p><p id="4641" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">例如，当用户访问一些旅行详细信息时，我们可以通过捐赠在前面部分中创建的类型的意图来让系统知道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="a9f3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这将向系统“捐赠”一个交互。如果系统检测到用户在某个时间在他们的设备中执行了一些操作，变成了这些交互之一，那么智能堆栈将显示一个与该交互的标识符匹配的小部件。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fc70" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">更新</h1><p id="f19d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Xcode 12中的实现略有变化。这些是主要的变化:</p><ul class=""><li id="b6ee" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">占位符:您不需要在小部件配置<code class="fe oi oj ok ol b">StaticConfiguration</code>或<code class="fe oi oj ok ol b">IntentConfiguration</code>中提供占位符。相反，在你的<code class="fe oi oj ok ol b">TimelineProvider</code>中覆盖<code class="fe oi oj ok ol b">placeholder(in:)</code>。</li><li id="dad1" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe oi oj ok ol b">snapshot(for:in:completion:)</code>已更名为<code class="fe oi oj ok ol b">getSnapshot(for:in:completion:)</code></li><li id="49fc" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe oi oj ok ol b">timeline(for:in:completion:)</code>已更名为<code class="fe oi oj ok ol b">getTimeline(for:in:completion:)</code></li></ul><h1 id="d82e" class="lg lh it bd li lj qe ll lm ln qf lp lq jz qg ka ls kc qh kd lu kf qi kg lw lx bi translated">结论</h1><p id="3099" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">苹果押注于widgets，这些widgets似乎比旧的Today widgets有用得多。根据您的需求使用静态或动态配置，不要一次给用户提供过多的信息。保持你的小工具简单，交互少。不要执行任何耗时的操作。请改用应用程序。</p></div></div>    
</body>
</html>