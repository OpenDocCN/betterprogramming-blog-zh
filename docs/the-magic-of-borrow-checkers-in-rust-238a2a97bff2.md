# 生锈借检查器的魔力

> 原文：<https://betterprogramming.pub/the-magic-of-borrow-checkers-in-rust-238a2a97bff2>

## 了解 Rust 编程语言的独特之处

![](img/894fc0921791fdbafdc0cf63240cec81.png)

由 [Jantine Doornbos](https://unsplash.com/@jantined?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

当我第一次偶然发现 Rust 时，是通过一篇文章，这篇文章吹捧 Rust 在 Stack Overflow 的年度最受欢迎编程语言调查中连续几年被选为“最受欢迎的编程语言”。

高级语言描述很有趣——编译、无虚拟机、高效、快速、安全。我承认对编译语言和类型安全语言的偏爱。我在 C 上长大，教过 C、C++和 Java，职业生涯的大部分时间都在使用 Java。在我研究的早期，我碰到了一堆类似“为什么 Rust 比<insert programming="" language="" here="">更好”和“为什么你应该学习 Rust”的文章。</insert>

它们似乎都来自同一个根源——并且大部分涵盖了任何不在虚拟机运行时上运行的静态类型语言所拥有的要点。“快得惊人”“在编译时发现变量类型不匹配”就是例子。

缺少的是对 Rust 的独特之处的解释，这是其他语言所没有的。我想解决本文中的第一个原因 Rust 借用检查器。

Rust 的发明者受益于其他编程语言的多年实践经验。他们在语言和相关工具中设计了一组特性，解决了应用程序开发人员面临的许多棘手问题。首先是内存管理。从一开始，程序就处理如何安全地使用内存，而 Rust 借用检查器是解决这个问题的一种新方法。

# 一些历史

首先，让我回顾一下编程语言试图解决这个问题的历史。一开始有 C，还有低级的、经常被诅咒的“`malloc()`”和“`free()`”c 是一种编程语言，它让开发人员能够完全控制他们的环境——它是汇编语言的一小步。

开发人员可以完全管理应用程序的内存访问，以及如何将分配的内存交还给操作系统。这种低层次的控制需要大量仔细的计划。但是，它是许多运行时错误的来源，通过内存泄漏(不释放内存)或崩溃(释放同一个指针两次或在释放后使用内存是常见的问题)。这也是安全问题的一个来源——读取先前释放的内存中不应该有的数据可能会被利用。

下面是一个示例程序，它演示了编译器允许但不正确的内容:

c 代码示例

C++能够更好地控制内存分配。类有构造函数为它们的对象分配内存，析构函数释放内存。还创建了智能指针，在变量超出范围时帮助自动释放内存。但是低级指针和引用的“脚枪”使得错误难以消除。如果你遵循这些规则，你是没问题的，但是如果你不知道这些规则，编译器是没有任何帮助的。对象内部隐藏的复杂性也使得遵循规则和预测应用程序的性能变得困难。

# 碎片帐集

编程语言转向垃圾收集作为解决这些问题的手段。基于垃圾收集的程序可以从运行时环境中获取它们需要的任何内存。在后台，一旦程序不再使用内存，垃圾收集进程就会将内存释放回操作系统。依赖于在运行时解释源代码的脚本语言，包括 Basic、Python 和 JavaScript，在其解释器的运行时环境中使用这种方法。

Java 是第一种以在执行垃圾收集的运行时(JVM)中运行为目标的编译语言。新的编程语言，包括 Golang (Go)和 Dart，利用了垃圾收集。这些环境对于开发人员来说是高效的——它使得管理内存变得更加简单。垃圾收集器已经变得非常复杂，许多应用程序类型在这种环境下都能很好地工作。

但是垃圾收集有其局限性。垃圾收集器带来的开销会影响应用程序的运行时行为。应用程序中的暂停必须被调度，这使得垃圾收集语言不适合实时编程。伴随环境的运行时通常也是重量级的，这在嵌入式和物联网设备(或容器化微服务)的小环境中运行时会造成阻碍。

这里有一个与我们的 C 版本类似的 Java 应用程序的简单例子。它展示了垃圾收集是如何有用的:

Java 代码示例

一切都可以编译，但是我们在运行时得到的是一致的崩溃，而不是未定义的运行时行为；这有好有坏。可预测的行为是好的，但是 Java " `NullPointerException`"运行时错误已经使生产中的应用程序崩溃了很多次，这是任何人都不愿意承认的。

当我们注释掉错误的行时，我们现在会看到一个副作用——新变量没有接收到数组的全新版本；它只是“指向”原文。当我们修改新变量时，原来的变量的内容被修改掉了。在这个简单的例子中，我们可以跟踪这里发生的事情，但是如果修改发生在嵌套库函数的深处，我们很容易感到惊讶。

但是，我们的内存管理更加简单。我们可以在运行时请求我们需要的内存空间，而不必处理放弃它的问题。易用性是垃圾收集广泛存在的原因，像 JavaScript、Python、Go 和 Dart 这样的主流语言今天都在使用它。

# 铁锈有什么不同

Rust 的内存管理方法简化了垃圾收集环境的内存管理，而没有运行时环境开销或相关的性能损失。它还解决了我们在 Java 示例中看到的意外副作用问题。

智能指针风格的机制是一个关键，但是编译器强制执行访问规则，而不是依赖程序员来遵循使用规则(如 C++)。“对抗借用检查器”是 Rust 新开发人员首先要解决的问题之一，但是一旦掌握了，它就能让开发人员自动管理他们的内存使用。

除了高效的开发环境，Rust 的借用检查器还消除了一整类与内存管理相关的编程错误。调查表明，应用程序中的许多安全漏洞是由于程序无法保护对已分配内存的访问。Rust 程序运行速度快，使开发人员更高效，更安全，并减少运行时崩溃。

让我们看一个 Rust 应用程序，它模拟了我们的例子:

最后—一些生锈的代码！

我们再次使用 Rust 的 Vector 类型在堆上分配一块内存。`Vector`是动态调整大小的连续内存块，像数组一样被访问，并存储在堆上。相比之下，第 8 行分配一个数组，它在编译时大小固定，在堆栈上分配。因为我们知道编译时的数组大小，所以我们在第 11 行得到一个编译器警告。Rust 知道我们已经过了数组的末尾。

Rust 的编译器让我们安全。

Rust 编译器非常擅长给我们提供有意义的错误信息。在第 15 行，向量被“移动”到一个新家——它在`my_vector`不再存在。Rust 跟踪分配的内存，但确保只有一个变量“拥有”内存并可以进行更改。

如果我们声明一个变量是不可变的，我们可以把它赋给我们的向量。我们只能通过这个新变量“读取”值，而不能写入它们。Rust 强制执行一条规则，即一次只能有一个“作者”/“所有者”——这样，它可以防止所有“谁保存最后谁就赢”的错误，这是我们在 Java 示例中看到的意外副作用问题。它还可以跟踪使用已分配内存的变量，以确保当使用内存的所有变量都超出范围时，它会被释放。

下面是我们的示例程序，其中一个不可变变量指向我们的向量:

相同的代码，显示借用一个不可变变量。

# Rust 的借用检查器的神奇之处在于…

1.  Rust 确保任何内存(堆或栈)的所有权都在一个地方。只有数据的所有者才能操作它。允许多次只读访问。
2.  Rust 跟踪使用的内存变量，并在所有使用内存的变量都超出范围时自动释放内存——无论是在堆栈上(我们的数组示例)还是在堆上(我们的 Vector 示例)。
3.  边界检查在编译时(对于数组，其大小在编译时确定)或运行时(向量，其大小在运行时设置)强制执行。
4.  这些规则消除了一整类错误和安全漏洞。我们不能在`free()`之后写入内存——只要有任何东西可以访问，Rust 就会自动为我们保留内存。这些规则都是在编译时检查的。我们不必担心释放内存——Rust 会处理好这一点。边界检查还防止我们在分配给我们的内存空间之外进行写操作。
5.  这大部分发生在编译时——我们没有运行时垃圾收集器必须与我们一起运行，并且没有中断程序执行以允许垃圾收集器询问内存使用情况。一个常见的 Rust 说法是:“如果它编译，它将工作。”

更好的是，借用检查器的工作方式使多个线程能够安全地使用分配的内存。当程序进入多线程执行时，出错的机会会成倍增加。“无所畏惧的并发性”——自动跨多个线程安全地使用数据——是 Rust 的借用检查器的一个显著优势。

Rust 的内存管理和借用检查器是 Rust 与众不同的两个主要原因。您可以完全控制地访问低级别内存，没有垃圾收集器运行时，也没有运行时错误意外破坏程序的风险。

这个特性使得 Rust 非常适合低级别系统、嵌入式或实时应用程序，这些应用程序都需要效率。它还使 Rust 能够用于更高级别的应用程序，如 web 服务发布，因为“内存自动释放”环境对开发人员来说是高效的。

但这还不是全部。

请继续关注 Rust 的另一个伟大特性！