<html>
<head>
<title>Uses of Coroutines in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中协程的使用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/coroutines-in-android-a-thought-8044995fa0e3?source=collection_archive---------10-----------------------#2022-02-10">https://betterprogramming.pub/coroutines-in-android-a-thought-8044995fa0e3?source=collection_archive---------10-----------------------#2022-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="828a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">知道如何使用协程处理长时间运行的任务和主线程安全</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a5f851689be9a76932e600cbf42d89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cHhBYNqZuvUi3jOI"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马克·赖歇尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="153c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协同程序是在Kotlin 1.3中引入的。这些在Kotlin中可能是新的，但是协程的概念并不新颖。它于1967年首次在Simula推出。现在它已经流行起来，被很多语言采用，比如Python，C#，Ruby，Go等等。</p><p id="59f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协同程序引入了一种新的并发方式，有助于简化异步编程。</p><p id="0153" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所知，在android编程中，我们面临两个主要问题:</p><ol class=""><li id="b17d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">长期运行任务的处理</li><li id="2d4b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">主要安全</li></ol><h1 id="9e46" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">长时间运行任务的处理</h1><p id="d236" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">长时间运行的任务需要花费太多时间来执行，我们不得不等待它们，这些任务可以是我们从网络服务器获取数据的任何网络请求，也可以是读取设备中的任何文件。</p><p id="460c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据设备的配置，这些任务的性能因设备而异。具有高配置的设备执行这些请求将花费较少的时间，而具有低配置的设备将花费较多的时间，并且可能导致无响应。</p><p id="1e0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Android中，每个应用程序都有一个主线程，负责处理和绘制该应用程序的UI。如果任何任务花费太多时间来执行，那么它将导致该应用程序的不适当行为，因为它阻塞了主线程。为了克服这个问题，协程可以帮助我们。</p><p id="2dda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在协程之前，这些操作是通过使用回调和其他库如RxJava、RxAndroid来处理的。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="56e7" class="ni mh iq ne b gy nj nk l nl nm">class NotesViewModel:ViewModel(){<br/>    fun fetchNotes(){<br/>        get(“someurl”)<strong class="ne ir">{<br/>                </strong>result<strong class="ne ir">-&gt;{<br/>            </strong>showNotes(result)<br/>        <strong class="ne ir">}<br/>        }<br/>    </strong>}<br/>}</span></pre><p id="4de5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种类型的请求方法将从主线程调用，请求将来自另一个工作线程，结果将在主线程上提供，以便我们可以根据需要访问该结果。</p><p id="5d1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种类型的功能可以由第三方库提供，如翻新，使网络请求远离应用程序的主线程。</p><h2 id="94cd" class="ni mh iq bd mi nn no dn mm np nq dp mq lf nr ns ms lj nt nu mu ln nv nw mw nx bi translated">在长时间运行的任务中使用协程</h2><p id="a153" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个操作也可以在协程的帮助下完成。但是这里的主要区别是，它不会阻塞主线程，而是基于挂起和恢复的概念工作。</p><p id="73e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用协程，上述请求如下所示:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8730" class="ni mh iq ne b gy nj nk l nl nm">class NotesViewModel : ViewModel() {<br/>    suspend fun fetchNotes() {<br/>        var result = get(“ someurl ”)<strong class="ne ir">{<br/>            </strong>showNotes(result)<br/>        <strong class="ne ir">}<br/>    </strong>}<br/><br/>    suspend fun get(url: String) {<br/>        <em class="ny">/**/<br/>    </em>}<br/>}</span></pre><p id="0186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子不会阻塞主线程，但是它会挂起当前的协程，并等待方法的结果，当它得到结果时，它将从挂起前一次执行的地方开始执行。</p><p id="8a1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个过程中，它不会阻塞主线程，主线程可以自由地完成它的任务，无论它在做什么。</p><p id="4688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它看起来像我们写的顺序代码，但它不会阻塞主线程。</p><h1 id="7645" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">主安全</strong></h1><p id="07e6" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在Kotlin中，从主线程调用这些挂起函数是安全的，因为它们不会阻塞主线程。除了这些任务之外，android中还有几个我们不能在主线程上执行的功能，因为它们的行为很慢，比如JSON解析、从数据库读取和写入数据，所以所有这些任务都可以使用suspend函数来完成。</p><p id="4269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用suspend并不表示这个操作将在后台线程上执行，它将告诉我们这个操作不会妨碍主线程。因此，无论何时你做任何缓慢的任务，你都可以使用协程。</p><p id="bdc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Android中，所有的协程都运行在一个调度程序上，它们可以挂起自己，调度程序知道如何恢复协程。</p><p id="44f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用Kotlin提供的调度程序来指定<code class="fe nz oa ob ne b">suspend</code>函数将在哪里运行</p><p id="1afd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同一件事的三个调度员:</p><ol class=""><li id="8357" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">调度员。主要的</li><li id="3a61" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">调度员。超正析象管(Image Orthicon)</li><li id="4439" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">调度员。默认</li></ol><h2 id="1b38" class="ni mh iq bd mi nn no dn mm np nq dp mq lf nr ns ms lj nt nu mu ln nv nw mw nx bi translated"><strong class="ak">调度员。主</strong></h2><p id="d938" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">顾名思义，它运行在主线程上，用于更新应用程序的UI。可以从这里调用挂起函数。</p><h2 id="e77b" class="ni mh iq bd mi nn no dn mm np nq dp mq lf nr ns ms lj nt nu mu ln nv nw mw nx bi translated"><strong class="ak">调度员。IO </strong></h2><p id="cdd4" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">它在后台线程中运行，主要用于与网络相关的繁重任务。</p><h2 id="0453" class="ni mh iq bd mi nn no dn mm np nq dp mq lf nr ns ms lj nt nu mu ln nv nw mw nx bi translated"><strong class="ak">调度员。默认</strong></h2><p id="292e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">它在后台线程中工作，主要用于CPU密集型工作，如解析JSON或访问任何列表。</p><p id="d632" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续上面的例子，如果我们在Dispatchers的上下文中讨论，那么上面的代码看起来像这样</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d86b" class="ni mh iq ne b gy nj nk l nl nm">class NotesViewModel : ViewModel() {<br/>    suspend fun fetchNotes() {<br/>        <em class="ny">//Dispatchers.Main<br/>        </em>var result = get(“ someurl ”)<strong class="ne ir">{<br/>            </strong><em class="ny">//Dispatchers.Main<br/>            </em>showNotes(result)<br/>        <strong class="ne ir">}<br/>    </strong>}<br/><br/>    <em class="ny">//Dispatchers.IO<br/>    </em>suspend fun get(url: String) {<br/>        <em class="ny">/**/<br/>    </em>}<br/>}</span></pre><p id="14da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，<code class="fe nz oa ob ne b">get()</code>方法正在发出一个网络请求，它正在使用运行在主线程上的<code class="fe nz oa ob ne b">Dispatchers.IO</code>及其结果，我们正在主线程上使用<code class="fe nz oa ob ne b">Dispatchers.Main</code>上下文更新主线程上的UI。</p><p id="6458" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让每个挂起函数都是主安全的，这是一个非常好的实践。如果它做任何使用太多CPU的事情，使用<code class="fe nz oa ob ne b">withContext</code>使它从主线程调用变得安全。这是基于协程的库(如Retrofit和Room)遵循的模式。</p><p id="b2e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你使用这种风格，那么你的代码会简单得多。当一致遵循时，协程可以在主线程上自由启动，用简单的代码发出网络或数据库请求，同时保证用户不会面临任何问题。</p><h2 id="97de" class="ni mh iq bd mi nn no dn mm np nq dp mq lf nr ns ms lj nt nu mu ln nv nw mw nx bi translated">withContext性能</h2><p id="5531" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><code class="fe nz oa ob ne b">withContext</code>与回调或RxJava一样快，可提供主要安全性。在某些情况下，甚至可以优化<code class="fe nz oa ob ne b">withContext</code>调用，而不仅仅是回调。</p><p id="7f5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个函数将对一个数据库进行10次调用，你可以告诉Kotlin在所有10次调用的外围<code class="fe nz oa ob ne b">withContext</code>切换一次。然后，即使数据库库会反复调用<code class="fe nz oa ob ne b">withContext</code>，它也会停留在同一个调度程序上，并遵循一条快速路径。</p><p id="02b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，优化了<code class="fe nz oa ob ne b">Dispatchers.Default</code>和<code class="fe nz oa ob ne b">Dispatchers.IO</code>之间的切换，以尽可能避免线程切换。</p><h1 id="eb81" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">最后的想法</h1><p id="09a9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">正如我们已经看到的，我们可以通过协程解决什么问题。协程是一个老概念，最近变得流行起来，因为它们能够使与网络交互的代码更加简单。</p><p id="bd2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在Android中使用它，原因如下:</p><ol class=""><li id="8fe8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">简化长时间运行操作的代码，如下载图像、获取数据或读取文件。</li><li id="fcff" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">执行主安全意味着您的代码不会阻塞主线程，并且保持简单。</li></ol><h1 id="fc0e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">参考</h1><p id="7c78" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><a class="ae kv" href="https://developer.android.com/kotlin/coroutines?gclid=Cj0KCQiAjJOQBhCkARIsAEKMtO0tFOa9ntBdbEfu3DjPIMfOzz9xdKWg5-38sdFXtQOGnFX8q1cyCrkaAqvrEALw_wcB&amp;gclsrc=aw.ds" rel="noopener ugc nofollow" target="_blank">Android上的Kotlin协同程序</a></p></div></div>    
</body>
</html>