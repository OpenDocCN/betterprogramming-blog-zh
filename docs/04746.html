<html>
<head>
<title>How to Easily Fetch Binance Historical Trades Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python轻松获取币安历史交易</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-easily-fetch-your-binance-historical-trades-using-python-174a6569cebd?source=collection_archive---------0-----------------------#2020-05-06">https://betterprogramming.pub/how-to-easily-fetch-your-binance-historical-trades-using-python-174a6569cebd?source=collection_archive---------0-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f0e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">创建一个可靠的脚本，从币安提取历史贸易数据</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1df443e444436a85147de8a3e28b2941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpqqDEzH1oOMgbrKIyunaA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@austindistel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>在<a class="ae ky" href="https://unsplash.com/s/photos/trading?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:本文仅供娱乐和教育之用，并非理财建议。</em></p><p id="a774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一家加密货币交易所的前首席技术官，我参与了几个主要交易所的API。在本文中，我将指导您创建一个可靠的Python脚本来从币安提取历史贸易数据。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="588c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">基本原理</h1><p id="38bb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当回测交易策略时，也就是说，用过去的数据执行我们的策略，分析回报和其他重要因素时，我们必须确保我们有合适的数据来处理。这个过程并不总是如此简单，因为有些策略需要水平簿数据，其他策略可能只需要一小时蜡烛线就可以了，并且基础架构、可用性和连接性等元素可能会因您需要的数据类型而有很大不同。</p><p id="ad65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道这些<em class="lv">级别的书籍数据是什么意思，也没有必要担心，因为我们不会在这篇文章中触及这些。</em></p><p id="6cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所需数据主要由交易策略的频率决定。交易策略类别是我将在我的算法交易系列中写的另一个主题，但是你可以在<a class="ae ky" href="https://www.investopedia.com/articles/active-trading/11/four-types-of-active-traders.asp" rel="noopener ugc nofollow" target="_blank"> Investopedia中找到一些可靠的信息。</a></p><p id="d394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，但是为什么这篇文章仅仅是关于获取“交易”数据，为什么我们要使用币安API？你，读者，一定对我的文章内容有点困惑。</p><h2 id="dc17" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">数据频率和币安</h2><p id="d9f4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我认为，贸易数据端点主要存在于99.99%的交易所。它是细粒度的，为回溯测试<a class="ae ky" href="https://www.investopedia.com/terms/h/high-frequency-trading.asp" rel="noopener ugc nofollow" target="_blank">高频交易(HFT) </a>策略提供了足够的细节(在某些<strong class="lb iu"> </strong>非常特殊的情况下)，也为<a class="ae ky" href="https://www.investopedia.com/terms/o/ohlcchart.asp" rel="noopener ugc nofollow" target="_blank"> OHLC蜡烛线</a>(1秒到24H，或者更多，如果你愿意的话)。</p><p id="28a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交易数据是多用途的，允许对不同频率的策略进行大量实验。</p><p id="da3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么<a class="ae ky" href="https://binance.com" rel="noopener ugc nofollow" target="_blank">币安</a>？这只是因为它是我倾向于回测的交易所之一，因为它的交易量很大。我与币安没有任何关系。我们将在我的算法交易系列中查看其他交易所。</p><blockquote class="nm"><p id="f8e7" class="nn no it bd np nq nr ns nt nu nv lu dk translated">“空谈是廉价的。给我看看代码。”——莱纳斯·托瓦尔兹</p></blockquote></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7380" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我们将编码什么</h1><p id="96eb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们将创建一个Python脚本，它接收成对符号、开始日期和结束日期作为命令行参数。它会将包含所有交易的CSV文件输出到磁盘。该过程可以通过以下步骤来详述:</p><ul class=""><li id="59ad" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">解析<code class="fe of og oh oi b">symbol</code>、<code class="fe of og oh oi b">starting_date</code>和<code class="fe of og oh oi b">ending_date</code>参数。</li><li id="1d48" class="nw nx it lb b lc oj lf ok li ol lm om lq on lu ob oc od oe bi translated">获取起始日发生的第一笔交易，得到第一笔<code class="fe of og oh oi b">trade_id</code>。</li><li id="eb8e" class="nw nx it lb b lc oj lf ok li ol lm om lq on lu ob oc od oe bi translated">循环提取每个请求1000笔交易(币安API限制)，直到达到<code class="fe of og oh oi b">ending_date</code>。</li><li id="c3a4" class="nw nx it lb b lc oj lf ok li ol lm om lq on lu ob oc od oe bi translated">最后，将数据保存到磁盘。对于这个例子，我们将把它保存在CSV中，但是您还有其他几个选项可以选择。</li></ul><p id="a0a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<code class="fe of og oh oi b">pandas</code>、<code class="fe of og oh oi b">requests</code>、<code class="fe of og oh oi b">time</code>、<code class="fe of og oh oi b">sys</code>和<code class="fe of og oh oi b">datetime</code>库。在代码片段中，不会显示错误验证，因为它不会给解释增加任何价值。当然，你可以在<a class="ae ky" href="https://github.com/tgcandido/binance-data-fetcher" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看完整代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2842" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">编码时间</h1><h2 id="ea41" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">解析参数</h2><p id="5628" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">该脚本将使用以下参数:</p><ul class=""><li id="24f4" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe of og oh oi b">symbol</code>:交易对的符号，由币安定义。可以在这里查询<a class="ae ky" href="https://api.binance.com/api/v1/ticker/allPrices" rel="noopener ugc nofollow" target="_blank">，也可以从币安web app的网址复制，不包括<code class="fe of og oh oi b">_</code>字符。</a></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/c8c2847352442b9e07e81f279f3bd49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*_pB8bKGbi5_ofHVFOouj8A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从URL的最后一部分去掉“_”，就得到这个符号</p></figure><ul class=""><li id="80a0" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe of og oh oi b">starting_date and ending_date</code>:不言自明。期望的格式是<code class="fe of og oh oi b">mm/dd/yyyy</code>，或者用Python俚语来说是<code class="fe of og oh oi b">%m/%d/%Y</code>。</li></ul><p id="df31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得参数，我们将使用内置的<code class="fe of og oh oi b">sys</code>(这里没有什么特别的)，为了解析日期，我们将使用<code class="fe of og oh oi b">datetime</code>库。</p><pre class="kj kk kl km gt op oi oq or aw os bi"><span id="ccb8" class="na me it oi b gy ot ou l ov ow">symbol = sys.argv[1]<br/>starting_date = datetime.strptime(sys.argv[2], '%m/%d/%Y')<br/>ending_date = datetime.strptime(sys.argv[3], '%m/%d/%Y') + timedelta(days=1) - timedelta(microseconds=1)</span></pre><p id="34c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们增加一天，减去一微秒，这样<code class="fe of og oh oi b">ending_date</code>的时间部分总是在<code class="fe of og oh oi b">23:59:59.999</code>处，使得获得同一天的时间间隔更加实际。</p><h2 id="e0b1" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">获取交易</h2><p id="23a9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用<a class="ae ky" href="https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md" rel="noopener ugc nofollow" target="_blank">币安的API </a>和使用<code class="fe of og oh oi b"><a class="ae ky" href="https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list" rel="noopener ugc nofollow" target="_blank">aggTrades</a></code>端点，我们在一个请求中最多可以获得1000笔交易，如果我们使用start和end参数，它们最多可以相差一个小时。在一些失败之后，通过利用时间间隔(在某个时候，流动性会变得疯狂，我会失去一些宝贵的交易)，我决定尝试<code class="fe of og oh oi b">from_id</code>策略。</p><p id="5361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择<code class="fe of og oh oi b">aggTrades</code>端点是因为它返回压缩的交易。这样，我们就不会丢失任何珍贵的信息。</p><p id="7727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进行压缩、汇总交易。在同一时间、同一订单、以相同价格成交的交易将对数量进行汇总。</p><p id="6e83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">from_id</code>策略是这样的:我们将通过向端点发送日期间隔来获得<code class="fe of og oh oi b">starting_date</code> <em class="lv"> </em>的第一笔交易。之后，我们将获取1000个交易，从第一个获取的交易ID开始。然后，我们将检查最后一笔交易是否发生在我们的<code class="fe of og oh oi b">ending_date</code>之后。如果是这样，我们已经完成了所有的时间段，我们可以将结果保存到文件中。否则，我们将更新我们的<code class="fe of og oh oi b">from_id</code>变量以获得最后一个交易ID，并再次开始循环。</p><p id="3654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唉，说够了，让我们编码吧。</p><h2 id="0fa9" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">获取第一个交易ID</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="ef45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们创建一个<code class="fe of og oh oi b">new_end_date</code>。这是因为我们通过传递一个<code class="fe of og oh oi b">startTime</code>和一个<code class="fe of og oh oi b">endTime</code> <em class="lv"> </em>参数来使用<code class="fe of og oh oi b">aggTrades</code>。现在，我们只需要知道这个周期的第一个交易ID，所以我们给这个周期增加了60秒。在低流动性对中，这个参数是可以改变的，因为不能保证交易发生在被请求的当天的第一分钟。</p><p id="9635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，使用我们的helper函数解析日期，通过使用<code class="fe of og oh oi b">calendar.timegm</code>函数将其转换为Unix毫秒表示。最好使用<code class="fe of og oh oi b">timegm</code>函数，因为它以UTC格式保存日期。</p><pre class="kj kk kl km gt op oi oq or aw os bi"><span id="6036" class="na me it oi b gy ot ou l ov ow">def get_unix_ms_from_date(date):<br/>    return int(calendar.timegm(date.timetuple()) * 1000 + date.microsecond/1000)</span></pre><p id="adda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该请求的响应是一个按日期排序的交易对象列表，格式如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="313d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们需要第一个交易ID <strong class="lb iu">、</strong>时，我们将返回<code class="fe of og oh oi b">response[0]["a"]</code>值。</p><h2 id="7a12" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">主循环</h2><p id="7303" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们有了第一个交易ID，我们可以一次获取1000笔交易，直到到达我们的<code class="fe of og oh oi b">ending_date</code>。下面的代码将在我们的主循环中被调用。它将使用<code class="fe of og oh oi b">from_id</code>参数执行我们的请求，放弃<code class="fe of og oh oi b">startDate</code>和<code class="fe of og oh oi b">endDate</code>参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="f0e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这里是我们的主循环，它将执行请求并创建我们的<code class="fe of og oh oi b"><a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank">DataFrame</a></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="b354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们检查包含最近获取的交易日期的<code class="fe of og oh oi b">current_time</code>是否大于我们的<code class="fe of og oh oi b">to_date</code>，如果是，我们:</p><ul class=""><li id="4d02" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">使用<code class="fe of og oh oi b">from_id</code>参数提取交易</li><li id="4fb2" class="nw nx it lb b lc oj lf ok li ol lm om lq on lu ob oc od oe bi translated">更新<code class="fe of og oh oi b">from_id</code>和<code class="fe of og oh oi b">current_time</code>参数，两者都使用从最新交易中获取的信息</li><li id="8d82" class="nw nx it lb b lc oj lf ok li ol lm om lq on lu ob oc od oe bi translated">打印一条<code class="fe of og oh oi b">nice</code>调试信息</li><li id="232f" class="nw nx it lb b lc oj lf ok li ol lm om lq on lu ob oc od oe bi translated"><code class="fe of og oh oi b"><a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html" rel="noopener ugc nofollow" target="_blank">pd.concat</a></code>我们的<code class="fe of og oh oi b">DataFrame</code>中的交易与之前的交易一起提取</li><li id="aaee" class="nw nx it lb b lc oj lf ok li ol lm om lq on lu ob oc od oe bi translated">稍微睡一会儿，这样币安就不会给我们一个难看的429 HTTP响应</li></ul><h2 id="a327" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">清洁和保存</h2><p id="900c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">组装完我们的<code class="fe of og oh oi b">DataFrame</code>之后，我们需要执行一个简单的数据清理。我们将删除重复的和<code class="fe of og oh oi b">trim</code>在我们的<code class="fe of og oh oi b">to_date</code>之后发生的交易(我们有这个问题，因为我们正在获取1000个交易的大块，所以预计我们会在我们的目标结束日期之后执行一些交易)。</p><p id="2c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以封装我们的<code class="fe of og oh oi b">trim</code>功能:</p><pre class="kj kk kl km gt op oi oq or aw os bi"><span id="b3bb" class="na me it oi b gy ot ou l ov ow">def trim(df, to_date):<br/>    return df[df['T'] &lt;= get_unix_ms_from_date(to_date)]</span></pre><p id="669e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并执行我们的数据清理:</p><pre class="kj kk kl km gt op oi oq or aw os bi"><span id="ace5" class="na me it oi b gy ot ou l ov ow">df.drop_duplicates(subset='a', inplace=True)<br/>df = trim(df, to_date)</span></pre><p id="f647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用<code class="fe of og oh oi b"><a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html" rel="noopener ugc nofollow" target="_blank">to_csv</a></code>方法将其保存到文件中:</p><pre class="kj kk kl km gt op oi oq or aw os bi"><span id="ebaf" class="na me it oi b gy ot ou l ov ow">filename = f'binance__{symbol}__trades__from__{sys.argv[2].replace("/", "_")}__to__{sys.argv[3].replace("/", "_")}.csv'<br/>df.to_csv(filename)</span></pre><p id="812d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用其他数据存储机制，比如Arctic。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d75e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">奖励:验证您的数据</h1><p id="842f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在制定交易策略时，相信我们的数据是很重要的。通过应用以下验证，我们可以很容易地对提取的交易数据进行验证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="3483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码片段中，我们将我们的<code class="fe of og oh oi b">DataFrame</code>转换为一个<a class="ae ky" href="https://numpy.org/doc/stable/reference/arrays.html" rel="noopener ugc nofollow" target="_blank"> NumPy数组</a>，并逐行迭代，检查交易ID是否每行增加1。</p><p id="459d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">币安交易id是递增编号的，并且是为每个符号创建的，因此很容易验证您的数据是否正确。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="52d3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="f5a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">创建成功交易策略的第一步是拥有正确的数据。</p><p id="3454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的算法交易系列还在进行中，所以我欢迎你在评论区给我任何反馈或建议。你可以在我的GitHub <a class="ae ky" href="https://github.com/tgcandido/binance-data-fetcher" rel="noopener ugc nofollow" target="_blank">库</a>中查看这个小教程的完整代码。</p><p id="de1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读这篇文章。</p><p id="bb81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">如果你有，考虑在</em><a class="ae ky" href="https://twitter.com/ogaihtcandido" rel="noopener ugc nofollow" target="_blank"><em class="lv">Twitter</em></a><em class="lv">上关注我。</em></p><p id="b748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你的时间。保重，继续编码！</p></div></div>    
</body>
</html>