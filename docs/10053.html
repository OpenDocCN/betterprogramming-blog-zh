<html>
<head>
<title>Clean API Call With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React挂钩清除API调用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-api-call-with-react-hooks-3bd6438a375a?source=collection_archive---------0-----------------------#2021-11-19">https://betterprogramming.pub/clean-api-call-with-react-hooks-3bd6438a375a?source=collection_archive---------0-----------------------#2021-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e588" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用简洁、干净和可重用的代码使API调用在整个应用程序中更加一致</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3403fba8e6bd3c11620e7297f9ed8bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xSyep4c_vjXcB16f"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@juanjodev02?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">胡安乔·哈拉米略</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ff04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用API是任何现代web应用程序中最常见的事情。当谈到与API对话时，大多数时候我们需要做许多重复的事情，比如从API调用中获取数据，处理成功或错误的情况，等等。</p><p id="dbe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当调用成百上千个API调用时，我们总是不得不做那些繁琐的任务。我们可以通过对这些准系统API调用进行更高层次的抽象来有效地处理这些事情，而在一些小型应用程序中，有时我们甚至不在乎。</p><p id="8b37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">当我们开始在现有功能的基础上添加新功能，而没有以有效和可重用的方式处理API调用时，问题就来了。在这种情况下，对于所有这些API调用相关的重复，我们最终会在整个应用程序中产生大量重复的代码。</em></p><p id="84da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React中，我们有不同的调用API的方法。现在我们大多使用反应钩。有了React钩子，不管应用程序的规模有多大，都可以在整个应用程序中以一种非常干净和一致的方式处理API调用。因此，让我们看看如何使用React钩子为一个简单的web应用程序创建一个干净的、可重用的API调用层。</p><p id="7aa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为这个博客使用了一个代码沙箱，你可以在这里得到<a class="ae kv" href="https://codesandbox.io/s/clean-api-call-with-react-hooks-8smsr?file=/src/App.js" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从JsonPlaceholder获取帖子数据</p></figure><p id="2724" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道上面的例子不是最好的代码，但至少它是有效的代码。我以后会努力改进的。现在，我们可以只关注调用API的最基本的事情。</p><p id="ef85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您可以尝试从<a class="ae kv" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JsonPlaceholer </a>获取帖子数据。这些是调用API最常见的步骤，比如请求数据、处理加载、成功和错误情况。</p><p id="1c1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们试图从同一个组件调用另一个API，那会是什么样子呢？让我们看看。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从JsonPlaceholder获取帖子和评论数据</p></figure><p id="06a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在它变得疯狂了！为了调用两个简单的API，我们做了大量的重复工作。从顶层来看，组件什么也不做，只是发出两个GET请求，并处理成功和错误情况。对于每个请求，它保持三种状态，如果我们有更多的调用，这三种状态会定期增加。</p><p id="af54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们进行重构，以减少重复，提高代码的可重用性。</p><h1 id="4bcc" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">步骤1:为冗余的API请求代码创建一个挂钩</h1><p id="8f5d" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">到目前为止，我们所做的大部分重复都是关于请求数据、处理异步事务、处理错误、成功和加载状态。把这些东西封装在一个钩子里怎么样？</p><p id="dfa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe ms mt mu mv b">handleComments</code>和<code class="fe ms mt mu mv b">handlePosts</code>中做的唯一独特的事情是调用不同的端点。其余的事情都差不多。所以我们可以创建一个钩子来为我们处理多余的工作，从外部我们会让它知道调用哪个API。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="93d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，这个<code class="fe ms mt mu mv b">request</code>功能与我们在<code class="fe ms mt mu mv b">handlePosts</code>和<code class="fe ms mt mu mv b">handleComments</code>上所做的相同。唯一的区别是，它调用了一个异步函数<code class="fe ms mt mu mv b">apiFunc</code>，我们将把它作为这个钩子的参数提供。这个<code class="fe ms mt mu mv b">apiFunc</code>是我们需要的所有API调用中唯一独立的东西。</p><p id="9245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用钩子，让我们改变我们在<code class="fe ms mt mu mv b">App</code>组件中的旧代码，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用钩子调用帖子和评论API</p></figure><p id="bad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在的代码怎么样？没有任何重复和重复的API调用处理的东西不是很美吗？</p><p id="5872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从当前代码开始继续我们的旅程。我们可以让<code class="fe ms mt mu mv b">App</code>组件更优雅。现在它知道了API调用的底层库的很多细节。它不应该知道这些。所以，这是下一步…</p><h1 id="573f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">步骤2:一个组件应该只承担一项责任</h1><p id="176a" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">我们的App组件太了解API调用机制了。它的职责应该只是请求数据。如何在幕后请求数据，it不应该关心这个。</p><p id="5908" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从<code class="fe ms mt mu mv b">App</code>组件中提取与API客户端相关的代码。此外，我们将根据API资源对所有与API请求相关的代码进行分组。这是我们的API客户端:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">API客户端</p></figure><p id="242f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注释资源的所有API调用将位于以下文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">注释资源的详细信息</p></figure><p id="ca55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">posts资源的所有API调用都放在以下文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">发布资源的详细信息</p></figure><p id="def8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe ms mt mu mv b">App</code>组件如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有两个API调用的应用程序组件</p></figure><p id="baac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在它不知道API是如何被调用的。明天，如果我们想将API调用库从<code class="fe ms mt mu mv b">axios</code>更改为<code class="fe ms mt mu mv b">fetch</code>或其他，我们的<code class="fe ms mt mu mv b">App</code>组件代码不会受到影响。我们可以改变代码形式<code class="fe ms mt mu mv b">client.js</code>这就是抽象的美妙之处。</p><p id="d457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了API调用的抽象之外，<code class="fe ms mt mu mv b">App</code> component不适合显示帖子和评论的列表。它是一个高级组件。它不应该处理这种低级的数据插值的事情。</p><p id="2afb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们应该把这个数据显示相关的东西移到另一个底层组件。在这里，我将它们直接放在应用程序组件中，只是为了演示的目的，而不是为了分散与组件组合相关的事情的注意力。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">clean-API-call-with-react-hooks</p></figure><h1 id="99a0" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">最后的想法</h1><p id="8caa" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">React库提供了基于应用需求使用任何第三方库的灵活性。因为它没有任何预定义的架构，所以不同的团队/开发人员采用不同的方法来开发React应用程序。没有好坏之分。我们根据我们的需求/选择来选择开发实践。有一件事是无法选择的，那就是编写干净且可维护的代码。</p></div></div>    
</body>
</html>