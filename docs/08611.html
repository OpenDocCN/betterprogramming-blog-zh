<html>
<head>
<title>What’s New in Android 12 For Developers?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对于开发者来说，Android 12有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-for-developers-in-android-12-cac901993bc1?source=collection_archive---------2-----------------------#2021-05-20">https://betterprogramming.pub/whats-new-for-developers-in-android-12-cac901993bc1?source=collection_archive---------2-----------------------#2021-05-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1399" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">闪屏API、可定制的小部件、新的权限等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f79425eaceab1c0aee29720b106671e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjXxBn-PbGsonx2uzTcVuw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@thenewmalcolm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Obi Onyeador </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片(作者用Android 12官方logo修改)。</p></figure><p id="3699" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">谷歌I/O 2021活动正在进行中，我们已经发现了Android开发者需要知道的一些最重要的变化。</p><p id="dae0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我们将讨论Android SDK 31发布的新特性和API变化，它目前处于测试阶段。你可以接触到Android Studio北极狐的早期预览版，并体验一下API。</p><p id="0606" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们开始吧。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c633" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">一个新的闪屏API</h1><p id="e8c5" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">过去，Android的闪屏指南相当模糊。大多数开发人员只是为闪屏创建一个布局文件。虽然有更好的方法通过设置自定义主题来组成闪屏，但谷歌现在推出了专用的<a class="ae kz" href="https://developer.android.com/reference/android/window/SplashScreen" rel="noopener ugc nofollow" target="_blank">闪屏API </a>。</p><p id="5684" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">简单地说，您可以通过调用<code class="fe na nb nc nd b">Activity.getSplashScreen()</code>在应用程序中检索闪屏实例。</p><p id="2770" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">新的API在所有应用程序中使用徽标和启动动画来标准化启动屏幕。当然，您仍然可以通过使用样式属性来自定义屏幕:</p><ul class=""><li id="fd21" class="ne nf iu lc b ld le lg lh lj ng ln nh lr ni lv nj nk nl nm bi translated"><code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/R.attr#windowSplashScreenBackground" rel="noopener ugc nofollow" target="_blank">windowSplashScreenBackground</a></code>用于填充屏幕的背景。</li><li id="ea09" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated"><code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/R.attr#windowSplashScreenAnimatedIcon" rel="noopener ugc nofollow" target="_blank">windowSplashScreenAnimatableIcon</a></code>用于将闪屏上显示的应用标志替换为另一个动画drawable。</li><li id="e7b6" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated"><code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/R.attr#windowSplashScreenAnimationDuration" rel="noopener ugc nofollow" target="_blank">windowSplashScreenAnimationDuration</a></code>用于设置闪屏消失前的超时时间。</li></ul><p id="4913" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您还可以通过调用闪屏实例上的<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/window/SplashScreen#setOnExitAnimationListener(android.window.SplashScreen.OnExitAnimationListener)" rel="noopener ugc nofollow" target="_blank">setOnExitAnimationListener</a></code>来自定义闪屏的过渡或消失。</p><p id="fd70" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">总是调用<code class="fe na nb nc nd b">splashScreenView.remove()</code>来结束Android 12中自定义的闪屏动画。</p><p id="48be" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有关更多详细信息，请查看<a class="ae kz" href="https://developer.android.com/about/versions/12/features/splash-screen" rel="noopener ugc nofollow" target="_blank">闪屏API文档</a>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="bb12" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">改进的Widgets API</h1><p id="dbf7" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">十年来，微件一直是Android生态系统的核心部分。可悲的是，谷歌直到iOS 14的可定制widgets才认真对待他们的Widgets API。</p><p id="54f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Android 12中，小部件有很多变化。让我们一次看一个。</p><h2 id="8655" class="ns me iu bd mf nt nu dn mj nv nw dp mn lj nx ny mp ln nz oa mr lr ob oc mt od bi translated">圆角</h2><p id="2aa5" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">小部件将包含在圆角中，您可以使用<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/R.dimen#system_app_widget_background_radius" rel="noopener ugc nofollow" target="_blank">system_app_widget_background_radius</a></code>维度属性来查找。</p><p id="857e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样值得注意的是，小部件中的子视图将有一个单独的圆角半径:<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/R.dimen#system_app_widget_inner_radius" rel="noopener ugc nofollow" target="_blank">system_app_widget_inner_radius</a></code>。因此，需要确保小部件视图背景/布局是可裁剪的。</p><h2 id="0dfd" class="ns me iu bd mf nt nu dn mj nv nw dp mn lj nx ny mp ln nz oa mr lr ob oc mt od bi translated">颜色；色彩；色调</h2><p id="d054" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Android 12引入了新的“Material You”设计，带来了与背景形成对比的动态字体颜色。</p><p id="193d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，为小部件使用<code class="fe na nb nc nd b">Theme.DeviceDefault.DayNight</code>风格是理想的，这样小部件UI组件就可以根据设备主题进行调整。</p><p id="375f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，当用户点击一个小部件来启动应用程序时，过渡并不平滑(主要是由于应用程序背景和小部件背景的颜色不同)。Android 12通过加入一个新的属性对此进行了改进。</p><p id="d467" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过将<code class="fe na nb nc nd b">@android:id/background</code>设置为widget视图中根布局的ID，您让应用程序知道在过渡期间应用程序launch open使用了widget背景。</p><h2 id="7bd6" class="ns me iu bd mf nt nu dn mj nv nw dp mn lj nx ny mp ln nz oa mr lr ob oc mt od bi translated">通过样式个性化部件</h2><p id="e9f9" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">之前，您可以设置一个配置属性(<code class="fe na nb nc nd b">&lt;appwidget-provider&gt;</code>)来将小部件重定向到所需的活动。你也可以使用<code class="fe na nb nc nd b">android:widgetFeatures="reconfigurable"</code>长按并重新配置你的Android <code class="fe na nb nc nd b">Activity</code>上的一个小部件。</p><p id="c444" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，Android 12中的<code class="fe na nb nc nd b">android:widgetFeatures</code>又有了一个标志，可以提供更多的定制。<code class="fe na nb nc nd b">configuration_optional</code>可用于绕过从您的应用程序配置小工具。</p><p id="3a9c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您还可以使用以下属性设置在选取器中显示的widget模板预览:</p><pre class="kk kl km kn gu oe nd of og aw oh bi"><span id="edb9" class="ns me iu nd b gz oi oj l ok ol">&lt;appwidget-provider<br/>  ...<br/>  android:previewLayout="@layout/my_widget_preview"<br/>  android:description="@string/my_widget_description"&gt;<br/>&lt;/appwidget-provider&gt;</span></pre><h2 id="a058" class="ns me iu bd mf nt nu dn mj nv nw dp mn lj nx ny mp ln nz oa mr lr ob oc mt od bi translated">远程视图</h2><p id="2869" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">由于小部件驻留在应用程序外的启动屏幕上，<code class="fe na nb nc nd b">RemoteViews</code>用于实现它们。<code class="fe na nb nc nd b">RemoteView</code>接口负责向小部件添加UI元素，并监听用户交互。</p><p id="4b74" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Android 12中，<code class="fe na nb nc nd b">RemoteView</code>现在包括了一个<code class="fe na nb nc nd b">setRemoteAdapter</code>方法，你可以传递布局并插入一组项目——类似于我们在<code class="fe na nb nc nd b">ListViews</code>中所做的。</p><h2 id="3587" class="ns me iu bd mf nt nu dn mj nv nw dp mn lj nx ny mp ln nz oa mr lr ob oc mt od bi translated">布局属性</h2><p id="37eb" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Widgets API带来了更多的属性，有助于确定Android 12中Widgets的大小:</p><ul class=""><li id="8ff6" class="ne nf iu lc b ld le lg lh lj ng ln nh lr ni lv nj nk nl nm bi translated"><code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/appwidget/AppWidgetProviderInfo#targetCellWidth" rel="noopener ugc nofollow" target="_blank">targetCellWidth</a></code>和<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/appwidget/AppWidgetProviderInfo#targetCellHeight" rel="noopener ugc nofollow" target="_blank">targetCellHeight</a></code>定义了启动器网格中小部件主机的精确宽度和高度。</li><li id="bbfc" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated"><code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/appwidget/AppWidgetProviderInfo#maxResizeWidth" rel="noopener ugc nofollow" target="_blank">maxResizeWidth</a></code>和<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/appwidget/AppWidgetProviderInfo#maxResizeWidth" rel="noopener ugc nofollow" target="_blank">maxResizeHeight</a></code>定义了允许调整大小时小工具的最大尺寸。</li></ul><p id="e2f4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以为您的<code class="fe na nb nc nd b">RemoteViews</code>中的小部件定义多达三种不同的大小布局。</p><p id="b044" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Android 12中另一个有趣的小部件更新是通过语音命令调用它们的能力。为此，我们只需在<code class="fe na nb nc nd b">capability</code>下添加一个<code class="fe na nb nc nd b">app-widget</code>标签，并在<code class="fe na nb nc nd b">shortcuts.xml</code>文件中定义<code class="fe na nb nc nd b">WidgetProvider</code>的小部件标识符和目标类。您还可以使用新提供的<code class="fe na nb nc nd b">setResponseSpeech</code>和<code class="fe na nb nc nd b">setResponseText</code>方法在您的小部件中添加文本到语音转换功能。</p><p id="7084" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要深入了解Android 12中的小部件，请查看官方资源库<a class="ae kz" href="https://github.com/android/user-interface-samples/tree/main/AppWidget" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="ae21" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">新的Android 12权限:位置、蓝牙和剪贴板</h1><p id="beb0" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">随着用户越来越意识到数据隐私，Android 12使用户隐私成为其设计系统中更不可或缺的一部分。Android 12权限模型中有一些新的变化，你可能想知道。</p><p id="1d08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，位置许可对话框现在允许用户在近似位置和精确位置之间进行选择。大概的位置由<code class="fe na nb nc nd b">ACCESS_COARSE_LOCATION</code>权限访问，如果你不需要精确的位置，你应该避免询问<code class="fe na nb nc nd b">ACCESS_FINE_LOCATION</code>。</p><p id="bd19" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">任何应用程序都可以访问剪贴板，这对许多人来说是一个隐私噩梦。展望未来，Android 12将在每次外部应用程序从剪贴板读取数据时显示一段祝酒词。为了避免过多的弹出消息，您可以在使用<code class="fe na nb nc nd b">ClipboardManager.getPrimaryClipDescription()</code>访问数据之前先检查数据的种类。这个方法不显示吐司。</p><p id="aa18" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">说到祝酒词，他们现在可以显示一个应用程序图标，但更重要的是，Android 12进一步限制了小时间范围内可以显示的祝酒词数量。</p><p id="7152" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">直到最近，扫描附近设备的蓝牙也需要位置访问。但随着Android 12的推出，这一切都将改变。两个新的权限<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/Manifest.permission#BLUETOOTH_SCAN" rel="noopener ugc nofollow" target="_blank">BLUETOOTH_SCAN</a></code>和<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/Manifest.permission#BLUETOOTH_CONNECT" rel="noopener ugc nofollow" target="_blank">BLUETOOTH_CONNECT</a></code>，分别用于扫描和连接已经配对的设备。您可以通过以下方式明确声明您的应用程序从不需要附近设备的物理位置:</p><pre class="kk kl km kn gu oe nd of og aw oh bi"><span id="1ea4" class="ns me iu nd b gz oi oj l ok ol">&lt;uses-permission android:name="android.permission.BLUETOOTH_SCAN"<br/>                 android:usesPermissionFlags="neverForLocation" /&gt;</span></pre><p id="4c8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Android 12还带来了新的自动休眠功能。这是对Android 11中引入的自动重置权限的增强。简而言之，系统会在一段时间(通常为30天)后自动重置未使用应用的权限。</p><p id="8399" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">作为开发人员，如果应用程序需要在后台定期轮询，您可能需要禁用自动重置行为。为此，调用<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/provider/Settings#ACTION_APPLICATION_DETAILS_SETTINGS" rel="noopener ugc nofollow" target="_blank">Intent.ACTION_APPLICATION_DETAILS_SETTINGS</a></code>意图，将用户带到设置屏幕手动撤销自动复位行为。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8e1e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">通知API的增强</h1><p id="be33" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果通知设计系统没有重大改变，Android更新就不会结束。那些使用<code class="fe na nb nc nd b">RemoteViews</code>设计定制通知的人将再次经历一段艰难的时间，因为Android 12将不再能够使用完整的通知。相反，它们将被包装在一个标准的通知样式的模板中。</p><p id="5ace" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">API还有一些值得一提的变化:</p><ul class=""><li id="2798" class="ne nf iu lc b ld le lg lh lj ng ln nh lr ni lv nj nk nl nm bi translated"><code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/app/Notification.CallStyle" rel="noopener ugc nofollow" target="_blank">Notification.CallStyle</a></code>是一个专门的电话模板。</li><li id="660e" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated"><code class="fe na nb nc nd b">MessagingStyle</code>和<code class="fe na nb nc nd b">BigPictureStyle</code>通知获得了一些新的定制方法(比如<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/app/Notification.BigPictureStyle#bigPicture(android.graphics.drawable.Icon)" rel="noopener ugc nofollow" target="_blank">bigPicture</a>(<a class="ae kz" href="https://developer.android.com/reference/android/graphics/drawable/Icon" rel="noopener ugc nofollow" target="_blank">Icon</a> icon)</code>)。您现在可以在通知中显示动画图像/gif，还可以调用<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/app/Notification.BigPictureStyle#showBigPictureWhenCollapsed(boolean)" rel="noopener ugc nofollow" target="_blank">showBigPictureWhenCollapsed</a></code>方法来优先显示大图片，而不是大的应用程序图标。</li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4d39" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">机器学习和增强现实:ML Kit和ARCore</h1><p id="685d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">设备上的机器学习已经成为当务之急，谷歌进一步增强了他们已经流行的<a class="ae kz" href="https://developers.google.com/ml-kit" rel="noopener ugc nofollow" target="_blank"> ML Kit </a>框架。框架中添加了一些强大的API，使移动设备上的机器学习变得更加容易:</p><ul class=""><li id="c85a" class="ne nf iu lc b ld le lg lh lj ng ln nh lr ni lv nj nk nl nm bi translated">数字墨迹识别:跨多种语言检测手写文本。</li><li id="40d3" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">实体提取:智能检测原始文本类型，并做出所需的行动。例如，如果你从文本中选择一个地址，它会显示一个带有地图选项的弹出窗口。</li><li id="57d3" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">自拍分割:将前景与背景分开。</li><li id="5f9a" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">姿态检测:实时检测和跟踪人体部位(32点)。</li></ul><p id="da8f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，ARCore也给了我们一些强大的API。原始深度API允许您更详细地分析场景几何，而新的深度命中测试API允许您立即将虚拟对象放置在场景中，而无需搜索平面或最佳照明。</p><p id="6017" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">谷歌还发布了一个录制和播放API，让你可以将ARCore对象添加到常规视频中。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="900f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">前台服务限制</h1><p id="5676" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Android已经从后台限制了打开活动，而有了最新的API level 31，你就再也不能从后台启动大部分前台服务了。</p><p id="f40d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在一些必须的场景中，最好使用<a class="ae kz" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank">工作管理器</a> API并调用<code class="fe na nb nc nd b">setExpedited()</code>来优先运行前台服务。</p><p id="2c5c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于报警管理员来说，为了发送准确的报警，声明<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/reference/android/Manifest.permission#SCHEDULE_EXACT_ALARM" rel="noopener ugc nofollow" target="_blank">SCHEDULE_EXACT_ALARM</a></code>权限是至关重要的。</p><p id="cd78" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">更多详情，请查看<a class="ae kz" href="https://developer.android.com/about/versions/12/foreground-services" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7a7a" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">减少样板代码的新内容API</h1><p id="94e7" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">对于拖放、复制粘贴和键盘贴纸，我们以前有三种不同的界面方法:</p><pre class="kk kl km kn gu oe nd of og aw oh bi"><span id="ccdb" class="ns me iu nd b gz oi oj l ok ol">setOnDragListener.    //drag-drop<br/>onTextContextMenuItem //copy-paste<br/>OnCommitContentListener //keyboard sticker</span></pre><p id="f14c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Android 12将它们合二为一，从而增强了可重用性:</p><pre class="kk kl km kn gu oe nd of og aw oh bi"><span id="d3ba" class="ns me iu nd b gz oi oj l ok ol">setOnReceiveContentListener(mimeTypes)</span></pre><ul class=""><li id="0d72" class="ne nf iu lc b ld le lg lh lj ng ln nh lr ni lv nj nk nl nm bi translated">为了模糊图像或视图，我们现在有一种<code class="fe na nb nc nd b">setRenderEffect</code>方法，通过使用硬件加速来加速操作，使其几乎实时工作。</li><li id="9971" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">为了设计适应平板电脑和可折叠屏幕的应用程序布局，两个UI组件得到了更新:<code class="fe na nb nc nd b"><a class="ae kz" href="https://developer.android.com/jetpack/androidx/releases/slidingpanelayout" rel="noopener ugc nofollow" target="_blank">SlidingPaneLayout</a></code>让您可以在多个窗格上设计布局。另一方面，<code class="fe na nb nc nd b"><a class="ae kz" href="https://material.io/components/navigation-rail" rel="noopener ugc nofollow" target="_blank">NavRail</a></code>可以方便地设置底部菜单式的侧边栏。</li><li id="9e7d" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated"><a class="ae kz" href="https://developer.android.com/about/versions/12/features/pip-improvements" rel="noopener ugc nofollow" target="_blank">画中画</a> (PiP)模式也有API增强，引入了标志以实现更平滑的过渡、禁用调整大小等等。</li><li id="f823" class="ne nf iu lc b ld nn lg no lj np ln nq lr nr lv nj nk nl nm bi translated">Android 12还引入了一种叫做AVIF的新图像格式。据说同样大小的质量更好。这也意味着我们现在需要在清单文件中明确提到我们的应用程序支持的文件格式(如果AVIF不可用，Android将自动切换到最受支持的格式)。</li></ul><p id="be6a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后但同样重要的是，Jetpack Compose，被视为Android开发未来的现代声明式UI工具包，现在有了一个成熟的智能编辑器来进行实时预览。该库的1.0版本将于7月份推出。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8c86" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="b0a3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">虽然这几乎是你作为开发者需要了解的关于Android 12的一切，但还有很多更微妙的功能。跳转到<a class="ae kz" href="https://events.google.com/io/program/discover/?lng=en" rel="noopener ugc nofollow" target="_blank">谷歌IO </a>网站或<a class="ae kz" href="https://developer.android.com/about/versions/12" rel="noopener ugc nofollow" target="_blank">安卓文档</a>获取更多信息。</p><p id="ac68" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你会发现这份清单对于在更新发布之前发布应用程序很有用。</p><p id="6925" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读。</p></div></div>    
</body>
</html>