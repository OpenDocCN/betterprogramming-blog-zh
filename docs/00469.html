<html>
<head>
<title>RxSwift and Production-Level Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxSwift和生产级代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxswift-github-search-done-right-d57aa042f97f?source=collection_archive---------2-----------------------#2019-05-27">https://betterprogramming.pub/rxswift-github-search-done-right-d57aa042f97f?source=collection_archive---------2-----------------------#2019-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/733fd9106ac6d1611c08591c868aad56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BOq5h6hdbJZ9zB7lLjIseA.png"/></div></div></figure><div class=""/><div class=""><h2 id="615c" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">加上其他一些我希望在我开始使用RxSwift时有人告诉我的事情</h2></div><p id="c6d9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">访问GitHub 上的<a class="ae lp" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift知识库，你会发现RxSwift威力的一个经典例子:GitHub搜索。</a></p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/4009220d42b3e14066795038e0682049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F48pg2RuL6JFHX0ve4bCaQ.png"/></div></div></figure><p id="8dd8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在短短18行代码中，您实现了一个完整的用户界面，将一些搜索栏文本绑定到一个数据查询，然后将数据查询的结果直接绑定到一个表格视图。确实是很强大的东西。</p><p id="bfeb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是，正如在早先的一篇文章<a class="ae lp" href="https://medium.com/@michaellong/rxswift-the-complexity-tradeoff-61cf49e996f0" rel="noopener"> RxSwift:复杂性权衡</a>中提到的，为了简洁和清晰起见，这种样本代码进行了一些明显的权衡，并且还远远没有准备好投入生产。</p><h2 id="c505" class="lv lw je bd lx ly lz dn ma mb mc dp md lc me mf mg lg mh mi mj lk mk ml mm mn bi translated">什么是生产级代码？</h2><p id="a7e2" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">首先，没有真正的错误处理代码。任何API错误都会被忽略，留给用户的是一个空的搜索屏幕。这远非理想。</p><p id="c921" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们当然希望向用户表明搜索正在进行中。</p><p id="b402" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">说到搜索，添加一个搜索缓存会很好。我们已经看到了结果，为什么还要再次使用API呢？</p><p id="5739" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，所显示的搜索代码似乎是直接嵌入到视图控制器中的。这并不好——这种类型的逻辑应该出现在视图模型中(至少对MVVM来说是这样)。)</p><p id="177e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">话说回来，支持所有这些东西会增加代码的复杂性，使其更难理解，并减少使用RxSwift的许多优势…不是吗？</p><p id="0279" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们找出答案。</p><p id="b67b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这个过程中，我将展示一些RxSwift最佳实践、技巧和设计模式——我希望在我开始使用RxSwift时有人告诉过我这些事情。</p><h1 id="e9d4" class="mu lw je bd lx mv mw mx ma my mz na md kk nb kl mg kn nc ko mj kq nd kr mm ne bi translated">GitHub搜索视图模型</h1><p id="eb4a" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">让我们首先创建一个实现我们的搜索逻辑的视图模型。</p><p id="49d6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">按照我们修改后的要求，它接受一个搜索字符串，然后显示我们的搜索结果(或者一条错误消息，如果出现错误的话)。</p><p id="2c4e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">看起来是这样的:</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="2793" class="lv lw je ng b gy nk nl l nm nn">class GitHubSearchViewModel {<br/>    public var data: Observable&lt;[Repository]&gt;!<br/>    public var error: Observable&lt;String?&gt;!<br/>    internal var searchService = GithubSearchService()<br/>    public func configure(search: Observable&lt;String&gt;) {<br/>        ...<br/>    }<br/>}</span></pre><p id="b1d2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请注意，我们的数据和错误是作为简单的可观察对象而不是主体暴露出来的。这确保了只有我们的视图模型控制我们的视图控制器可能看到的任何事件。</p><p id="0bd7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此外，我们唯一的输入来自作为可观察参数传递给configure函数的搜索文本。这简化了代码和调试——我们现在知道只有一个地方事件会影响我们的视图模型。</p><p id="4837" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">例如，任何人都可以在任何时候调用一个独立且独特的<code class="fe no np nq ng b">load()</code>函数，这增加了出现意外结果的可能性。</p><p id="6611" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，我们还为GithubSearchService添加了一个变量，与原始示例中的searchGitHub(query)函数一样，它将处理我们实际的URLSession数据任务请求。这是一个盲函数，所以我们也这样对待它。</p><p id="8cb0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">总而言之，定义一个基本的视图模型只需要添加7行代码。</p><h2 id="7fc5" class="lv lw je bd lx ly lz dn ma mb mc dp md lc me mf mg lg mh mi mj lk mk ml mm mn bi translated">我们的配置功能</h2><p id="f793" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">配置函数是最神奇的地方，所以让我们来实现它。</p><p id="9e9f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">它包含了大部分的原始示例代码，以及一些改进错误处理的代码。</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="926c" class="lv lw je ng b gy nk nl l nm nn">    public func configure(search: Observable&lt;String&gt;) {<br/>        let result = search<br/>            .flatMapLatest { [unowned self] text -&gt; Observable&lt;Event&lt;[Repository]&gt;&gt; in<br/>                if text.isEmpty {<br/>                    return .just(.next([]))<br/>                }<br/>                return self.searchService.search(text)<br/>                    .materialize()<br/>            }<br/>            .observeOn(MainScheduler.instance)<br/>            .share()<br/>    data = result<br/>            .map { $0.element ?? [] }<br/>    error = result<br/>            .map { $0.error?.localizedDescription }<br/>            .share()<br/>    }</span></pre><h1 id="74a1" class="mu lw je bd lx mv mw mx ma my mz na md kk nb kl mg kn nc ko mj kq nd kr mm ne bi translated">错误处理</h1><p id="fa30" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">如果你做过很多RxSwift，或者你读过<a class="ae lp" href="https://medium.com/@michaellong/rxswift-better-error-handling-with-compactmap-48a5d314d0f1" rel="noopener"> RxSwift:用CompactMap </a>更好地处理错误，上面的模式就很清楚了。</p><p id="523d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将异步搜索调用封装在一个<code class="fe no np nq ng b">flatMapLatest</code>函数中，并将该函数的结果分成两个流——一个用于我们的数据，一个用于我们的错误。</p><p id="9996" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们的平面图的结果是一个<code class="fe no np nq ng b"><em class="mt">Observable&lt;Event&lt;[Repository]&gt;&gt;</em></code> <em class="mt">。我们将使用RxSwift的<code class="fe no np nq ng b">materialize</code>功能将我们的数据和任何潜在的错误转化为一系列事件。这个函数代替了原始代码中简单的<code class="fe no np nq ng b">.catchErrorJustReturn([])</code>行。</em></p><p id="77b3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果搜索操作成功，我们的结果是类型<code class="fe no np nq ng b">Event.next&lt;[String]&gt;</code> <em class="mt">。</em>如果出现错误，则为<code class="fe no np nq ng b">Event.error(Swift.Error)</code> <em class="mt">。</em>在这两种情况下，我们都保护了我们的可观察流，防止任何错误逃离平面图并终止我们的事件流。(如果这还不清楚，CompactMap文章使用<code class="fe no np nq ng b">materialize</code>对此进行了更详细的解释。)</p><p id="ad31" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">继续，对数据的赋值使用事件的<em class="mt">元素</em>变量从事件中提取可选数据。如果没有，我们返回一个空数组。</p><p id="916b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">类似地，error的赋值提取错误(如果有的话)。如果没有错误发生，可选的unwrap将为零，我们将传递它，这样任何以前的错误将被自动清除。</p><p id="3a79" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">错误结果也是<code class="fe no np nq ng b">shared()</code>，因为我们将在视图控制器中多次使用错误的输出。不必要的话，执行这些代码是没有意义的。</p><p id="8581" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">净结果:可观察值和五个数据/误差分割值。</p><h2 id="dc75" class="lv lw je bd lx ly lz dn ma mb mc dp md lc me mf mg lg mh mi mj lk mk ml mm mn bi translated">活动指示器</h2><p id="71e6" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">正如我们的需求中提到的，我们希望向用户表明搜索正在进行中。如果您认为这意味着我们需要另一个可观察对象来显示我们正在处理一个请求，那么您就错了！</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="c45c" class="lv lw je ng b gy nk nl l nm nn">public var processing: Observable&lt;Bool&gt;!</span></pre><p id="df0b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了支持它，我们只需要在配置函数的末尾添加两行代码。</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="977a" class="lv lw je ng b gy nk nl l nm nn">processing = Observable&lt;Bool&gt;<br/>    .merge( search.map { _ in true }, data.map { _ in false } )</span></pre><p id="c2b2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里，我们将原始的搜索事件映射到<em class="mt"> true </em>，并使用它来触发我们的微调器。当我们在<em class="mt">结果</em>上看到一个事件，空或其他，我们将它映射到<em class="mt"> false </em>并使用它来停止我们的旋转器旋转。</p><p id="c31e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这两个事件被合并，并通过我们的单个暴露的<code class="fe no np nq ng b">processing</code>标志发送出去。你会看到习语在RxSwift代码中使用了相当多的多重映射、合并事件。</p><p id="3e38" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">又加了三行。</p><h2 id="d77d" class="lv lw je bd lx ly lz dn ma mb mc dp md lc me mf mg lg mh mi mj lk mk ml mm mn bi translated">贮藏</h2><p id="beeb" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">我们想从修订后的需求列表中添加的最后一件事是某种形式的搜索结果缓存，所以我们不经常使用我们的API。</p><p id="3795" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">缓存需要一个缓存，所以让我们添加一个。我们将使用一个简单的字典，将搜索关键字作为查找值:</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="fa4f" class="lv lw je ng b gy nk nl l nm nn">internal var searchCache = [String:[Repository]]()</span></pre><p id="72ef" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将在我们的<code class="fe no np nq ng b">flatMapLatest</code>闭包内处理实现:</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="944a" class="lv lw je ng b gy nk nl l nm nn">.flatMapLatest { [unowned self] text -&gt; Observable&lt;Event&lt;[Repository]&gt;&gt; in<br/>    if text.isEmpty {<br/>        return .just(.next([]))<br/>    }<br/>    // check cache...<br/>    let key = text.lowercased()<br/>    if let cachedResult = self.searchCache[key] {<br/>        return .just(.next(cachedResult))<br/>    }<br/>    return self.searchService.search(text)<br/>        // cache results<br/>        .do(onNext: { (results) in<br/>            self.searchCache[key] = results<br/>        })<br/>        .materialize()<br/>}</span></pre><p id="5b91" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">够直接了。如果我们的缓存包含来自原始搜索关键字的结果，我们只需在尝试API调用之前<em class="mt">返回它们。</em></p><p id="20f8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果没有，我们进行搜索并添加一个<code class="fe no np nq ng b">do(onNext: { … ))</code> <em class="mt"> </em>处理程序来捕获结果并将其添加到我们的缓存中。如果API调用出错，do函数将被绕过。</p><p id="8ee8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您需要更健壮的缓存机制，您可以自由添加。只需将您的缓存请求和缓存插入函数调用插入到我们刚刚添加的代码中。</p><p id="cebb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">就这样，只剩下八行代码，这是我们的一个新特性所需要的最多的代码。</p><h2 id="4469" class="lv lw je bd lx ly lz dn ma mb mc dp md lc me mf mg lg mh mi mj lk mk ml mm mn bi translated">视图模型最终结果</h2><p id="3d34" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">如果您一直在跟踪，我们完成的视图模型应该是这样的:</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="ca45" class="lv lw je ng b gy nk nl l nm nn">class CachingGitHubSearchViewModel {<br/>    public var data: Observable&lt;[Repository]&gt;!<br/>    public var error: Observable&lt;String?&gt;!<br/>    public var processing: Observable&lt;Bool&gt;!<br/>    internal var searchService = GithubSearchService()<br/>    internal var searchCache = [String:[Repository]]()<br/>    public func configure(search: Observable&lt;String&gt;) {<br/>        let result = search<br/>            .flatMapLatest { [unowned self] text -&gt; Observable&lt;Event&lt;[Repository]&gt;&gt; in<br/>                if text.isEmpty {<br/>                    return .just(.next([]))<br/>                }<br/>                let key = text.lowercased()<br/>                if let cachedResult = self.searchCache[key] {<br/>                    return .just(.next(cachedResult))<br/>                }<br/>                return self.searchService.search(text)<br/>                    .do(onNext: { (results) in<br/>                        self.searchCache[key] = results<br/>                    })<br/>                    .materialize()<br/>            }<br/>            .observeOn(MainScheduler.instance)<br/>            .share()<br/>    data = result<br/>            .map { $0.element ?? [] }<br/>    error = result<br/>            .map { $0.error?.localizedDescription }<br/>            .share()<br/>    processing = Observable&lt;Bool&gt;<br/>            .merge( <br/>               search.map { _ in true }, <br/>               data.map { _ in false } <br/>            )<br/>    }<br/>}</span></pre><p id="f4b8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">花点时间也注意一下我们的可观察对象是如何停留在流中的，从原始事件通过我们的处理代码直接进入我们的输出流。</p><p id="7b3b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这绝对是RxSwift的最佳实践。</p><h2 id="54e6" class="lv lw je bd lx ly lz dn ma mb mc dp md lc me mf mg lg mh mi mj lk mk ml mm mn bi translated">更多代码？</h2><p id="6906" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">比原来的代码多？当然了。事实上，几乎是两倍。但是我们添加了更好的错误处理、处理标志，同时实现了API缓存。</p><p id="cd90" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我也没有提到，添加的代码中大约有四分之一是需要将原始代码移动到视图模型中的——无论使用什么方法都是一种浪费。</p><h1 id="bd51" class="mu lw je bd lx mv mw mx ma my mz na md kk nb kl mg kn nc ko mj kq nd kr mm ne bi translated">GitHub搜索视图控制器</h1><p id="c242" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">因为我们将大部分业务逻辑移到了视图模型中，所以我们的视图控制器应该相当简单。</p><p id="08f5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">的确如此。让我们看看外壳:</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="9d2f" class="lv lw je ng b gy nk nl l nm nn">class GiHubSearchViewController: UIViewController {<br/>    var viewModel = GitHubSearchViewModel()<br/>    var disposeBag = DisposeBag()<br/>    @IBOutlet var searchBar: UISearchBar!<br/>    @IBOutlet var tableView: UITableView!<br/>    @IBOutlet var activityIndicator: UIActivityIndicatorView!<br/>    @IBOutlet var errorLabel: UILabel!<br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        configureViewModel()<br/>        setupObservables()<br/>    }<br/>   func configureViewModel() {<br/>        ...<br/>    }<br/>    func setupObservables() {<br/>        ...<br/>    }<br/>}</span></pre><p id="e9c0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们有了自己的视图模型，并实例化了一个RxSwift <code class="fe no np nq ng b">DisposeBag</code>。我们还有搜索栏、结果表视图、错误消息标签和活动指示器的出口。</p><p id="0412" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="mt"> </em> <code class="fe no np nq ng b">viewDidLoad()</code>函数调用super，然后调用两个函数，一个用于配置视图模型，另一个用于绑定我们的观察对象。</p><p id="f370" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请注意，无论是RxSwift还是其他，任何所需功能的实现都需要类定义、视图模型定义和出口。</p><h2 id="3080" class="lv lw je bd lx ly lz dn ma mb mc dp md lc me mf mg lg mh mi mj lk mk ml mm mn bi translated">configureViewModel()</h2><p id="92e6" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">让我们从定义配置函数开始:</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="c926" class="lv lw je ng b gy nk nl l nm nn">func configureViewModel() {<br/>    let searchObservable = searchBar.rx.text<br/>        .orEmpty<br/>        .throttle(.milliseconds(500), scheduler: MainScheduler.instance)<br/>        .distinctUntilChanged()<br/>    viewModel.configure(search: searchObservable)<br/>}</span></pre><p id="13a7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们制作了一个可观察的搜索栏文本，并使用<code class="fe no np nq ng b">orEmpty</code>使其成为一个值为零的字符串。<code class="fe no np nq ng b">throttle</code>函数在发送事件之前等待半秒钟，有效地延迟了搜索，直到用户停止输入。</p><p id="5dbe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后<code class="fe no np nq ng b">distinctUntilChanged()</code>确保最终值实际上不同于之前的值，然后我们再用它来干扰我们的视图模型。</p><p id="a79e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后，我们将可观察的文本传递给视图模型。菲尼。</p><h2 id="9c63" class="lv lw je bd lx ly lz dn ma mb mc dp md lc me mf mg lg mh mi mj lk mk ml mm mn bi translated">setupObservables()</h2><p id="e840" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">这是问题的核心。这个地方把我们所有的可观察事物和我们的各种观点联系在一起——这个地方给我们的表视图提供信息。一定很复杂，对吧？</p><p id="e762" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你是法官:</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="46b1" class="lv lw je ng b gy nk nl l nm nn">func setupObservables() {<br/>    disposeBag.insert(<br/>        viewModel.data<br/>            .bind(to: tableView.rx.items(cellIdentifier: "Cell")) { index, repository, cell in<br/>                cell.textLabel?.text = repository.name<br/>                cell.detailTextLabel?.text = repository.url<br/>        },<br/>        viewModel.error<br/>            .bind(to: errorLabel.rx.text),<br/>        viewModel.error<br/>            .map { $0 == nil }<br/>            .bind(to: errorLabel.rx.isHidden),<br/>        viewModel.processing<br/>            .bind(to: activityIndicator.rx.isAnimating)<br/>    )<br/>}</span></pre><p id="8b42" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将存储库数据绑定到表视图，配置单元格。</p><p id="514d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将错误消息绑定到错误标签，并将相同的值映射到<em class="mt"> isHidden </em>标志，因此错误标签可以适当地显示和隐藏。</p><p id="2856" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将处理标志绑定到我们的spinner。</p><p id="f1b9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">注意这里我们使用了<a class="ae lp" href="https://medium.com/@michaellong/rxswifty-and-his-variadic-disposebag-1682ecceaf41" rel="noopener">变量disposeBag插入方法</a>来清理代码。</p><p id="e3cd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后…就这样。没有tableView委托。没有tableView numberOfRows或cellForRowAtIndexPath函数。</p><p id="04c7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们最终的视图控制器源代码如下:</p><pre class="lr ls lt lu gt nf ng nh ni aw nj bi"><span id="c40c" class="lv lw je ng b gy nk nl l nm nn">class GiHubSearchViewController: UIViewController {<br/>    var viewModel = CachingGitHubSearchViewModel()<br/>    var disposeBag = DisposeBag()<br/>    @IBOutlet var searchBar: UISearchBar!<br/>    @IBOutlet var tableView: UITableView!<br/>    @IBOutlet var activityIndicator: UIActivityIndicatorView!<br/>    @IBOutlet var errorLabel: UILabel!<br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        setupObservables()<br/>    }<br/>   func configureViewModel() {<br/>        let searchObservable = searchBar.rx.text<br/>            .orEmpty<br/>            .throttle(.milliseconds(500), scheduler: MainScheduler.instance)<br/>            .distinctUntilChanged()<br/>        viewModel.configure(search: searchObservable)<br/>    }<br/>    func setupObservables() {<br/>        disposeBag.insert(<br/>            viewModel.data<br/>                .bind(to: tableView.rx.items(cellIdentifier: "Cell")) { index, repository, cell in<br/>                    cell.textLabel?.text = repository.name<br/>                    cell.detailTextLabel?.text = repository.url<br/>            },<br/>            viewModel.error<br/>                .bind(to: errorLabel.rx.text),<br/>            viewModel.error<br/>                .map { $0 == nil }<br/>                .bind(to: errorLabel.rx.isHidden),<br/>            viewModel.processing<br/>                .bind(to: activityIndicator.rx.isAnimating)<br/>        )<br/>    }<br/>}</span></pre><h1 id="efd9" class="mu lw je bd lx mv mw mx ma my mz na md kk nb kl mg kn nc ko mj kq nd kr mm ne bi translated">完成处理程序</h1><p id="76aa" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">因此，我们采用了经典的RxSwift GitHub搜索演示代码，并将其转换为现代的MVVM生产就绪代码。</p><p id="7300" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">是的，代码有点长，但是它做得更多，启动起来更健壮。</p><p id="0c35" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我想再次强调，较长代码的很大一部分是样板类定义和UIView输出——无论您选择什么实现方法，RxSwift或其他，这些都是非常必要的。</p><p id="fdb1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">还展示了一些常见的RxSwift最佳实践，包括“流内”输入/输出可观察流、临时范围可观察流的使用，以及用于将输入流拆分为多个输出流的一些技术。</p><p id="6415" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此外，我们还研究了这个过程中涉及的一些思维过程。</p><p id="885f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">和往常一样，如果你有问题，请在下面的评论区留言，我会尽力回答。如果你想看更多这些“跟随代码”的文章，也请告诉我，或者如果你忙的话，请给我一个大拇指。</p><p id="5a3d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">直到下次。</p></div></div>    
</body>
</html>