<html>
<head>
<title>A Fundamental Guide To React Suspense</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应对悬念的基本指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-fundamental-guide-to-react-suspense-397fdb06b49c?source=collection_archive---------13-----------------------#2022-02-28">https://betterprogramming.pub/a-fundamental-guide-to-react-suspense-397fdb06b49c?source=collection_archive---------13-----------------------#2022-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="decb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">悬念终于随着React 18结束了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c00b5e8b163e8bba2fe0a7bfe382e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_bOxK92Z6QTDHgaYPBkhw.png"/></div></div></figure><p id="b54f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React 18即将发布的另一大特色是悬念。如果你已经在React开发领域呆了很长时间，那么你会知道悬念特性并不是特别新。回到2018年，悬念作为React版本的一部分作为实验性功能发布。然后，它主要针对结合<code class="fe lq lr ls lt b">React.lazy</code>处理代码分割。</p><p id="5d3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是现在有了React 18，悬念正式释放就在眼前了。再加上<a class="ae lu" href="https://www.chakshunyu.com/blog/an-introductory-guide-to-concurrent-rendering/" rel="noopener ugc nofollow" target="_blank">并发渲染</a>的发布，悬疑的真正力量终于被解锁了。悬念和并发渲染之间的交互为改善用户体验打开了一个巨大的机会世界。</p><p id="a6a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是就像所有特性一样，就像并发渲染一样，从基础开始很重要。悬念到底是什么？为什么我们首先需要悬念？悬疑是怎么解决那个问题的？有什么好处？为了帮助你理解这些基本原理，这篇文章将会详细讨论这些问题，并为你提供一个关于悬念的坚实的知识基础。</p><h1 id="f01f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">悬念是什么？</h1><p id="93b4" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">本质上，悬念是React开发人员向React表明组件正在等待数据准备就绪的一种机制。React知道它应该等待获取数据。同时，将向用户显示一个回退，React将继续呈现应用程序的其余部分。数据准备好之后，React将返回到那个特定的UI并相应地更新它。</p><p id="f3de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从根本上说，这听起来与React开发人员必须实现数据获取流的当前方式没有太大区别:使用某种状态来指示组件是否仍在等待数据，使用一个<code class="fe lq lr ls lt b">useEffect</code>来启动数据获取，根据数据的状态显示加载状态，并在数据准备就绪后更新UI。</p><p id="0eb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但在实践中，悬念使这发生在一个技术上完全不同的。与前面提到的数据获取流程相反，悬念与React深度集成，允许开发人员更直观地编排加载状态，并避免竞争情况。为了更好地理解这些细节，知道我们为什么需要悬念是很重要的。</p><h1 id="5eab" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么我们需要悬念？</h1><p id="a69a" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">毫无疑问，有两种实现数据获取流的主要方法:呈现时获取和获取后呈现。然而，这些传统的数据获取流程存在一些问题。为了理解悬念，我们必须深入到这些流动的问题和限制中去。</p><h1 id="cab9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">渲染时提取</h1><p id="3a40" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">大多数人会使用<code class="fe lq lr ls lt b">useEffect</code>和状态变量来实现前面提到的数据获取流程。这意味着只有当组件呈现时才开始获取数据。所有的数据获取都发生在组件的效果和生命周期方法中。</p><p id="8f20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法的主要问题是，组件仅在渲染时触发数据提取，异步特性迫使组件必须等待其他组件的数据请求。</p><p id="c53e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有一个组件<code class="fe lq lr ls lt b">ComponentA</code>，它获取一些数据并有一个加载状态。在内部，<code class="fe lq lr ls lt b">ComponentA</code>也呈现另一个组件<code class="fe lq lr ls lt b">ComponentB</code>，它也自己执行一些数据获取。但是由于数据获取的实现方式，<code class="fe lq lr ls lt b">ComponentB</code>只在数据被渲染时才开始获取数据。这意味着它必须等到<code class="fe lq lr ls lt b">ComponentA</code>完成获取其数据，然后呈现<code class="fe lq lr ls lt b">ComponentB</code>。</p><p id="6be2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这导致了一种瀑布式的方法，在这种方法中，组件之间的数据获取是按顺序进行的，这实质上意味着它们相互阻塞。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="8a7a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">提取然后渲染</h1><p id="c5ed" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">为了防止组件之间数据获取的这种顺序阻塞，另一种方法是尽可能早地开始所有的数据获取。因此，不是让组件负责处理渲染时的数据获取，而是数据请求都单独发生，所有请求都在树开始渲染之前启动。</p><p id="b33e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法的优点是所有数据请求一起发起，因此<code class="fe lq lr ls lt b">ComponentB</code>不必等待<code class="fe lq lr ls lt b">ComponentA</code>完成。这解决了组件顺序阻塞彼此数据流的问题。然而，它引入了另一个问题，即我们必须等待所有数据请求完成，然后才能向用户呈现任何内容。可想而知，这并不是一个最优的体验。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="e767" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">悬念是如何解决数据获取问题的？</h1><p id="dac0" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">本质上，渲染时提取和提取后渲染的主要问题归结为一个事实，即我们试图强制同步两个不同的流，即数据提取流和React生命周期。带着悬念，我们得出了一种不同的数据获取方法，即所谓的“随取随渲染”方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b37f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与以前的实现的不同之处在于，它允许组件在React到达时启动数据获取。这甚至发生在组件渲染和反应没有停止之前。然后，它继续评估组件的子树，并继续尝试呈现它，同时等待数据获取完成。</p><p id="c6c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着悬念不会阻止呈现，这意味着子组件不必等待父组件完成后再发起数据获取请求。React试图尽可能多地呈现，同时发起适当的数据获取请求。请求完成后，React将重新访问相应的组件，并使用新接收的数据相应地更新UI。</p><h1 id="07d2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">悬疑有什么好处？</h1><p id="c2f8" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">悬念带来了很多好处，尤其是用户体验。但是一些好处也涵盖了开发者的体验。</p><ul class=""><li id="95f7" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">提前开始抓取。Suspense引入的即取即渲染方法的最大和最直接的好处是数据获取尽可能早地启动。这意味着用户需要等待的时间更少，应用程序更快，这对任何前端应用程序都是普遍有益的。</li><li id="2ca2" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">更直观的装载状态。有了悬念，组件不再需要包含大量的if语句或者单独跟踪状态来实现加载状态。相反，加载状态被集成到它所属的组件本身中。这使得组件更加直观，因为加载状态包含在组件中，所以加载代码与相关代码保持一致，并且更加可重用。</li><li id="85c6" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">避免竞态条件。我在本文中没有深入讨论的现有数据获取实现的一个问题是竞争条件。在某些情况下，传统的提取-渲染和提取-渲染实现可能会导致竞争情况，这取决于不同的因素，如时间、用户输入和参数化的数据请求。主要的潜在问题是，我们试图强制同步两个不同的过程，反应和数据获取。但是有了悬念，这就做得更优雅、更完整，避免了前面提到的问题。</li><li id="974a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">更加集成的错误处理。使用悬念，我们基本上为数据请求流创建了边界。最重要的是，因为悬念使它与组件代码的集成更加直观，它允许React开发人员为React代码和数据请求实现更加集成的错误处理。</li></ul><h1 id="0020" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后的想法</h1><p id="98a4" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">React悬念已经在雷达上3年多了。但是有了React 18，正式发布就越来越近了。除了并发渲染之外，它将是React发行版中最大的特性之一。就其本身而言，它可以将数据获取和加载状态实现提升到一个直观和优雅的新水平。</p><p id="b32e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了帮助您理解悬念的基本原理，本文讨论了几个对它很重要的问题和方面。这包括回顾什么是悬念，为什么我们首先需要像悬念这样的东西，它如何解决某些数据获取问题，以及悬念带来的所有好处。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nq lt nr ns aw nt bi"><span id="d636" class="nu lw it lt b gy nv nw l nx ny"><strong class="lt iu">Want to Connect?</strong></span><span id="ebe0" class="nu lw it lt b gy nz nw l nx ny">If you liked this article, consider checking out the other entries in the <a class="ae lu" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">Uncommon React</a> newsletter and my <a class="ae lu" href="https://twitter.com/keraito" rel="noopener ugc nofollow" target="_blank">Twitter</a> for future updates.</span></pre></div></div>    
</body>
</html>