<html>
<head>
<title>Why (0.302 == 0.302) is False in C++?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中为什么(0.302 == 0.302)为假？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/you-are-top-1-programmer-if-you-know-answer-to-this-d9e29db278b4?source=collection_archive---------3-----------------------#2022-10-05">https://betterprogramming.pub/you-are-top-1-programmer-if-you-know-answer-to-this-d9e29db278b4?source=collection_archive---------3-----------------------#2022-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6fe9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个让每个人解释浮点比较问题的问题——一个需要小心的问题。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53d8ecd14d118cd04c5aa38b7ae7fb33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YqcsgoYWl3IWnZBlO7Lpw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由Minhaz(作者)使用<a class="ae ky" href="https://www.photopea.com/" rel="noopener ugc nofollow" target="_blank"> Photopea </a>生成。</p></figure><p id="760e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的问题5%是数学，5%是C++，90%与主流编程语言中浮点计算的细微差别有关。</p><p id="ea36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入理论之前，让我们先从经验上尝试一下。我写了一个迷你程序来测试1000万次(只是为了确定)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上面的代码测试这个问题大约1000万次。</p></figure><p id="2bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以试试运行这个程序<a class="ae ky" href="https://onecompiler.com/cpp/3yhzce78p" rel="noopener ugc nofollow" target="_blank">这里</a>。我得到的输出是</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="7ff8" class="mc md it ly b gy me mf l mg mh">Counter = 0</span></pre><p id="f469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不用再去检查数学了，就像我说的，这只是一道数学题的5%。这甚至不是我在上面的例子中使用的特定编程语言的问题(在这个例子中是C++)。</p><p id="1864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你尝试运行一个类似的Python程序<a class="ae ky" href="https://onecompiler.com/python2/3yhzcu3xd" rel="noopener ugc nofollow" target="_blank">这里</a>，你会得到类似的结果。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1baf" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">这是怎么回事？</h1><h2 id="8ed6" class="mc md it bd mq ng nh dn mu ni nj dp my li nk nl na lm nm nn nc lq no np ne nq bi translated">内存中浮点值的表示</h2><p id="a030" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">这与浮点值在内存中的表示方式有关。</p><p id="9f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与直接以二进制值存储的整数值不同，浮点值表示为由符号、指数和尾数(分数)组成的等式。</p><p id="07e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">32位浮点数布局的一个例子是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/b13b4ff932a757ac5f51a5a1d4ffc9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_tGIsi-brbe3r4JavuYtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">32位浮点数的表示形式。来源<a class="ae ky" href="https://en.m.wikipedia.org/wiki/Floating-point_arithmetic" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure><p id="f6a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，64位浮点数可以存储为</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/605af98bb62a551b86d04ec0f488bda1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhCPpxyLsVkpS4p-IYdRjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">32位浮点数的表示形式。来源<a class="ae ky" href="https://en.m.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure><p id="a953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IEEE 754是表示非整数的最常用标准。几乎所有的现代处理器都包含称为FPU(浮点单元)的专门硬件来处理它们。</p><p id="528e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浮点数通常表示为</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8e11ff213413c3ad7915d45bb14c7f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/0*7z4k0YkngoZxPHv6.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">浮点方程的例子，由作者使用<a class="ae ky" href="https://quicklatex.com/" rel="noopener ugc nofollow" target="_blank">quicklatex.com</a>生成。</p></figure><p id="95c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在哪里，</p><ul class=""><li id="af33" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">s —是有符号位</li><li id="6131" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">m —由尾数位(小数部分)表示</li><li id="1eaf" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">e —(无符号整数)由指数位表示</li><li id="4687" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">c —是“e”最大值的一半(32位为127，64位为1023)</li></ul><p id="873c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在指数位为零的特殊情况下，数字表示为</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/072da20427fe5e6f499e65e4c3640fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/0*1-Nyx9JyhHkrxpJT.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">指数为零时的浮点方程示例，由作者使用<a class="ae ky" href="https://quicklatex.com/" rel="noopener ugc nofollow" target="_blank">quicklatex.com</a>生成。</p></figure><p id="32b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使我们能够更准确地存储接近于零的值(称为非正常值或次正常值)。某些表示允许我们表示-∞、+∞和NaN(非数字)值。</p><h2 id="eb67" class="mc md it bd mq ng nh dn mu ni nj dp my li nk nl na lm nm nn nc lq no np ne nq bi translated">你现在明白问题了吗？</h2><p id="3cc0" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">由于这种表示形式，浮点值不能存储任意实数，甚至不能存储任意有理数。它只能存储可以用上述等式表示的值。</p><p id="5ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们声明一个变量，如</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="8bf1" class="mc md it ly b gy me mf l mg mh">float a = 1.0f</span></pre><p id="9a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“a”变成了<code class="fe oo op oq ly b">0.10000001490116119384765625</code>，最接近<code class="fe oo op oq ly b">0.1</code>的32位浮点值。</p><p id="150f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是上面的计数器返回零的原因。</p><p id="f22c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果仍然不清楚，请检查这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示完全相同的值的差的结果的C++代码。</p></figure><p id="c304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码的输出应该是零，对吗？</p><p id="307a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是的，这段代码输出:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="4223" class="mc md it ly b gy me mf l mg mh">a = 100.302; b = 100.302<br/>Diff = 7.62939e-06</span></pre><p id="0e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试试在这里自己跑<a class="ae ky" href="https://onecompiler.com/cpp/3yj2bsmkb" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="7834" class="mp md it bd mq mr or mt mu mv os mx my jz ot ka na kc ou kd nc kf ov kg ne nf bi translated">如何解决这个问题？</h1><p id="7bb0" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">有几种方法可以做到这一点。一个相当天真但最常见的方法是看这些数字是否几乎相等，而不是正好等于最后一位。</p><p id="5a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过确保两个数字之间的差异小于某个小阈值(通常用字符ε-ε表示)来实现。</p><p id="3cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oo op oq ly b">FLT_EPSILON</code>是标准库中预定义的常数<code class="fe oo op oq ly b">float.h</code>。我们可以修改上面的代码来得到预期的答案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="28c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，输出变成:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="f7c2" class="mc md it ly b gy me mf l mg mh">Counter = 10000000</span></pre><p id="78b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，这种方法也有局限性。</p><p id="5237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为浮点方程是指数型的，所以相邻值上的数字之间的距离是指数增长的。因此，大数之间的距离，甚至是<code class="fe oo op oq ly b">100.0f</code>的范围，都会与<code class="fe oo op oq ly b">1.0f</code>不同。</p><p id="c7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得比较浮点值变得特别困难，因为我们需要用一种方法来处理接近零、稍大和非常大的数字。</p><p id="e464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用稍大的数字改变代码值</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用FLTε的isNearlyEqual()对100.0f范围内的值都不起作用</p></figure><p id="fad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果又变成了:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="0b51" class="mc md it ly b gy me mf l mg mh">Counter = 0</span></pre><p id="c60d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个解决这个问题的方法是使用相对ε值。试试在线代码<a class="ae ky" href="https://onecompiler.com/cpp/3yj2ar3q2" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">isNearlyEqual的修改版本(..)这应该适用于更大的值。</p></figure><p id="d082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这比简单的方法更有效，但要意识到<code class="fe oo op oq ly b">max_relative_diff</code>的正确值应该是多少仍然很棘手。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="8001" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">更好的方法？</h1><p id="edb9" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">有更好的处理方式。如果上面的方法对您的用例不起作用(也考虑到极限情况)，请尝试阅读下面的文章:</p><ul class=""><li id="48cd" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><a class="ae ky" href="https://bitbashing.io/comparing-floats.html" rel="noopener ugc nofollow" target="_blank">比较浮点数很棘手</a></li><li id="6382" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://stackoverflow.com/a/32334103/2614250" rel="noopener ugc nofollow" target="_blank">我应该如何进行浮点比较？</a></li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="58ed" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">参考</h1><p id="d8f3" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">上述理论的很大一部分来源于<a class="ae ky" href="https://bitbashing.io/about.html" rel="noopener ugc nofollow" target="_blank">马特·克莱恩</a>在文章<a class="ae ky" href="https://bitbashing.io/comparing-floats.html" rel="noopener ugc nofollow" target="_blank">中的一篇令人惊叹的文章——比较浮点数很棘手</a>。</p><h2 id="70da" class="mc md it bd mq ng nh dn mu ni nj dp my li nk nl na lm nm nn nc lq no np ne nq bi translated">其他参考文献</h2><ul class=""><li id="9055" class="nz oa it lb b lc nr lf ns li ow lm ox lq oy lu oe of og oh bi translated"><a class="ae ky" href="https://floating-point-gui.de/errors/comparison/" rel="noopener ugc nofollow" target="_blank">浮点比较</a></li></ul></div></div>    
</body>
</html>