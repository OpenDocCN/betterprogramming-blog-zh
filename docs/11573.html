<html>
<head>
<title>Generics in Go: Are We There Yet?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的泛型:我们到了吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/generics-in-go-are-we-there-yet-af851c35ba0?source=collection_archive---------4-----------------------#2022-03-31">https://betterprogramming.pub/generics-in-go-are-we-there-yet-af851c35ba0?source=collection_archive---------4-----------------------#2022-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f78a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">围棋向多范式语言过渡的探索</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/145dbbc153a1f8f6484fb09432044508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVJJyQJdtILixj55iB7kTQ.png"/></div></div></figure><p id="f9fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着泛型的到来——这一特性无疑已经将Go社区分割开来——Go最终从一种绝对命令式语言转变为一种多范式语言。但是我们到了吗？这是大家一直在等待的泛型实现吗？</p><p id="7c86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将利用我在Go中开发的<a class="ae lq" href="https://github.com/pscosta/go-strm" rel="noopener ugc nofollow" target="_blank">functional Map/Reduce Api</a>[1]来尝试回答这些问题。我将详细说明我发现的更多限制的问题和语言设计决策，并给出一些克服它们的变通方法。这一切，在Go 1.18探索泛型威力的同时！</p><p id="6277" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，仿制药呢？</p><p id="9b35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一些人认为，Go过于简单的咒语不太符合泛型允许创造性大脑做的事情。但是就像口语一样，编程语言不是静态的结构，而是随着时间的推移而发展的。工程师们今天正在解决的计算问题，肯定与我们20年前用来解决的不一样，所以我们用来解决这类问题的工具自然也在发展。</p><p id="fb59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有几个具体的例子说明语言进化是如何被外部因素驱动的。随着多核的出现，不需要低级锁定原语就能实现并行计算的更好的抽象诞生了:像Goroutines或其他“轻量级线程”构造这样的概念现在已经被许多编程语言所支持。</p><p id="0f78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着区块链的出现，智能合约越来越重要，这表明它的概念在编程中没有强有力的对等物。它可以通过类来模拟，但它可能对人们习惯于思考它的方式非常有害(<a class="ae lq" href="https://www.cnbc.com/2021/08/11/over-600-million-dollars-was-stolen-in-a-massive-defi-hack.html" rel="noopener ugc nofollow" target="_blank">见一个有缺陷的DEFI智能合约中编写的错误如何花费数百万</a> [2】)。然后坚固发生了。</p><p id="975c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">围棋也不例外。随着Go越来越多地被用在大型后端来执行非常普通的任务，扩展它的特性集是非常必要的。</p><p id="fb90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个干净代码的倡导者和函数式编程的狂热爱好者，我认为Go中的新泛型是一个很好的机会，可以用全新的更好的方式做同样的事情。函数式编程范式也变得越来越流行，因为它是实现这一目标的一个很好的工具，因为它做到了以下几点:</p><ul class=""><li id="b180" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">鼓励不可变的状态</li><li id="89f6" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">避免共享状态上的竞争情况</li><li id="ff05" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">支持并行执行较小且定义明确的任务</li><li id="dedb" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">提高可读性</li><li id="6f6f" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">减少样板代码</li></ul><p id="b51e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们深入探讨一下我在实现这个<a class="ae lq" href="https://github.com/pscosta/go-strm" rel="noopener ugc nofollow" target="_blank">功能图/Reduce API </a>时遇到的一些限制，并尝试回答一个重要的问题:我们到了吗？</p><h1 id="7aa7" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">缺少额外的类型参数</h1><p id="b115" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">与高阶函数不同，Go中的方法可能不接受额外的类型参数。这可能是1.18泛型实现中最缺少的特性，因为它不允许在Map/Reduce API中进行适当的链接。</p><p id="b78d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下面的类型为例，目标是创建一个由内部的<code class="fe nc nd ne nf b">slice[T]</code>支持的包装器<code class="fe nc nd ne nf b">Stream[T]</code>结构，为其元素提供映射、过滤和归约方法。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="0fc3" class="nk mg it nf b gy nl nm l nn no">type Stream[T any] struct {<br/>   slice      []T<br/>}</span></pre><p id="d4fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是期望的<code class="fe nc nd ne nf b">Map</code>方法，旨在应用形式<code class="fe nc nd ne nf b">Stream[IN] -&gt; Stream[OUT]</code>的转换。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="56d0" class="nk mg it nf b gy nl nm l nn no">func (s *Stream[IN]) Map[IN any, OUT any](f func(IN) OUT) *Stream[OUT]</span></pre><p id="4ec4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将允许流上的方法链接，动态地改变其泛型类型，如:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="71c3" class="nk mg it nf b gy nl nm l nn no">strm.Of(“Hey!”, “Hello!”, “Hi!”).<br/>     Map(func (s string) int { return len(s) }).<br/>     Filter(func (i int) bool { return i &gt; 1 }).<br/>     ToSlice()</span></pre><p id="13b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，由于没有办法在方法定义中指定<code class="fe nc nd ne nf b">OUT</code>类型，因此必须编写以下代码:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="3bf4" class="nk mg it nf b gy nl nm l nn no">func Map[IN any, OUT any](s *Stream[IN], f func(IN) OUT) *Stream[OUT]</span></pre><p id="4bc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使得底层的链接语法可读性更差:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="f9e4" class="nk mg it nf b gy nl nm l nn no">strm.Map(<br/>       strm.Of(“Hey!”, “Hello!”, “Hi!”),<br/>       func (s string) int { return len(s) },<br/>).<br/>Filter(func (i int) bool { return i &gt; 1 }).<br/>ToSlice()</span></pre><p id="6ba1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种限制背后的原因是什么？正如我们将看到的，这与Go中类型和接口实例化的工作方式有关。</p><p id="1206" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go中，<code class="fe nc nd ne nf b">Interfaces</code>是隐式实现的。类型通过实现其方法而不是显式声明来实现接口。</p><p id="fa00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，Go中没有类型擦除。在诸如Kotlin或Java之类的语言中，泛型类型约束是在编译时强制执行的，但实际的类型信息在运行时会被丢弃。在Go中，所有泛型类型在使用时都必须被急切地实例化。</p><p id="321e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">举以下例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="759a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单来说，只要声明了<code class="fe nc nd ne nf b">var Box[string]</code>，编译器也会实例化，如下所示:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="6dfd" class="nk mg it nf b gy nl nm l nn no">Box[string]<br/>Box[string].store(string)</span><span id="555f" class="nk mg it nf b gy nr nm l nn no">Storage[string]<br/>Storage[string].store(string)</span></pre><p id="d1a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着编译器必须拥有要被推断的泛型类型参数的所有信息，并用具体的参数替换，从而在运行时完全定义可用类型的整个范围。</p><p id="549a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到我们的流示例，假设下面的代码片段是有效的，Go编译器不仅要实例化显式声明的<code class="fe nc nd ne nf b">Stream[string]</code>，还要实例化从<code class="fe nc nd ne nf b">Map</code>调用中推断出的<code class="fe nc nd ne nf b">Stream[int]</code>。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4ee8" class="nk mg it nf b gy nl nm l nn no">strings := []string{“Hey!”, “Hello!”, “Hi!”}</span><span id="1b4a" class="nk mg it nf b gy nr nm l nn no">Stream[string]{slice: strings}.<br/>     Map(func (s string) int { return len(s) })</span></pre><p id="8385" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这种类型的推理还没有在方法中实现，因为在这种情况下需要增加复杂性。允许方法在没有类型推断支持的情况下接受额外的类型参数，会破坏类型实例化规则和<code class="fe nc nd ne nf b">Interfaces</code>的隐式实现。</p><p id="0227" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于如何支持这一点，有几个建议，要么在运行时进行推理，要么简单地将这些方法视为顶级函数。不管选择哪种技术解决方案，我相信未来的版本会解决这个问题。</p><h1 id="078d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak">无通用专业</strong></h1><p id="2ab0" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">简而言之，没有办法用具体的类型参数重载泛型函数或方法。</p><p id="9071" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过允许泛型类型的具体变化，这可以部分减轻上面讨论的方法的附加类型限制。</p><p id="b5f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次回到<code class="fe nc nd ne nf b">Stream[string]</code>的例子，让我们想象我们想要为一些可数类型编写一个<code class="fe nc nd ne nf b">Sum</code>函数的不同专门化:一个用于返回所有整数之和的<code class="fe nc nd ne nf b">Stream[int]</code>,另一个用于连接所有字符串的<code class="fe nc nd ne nf b">Stream[string]</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6456" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上根本不可能。一般来说，方法很少支持泛型。它们不能被重载，也不能接受额外的类型参数或进一步的类型约束。</p><p id="7d5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一种肮脏的变通方法，可以使用一些代价高昂的反射来在运行时确定泛型类型，决定如何处理它，最后进行一系列强制转换，以便仍然遵守方法擦除:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="523d" class="nk mg it nf b gy nl nm l nn no">strm.Of("a", "b", "c").Sum()<br/>// returns -&gt; abc </span><span id="f939" class="nk mg it nf b gy nr nm l nn no">strm.Of(1, 2).Sum() <br/>// returns -&gt; 3</span><span id="67a6" class="nk mg it nf b gy nr nm l nn no">strm.Of(Person{"Tim", 3}, Person{"Tom", 4}).Sum() <br/>// returns -&gt; { 0} the zero value for Person struct type</span></pre><p id="c357" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这确实有效，但这并不是一个人想要实现的东西。</p><h1 id="e07b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">兰姆达斯太冗长了</h1><p id="faea" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">简洁的lambda表达式对于有效表达函数范式至关重要，因为它们被广泛用作函数输入表达式，并且经常被链接在一起。</p><p id="e859" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一些lambdas如何用其他语言表达的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5334" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是围棋中的一个λ:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="d290" class="nk mg it nf b gy nl nm l nn no">// Go<br/>Map(func (a int, b int) int { <br/>     return a + b<br/>})</span></pre><p id="a920" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go指定lambdas具有与常规函数完全相同的语法，除了实际的函数名。这迫使显式使用<code class="fe nc nd ne nf b">func</code>和<code class="fe nc nd ne nf b">return</code>关键字，以及冗余的输入和输出类型声明。</p><p id="64f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将它们链接在一起时，符号变得更糟:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="39fc" class="nk mg it nf b gy nl nm l nn no">Map(func(it string) int { <br/>     return len(it) <br/>}).<br/>Filter(func(it int) bool { <br/>     return it &gt; 10 <br/>}).<br/>Reduce(func(a int, b int) int { <br/>     return a + b <br/>})</span></pre><p id="0b15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中大部分样板文件可以简化为:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="d414" class="nk mg it nf b gy nl nm l nn no">Map((it string) -&gt; len(it)).<br/>Filter((it int) -&gt; it &gt; 10).<br/>Reduce((a int, b int) -&gt; a + b)</span></pre><p id="1031" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者更简单，比如在Kotlin或Groovy中，使用隐式参数(通常是<code class="fe nc nd ne nf b">it</code>):</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="6038" class="nk mg it nf b gy nl nm l nn no">Map(len(it)).<br/>Filter(it &gt; 10).<br/>Reduce((a, b) -&gt; a + b)</span></pre><p id="3bee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">轻量级语法不仅删除了不必要的重复，而且最重要的是，通过删除所有混淆真正重要的操作的样板文件，提高了代码的可读性。</p><h1 id="8aab" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak">零值问题</strong></h1><p id="3b12" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">当前的1.18 Go泛型实现没有简单的方法来表示泛型类型参数的零值。</p><p id="c453" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您正在收缩一个泛型<code class="fe nc nd ne nf b">[T any]</code>类型的<code class="fe nc nd ne nf b">slice</code>，并且需要对删除的元素进行垃圾收集。通常，人们只需将这些元素设置为<code class="fe nc nd ne nf b">nil</code>，或者只需将<code class="fe nc nd ne nf b">slice</code>类型的零值赋给它们。下面是使用泛型类型的方法:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="910a" class="nk mg it nf b gy nl nm l nn no">func delete[T any](slice []T, idx int) {<br/>   for j := idx; j &lt; len(slice); j++ {<br/>      var t T<br/>      slice[j] = t<br/>   }<br/>   slice = slice[:idx]<br/>}</span></pre><p id="a310" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于没有办法写入或返回<code class="fe nc nd ne nf b">T</code>的零值，这必须在两个语句中完成:首先声明一个<code class="fe nc nd ne nf b">T</code>类型的变量——被编译器隐式赋值给泛型类型的零值——然后在一个新语句中执行赋值。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="628d" class="nk mg it nf b gy nl nm l nn no">var t T<br/>slice[j] = t</span></pre><p id="fb52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自然的想法是在类似于<code class="fe nc nd ne nf b">slice[j] = nil</code>的赋值中使用<code class="fe nc nd ne nf b">nil</code>，并希望编译器足够聪明，能够将它转换为不可空类型(如int或strings)的零值，或者甚至尝试类似于泛型类型<code class="fe nc nd ne nf b">T</code>的空构造函数(如<code class="fe nc nd ne nf b">slice[j] = T{}</code>)。但是这里也没有运气。</p><p id="eae1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我肯定不记得有哪种情况下这可能是一个阻碍，但它肯定感觉像一个未经打磨的粗糙边缘。</p><h1 id="8630" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak">哈希问题</strong></h1><p id="e668" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在围棋中比较事物是…嗯…复杂的。</p><p id="49b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像<code class="fe nc nd ne nf b">ints</code>、<code class="fe nc nd ne nf b">strings</code>、<code class="fe nc nd ne nf b">booleans</code>、<code class="fe nc nd ne nf b">pointers</code>和<code class="fe nc nd ne nf b">channel</code>这样的原始类型是可以比较的，也就是说运算符<code class="fe nc nd ne nf b">==, !=</code>适用于这些类型。<code class="fe nc nd ne nf b">Slice</code> s，<code class="fe nc nd ne nf b">Map</code> s，和函数都不是。包含不可比较类型的结构也是不可比较的。</p><p id="24e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当试图定义断言或要求<code class="fe nc nd ne nf b">Identity</code>概念的真正通用函数时，缺乏比较某些数据结构的本机方法——不管Go lang devs提出的有效动机如何(我在这里不讨论)—都成为一个严重的限制。</p><p id="fce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将展示几个例子，说明这种限制如何在诸如<code class="fe nc nd ne nf b">Stream[T].Contains()</code>或<code class="fe nc nd ne nf b">Stream[T].Distinct()</code>这样的方法上变得明显，以及克服这种限制所需的技巧。</p><p id="2b9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个关于<code class="fe nc nd ne nf b">Contains()</code>的天真而有问题的版本:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="1f87" class="nk mg it nf b gy nl nm l nn no">func (s *Stream[T]) Contains(element T) bool {<br/>   for _, a := range s.slice {<br/>      if a == element {<br/>         return true<br/>      }<br/>   }<br/>   return false<br/>}</span></pre><p id="5212" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编译器立即返回:</p><p id="004c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ns">无效操作:a ==元素(运算符==未在T上定义)</em></p><p id="dc25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于主流结构已经定义为<code class="fe nc nd ne nf b">Stream[T any]</code>以支持所有类型<strong class="kw iu">，</strong> <code class="fe nc nd ne nf b">T</code>不实现可比性。</p><p id="5eca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go的反射包再一次拯救了我们。以下是可能的加密代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d605" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它是这样做的:</p><p id="57f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1.检查类属<code class="fe nc nd ne nf b">T</code>是否确实是可比类型之一:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="be50" class="nk mg it nf b gy nl nm l nn no">reflect.TypeOf((*T)(nil)).Elem().Comparable()</span></pre><p id="e0d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.一旦断言了泛型类型是否可比较，它们就被转换为<code class="fe nc nd ne nf b">any</code><strong class="kw iu"/>(<code class="fe nc nd ne nf b">interface{}</code>的可互换别名)，这样编译器就不会抱怨在泛型类型<code class="fe nc nd ne nf b">T</code>上使用了<code class="fe nc nd ne nf b">==</code>运算符。</p><p id="567f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么不可比的类型呢，比如<code class="fe nc nd ne nf b">slice</code>或者包含<code class="fe nc nd ne nf b">slice</code>的结构？</p><p id="b65a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们试图比较它们，我们肯定会得到一个运行时的恐慌。这里有一个可能的解决方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3fab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，<code class="fe nc nd ne nf b">reflect.DeepEqual()</code>实现了预期的行为。文档中对切片的描述如下:</p><blockquote class="nt nu nv"><p id="b682" class="ku kv ns kw b kx ky ju kz la lb jx lc nw le lf lg nx li lj lk ny lm ln lo lp im bi translated">" DeepEqual报告x和y是否“完全相等”，定义如下:<br/>当满足以下所有条件时，切片值完全相等:<br/>它们都为零或非零，它们具有相同的长度，<br/>并且它们要么指向同一基础数组的相同初始项"</p></blockquote><p id="c928" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，人们很自然地开始思考默认情况下没有这种行为背后的原因。不管那种推理，当把泛型和<code class="fe nc nd ne nf b">Map</code>放在一起时，这种语言设计决策变得更加受限。Go不允许不可比较的类型作为<code class="fe nc nd ne nf b">Map</code> s的键。</p><p id="81fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们试图使用一个泛型<code class="fe nc nd ne nf b">T</code>作为映射键，例如<code class="fe nc nd ne nf b">map[T]string</code>，编译器会报错:</p><blockquote class="nt nu nv"><p id="4977" class="ku kv ns kw b kx ky ju kz la lb jx lc nw le lf lg nx li lj lk ny lm ln lo lp im bi translated">无效的映射键类型:比较运算符==和！=必须为密钥类型完全定义</p></blockquote><p id="e380" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那我们现在的<code class="fe nc nd ne nf b">Stream[T].Distinct()</code>呢？</p><p id="26b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在go世界中，去重复数据结构的首选是在<code class="fe nc nd ne nf b">Map</code>中索引数据(利用散列值是非常廉价的操作的事实)，然后拒绝任何重复的键。</p><p id="0913" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一些数据结构本身不是可散列的，那么就不可能实现一个通用的<code class="fe nc nd ne nf b">.Distinct()</code>方法，或者至少是开箱即用的。</p><p id="6b55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个可能的解决方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="60bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里使用的技巧在于为不可比较的类型显式生成一个自定义哈希值，并将其用作映射键。幸运的是，有很多简单的方法可以做到这一点，在这个例子中，我使用了流行的<a class="ae lq" href="https://github.com/mitchellh/hashstructure" rel="noopener ugc nofollow" target="_blank"> hashstructure </a> [4]包。</p><p id="fd67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，请注意结构<code class="fe nc nd ne nf b">map[any]struct{}</code>。这将允许后台<code class="fe nc nd ne nf b">Map</code>接受任何种类的密钥，同时存储一个不需要任何额外空间的空<code class="fe nc nd ne nf b">struct{}</code>。</p><p id="2d7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想还不算太糟，但还是很乱。</p><h1 id="6478" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak">递归实例化循环</strong></h1><p id="f1a4" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">这里有一个简单的用例:在一个<code class="fe nc nd ne nf b">Stream[things]</code>上应用批处理，并使它成为一个<code class="fe nc nd ne nf b">Stream[[]things]</code>。可能很直白吧？</p><p id="e895" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不完全是。结果是这个<code class="fe nc nd ne nf b">T -&gt; []T</code>转换，即使是在同一个类型<code class="fe nc nd ne nf b">T</code>之上，也会触发一个意外的实例化循环。</p><p id="38e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下面的<code class="fe nc nd ne nf b">Stream[T].Chunked(batchSize)</code>方法为例，目标是将<code class="fe nc nd ne nf b">T</code>中的一个<code class="fe nc nd ne nf b">slice</code>按照提供的批次大小批量分成更小的片，例如:<code class="fe nc nd ne nf b">[1, 2, 3, 4]</code>对于一个<code class="fe nc nd ne nf b">batchSize = 2</code>变成<code class="fe nc nd ne nf b">[[1, 2] [3, 4]]</code>。</p><p id="a048" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个简单的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a750" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是意外的编译错误:</p><blockquote class="nt nu nv"><p id="e8f4" class="ku kv ns kw b kx ky ju kz la lb jx lc nw le lf lg nx li lj lk ny lm ln lo lp im bi translated">。/strms_test.go:1:10:实例化周期:<br/>。/strms_test.go:1:13: T实例化为[]T</p></blockquote><p id="0549" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种循环错误的根本原因再次与Go的类型实例化机制有关。正如我们之前所看到的，一旦声明了所有类型及其方法，Go就会急切地实例化它们。</p><p id="1bc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个<code class="fe nc nd ne nf b">Stream[string]</code>被实例化时，方法<code class="fe nc nd ne nf b">*Stream[string].Chunked(int): *Stream[[]string]</code>也被实例化。它的返回类型<code class="fe nc nd ne nf b">*Stream[[]string]</code>本身是一个新类型，这又将实例化<code class="fe nc nd ne nf b">*Stream[[]string].Chunked(int): *Stream[[][]string]</code>，以此类推，形成一个实例化循环。</p><p id="1079" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打破这个循环的解决方案可以简单到将<code class="fe nc nd ne nf b">Chunked()</code>返回类型改为<code class="fe nc nd ne nf b">[][]T</code>而不是<code class="fe nc nd ne nf b">*Stream[[]T]</code>，或者将<code class="fe nc nd ne nf b">[]T</code>包装在新的结构中。对于提供一致的<code class="fe nc nd ne nf b">*Stream -&gt; *Stream</code>功能API来说，这两种解决方案都不理想，因为我们放弃了期望的返回类型契约。</p><p id="ed10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再一次，这感觉像是在泛型实现过程中被匆忙或忽略的事情，但我仍然相信随着泛型API的稳定，它会在未来的版本中得到处理。</p><h1 id="f2be" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="d035" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">我希望我已经说得很清楚了，一个简洁明了的函数式Map/Reduce API在Go中仍然不能完全实现。虽然大多数函数范式技术仍然是可能的，使许多丰富的函数成为现实，但缺乏对方法中附加类型参数的支持是非常有限的。</p><p id="b3d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一方面，Go仍然是一门非常年轻的语言，我确实看到了很大的改进空间。我遇到的大多数限制通常与固有的实现复杂性有关，而不是与某些语言规范不兼容有关。</p><p id="4189" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，在某些情况下，令人印象深刻的是，旧语言可以很好地支持新的范例，而这些范例并不是为它们设计的。Go仍处于起步阶段，如果算上一个非常活跃、受过良好教育的社区，它肯定会发展得很好。</p><p id="c7d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我也认为更加“宽容”，允许用多种方式做同样的事情，最终是好的，因为更多拥有不同技能的人会采用Go。</p><p id="1e4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终，就像莱纳斯·托沃兹曾经说过的，“只要有足够的眼球，所有的错误都是肤浅的。”</p><p id="8b73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于最初的问题:我们到了吗？嗯……不完全是，但我们肯定是朝着正确的方向前进。</p><h1 id="0164" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">参考</h1><p id="0698" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">[1]—<a class="ae lq" href="https://github.com/pscosta/go-strm" rel="noopener ugc nofollow" target="_blank">Go-strm:Go中丰富的Map/Reduce API，PS Costa</a><br/>【2】—<a class="ae lq" href="https://www.cnbc.com/2021/08/11/over-600-million-dollars-was-stolen-in-a-massive-defi-hack.html" rel="noopener ugc nofollow" target="_blank">在迄今为止最大的DeFi黑客攻击之一中，超过6亿美元被盗</a><br/>【3】—<a class="ae lq" href="https://github.com/golang/go/issues/49085" rel="noopener ugc nofollow" target="_blank">Go规范:允许方法# 49085</a><br/>【4】—<a class="ae lq" href="https://github.com/mitchellh/hashstructure" rel="noopener ugc nofollow" target="_blank">https://github.com/mitchellh/hashstructure</a></p></div></div>    
</body>
</html>