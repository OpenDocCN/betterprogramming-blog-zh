<html>
<head>
<title>What Is the @escaping Keyword in Swift 5?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5中的@escaping关键字是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-5-escaping-explained-96051695530?source=collection_archive---------10-----------------------#2020-04-27">https://betterprogramming.pub/swift-5-escaping-explained-96051695530?source=collection_archive---------10-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="90ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">新的和改进的完成处理程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/91a3f34f7932b396f71d9435f52fb327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgeU8HPo8TFF1cZQ-4XjJw.jpeg"/></div></div></figure><p id="d78d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理解的先决条件:</p><ul class=""><li id="6265" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">基本Swift 5语法。</li><li id="5873" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">关闭。</li><li id="2fb4" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">异步数据处理。</li></ul><p id="d5ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了完全掌握<code class="fe mb mc md me b">@escaping</code>关键字的作用，我们必须首先理解什么是完成处理程序。</p><p id="533d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们考虑下面的函数:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="952e" class="mj mk iq me b gy ml mm l mn mo">func fetchData(url: String){</span><span id="62d3" class="mj mk iq me b gy mp mm l mn mo">  print("Fetching data...")<br/>  print("Data has been fetched!")</span><span id="b893" class="mj mk iq me b gy mp mm l mn mo">}</span></pre><p id="484c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个非常基本的功能，除了打印到控制台之外什么也不做。到目前为止还没有异步请求。</p><p id="c229" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于函数，你需要了解的第一件事是它有一个函数作用域。这意味着，当线程执行完这个函数时，这个函数将被丢弃。</p><p id="7847" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以把它想象成功能已经被扔掉了。在这种情况下，该函数将在该行之后被丢弃:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="6a13" class="mj mk iq me b gy ml mm l mn mo">print("Data has been fetched!")</span></pre><p id="e2df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">意味着该功能及其范围不再存在。</p><p id="e1a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，假设您想要传入一个函数(闭包)在<code class="fe mb mc md me b">fetchData</code>函数执行完毕后执行。通常被称为“完成处理器”我们应该这样写:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="214f" class="mj mk iq me b gy ml mm l mn mo">func fetchData(url: String, completionHandler: () -&gt; ()){</span><span id="9586" class="mj mk iq me b gy mp mm l mn mo">  print("Fetching data...")<br/>  print("Data has been fetched!")<br/>  completionHandler()</span><span id="387a" class="mj mk iq me b gy mp mm l mn mo">}</span></pre><p id="e1e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，当我们调用这个方法时，我们作为<code class="fe mb mc md me b">completionHandler</code>的值传入的参数将在函数结束时执行。</p><p id="94f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记住，在这个例子中，在调用了<code class="fe mb mc md me b">completionHandler</code>之后，函数的作用域仍然被丢弃。</p><p id="7766" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你好奇，你可以这样调用这个函数:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="65d4" class="mj mk iq me b gy ml mm l mn mo">fetchData("https://www.google.com") {</span><span id="f324" class="mj mk iq me b gy mp mm l mn mo">  print("Code has finished executing!")</span><span id="2978" class="mj mk iq me b gy mp mm l mn mo">}</span></pre><p id="7c3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="c166" class="mj mk iq me b gy ml mm l mn mo">fetchData("https://www.google.com", { () in print("Hello") } )</span></pre><p id="7d59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们介绍一个揭示<code class="fe mb mc md me b">@escaping</code>含义的问题。</p><p id="08ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设在<code class="fe mb mc md me b">fetchData</code>中，我们构建了一个获取数据的请求，一旦数据被返回，我们希望调用我们的完成处理程序。</p><p id="97e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="df4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，在我们的函数中，我们实际上是在函数作用域被破坏后调用我们传入的<code class="fe mb mc md me b">completionHandler</code>闭包。</p><p id="becf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">发生这种情况是因为主线程将执行<code class="fe mb mc md me b">URLSession.shared.dataTask()</code>方法，当它等待响应时，它将继续执行函数的其余部分。</p><p id="026b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，当它仍在等待响应时，它将打印到控制台:“我们的函数作用域即将被销毁”，然后该函数将被丢弃…同时它仍在等待请求的响应。</p><p id="dbc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要解决这个问题，我们需要以某种方式告诉函数:“嘿，当你执行完了，我仍然需要这个完成处理程序，所以不要因为你执行完了就丢弃它。”</p><p id="bb10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是<code class="fe mb mc md me b">@escaping</code>发挥作用的地方…</p><p id="ed3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过将关键字<code class="fe mb mc md me b">@escaping</code>添加到函数定义的<code class="fe mb mc md me b">completionHandler</code>参数中，我们确切地告诉函数:“在这个闭包被执行之前，不要放弃自己。”</p><p id="3a66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看它的语法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4e5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很简单。</p><p id="1214" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">唯一的区别是我们在闭包前添加了<code class="fe mb mc md me b">@escaping</code>。现在，该函数知道在调用<code class="fe mb mc md me b">completionHandler</code>参数之前不要丢弃自己。</p><p id="2278" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，让我们称我们的方法为…</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="9626" class="mj mk iq me b gy ml mm l mn mo">fetchData("https://www.google.com") {</span><span id="abea" class="mj mk iq me b gy mp mm l mn mo">  print("Completion Handler called")</span><span id="f5e5" class="mj mk iq me b gy mp mm l mn mo">}</span></pre><p id="e614" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，打印语句序列将成功记录如下:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="462e" class="mj mk iq me b gy ml mm l mn mo">Function started<br/>Our function scope is going to remain open<br/>Completion Handler called</span></pre><p id="b18e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望你今天学到了一些东西。</p><p id="25d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">干杯。</p></div></div>    
</body>
</html>