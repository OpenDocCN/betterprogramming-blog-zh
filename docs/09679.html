<html>
<head>
<title>A First Look at Serverless Architecture: The Why, The What, and The How</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器架构初探:原因、内容和方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/serverless-architecture-why-what-and-how-23c2c4f3e18c?source=collection_archive---------0-----------------------#2021-09-26">https://betterprogramming.pub/serverless-architecture-why-what-and-how-23c2c4f3e18c?source=collection_archive---------0-----------------------#2021-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fdbc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实施您的首个无服务器应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89f97fc414d56446c9e35127ef847ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WIZFcnU-gbhaXp_q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@santosh313?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Santosh 313 </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2b60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近遇到了无服务器架构，乍一看，它似乎是我所有基础架构问题的一站式解决方案。但是随着更多的时间花在阅读它存在的理由上，我发现无服务器架构旨在解决一个特定的用例，因此我决定写一篇文章详细介绍我对它的看法。</p><h1 id="98b2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么没有服务器？</h1><p id="5ce6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设您想创建一个微服务，简单地检查某个特定的<code class="fe ms mt mu mv b">property</code>是否在用户的预算之内。该服务将最终执行以下步骤:</p><ul class=""><li id="6815" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">从请求中提取<code class="fe ms mt mu mv b">propertyId</code>和预算</li><li id="7929" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">使用<code class="fe ms mt mu mv b">propertyId</code>从外部微服务或数据库获取房产价格</li><li id="a27f" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">返回<code class="fe ms mt mu mv b">property</code>是否可承受</li></ul><p id="7481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了实现这个简单的功能，你必须启动整个基础设施，假设你决定使用AWS提供的一个简单的<code class="fe ms mt mu mv b">Ec2</code>实例。</p><ul class=""><li id="0810" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">首先，您必须决定选择哪个操作系统映像进行实例化。</li><li id="ac30" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">然后设置其他实例配置，如入站规则、CPU和磁盘大小等</li><li id="717f" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">然后安装环境和环境依赖项，如<code class="fe ms mt mu mv b">npm</code>、<code class="fe ms mt mu mv b">pm2</code>等(假设您使用Node.js作为您的环境)</li><li id="8fd4" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">然后设置一个类似Nginx的反向代理服务器来处理正确的DNS解析。</li></ul><p id="ad41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使做了所有这些，如果明天服务器上的负载增加，您的服务可能会中断，您将被迫寻找一些自动扩展解决方案，这本身就是一个选择的世界，最终会让您花费更多。</p><p id="6143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这样一个简单的服务来说，所有这些工作似乎太多了。这就是无服务器架构的用武之地。</p><h1 id="2dfa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是无服务器？</h1><p id="06de" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">无服务器架构是一种软件设计模式，其中应用程序由第三方服务托管，无需开发人员管理服务器软件和硬件。</p><p id="c187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也称为功能即服务，无服务器功能运行在与用户和开发人员隔离的环境中，完全由云提供商管理。</p><p id="c964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无服务器应用运行在短暂的无状态计算容器中(可能持续一次调用),并且可以由各种不同的事件触发，如HTTP调用(通过API网关)或数据库触发器等。</p><p id="8f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这并不意味着无服务器体系结构是所有应用程序的首选，无服务器有几个优点和缺点</p><h2 id="721a" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">赞成的意见</h2><ul class=""><li id="397f" class="mw mx it lb b lc mn lf mo li nw lm nx lq ny lu nb nc nd ne bi translated">成本:无服务器架构有助于节省基础设施成本，因为只根据运行代码所分配的时间和内存来收费。</li><li id="21c1" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">可伸缩性:作为一名开发人员，当负载增加时，您不需要担心扩展服务，所有这些都由云提供商自己管理。</li><li id="cd74" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">效率:无服务器架构最终提高了团队的效率，因为开发人员现在不必关注与部署服务器、编写自动缩放逻辑、处理多线程和各种其他性能优化相关的本质细节，因此只需关注服务业务。</li></ul><h2 id="5164" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated"><strong class="ak">缺点</strong></h2><ul class=""><li id="c0c9" class="mw mx it lb b lc mn lf mo li nw lm nx lq ny lu nb nc nd ne bi translated">性能:只要长时间不使用无服务器逻辑，云提供商就会关闭运行代码的容器(尽管所有这些功能都是从开发人员那里抽象出来的)。因此，不经常使用的无服务器功能通常需要很长时间来提供响应，因为它们需要大量的时间来启动。</li><li id="164f" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">资源限制:无服务器功能可以占用的计算能力和内存量通常有硬性限制，这就是无服务器计算不适合一些计算密集型工作负载的原因。还有其他硬限制，比如AWS Lambda中的300秒默认超时限制。</li><li id="bb73" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">监控和调试:监控和调试无服务器功能不像传统服务器那样容易，传统应用程序中可用的工具数量在无服务器架构中是不可用的(尽管随着无服务器框架等工具的出现，这种情况正在发生变化)</li><li id="7fbd" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">供应商锁定:使用特定的云提供商创建无服务器架构会产生对提供商的依赖性。云提供商可以在内部进行更改，如更改默认阈值、超时、定价，开发人员必须遵守这些更改(同样，无服务器框架通过提供与云提供商无关的接口解决了这个问题)</li><li id="bd78" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">重复工作:在传统的应用程序中，我们可以为应用程序中的每个触发器配置一个公共管道，现在在无服务器函数的情况下，由于每个函数都是无状态的，因此需要单独为每个函数重写所有公共逻辑。</li></ul><p id="6283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑上述参数可以帮助我们决定是否应该为我们的项目采用无服务器架构。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h1 id="add9" class="lv lw it bd lx ly og ma mb mc oh me mf jz oi ka mh kc oj kd mj kf ok kg ml mm bi translated"><strong class="ak">如何实现无服务器架构？</strong></h1><p id="cbb7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这一节中，我将简要介绍如何创建一个可以被HTTP端点调用的无服务器函数。在这里，我们将使用AWS Lambda来实现这一点，因为这是该领域最古老、最成熟的服务之一。</p><p id="2774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前往<a class="ae ky" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>的主页，点击<code class="fe ms mt mu mv b">Get started with Amazon Lambda</code>按钮:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/9cf734dde3c318639769fe53cdd17e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiRakjxfE93ef7mW2RtiFA.png"/></div></div></figure><p id="1552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果还没有，你将被要求登录亚马逊控制台。之后，你会被重定向到亚马逊的lambda仪表盘。</p><p id="38b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击“创建函数”按钮创建一个lambda函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/54a483cd842f6dd693cd239f05ad775f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gPPna5KNlFakHMR3tm5RUg.png"/></div></div></figure><p id="b062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后确保选择了<code class="fe ms mt mu mv b">Author from Scratch</code>按钮，并提供如下图所示的功能名称:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/b5b2fa237228303c3dcd80dd9728d507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwMKs26Zza__5sb-2lKbng.png"/></div></div></figure><p id="7c2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，单击create function按钮，您将能够看到您的lambda函数，代码如下:</p><pre class="kj kk kl km gt on mv oo op aw oq bi"><span id="b0db" class="nk lw it mv b gy or os l ot ou">exports.handler = async (event) =&gt; {<br/>    // TODO implement<br/>    const response = {<br/>        statusCode: 200,<br/>        body: JSON.stringify('Hello from Lambda!'),<br/>    };<br/>    return response;<br/>};</span></pre><p id="6ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是您将无法触发该函数，除非您为该函数实现一个触发器。对于这个例子，让我们实现一个简单的HTTP触发器。</p><p id="c53a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击添加触发器按钮，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/1d1cd8cb9e0ffaf10fcb0a31050a8a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOVmQjuwC2Z3lMb_21rgSw.png"/></div></div></figure><p id="951f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从下拉列表中选择API网关，然后单击添加按钮:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/79d0a8a5059f06e701a17faeb445d25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvyjJVlapKZCtvAMHZOS9A.png"/></div></div></figure><p id="bb55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的触发器现已成功实现，您可以使用生成的URL来触发lambda函数，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/fe4a506a1802c224872714d184bf6380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0MuCq_dLcf52EhGsZewvg.png"/></div></div></figure><p id="49d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在浏览器中粘贴以下URL会显示以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/20e0409c24d86a907f27b36c21237b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*WHUgqFjUp9K85zofVsNltQ.png"/></div></figure><p id="a857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，你就成功地实现了你的第一个lambda函数，遵循一个无服务器架构。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h1 id="bf9b" class="lv lw it bd lx ly og ma mb mc oh me mf jz oi ka mh kc oj kd mj kf ok kg ml mm bi translated">结论</h1><p id="ddfc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">无服务器架构服务于一个非常具体的用例，并在其中大放异彩，但这并不意味着它可以用来完全取代市场上的其他基础架构解决方案。</p><p id="8ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像剑不应该用来削苹果皮，菜刀不应该用来打仗一样，重要的是根据问题的背景和要求来选择解决方案。</p><h1 id="4a28" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="9201" class="mw mx it lb b lc mn lf mo li nw lm nx lq ny lu nb nc nd ne bi translated"><a class="ae ky" href="https://www.twilio.com/docs/glossary/what-is-serverless-architecture" rel="noopener ugc nofollow" target="_blank">无服务器架构</a></li><li id="e658" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Serverless_computing#Advantages" rel="noopener ugc nofollow" target="_blank">无服务器计算</a></li></ul></div></div>    
</body>
</html>