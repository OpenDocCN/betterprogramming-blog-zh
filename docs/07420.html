<html>
<head>
<title>Master TypeScript’s Type Guards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Master TypeScript的类型保护</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/master-typescripts-type-guards-1fd5436bc6f2?source=collection_archive---------5-----------------------#2021-01-13">https://betterprogramming.pub/master-typescripts-type-guards-1fd5436bc6f2?source=collection_archive---------5-----------------------#2021-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="afaf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在TypeScript的type guards中从初学者到专业人员</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36f31b56523b29c97087a49701ee4761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sKis8YF-5C61snU7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺德·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="0fa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，TypeScript是微软在2012年开发的一种语言。它是一个JavaScript超集，并且是动态类型的。因为它是动态类型的，所以类型守卫有时会发挥很大的作用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基础知识</h1><p id="f2a4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到底什么是类型守卫？它们是一套帮助我们缩小对象类型的工具。这意味着你正在从一个更一般的类型转向一个更具体的类型。它们最常见的用法是缩小联合类型。</p><p id="7e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多种技术可以执行类型保护。选择正确的将取决于您的具体场景和个人偏好。我们将探索每一种技术及其注意事项。</p><p id="09d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<a class="ae ky" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank">TypeScript Playground app</a>来运行本文中包含的所有代码片段。这是一个很好的工具，你可以用它来练习和提高你的打字技巧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9263" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.可空类型</h1><p id="bd8a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从最简单的开始。假设你有一个可以为空的类型。任何时候你在做一个<code class="fe mz na nb nc b">null</code>，你基本上是在做一个类型守卫。如果您已经在进行<code class="fe mz na nb nc b">null</code>检查，那么您已经在直观地使用类型保护:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ad37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解类型保护如何处理条件块是非常重要的。在一个简单的条件块中(如上)，类型保护将只应用于它的内部。但是，如果您在条件类型保护内执行了一个<code class="fe mz na nb nc b">return</code>语句，TypeScript会很聪明地从条件块外的<code class="fe mz na nb nc b">union</code>中删除该类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">型守卫现在没那么恐怖了吧？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dbc7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 2。===而且！==运算符</strong></h1><p id="c36e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">typeof</code>是你日常打字使用的一个基本工具。它最常用于从值对象中提取TypeScript类型。它将值对象移植回TypeScript的类型。</p><p id="f169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要混淆，因为JavaScript有自己的<code class="fe mz na nb nc b">typeof</code>操作符，它返回一个表示未赋值操作数类型的字符串。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="124a" class="nj md it nc b gy nk nl l nm nn">// Typescript<br/>const literal = 'literal type';<br/>type literal = typeof literal; // literal = 'literal type'</span><span id="7a9c" class="nj md it nc b gy no nl l nm nn">// Javascript<br/>const literal = 'literal type';<br/>typeof literal; // 'string'</span></pre><p id="4730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe mz na nb nc b">typeof</code>提取类型的另一个例子:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="8dfa" class="nj md it nc b gy nk nl l nm nn">interface Book {<br/>  author: string;<br/>}</span><span id="9cb0" class="nj md it nc b gy no nl l nm nn">const b: Book = { author: 'jose granja'};</span><span id="2bca" class="nj md it nc b gy no nl l nm nn">type C = typeof b; // we have extracted the type Book from b</span></pre><p id="25f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将<code class="fe mz na nb nc b">typeof</code>与操作符<code class="fe mz na nb nc b">!==</code>或<code class="fe mz na nb nc b">===</code>结合起来执行类型保护。</p><p id="b16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个<code class="fe mz na nb nc b">string | number</code>类型的联合入口参数创建我们自己的<code class="fe mz na nb nc b">fizzBuzz</code>。当变量是一个<code class="fe mz na nb nc b">string</code>时，我们将打印<code class="fe mz na nb nc b">Fizz</code>。当它是一个数字时，我们将打印<code class="fe mz na nb nc b">Buzz</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有<code class="fe mz na nb nc b">typeof</code>操作符，我们无法从<code class="fe mz na nb nc b">x</code>中提取类型。这就是它如此重要、基本和强大的原因。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2ae0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.实例of</h1><p id="353d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可能对JavaScript <code class="fe mz na nb nc b">instanceof</code>操作符很熟悉。这个操作符类似于<code class="fe mz na nb nc b">typeof</code>，但是它的使用主要集中在ECMAScript类上。右边的运算符需要是一个类。否则，我们会得到一个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e551" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.类型断言</h1><p id="d2f7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些是最手工的。它们基于开发人员对代码的了解。这就是为什么应该尽可能避免它们。然而，它们是你可以使用的工具，你应该意识到它们。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3fc5" class="nj md it nc b gy nk nl l nm nn">function addOne(x: unknown) {<br/>  // devs knows x will always be a number<br/>  return x as number + 1;<br/>}</span></pre><p id="266d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe mz na nb nc b">as</code>关键字手动更改变量类型。你可以从一个通用类型到一个更具体的类型。但是，如果这两种类型不相关，您需要先转换为<code class="fe mz na nb nc b">unknown/any</code>:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="dd87" class="nj md it nc b gy nk nl l nm nn">const x: number = 12;</span><span id="bd1b" class="nj md it nc b gy no nl l nm nn">const a: string = x; // Type 'number' is not assignable to type 'string'</span><span id="3b0d" class="nj md it nc b gy no nl l nm nn">const b: string = x as unknown as string; // Type 'number' was converted to 'string'</span></pre><p id="f0b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，输入是错误的，因为我们将一个<code class="fe mz na nb nc b">number</code>赋值给一个<code class="fe mz na nb nc b">string</code>。编译器确实信任我们，即使它看起来是错误的，因为我们对此非常明确。这就是为什么要避免这种选角。</p><p id="33ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的<code class="fe mz na nb nc b">addOne</code>示例中，如果我们正确地输入了函数param，我们可以移除类型保护:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="2884" class="nj md it nc b gy nk nl l nm nn">function addOne(x: number) {<br/> return x + 1; // no type guard needed<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="04f9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.歧视工会</h1><p id="0cae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以使用<code class="fe mz na nb nc b">literal</code>类型与类型保护装置一起工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="947a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来并没有那么花哨…但是让我们让<code class="fe mz na nb nc b">'hunter' | 'pray'</code>成为一些接口类型保护的关键。</p><p id="c67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先定义两个相似的接口，它们具有相同的<code class="fe mz na nb nc b">kind</code>属性，但是类型不同。这样，我们可以通过断言<code class="fe mz na nb nc b">kind</code>属性来知道哪个接口是调用者的类型。TypeScript将自动区分联合类型，并在函数范围内分配正确的类型。</p><p id="36e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Typescript中，它被称为<code class="fe mz na nb nc b">Discriminated Union</code>:您正在使用一个文字成员来区分联合成员。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在TypeScript中使用<code class="fe mz na nb nc b">enum</code>以一种更简洁的方式来做到这一点。受歧视的工会也与<code class="fe mz na nb nc b">enums</code>合作。这使得我们的代码不容易出现类型和打字错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1092" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.用户定义的Using谓词</h1><p id="a913" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些比之前的要复杂一点。您可以为任何给定的类型定义类似函数的断言。我们只需要定义一个返回类型为<code class="fe mz na nb nc b">type predicate</code>的函数，它返回<code class="fe mz na nb nc b">true/false</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意函数<code class="fe mz na nb nc b">isHunter</code>的返回类型是<code class="fe mz na nb nc b">x is Hunter</code>。这是因为它是一个断言函数，这也是它返回<code class="fe mz na nb nc b">true</code>或<code class="fe mz na nb nc b">false</code>的原因。</p><p id="1490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码块<code class="fe mz na nb nc b">isHunter(x)</code>中，<code class="fe mz na nb nc b">x</code>变量的类型为<code class="fe mz na nb nc b">Hunter</code>。这意味着我们可以安全地调用它的<code class="fe mz na nb nc b">hunt</code>方法。然而，在这个代码块之外，<code class="fe mz na nb nc b">x</code>类型仍然是<code class="fe mz na nb nc b">unknown</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="af7d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.用户定义的使用in运算符</h1><p id="5910" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">还有另一种方法，那就是使用<code class="fe mz na nb nc b">in</code>操作符。JavaScript确实有一个类似的操作符，它的行为方式也类似。它的目的是检查接口/类型中是否存在给定的属性。</p><p id="b3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重复前面的例子，但这次使用<code class="fe mz na nb nc b">in</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过检查方法<code class="fe mz na nb nc b">hide</code>或<code class="fe mz na nb nc b">hunt</code>的存在来区分<code class="fe mz na nb nc b">Hunter/Pray</code>类型。</p><p id="f6b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">何时使用这种方法与前一种方法将取决于代码风格和用例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5101" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">警卫和回调类型</h1><p id="caf3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">类型守卫和回调有一个特殊的行为值得了解。让我们用一些例子来验证一下:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="dd46" class="nj md it nc b gy nk nl l nm nn">let x: string | number = "a";</span><span id="9737" class="nj md it nc b gy no nl l nm nn">if (typeof x === "string") {<br/>  console.log(x.split(' ')[0]); // x is of type string as expected<br/>}</span></pre><p id="f688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在回调中使用像<code class="fe mz na nb nc b">x</code>这样的可变变量，TypeScript将不会考虑类型保护。它会将<code class="fe mz na nb nc b">x</code>视为<code class="fe mz na nb nc b">setTimeout</code>回调中的<code class="fe mz na nb nc b">string | number</code>，并因此抛出一个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="31d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是因为TypeScript不确定什么时候调用，而在那段时间内，<code class="fe mz na nb nc b">x</code>可以改变它的类型。TypeScript不可能判断变量是否会改变它的类型，所以它给出一个错误作为预防措施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果变量不是可变的，这就不会发生。如果我们将其定义为<code class="fe mz na nb nc b">const x</code>，而不是<code class="fe mz na nb nc b">let x</code>，那么将不会抛出错误，因为该变量的值是密封的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4c2f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/835429be15fd64d29622e7ecd214f73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HeTdTEL565WgNJBK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">瓦西里·科洛达在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="bba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了使用类型保护的不同方法。根据经验，你不应该滥用它们。</p><p id="4b5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是，就要分析一下为什么这么经常需要它们。幕后可能有更大的问题在发生。它们只是为了在一些特定的场景中使用。</p><p id="02d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想继续提高您的类型脚本技能，我写了一篇关于映射类型的文章，值得一看:</p><div class="nq nr gp gr ns nt"><a href="https://medium.com/better-programming/mastering-typescripts-mapped-types-5fa5700385eb" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">掌握TypeScript的映射类型</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">了解如何像专家一样处理Typescript映射类型</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><p id="cb75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将来会有更多的TypeScript内容出现。干杯！</p></div></div>    
</body>
</html>