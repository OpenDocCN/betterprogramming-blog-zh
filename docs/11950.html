<html>
<head>
<title>How to Use GitHub Webhooks, Docker, and Python for Automatic End-to-End Deployments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用GitHub Webhooks、Docker和Python进行自动端到端部署</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/github-webhooks-docker-and-python-for-automatic-app-deployments-a7f18d23d5b7?source=collection_archive---------1-----------------------#2022-04-29">https://betterprogramming.pub/github-webhooks-docker-and-python-for-automatic-app-deployments-a7f18d23d5b7?source=collection_archive---------1-----------------------#2022-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0b56" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解自动更新应用程序的流程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/359e27d6c12554229364b66ac5b5657c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_b5eEcBkRTLFSHyqKns6yA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">通过Webhooks和API的</strong> <br/>回购应用程序(图片由作者提供，来源<a class="ae kw" href="https://viewer.diagrams.net/?tags=%7B%7D&amp;highlight=0000ff&amp;edit=_blank&amp;layers=1&amp;nav=1&amp;title=diagrams.drawio#Uhttps%3A%2F%2Fraw.githubusercontent.com%2Fchrimaho%2Fupdate-from-git%2Fmain%2Fblog%2Fdiagrams%2Fdiagrams.drawio" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/blog/diagrams/cover-image.png" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><h1 id="d6e5" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">目录</h1><p id="bc51" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">1.<a class="ae kw" href="#c73a" rel="noopener ugc nofollow">动机</a> <br/> <a class="ae kw" href="#241b" rel="noopener ugc nofollow"> <strong class="lr ir">第一节:语境及概述</strong> </a> <strong class="lr ir"> <br/> </strong> 2 .<a class="ae kw" href="#b214" rel="noopener ugc nofollow">上下文</a> <br/> 3。<a class="ae kw" href="#0fdc" rel="noopener ugc nofollow">其他方法</a> <br/> — 3.1。<a class="ae kw" href="#637e" rel="noopener ugc nofollow">手动流程</a><br/>———3 . 1 . 1。<a class="ae kw" href="#c1cb" rel="noopener ugc nofollow">优点</a> <br/> — — 3.1.2。<a class="ae kw" href="#8ff4" rel="noopener ugc nofollow">缺点</a> <br/> — 3.2 <a class="ae kw" href="#1337" rel="noopener ugc nofollow"> Docker流程</a><br/>———3 . 2 . 1。<a class="ae kw" href="#5ddb" rel="noopener ugc nofollow">优点</a><br/>———3 . 2 . 2。<a class="ae kw" href="#ba70" rel="noopener ugc nofollow">缺点</a> <br/> <a class="ae kw" href="#2aa5" rel="noopener ugc nofollow"> <strong class="lr ir">第二节:关于App的细节</strong> </a> <strong class="lr ir"> <br/> </strong> 4。<a class="ae kw" href="#9220" rel="noopener ugc nofollow">自动化的Webhook是方法</a> <br/> 5。<a class="ae kw" href="#ffad" rel="noopener ugc nofollow">关键档案</a> <br/> — 5.1说明。<a class="ae kw" href="#4aeb" rel="noopener ugc nofollow">File:/requirements . txt</a><br/>—5.2。<a class="ae kw" href="#9d9d" rel="noopener ugc nofollow">文件:/docker/uvicon。Dockerfile </a> <br/> — 5.3。<a class="ae kw" href="#def7" rel="noopener ugc nofollow">File:/docker/docker-compose . yml</a><br/>———5 . 3 . 1。<a class="ae kw" href="#4881" rel="noopener ugc nofollow">环境部分</a><br/>———5 . 3 . 2。<a class="ae kw" href="#a56b" rel="noopener ugc nofollow">各卷第</a>节<br/>———5 . 3 . 3。<a class="ae kw" href="#6781" rel="noopener ugc nofollow">港口段</a> <br/> — 5.4。<a class="ae kw" href="#3e61" rel="noopener ugc nofollow">File:/src/API/main . py</a><br/>———5 . 4 . 1。<a class="ae kw" href="#ce60" rel="noopener ugc nofollow">导入库</a> <br/> — — 5.4.2。<a class="ae kw" href="#7b66" rel="noopener ugc nofollow">编译变量</a><br/>———5 . 4 . 3。<a class="ae kw" href="#d1d7" rel="noopener ugc nofollow">设置登陆页面</a><br/>———5 . 4 . 4。<a class="ae kw" href="#3b74" rel="noopener ugc nofollow">实例化App</a><br/>———5 . 4 . 5。<a class="ae kw" href="#177d" rel="noopener ugc nofollow">设置自定义功能</a><br/>———5 . 4 . 6。<a class="ae kw" href="#c939" rel="noopener ugc nofollow">设置自定义类别</a><br/>———5 . 4 . 7。<a class="ae kw" href="#55bd" rel="noopener ugc nofollow">定义端点:登陆页面</a><br/>———5 . 4 . 8。<a class="ae kw" href="#6cef" rel="noopener ugc nofollow">定义终点:健康检查</a><br/>———5 . 4 . 9。<a class="ae kw" href="#cd20" rel="noopener ugc nofollow">定义端点:主端点</a> <br/> — 5.5。<a class="ae kw" href="#39e4" rel="noopener ugc nofollow">File:/templates/landing _ page . html</a><br/><a class="ae kw" href="#2088" rel="noopener ugc nofollow"><strong class="lr ir">第三节:如何使用App</strong></a><strong class="lr ir"><br/></strong>6 .<a class="ae kw" href="#65ea" rel="noopener ugc nofollow">如何使用</a>T107】—6.1。<a class="ae kw" href="#ecb0" rel="noopener ugc nofollow">创建服务器(使用AWS) </a> <br/> — 6.1。<a class="ae kw" href="#a07e" rel="noopener ugc nofollow">添加docker-compose.yml文件</a> <br/> — 6.1。<a class="ae kw" href="#0b25" rel="noopener ugc nofollow">在服务器上启动Docker</a><br/>—6.1。<a class="ae kw" href="#a5e6" rel="noopener ugc nofollow">在Git上添加Webhook(使用GitHub) </a> <br/> — 6.1。<a class="ae kw" href="#faf0" rel="noopener ugc nofollow">测试一下</a> <br/> <a class="ae kw" href="#7fac" rel="noopener ugc nofollow"> <strong class="lr ir">第四节:更多信息</strong> </a> <strong class="lr ir"> <br/> </strong> 7。<a class="ae kw" href="#1f33" rel="noopener ugc nofollow">下一步是什么</a> <strong class="lr ir"> <br/> </strong> 8。<a class="ae kw" href="#cc2c" rel="noopener ugc nofollow">在哪里可以找到更多信息</a> <br/> 9。<a class="ae kw" href="#76bf" rel="noopener ugc nofollow">完整文件为:/src/api/main.py </a> <br/> 10。<a class="ae kw" href="#22a6" rel="noopener ugc nofollow">联系人</a></p><h1 id="c73a" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">1.动机</h1><p id="03f8" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">如果你和我一样，你就是一个好奇的生物。所以，当我开始学习什么是<a class="ae kw" href="https://en.wikipedia.org/wiki/Webhook" rel="noopener ugc nofollow" target="_blank">网钩</a>以及如何使用它们时，感觉就像是在拉我t恤上的一根松线。我拉得越多，Webhooks的世界就解开得越多，我学得越多，我理解得越多，我就越揭开API、Webhooks和自动化的神秘世界，我就越想了解更多！</p><p id="ac95" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">因此，这里的动机是创建一种从GitHub到生产服务器的简化的无缝部署方式。我觉得编写一个简单的Python应用程序来实现这一点是可能的。所以让我们来看看怎么做吧！</p><p id="6509" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">本文将分为四个部分，每个部分概述了这个过程的不同方面。第二部分非常详细，但是我已经尽可能多地包含了必要的描述和截图，以便更容易理解这里发生的事情。<a class="ae kw" href="#2088" rel="noopener ugc nofollow">第三部分</a>包含如何使用该应用程序的实际操作说明。尽情享受吧！</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="241b" class="kx ky iq bd kz la mx lc ld le my lg lh jw mz jx lj jz na ka ll kc nb kd ln lo bi translated">第一部分:背景和概述</h1><h1 id="b214" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">2.语境</h1><p id="740a" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我现在已经编码几年了，在<a class="ae kw" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>(还有<a class="ae kw" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank"> GitLab </a>，还有其他几个)上有不少回购。我看到这个按钮:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/a6c90751b0266a410203464d9570b41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_AOnXQYX4aL5B1HkRur6ng.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">GitHub&gt;*</strong><code class="fe nd ne nf ng b"><strong class="bd kv">Repo</strong></code><strong class="bd kv">*&gt;设置&gt; Webhooks &gt;添加webhook </strong> <br/>(图片作者)</p></figure><p id="2cc2" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">因此，我在GitHub的<a class="ae kw" href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks" rel="noopener ugc nofollow" target="_blank"> Webhooks指南</a>页面上读到了一些关于它的内容，以及一些关于如何设置它的博客(比如<a class="ae kw" href="https://medium.com/@samarthgvashist2000/setting-up-a-github-webhook-ccd895e7b85c" rel="noopener">这个</a>和<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/how-to-automatically-deploy-from-github-to-server-using-webhook-79f837dcc4f4">这个</a>)。我的理解是这样的:</p><blockquote class="nh ni nj"><p id="5783" class="lp lq nk lr b ls ml jr lu lv mm ju lx nl mn ma mb nm mo me mf nn mp mi mj mk ij bi translated">当你在一个Repo上设置Webhooks，你<code class="fe nd ne nf ng b">commit</code>然后<code class="fe nd ne nf ng b">push</code>到Repo，GitHub会自动发送一个HTTP <code class="fe nd ne nf ng b">POST</code>请求到你指定的URL。</p></blockquote><p id="0901" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">该请求的有效负载将包含来自GitHub的事件的<em class="nk">元数据</em>，但不包含来自Repo本身的内容。因此，<em class="nk">接收</em>web hook请求的系统将需要采取某种行动来从回购中获取<code class="fe nd ne nf ng b">pull</code>或<code class="fe nd ne nf ng b">clone</code>最新数据。</p><p id="a27e" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">这种Webhook方法并不是GitHub所独有的，GitLab和BitBucket和许多其他Git平台也可以使用。</p><h1 id="56ee" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">3.其他方法</h1><p id="c652" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">首先，重要的是要明白有很多很多(<em class="nk">很多！</em>)在生产环境中部署应用的不同方式。让我们看看另外两种常见的方法:</p><h2 id="637e" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">3.1.手动过程</h2><p id="48cb" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">手动干预过程如下所示:</p><ol class=""><li id="e216" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk of og oh oi bi translated">在本地PC上做<code class="fe nd ne nf ng b">git commit</code>，然后<code class="fe nd ne nf ng b">git push</code>推送到上游回购。</li><li id="dc50" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">当准备部署时，要手动将<code class="fe nd ne nf ng b">ssh</code>放到目标服务器上。</li><li id="2830" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">To do <code class="fe nd ne nf ng b">git clone</code>(如果是第一次)或<code class="fe nd ne nf ng b">git pull</code>(对于后续更新)从Repo获取最新代码到服务器。</li></ol><p id="fe81" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">显然，这个手动过程有很多步骤，非常复杂。但是，我只将它放在高级部署步骤中，这样您就可以了解这个过程。</p><p id="c1cb" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 3.1.1。优点:<br/> </strong> —易于维护<br/> —开发人员拥有完全控制权<br/> —不需要/依赖外部工具或应用程序(如Docker)</p><p id="8ff4" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 3.1.2。缺点:<br/> </strong> —部署时需要开发者的时间、精力、注意力<br/> —一步走错，容易出错；开发人员甚至可能直到很久以后才意识到这一点<br/>——除了这个Git过程之外，任何依赖项(如其他应用程序、其他库等)都需要手动执行。</p><h2 id="1337" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">3.2.码头工艺</h2><p id="48ef" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">Docker 应用程序大大简化了这个过程，让开发者的生活变得更加轻松。高级流程是:</p><ol class=""><li id="3a5f" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk of og oh oi bi translated">在本地PC上运行<code class="fe nd ne nf ng b">docker build</code>和<code class="fe nd ne nf ng b">docker run</code>以确保图像/容器正常工作(这可以通过运行<code class="fe nd ne nf ng b">docker compose up</code>来简化)</li><li id="7627" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">使用<code class="fe nd ne nf ng b">docker login</code>发布容器，然后使用<code class="fe nd ne nf ng b">docker push</code>将容器上传到容器存储库(这可以是<a class="ae kw" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank"> AWS ECR </a>或<a class="ae kw" href="https://azure.microsoft.com/en-us/services/container-registry/" rel="noopener ugc nofollow" target="_blank"> Azure ACR </a>或<a class="ae kw" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>，或任何其他容器托管平台)</li><li id="b46d" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">然后到服务器上的<code class="fe nd ne nf ng b">ssh</code>，做<code class="fe nd ne nf ng b">docker pull</code>，接下来是<code class="fe nd ne nf ng b">docker build</code>和<code class="fe nd ne nf ng b">docker run</code>(或者只是简单的<code class="fe nd ne nf ng b">docker compose up</code>，假设编写文件设置正确)。</li></ol><p id="86fb" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">虽然看起来这个过程中有更多的步骤，但实际上这个过程要简单得多。因为它不是通过部署<em class="nk">一个Git仓库，而是一个容器仓库。意思是说，容器可以完全构建并在本地PC上运行，当部署到服务器时，它将以完全相同的方式运行。</em></p><p id="5ddb" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 3.2.1。优点:</strong> <br/> — Docker会在任何系统上运行，完全一样的方式；所以它是非常可靠的<br/>——所有的依赖都已经通过Docker处理了，因此开发人员需要更少的努力/专注/关注</p><p id="ba70" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">3.2.2。缺点: <br/> —配置设置有时会有点混乱<br/> —如果开发人员不熟悉Docker，设置和调试可能需要一点时间才能完成</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="2aa5" class="kx ky iq bd kz la mx lc ld le my lg lh jw mz jx lj jz na ka ll kc nb kd ln lo bi translated">第二部分:应用程序的详细信息</h1><h1 id="9220" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">4.自动化Webhook方法</h1><p id="6860" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">这个过程很容易自动化。这里的解决方案是创建一个非常非常简单的Python应用程序(使用<a class="ae kw" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>)，它将接收来自Git的HTTP <code class="fe nd ne nf ng b">POST</code>请求，然后调用一个Python脚本来<code class="fe nd ne nf ng b">pull</code>来自Git上游Repo的最新更新。它与上述手动过程非常相似；其中开发者将<code class="fe nd ne nf ng b">pull</code>来自回购的最新代码。然而，这里的不同之处在于，我们将使用Python的力量来自动为我们拉取最新的代码。</p><p id="ab94" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">端到端流程如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/5907521f16e895d038dcfb8cd5cda655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUyA65T0u8eEuTpzBn9uqQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">端到端流程<br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://viewer.diagrams.net/?tags=%7B%7D&amp;highlight=0000ff&amp;edit=_blank&amp;layers=1&amp;nav=1&amp;page-id=I7LHdRjH9WNjt-zTn0nW&amp;title=diagrams.drawio#Uhttps%3A%2F%2Fraw.githubusercontent.com%2Fchrimaho%2Fupdate-from-git%2Fmain%2Fblog%2Fdiagrams%2Fdiagrams.drawio" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/blog/diagrams/end-to-end.png" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="d24c" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">一步一步来看，这是正在发生的事情:</p><ol class=""><li id="d22b" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk of og oh oi bi translated">开发者将在他们的本地电脑上开发应用程序</li><li id="b550" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">开发者会将更新推送到上游Git repo(本例中，我们使用GitHub但是任何其他托管平台也可以工作)，</li><li id="04b4" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">然后Git Repo将触发Webhook进程，并向指定的URL发送HTTP <code class="fe nd ne nf ng b">POST</code>请求，</li><li id="dfd3" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">那个URL后面是一个IP地址，应该托管在一个云计算平台上(这里我们用AWS，但是其他任何云计算平台，比如Azure也可以)，</li><li id="9d02" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">取决于Git repo使用HTTP还是HTTPS，它将在端口<code class="fe nd ne nf ng b">80</code>(HTTP)或端口<code class="fe nd ne nf ng b">443</code>(HTTPS)上攻击服务器，</li><li id="0d6a" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">然后，服务器会将其端口<code class="fe nd ne nf ng b">80</code>和端口<code class="fe nd ne nf ng b">443</code>暴露给公众，以允许网络流量通过。</li><li id="aa22" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">托管在服务器上的是Docker容器，该容器会将外部端口<code class="fe nd ne nf ng b">80</code>和<code class="fe nd ne nf ng b">443</code>映射到内部端口<code class="fe nd ne nf ng b">8880</code>，然后可以由内部应用程序使用，</li><li id="0b7e" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">安装在Docker容器中的是FastAPI应用程序，它将监听端口<code class="fe nd ne nf ng b">8880</code>和由开发者定义的端点，</li><li id="e19b" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">一旦HTTP <code class="fe nd ne nf ng b">POST</code>消息命中端点URL，那么FastAPI应用程序将调用一个Python脚本，</li><li id="93de" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">该Python脚本将触发一个<code class="fe nd ne nf ng b">git clone</code>(或<code class="fe nd ne nf ng b">git pull</code>)进程从上游repo获取最新代码，</li><li id="f62d" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">Python然后会将该信息保存到Docker上的一个目录中(在本例中，我们将它保存到<code class="fe nd ne nf ng b">/app/repo</code>目录中，但这是可配置的，您可以将其保存到任何地方)，</li><li id="3d35" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">Docker随后将使用一个名为<a class="ae kw" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">卷映射</a>的过程将容器上该目录的数据持久化到容器外的一个目录中(这意味着一旦容器上的<code class="fe nd ne nf ng b">/app/repo</code>目录被更新，容器外的<code class="fe nd ne nf ng b">/repo</code>目录也将立即被更新)，</li><li id="bd85" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">一旦在服务器级更新了<code class="fe nd ne nf ng b">/repo</code>目录，就可以根据需要执行任何其他应用程序。</li></ol><p id="4f4e" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">对于精明的人来说，你会注意到，将多个Docker容器聚集在一起实际上是可能的，这样一个容器将自己运行应用程序，而不是依赖于服务器级别来运行它。对，没错，而且这样做也很常见。然而，为了简单起见，我在这里保留了这个过程，以便简单地展示从Git到服务器的Webhook过程。以此为基础，就有可能增加更多的复杂性。</p><h1 id="a099" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">5.关键文件的说明</h1><p id="634e" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在这个过程中使用了许多关键文件。接下来的几节将详细解释这些文件。</p><h2 id="4aeb" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">5.1.File: /requirements.txt</h2><p id="7db6" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">要求超级简单。我们只需要三个包:</p><ol class=""><li id="8d51" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk of og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank">fastapi</a></code>:实际构建API端点</li><li id="8535" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://gitpython.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">gitpython</a></code>:来自上游回购的<code class="fe nd ne nf ng b">clone</code>/<code class="fe nd ne nf ng b">pull</code></li><li id="99e3" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://pypi.org/project/python-decouple/" rel="noopener ugc nofollow" target="_blank">python-decouple</a></code>:用于处理默认环境变量</li></ol><p id="e824" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">将会有一些其他的库在运行时被导入；然而，这些将是Python内置的一部分，不需要添加到<code class="fe nd ne nf ng b">requirements.txt</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="ak"> /requirements.txt <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/wn0OdSeb5pxMP6doAnLO" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/requirements.txt" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/e86f7fb846fcceec001e975506fa4cd1" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><h2 id="9d9d" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">5.2.文件:/docker/uvicon。Dockerfile文件</h2><p id="e16a" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在<a class="ae kw" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>的世界里，<code class="fe nd ne nf ng b"><a class="ae kw" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code>是一组应该在特定容器上执行的“指令”,以便为它的操作进行设置。趁着还有很多很多(<em class="nk">很多</em>！)，不同的选项和配置可用，这里我们保持事情相当简单。</p><p id="5cfb" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">具体步骤是:</p><ol class=""><li id="2bb6" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk of og oh oi bi translated">使用基本映像作为<code class="fe nd ne nf ng b"><a class="ae kw" href="https://hub.docker.com/r/tiangolo/uvicorn-gunicorn-fastapi" rel="noopener ugc nofollow" target="_blank">tiangolo/uvicorn-gunicorn-fastapi</a></code>，它包含了建立和运行服务器以成功运行FastAPI所需的所有源基础设施。</li><li id="ead8" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">将本地环境中的<code class="fe nd ne nf ng b">requirements.txt</code>文件复制到容器中。</li><li id="abdf" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">运行三个不同的PIP语句来:<br/> 1 .升级<code class="fe nd ne nf ng b"><a class="ae kw" href="https://pip.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank">pip</a></code>，万一过时，<br/> 2。从<code class="fe nd ne nf ng b">requirements.txt</code>文件<br/> 3安装软件包。升级<code class="fe nd ne nf ng b"><a class="ae kw" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uvicorn</a></code>包，以防它过时。</li><li id="1f07" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">从本地环境的<code class="fe nd ne nf ng b">src</code>和<code class="fe nd ne nf ng b">templates</code>目录中复制所有需要的文件到容器中。</li><li id="5479" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">将容器内的工作目录设置为<code class="fe nd ne nf ng b">/app</code>目录。</li><li id="e241" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">设置命令行，该命令行将在容器构建完成并准备运行时执行。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="ak">/docker/uvicon。Dockerfile <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/JzjQqSh7Jv7KTOjgWlIS" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/docker/uvicorn.Dockerfile" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/c25d5b4031d0f9eef5c99fe4cd27e78f" rel="noopener ugc nofollow" target="_blank">这里</a>)</p></figure><p id="622e" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">最后一行(即<code class="fe nd ne nf ng b">CMD</code>那一行)相当有趣。让我指出一些重要的信息:</p><ul class=""><li id="19f5" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk or og oh oi bi translated">它将执行<code class="fe nd ne nf ng b">uvicorn</code>应用程序，这实际上是一个用于处理FastAPI进程和命令的服务器</li><li id="d786" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated">它将执行在<code class="fe nd ne nf ng b"><a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py" rel="noopener ugc nofollow" target="_blank">main.py</a></code>模块中被称为<code class="fe nd ne nf ng b"><a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L65" rel="noopener ugc nofollow" target="_blank">app</a></code>的应用程序。</li><li id="b4a2" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated"><code class="fe nd ne nf ng b">main.py</code>模块实际上位于容器的子目录中，可以在<code class="fe nd ne nf ng b">/src/api</code>目录中找到。</li><li id="e7c0" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated">它被托管来监控IP地址:<code class="fe nd ne nf ng b">0.0.0.0</code>。这实际上是在说“监控本地主机”。这是因为外部系统(通过URL)使用服务器IP地址，但是信号在服务器内部，它将在本地主机IP上找到。因此，Uvicorn只需要监视服务器本身的本地主机。</li><li id="f6f0" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated">系统将监控端口<code class="fe nd ne nf ng b">8880</code>，这就是为什么将外部端口映射到内部端口很重要的原因(这将在下一节关于<code class="fe nd ne nf ng b">docker-compose.yml</code>文件的内容中介绍)。</li><li id="71c3" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated">应用程序的根路径在当前文件夹中(用<code class="fe nd ne nf ng b">"."</code>语法表示)。</li><li id="8c5e" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated">应用程序的输出将被打印到终端上，使用一些漂亮的颜色；这有助于以后阅读日志文件和消息。</li></ul><h2 id="def7" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">5.3.文件:<code class="fe nd ne nf ng b">/docker/docker-compose.yml</code></h2><p id="efe9" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在Dockerfile之后，<code class="fe nd ne nf ng b"><a class="ae kw" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank">docker-compose.yml</a></code>文件是逻辑上的下一步，它将再次进一步处理这个过程。它可以用来创建容器集群，每个容器都可以被设置为协同工作并相互依赖。虽然这是一个令人惊奇的功能，但它不是我们这里的目的所需要的。在这种情况下，我们将只需要一个容器，它将使用上面定义的Dockerfile来构建。我们之所以使用<code class="fe nd ne nf ng b">docker-compose.yml</code>方法是因为它很方便；它允许轻松添加<code class="fe nd ne nf ng b">environment</code>变量和<code class="fe nd ne nf ng b">volume</code>映射。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/docker/docker-compose.yml</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/DXPEYxx2Mv8sE9gTz2FR" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/docker/docker-compose-sample-local.yml" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/741c96e658833e509a8e547982b3ce1e" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="c1ac" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">注意，这是一个<code class="fe nd ne nf ng b">docker-compose.yml</code>的样本文件。从中提取数据的Git URL实际上并不是一个应用程序(仅仅是代码片段的集合)。因此，这仅仅是展示如何设置应用程序的过程。</p><p id="4881" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">5.3.1。 <code class="fe nd ne nf ng b"><strong class="lr ir">environment</strong></code> <strong class="lr ir">章节:</strong></p><p id="096b" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">有9个值可以/应该包含在<code class="fe nd ne nf ng b">environment</code>部分，包括:</p><ol class=""><li id="22cc" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk of og oh oi bi translated"><code class="fe nd ne nf ng b">GIT_URL </code> ( <em class="nk">强制</em>):从中克隆回购的URL。</li><li id="4406" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b">API_ENDPOINT </code> ( <em class="nk">可选</em>，默认<code class="fe nd ne nf ng b">/api/webhook</code>):web hook将调用的端点。</li><li id="b4bd" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b">REPO_DIR </code> ( <em class="nk">强制</em>):回购将被克隆到的目录。</li><li id="f42b" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b">VERSION </code> ( <em class="nk">可选</em>，默认<code class="fe nd ne nf ng b">0.0.1</code>):app的版本号。</li><li id="307f" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b">TITLE </code> ( <em class="nk">可选</em>，默认<code class="fe nd ne nf ng b">Update from Git</code>):app的标题。</li><li id="91ec" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b">DESCRIPTION </code> ( <em class="nk">可选</em>，默认<code class="fe nd ne nf ng b">Automated process for pulling from Git repo upon webhook call.</code>):app的描述。</li><li id="8b0e" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b">CONTACT_NAME </code> ( <em class="nk">可选</em>，默认<code class="fe nd ne nf ng b">None</code>):关于app的联系人姓名。</li><li id="d124" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b">CONTACT_URL </code> ( <em class="nk">可选</em>，默认<code class="fe nd ne nf ng b">None</code>):联系人的网址。</li><li id="d2e4" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated"><code class="fe nd ne nf ng b">CONTACT_EMAIL </code> ( <em class="nk">可选</em>，默认<code class="fe nd ne nf ng b">None</code>):联系人的电子邮件。</li></ol><p id="3674" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">更多详情见<a class="ae kw" href="https://github.com/chrimaho/update-from-git#explanation-on-the-environment-variables" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="a56b" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.3.2。</strong> <code class="fe nd ne nf ng b"><strong class="lr ir">volumes</strong></code> <strong class="lr ir">部分:</strong></p><p id="0c39" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">以便利用父容器(即服务器)和Docker容器中，<a class="ae kw" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">卷</a>部分是为实现两个环境之间的持久性而设计的机制。实际上，冒号(<code class="fe nd ne nf ng b">:</code>)左边的值是父容器<em class="nk">上的目录位置，右边的值是Docker </em>容器本身上的目录位置。这样，对任何一个目录的任何更改都会立即更新另一个目录。</p><p id="d5ba" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">默认值:</p><pre class="kg kh ki kj gt os ng ot ou aw ov bi"><span id="05d2" class="no ky iq ng b gy ow ox l oy oz">- ../repo:/app/repo</span></pre><p id="6781" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">5.3.3。 <code class="fe nd ne nf ng b"><strong class="lr ir">ports</strong></code> <strong class="lr ir">章节:</strong></p><p id="2dfd" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><a class="ae kw" href="https://docs.docker.com/compose/networking/" rel="noopener ugc nofollow" target="_blank">端口映射</a>对于确保外部端口能够正确映射到Docker中的内部进程非常重要。因为端口<code class="fe nd ne nf ng b">80</code>用于HTTP，而端口<code class="fe nd ne nf ng b">443</code>用于HTTPS进程，所以期望任何上游Git进程使用其中任何一个都是合理的。由于FastAPI应用程序正在监听端口<code class="fe nd ne nf ng b">8880</code>，因此将这两个外部端口(<code class="fe nd ne nf ng b">80</code>和<code class="fe nd ne nf ng b">443</code>)映射到内部端口<code class="fe nd ne nf ng b">8880</code>是合乎逻辑的。对于服务器来说,<code class="fe nd ne nf ng b">8880:8880</code>的映射可能是多余的，但是这里包含了它，因为它对于在本地PC上进行测试是必要的。</p><p id="4946" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">为了便于参考，冒号(<code class="fe nd ne nf ng b">:</code>)左边的值是<em class="nk">外部</em>端口，右边的值是<em class="nk">内部</em>端口。</p><p id="c8d7" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">默认值:</p><pre class="kg kh ki kj gt os ng ot ou aw ov bi"><span id="f5df" class="no ky iq ng b gy ow ox l oy oz">- 8880:8880<br/>- 443:8880<br/>- 80:8880</span></pre><h2 id="3e61" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">5.4.文件:/src/api/main.py</h2><p id="9059" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">由于文件的大小，我把它分成了几个部分，并分别解释了每一部分。完整文件复制到本文末尾(见<a class="ae kw" href="#76bf" rel="noopener ugc nofollow">此处</a>)。</p><p id="ce60" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.4.1。导入库</strong></p><p id="a12f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">首先要做的是导入所需的库。这种结构的方式是不从每个库中导入完整的代码库；而是仅从每一个导入所需的函数/类。</p><p id="1171" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">更具体地说:</p><ul class=""><li id="f874" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk or og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://docs.python.org/3/library/sys.html#sys.exc_info" rel="noopener ugc nofollow" target="_blank">exec_info</a></code>用于处理错误并通过API返回错误</li><li id="4f65" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://github.com/henriquebastos/python-decouple/#usage" rel="noopener ugc nofollow" target="_blank">config</a></code>用于处理默认环境变量</li><li id="d209" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/tutorial/first-steps/#first-steps" rel="noopener ugc nofollow" target="_blank">FastAPI</a></code>和<code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/tutorial/query-params/#query-parameters" rel="noopener ugc nofollow" target="_blank">Query</a></code>用于运行API端点</li><li id="2e78" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/tutorial/response-model/?h=base+model#response-model" rel="noopener ugc nofollow" target="_blank">BaseModel</a></code>为迂腐(或‘pydantic’😂)通过API端点处理对象的方法</li><li id="3f02" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/advanced/custom-response/?h=htmlresponse#plaintextresponse" rel="noopener ugc nofollow" target="_blank">PlainTextResponse</a></code>、<code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/advanced/custom-response/?h=htmlresponse#jsonresponse" rel="noopener ugc nofollow" target="_blank">JSONResponse</a></code>和<code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/advanced/custom-response/?h=htmlresponse#htmlresponse" rel="noopener ugc nofollow" target="_blank">HTMLResponse</a></code>是FastAPI端点将返回的特定对象</li><li id="a2f9" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://gitpython.readthedocs.io/en/stable/tutorial.html#meet-the-repo-type" rel="noopener ugc nofollow" target="_blank">Repo</a></code>用于实际调用<code class="fe nd ne nf ng b"><a class="ae kw" href="https://git-scm.com/docs/git-clone" rel="noopener ugc nofollow" target="_blank">git clone</a></code>和<code class="fe nd ne nf ng b"><a class="ae kw" href="https://git-scm.com/docs/git-pull" rel="noopener ugc nofollow" target="_blank">git pull</a></code>方法</li><li id="5a31" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated"><code class="fe nd ne nf ng b"><a class="ae kw" href="https://docs.python.org/3/library/os.path.html#os.path.exists" rel="noopener ugc nofollow" target="_blank">exists</a></code>用于检查<code class="fe nd ne nf ng b">/repo</code>文件夹是否存在</li><li id="5619" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk or og oh oi bi translated">最后，<code class="fe nd ne nf ng b"><a class="ae kw" href="https://docs.python.org/3/library/shutil.html#shutil.rmtree" rel="noopener ugc nofollow" target="_blank">rmtree</a></code>用于在执行<code class="fe nd ne nf ng b">git</code>过程之前物理删除<code class="fe nd ne nf ng b">/repo</code>中的数据。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py (lines: 19–27)</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/7VkaMQVQKLqQB1Lp3DWI" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L19-L27" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/b069d33231cddd69425793a873d99dec" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="7b66" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.4.2。编译变量</strong></p><p id="f62f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">如上述中的<a class="ae kw" href="#4881" rel="noopener ugc nofollow">所述，该过程中使用了9个环境变量。其中两个<em class="nk">为强制</em>，其余为<em class="nk">可选</em>。使用<code class="fe nd ne nf ng b">python-decouple</code>包的<code class="fe nd ne nf ng b">config()</code>功能设置这些强制和可选过程的处理方式。实际上，这将允许开发人员为环境变量定义一个默认值，并将解析的任何值转换为所需的数据类型。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py (lines: 30–45)</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/n9LOcmp3DJnrBUw5UgPl" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L30-L45" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/49a898548146e86e895f3234732cbcf9" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="d1d7" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.4.3。设置登陆页面</strong></p><p id="11a7" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">登录页面非常简单。这只是一个基本的HTML表格，它允许开发人员(实际上任何其他用户)直接在应用程序的登录页面上看到关键的环境变量。加载的模板将在下面的<a class="ae kw" href="#55bd" rel="noopener ugc nofollow"/><strong class="lr ir"/>段落中进一步概述。将其物理导入Python环境的过程实际上非常简单，如下所示。此外，<code class="fe nd ne nf ng b">str.format()</code>方法被用来直接解析HTML字符串中的特定环境变量。从计算上来说，这是非常高效的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py (lines: 48-61)</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/RVSU4aooarVriuTPx5LX" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L48-L61" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/8ed3828f349b13cb77dc8f427e7d8b0d" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="3b74" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.4.4。实例化应用程序</strong></p><p id="e90a" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">一旦加载了所有包并定义了常量，就该实例化应用程序了。FastAPI包有一套非常直观、非常简单、非常有用的过程。大多数默认值都是完全可用的，这为开发人员消除了许多复杂性(以及模糊性)。只需几行代码，就可以定义整个FastAPI应用程序，并且随时可以使用。如下图所示</p><p id="27f3" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">唯一需要详细说明的方面是<code class="fe nd ne nf ng b">openapi_tags</code>部分。这是一个美学选择，因此当加载<code class="fe nd ne nf ng b">/swagger</code>页面时，很容易看到哪些API端点被分组到了哪些部分。这是另一个完全可选(但强烈建议)的配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py (lines: 64-76)</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/iBO9GuRnthQQvtnujjDE" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L64-L76" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/684776c6addd081b59e22fd048c5873c" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="177d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.4.5。设置自定义功能</strong></p><p id="aa7a" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">虽然我保留了一部分来制作一些自定义函数，但实际上我在这里只添加了一个。这是一个助手功能，用于删除目录中的所有文件。这是必要的，因为有时<code class="fe nd ne nf ng b">gitpython</code>包不喜欢<code class="fe nd ne nf ng b">clone</code>一个目录中的回购，当已经有其他数据和文件存在于相同的位置。因此，这个功能将随时删除过时的文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py (lines: 85-89)</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/UrjufcAzwgQ2GhaAN4wx" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L85-L89" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/1a9c574b44833cf845335a162c2a1f34" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="c939" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.4.6。设置自定义类别</strong></p><p id="5884" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">FastAPI包依赖于包含在<code class="fe nd ne nf ng b">pydantic</code>包的<code class="fe nd ne nf ng b">BaseModel</code>类中的有用进程。通过使用这个类，定义API使用的请求和响应对象非常容易。更多详情可在<a class="ae kw" href="https://fastapi.tiangolo.com/tutorial/body/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。对于我们这里的目的，我只定义了三个定制类，它们的结构非常简单明了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py (lines: 97-110)</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/FCk7FX0NJnS5ejwBfdIq" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L97-L110" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/7b4b6c24494de73382f6b9cb46cda8a2" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="55bd" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.4.7。定义端点:登陆页面</strong></p><p id="bbdd" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">既然一切都已设置就绪，是时候定义实际的端点了。这里，我们将使用三个特定的端点；第一个是登录页面。每个端点都将利用FastAPI的<a class="ae kw" href="https://peps.python.org/pep-0318/" rel="noopener ugc nofollow" target="_blank">装饰</a>方法，特别是<code class="fe nd ne nf ng b">@app.get()</code>或<code class="fe nd ne nf ng b">@app.post()</code>方法。</p><p id="fe3d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">对于第一个端点，我们知道这是登录页面，因为我们已经定义了<code class="fe nd ne nf ng b">path="/"</code>，这基本上意味着这将是该网站的根目录。其他所有内容都将构建在这个根目录之上。这是一个非常简单的端点，它返回一个<code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/advanced/custom-response/?h=htmlre#return-an-htmlresponse-directly" rel="noopener ugc nofollow" target="_blank">HTMLResponse</a></code>类，其中包含我们之前定义的<code class="fe nd ne nf ng b">LANDING_PAGE</code>。此外，这个端点的<code class="fe nd ne nf ng b">schema</code>被关闭，因此当检查<code class="fe nd ne nf ng b">/swagger</code>页面时，读者不会看到不必要和多余的模式定义。</p><p id="d655" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">代码看起来像这样👇</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py (lines: 118-134)</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/TJI6GcPi71Tu8jPMVFEc" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L137-L153" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/965d3ef3ed0d69386033c8c795eefc36" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="3d10" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当它运行时，Swagger页面如下所示👇</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/265b70fbe3d16c5489fe88f1bbf894cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Tl8-iE1JKD4UHtRxt_Jaw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">The Swagger page for the Landing Page Endpoint</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者提供)</p></figure><p id="9e27" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当它运行时，URL看起来像这样👇</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/6d5c76e656f2a3d99dcb405299192e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iE3ww8ibHjBIxFxkZG6fDw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">The URL page for the Landing Page Endpoint</strong></code> <strong class="bd kv"> <br/> </strong>(图片由作者提供)</p></figure><p id="6cef" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.4.8。定义终点:健康检查</strong></p><p id="7cde" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">要声明的第二个API端点是健康检查。这一点很重要，这样用户就能够知道整个应用程序是否启动并运行，并返回健康的响应。为此，最佳做法是设置一个端点。</p><p id="706d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">这个端点的结构就像登录页面一样简单。也许更简单，因为它返回一个<code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/advanced/custom-response/?h=htmlre#plaintextresponse" rel="noopener ugc nofollow" target="_blank">PlainTextResponse</a></code>，它只会返回一个短的文本字符串。</p><p id="9a62" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py (lines: 137-153)</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/nXNwHVWixhIeY2me5bKX" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L137-L153" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/2aaeb0649346f47b0f50ed5a63793010" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="a802" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">运行时，Swagger页面如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/495346347c227778308dfd4cd6cf39b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNL1Tqc-gIlApoDsLnY2ng.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">The Swagger page for the Health Check Endpoint</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者)</p></figure><p id="e594" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当它运行时，URL如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/065ee239f753980ac524f852b016659b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqOVc7l0_wqQ_wQQW-gpoQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">The URL page for the Health Check Endpoint</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者)</p></figure><p id="cd20" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir"> 5.4.9。定义端点:主端点</strong></p><p id="395a" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">最后，我们到达主要终点。这是主要的魔法发生的地方。虽然这个端点看起来很长，但实际上并不长。这段代码可以分为三个部分:</p><ol class=""><li id="c44e" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk of og oh oi bi translated">装饰器部分:<br/> —这是实际定义它是一个HTTP <code class="fe nd ne nf ng b">POST</code>方法的部分。<br/>—<code class="fe nd ne nf ng b">path</code>是一个参数，由用户在<code class="fe nd ne nf ng b">environment</code>变量的<code class="fe nd ne nf ng b">API_ENDPOINT </code>部分定义。<br/>—<code class="fe nd ne nf ng b">description</code>被分成三行(主要是为了让它在屏幕上看起来更美观😉)，它还包括特定的<code class="fe nd ne nf ng b">GIT_URL</code>和<code class="fe nd ne nf ng b">REPO_DIR</code>，如用户在<code class="fe nd ne nf ng b">environment</code>变量中所定义的。<br/> —它将始终返回一个JSON对象。<br/> —根据数据如何被解析<em class="nk">到</em>该API端点，它将返回三种状态之一:<code class="fe nd ne nf ng b">200</code>表示成功，<code class="fe nd ne nf ng b">422</code>表示验证错误，或者<code class="fe nd ne nf ng b">500</code>表示存在内部服务器错误。这是我们在上面定义的三个自定义类<a class="ae kw" href="#c939" rel="noopener ugc nofollow">。</a></li><li id="18f6" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">声明部分:<br/> —该部分只有两个参数:从中<em class="nk">拉取数据的位置的<code class="fe nd ne nf ng b">git_url</code>，以及将<em class="nk">数据保存到</em>的位置的<code class="fe nd ne nf ng b">repo_dir</code>。<br/>——在引擎盖下，他们每个人都将成为<code class="fe nd ne nf ng b"><a class="ae kw" href="https://fastapi.tiangolo.com/tutorial/query-params-str-validations/" rel="noopener ugc nofollow" target="_blank">Query</a></code>的对象。<br/> —唯一看起来长的是因为<code class="fe nd ne nf ng b">description</code>部分覆盖了多行。</em></li><li id="dac9" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">函数执行部分<br/>——实际的代码执行部分将进入<code class="fe nd ne nf ng b">try</code>以完成两件事:1)检查目标目录(并删除其中存在的任何内容，如果必要的话)，以及2)从上游回购克隆最新的数据。<br/> —如果遇到错误，它将通过API向调用者返回一个<code class="fe nd ne nf ng b">InternalServerError</code>响应，这样他们就可以在必要时看到并调试错误。<br/> —如果成功，那么它将向调用者返回一个<code class="fe nd ne nf ng b">Success</code>响应。</li></ol><p id="cc9f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py (lines: 156-205)</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/3hjKf2WfLKxK7Cvcy8KZ" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py#L156-L205" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/f874e19fe6d32f59982ce3997936d901" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="2f3e" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当它运行时，Swagger页面如下所示👇</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/1571996577624d83a2d6f1443eef1d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOLA4fs7r9XtAcGu_b6LOQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">The Swagger page for the Main Endpoint</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者提供)</p></figure><h2 id="39e4" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">5.5.文件:<code class="fe nd ne nf ng b">/templates/landing_page.html</code></h2><p id="bbf9" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">正如上面的提到的<a class="ae kw" href="#d1d7" rel="noopener ugc nofollow">，我写了一个超级简单的HTML页面，可以用于API的登陆页面。您会注意到这里有两个特点:</a></p><ol class=""><li id="e4ad" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk of og oh oi bi translated"><code class="fe nd ne nf ng b">&lt;style&gt;</code>标签中的值不是正确的CSS语法，因为它们有双花括号(<code class="fe nd ne nf ng b">{{</code>、<code class="fe nd ne nf ng b">}}</code>)。这是因为这些信息将被解析到Python中，然后Python将把花括号中的任何内容解释为参数，并尝试给它们分配变量。为了避免这种情况，使用了双花括号语法。这个过程在<a class="ae kw" href="https://docs.python.org/3/library/string.html#format-string-syntax" rel="noopener ugc nofollow" target="_blank"> Python文档</a>中定义。</li><li id="93cc" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">单花括号内的值是全局常量，由环境变量定义(见上文中的<a class="ae kw" href="#7b66" rel="noopener ugc nofollow">)。</a></li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/templates/landing_page.html</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/3TgeFLSMUpRmTg6XbREp" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/templates/landing_page.html" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/d81fcd3d76374ca3cc62aafe90f1f012" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="2088" class="kx ky iq bd kz la mx lc ld le my lg lh jw mz jx lj jz na ka ll kc nb kd ln lo bi translated">第三部分:如何使用应用程序</h1><h1 id="65ea" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">6.如何使用它</h1><p id="64bb" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">既然我们已经构建了应用程序，并且了解了所有组件的功能，现在是时候设置并开始使用它了。</p><h2 id="ecb0" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">6.1.创建服务器(使用AWS)</h2><p id="cf54" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">首先，有必要在云中创建服务器。有可能使用许多不同的云计算平台；最受欢迎的两个是<a class="ae kw" href="https://aws.amazon.com/ec2" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务</a><a class="ae kw" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">(又名AWS)平台上的</a><a class="ae kw" href="https://aws.amazon.com/ec2" rel="noopener ugc nofollow" target="_blank">弹性计算云</a>(又名EC2)，以及<a class="ae kw" href="https://azure.microsoft.com/" rel="noopener ugc nofollow" target="_blank">微软Azure </a>(又名Azure)平台上的<a class="ae kw" href="https://azure.microsoft.com/services/virtual-machines/" rel="noopener ugc nofollow" target="_blank"> Azure虚拟机</a>(又名AVM)。如果你想了解这两个平台之间的差异，可以看看这篇文章:<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/architecture/aws-professional/compute" rel="noopener ugc nofollow" target="_blank">比较AWS和Azure计算服务</a>。</p><p id="b627" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">出于本教程的目的，我们将使用AWS EC2平台。在这里，有许多不同的关于创建EC2实例的教程<em class="nk">。比如<a class="ae kw" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html" rel="noopener ugc nofollow" target="_blank">这个</a>或者<a class="ae kw" href="https://medium.com/serverlessguru/creating-an-aws-ec2-instance-d5cf332fdb0c" rel="noopener">这个</a>或者<a class="ae kw" href="https://medium.com/edureka/aws-ec2-tutorial-16583cc7798e" rel="noopener">这个</a>。我个人认为简·贾科姆利的文章最有帮助，因为他包含了大量的细节、解释和截图。参见教程:<a class="ae kw" href="https://testdriven.io/blog/django-docker-https-aws/" rel="noopener ugc nofollow" target="_blank">用Docker </a>将Django部署到AWS。</em></p><p id="292f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">请密切注意本教程中在服务器上安装Docker 的步骤。除此之外，Docker文档上还有另外两个页面可以帮助指导您进行安装:<a class="ae kw" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">在Ubuntu上安装Docker Engine</a>和<a class="ae kw" href="https://docs.docker.com/compose/cli-command/#install-on-linux" rel="noopener ugc nofollow" target="_blank">在Linux上安装Docker Compose V2</a>。一旦您<code class="fe nd ne nf ng b">ssh</code>进入服务器，您将需要运行的特定指令集是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">Install Docker and Docker Compose on EC2 Instance</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/hPmRP97XwzNzE82qRxoO" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/cli/aws/install-docker.sh" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/bcbe79f2f8d0f400acadef43c08575bf" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="40c0" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">一旦创建了EC2实例并成功运行，添加一个额外的步骤是很重要的。也就是将GitHub的IP地址列入白名单，这样当GitHub触发针对EC2实例的HTTP <code class="fe nd ne nf ng b">POST</code>请求时，它就不会被EC2上默认设置的网络规则所阻止。有关这一点为什么重要的更多信息，请参见<a class="ae kw" href="https://docs.github.com/en/enterprise-cloud@latest/authentication/keeping-your-account-and-data-secure/about-githubs-ip-addresses" rel="noopener ugc nofollow" target="_blank">上关于GitHub的IP地址</a>和<a class="ae kw" href="https://github.com/stakater/gitwebhookproxy/issues/62" rel="noopener ugc nofollow" target="_blank">将Webhooks IP地址</a>和<a class="ae kw" href="https://github.blog/changelog/2019-04-09-webhooks-ip-changes/" rel="noopener ugc nofollow" target="_blank"> GitHub Webhooks IP范围</a>列入白名单的可能性的详细信息。</p><p id="fd67" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">要将这些IP加入白名单，请遵循本教程中给出的说明:<a class="ae kw" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/authorizing-access-to-an-instance.html" rel="noopener ugc nofollow" target="_blank">授权EC2实例的入站流量</a>。完成后，您的入站规则应该如下所示👇</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/6e338a133f653cf72eb0d2b40a452426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMkRcTTY3hdHpp30NsaFRw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Inbound Rules required for GitHub to access EC2 Instance</strong></code> <strong class="bd kv"> <br/> </strong>(图片由作者提供)</p></figure><p id="e686" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">你可能会问这样的问题:“但是我为什么要这么做呢？”或者也许是“我怎么知道它起作用了？”或者也许是“我如何知道GitHub失败是因为IP没有被列入白名单？”。所有这些问题的答案都是一样的。</p><p id="0d17" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">具体来说:如果GitHub IP<em class="nk">没有</em>列入白名单，那么当Webhook从GitHub触发到AWS时，将被阻止，返回的错误信息将是:<code class="fe nd ne nf ng b">failed to connect to host</code>。请参见下面的屏幕截图示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/b99f98f07f1f2ae4b4aaa8a4d965a73d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kocPuMiyaLvJDTch89EtA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Error message received when IP Addresses are not correctly whitelisted</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者)</p></figure><h2 id="a07e" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">6.2.将<code class="fe nd ne nf ng b">docker-compose.yml</code>文件添加到服务器</h2><p id="60a4" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在EC2实例已经准备好了，接下来的步骤是向它添加<code class="fe nd ne nf ng b">docker-compose.yml</code>文件。为此，有三种方法可以将文件添加到服务器:</p><ol class=""><li id="d392" class="oa ob iq lr b ls ml lv mm ly oc mc od mg oe mk of og oh oi bi translated">使用<code class="fe nd ne nf ng b">ssh</code> : <br/> —遵循此处<a class="ae kw" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html" rel="noopener ugc nofollow" target="_blank">和此处</a>和<a class="ae kw" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-connect-methods.html" rel="noopener ugc nofollow" target="_blank">的说明，了解如何使用<code class="fe nd ne nf ng b">ssh</code>登录EC2实例。<br/> —一旦在服务器上，使用<code class="fe nd ne nf ng b">touch docker-compose.yml</code>添加一个空文件。<br/> —使用<code class="fe nd ne nf ng b">nano docker-compose.yml</code>打开文件。<br/> —直接将文本从本地PC复制粘贴到服务器。<br/> —通过按<code class="fe nd ne nf ng b">ctrl+O</code>然后按<code class="fe nd ne nf ng b">ctrl+X</code>保存并关闭文件。</a></li><li id="2c72" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">使用<code class="fe nd ne nf ng b">scp</code> : <br/> —按照这里的<a class="ae kw" href="https://stackoverflow.com/questions/6558080/scp-secure-copy-to-ec2-instance-without-password" rel="noopener ugc nofollow" target="_blank"/>和这里的<a class="ae kw" href="https://medium.com/srcecde/copy-file-directory-to-from-ec2-using-scp-secure-copy-685c46636399" rel="noopener"/>的说明执行<code class="fe nd ne nf ng b">scp</code>脚本，将文件推送到安全服务器。<br/> —该命令应该类似于:<br/> <code class="fe nd ne nf ng b">scp -i path/to/pem/file/ec2_identity_file.pem /path/on/localpc/docker-compose.yml username@server:path/on/server</code></li><li id="efe4" class="oa ob iq lr b ls oj lv ok ly ol mc om mg on mk of og oh oi bi translated">使用FileZilla(或其他类似的FTP软件):<br/> —按照说明<a class="ae kw" href="https://stackoverflow.com/questions/16744863/connect-to-amazon-ec2-file-directory-using-filezilla-and-sftp" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kw" href="https://www.youtube.com/watch?v=e9BDvg42-JI" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kw" href="https://filezillapro.com/docs/v3/basic-usage-instructions/ssh-private-keys-for-sftp/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kw" href="https://medium.com/@shivambhanvadia/how-to-upload-files-on-ec2-using-filezilla-and-host-a-static-website-ae1eccad141d" rel="noopener">这里</a>，了解如何使用FileZilla将文件推送到EC2实例。</li></ol><p id="55ff" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">下面给出了您应该复制到服务器的确切文件。确保用您的具体信息更新<code class="fe nd ne nf ng b">&lt;update&gt;</code>部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">Template for the </strong></code><strong class="ak">docker-compose . yml</strong><code class="fe nd ne nf ng b"><strong class="ak"> file</strong></code><strong class="ak"><br/></strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/1HzLtSfZlsEZ5pNiJA5N" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/docker/docker-compose-template.yml" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/4a83f74de423903e8daf75def6ed4263" rel="noopener ugc nofollow" target="_blank">这里</a>)</p></figure><h2 id="0b25" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">6.3.在服务器上启动Docker</h2><p id="9da2" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">既然一切都已准备就绪，下一步就很容易了。启动Docker容器并启动API监听器只需要一行代码👇</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">Install Docker and Docker Compose on EC2 Instance</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/9GgdqwKJVOEjM97kKmPg" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/cli/docker/up.sh" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/e8db51a3e187b3464258c4ff68ba1d42" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="9dbc" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当您在服务器上运行它时，它看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/2b5a20a022c43da98f4ee6386925e5e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_zLS_esHoaZ1af6p_4G9w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Script for setting up Docker on the EC2 Server</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者)</p></figure><h2 id="a5e6" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">6.4.在Git上添加Webhook(使用GitHub)</h2><p id="26dc" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">接下来，我们需要实际配置GitHub来触发Webhook。GitHub 提供的<a class="ae kw" href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks" rel="noopener ugc nofollow" target="_blank">文档实际上对此很有帮助，并且很容易理解。此外，网上也有一些非常好的博客和教程，包括:</a><a class="ae kw" href="https://medium.com/the-sysadmin/deploy-from-github-gitlab-to-server-using-webhook-d1cb6496368f" rel="noopener">使用Webhook从Github/Gitlab部署到服务器</a>和<a class="ae kw" href="https://towardsdatascience.com/create-your-first-ci-cd-pipeline-with-jenkins-and-github-6aefe21c9240" rel="noopener" target="_blank">使用Jenkins和Github创建您的第一个CI/CD管道</a>。</p><p id="6a02" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在这个例子中，我将使用我的另一个Repo，名为<a class="ae kw" href="https://github.com/chrimaho/code-snippets/settings/hooks" rel="noopener ugc nofollow" target="_blank">代码片段</a>。虽然从技术上来说，它本身不是一个应用程序，但它仍然足够简单，可以帮助我们理解这个过程。</p><p id="072f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当我们导航到Repo时，我们可以打开<strong class="lr ir">设置</strong>，然后打开<strong class="lr ir"> Webhooks </strong>部分，然后按下<strong class="lr ir">添加Webhook </strong>按钮。如下图。</p><p id="83c9" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">这个的网址也很简单:<a class="ae kw" href="https://github.com" rel="noopener ugc nofollow" target="_blank">https://github.com/&lt;用户名&gt; / &lt;回购&gt;/设置/挂钩</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/d8361dfdf5f71e9caacb05f81d5f91f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ir9iamCazHCeYLMA-P69xQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Where to find Webhooks on GitHub Repo</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者)</p></figure><p id="2256" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">下一个菜单要求您添加URL。这是您在EC2实例中设置的弹性IP地址(参见<a class="ae kw" href="https://testdriven.io/blog/django-docker-https-aws/#elastic-ip" rel="noopener ugc nofollow" target="_blank">本节</a>)。如果你知道如何添加子域到你现有的网站，那么你也可以这样做。IP地址在之后的部分<em class="nk">与您在<code class="fe nd ne nf ng b">docker-compose.yml</code>文件的<code class="fe nd ne nf ng b">environment</code>部分的<code class="fe nd ne nf ng b">API_ENDPOINT</code>值中配置的值相同。现在一切都开始明朗了。</em></p><p id="54fe" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">对于<strong class="lr ir">内容类型</strong>，选择<code class="fe nd ne nf ng b">application/json</code>，将<strong class="lr ir">事件</strong>保留在<code class="fe nd ne nf ng b">push</code>事件上，然后选择<strong class="lr ir">添加Webhook </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/34a6370ea4ca462245e3dc448eb9717d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cx8gq4MHcw0QY1hbEEexIg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Settings for adding a Webhook on GitHub</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者提供)</p></figure><p id="bf50" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">保存后，您会在屏幕顶部看到一条消息:</p><pre class="kg kh ki kj gt os ng ot ou aw ov bi"><span id="fb65" class="no ky iq ng b gy ow ox l oy oz">Okay, that hook was successfully created. We sent a ping payload to test it out!</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/c7eafff3545bafd3a4de19cce009e239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkNWMIlrsVwUX2fyGxV_tA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Successfully Created Webhook on GitHub Repo</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者提供)</p></figure><p id="910c" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当您进入Webhook检查最近的交付时，您会发现已经发送了一个请求，并且已经收到了一个响应。并且，<em class="nk">希望是</em>，如果您的所有配置都成功设置，您将看到一个绿色勾号和一个响应状态代码:<code class="fe nd ne nf ng b">200</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/dcf63121a2e0d08b960412c221a50770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuAdnAWHa8N7rzpO_bchaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Confirmation of Successful response from GitHub Webhook ping</strong></code> <strong class="bd kv"> <br/> </strong>(图片由作者提供)</p></figure><h2 id="faf0" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">6.5.测试一下</h2><p id="c5bf" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">测试它超级简单。首先，让我们跳到EC2服务器上，检查一下<code class="fe nd ne nf ng b">docker compose logs</code>看起来是否正常。然后我们将使用<code class="fe nd ne nf ng b">ls repo</code>检查目录的内容。这是结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/1e37414aae8f5b32d3cb120b85749aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acLaYPU3p9eupC09avRj9g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Checking the files on the Server</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者提供)</p></figure><p id="5e6c" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">首先，你可以看到来自GitHub的<code class="fe nd ne nf ng b">ping</code>请求已经成功通过！并且<code class="fe nd ne nf ng b">/repo</code>目录已经<em class="nk">包含来自上游Git repo的更新信息</em>！</p><p id="6f87" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">接下来，在我们的本地PC上，在您想要<code class="fe nd ne nf ng b">push</code>到GitHub的回购目录中，让我们只创建一个<em class="nk">非常小的</em>文本文件，名为<code class="fe nd ne nf ng b">test.txt</code>。然后我们会做<code class="fe nd ne nf ng b">git add</code>、<code class="fe nd ne nf ng b">git commit</code>、<code class="fe nd ne nf ng b">git push</code>把它拿到上游回购。代码看起来像这样👇</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">Add a new file to Git and </strong></code> <strong class="ak">推</strong> <code class="fe nd ne nf ng b"><strong class="ak"> to upstream Repo</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/FCKwSx8GZq2rqvyB2lOz" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/cli/git/add.sh" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/8d5ed49800f94f8b6f45a0d39314a3c3" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="f19f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">终端看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/ba0132942b4d663d2cd8200651e305f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rF1bkWNLoP7AqKZHo-Hkug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Add a new file to Git</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者提供)</p></figure><p id="5873" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">然后当我们回到EC2服务器检查它时，我们可以重新运行<code class="fe nd ne nf ng b">docker compose logs</code>来检查它是否成功通过(它确实成功了！)，并检查<code class="fe nd ne nf ng b">ls repo</code>以确认该文件现在已经存在(确实存在！).看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/ef17f97ffa4ed5623d1fac1ee7da8ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9cErOlzZDH1LwlXlyhgPQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="bd kv">Re-Checking the files on the Server</strong></code> <strong class="bd kv"> <br/> </strong>(图片作者提供)</p></figure><p id="4494" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">现在一切都运转良好！</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="7fac" class="kx ky iq bd kz la mx lc ld le my lg lh jw mz jx lj jz na ka ll kc nb kd ln lo bi translated">第四部分:更多信息</h1><h1 id="1f33" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">7.下一步是什么</h1><p id="ba08" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><strong class="lr ir">注意:</strong>现在Webhooks已经设置好了，你的服务器会自动更新，技术上来说还有一个步骤你需要做。这通常是重新启动你在服务器上运行的应用程序，以确保它总是引用最新的源文件。但是，因为各种应用程序有不同的重启方式，所以我不打算在这里提到它们。</p><p id="2a51" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">此外，最近，我发现有一个Webhook进程可用于各种Docker容器进程。包括在<a class="ae kw" href="https://docs.docker.com/docker-hub/webhooks/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>、<a class="ae kw" href="https://aws.amazon.com/blogs/containers/create-a-ci-cd-pipeline-for-amazon-ecs-with-github-actions-and-aws-codebuild-tests/" rel="noopener ugc nofollow" target="_blank"> AWS ECR </a>、<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-webhook" rel="noopener ugc nofollow" target="_blank"> Azure ACR </a>上。这给了我灵感，让我写了另一篇关于如何使用它的博客！</p><h1 id="cc2c" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">8.哪里可以找到更多信息</h1><p id="e928" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">谢天谢地，这个过程并不难。我已经把它设置成开源的，随时可用。所有的源代码都保存到<a class="ae kw" href="https://github.com/chrimaho/update-from-git" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中，这个现成的容器托管在<a class="ae kw" href="https://hub.docker.com/r/chrimaho/update-from-git" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上。</p><div class="pj pk gp gr pl pm"><a href="https://github.com/chrimaho/update-from-git" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd ir gy z fp pr fr fs ps fu fw ip bi translated">chrimaho/从git更新</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">一个Python应用程序，托管在Docker映像上，用于监听git存储库，然后从中提取数据。</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">github.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa kp pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a href="https://hub.docker.com/r/chrimaho/update-from-git" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd ir gy z fp pr fr fs ps fu fw ip bi translated">chrimaho/从git更新</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">一个Python应用程序，托管在Docker映像上，用于监听git存储库，然后从中提取数据。</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">hub.docker.com</p></div></div></div></a></div><h2 id="76bf" class="no ky iq bd kz np nq dn ld nr ns dp lh ly nt nu lj mc nv nw ll mg nx ny ln nz bi translated">9./src/api/main.py的完整文件</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b"><strong class="ak">/src/api/main.py</strong></code> <strong class="ak"> <br/> </strong>(图片由作者提供，来源<a class="ae kw" href="https://carbon.now.sh/e2pEa9JxpvuyO9OdkUxL" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://github.com/chrimaho/update-from-git/blob/main/src/api/main.py" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kw" href="https://gist.github.com/chrimaho/111fee2575979a9ff1e2d5f8ba856868" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure><p id="22a6" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">感谢阅读。</p><pre class="kg kh ki kj gt os ng ot ou aw ov bi"><span id="0ee4" class="no ky iq ng b gy ow ox l oy oz"><strong class="ng ir">Want to Connect?</strong></span><span id="b62a" class="no ky iq ng b gy qb ox l oy oz">Shoot me queries,ideas and suggestions at <a class="ae kw" href="https://chrimaho.com" rel="noopener ugc nofollow" target="_blank">https://chrimaho.com</a>.</span></pre></div></div>    
</body>
</html>