<html>
<head>
<title>Python Reflection and Introspection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python反射和自省</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-reflection-and-introspection-97b348be54d8?source=collection_archive---------1-----------------------#2020-01-16">https://betterprogramming.pub/python-reflection-and-introspection-97b348be54d8?source=collection_archive---------1-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c764" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在代码中，而不是在我们自己身上</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d85b810d4d9865fcb3db59c8df2b0c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3QQ1ul-nb_lszqJc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rayhennessy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷·轩尼诗</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="810b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程中，<em class="lv">自省</em>是在运行时找出对象信息的能力。<em class="lv">反射</em>通过允许对象在运行时被<em class="lv">修改</em>而更进一步。</p><p id="d860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，这两个语言特性确实让Python变得有趣，并使它有别于不太动态的语言。Python支持自省和反射，在本文中，我将解释它们是如何工作的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6dc7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">反省</h1><p id="6225" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你可以在运行时自省的最基本的信息是一个对象的类型。这可以通过<code class="fe na nb nc nd b">type()</code>功能实现。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="a8ff" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; type(1)<br/>&lt;class 'int'&gt;</span><span id="1264" class="ni me it nd b gy nn nk l nl nm">&gt;&gt;&gt; type(1.0)<br/>&lt;class 'float'&gt;</span><span id="2c63" class="ni me it nd b gy nn nk l nl nm">&gt;&gt;&gt; type(int)<br/>&lt;class 'type'&gt;</span></pre><p id="cc9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，解释器告诉我们整数<code class="fe na nb nc nd b">1</code>属于<code class="fe na nb nc nd b">int</code>，<code class="fe na nb nc nd b">1.0</code>属于<code class="fe na nb nc nd b">float</code>，而<code class="fe na nb nc nd b">int</code>属于<code class="fe na nb nc nd b">type</code>。</p><p id="878b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自<code class="fe na nb nc nd b">type()</code>函数的返回值被称为<em class="lv">类型对象</em>。类型对象告诉我们参数是哪个类的实例。</p><p id="da59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe na nb nc nd b">isinstance()</code>巧妙地证实这一点:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="5aa2" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; isinstance(1, int)<br/>True</span><span id="f901" class="ni me it nd b gy nn nk l nl nm">&gt;&gt;&gt; isinstance(int, type)<br/>True</span></pre><p id="0b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型对象支持<code class="fe na nb nc nd b">is</code>操作符，所以我们可以写:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="91bf" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; type(1) is int<br/>True</span><span id="594e" class="ni me it nd b gy nn nk l nl nm">&gt;&gt;&gt; type(int) is type<br/>True</span></pre><p id="e793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe na nb nc nd b">type()</code>和<code class="fe na nb nc nd b">isinstance()</code>并不直接等价，因为<code class="fe na nb nc nd b">isinstance()</code>也考虑对象的基类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可能想一起使用<code class="fe na nb nc nd b">type()</code>和<code class="fe na nb nc nd b">isinstance()</code>，就像这样:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="84a5" class="ni me it nd b gy nj nk l nl nm">if isinstance(obj, A):<br/>    # do something for all children of A<br/>    <br/>    if type(obj) is B:<br/>        # do something specifically for instances of B</span></pre><p id="a81b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用Python中的其他技术来发现对象，包括:</p><ul class=""><li id="0fb8" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">hasattr(obj,'a')</code> —如果<code class="fe na nb nc nd b">obj</code>具有属性<code class="fe na nb nc nd b">a</code>，则返回<code class="fe na nb nc nd b">True</code>。</li><li id="5982" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">id(obj)</code> —返回对象的唯一ID。</li><li id="b22b" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">dir(obj)</code> —返回列表中对象的所有属性和方法。</li><li id="299b" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">vars(obj)</code> —返回字典中对象的所有实例变量。</li><li id="d317" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">callable(obj)</code> —如果<code class="fe na nb nc nd b">obj</code>可调用，则返回<code class="fe na nb nc nd b">True</code>。</li></ul><p id="95e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用创建时自动添加到对象中的属性来直接访问这些信息。例如:</p><ul class=""><li id="4ec7" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">obj.__class__</code>为<code class="fe na nb nc nd b">obj</code>存储<em class="lv">类型对象</em>。</li><li id="65f1" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">obj.__class__.__name__</code>为<code class="fe na nb nc nd b">obj</code>存储<em class="lv">类名</em>。</li><li id="12af" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">对于函数对象，<code class="fe na nb nc nd b">obj.__code__</code>存储一个代码对象，包含函数中代码的信息。</li></ul><p id="62da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关代码对象的更多信息，请参见<a class="ae ky" href="https://docs.python.org/3.8/c-api/code.html" rel="noopener ugc nofollow" target="_blank">Python文档</a>。</p><h2 id="ed4f" class="ni me it bd mf oe of dn mj og oh dp mn li oi oj mp lm ok ol mr lq om on mt oo bi translated">自省示例</h2><p id="743c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">将所有这些放在一起，我们可以创建一个简单的<code class="fe na nb nc nd b">introspect()</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ee9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们是如何在函数中使用内省来打印被调用函数的名称(<code class="fe na nb nc nd b">func.__name__</code>)和内省参数的名称(<code class="fe na nb nc nd b">introspect.__code__.co_varnames[0]</code>)！</p><p id="784c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="b6f7" class="ni me it nd b gy nj nk l nl nm">type(obj):              &lt;class '__main__.Test'&gt;                                                                       <br/>id(obj):                139779613404408                                                                               <br/>dir(obj):               ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__<br/>', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__red<br/>uce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'x', '<br/>y']<br/>vars(obj):              {'y': 2, 'x': 1}                                                                              <br/>callable(obj):          False</span></pre><p id="f632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于两行代码来说还不错！</p><h2 id="5507" class="ni me it bd mf oe of dn mj og oh dp mn li oi oj mp lm ok ol mr lq om on mt oo bi translated">高级内省</h2><p id="f9d7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">上面概述的工具已经非常强大了。然而，如果你想更深入地研究内省，Python的<a class="ae ky" href="https://docs.python.org/3/library/inspect.html" rel="noopener ugc nofollow" target="_blank"> inspect模块</a>提供了内省活动对象的更多功能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5d46" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">动态修改对象</h1><p id="305b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">到目前为止，我们已经讨论了如何在运行时找到关于一个对象的信息。我们现在要学习如何动态地<em class="lv">修改</em>或者甚至创建新的对象和类！</p><p id="fa1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们应该知道属性可以在运行时添加到类或对象中。所以，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="14d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于方法只是一种特殊类型的属性，这意味着我们也可以在运行时添加方法。让我们通过动态添加一个<code class="fe na nb nc nd b">__init__</code>方法来修改我们的类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="89e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们如何使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://docs.python.org/3/library/functions.html#setattr" rel="noopener ugc nofollow" target="_blank">setattr</a></code>函数将<code class="fe na nb nc nd b">A</code>的<code class="fe na nb nc nd b">__init__</code>方法设置为<code class="fe na nb nc nd b">init</code>。这使得我们正在设置的属性的名称也可以动态确定。</p><p id="0afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过修改函数的<code class="fe na nb nc nd b">__code__</code>属性来进一步理解这个概念。这次通过简单的赋值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="cdfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这可用于创建只执行一次的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="4ff6" class="ni me it bd mf oe of dn mj og oh dp mn li oi oj mp lm ok ol mr lq om on mt oo bi translated">在运行时创建类</h2><p id="b2a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们现在要重温前面提到的<code class="fe na nb nc nd b">type()</code>函数，并用它来动态地<em class="lv">创建</em>一个新类。为此，我们用三个参数调用<code class="fe na nb nc nd b">type()</code>:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e931" class="ni me it nd b gy nj nk l nl nm">type(name, bases, dict)</span></pre><p id="1932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中:</p><ul class=""><li id="23c7" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">name</code>是我们正在创建的类的名称。</li><li id="8a05" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">bases</code>是我们继承的基类元组。</li><li id="4381" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe na nb nc nd b">dict</code>是属性名、属性值对的字典。</li></ul><p id="8e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，最简单的形式是，我们可以写:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9089" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; A = type('A', (), {'x': 1})<br/>&gt;&gt;&gt; a = A()<br/>&gt;&gt;&gt; a.x<br/>1</span></pre><p id="c1a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们可以得到更多的进展。例如，要创建一个完全成熟的类:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="3e71" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; exec("def init(self):\n\tprint(self.__class__.__name__ + \" created!\")")<br/>&gt;&gt;&gt; A = type('A', (), {'__init__' : init })<br/>&gt;&gt;&gt; a = A()<br/>"A created!"</span></pre><p id="632e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在这里，我们使用Python的内置<code class="fe na nb nc nd b"><a class="ae ky" href="https://docs.python.org/3/library/functions.html#exec" rel="noopener ugc nofollow" target="_blank">exec</a></code>函数从字符串生成我们的类的<code class="fe na nb nc nd b">__init__</code>方法。方法定义本身使用<code class="fe na nb nc nd b">self.__class__.__name__</code>动态获取类名！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4b86" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">最后提醒一句</h1><p id="6d79" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">虽然本文中概述的语言能力是强大的，但是<a class="ae ky" href="https://en.wikipedia.org/wiki/With_great_power_comes_great_responsibility" rel="noopener ugc nofollow" target="_blank">强大的能力意味着巨大的责任</a>！</p><p id="ab5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些技术应该尽量少用。过度使用动态编程会使代码更难阅读。在某些情况下，它还会引入安全漏洞，尤其是在动态执行涉及用户输入的情况下。</p><p id="77c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行时动态修改代码有时被称为<em class="lv">猴子补丁</em>。关于潜在应用和陷阱的更多细节可以在维基百科上找到<a class="ae ky" href="https://en.wikipedia.org/wiki/Monkey_patch" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="68a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>