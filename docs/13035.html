<html>
<head>
<title>Getting Started With Elixir — Know Its Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">长生不老药入门——了解它的种类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-elixir-in-2023-a691d37f521?source=collection_archive---------10-----------------------#2022-07-20">https://betterprogramming.pub/learn-elixir-in-2023-a691d37f521?source=collection_archive---------10-----------------------#2022-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb98" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第1部分—基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9221f6df4ae02278a1a0e72fd3d5a7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9vxXZyhPoiiw4BdR.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">摘自<a class="ae ku" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/</a></p></figure><p id="3f41" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它是一种动态的函数式语言，旨在构建可扩展和可维护的应用程序。</p><p id="57b8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它运行在Erlang虚拟机之上，该虚拟机以运行低延迟、分布式和容错系统而闻名。</p><p id="821a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在Erlang虚拟机中，所有代码都在小型并发进程中运行。每个进程都包含自己的状态。这些进程通过消息相互交流。</p><p id="cd83" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它是一种通用语言，用于web开发、嵌入式软件、数据管理和多媒体处理，以及广泛的行业。</p><p id="f155" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">二郎生态系统是巨大的，运行药剂，LFE，羊驼，Prolog，卢埃尔(Lua)。一些公司在生产中使用长生不老药，如Heroku、Discord和change.org等。苹果和Adobe也在他们的一些API中使用Elixir。</p><h1 id="1d80" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">安装药剂</h1><p id="7c0a" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">对于macOS，使用自制软件非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="538e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于Ubuntu或者Debian来说，也很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="eb5a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一旦安装了elixir，我们只需编写iex就可以使用它的命令行或Elixir交互式控制台。</p><p id="1399" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它完全可以作为计算器使用。然而，其他工具可以让我们更容易地学习这种编程语言。</p><h1 id="d985" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Livebook(长生不老药的Jupyter)</h1><p id="4e23" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">它对于构建代码解决方案的原型非常有用，就像Jupyter和Python一样。在Mac上安装Livebook有很多方法。这些文件已经打包在一个dmg中，所以只需下载它们并将其移动到您的应用程序文件夹中。</p><p id="552a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用Elixir安装它也非常容易。Elixir附带了一个包管理器，像npm或pip，叫做mix(对于Erlang，有hex)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ed99" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Livebook的一个伟大之处在于，我们可以在除代码单元格之外的单元格中添加到数据库和图形的连接。它们被称为智能细胞。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mq"><img src="../Images/31573030d1a65a61fbd5e375cc6c1f55.png" data-original-src="https://miro.medium.com/v2/format:webp/1*b31hiO4ynbDLRrXWEFF4aQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我拍摄的Livebook中的智能细胞</p></figure><h1 id="69bb" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">基本数据类型</h1><p id="692e" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">让我们来看一些关于灵药基本类型的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="00b1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">加法、减法和乘法与其他编程语言完全相同；然而，除法总是返回一个浮点数。为了避免这种情况，我们使用了一个名为div/2的内核模块函数(它是自导入的)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d921" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">和Ruby一样，在函数中，括号是可选的，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3cf1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">函数存储在模块中。为了识别和记录它们，解剖如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="97fb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如我已经提到的，唯一可以自我导入的模块是内核模块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="700f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在Livebook中，一些助手允许我们以非常直观和友好的方式查看文档。我们放置模块的名称，然后用鼠标悬停。这不仅给我们带来了文档，还带来了很好的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mq"><img src="../Images/31573030d1a65a61fbd5e375cc6c1f55.png" data-original-src="https://miro.medium.com/v2/format:webp/1*b31hiO4ynbDLRrXWEFF4aQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我服用的长生不老药的记录</p></figure><h1 id="f1a2" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">原子或符号</h1><p id="fad2" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">这些变量的值与变量名相同。下面是一些示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6f38" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一些操作可以用原子来完成，例如，比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2d86" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在Elixir和Erlang中，原子通常表示一个操作的状态，最常见的是用<code class="fe mr ms mt mu b">:ok</code>和<code class="fe mr ms mt mu b">:error</code>。</p><p id="00ac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">布尔值是原子，但为了方便起见，它们没有以冒号开头。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7409" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Elixir有一个以大写字母开头的构造，叫做别名。这些也是原子，通常用来命名模块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="ebf5" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">用线串</h1><p id="a6d0" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">原子可以被插入字符串。值得一提的是，字符串总是使用双引号，就像在许多编程语言中一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="db29" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了处理字符串，我们使用名为String的模块。例如，它们可以帮助我们了解字符串的长度和一些有趣的功能，如大写字母。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="bfe1" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">匿名函数、列表和元组</h1><p id="7d44" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">匿名函数由关键字<code class="fe mr ms mt mu b">fn</code>和<code class="fe mr ms mt mu b">end</code>分隔。这些匿名函数，就像在JavaScript中一样，我们可以保存在一个变量中。让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="f593" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行该函数的方法是通过一个点和括号中的参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e30a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如我们对布尔函数所做的那样，我们可以通过另一个叫做<code class="fe mr ms mt mu b">is_function</code>的函数来查看我们的变量add是否是一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="9330" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们还可以看到函数接收了多少个参数。为了验证参数的数量，我们向它传递以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="e150" class="mv ls it bd lt mw mx dn lx my mz dp mb le na nb md li nc nd mf lm ne nf mh ng bi translated">关闭</h2><p id="2773" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">他们可以访问原始函数范围内的变量。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="a4c8" class="mv ls it bd lt mw mx dn lx my mz dp mb le na nb md li nc nd mf lm ne nf mh ng bi translated">功能范围</h2><p id="177c" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">一个函数不能重定义一个不在同一个函数作用域内的变量，我们来做一个不接受任何参数的匿名函数，我们在同一行执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5ba7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这将返回“hello”的值(以及一个警告，因为我们没有使用该变量)。我们可以添加一个下划线来消除这个警告。</p><p id="aa47" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果在函数范围之外，我们用另一个值初始化变量，在函数范围之外我们不会修改变量的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mq"><img src="../Images/1de94b64052e9bb979ca0f3a44a5152d.png" data-original-src="https://miro.medium.com/v2/format:webp/0*Ki_c8XRoCZU2Zoc-.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我拍的不变变量截图</p></figure><h2 id="3d07" class="mv ls it bd lt mw mx dn lx my mz dp mb le na nb md li nc nd mf lm ne nf mh ng bi translated">列表</h2><p id="dcce" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">Elixir使用括号来指定列表。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3f6a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">内核中有一些函数可以让我们了解列表的情况。代码可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c25f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了连接两个列表，我们使用了<code class="fe mr ms mt mu b">++</code>操作符，因此我们有如下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a6a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们也可以从一个列表中减去另一个列表。可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3700" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是，这只会删除列表中显示的前几项。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="83ec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">返回给我们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="25d8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Elixir中列表上的操作符总是返回一个新列表。也就是说，它们不修改现有的列表，Elixir中的数据结构是不可变的。</p><p id="3596" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以通过一个叫做head和tail的函数来访问第一个元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="bce0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们将看到如何做同样的事情，但模式匹配。这是一个我喜欢的解决方案，它让我可以更有效地使用Elixir。是天才，和JS重组很像。</p><h2 id="a4d6" class="mv ls it bd lt mw mx dn lx my mz dp mb le na nb md li nc nd mf lm ne nf mh ng bi translated">元组</h2><p id="1086" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">元组是类似列表的结构。然而，它们在内存中是连续存储的，所以比列表快得多。<code class="fe mr ms mt mu b">put_elem/3</code>函数返回一个新的元组，在给定的位置有一个新元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="e594" class="mv ls it bd lt mw mx dn lx my mz dp mb le na nb md li nc nd mf lm ne nf mh ng bi translated">更多运算符和布尔值</h2><p id="dd0c" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">使用<code class="fe mr ms mt mu b">and</code>和<code class="fe mr ms mt mu b">or</code>的操作是严格的。也就是说，它们只计算布尔值。然而，<code class="fe mr ms mt mu b">&amp;&amp;</code>和<code class="fe mr ms mt mu b">||</code>评估完整的表达式。让我们看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="1ddd" class="mv ls it bd lt mw mx dn lx my mz dp mb le na nb md li nc nd mf lm ne nf mh ng bi translated">&amp;&amp; y ||</h2><p id="ca35" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">用于真值和假值</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="ebdc" class="mv ls it bd lt mw mx dn lx my mz dp mb le na nb md li nc nd mf lm ne nf mh ng bi translated">不</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="2025" class="mv ls it bd lt mw mx dn lx my mz dp mb le na nb md li nc nd mf lm ne nf mh ng bi translated">比较</h2><p id="66c6" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">在Elixir中，我们可以使用<code class="fe mr ms mt mu b">&lt;</code>和<code class="fe mr ms mt mu b">&gt;</code>操作符来比较不同类型的数据。这样做的原因纯粹是实用主义的，所以Elixir的内部算法在排序时并不关心不同类型的数据。顺序如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4bac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在下一期文章中，我们将讨论模式匹配，这是Elixir的一个很酷的工具。</p><p id="892e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">干杯。</p><h1 id="df14" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">重要参考</h1><div class="nh ni gp gr nj nk"><a href="https://elixir-lang.org/getting-started/basic-operators.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">基本运算符</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">从上一章开始，我们看到Elixir提供了+、-、*、/作为算术运算符，加上函数…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">elixir-lang.org</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ko nk"/></div></div></a></div></div></div>    
</body>
</html>