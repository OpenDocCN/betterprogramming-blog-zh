<html>
<head>
<title>Time to Split Your Monorepo? Our Take on Structuring Web3 Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是时候拆分你的Monorepo了？我们对构建Web3项目的看法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/time-to-split-your-monorepo-our-take-on-structuring-web3-project-5ad93be1cf9f?source=collection_archive---------14-----------------------#2022-04-25">https://betterprogramming.pub/time-to-split-your-monorepo-our-take-on-structuring-web3-project-5ad93be1cf9f?source=collection_archive---------14-----------------------#2022-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abfb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们为什么拆分我们的单一回购协议，以及我们如何处理智能合约</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96555c6a7d36455f7600336df2c53706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mb0fUoK2Q1iBhj0FZ5_J6Q.png"/></div></div></figure><p id="e3d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我认为把所有代码放在一个地方是完全没问题的，尤其是在项目开始的时候。把事情做好。不要过度复杂化。然而，最终，事情变得复杂了。处理智能合同很棘手，因为一旦部署，它们就在那里，更新并不总是容易的。此外，您的dApp的其他部分需要一个契约代码来与它们进行交互。本文将展示我们在<a class="ae lq" href="https://feltlabs.ai/" rel="noopener ugc nofollow" target="_blank"> FELToken </a>中使用的代码结构，这将有望使事情变得可扩展和易于维护。</p><h1 id="717a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">主要组件</h1><p id="d72d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">每个dApp通常由两个主要组件组成:智能合约和一个与它们通信的web应用程序。通常，额外的库也与智能合约通信。要与智能合约交互，您总是需要合约的地址和ABI。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/d1a450a1fa5696b1e57bd8b6aa604ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*IJBUh7rWxTwE4U9FYG9onQ.png"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">大多数Web3应用程序的依赖结构。</p></figure><p id="b426" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">依赖结构并不复杂。所有组件都依赖于存储部署地址和合同ABI的智能合同。</p><h1 id="7f19" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">为什么不是Monorepo？</h1><p id="9a75" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">看看上面的结构，很明显，如果我们拆分组件，我们将不得不处理必要文件的交换。那么我们为什么要把东西分开呢？既然我们可以把所有东西都放在一个地方，为什么还要经历这种额外的挣扎呢？</p><p id="650c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">反对monorepo的最大理由可能是版本控制。如果我们更新一个组件，我们通常也必须更新其他部分。我们要么必须总是一次进行大的更新，要么习惯于我们的主分支经常出问题的事实。当越来越多的人开始贡献时，这就成了一个问题，因为我们需要一个用于测试的工作项目。</p><p id="177d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，不同的组件通常有不同的版本周期，例如，智能合同通常不会像web应用程序一样经历那么多的更新。把所有东西都放在一个地方会很难区分这些更新。</p><p id="6055" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将代码分割成多个存储库，我们可以确保在每个开发点都能正常工作。此外，我们可以使用git标签在存储库之间引用正确的版本。例如，当我们更新智能合同时，web应用程序仍然可以引用旧版本，直到它被更新。这种方法确保更多的人可以同时工作，而不会损坏东西。</p><h1 id="22fa" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">如何兑换智能合约ABI？</h1><p id="c511" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们使用<a class="ae lq" href="https://eth-brownie.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">布朗尼</strong> </a>来处理智能合同部署。我们还决定使用GitHub来交换智能合同的文件(地址和ABI)。很容易创建GitHub action，它将自动部署智能合约并将必要的文件存储在GitHub repo中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="668f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后在web应用程序中，我们可以基于标签从GitHub中<code class="fe mv mw mx my b">fetch</code>获取必要的文件。超级简单对吧？嗯，还有最后一个棘手的部分:地方发展。</p><h2 id="531b" class="mz ls it bd lt na nb dn lx nc nd dp mb ld ne nf md lh ng nh mf ll ni nj mh nk bi translated">地方发展解决方案</h2><p id="62aa" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">运行本地加纳切区块链是Web3开发的日常面包。同时运行智能合约和web应用程序是不可避免的。我们需要确保不会因为将代码分成多个存储库而使这变得复杂。</p><p id="a430" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们决定使用本地文件服务器来解决这个问题。这听起来可能有点过分，但它很好地解决了所有问题。因此，在部署脚本的最后，我们运行一个文件服务器。在Python中运行文件服务器很简单，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bc03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后在部署脚本的最后，我们需要运行<code class="fe mv mw mx my b">server_build_directory()</code>。确保在绝对端运行该函数，因为它会阻止执行。你可以在这里阅读我们的完整部署脚本:<code class="fe mv mw mx my b"><a class="ae lq" href="https://github.com/FELToken/smart-contracts/blob/e9c49f151d9d80eebbc6d35a875bd1eaaffdf1c5/scripts/deploy_dev.py" rel="noopener ugc nofollow" target="_blank">deploy_dev.py</a></code>。一旦服务器开始运行，我们可以像从GitHub获取文件一样获取文件。我们只需要用<code class="fe mv mw mx my b">http://localhost:8100</code>替换GitHub URL。文件的结构保持不变！</p><p id="9895" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法的优点是Brownie会自动清除本地开发文件。因此，我们不会将任何本地文件提交到git中。</p><h1 id="6b8f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="35e1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们的方法不是唯一正确的方法。我看到人们使用不同的策略来存储智能合约，例如，将它们保存为NPM包。然后使用NPM将这个包安装到一个web应用程序中。只要您的所有组件都使用JavaScript，这就非常简单。问题是我们有JavaScript和Python库与智能契约通信，这使得特定于语言的解决方案不切实际。</p><p id="3301" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nl">如果你觉得这有帮助，别忘了关注更多教程。我写了我们在整个</em><a class="ae lq" href="https://twitter.com/FELT_labs" rel="noopener ugc nofollow" target="_blank"><em class="nl">@ FELT _ labs</em></a><em class="nl">项目开发过程中的web3体验，创造了一个保护隐私的AI解决方案。</em></p></div></div>    
</body>
</html>